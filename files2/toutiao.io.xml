<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>5c55e7d84a6dcfb9bcbb867a999bf1a7</guid>
<title>架构师三大难：领域划分问题</title>
<link>https://toutiao.io/k/q25g5er</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485868&amp;amp;idx=1&amp;amp;sn=843459f44e37003814c7a9b44bf721ec&amp;amp;chksm=fafde302cd8a6a142123716eef9228df519285d9d1b94b6a135fb701adf8cf826a570298f497&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《架构师之路-redis集群解析》&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《架构师之路-redis集群解析》&lt;/a&gt;提到：提出有水平的问题、做出有水平的总结和建议、做出有水平的回答 是架构师面临的三大难。&lt;/p&gt;&lt;p&gt;天天开会，最怕开会。开会十分钟，准备半天功。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100002243&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/2tk5ianItRl99HCEakE1XJbqGpiahvANc79ialFqN3Y5NJicf1ibFhIt1DUnE9XOsUb5RgxGYkQAq3WjV0LqI3cicXYQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;350&quot;/&gt;&lt;/p&gt;&lt;p&gt;下面是围绕这三大难展开的故事。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;情景-领域划分问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;几年前的一天，在一个会上，完全不相关的团队人员在进行我们系统的架构评审。由于他们对我的系统不了解，提的问题多是针对架构师个人能力上的。&lt;/p&gt;&lt;p&gt;我在介绍的时候提到：“根据系统的特点，按照角色划分领域的同时结合现有人员情况划分了下面几个应用……”，然后我被打断了，有人提问说：“应用是按领域划分还是按照人员划分？”&lt;/p&gt;&lt;p&gt;针对这种埋坑的问题，选项有A和B，那更合理的答案一般是C。&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100002241&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRl99HCEakE1XJbqGpiahvANc7wE8IfibQA259iaH3b1FSx597gAuoxUV8wOiax0Y1b1HHu82RVBc3Y3a6Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;450&quot;/&gt;&lt;/p&gt;&lt;p&gt;翻译提问者的问题其实是在问：“不是都是用领域划分领域吗？按照人员划分的方法不对吧？”&lt;/p&gt;&lt;p&gt;先来分析一下，我顺着提问者的话说会怎样：“模块需要按照领域划分，模块是分层级的。人员划分决定的是独立部署单位的粒度，在实际项目中应该综合考虑。”&lt;/p&gt;&lt;p&gt;这样虽然回答了提问者的问题，但是提问者很显然有知识上的盲区，需要我给他解惑的地方：“究竟要怎样划分应用？”而我的回答没有给出他完整的答案，他会继续找一些回答的漏洞来细化问题，比如：“资源预算不算做考虑粒度的因素吗？” 假定我每次顺着他的思路来，整个回答过程就没有清晰的结构了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100002242&quot; data-ratio=&quot;0.9815195071868583&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl99HCEakE1XJbqGpiahvANc7hyrJhK8kLNiccfJx36iadeowdaTmszgutYvlKCWTguwhpt7VugrxwtLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;487&quot;/&gt;&lt;/p&gt;&lt;p&gt;所以我需要直接针对他本质的问题展开回答，以下是回答内容：&lt;/p&gt;&lt;p&gt;在这次介绍的系统中，最主要的依据是按照领域来划分模块，同时根据资源和人员等情况来决定独立部署的应用模块的粒度。&lt;/p&gt;&lt;p&gt;但是在其他的系统中，根据不同的系统特点，模块或者应用的划分上，考虑侧重点会有所不同。我举几个例子。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;示例一(管道过滤器模式)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;比如工作流类的系统，从总体架构上采用的是管道过滤器模式&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.190625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fEsWkVrSk56VOicS57DLZOX5s8iby5iarBoXiazJ1k7libMTgEib1NgAeCcWrzqhzYUxVXwMmticlBcjXic5rXz8rcXibuA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上图，在这种系统中主要有两种角色，一种是管理者角色，负责把其他模块组织串联起来，整体对外提供服务。记得之前做个这样的项目，管理者角色的模块系统名叫captain（当时大家都以漫威英雄人物命名，captain对应美国队长）。其他模块都是一个个过滤器。是否要将每个过滤器独立应用部署，还是主要根据人力和资源来定。只要设计清晰，将来人力和资源有调整，或者随着业务的发展，对稳定性有个更好的要求，可能会需要根据可用性做一个隔离。高SLA和低SLA的单独部署，高SLA的多地区多机房部署。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例二(三平面分离模式)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;比如三平面分离架构系统，详情可参考我之前的文章&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485742&amp;amp;idx=1&amp;amp;sn=b3fa976a6bc5ec30c3f4b7b93d60711f&amp;amp;chksm=fafde380cd8a6a968c2b8204ec1e5ebd48625b2ba51714f581d358007d69ba0e2e80223434ba&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《三平面分离架构》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《三平面分离架构》&lt;/a&gt;。简单来说分成最核心的流程控制平面、次核心的组件支撑平面和SLA只要求两个9的管理运维平面。如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.43274244004171014&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9CmJJia6SPKn3aiat9bnl33qic0t3amOJPEs8W0qUkN1Pzkib3juW3ZbkHwibtMFeibvw6X7mOQr2klIGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;959&quot;/&gt;&lt;/p&gt;&lt;p&gt;所以领域划分时这三个平面要边界分明，三个平面可用性级别不同，资源分配也不同。比如最核心的流程控制平台日志存储要90天，其他可能需要30天；流程控制平面可能需每笔请求开始和结束打日志，而其他服务只需要异常时打日志；流程控制平面和组件支撑平面需要四地八中心高可用部署，而管理运维平台只需要两机房容灾。所以核心是要将三个平面分开以分配不同的资源。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例三(异步处理模式)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;有些应用整体是实现一个大职责，但是被中间件分成了两个部分。比如有个服务是异步处理模式。所谓异步处理模式是将一个执行耗时长的流程分成两个阶段。比如退款操作。用户提交一个退款请求，先会收到一个实时通知：“您的退款请求已经收到，退款会于1~2个工作日内到账。”之后系统会将这个退款请求扔到MQ中，慢慢来消费处理。&lt;/p&gt;&lt;p&gt;这种模式的服务，根据实际资源等情况可以分成两个独立部署的系统，或者合在一个应用里既作为MQ的生产者又作为MQ的消费者。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6078125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fEsWkVrSk56VOicS57DLZOX5s8iby5iarBoFsr3nIKUVKRZgdiaQib3Y3Y0G9BKwh0opBib5Vb25B2YN4RosD3icujTEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;如果观察到别人总是就细节进行追问，这时候可以先把思路跳出来弄清楚他的本质问题是什么。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485029&amp;amp;idx=1&amp;amp;sn=81b593816669318ee3203449177f90c9&amp;amp;chksm=fafdeccbcd8a65dd8a1116dd4eee9e9de9c4c8833e64854422d0a8bc57d28d83d8d57e1e936d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;分布式存储系统的一致性-可见性差异&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;分布式存储系统的一致性-可见性差异&lt;/a&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4edd9ba10ccb61b3cc690690f6cd15be</guid>
<title>@Import 注解：导入配置类的四种方式 &amp; 源码解析</title>
<link>https://toutiao.io/k/dd73o71</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4255555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hXEWOsco2BX1GUrLia73kRWicgUaNia6RTha47Yv20nriaNsDPGAicJ9kibdB3iaTnvaOfXVFeibgGkrTM5NkmiamhzucMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;微信搜索：码农StayUp&lt;/p&gt;&lt;p&gt;主页地址：https://gozhuyinglong.github.io&lt;/p&gt;&lt;p&gt;源码分享：https://github.com/gozhuyinglong/blog-demos&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;平时喜欢看源码的小伙伴，应该知道Spring中大量使用了&lt;code&gt;@Import&lt;/code&gt;注解。该注解是Spring用来导入配置类的，等价于&lt;code&gt;Spring XML&lt;/code&gt;中的&lt;code&gt;&amp;lt;import/&amp;gt;&lt;/code&gt;元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文将对该注解进行介绍，并通过实例演示它导入配置类的四种方式，最后对该注解进行源码解析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;话不多说，走起~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;简介&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;@Import&lt;/code&gt;注解的全类名是&lt;code&gt;org.springframework.context.annotation.Import&lt;/code&gt;。其只有一个默认的&lt;code&gt;value&lt;/code&gt;属性，该属性类型为&lt;code&gt;Class&amp;lt;?&amp;gt;[]&lt;/code&gt;，表示可以传入一个或多个&lt;code&gt;Class&lt;/code&gt;对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过注释可以看出，该注解有如下作用：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可以导入一个或多个组件类（通常是&lt;code&gt;@Configuration&lt;/code&gt;配置类）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;该注解的功能与&lt;code&gt;Spring XML&lt;/code&gt;中的&lt;code&gt;&amp;lt;import/&amp;gt;&lt;/code&gt;元素相同。可以导入&lt;code&gt;@Configuration&lt;/code&gt;配置类、&lt;code&gt;ImportSelect&lt;/code&gt;和&lt;code&gt;ImportBeanDefinitionRegistrar&lt;/code&gt;的实现类。从4.2版本开始，还可以引用常规组件类（普通类），该功能类似于&lt;code&gt;AnnotationConfigApplicationContext.register&lt;/code&gt;方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;该注解可以在类中声明，也可以在元注解中声明。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果需要导入&lt;code&gt;XML&lt;/code&gt;或其他非&lt;code&gt;@Configuration&lt;/code&gt;定义的资源，可以使用&lt;code&gt;@ImportResource&lt;/code&gt;注释。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;导入配置类的四种方式&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码注释写得很清楚，该注解有四种导入方式：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;普通类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;@Configuration&lt;/code&gt;配置类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ImportSelector&lt;/code&gt;的实现类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ImportBeanDefinitionRegistrar&lt;/code&gt;的实现类&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们逐个来介绍~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;准备工作&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建四个配置类：ConfigA、ConfigB、ConfigC、ConfigD。其中ConfigB中增加&lt;code&gt;@Configuration&lt;/code&gt;注解，表示为配置类，其余三个均为普通类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ConfigA：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ConfigA&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;输出：ConfigA.class&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ConfigB：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ConfigB&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;输出：ConfigB.class&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ConfigC：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ConfigC&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;输出：ConfigC.class&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ConfigD：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ConfigD&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;输出：ConfigD.class&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再创建一个主配置类Config，并试图通过&lt;code&gt;@Resource&lt;/code&gt;注解将上面四个配置类进行注入。当然，这样是不成功的，还需要将它们进行导入。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Config&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    ConfigA configA;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    ConfigB configB;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    ConfigC configC;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    ConfigD configD;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        configA.print();&lt;br/&gt;        configB.print();&lt;br/&gt;        configC.print();&lt;br/&gt;        configD.print();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方式一：导入普通类&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;导入普通类非常简单，只需在&lt;code&gt;@Import&lt;/code&gt;传入类的&lt;code&gt;Class&lt;/code&gt;对象即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;(ConfigA&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Config&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方式二：导入&lt;code&gt;@Configuration&lt;/code&gt;配置类&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;导入配置类与导入普通类一样，在&lt;code&gt;@Import&lt;/code&gt;注解中传入目标类的&lt;code&gt;Class&lt;/code&gt;对象。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;({ConfigA&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;ConfigB&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Config&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方式三：导入&lt;code&gt;ImportSelector&lt;/code&gt;的实现类&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ImportSelector&lt;/code&gt;接口的全类名为&lt;code&gt;org.springframework.context.annotationImportSelector&lt;/code&gt;。其主要作用的是收集需要导入的配置类，并根据条件来确定哪些配置类需要被导入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该接口的实现类同时还可以实现以下任意一个&lt;code&gt;Aware&lt;/code&gt;接口，它们各自的方法将在&lt;code&gt;selectImport&lt;/code&gt;之前被调用：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;EnvironmentAware&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;BeanFactoryAware&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;BeanClassLoaderAware&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ResourceLoaderAware&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，该接口实现类可以提供一个或多个具有以下形参类型的构造函数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Environment&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;BeanFactory&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ResourceLoader&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想要推迟导入配置类，直到处理完所有的&lt;code&gt;@Configuration&lt;/code&gt;。那么你可以使用&lt;code&gt;DeferredImportSelector&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们创建一个实现该接口的类 MyImportSelector。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下面示例：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;selectImports&lt;/code&gt;方法中，入参&lt;code&gt;AnnotationMetadata&lt;/code&gt;为主配置类 Config 的注解元数据。返回值为目标配置类 ConfigC 的全类名，这里是一个数组，表示可以导入多个配置类。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyImportSelector&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ImportSelector&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; String[] selectImports(AnnotationMetadata importingClassMetadata) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; String[]{&lt;span&gt;&quot;io.github.gozhuyinglong.importanalysis.config.ConfigC&quot;&lt;/span&gt;};&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在配置类 Config 中导入 MyImportSelector 类。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;({ConfigA&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;ConfigB&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;MyImportSelector&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Config&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方式四：导入&lt;code&gt;ImportBeanDefinitionRegistrar&lt;/code&gt;的实现类&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该接口的目的是有选择性的进行注册&lt;code&gt;Bean&lt;/code&gt;，注册时可以指定&lt;code&gt;Bean&lt;/code&gt;名称，并且可以定义bean的级别。其他功能与&lt;code&gt;ImportSelector&lt;/code&gt;类似，这里就不再赘述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面来看示例：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个实现 &lt;code&gt;ImportBeanDefinitionRegistrar&lt;/code&gt; 接口的类 MyImportBeanDefinitionRegistrar，并在 &lt;code&gt;registerBeanDefinitions&lt;/code&gt;方法中注册 configD 类。入参 &lt;code&gt;AnnotationMetadata&lt;/code&gt;为主配置类 Config 的注解元数据；&lt;code&gt;BeanDefinitionRegistry&lt;/code&gt;参数可以注册&lt;code&gt;Bean&lt;/code&gt;的定义信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyImportBeanDefinitionRegistrar&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ImportBeanDefinitionRegistrar&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;registerBeanDefinitions&lt;/span&gt;&lt;span&gt;(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        registry.registerBeanDefinition(&lt;span&gt;&quot;configD&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; RootBeanDefinition(ConfigD&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在配置类 Config 中导入 MyImportBeanDefinitionRegistrar 类。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;({ConfigA&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;ConfigB&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;MyImportSelector&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;MyImportBeanDefinitionRegistrar&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Config&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;测试结果&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个测试类 ImportDemo，看上面四个配置类是否被注入。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ImportDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        AnnotationConfigApplicationContext ctx = &lt;span&gt;new&lt;/span&gt; AnnotationConfigApplicationContext(Config&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        Config config = ctx.getBean(Config&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        config.print();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;输出：ConfigA.class&lt;br/&gt;输出：ConfigB.class&lt;br/&gt;输出：ConfigC.class&lt;br/&gt;输出：ConfigD.class&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过输出结果可以看出，这四个配置类被导入到主配置类中，并成功注入。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;源码解析&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ConfigurationClassParser&lt;/code&gt;类为Spring的工具类，主要用于分析配置类，并产生一组&lt;code&gt;ConfigurationClass&lt;/code&gt;对象（因为一个配置类中可能会通过&lt;code&gt;@Import&lt;/code&gt;注解来导入其它配置类）。也就是说，其会递归的处理所有配置类。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;doProcessConfigurationClass&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中的&lt;code&gt;doProcessConfigurationClass&lt;/code&gt;方法是处理所有配置类的过程，其按下面步骤来处理：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;@Component注解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@PropertySource注解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@ComponentScan注解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Import注解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@ImportResource注解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Bean注解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置类的接口上的默认方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置类的超类&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Nullable&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SourceClass &lt;span&gt;doProcessConfigurationClass&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;    ConfigurationClass configClass, SourceClass sourceClass, Predicate&amp;lt;String&amp;gt; filter)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (configClass.getMetadata().isAnnotated(Component&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getName&lt;/span&gt;())) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 1.首先会递归的处理所有成员类，即@Component注解&lt;/span&gt;&lt;br/&gt;        processMemberClasses(configClass, sourceClass, filter);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 2.处理所有@PropertySource注解&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(&lt;br/&gt;        sourceClass.getMetadata(), PropertySources&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;org&lt;/span&gt;.&lt;span&gt;springframework&lt;/span&gt;.&lt;span&gt;context&lt;/span&gt;.&lt;span&gt;annotation&lt;/span&gt;.&lt;span&gt;PropertySource&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;)) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.environment &lt;span&gt;instanceof&lt;/span&gt; ConfigurableEnvironment) {&lt;br/&gt;            processPropertySource(propertySource);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            logger.info(&lt;span&gt;&quot;Ignoring @PropertySource annotation on [&quot;&lt;/span&gt; + sourceClass.getMetadata().getClassName() +&lt;br/&gt;                        &lt;span&gt;&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 3.处理所有@ComponentScan注解&lt;/span&gt;&lt;br/&gt;    Set&amp;lt;AnnotationAttributes&amp;gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(&lt;br/&gt;        sourceClass.getMetadata(), ComponentScans&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;ComponentScan&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!componentScans.isEmpty() &amp;amp;&amp;amp;&lt;br/&gt;        !&lt;span&gt;this&lt;/span&gt;.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (AnnotationAttributes componentScan : componentScans) {&lt;br/&gt;            &lt;span&gt;// 配置类的注解为@ComponentScan-&amp;gt; 立即执行扫描&lt;/span&gt;&lt;br/&gt;            Set&amp;lt;BeanDefinitionHolder&amp;gt; scannedBeanDefinitions =&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());&lt;br/&gt;            &lt;span&gt;// 检查扫描过的BeanDefinition集合，看看是否有其他配置类，如果需要，递归解析&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (BeanDefinitionHolder holder : scannedBeanDefinitions) {&lt;br/&gt;                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (bdCand == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    bdCand = holder.getBeanDefinition();&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, &lt;span&gt;this&lt;/span&gt;.metadataReaderFactory)) {&lt;br/&gt;                    parse(bdCand.getBeanClassName(), holder.getBeanName());&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 4.处理所有@Import注解&lt;/span&gt;&lt;br/&gt;    processImports(configClass, sourceClass, getImports(sourceClass), filter, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 5.处理所有@ImportResource注解&lt;/span&gt;&lt;br/&gt;    AnnotationAttributes importResource =&lt;br/&gt;        AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (importResource != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        String[] resources = importResource.getStringArray(&lt;span&gt;&quot;locations&quot;&lt;/span&gt;);&lt;br/&gt;        Class&amp;lt;? extends BeanDefinitionReader&amp;gt; readerClass = importResource.getClass(&lt;span&gt;&quot;reader&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (String resource : resources) {&lt;br/&gt;            String resolvedResource = &lt;span&gt;this&lt;/span&gt;.environment.resolveRequiredPlaceholders(resource);&lt;br/&gt;            configClass.addImportedResource(resolvedResource, readerClass);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 6.处理标注为@Bean注解的方法&lt;/span&gt;&lt;br/&gt;    Set&amp;lt;MethodMetadata&amp;gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (MethodMetadata methodMetadata : beanMethods) {&lt;br/&gt;        configClass.addBeanMethod(&lt;span&gt;new&lt;/span&gt; BeanMethod(methodMetadata, configClass));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 7.处理配置类的接口上的默认方法&lt;/span&gt;&lt;br/&gt;    processInterfaces(configClass, sourceClass);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 8.处理配置类的超类（如果有的话）&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (sourceClass.getMetadata().hasSuperClass()) {&lt;br/&gt;        String superclass = sourceClass.getMetadata().getSuperClassName();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (superclass != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !superclass.startsWith(&lt;span&gt;&quot;java&quot;&lt;/span&gt;) &amp;amp;&amp;amp;&lt;br/&gt;            !&lt;span&gt;this&lt;/span&gt;.knownSuperclasses.containsKey(superclass)) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.knownSuperclasses.put(superclass, configClass);&lt;br/&gt;            &lt;span&gt;// Superclass found, return its annotation metadata and recurse&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; sourceClass.getSuperClass();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 处理完成&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;processImports&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;processImports&lt;/code&gt;方法为处理&lt;code&gt;@Import&lt;/code&gt;注解导入的配置类，是我们本篇的主题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法会循环处理每一个由@Import导入的类：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ImportSelector类的处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ImportBeanDefinitionRegistrar类的处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其它类统一按照@Configuration类来处理，所以加不加@Configuration注解都能被导入&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 处理配置类上的&lt;span&gt;@Import&lt;/span&gt;注解引入的类&lt;br/&gt; *&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; configClass 配置类，这里是Config类&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; currentSourceClass 当前资源类&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; importCandidates 该配置类中的&lt;span&gt;@Import&lt;/span&gt;注解导入的候选类列表&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; exclusionFilter 排除过滤器&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; checkForCircularImports 是否循环检查导入&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;processImports&lt;/span&gt;&lt;span&gt;(ConfigurationClass configClass, SourceClass currentSourceClass,&lt;br/&gt;                            Collection&amp;lt;SourceClass&amp;gt; importCandidates, Predicate&amp;lt;String&amp;gt; exclusionFilter,&lt;br/&gt;                            &lt;span&gt;boolean&lt;/span&gt; checkForCircularImports)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;// 如果该@Import注解导入的列表为空，直接返回&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (importCandidates.isEmpty()) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt; &lt;span&gt;// 循环检查导入&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (checkForCircularImports &amp;amp;&amp;amp; isChainedImportOnStack(configClass)) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.problemReporter.error(&lt;span&gt;new&lt;/span&gt; CircularImportProblem(configClass, &lt;span&gt;this&lt;/span&gt;.importStack));&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.importStack.push(configClass);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 循环处理每一个由@Import导入的类&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (SourceClass candidate : importCandidates) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (candidate.isAssignable(ImportSelector&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)) &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;// 1. ImportSelector类的处理&lt;/span&gt;&lt;br/&gt;                    Class&amp;lt;?&amp;gt; candidateClass = candidate.loadClass();&lt;br/&gt;                    ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;br/&gt;                                                                                   &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;environment&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;resourceLoader&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;registry&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;                    Predicate&amp;lt;String&amp;gt; selectorFilter = selector.getExclusionFilter();&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (selectorFilter != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                        exclusionFilter = exclusionFilter.or(selectorFilter);&lt;br/&gt;                    }&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (selector &lt;span&gt;instanceof&lt;/span&gt; DeferredImportSelector) {&lt;br/&gt;                        &lt;span&gt;// 1.1 若是DeferredImportSelector接口的实现，则延时处理&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;this&lt;/span&gt;.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);&lt;br/&gt;                    }&lt;br/&gt;                    &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;// 1.2 在这里调用我们的ImportSelector实现类的selectImports方法&lt;/span&gt;&lt;br/&gt;                        String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());&lt;br/&gt;                        Collection&amp;lt;SourceClass&amp;gt; importSourceClasses = asSourceClasses(importClassNames, exclusionFilter);&lt;br/&gt;                        &lt;span&gt;// 1.3 递归处理每一个selectImports方法返回的配置类&lt;/span&gt;&lt;br/&gt;                        processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (candidate.isAssignable(ImportBeanDefinitionRegistrar&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)) &lt;/span&gt;{&lt;br/&gt;                     &lt;span&gt;// 2. ImportBeanDefinitionRegistrar类的处理&lt;/span&gt;&lt;br/&gt;                    Class&amp;lt;?&amp;gt; candidateClass = candidate.loadClass();&lt;br/&gt;                    ImportBeanDefinitionRegistrar registrar =&lt;br/&gt;                        ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;br/&gt;                                                             &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;environment&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;resourceLoader&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;registry&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;                    configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;// 3. 其它类统一按照@Configuration类来处理，所以加不加@Configuration注解都能被导入&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;this&lt;/span&gt;.importStack.registerImport(&lt;br/&gt;                        currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());&lt;br/&gt;                    processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;catch&lt;/span&gt; (BeanDefinitionStoreException ex) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; ex;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;catch&lt;/span&gt; (Throwable ex) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BeanDefinitionStoreException(&lt;br/&gt;                &lt;span&gt;&quot;Failed to process import candidates for configuration class [&quot;&lt;/span&gt; +&lt;br/&gt;                configClass.getMetadata().getClassName() + &lt;span&gt;&quot;]&quot;&lt;/span&gt;, ex);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.importStack.pop();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面源码的解析可以看出，&lt;code&gt;@Import&lt;/code&gt;注解主要作用是导入外部类的，并且普通类也会按照&lt;code&gt;@Configuration&lt;/code&gt;类来处理。这大大方便了我们将自己的组件类注入到容器中了（无需修改自己的组件类）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;源码分享&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整代码请访问我的Github，若对你有帮助，欢迎给个⭐，感谢~~🌹🌹🌹&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/gozhuyinglong/blog-demos/tree/main/spring-source-analysis/src/main/java/io/github/gozhuyinglong/importanalysis&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;往期推荐&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关于作者&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;项目&lt;/th&gt;&lt;th&gt;内容&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;公众号&lt;/td&gt;&lt;td&gt;码农StayUp（ID：AcmenStayUp）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;主页&lt;/td&gt;&lt;td&gt;https://gozhuyinglong.github.io&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CSDN&lt;/td&gt;&lt;td&gt;https://blog.csdn.net/gozhuyinglong&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;掘进&lt;/td&gt;&lt;td&gt;https://juejin.cn/user/1239904849494856&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Github&lt;/td&gt;&lt;td&gt;https://github.com/gozhuyinglong&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Gitee&lt;/td&gt;&lt;td&gt;https://gitee.com/gozhuyinglong&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6933333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/hXEWOsco2BX1GUrLia73kRWicgUaNia6RThGmC9HQU3icLhIHLjTH5V8x2tzeSjMgMhYd6lJGbBpTyvTMnuBRI3nDg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;750&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fe80de2d3c36b3da972847431267af86</guid>
<title>别被你的框架框住了</title>
<link>https://toutiao.io/k/eippx4u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;main class=&quot;post-styles_main__2vaxQ&quot;&gt;&lt;p class=&quot;zh-cn&quot;&gt;我短暂的职业生涯被 React 充斥着。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;还没毕业前我从 Vue 2.x 入手开始学习框架，在一个我当时觉得还行现在回看完全不行的状态进了公司。然后开启了跟 React 死磕的状态，从 class 组件到函数式组件，从 Redux 到 Recoil，从 Antd 到 MUI...&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;不久前一个呆了2年多的项目成功结束，接下来要去一个新项目，新项目要用 Angular，于是我开始告别从毕业就开始用的 React，开始学习这个大家少有提及的框架。&lt;/p&gt;
&lt;h2 id=&quot;得&quot;&gt;得&lt;/h2&gt;
&lt;p class=&quot;zh-cn&quot;&gt;回顾这几年，要说 React 带给我最多的是什么，我觉得可能是思想，是一种编程范式。为了理解 React 新的函数式组件，我去学习 FP，但我并不是一个原教旨主义者，所以我当然也不认同你想学 FP 就得去学 Lisp 的说法。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;在这期间我发现&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS&quot;&gt;小黄书&lt;/a&gt;的作者 &lt;a href=&quot;https://www.linkedin.com/in/getify&quot;&gt;Kyle Simpson&lt;/a&gt; 也写了一本专门为 JSer 介绍 FP 的&lt;a href=&quot;https://github.com/getify/Functional-Light-JS&quot;&gt;书&lt;/a&gt;，书中前言部分我深以为然：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p class=&quot;zh-cn&quot;&gt;The way I see it, functional programming is at its heart about using patterns in your code that are well-known, understandable, &lt;em&gt;and&lt;/em&gt; proven to keep away the mistakes that make code harder to understand.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;zh-cn&quot;&gt;是的，编程范式的作用是为了让人们更好地组织和理解代码，编程范式应该去服务写代码的人，而不是人去事无巨细地遵循编程范式的每一个规则，理解每一个晦涩难懂的概念。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p class=&quot;zh-cn&quot;&gt;I believe that programming is fundamentally about humans, not about code. I believe that code is first and foremost a means of human communication, and only as a &lt;em&gt;side effect&lt;/em&gt; (hear my self-referential chuckle) does it instruct the computer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;zh-cn&quot;&gt;敏捷需要以人为本，写代码其实也一样。我们要做的应该是理解编程范式本身以及它背后的作用，或许在未来的某天你会突然发现，原来我用了这么久的这个玩意儿有一个这么有意思的名字，亦或者你可能永远也解释不清楚那个概念到底是什么：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;em&gt;A monad is just a monoid in the category of endofunctors.&lt;/em&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;em&gt;一个单子不过是自函子范畴上的幺半群&lt;/em&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;zh-cn&quot;&gt;那是不是搞不懂我就不能玩 FP 了？然后我就得站在鄙视链底端，被 Haskell、Lisp 玩家们指着鼻子嘲笑：你们看那家伙，其实啥也不懂，他那也叫 FP？&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这个问题我没有答案，或许可以留给大家来讨论。但是到这里我至少明白了 React Hooks 为什么要叫 &quot;hook&quot;；为什么有一个 hook 叫 &quot;useEffect&quot;；我也理解了为什么大家都说不要用 hook 去实现 class 组件的生命周期。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;除了写好 React 本身，我也尝试了纯函数、偏函数、柯里化、组合和 Point-free 风格的代码，确实得到了一些好处，也确实带来了一些不便。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;可能这些思想就是学习 React 带给我最大的 side effect 吧（笑。&lt;/p&gt;
&lt;h2 id=&quot;失&quot;&gt;失&lt;/h2&gt;
&lt;p class=&quot;zh-cn&quot;&gt;与 React 准备 all in FP 相反的是，与 Angular 短暂接触的我发现它全面拥抱 OOP。与当时 React 从 class 组件切换到函数式组件一样，首先你得把编程范式思想完全转变过来才能很好地理解 Angular。这又促使我不得不去复习许多被我丢弃很久的 OOP 思想。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;到这我不禁想起一次公司内 TDD 训练营，作业完成后去找 coach 讲解，讲解过程中 coach 讲到了抽象能力、隔离层、防腐层。那时我才发现自己 OO 的抽象能力和一起的后端小伙伴一比实在是差到不行，只有大学时候的能力。反思过后像是被 React 给“惯”坏了，几乎已经丢掉了这部分能力。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;老实说我接触 React class 组件时间并不长，第一个项目只有短短几个月。后面两个项目虽然去写 Java 了，但是第一个都是一些修修补补的工作，更像是在做 DevOps，后来的项目去写 Java BFF，毫无抽象可言，全是数据 mapping。然后又进到了一个将“追求技术卓越”贯彻执行的项目，成了那批最早吃函数式组件螃蟹的人。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;于是我接触 class 组件的时间就只有作为毕业生的那短短几个月而已。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;然后当我看到 Angular 文档中的依赖注入时，我脑子只能零星蹦出一些概念：SOLID、解耦。别说细节，我甚至不知道我蹦出来的这些东西是不是对的。于是我又只能凭着自己的记忆去邮件里搜相关的博客大赛的文章。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;我好像已经丢掉了 OOP 了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p class=&quot;zh-cn&quot;&gt;种下一棵树最好的时间是十年前，其次是现在。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;悟&quot;&gt;悟&lt;/h2&gt;
&lt;p class=&quot;zh-cn&quot;&gt;跳出all in FP 的 React 我发现世界不是非黑即白的。说是全面拥抱 OOP，但其实你可以很轻易的在 Angular 中发现 FP 的影子 -- 用 pipe 来处理数据，用 Rx 来处理请求。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;既然是以人为本，编程范式本就&lt;strong&gt;不应该对立&lt;/strong&gt;，它们明明可以互补，在自己擅长的领域处理自己擅长的事情，哪怕是同一个项目。看惯了两个阵营吵架的场景，好像这样的场景才是我想要的。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;于是我又回忆起某天在项目上和大家讨论的项目分包问题，最后的结论是 OOP 的以对象和 domain 分包的策略在大多数时候要优于单纯的 FP 的方式。它能让功能更集中，让大家更容易找到自己想要找的东西。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;但是回过头来静静思考，我虽然会好好学习 OOP，但是我目前大概率不会去深入学习相关的建模方法。因为在目前我的工作环境下，我没看到有前端同学需要深刻理解建模方法的场景，大多数情况浅尝辄止即可。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;以我自身的经历来看，DDD 我看过也参加过培训，也跟着项目后端小伙伴在搭建项目时从零到一实践过。但是在实践不多的情况下，整个过程逃脱不了学了忘忘了学的魔咒。大概唯一的用处就是当我被抓到后端去干活能看懂他们为什么要这么组织代码，至于建模的那个过程，被抓去干活的我是大概率不会参与的。（当然如果你有相关的经历还请喷醒我，比如你作为偏前端的小伙伴就是要熟练掌握建模方法，不然工作就做不下去了）&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;不要被技术栈限制住了自己，其实以前一直对这句话一知半解，虽然可能现在的理解也没有很强。可是当你从一个框里跳出来以后，去思考画框这个人的想法，你可能能够得到一些不一样的思考。对于 Thoughtworker 来说学习一个新框架，一门新语言可能不是什么问题，那我们是不是可以更进一步，想想那些看起来“虚无缥缈”的东西呢。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;别被你的框架框住你了。&lt;/p&gt;
&lt;/main&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b0b6b86fa0f5b2a2917377573742f79b</guid>
<title>C/C++ 为什么要专门设计个 do…while？</title>
<link>https://toutiao.io/k/n0wpt8l</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最初&lt;code&gt;do ... while&lt;/code&gt;的出现，更多的是作为循环控制流的一种语法糖。因为不论是while 还是 for循环，都是要先判断是否满足进入循环体的条件的。满足条件之后才能进入循环去执行循环体内的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而有些时候，第一次的执行逻辑我们不需要满足循环条件，也要执行。这时候就可以用&lt;code&gt;do ... while&lt;/code&gt;。举个例子，前几天的LeetCode每日一题 &lt;code&gt;869. 重新排序得到2的幂&lt;/code&gt;，刚好遇到这么一个场景：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;https://leetcode-cn.com/problems/reordered-power-of-2/&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解题偷懒的话，可以直接用STL的排列相关的函数next_permutation来解答：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;reorderedPowerOf2&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;auto&lt;/span&gt; check = [](&lt;span&gt;int&lt;/span&gt; n) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; (n&amp;amp;(n&lt;span&gt;-1&lt;/span&gt;)) == &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        };&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;string&lt;/span&gt; s = to_string(n);&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; len = s.size();&lt;br/&gt;        sort(s.begin(), s.end());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (s[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;&#x27;0&#x27;&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (check(stoi(s))) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;while&lt;/span&gt; (next_permutation(s.begin(), s.end()));&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本题，在我们将字符串&lt;code&gt;sort()&lt;/code&gt;以后，变成了字典升序，然后每次通过调用&lt;code&gt;next_permutation()&lt;/code&gt; 修改字符串s，变成其中字母的下一个排列。当不存在下一个排列的时候（字符串已经变成字典序逆序），返回false。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一开始进来的时候不能&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        &lt;span&gt;while&lt;/span&gt; (next_permutaion(s.begin(), s.end()) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (s[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;&#x27;0&#x27;&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (check(stoi(s))) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为这样会导致sort完成的那个s（升序）没有参与到check的计算，造成遗漏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不能&lt;code&gt;do ... while&lt;/code&gt;就只能这样写：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        sort(s.begin(), s.end());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (s[&lt;span&gt;0&lt;/span&gt;] != &lt;span&gt;&#x27;0&#x27;&lt;/span&gt; &amp;amp;&amp;amp; check(stoi(s))) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (next_permutation(s.begin(), s.end())) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (s[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;&#x27;0&#x27;&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (check(stoi(s))) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在while执行之前做一次check计算，然后才进入while。逻辑上当然没问题，只是造成了代码冗余。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这是do ... while最初的用法，后面程序员们集思广益，又利用do ... while的特性发明了独特了 do ... while(0)的特殊使用场景&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;do ... while(0) 搭配宏函数的定义&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C和C++语言中有宏的概念，而Java没有，所以这个条款对Java程序员没有用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在C/C++中，有时候我们可能用宏来定义“函数”。我们都知道其本质还是宏，而非函数。所以其实还是在编译预处理阶段进行代码文本的暴力替换！而如果你定义的宏函数中的代码，被插入的位置，附近有括号或分号，有时候常常不能如你所愿的编译运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;而do ... while(0)构造的代码块则不会受到大括号、分号等的影响。不管你把你的宏函数放到任何地方都不会出错。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如Redis源码中就有大量的这种用法，下面这段出自zmalloc的源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; update_zmalloc_stat_alloc(__n) do { \&lt;br/&gt;    size_t _n = (__n); \&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (_n&amp;amp;(sizeof(long)-1)) _n += sizeof(long)-(_n&amp;amp;(sizeof(long)-1)); \&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (zmalloc_thread_safe) { \&lt;br/&gt;        update_zmalloc_stat_add(_n); \&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; { \&lt;br/&gt;        used_memory += _n; \&lt;br/&gt;    } \&lt;br/&gt;} while(0)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;do ... while(0) 中断顺序执行的逻辑&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个条款适用于C、C++、Java等有&lt;code&gt;do ... while&lt;/code&gt;用法的语言。由于Java中int和bool不能转换，所以在Java中是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;} &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面言归正传，关于这个用法，其实我在之前这篇文章的条款7也介绍过了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDIyMjI3OQ==&amp;amp;mid=2649004091&amp;amp;idx=1&amp;amp;sn=47b2a52d314ef7d83d0350134d082e59&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hQZ4NEZ2sic4EJTcpzKx6Djia6NqvibMPnVicmf7qVbUxrD7rT1JO3gpshG6PFfuNdhHhkx9wbibDCqGC1mNoAKDibew/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;figcaption&gt;C++代码简化之道（一）&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;概括一下，函数（或方法）中一段顺序逻辑，依次经历1，2，3三个步骤，然后是其他逻辑（比如 4， 5）。其中1，如果失败就不执行2，2如果失败不执行3。就是逻辑中断之后直接跳到4和5。容易想到的实现思路有三：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;把步骤1， 2，3抽象成函数。每次判断函数的返回值，成功才调用下一个函数。OK。这样没问题。但是如果这种类似的逻辑很多，就要抽成很多个函数，而每个函数内只有寥寥几行代码。未免啰嗦。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用异常。如果是Java语言应该很习惯用异常来实现这个逻辑，把顺序逻辑封在try catch块里。每个步骤失败直接throw异常。OK，C++也可以写类似的代码。然而C++用异常隐患很多，不如Java安全，很多工程规范都竭力避免抛异常。另外就是抛异常也不是无开销的，而且这里只是逻辑中断，逻辑上也不算『异常』，通过throw异常和catch异常的方式未免影响代码可读性……&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;goto【Java没有，C和C++有】确实看过一些代码确实在这种场合使用过goto。当然我们要严厉禁止goto。这个方案直接略过。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实还有第4种方案：&lt;code&gt;do while(0)&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 步骤1&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (步骤&lt;span&gt;1&lt;/span&gt;失败) {&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 步骤2&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (步骤&lt;span&gt;2&lt;/span&gt;失败) {&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 步骤3&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (步骤&lt;span&gt;3&lt;/span&gt;失败) {&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;} &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 步骤4&lt;/span&gt;&lt;br/&gt;...&lt;br/&gt;&lt;span&gt;// 步骤5&lt;/span&gt;&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个其实也适用于其他用do while的语言，不止C++。当然关于这个用法在C++11以后，很多人提出，用立即执行的lambda会更好，表现力会更强一些：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[...](...) { &lt;span&gt;// 通过捕获或传参传入一些上下文中的变量，&lt;/span&gt;&lt;br/&gt;             &lt;span&gt;// 用...替代，表示省略 ...不是语法的一部分！&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 步骤1&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (步骤&lt;span&gt;1&lt;/span&gt;失败) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 步骤2&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (步骤&lt;span&gt;2&lt;/span&gt;失败) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 步骤3&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (步骤&lt;span&gt;3&lt;/span&gt;失败) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}(); &lt;span&gt;// 比普通lambda表达式多了一个括号，表示立即执行&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种匿名的、定义处立即执行的lambda，也叫&lt;code&gt;IIFE&lt;/code&gt;(Immediately Invoked Function Expression) ，翻译成：&lt;strong&gt;立即调用函数表达式&lt;/strong&gt;。IIFE是Javascript中的概念，见国外有些人也把C++的这种lambda表达式用法称作IIFE，私以为可能不是C++这边的官方说法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Anyway，不过其实IIFE的风格，代码量上也并没有比&lt;code&gt;do ... while(0)&lt;/code&gt;减少多少，而且还要额外的传参或捕获。支持者们认为，这里面的return中断逻辑，要比&lt;code&gt;do ... while(0)&lt;/code&gt;的 break表达中断要好。这个……见仁见智吧。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;往期推荐&lt;/span&gt;&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDIyMjI3OQ==&amp;amp;mid=2649003059&amp;amp;idx=1&amp;amp;sn=9de099fe618452c90e068d6761b4dd02&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4239036973344798&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hQZ4NEZ2sic4EJTcpzKx6Djia6NqvibMPnV8Qk0GUHFMdnoR10ibjRQTPG9TZF3JVk21x3J7DI1iaRlYaIBEGPGAKJw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1163&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;figcaption&gt;实践解读CLOSE_WAIT和TIME_WAIT&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDIyMjI3OQ==&amp;amp;mid=2649002886&amp;amp;idx=1&amp;amp;sn=815697147d0fd7415a4fc0d73aec5c89&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hQZ4NEZ2sic4EJTcpzKx6Djia6NqvibMPnVxuBDN1QwQ44Sqajt3ZYFmVuTrqvQu9CZUTqiaEn36jNGicuroTiaib4bBQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;figcaption&gt;大四那一年&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDIyMjI3OQ==&amp;amp;mid=2649004681&amp;amp;idx=1&amp;amp;sn=02f8c4509b18de5d8c8abac527bbf660&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4247211895910781&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hQZ4NEZ2sic4EJTcpzKx6Djia6NqvibMPnVxicDpx1lZwANYsYEfU8HqxxUwUcOltniaQLmVmYIDWvzz4WroIomO02Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1076&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;figcaption&gt;白嫖Github的Action做定时任务&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDIyMjI3OQ==&amp;amp;mid=2649004646&amp;amp;idx=1&amp;amp;sn=e3f3a6e5b6e7e03e8be4660b9c983f18&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hQZ4NEZ2sic4EJTcpzKx6Djia6NqvibMPnV7pThXHiaOcsNVcxq9JGjibibfH8icfvGhUFwnpzNTzVAUXYWnFQfeIkhBw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;figcaption&gt;brpc小课堂：从StringPiece说开来&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDIyMjI3OQ==&amp;amp;mid=2649004917&amp;amp;idx=1&amp;amp;sn=4ab837ecf07f7e3b6170eef797c5c518&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4261954261954262&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hQZ4NEZ2sic4EJTcpzKx6Djia6NqvibMPnVGv5jamXIR4I8NH1yCyeuicia4NTve87QPHQUfLsHYYqmY7EcFEpW6EKQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;962&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;figcaption&gt;STL中有哪些副作用或容易会产生性能开销的地方？&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0b2db0f68ecd5bb1d1f7dbf19a0acb67</guid>
<title>Google Wave 的失败教训</title>
<link>https://toutiao.io/k/jf3fksk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;Google Wave是2009年Google I/O大会的宠儿，但在短短的两年内就失败了。分析失败的原因，有助于我们为未来的远程工作和协作工具构建更好的协作工具。&lt;/p&gt;&lt;p&gt;当Google Wave在2009年I/O大会上发布预览版本时，一时风头无两。它不仅是远程工作爆发之前第一个统一的工作空间和协作平台，而且还试图解决我们今天面临的许多同样的问题。&lt;/p&gt;&lt;p&gt;然而，在不到两年的时间里，Google Wave就失败了。&lt;/p&gt;&lt;p&gt;当我们回顾这个平台推出的历史时， 就会对这个SaaS创新历史上的一个小插曲不会感到任何意外。缺乏产品重点、定位问题和发布计划乏善可陈只是它的一些皮毛问题。&lt;/p&gt;&lt;p&gt;如今，随着越来越多的公司采用&lt;span&gt;分布式模型&lt;/span&gt;，我们从Google Wave的错误中吸取教训是很重要的。随着实时协作工具的全面复兴，反思先驱们的故事可以为未来提供宝贵的经验教训。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;span&gt;Google Wave的历史 🌊&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Google Wave起源于一个问题：&lt;em&gt;“如果电子邮件是在今天发明的，它会是什么样子？”&lt;/em&gt;这个问题产生了有史以来最雄心勃勃的实时协作工具之一。&lt;/p&gt;&lt;p&gt;让我们看看Google Wave的开发是如何开展的，从“Walkabout”作为代号开始，到2012年4月的最终关闭，2018年的开源项目关闭。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;span&gt;2006–2008: 从启动到产品发布 🌱&lt;/span&gt;&lt;/p&gt;&lt;p&gt;新项目由Lars 和 Jens Rasmussen兄弟来负责，他们成为了项目的主要开发者。当他们致力于Google地图的首次发布时，兄弟俩就开始考虑他们在谷歌的下一步工作可能是什么。&lt;/p&gt;&lt;p&gt;“聚焦于沟通”的想法来自Jens，他注意到人们在线互动方式的重大转变。两兄弟之间的共识是，他们应该建立一个反映此变化的平台&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;438&quot; data-ratio=&quot;0.5394088669950738&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z8ExnwlWwvI9q2BotEqmRoZU3QDJuleaZfiaNw7a2MlJPXXVTpu4d3bJ5HHNYicaWL0KXVVIyicAFqib6GrDmgcgFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;812&quot; data-width=&quot;812&quot;/&gt;&lt;/p&gt;&lt;p&gt;Google地图项目完成后，Lars 和 Jens继续开发一个被称为“Walkabout”的产品， 他们的最终目标是能够满足一些关于人们如何在线交流的问题：&lt;/p&gt;&lt;p&gt;从那里，Lars 和 Jens组建了一支尖刀连（开发团队）来实现这个想法。几个月后，他们构建出了一个原型，在接下来的几年里，它要演变成了一个可发布产品。这个产品被命名为 Google Wave。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;span&gt;2009–2011: 开发者预览版 👨🏻‍💻&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2009年5月，Lars 、Jens和产品经理Stephanie Hammond在谷歌的I/O会议上发布了Wave的预览版。一下子，Walkabout正式成为一个产品、平台和协议，通过一个叫做wave的进程进行实时通信。&lt;/p&gt;&lt;p&gt;以下是谷歌官方在博客发布对Wave的描述：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在Google Wave中，你创建了一个wave，并添加人。你的Wave中的每个人都可以使用富格式的文本、照片、小工具，甚至来自网络上其他来源的提要。他们可以直接插入回复或编辑wave。这是支持并发的富文本编辑，你几乎可以立即在屏幕上看到你的同事在你的wave中输入的内容。这意味着谷歌wave既适合需要持久化存储的内容，也适合短平快的信息——它支持协作和交流。你也可以使用“回放”来对wave做倒带，看看它是如何演进的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;主旨演讲以现场演示的形式进行，以Lars, Jens和Stephanie 将要进行的乘船旅行为例，展示了Wave的功能。&lt;/p&gt;&lt;p&gt;【请点击】&lt;/p&gt;&lt;p&gt;在演讲中，团队带领观众完成了他们乘船旅行的计划阶段，强调了Wave在实时更新、上下文线程和图像共享方面的工作方式。&lt;/p&gt;&lt;p&gt;虽然有一些Bug，Lars和Jens将其归因于Wave还在开发者预览版中。总的来说，这个发布版本的初期获得了压倒性的支持。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;span&gt;Wave的主动测试 ⚙️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;尽管I/O会议上的每个人都被获许访问Wave，但Lars和其他人强调，该工具仍在积极开发中。团队明白在改进产品方面还有很多工作要做，并希望利用参加I/O会议的开发人员来寻求帮助。&lt;/p&gt;&lt;p&gt;有了预览帐户，每位开发人员都可以访问谷歌Wave的API，这是这个发布版本的另一个重要内容。那时，在Lars看来，这个平台仍然是一个开源项目。使用该API将使用户能够将Wave连接到现有的网络应用程序并分别构建集成应用。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;832&quot; data-ratio=&quot;0.6520376175548589&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z8ExnwlWwvI9q2BotEqmRoZU3QDJuleafEHxtfDRFr144pvAGPZErTBXSo2F2uGEmUx574OIsWPsXOmhbJa0nA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1276&quot; data-width=&quot;1276&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;Google Wave 平台 via &lt;/em&gt;&lt;span&gt;&lt;em&gt;TechCrunch&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;事实证明，邀请开发人员进行主动测试是有风险的，也是Wave推出计划中的第一个失误。很快，谷歌IO大会的大约5000名与会者将成为第一批使用Wave的“局外人”，由此引发了一些头疼的问题。&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;span&gt;第一波问题 ❌&lt;/span&gt;&lt;/p&gt;&lt;p&gt;到&lt;span&gt;2009年7月&lt;/span&gt;，谷歌已经推出了大约6,000个开发人员账户，并正在处理另外20,000个请求。此时，Wave也在各种论坛、推特和其他社交媒体渠道上获得了大量的传播。&lt;/p&gt;&lt;p&gt;人们争先恐后地访问该平台，但谷歌却退缩了。Google只会发出单人邀请，这实际上削弱了Wave针对团队合作的目的。&lt;/p&gt;&lt;p&gt;虽然谷歌考虑得挺好的，不想给一个全新的平台带来过多的用户的压力，但发送邀请也意味着该公司无法破解围绕其产品的一些传言。&lt;/p&gt;&lt;p&gt;当谷歌最终决定开放Wave并允许10万名新用户时，到&lt;span&gt;2009年9月，&lt;/span&gt;只有27,000个活跃的开发者账户使用Wave的应用编程接口。这个数字与Lars的乐观预测相去甚远：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;“数百万人想尝试我们今年晚些时候推出的、仅限邀请的预览。Wave成为推特2009年最热门的技术话题。这比我们预期的要多得多——有些人会称之为炒作。&quot;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;-Lars Rasmussen 在 &lt;span&gt;赫芬顿邮报&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;一旦新用户进入该平台，热情就很快就被混乱所消弱：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&quot;推特上充斥着&quot;进入Google Wave-现在怎么办？&quot;的迷思。更糟糕的是：早期用户的热情在慢慢流失，因为他们的朋友还不太喜欢使用Wave。对我们演示的敬畏很快被对某些失败的预测所取代。&quot;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;-Lars Rasmussen 在 &lt;span&gt;赫芬顿邮报&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;很多不满之所以发生，是因为Wave中的小组对话并不像用户希望的那样容易用。奇怪的是，这些团队仍然不是谷歌新产品的目标受众。&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;组，恢复和其他更新 ⚡️&lt;/p&gt;&lt;p&gt;期待已久的对组的支持于&lt;span&gt;2009年12月&lt;/span&gt;添加到Wave中，这是该平台在Google IO大会上公开宣布的七个月后。&lt;span&gt;2010年1月&lt;/span&gt;，组之后还有另外两个功能，允许用户添加只读参与者，以及从以前的版本（版本历史）Wave中恢复到现有版本。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;165&quot; data-ratio=&quot;0.4125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z8ExnwlWwvI9q2BotEqmRoZU3QDJuleaGH1sH6pFvaouicLIGJQ2XMjsZ8Bfh3TIGLFTQFrBQt51gJF89Y6NS1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot; data-width=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;恢复功能，&lt;/em&gt;&lt;span&gt;&lt;em&gt;谷歌&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在一个平淡无奇的开始之后，Wave似乎终于朝着正确的方向前进了。&lt;/p&gt;&lt;p&gt;在&lt;span&gt;2010年3月&lt;/span&gt;，谷歌推出了通知，在2010年5月，经过一整年的封闭用户测试后，作为谷歌实验室项目孵化器的一部分，向公众发布了Wave。该活动伴随着另一个简短得多的主题演讲，&lt;span&gt;在此期间&lt;/span&gt;，Lars讨论了来自不同用户的用例。&lt;/p&gt;&lt;p&gt;这也是Lars和他的团队决定公开他的团队在过去一年面临的问题：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;“自从大约半年前开始我们的有限邀请预览以来，我们已经显著提高了Wave的速度、稳定性和易用性。我相信，用Gartner’s Hype 曲线的行话来说，谷歌浪潮已经到达了“启蒙斜坡”的山麓：产品已经足够成熟，真正的用例正在出现，这些用例充分说明了新技术的好处。&quot;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;-Lars Rasmussen 在 &lt;span&gt;赫芬顿邮报&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Lars的坦白揭示了谷歌Wave的另一个关键问题：团队并不确切知道他们想要它是什么。事实上，谷歌仍然在“沙箱”平台的运行很大一部分功能。&lt;/p&gt;&lt;p&gt;这就把我们带到了&lt;span&gt;2010年8月&lt;/span&gt;，当时谷歌宣布他们将停止该项目的积极开发：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;“我们内部对谷歌Wave同样感到兴奋，尽管我们不太确定用户会如何回应这种截然不同的交流。我们看到的用例显示了这项技术的力量：实时共享图像和其他媒体；通过不仅理解单个单词，还理解每个单词的上下文来改进拼写检查；并使第三方开发人员能够构建新的工具，如消费小工具用于旅行，或者机器人查码。但是尽管有这些胜利和众多忠实的粉丝，我们想要的用户并没有采用Wave并。&quot;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;谷歌以低迷的采用率为由，决定放弃Wave项目，将该技术用于两项新方向上：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;438&quot; data-ratio=&quot;0.5394088669950738&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z8ExnwlWwvI9q2BotEqmRoZU3QDJuleaZfiaNw7a2MlJPXXVTpu4d3bJ5HHNYicaWL0KXVVIyicAFqib6GrDmgcgFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;812&quot; data-width=&quot;812&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;span&gt;2012-2018：开源的潜逃和缓慢死亡💀&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在接下来的两年里，谷歌Wave几乎被藏在地毯下面。但这并没有阻止网上一些人讨论该产品的愿景及其用户体验问题。&lt;/p&gt;&lt;p&gt;这种兴趣一直持续到2012年1月，当时Wave被永久移动到只读阶段。虽然用户仍然可以导出现有的Wave，但核心技术不再受到支持。&lt;/p&gt;&lt;p&gt;在&lt;span&gt;2012年4月&lt;/span&gt;，谷歌完全关闭了Wave的服务器。该平台的唯一残余是Apache Wave和Wave的一个实验性开源变体，名为&lt;span&gt;Walkaround&lt;/span&gt;.。&lt;/p&gt;&lt;p&gt;尽管Wave在那时几乎已经死了，Apache软件基金会仍然管理着它的产品分支。然而，由于开源社区得到的投资很少，它也在2018年1月&lt;span&gt;正式退役&lt;/span&gt;。&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，为什么谷歌Wave失败了？🤔&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在谷歌资金的全力支持下，为什么我们今天都不使用Wave？是什么导致了一个革命性的实时协作工具在短短几年内失败？&lt;/p&gt;&lt;p&gt;回顾其动荡的历史，我们可以得出这样的结论：&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Wave&lt;strong&gt;远远领先于它的时代&lt;/strong&gt;。谷歌试图解决市场当时没有完全理解的问题&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;它缺乏方向，面临定位问题&lt;/strong&gt;。开发团队并不真正知道Wave应该变成什么，它是为谁而做的&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;它有一个不幸的启动。&lt;/strong&gt;过早发布使得谷歌不可能从第一天起就利用围绕他们产品的关注&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;如今，很难想象一个没有实时协作工具的世界。随着最近协同办公领域初创企业的繁荣，我们似乎生活在生产力的天堂。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;979&quot; data-ratio=&quot;0.9560546875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z8ExnwlWwvI9q2BotEqmRoZU3QDJuleaIarUkfXdJlVAIphQYOSaibibyAmYKLjuVUuia6hrKsZxWuKjCbRyH4xXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot; data-width=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt; 工作空间协作工具，来自 &lt;/em&gt;&lt;span&gt;&lt;em&gt;Merci Victoria Grace&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是在过去，谷歌Wave是前无古人的。为了将聊天、电子邮件、图像共享和文档结合起来，谷歌创造了一个没有认可可参考框架的工具。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;“但是Wave不仅仅是我们已经习惯于电子邮件和即时消息的传统消息和回复方式。您还可以通过并发团队协作编辑wiki风格的内容。任何试图在谷歌文档上对文档进行分组编辑的人都知道，这可能会很快变得棘手。&quot;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;-来自&lt;span&gt;TechCrunch&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;上下文线程、长时间运行的会话历史和富文本支持都是2009年的新奇事物。如果没有适当的培训，用户几乎不可能理解谷歌Wave能够提供的真正价值。&lt;/p&gt;&lt;p&gt;虽然发布后有一些积极的反应，但一旦更多的用户接触到该产品，该平台糟糕的可用性就扼杀了它的潜力。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;“剩下的大约500万人要求尝试我们的预览，他们比第一个一百万人要宽容得多。12月和1月期间，新用户的保留率大幅下降。&quot;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;-Lars Rasmussen 在 &lt;span&gt;赫芬顿邮报&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们能从谷歌Wave故事中学到什么🔄&lt;/span&gt;&lt;/p&gt;&lt;p&gt;有几个因素导致了Wave的最终消亡，每一个因素对今天的其他SaaS业务都是一个宝贵的教训。在一个实时协作迅速普及的时代，谷歌Wave是一个“&lt;em&gt;不该&lt;/em&gt;做什么”的典型案例。&lt;/p&gt;&lt;p&gt;Wave故事的关键是什么？&lt;strong&gt;定位就是一切。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们生活在一个选择的世界里。如果你正在构建一个产品，但不理解它为最终用户提供的具体价值，你就会失败。当人们感觉不到你的工具的影响时，他们会很快转向竞争对手，寻找更好（更有意义）的解决方案。&lt;/p&gt;&lt;p&gt;你需要给用户时间去理解你的产品提供的价值。在插头被拔掉之前，谷歌Wave已经积极开发了大约18个月。这还不足以让用户看到产品是如何发展和成长的。&lt;/p&gt;&lt;p&gt;最后，你的发布计划是关键。当Wave被引入时，谷歌限制了可以积极参与的人数。在当今竞争激烈的市场中，尽快向尽可能多的人传播信息至关重要。&lt;/p&gt;&lt;p&gt;毕竟，一个产品如果没有用户基础支撑，又有什么用呢？&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;理解失败有助于你成长📈&lt;/p&gt;&lt;p&gt;Google Wave是实时协作的首批尝试之一。它有可能席卷市场，但事实并非如此。&lt;/p&gt;&lt;p&gt;观察这个平台如何从“有希望”变成“令人失望”表明，构建成功的工具可以归结为几个要点：&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;了解您的产品并决定您期望它是什么。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;找出您的用户是&lt;strong&gt;谁&lt;/strong&gt;，并关注他们的反馈&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;弄清楚项目启动的最佳时机&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;当你做到这一点时，你将能够吸引到那些能够真正理解你的产品，并使用它来帮助他们完成任务的用户。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;《老熊看架构》，专注于企业级应用的业务、产品、技术架构设计。&lt;/p&gt;&lt;p&gt;查看原文，以及相关的讨论，可以通过团队码加入飞书群来沟通。 &lt;/p&gt;&lt;p&gt;邀请你加入支付交流群，可通过此链接：&lt;/p&gt;&lt;p&gt;https://payment.feishu.cn/invite/member/A2Q-T5PnjRXabQEi&lt;/p&gt;&lt;p&gt;或 8 位团队码：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;XLELVLLE &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;加入团队。&lt;/p&gt;&lt;p&gt;如何使用团队码：https://www.feishu.cn/hc/zh-CN/articles/360040931334&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>