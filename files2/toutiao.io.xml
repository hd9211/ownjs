<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>31894b68c930c08e262e6e7706c851f9</guid>
<title>声网开发者创业讲堂丨第 4 期：创业团队如何保障产品业务的安全合规？</title>
<link>https://toutiao.io/k/lgn6aun</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;event-intro tab-content&quot; id=&quot;eventContentAreaMain&quot;&gt;&amp;#13;
                    &amp;#13;
&amp;#13;
                    &lt;div class=&quot;  &quot; id=&quot;event_desc_page&quot;&gt;&amp;#13;
                        &lt;p ql-global-para=&quot;true&quot; line=&quot;Sl5P&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;安全与合规是两个非常大的话题，即涉及到技术层面，也涉及到政策和业务管理。很多创业团队会在创业初期因为公司规模、项目体量的原因，忽略或刻意规避安全合规，从而引发不可挽回的风险或隐患。在创业初期存在诸多不确定性的情况下，作为创业者应该如何正确且合理的保障产品业务的安全与合规？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7 月 16 日下午&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，声网开发者创业讲堂 • 第 4 期将以「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;创业团队如何保障产品业务的安全合规？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」为题，邀请&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;环信、游族、白山云&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;三家优秀企业的技术专家为大家带来精彩的分享。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Sl5P&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;h4 data-foldable-wrapper=&quot;&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;时间地点&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;活动时间：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;7 &lt;/span&gt;&lt;span&gt;月 16 日（星期六）&lt;/span&gt;&lt;span&gt; 14:00——16:30&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;活动地点：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;线上直播&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;h4 data-foldable-wrapper=&quot;&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;活动流程&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;span&gt;14:00-14:10 开场&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 14:10-14:50 《即时通信场景下安全合规的实践和经验》&lt;/span&gt;&lt;span&gt;赵亮 环信IM SDK 研发负责人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 14:50-15:30 &lt;/span&gt;&lt;span&gt;《常见信息安全攻击风险及应对方案》马寅龙 游族网络信息化中心总监&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;15:30-16:10 《&lt;/span&gt;&lt;span&gt;攻防视角下业务安全的实战经验分享&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;&lt;span&gt;胡金涌&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;白山云安全研发总监&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 16:10-16:30 抽奖&lt;/span&gt;&lt;/p&gt;&lt;p helvetica=&quot;&quot; hiragino=&quot;&quot; sans=&quot;&quot; noto=&quot;&quot; cjk=&quot;&quot; microsoft=&quot;&quot; apple=&quot;&quot; color=&quot;&quot; segoe=&quot;&quot; ui=&quot;&quot; text-align:=&quot;&quot; text-size-adjust:=&quot;&quot; letter-spacing:=&quot;&quot; line-height:=&quot;&quot; span=&quot;&quot; strong=&quot;&quot; p=&quot;&quot;&gt;​&lt;/p&gt;&lt;h4 data-foldable-wrapper=&quot;&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;span ql-global=&quot;true&quot; class=&quot;ql-author-10306337&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section microsoft=&quot;&quot; line-height:=&quot;&quot; border:=&quot;&quot; text-align:=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;嘉宾一&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5mYi&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;img src=&quot;http://cdn.huodongxing.com/file/ue/20150907/11EC6A5AE18CC6F72FD13133F73B484844/30214561467379533.jpg&quot; title=&quot;赵亮.jpeg&quot; alt=&quot;赵亮.jpeg&quot;/&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5mYi&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span class=&quot;ql-author-7400209 ql-font-microsoftyahei&quot; ql-global=&quot;true&quot; microsoft=&quot;&quot;/&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;M81Y&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;strong class=&quot;ql-author-7400209 ql-font-microsoftyahei&quot; ql-global=&quot;true&quot; microsoft=&quot;&quot;&gt;赵亮，环信IM SDK 研发负责人&lt;/strong&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;M81Y&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分享主题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;M81Y&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;strong class=&quot;ql-author-7400209 ql-font-microsoftyahei&quot; ql-global=&quot;true&quot; microsoft=&quot;&quot;&gt;即时通信场景下安全合规的实践和经验&lt;/strong&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5mYi&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span ql-global=&quot;true&quot; class=&quot;ql-author-10306337&quot;&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;个人简介：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5mYi&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;环信IM SDK 研发负责人，十余年电信和互联网从业经验，曾主持研发多个明星项目，目前在环信主持即时通讯云 SDK 研发工作。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Ji92&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分享简介：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;LCNh&quot; linespacing=&quot;200&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;span&gt;在监管趋紧的形式下，即时通讯场景会遇到很多安全合规领域的挑战，如何满足这些安全合规的要求，如何保护用户的隐私安全，是一件非常有挑战的事情。本次分享将介绍环信在这个领域所做的一些实践和经验。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-foldable-wrapper=&quot;&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span microsoft=&quot;&quot; font-size:=&quot;&quot; font-weight:=&quot;&quot; letter-spacing:=&quot;&quot; text-align:=&quot;&quot; text-size-adjust:=&quot;&quot; background-color:=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;section helvetica=&quot;&quot; pingfang=&quot;&quot; hiragino=&quot;&quot; sans=&quot;&quot; microsoft=&quot;&quot; yahei=&quot;&quot; font-size:=&quot;&quot; letter-spacing:=&quot;&quot; text-align:=&quot;&quot; white-space:=&quot;&quot; text-size-adjust:=&quot;&quot; section=&quot;&quot; line-height:=&quot;&quot; border:=&quot;&quot; span=&quot;&quot; p=&quot;&quot; img=&quot;&quot; src=&quot;http://cdn.huodongxing.com/file/ue/20150907/11EC6A5AE18CC6F72FD13133F73B484844/30294520688364826.jpg&quot; title=&quot;讲师-3.jpg&quot; alt=&quot;讲师-3.jpg&quot; ql-global-para=&quot;true&quot; line=&quot;92I0&quot; class=&quot;ql-author-10306337&quot; linespacing=&quot;200&quot; strong=&quot;&quot; ql-global=&quot;true&quot; h4=&quot;&quot; data-foldable-wrapper=&quot;&quot;&gt;&lt;section microsoft=&quot;&quot; line-height:=&quot;&quot; border:=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;嘉宾二&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5mYi&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;img src=&quot;http://cdn.huodongxing.com/file/ue/20150907/11EC6A5AE18CC6F72FD13133F73B484844/30624561468989583.jpg&quot; title=&quot;马寅龙.jpeg&quot; alt=&quot;马寅龙.jpeg&quot;/&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5mYi&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;strong class=&quot;ql-author-7400209 ql-font-microsoftyahei&quot; ql-global=&quot;true&quot; microsoft=&quot;&quot;&gt;马寅龙，游族网络信息化中心总监&lt;/strong&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5mYi&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分享主题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5mYi&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong ql-global=&quot;true&quot; class=&quot;ql-author-10306337&quot;&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;ezi5&quot; linespacing=&quot;200&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;strong class=&quot;ql-author-7400209 ql-font-microsoftyahei&quot; ql-global=&quot;true&quot; microsoft=&quot;&quot;&gt;常见信息安全攻击风险及应对方案&lt;/strong&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5mYi&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong ql-global=&quot;true&quot; class=&quot;ql-author-10306337&quot;&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;个人简介：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5mYi&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;span&gt;​游族网络信息化中心与信息安全部负责人，拥有 12 年信息安全管理建设经验，主导构建了游族网络信息安全纵深防护体系，曾作为嘉宾在 CIS / EISS / FIT / SSC等国内顶级安全峰会演讲。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Ji92&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分享简介：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;LCNh&quot; linespacing=&quot;200&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;span&gt;从企业常见的安全事件出发，分析企业信息安全管理的演进路径，包括安全团队建设、安全工具选型、安全服务选型，以及如何以高性价比方式建设企业安全防护能力。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;LCNh&quot; linespacing=&quot;200&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;span microsoft=&quot;&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-foldable-wrapper=&quot;&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span microsoft=&quot;&quot; font-size:=&quot;&quot; font-weight:=&quot;&quot; letter-spacing:=&quot;&quot; text-align:=&quot;&quot; text-size-adjust:=&quot;&quot; background-color:=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;section helvetica=&quot;&quot; pingfang=&quot;&quot; hiragino=&quot;&quot; sans=&quot;&quot; microsoft=&quot;&quot; yahei=&quot;&quot; font-size:=&quot;&quot; letter-spacing:=&quot;&quot; text-align:=&quot;&quot; white-space:=&quot;&quot; text-size-adjust:=&quot;&quot; section=&quot;&quot; line-height:=&quot;&quot; border:=&quot;&quot; span=&quot;&quot; p=&quot;&quot; img=&quot;&quot; src=&quot;http://cdn.huodongxing.com/file/ue/20150907/11EC6A5AE18CC6F72FD13133F73B484844/30294520688364826.jpg&quot; title=&quot;讲师-3.jpg&quot; alt=&quot;讲师-3.jpg&quot; ql-global-para=&quot;true&quot; line=&quot;92I0&quot; class=&quot;ql-author-10306337&quot; linespacing=&quot;200&quot; strong=&quot;&quot; ql-global=&quot;true&quot; h4=&quot;&quot; data-foldable-wrapper=&quot;&quot;&gt;&lt;section microsoft=&quot;&quot; line-height:=&quot;&quot; border:=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;嘉宾三&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;LCNh&quot; linespacing=&quot;200&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;span microsoft=&quot;&quot;/&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;xXLn&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span class=&quot;ql-author-7400209&quot; ql-global=&quot;true&quot;&gt;&lt;img src=&quot;http://cdn.huodongxing.com/file/ue/20150907/11EC6A5AE18CC6F72FD13133F73B484844/30874561474629783.jpg&quot; title=&quot;胡金涌.jpeg&quot; alt=&quot;胡金涌.jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;xXLn&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span class=&quot;ql-author-7400209&quot; ql-global=&quot;true&quot;&gt;胡金涌，白山云安全研发总监&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;xXLn&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分享主题&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;xXLn&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;攻防视角下业务安全的实战经验分享&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Sl5P&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;个人简介：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Sl5P&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;span&gt;白山云安全研发总监，&lt;/span&gt;十年云安全产品研发经验，主持研发了SCDN、抗DDoS、云WAF、SoC、零信任等安全产品，在攻防领域有丰富的经验。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Los9&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分享简介：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Los9&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从攻防的视角分享业务上线后可能遇到的常见攻击，并分享安全研发规范、上线前的安全巡检、上线后的安全防护等实战经验并给出一些安全建议。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Los9&quot; class=&quot;ql-align-justify ql-long-10306337&quot; linespacing=&quot;200&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;LCNh&quot; linespacing=&quot;200&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;/p&gt;&lt;h4 data-foldable-wrapper=&quot;&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;活动社群&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;当下是一个人人可创业的时代，对技术人来说，更是一个创业友好的时代。如果你懂技术，会比其他人更容易将自己的创业想法和梦想付诸实践。但创业意味着要从 0 到 1，意味着要持续的创造和创新，意味着创业者和团队需要不断的成长和突破。只有这样才能打造出满足市场需求的、有价值的产品，逐渐形成企业的优势和壁垒，成长为一家成熟的企业。声网关注有创新能力、开发能力和创业意向的开发者，并希望为开发者提供相应的支持和服务。为此，我们推出了“声网开发者创业讲堂”系列创业分享，以便为大家在成长和创业路上提供更多的帮助。欢迎扫码申请加入我们的创业开发者社群！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.huodongxing.com/file/ue/20150907/11EC6A5AE18CC6F72FD13133F73B484844/30884567754245388.jpg&quot; title=&quot;WechatIMG263.jpeg&quot; alt=&quot;WechatIMG263.jpeg&quot;/&gt;&lt;/p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;LCNh&quot; linespacing=&quot;200&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;/p&gt;&lt;h4 data-foldable-wrapper=&quot;&quot; class=&quot;ql-long-10306337&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;活动福利&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;报名直播参与活动，即有机会领取&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;精美声网周边&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;，心动不如行动，赶快报名本次活动吧！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;http://cdn.huodongxing.com/file/ue/20150907/11EC6A5AE18CC6F72FD13133F73B484844/30714561552961563.jpeg&quot; title=&quot;副本_未命名_自定义px_2022-06-28+12_00_12.png&quot; alt=&quot;副本_未命名_自定义px_2022-06-28+12_00_12.png&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;联合主办&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p helvetica=&quot;&quot; pingfang=&quot;&quot; hiragino=&quot;&quot; sans=&quot;&quot; microsoft=&quot;&quot; yahei=&quot;&quot; font-size:=&quot;&quot; text-size-adjust:=&quot;&quot; letter-spacing:=&quot;&quot; line-height:=&quot;&quot; text-align:=&quot;&quot; img=&quot;&quot; src=&quot;http://cdn.huodongxing.com/file/ue/20150907/11EC6A5AE18CC6F72FD13133F73B484844/30264520732955891.jpg&quot; title=&quot;联合主办.jpeg&quot; alt=&quot;联合主办.jpeg&quot; section=&quot;&quot; powered-by=&quot;xiumi.us&quot; white-space:=&quot;&quot;&gt;&lt;img src=&quot;http://cdn.huodongxing.com/file/ue/20150907/11EC6A5AE18CC6F72FD13133F73B484844/30954561508360622.jpg&quot; title=&quot;联合主办.jpeg&quot; alt=&quot;联合主办.jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;合作伙伴&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.huodongxing.com/file/ue/20150907/11EC6A5AE18CC6F72FD13133F73B484844/30494561569642118.jpg&quot; title=&quot;安全课联合主办.jpeg&quot; alt=&quot;安全课联合主办.jpeg&quot;/&gt;​&lt;/p&gt;&lt;/section&gt;&amp;#13;
                    &lt;/div&gt;&amp;#13;
                    &lt;p class=&quot;clear&quot;&gt;&amp;#13;
                    &lt;/p&gt;&amp;#13;
                    &amp;#13;
                    &amp;#13;
                &lt;/div&gt;&amp;#13;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b9607120eb4824ef0d29d3b02dd46a5c</guid>
<title>一文读懂遗传算法工作原理（Python实现）</title>
<link>https://toutiao.io/k/s0vxu7o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;103122&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-id=&quot;85660&quot; data-custom=&quot;rgb(117, 117, 118)&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-id=&quot;85660&quot; data-custom=&quot;rgb(117, 117, 118)&quot;&gt;&lt;section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUzODYwMDAzNA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/NOM5HN2icXzy3oUJC81lHlcGDwlibYtVXDSYeqoFaryPvqlHlNBibLibKGcA9jyVJFAIoKenjxqSpItzhBLqR9DBMw/0?wx_fmt=png&quot; data-nickname=&quot;Python数据科学&quot; data-alias=&quot;PyDataScience&quot; data-signature=&quot;以Python为核心语言，专攻于「数据科学」领域，文章涵盖数据分析，数据挖掘，机器学习等干货内容，分享大量数据挖掘实战项目分析和讲解，以及海量的学习资源。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;选自：AnalyticsVidhya，编译：机器之心&lt;/span&gt;&lt;strong/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Analyticsvidhya 上发表了一篇题为《Introduction to Genetic Algorithm &amp;amp; their application in data science》的文章，作者 Shubham Jain 现身说法，用通俗易懂的语言对遗传算法作了一个全面而扼要的概述，并列举了其在多个领域的实际应用，其中重点介绍了遗传算法的数据科学应用。机器之心对该文进行了编译。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;几天前，我着手解决一个实际问题——大型超市销售问题。在使用了几个简单模型做了一些特征工程之后，我在排行榜上名列第 219 名。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5622254758418741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicH4Y4vjNrcXwlsvPRXyrE97tGeiclUf2yqEGLCfempcFalcRQ3r7A119IZhZd5J7M8jlslaJRb0dg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1366&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;虽然结果不错，但是我还是想做得更好。于是，我开始研究可以提高分数的优化方法。结果我果然找到了一个，它叫遗传算法。在把它应用到超市销售问题之后，最终我的分数在排行榜上一下跃居前列。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5622254758418741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicH4Y4vjNrcXwlsvPRXyrE91uz5NE5xCF1wnC3qOCnOGEL1hjVIibXBrFU5T2ic1c7OW3GnYiaP3FBzQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1366&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;没错，仅靠遗传算法我就从 219 名直接跳到 15 名，厉害吧！相信阅读完本篇文章后，你也可以很自如地应用遗传算法，而且会发现，当把它用到你自己正在处理的问题时，效果也会有很大提升。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、遗传算法理论的由来&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、生物学的启发&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3、遗传算法定义&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4、遗传算法具体步骤&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;5、遗传算法的应用&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;6、实际应用&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;7、结语&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;1、遗传算法理论的由来&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们先从查尔斯·达尔文的一句名言开始：&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;能够生存下来的往往不是最强大的物种，也不是最聪明的物种，而是最能适应环境的物种。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;你也许在想：这句话和遗传算法有什么关系？其实遗传算法的整个概念就基于这句话。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;让我们用一个基本例子来解释 ：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们先假设一个情景，现在你是一国之王，为了让你的国家免于灾祸，你实施了一套法案：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;你选出所有的好人，要求其通过生育来扩大国民数量。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;这个过程持续进行了几代。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;你将发现，你已经有了一整群的好人。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个例子虽然不太可能，但是我用它是想帮助你理解概念。也就是说，我们改变了输入值（比如：人口），就可以获得更好的输出值（比如：更好的国家）。现在，我假定你已经对这个概念有了大致理解，认为遗传算法的含义应该和生物学有关系。那么我们就快速地看一些小概念，这样便可以将其联系起来理解。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;2、生物学的启发&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;相信你还记得这句话：「细胞是所有生物的基石。」由此可知，在一个生物的任何一个细胞中，都有着相同的一套染色体。所谓染色体，就是指由 DNA 组成的聚合体。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.646551724137931&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicH4Y4vjNrcXwlsvPRXyrE9IibqiaUibvianIlLXJDr4Ik4NeLmoXs7NXUmyh9Bzrr7unsL8Eam3Cf2Qw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;348&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;传统上看，这些染色体可以被由数字 0 和 1 组成的字符串表达出来。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9513888888888888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicH4Y4vjNrcXwlsvPRXyrE9bgx0KWvYTUIibictDGq1GmowM5Lw3icNdFQiawsYPpMe5UrmOQAMecfhVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;288&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一条染色体由基因组成，这些基因其实就是组成 DNA 的基本结构，DNA 上的每个基因都编码了一个独特的性状，比如，头发或者眼睛的颜色。希望你在继续阅读之前先回忆一下这里提到的生物学概念。结束了这部分，现在我们来看看所谓遗传算法实际上指的是什么？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;3、遗传算法定义&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先我们回到前面讨论的那个例子，并总结一下我们做过的事情。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先，我们设定好了国民的初始人群大小。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;然后，我们定义了一个函数，用它来区分好人和坏人。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;再次，我们选择出好人，并让他们繁殖自己的后代。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最后，这些后代们从原来的国民中替代了部分坏人，并不断重复这一过程。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;遗传算法实际上就是这样工作的，也就是说，它基本上尽力地在某种程度上模拟进化的过程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此，为了形式化定义一个遗传算法，我们可以将它看作一个优化方法，它可以尝试找出某些输入，凭借这些输入我们便可以得到最佳的输出值或者是结果。遗传算法的工作方式也源自于生物学，具体流程见下图：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4285714285714286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicH4Y4vjNrcXwlsvPRXyrE9HzQzE4DVrROAqXwwxx4bmQKhyGvvkkghnFZaZSCW8NbtuAno6Ynhgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;343&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么现在我们来逐步理解一下整个流程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;4、遗传算法具体步骤&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了让讲解更为简便，我们先来理解一下著名的组合优化问题「背包问题」。如果你还不太懂，这里有一个我的解释版本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如，你准备要去野游 1 个月，但是你只能背一个限重 30 公斤的背包。现在你有不同的必需物品，它们每一个都有自己的「生存点数」（具体在下表中已给出）。因此，你的目标是在有限的背包重量下，最大化你的「生存点数」。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3292867981790592&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicH4Y4vjNrcXwlsvPRXyrE9YYazzfIibGLBqeriavu0wv9X8xu3TS36BFfMBpicGGNhYEkdVvEYzIjKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;659&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;4.1 初始化&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里我们用遗传算法来解决这个背包问题。第一步是定义我们的总体。总体中包含了个体，每个个体都有一套自己的染色体。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们知道，染色体可表达为二进制数串，在这个问题中，1 代表接下来位置的基因存在，0 意味着丢失。（译者注：作者这里借用染色体、基因来解决前面的背包问题，所以特定位置上的基因代表了上方背包问题表格中的物品，比如第一个位置上是 Sleeping Bag，那么此时反映在染色体的『基因』位置就是该染色体的第一个『基因』。）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6212389380530974&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicH4Y4vjNrcXwlsvPRXyrE9WokibFjCpl1LB4KibsypEKT2tiaUUbHhIfnWL9NXQrFSjD226KASQ3rEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;565&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在，我们将图中的 4 条染色体看作我们的总体初始值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;4.2 适应度函数&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;接下来，让我们来计算一下前两条染色体的适应度分数。对于 A1 染色体 [100110] 而言，有：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24605678233438485&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicH4Y4vjNrcXwlsvPRXyrE9tojMs0xibu4PsYwJiaT2jgW3CxkDyLuZWyJniaW8OwBLyxib8L2Om9QQPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;634&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;类似地，对于 A2 染色体 [001110] 来说，有：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24726134585289514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicH4Y4vjNrcXwlsvPRXyrE9o0QicdWNK968qd7fNBBxK7OQxhJVveI1hdMFZNGdNkVak5icdYUJev1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;639&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于这个问题，我们认为，当染色体包含更多生存分数时，也就意味着它的适应性更强。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此，由图可知，染色体 1 适应性强于染色体 2。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;4.3 选择&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在，我们可以开始从总体中选择适合的染色体，来让它们互相『交配』，产生自己的下一代了。这个是进行选择操作的大致想法，但是这样将会导致染色体在几代之后相互差异减小，失去了多样性。因此，我们一般会进行「轮盘赌选择法」（Roulette Wheel Selection method）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6266666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicH4Y4vjNrcXwlsvPRXyrE9q7MGx7SohqDlxp5NcaHspQd0IlPbvx58a16OToxmOFmj8nUG4ibaOfQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;想象有一个轮盘，现在我们将它分割成 m 个部分，这里的 m 代表我们总体中染色体的个数。每条染色体在轮盘上占有的区域面积将根据适应度分数成比例表达出来。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2406832298136646&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicH4Y4vjNrcXwlsvPRXyrE9pu7Hib3ias76m2lGruXvUlbkZoC7EGf3kcDtMO87W3qeayuwiaTWqaUMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;644&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基于上图中的值，我们建立如下「轮盘」。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6808510638297872&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicH4Y4vjNrcXwlsvPRXyrE9KC1NIIztIqpnOqmEJoVSMK5Kzib2F8Zl77IxibhdE4DYtqjxOJa8V4wA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;564&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在，这个轮盘开始旋转，我们将被图中固定的指针（fixed point）指到的那片区域选为第一个亲本。然后，对于第二个亲本，我们进行同样的操作。有时候我们也会在途中标注两个固定指针，如下图：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6459854014598541&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicH4Y4vjNrcXwlsvPRXyrE9ssVkSOEKcx4YGCorydicueBcH4fZI9VkZeC6xsNsSY7QEZz2BMhQAUQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;548&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过这种方法，我们可以在一轮中就获得两个亲本。我们将这种方法成为「随机普遍选择法」（Stochastic Universal Selection method）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;4.4 交叉&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在上一个步骤中，我们已经选择出了可以产生后代的亲本染色体。那么用生物学的话说，所谓「交叉」，其实就是指的繁殖。现在我们来对染色体 1 和 4（在上一个步骤中选出来的）进行「交叉」，见下图：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3089983022071307&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicH4Y4vjNrcXwlsvPRXyrE9ic7tuhOFOsvxtxIicNrldldnVsJRDraTbrO43YlhSHuEKCIcpyNjua7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;589&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这是交叉最基本的形式，我们称其为「单点交叉」。这里我们随机选择一个交叉点，然后，将交叉点前后的染色体部分进行染色体间的交叉对调，于是就产生了新的后代。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你设置两个交叉点，那么这种方法被成为「多点交叉」，见下图：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3373913043478261&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicH4Y4vjNrcXwlsvPRXyrE9Z1LFReTP6NLDMPel8q9sp2kIvzlUGibS96sW9dCFst8OTEMKsXvk27A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;575&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;4.5 变异&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果现在我们从生物学的角度来看这个问题，那么请问：由上述过程产生的后代是否有和其父母一样的性状呢？答案是否。在后代的生长过程中，它们体内的基因会发生一些变化，使得它们与父母不同。这个过程我们称为「变异」，它可以被定义为染色体上发生的随机变化，正是因为变异，种群中才会存在多样性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下图为变异的一个简单示例：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18538324420677363&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicH4Y4vjNrcXwlsvPRXyrE9lyFqmWQZ9T2DSpsBguBeqJtKD10FdTOruDHXslt5yXiayraSnFVs2Bg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;561&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;变异完成之后，我们就得到了新为个体，进化也就完成了，整个过程如下图：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6549707602339181&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicH4Y4vjNrcXwlsvPRXyrE9SKowKzfof6BSoiaMH3ZibTJ3mYJADuIKt5BZrfhVM3TNEN0Hga1RFRLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;513&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在进行完一轮「遗传变异」之后，我们用适应度函数对这些新的后代进行验证，如果函数判定它们适应度足够，那么就会用它们从总体中替代掉那些适应度不够的染色体。这里有个问题，我们最终应该以什么标准来判断后代达到了最佳适应度水平呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一般来说，有如下几个终止条件：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在进行 X 次迭代之后，总体没有什么太大改变。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;我们事先为算法定义好了进化的次数。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当我们的适应度函数已经达到了预先定义的值。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;好了，现在我假设你已基本理解了遗传算法的要领，那么现在让我们用它在数据科学的场景中应用一番。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;5、遗传算法的应用&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;5.1 特征选取&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;试想一下每当你参加一个数据科学比赛，你会用什么方法来挑选那些对你目标变量的预测来说很重要的特征呢？你经常会对模型中特征的重要性进行一番判断，然后手动设定一个阈值，选择出其重要性高于这个阈值的特征。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么，有没有什么方法可以更好地处理这个问题呢？其实处理特征选取任务最先进的算法之一就是遗传算法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们前面处理背包问题的方法可以完全应用到这里。现在，我们还是先从建立「染色体」总体开始，这里的染色体依旧是二进制数串，「1」表示模型包含了该特征，「0 表示模型排除了该特征」。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不过，有一个不同之处，即我们的适应度函数需要改变一下。这里的适应度函数应该是这次比赛的的精度的标准。也就是说，如果染色体的预测值越精准，那么就可以说它的适应度更高。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在我假设你已经对这个方法有点一概念了。下面我不会马上讲解这个问题的解决过程，而是让我们先来用 TPOT 库去实现它。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;5.2 用 TPOT 库来实现&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个部分相信是你在一开始读本文时心里最终想实现的那个目标。即：实现。那么首先我们来快速浏览一下 TPOT 库（Tree-based Pipeline Optimisation Technique，树形传递优化技术），该库基于 scikit-learn 库建立。下图为一个基本的传递结构。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5243243243243243&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicH4Y4vjNrcXwlsvPRXyrE9HgUxjftoYnS95lUAnCnMCfulWrcOclXBS549fmbQVpSquicgIcSU8LQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;925&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图中的灰色区域用 TPOT 库实现了自动处理。实现该部分的自动处理需要用到遗传算法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们这里不深入讲解，而是直接应用它。为了能够使用 TPOT 库，你需要先安装一些 TPOT 建立于其上的 python 库。下面我们快速安装它们：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;# installing DEAP, update_checker and tqdm &lt;/span&gt;&lt;br/&gt;&lt;br/&gt;pip install deap update_checker tqdm&lt;br/&gt;&lt;span&gt;# installling TPOT &lt;/span&gt;&lt;br/&gt;pip install tpot&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里，我用了 Big Mart Sales（数据集地址：https://datahack.analyticsvidhya.com/contest/practice-problem-big-mart-sales-iii/）数据集，为实现做准备，我们先快速下载训练和测试文件，以下是 python 代码：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;# import basic libraries&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; numpy &lt;span&gt;as&lt;/span&gt; np &lt;br/&gt;&lt;span&gt;import&lt;/span&gt; pandas &lt;span&gt;as&lt;/span&gt; pd &lt;br/&gt;&lt;span&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span&gt;as&lt;/span&gt; plt &lt;br/&gt;%matplotlib inline &lt;br/&gt;&lt;span&gt;from&lt;/span&gt; sklearn &lt;span&gt;import&lt;/span&gt; preprocessing &lt;br/&gt;&lt;span&gt;from&lt;/span&gt; sklearn.metrics &lt;span&gt;import&lt;/span&gt; mean_squared_error &lt;br/&gt;&lt;span&gt;## preprocessing &lt;/span&gt;&lt;br/&gt;&lt;span&gt;### mean imputations &lt;/span&gt;&lt;br/&gt;&lt;br/&gt;train[&lt;span&gt;&#x27;Item_Weight&#x27;&lt;/span&gt;].fillna((train[&lt;span&gt;&#x27;Item_Weight&#x27;&lt;/span&gt;].mean()), inplace=&lt;span&gt;True&lt;/span&gt;)&lt;br/&gt;test[&lt;span&gt;&#x27;Item_Weight&#x27;&lt;/span&gt;].fillna((test[&lt;span&gt;&#x27;Item_Weight&#x27;&lt;/span&gt;].mean()), inplace=&lt;span&gt;True&lt;/span&gt;) &lt;br/&gt;&lt;span&gt;### reducing fat content to only two categories &lt;/span&gt;&lt;br/&gt;&lt;br/&gt;train[&lt;span&gt;&#x27;Item_Fat_Content&#x27;&lt;/span&gt;] = train[&lt;span&gt;&#x27;Item_Fat_Content&#x27;&lt;/span&gt;].replace([&lt;span&gt;&#x27;low fat&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;LF&#x27;&lt;/span&gt;], [&lt;span&gt;&#x27;Low Fat&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;Low Fat&#x27;&lt;/span&gt;]) &lt;br/&gt;train[&lt;span&gt;&#x27;Item_Fat_Content&#x27;&lt;/span&gt;] = train[&lt;span&gt;&#x27;Item_Fat_Content&#x27;&lt;/span&gt;].replace([&lt;span&gt;&#x27;reg&#x27;&lt;/span&gt;], [&lt;span&gt;&#x27;Regular&#x27;&lt;/span&gt;]) &lt;br/&gt;test[&lt;span&gt;&#x27;Item_Fat_Content&#x27;&lt;/span&gt;] = test[&lt;span&gt;&#x27;Item_Fat_Content&#x27;&lt;/span&gt;].replace([&lt;span&gt;&#x27;low fat&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;LF&#x27;&lt;/span&gt;], [&lt;span&gt;&#x27;Low Fat&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;Low Fat&#x27;&lt;/span&gt;]) &lt;br/&gt;test[&lt;span&gt;&#x27;Item_Fat_Content&#x27;&lt;/span&gt;] = test[&lt;span&gt;&#x27;Item_Fat_Content&#x27;&lt;/span&gt;].replace([&lt;span&gt;&#x27;reg&#x27;&lt;/span&gt;], [&lt;span&gt;&#x27;Regular&#x27;&lt;/span&gt;]) &lt;br/&gt;train[&lt;span&gt;&#x27;Outlet_Establishment_Year&#x27;&lt;/span&gt;] = &lt;span&gt;2013&lt;/span&gt; - train[&lt;span&gt;&#x27;Outlet_Establishment_Year&#x27;&lt;/span&gt;] &lt;br/&gt;test[&lt;span&gt;&#x27;Outlet_Establishment_Year&#x27;&lt;/span&gt;] = &lt;span&gt;2013&lt;/span&gt; - test[&lt;span&gt;&#x27;Outlet_Establishment_Year&#x27;&lt;/span&gt;] &lt;br/&gt;&lt;br/&gt;train[&lt;span&gt;&#x27;Outlet_Size&#x27;&lt;/span&gt;].fillna(&lt;span&gt;&#x27;Small&#x27;&lt;/span&gt;,inplace=&lt;span&gt;True&lt;/span&gt;)&lt;br/&gt;test[&lt;span&gt;&#x27;Outlet_Size&#x27;&lt;/span&gt;].fillna(&lt;span&gt;&#x27;Small&#x27;&lt;/span&gt;,inplace=&lt;span&gt;True&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;train[&lt;span&gt;&#x27;Item_Visibility&#x27;&lt;/span&gt;] = np.sqrt(train[&lt;span&gt;&#x27;Item_Visibility&#x27;&lt;/span&gt;])&lt;br/&gt;test[&lt;span&gt;&#x27;Item_Visibility&#x27;&lt;/span&gt;] = np.sqrt(test[&lt;span&gt;&#x27;Item_Visibility&#x27;&lt;/span&gt;])&lt;br/&gt;&lt;br/&gt;col = [&lt;span&gt;&#x27;Outlet_Size&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;Outlet_Location_Type&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;Outlet_Type&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;Item_Fat_Content&#x27;&lt;/span&gt;]&lt;br/&gt;test[&lt;span&gt;&#x27;Item_Outlet_Sales&#x27;&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;combi = train.append(test)&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; col:&lt;br/&gt; combi[i] = number.fit_transform(combi[i].astype(&lt;span&gt;&#x27;str&#x27;&lt;/span&gt;))&lt;br/&gt; combi[i] = combi[i].astype(&lt;span&gt;&#x27;object&#x27;&lt;/span&gt;)&lt;br/&gt;train = combi[:train.shape[&lt;span&gt;0&lt;/span&gt;]]&lt;br/&gt;test = combi[train.shape[&lt;span&gt;0&lt;/span&gt;]:]&lt;br/&gt;test.drop(&lt;span&gt;&#x27;Item_Outlet_Sales&#x27;&lt;/span&gt;,axis=&lt;span&gt;1&lt;/span&gt;,inplace=&lt;span&gt;True&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;## removing id variables &lt;/span&gt;&lt;br/&gt;&lt;br/&gt;tpot_train = train.drop([&lt;span&gt;&#x27;Outlet_Identifier&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;Item_Type&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;Item_Identifier&#x27;&lt;/span&gt;],axis=&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;tpot_test = test.drop([&lt;span&gt;&#x27;Outlet_Identifier&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;Item_Type&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;Item_Identifier&#x27;&lt;/span&gt;],axis=&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;target = tpot_train[&lt;span&gt;&#x27;Item_Outlet_Sales&#x27;&lt;/span&gt;]&lt;br/&gt;tpot_train.drop(&lt;span&gt;&#x27;Item_Outlet_Sales&#x27;&lt;/span&gt;,axis=&lt;span&gt;1&lt;/span&gt;,inplace=&lt;span&gt;True&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;# finally building model using tpot library&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; tpot &lt;span&gt;import&lt;/span&gt; TPOTRegressor&lt;br/&gt;X_train, X_test, y_train, y_test = train_test_split(tpot_train, target,&lt;br/&gt; train_size=&lt;span&gt;0.75&lt;/span&gt;, test_size=&lt;span&gt;0.25&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;tpot = TPOTRegressor(generations=&lt;span&gt;5&lt;/span&gt;, population_size=&lt;span&gt;50&lt;/span&gt;, verbosity=&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;tpot.fit(X_train, y_train)&lt;br/&gt;print(tpot.score(X_test, y_test))&lt;br/&gt;tpot.export(&lt;span&gt;&#x27;tpot_boston_pipeline.py&#x27;&lt;/span&gt;)&lt;span/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46806569343065696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicH4Y4vjNrcXwlsvPRXyrE9uqsIFIqmWHQtOXWCS6fXdWPYdqouWHllicG0DmqgzygWham9URGH5pw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1096&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一旦这些代码运行完成，tpot_exported_pipeline.py 里就将会放入用于路径优化的 python 代码。我们可以发现，ExtraTreeRegressor 可以最好地解决这个问题。&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;## predicting using tpot optimised pipeline&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;tpot_pred = tpot.predict(tpot_test)&lt;br/&gt;sub1 = pd.DataFrame(data=tpot_pred)&lt;br/&gt;&lt;span&gt;#sub1.index = np.arange(0, len(test)+1)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;sub1 = sub1.rename(columns = {&lt;span&gt;&#x27;0&#x27;&lt;/span&gt;:&lt;span&gt;&#x27;Item_Outlet_Sales&#x27;&lt;/span&gt;})&lt;br/&gt;sub1[&lt;span&gt;&#x27;Item_Identifier&#x27;&lt;/span&gt;] = test[&lt;span&gt;&#x27;Item_Identifier&#x27;&lt;/span&gt;]&lt;br/&gt;sub1[&lt;span&gt;&#x27;Outlet_Identifier&#x27;&lt;/span&gt;] = test[&lt;span&gt;&#x27;Outlet_Identifier&#x27;&lt;/span&gt;]&lt;br/&gt;sub1.columns = [&lt;span&gt;&#x27;Item_Outlet_Sales&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;Item_Identifier&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;Outlet_Identifier&#x27;&lt;/span&gt;]&lt;br/&gt;sub1 = sub1[[&lt;span&gt;&#x27;Item_Identifier&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;Outlet_Identifier&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;Item_Outlet_Sales&#x27;&lt;/span&gt;]]&lt;br/&gt;sub1.to_csv(&lt;span&gt;&#x27;tpot.csv&#x27;&lt;/span&gt;,index=&lt;span&gt;False&lt;/span&gt;)&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;如果你提交了这个 csv，那么你会发现我一开始保证的那些还没有完全实现。那是不是我在骗你们呢？当然不是。实际上，TPOT 库有一个简单的规则。如果你不运行 TPOT 太久，那么它就不会为你的问题找出最可能传递方式。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，你得增加进化的代数，拿杯咖啡出去走一遭，其它的交给 TPOT 就行。此外，你也可以用这个库来处理分类问题。进一步内容可以参考这个文档：http://rhiever.github.io/tpot/。除了比赛，在生活中我们也有很多应用场景可以用到遗传算法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;6、 实际应用&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;遗传算法在真实世界中有很多应用。这里我列了部分有趣的场景，但是由于篇幅限制，我不会逐一详细介绍。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;6.1 工程设计&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;工程设计非常依赖计算机建模以及模拟，这样才能让设计周期过程即快又经济。遗传算法在这里可以进行优化并给出一个很好的结果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;相关资源：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;6.2 交通与船运路线（Travelling Salesman Problem，巡回售货员问题）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这是一个非常著名的问题，它已被很多贸易公司用来让运输更省时、经济。解决这个问题也要用到遗传算法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6237006237006237&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicH4Y4vjNrcXwlsvPRXyrE9qF0iaaJfh4TibNiajGzeZRUvVfiafuQbvOqonFYZO7ccyGh8Nct6uic0kew/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;962&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6242171189979123&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicH4Y4vjNrcXwlsvPRXyrE9SMOwqWx8I2fNILz9luCqOB76f9yJrQ0eYyo7H1begicXicj471VpCxWQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;958&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;6.3 机器人&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;遗传算法在机器人领域中的应用非常广泛。实际上，目前人们正在用遗传算法来创造可以像人类一样行动的自主学习机器人，其执行的任务可以是做饭、洗衣服等等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;相关资源：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;7、结语&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;希望通过本文介绍，你现在已经对遗传算法有了足够的理解，而且也会用 TPOT 库来实现它了。但是如果你不亲身实践，本文的知识也是非常有限的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，请各位读者朋友一定要在无论是数据科学比赛或是生活中尝试自己去实现它。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;原文链接：https://www.analyticsvidhya.com/blog/2017/07/introduction-to-genetic-algorithm/&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUzODYwMDAzNA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/NOM5HN2icXzy3oUJC81lHlcGDwlibYtVXDSYeqoFaryPvqlHlNBibLibKGcA9jyVJFAIoKenjxqSpItzhBLqR9DBMw/0?wx_fmt=png&quot; data-nickname=&quot;Python数据科学&quot; data-alias=&quot;PyDataScience&quot; data-signature=&quot;以Python为核心语言，专攻于「数据科学」领域，文章涵盖数据分析，数据挖掘，机器学习等干货内容，分享大量数据挖掘实战项目分析和讲解，以及海量的学习资源。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUzODYwMDAzNA==&amp;amp;action=getalbum&amp;amp;album_id=1699019347278561282#wechat_redirect&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;1. &lt;/span&gt;pandas100个骚操作&lt;/em&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;em&gt;2. &lt;/em&gt;&lt;em&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUzODYwMDAzNA==&amp;amp;action=getalbum&amp;amp;album_id=2217035551810125830#wechat_redirect&quot; textvalue=&quot;pandas数据清洗&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;pandas数据清洗&lt;/a&gt;&lt;/span&gt;&lt;/em&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;3 &lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUzODYwMDAzNA==&amp;amp;action=getalbum&amp;amp;album_id=1838255778403581970#wechat_redirect&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span&gt;&lt;em&gt;机器学习原创系列&lt;/em&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>26effba2be7c38dcf1f8d8e21ce68bac</guid>
<title>关于 Android MVVM 一些理解与实践</title>
<link>https://toutiao.io/k/en9y6w8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是MVVM？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先上图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3622159090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1c2u08YZrdroIGo0RPhFPTw2RfTjZXiaxzlcLjcjLa66bqpgEnibm8bGqJE1Dnv5PsiaISRXwBBdUvdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;704&quot;/&gt;&lt;figcaption&gt;1813550.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;viewmodel可以理解为桥梁，通过viewmodel 将 View和Model双向绑定，数据的变化可以直接作用在View上，就是MVVM，其实MVVM，MVP都是在MVC的基础上演变而来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;MVVM与DataBinding的关系&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MVVM是架构思想，没有固定的套路，你可以基于这个思想整个自己的MVVM框架。而DataBinding就是基于MVVM思想实现的一个框架。目前也是android MVVM 开发的主流框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;JetPack的ViewModel 与MVVM中ViewModel的关系&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有位大佬说过它们两个没有关系不是一个东西。其实这句话说要看怎么说. JetPack 的 ViewModel 官方给的定义是&lt;strong&gt;旨在存储和管理生命周期的方式与UI相关的数据&lt;/strong&gt;,而MVVM中的viewmodel是连接View与Model的纽带。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;不使用jetPack的ViewModel，我们可以自己实现一个ViewModel&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Presenter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;val&lt;/span&gt; size = ObservableField&amp;lt;&lt;span&gt;Int&lt;/span&gt;&amp;gt;()&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fun&lt;/span&gt; &lt;span&gt;numChange&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        size.&lt;span&gt;set&lt;/span&gt;(size.&lt;span&gt;get&lt;/span&gt;() + &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;        size.notifyChange()&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;xml 数据绑定&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;layout&lt;/span&gt; &lt;span&gt;xmlns:android&lt;/span&gt;=&lt;span&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;xmlns:app&lt;/span&gt;=&lt;span&gt;&quot;http://schemas.android.com/apk/res-auto&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;xmlns:tools&lt;/span&gt;=&lt;span&gt;&quot;http://schemas.android.com/tools&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;data&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;variable&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;presenter&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;com.example.myapplication.Presenter&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;data&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;android:gravity&lt;/span&gt;=&lt;span&gt;&quot;center_horizontal&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;android:orientation&lt;/span&gt;=&lt;span&gt;&quot;vertical&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;android:layout_width&lt;/span&gt;=&lt;span&gt;&quot;match_parent&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;android:layout_height&lt;/span&gt;=&lt;span&gt;&quot;match_parent&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;tools:context&lt;/span&gt;=&lt;span&gt;&quot;.MainActivity&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;TextView&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;android:layout_marginTop&lt;/span&gt;=&lt;span&gt;&quot;50dp&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;android:layout_width&lt;/span&gt;=&lt;span&gt;&quot;wrap_content&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;android:layout_height&lt;/span&gt;=&lt;span&gt;&quot;wrap_content&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;android:text&lt;/span&gt;=&lt;span&gt;&quot;@{presenter.size.toString()}&quot;&lt;/span&gt;&lt;br/&gt;         /&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;Button&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;android:onClick&lt;/span&gt;=&lt;span&gt;&quot;@{()-&amp;gt;presenter.numChange()}&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;android:layout_marginTop&lt;/span&gt;=&lt;span&gt;&quot;20dp&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;android:background&lt;/span&gt;=&lt;span&gt;&quot;@color/black&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;android:text&lt;/span&gt;=&lt;span&gt;&quot;点击数字自增&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;android:layout_width&lt;/span&gt;=&lt;span&gt;&quot;150dp&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;android:layout_height&lt;/span&gt;=&lt;span&gt;&quot;wrap_content&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;Button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;LinearLayout&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;layout&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是这样的情况,MVVM ViewMoel 是我们自己定义的Presenter类实现的，JetPack的ViewModel 和MVVM的ViewModel确实没有关系。但是因为我们自己定义的ViewModel实现类，在实际开发中会有很多问题，最突出就是没有生命周期的管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以你会想到什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用JetPack的ViewModel来承担MVVM的ViewModel的职责。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MainViewModel&lt;/span&gt; : &lt;span&gt;ViewModel&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;val&lt;/span&gt; size = MutableLiveData&amp;lt;&lt;span&gt;Int&lt;/span&gt;&amp;gt;().apply { &lt;span&gt;this&lt;/span&gt;.value = &lt;span&gt;0&lt;/span&gt; }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fun&lt;/span&gt; &lt;span&gt;numChange&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        size.postValue((size.value ?: &lt;span&gt;0&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;layout&lt;/span&gt; &lt;span&gt;xmlns:android&lt;/span&gt;=&lt;span&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;xmlns:app&lt;/span&gt;=&lt;span&gt;&quot;http://schemas.android.com/apk/res-auto&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;xmlns:tools&lt;/span&gt;=&lt;span&gt;&quot;http://schemas.android.com/tools&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;data&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;variable&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;mainViewModel&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;com.example.myapplication.MainViewModel&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;data&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;android:gravity&lt;/span&gt;=&lt;span&gt;&quot;center_horizontal&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;android:orientation&lt;/span&gt;=&lt;span&gt;&quot;vertical&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;android:layout_width&lt;/span&gt;=&lt;span&gt;&quot;match_parent&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;android:layout_height&lt;/span&gt;=&lt;span&gt;&quot;match_parent&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;tools:context&lt;/span&gt;=&lt;span&gt;&quot;.MainActivity&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;TextView&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;android:layout_marginTop&lt;/span&gt;=&lt;span&gt;&quot;50dp&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;android:layout_width&lt;/span&gt;=&lt;span&gt;&quot;wrap_content&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;android:layout_height&lt;/span&gt;=&lt;span&gt;&quot;wrap_content&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;android:text&lt;/span&gt;=&lt;span&gt;&quot;@{mainViewModel.size.toString()}&quot;&lt;/span&gt;&lt;br/&gt;           /&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;Button&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;android:onClick&lt;/span&gt;=&lt;span&gt;&quot;@{()-&amp;gt;mainViewModel.numChange()}&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;android:layout_marginTop&lt;/span&gt;=&lt;span&gt;&quot;20dp&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;android:background&lt;/span&gt;=&lt;span&gt;&quot;@color/black&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;android:text&lt;/span&gt;=&lt;span&gt;&quot;点击数字自增&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;android:layout_width&lt;/span&gt;=&lt;span&gt;&quot;150dp&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;android:layout_height&lt;/span&gt;=&lt;span&gt;&quot;wrap_content&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;Button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;LinearLayout&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;layout&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MainActivity&lt;/span&gt; : &lt;span&gt;AppCompatActivity&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;override&lt;/span&gt; &lt;span&gt;&lt;span&gt;fun&lt;/span&gt; &lt;span&gt;onCreate&lt;/span&gt;&lt;span&gt;(savedInstanceState: &lt;span&gt;Bundle&lt;/span&gt;?)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;.onCreate(savedInstanceState)&lt;br/&gt;        &lt;span&gt;val&lt;/span&gt; binding = DataBindingUtil.setContentView&amp;lt;ActivityMainBinding&amp;gt;(&lt;span&gt;this&lt;/span&gt;, R.layout.activity_main)&lt;br/&gt;        binding.lifecycleOwner = &lt;span&gt;this&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;val&lt;/span&gt; viewModel = ViewModelProvider(&lt;span&gt;this&lt;/span&gt;).&lt;span&gt;get&lt;/span&gt;(MainViewModel::&lt;span&gt;&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;java&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//将viewModel 数据 赋值给  View 声明的变量&lt;/span&gt;&lt;br/&gt;        binding.setVariable(BR.mainViewModel,viewModel)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gradle 的anroid 配置&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; dataBinding {&lt;br/&gt;        enabled = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gradle 的 dependencies 配置&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;dependencies&lt;/span&gt; {&lt;br/&gt;    implementation &lt;span&gt;&quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot;&lt;/span&gt;&lt;br/&gt;    implementation &lt;span&gt;&#x27;androidx.core:core-ktx:1.3.2&#x27;&lt;/span&gt;&lt;br/&gt;    implementation &lt;span&gt;&#x27;androidx.appcompat:appcompat:1.2.0&#x27;&lt;/span&gt;&lt;br/&gt;    implementation &lt;span&gt;&#x27;com.google.android.material:material:1.2.1&#x27;&lt;/span&gt;&lt;br/&gt;    implementation &lt;span&gt;&#x27;androidx.constraintlayout:constraintlayout:2.0.4&#x27;&lt;/span&gt;&lt;br/&gt;    testImplementation &lt;span&gt;&#x27;junit:junit:4.13.1&#x27;&lt;/span&gt;&lt;br/&gt;    androidTestImplementation &lt;span&gt;&#x27;androidx.test.ext:junit:1.1.2&#x27;&lt;/span&gt;&lt;br/&gt;    androidTestImplementation &lt;span&gt;&#x27;androidx.test.espresso:espresso-core:3.3.0&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;def&lt;/span&gt; lifecycle_version = &lt;span&gt;&quot;2.2.0&quot;&lt;/span&gt;&lt;br/&gt;    implementation &lt;span&gt;&quot;androidx.lifecycle:lifecycle-extensions:$lifecycle_version&quot;&lt;/span&gt;&lt;br/&gt;    implementation &lt;span&gt;&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version&quot;&lt;/span&gt;&lt;br/&gt;    implementation &lt;span&gt;&quot;androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是这中情况，那么JetPack的ViewModel 等同于 MVVM的ViewModel，当然JetPack的ViewModel还能干其他事，承担MVVM的ViewModel 仅是一个兼职。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.01067615658363&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1c2u08YZrdroIGo0RPhFPTwlbxdCVLxUczFkiaZLFtadwlbmQqfqvA7Z4Q9DG4NyA1XYdnl5Rwsm3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;562&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;android.gif&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对比了一下Vue的MVVM的实现&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;{{ size }}&lt;span&gt;&amp;lt;/&lt;span&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&quot;numChange&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;点击数字自增&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;methods&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;numChange&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.size = &lt;span&gt;this&lt;/span&gt;.size + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;data&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;size&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;style lang=&lt;span&gt;&quot;less&quot;&lt;/span&gt; scoped&amp;gt;&amp;lt;/style&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.5056947608200455&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1c2u08YZrdroIGo0RPhFPTwGBUBsTn2aGsQZmH8lDBD6xfpqqIC5K3ERmlpwVGl4BOUpeRH9kGNGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;439&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vue.gif&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两者都是在View层绑定了 size 变量 , 数据声明与方法的都在ViewModel中，（Vue的export default 也承担了MVVM中viewmodel的职责，当然了这也是它的一个兼职）&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;补充&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DataBinding 中的bindAdapter 还可以将每个控件单独处理，使结构更加松散，逻辑不会耦合在Activity中或者ViewModel里，特别在复杂的交互场景下需求迭代频繁的时候，MVVM太香了。相见恨晚，往事回想，泪目( Ĭ ^ Ĭ )&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;相关阅读&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNzU1Nzk3OQ==&amp;amp;mid=2247490373&amp;amp;idx=1&amp;amp;sn=998e57055657bb540e1ecdba67bc61e7&amp;amp;chksm=97f6a5f1a0812ce7a06e640deb888ed3dc3b335ed07c6451f62b369f0913ab7db567f81383c9&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Android MVP &amp;amp;&amp;amp; MVVM深度解析&lt;/a&gt;&lt;br/&gt;2 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNzU1Nzk3OQ==&amp;amp;mid=2247490854&amp;amp;idx=1&amp;amp;sn=fd42545ab0fed68c354dd5df209646bd&amp;amp;chksm=97f6a392a0812a8494683c3162d2fec1983cfbfccd4eff64b78301b26e7dab420c0f260440a2&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Google 推荐在 MVVM 架构中使用 Kotlin Flow&lt;/a&gt;&lt;br/&gt;3 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNzU1Nzk3OQ==&amp;amp;mid=2247491798&amp;amp;idx=1&amp;amp;sn=c47ae5c4f6a66eefdd5c6288b70ed684&amp;amp;chksm=97f55e62a082d77416b1202cd144e1af4577842567dc71513175638d6a65eebe13f1e6574ff8&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Android：MVVM 的工作原理之创建、销毁、保存、复用&lt;/a&gt;&lt;br/&gt;4 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNzU1Nzk3OQ==&amp;amp;mid=2247489827&amp;amp;idx=1&amp;amp;sn=df839c372dd046803d52f0347b7394b4&amp;amp;chksm=97f6a797a0812e81e99fc37c6441ea4971d97970256fbd07cc63ad44b41290a33df5fdb0c47e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;MVVM 最新学习心得&lt;/a&gt;&lt;br/&gt;5 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNzU1Nzk3OQ==&amp;amp;mid=2247489729&amp;amp;idx=1&amp;amp;sn=258c447cabb9878783c1b8e28d243361&amp;amp;chksm=97f6a675a0812f6356764805703a56b6320e656401d18c171b292fa6fb5ae6fac61c751b2207&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Android 从 MVP 到 MVVM&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d963ebbb486104fbbae6fdfc665ad856</guid>
<title>JSON神器之jq使用指南指北</title>
<link>https://toutiao.io/k/pzyy5co</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p&gt;1. 美化输出Json：&lt;/p&gt;
&lt;p&gt; 2. 只输出部分字段&lt;/p&gt;
&lt;section id=&quot;Invokingjq&quot;&gt;&lt;hr/&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;命令行参数&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这里大部分从官网翻译过来的，有问题请帮指点~&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;jq 过滤器在 JSON 数据流上运行。jq 的输入被解析为一系列以空格分隔的 JSON 值，一次一个地通过提供的过滤器。过滤器的输出被写入标准输出，同样是一系列以空格分隔的 JSON 数据。&lt;/p&gt;
&lt;p&gt;注意：注意 shell 的引用规则很重要。作为一般规则，最好总是引用（使用单引号字符） jq 程序，因为太多对 jq 具有特殊含义的字符也是 shell 元字符。例如，&lt;code&gt;jq &quot;foo&quot;&lt;/code&gt;在大多数 Unix shell 上会失败，因为这与 相同&lt;code&gt;jq foo&lt;/code&gt;，通常会失败，因为&lt;code&gt;foo is not defined&lt;/code&gt;. 使用 Windows 命令 shell (cmd.exe) 时，最好在命令行中给出 jq 程序时使用双引号（而不是&lt;code&gt;-f program-file&lt;/code&gt;选项），但是 jq 程序中的双引号需要反斜杠转义。&lt;/p&gt;
&lt;p&gt;您可以使用一些命令行选项影响 jq 如何读取和写入其输入和输出：&lt;/p&gt;

&lt;p&gt;输出 jq 版本并以零退出。&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;application/json-seq&lt;/code&gt;MIME 类型方案在 jq 的输入和输出中分隔 JSON 文本。这意味着在输出的每个值之前打印一个 ASCII RS（记录分隔符）字符，并且在每个输出之后打印一个 ASCII LF（换行符）。无法解析的输入 JSON 文本将被忽略（但警告），丢弃所有后续输入，直到下一个 RS。此模式还解析 jq 的输出而不使用该&lt;code&gt;--seq&lt;/code&gt; 选项。&lt;/p&gt;

&lt;p&gt;以流方式解析输入，输出路径和叶值数组（标量和空数组或空对象）。例如，&lt;code&gt;&quot;a&quot;&lt;/code&gt;变成&lt;code&gt;[[],&quot;a&quot;]&lt;/code&gt;，&lt;code&gt;[[],&quot;a&quot;,[&quot;b&quot;]]&lt;/code&gt; 变成&lt;code&gt;[[0],[]]&lt;/code&gt;，&lt;code&gt;[[1],&quot;a&quot;]&lt;/code&gt;，和&lt;code&gt;[[1,0],&quot;b&quot;]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这对于处理非常大的输入很有用。将此与过滤和&lt;code&gt;reduce&lt;/code&gt;and&lt;code&gt;foreach&lt;/code&gt;语法结合使用，以逐步减少大输入。&lt;/p&gt;

&lt;p&gt;不要为输入中的每个 JSON 对象运行过滤器，而是将整个输入流读入一个大数组并只运行一次过滤器。&lt;/p&gt;

&lt;p&gt;不要将输入解析为 JSON。相反，每一行文本都作为字符串传递给过滤器。如果与 结合使用&lt;code&gt;--slurp&lt;/code&gt;，则整个输入将作为单个长字符串传递给过滤器。&lt;/p&gt;

&lt;p&gt;根本不读取任何输入！相反，过滤器&lt;code&gt;null&lt;/code&gt;作为输入运行一次。这在将 jq 用作简单的计算器或从头构建 JSON 数据时很有用。&lt;/p&gt;

&lt;p&gt;默认情况下，jq 漂亮地打印 JSON 输出。使用此选项将通过将每个 JSON 对象放在一行中来生成更紧凑的输出。&lt;/p&gt;

&lt;p&gt;每个缩进级别使用一个制表符，而不是两个空格。&lt;/p&gt;

&lt;p&gt;使用给定数量的空格（不超过 7 个）进行缩进。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--color-output&lt;/code&gt;/&lt;code&gt;-C&lt;/code&gt;和&lt;code&gt;--monochrome-output&lt;/code&gt;/ &lt;code&gt;-M&lt;/code&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认情况下，如果写入终端，jq 会输出彩色 JSON。即使使用 写入管道或文件，您也可以强制它产生颜色&lt;code&gt;-C&lt;/code&gt;，并使用 禁用颜色&lt;code&gt;-M&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可以使用&lt;code&gt;JQ_COLORS&lt;/code&gt;环境变量配置颜色（见下文）。&lt;/p&gt;

&lt;p&gt;使用 WSL、MSYS2 或 Cygwin 的 Windows 用户在使用本机 jq.exe 时应使用此选项，否则 jq 会将换行符 (LF) 转换为回车换行符 (CRLF)。&lt;/p&gt;

&lt;p&gt;jq 通常将非 ASCII Unicode 代码点输出为 UTF-8，即使输入将它们指定为转义序列（如“\u03bc”）。使用此选项，您可以强制 jq 生成纯 ASCII 输出，并将每个非 ASCII 字符替换为等效的转义序列。&lt;/p&gt;

&lt;p&gt;在打印每个 JSON 对象后刷新输出（如果您将慢速数据源传送到 jq 并将 jq 的输出传送到其他地方，这很有用）。&lt;/p&gt;

&lt;p&gt;按排序顺序输出每个对象的字段和键。&lt;/p&gt;

&lt;p&gt;使用此选项，如果过滤器的结果是字符串，那么它将直接写入标准输出，而不是格式化为带引号的 JSON 字符串。这对于使 jq 过滤器与非基于 JSON 的系统对话很有用。&lt;/p&gt;

&lt;p&gt;Like&lt;code&gt;-r&lt;/code&gt;但 jq 不会在每次输出后打印换行符。&lt;/p&gt;

&lt;p&gt;像&lt;code&gt;-r&lt;/code&gt;，但 jq 将在每次输出后打印 NUL 而不是换行符。当输出的值可以包含换行符时，这可能很有用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-f filename&lt;/code&gt;/ &lt;code&gt;--from-file filename&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从文件而不是从命令行读取过滤器，如 awk 的 -f 选项。您也可以使用“#”来发表评论。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-Ldirectory&lt;/code&gt;/ &lt;code&gt;-L directory&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;预先&lt;code&gt;directory&lt;/code&gt;添加到模块的搜索列表中。如果使用此选项，则不使用内置搜索列表。请参阅下面的模块部分。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;false&lt;/code&gt;如果最后一个输出值不是nor &lt;code&gt;null&lt;/code&gt;，则将jq 的退出状态设置为 0，如果最后一个输出值是&lt;code&gt;false&lt;/code&gt;or &lt;code&gt;null&lt;/code&gt;，则设置为 1，如果没有产生有效结果，则设置为 4。如果有任何使用问题或系统错误，jq 通常退出 2，如果有 jq 程序编译错误，则退出 3，或者如果 jq 程序运行，则退出 0。&lt;/p&gt;
&lt;p&gt;另一种设置退出状态的方法是使用&lt;code&gt;halt_error&lt;/code&gt; 内置函数。&lt;/p&gt;

&lt;p&gt;此选项将值作为预定义变量传递给 jq 程序。如果您使用 运行 jq &lt;code&gt;--arg foo bar&lt;/code&gt;，则&lt;code&gt;$foo&lt;/code&gt;在程序中可用并具有值&lt;code&gt;&quot;bar&quot;&lt;/code&gt;。请注意， &lt;code&gt;value&lt;/code&gt;将被视为字符串，因此&lt;code&gt;--arg foo 123&lt;/code&gt;将绑定&lt;code&gt;$foo&lt;/code&gt;到&lt;code&gt;&quot;123&quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;jq 程序也可以使用命名参数作为 &lt;code&gt;$ARGS.named&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--argjson name JSON-text&lt;/code&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此选项将 JSON 编码的值作为预定义变量传递给 jq 程序。如果您使用 运行 jq &lt;code&gt;--argjson foo 123&lt;/code&gt;，则 &lt;code&gt;$foo&lt;/code&gt;在程序中可用并具有值&lt;code&gt;123&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--slurpfile variable-name filename&lt;/code&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此选项读取命名文件中的所有 JSON 文本，并将解析的 JSON 值的数组绑定到给定的全局变量。如果您使用 运行 jq &lt;code&gt;--slurpfile foo bar&lt;/code&gt;，则&lt;code&gt;$foo&lt;/code&gt;在程序中可用，并且有一个数组，其元素对应于名为 的文件中的文本&lt;code&gt;bar&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--rawfile variable-name filename&lt;/code&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此选项读入命名文件并将其内容绑定到给定的全局变量。如果你运行 jq with &lt;code&gt;--rawfile foo bar&lt;/code&gt;, then&lt;code&gt;$foo&lt;/code&gt;在程序中是可用的，并且有一个字符串，其内容是文件中的 texs 名为&lt;code&gt;bar&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--argfile variable-name filename&lt;/code&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不使用。改为使用&lt;code&gt;--slurpfile&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;（此选项类似于&lt;code&gt;--slurpfile&lt;/code&gt;，但当文件只有一个文本时，则使用该文本，否则使用文本数组，如&lt;code&gt;--slurpfile&lt;/code&gt;。）&lt;/p&gt;

&lt;p&gt;其余参数是位置字符串参数。这些可用于 jq 程序作为&lt;code&gt;$ARGS.positional[]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;其余参数是位置 JSON 文本参数。这些可用于 jq 程序作为&lt;code&gt;$ARGS.positional[]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;在给定文件或标准输入中运行测试。这必须是给出的最后一个选项，并且不支持所有前面的选项。输入由注释行、空行和程序行组成，后跟一个输入行，与预期一样多的输出行（每个输出一个），以及一个终止空行。编译失败测试从仅包含“%%FAIL”的行开始，然后是包含要编译的程序的行，然后是包含要与实际进行比较的错误消息的行。&lt;/p&gt;
&lt;p&gt;请注意，此选项可能会向后不兼容地更改。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;TypesandValues&quot;&gt;
&lt;h2&gt;类型和值&lt;/h2&gt;
&lt;p&gt;jq 支持与 JSON 相同的数据类型集 - 数字、字符串、布尔值、数组、对象（在 JSON 中是只有字符串键的散列）和“null”。&lt;/p&gt;
&lt;p&gt;布尔值、空值、字符串和数字的编写方式与 javascript 相同。就像 jq 中的其他所有内容一样，这些简单的值接受一个输入并产生一个输出 -&lt;code&gt;42&lt;/code&gt;是一个有效的 jq 表达式，它接受一个输入，忽略它，并返回 42。&lt;/p&gt;
&lt;section id=&quot;Arrayconstruction:[]&quot;&gt;
&lt;h3&gt;数组构造：&lt;code&gt;[]&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;在 JSON 中，&lt;code&gt;[]&lt;/code&gt;用于构造数组，如在 &lt;code&gt;[1,2,3]&lt;/code&gt;. 数组的元素可以是任何 jq 表达式，包括管道。所有表达式产生的所有结果都收集到一个大数组中。您可以使用它从已知数量的值中构造一个数组（如&lt;code&gt;[.foo, .bar, .baz]&lt;/code&gt;）或将过滤器的所有结果“收集”到一个数组中（如&lt;code&gt;[.items[].name]&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;一旦你理解了 &quot;,&quot; 操作符，你就可以从不同的角度来看待 jq 的数组语法：表达式&lt;code&gt;[1,2,3]&lt;/code&gt;没有使用逗号分隔数组的内置语法，而是将&lt;code&gt;[]&lt;/code&gt;操作符（收集结果）应用于表达式1,2,3（产生三种不同的结果）。&lt;/p&gt;
&lt;p&gt;如果您有一个&lt;code&gt;X&lt;/code&gt;产生四个结果的过滤器，那么表达式&lt;code&gt;[X]&lt;/code&gt;将产生一个结果，即一个由四个元素组成的数组。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;ObjectConstruction:{}&quot;&gt;
&lt;h3&gt;对象构造：&lt;code&gt;{}&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;像 JSON 一样，&lt;code&gt;{}&lt;/code&gt;用于构造对象（又名字典或哈希），如：&lt;code&gt;{&quot;a&quot;: 42, &quot;b&quot;: 17}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;如果键是“类似标识符”，则可以省略引号，如&lt;code&gt;{a:42, b:17}&lt;/code&gt;. 作为键表达式的变量引用使用变量的值作为键。常量文字、标识符或变量引用以外的关键表达式需要用括号括起来，例如 &lt;code&gt;{(&quot;a&quot;+&quot;b&quot;):59}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;该值可以是任何表达式（尽管您可能需要将其括在括号中，例如，如果它包含冒号），它将应用于 {} 表达式的输入（请记住，所有过滤器都有一个输入和一个输出）。&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{foo: .bar}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;{&quot;foo&quot;: 42}&lt;/code&gt;如果将 JSON 对象&lt;code&gt;{&quot;bar&quot;:42, &quot;baz&quot;:43}&lt;/code&gt;作为其输入，将生成 JSON 对象。您可以使用它来选择对象的特定字段：如果输入是具有“user”、“title”、“id”和“content”字段的对象，而您只需要“user”和“title”，则可以写&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{user: .user, title: .title}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为这很常见，所以有一个快捷语法： &lt;code&gt;{user, title}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;如果其中一个表达式产生多个结果，则将产生多个字典。如果输入的&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{&quot;user&quot;:&quot;stedolan&quot;,&quot;titles&quot;:[&quot;JQ Primer&quot;, &quot;More JQ&quot;]}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后表达式&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{user, title: .titles[]}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将产生两个输出：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{&quot;user&quot;:&quot;stedolan&quot;, &quot;title&quot;: &quot;JQ Primer&quot;}
{&quot;user&quot;:&quot;stedolan&quot;, &quot;title&quot;: &quot;More JQ&quot;}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在键周围加上括号意味着它将被评估为表达式。使用与上述相同的输入，&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{(.user): .titles}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{&quot;stedolan&quot;: [&quot;JQ Primer&quot;, &quot;More JQ&quot;]}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;作为键的变量引用使用变量的值作为键。如果没有值，则变量的名称将成为键，其值将成为值，&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;&quot;f o o&quot; as $foo | &quot;b a r&quot; as $bar | {$foo, $bar:$foo}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{&quot;f o o&quot;:&quot;f o o&quot;,&quot;b a r&quot;:&quot;f o o&quot;}&lt;/code&gt;&lt;/pre&gt;

&lt;/section&gt;
&lt;section id=&quot;RecursiveDescent:..&quot;&gt;
&lt;h3&gt;递归下降：&lt;code&gt;..&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;递归下降&lt;code&gt;.&lt;/code&gt;，产生每个值。这与内置的零参数相同&lt;code&gt;recurse&lt;/code&gt;（见下文）。这旨在类似于 XPath&lt;code&gt;//&lt;/code&gt;运算符。注意 &lt;code&gt;..a&lt;/code&gt;不起作用；改为使用&lt;code&gt;..|.a&lt;/code&gt;。在下面的示例中，我们使用&lt;code&gt;..|.a?&lt;/code&gt;在 &quot;below&quot; 找到的任何对象中查找对象键 &quot;a&quot; 的所有值&lt;code&gt;.&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这在与&lt;code&gt;path(EXP)&lt;/code&gt; （另见下文）和&lt;code&gt;?&lt;/code&gt;运算符结合使用时特别有用。&lt;/p&gt;
&lt;div&gt;
&lt;pre class=&quot;language-bash highlighter-hljs&quot;&gt;&lt;code&gt;echo &#x27;{&quot;a&quot;:{&quot;A&quot;:1,&quot;B&quot;:2}}&#x27;|jq &#x27;..&#x27;
{
  &quot;a&quot;: {
    &quot;A&quot;: 1,
    &quot;B&quot;: 2
  }
}
{
  &quot;A&quot;: 1,
  &quot;B&quot;: 2
}
1
2&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;Builtinoperatorsandfunctions&quot;&gt;
&lt;h2&gt;内置运算符和函数&lt;/h2&gt;
&lt;p&gt;一些 jq 运算符（例如&lt;code&gt;+&lt;/code&gt;）根据其参数的类型（数组、数字等）执行不同的操作。但是， jq 从不进行隐式类型转换。如果您尝试将字符串添加到对象，您将收到一条错误消息并且没有结果。&lt;/p&gt;
&lt;section id=&quot;Addition:+&quot;&gt;
&lt;h3&gt;添加：&lt;code&gt;+&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;运算符&lt;code&gt;+&lt;/code&gt;采用两个过滤器，将它们都应用于相同的输入，然后将结果相加。“添加”的含义取决于所涉及的类型：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;null&lt;/code&gt;可以添加到任何值，并返回其他值不变。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;Subtraction:-&quot;&gt;
&lt;h3&gt;减法：&lt;code&gt;-&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;除了对数字进行普通算术减法外，该&lt;code&gt;-&lt;/code&gt; 运算符还可用于数组以从第一个数组中删除第二个数组元素的所有出现。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;Multiplication,division,modulo:*,/,and%&quot;&gt;
&lt;h3&gt;乘法、除法、取模：&lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, 和&lt;code&gt;%&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;当给定两个数字时，这些中缀运算符的行为符合预期。除以零会引发错误。&lt;code&gt;x % y&lt;/code&gt;计算 x 模 y。&lt;/p&gt;
&lt;p&gt;将一个字符串乘以一个数字会产生多次串联该字符串。&lt;code&gt;&quot;x&quot; * 0&lt;/code&gt;产生&lt;strong&gt;null&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;将一个字符串除以另一个字符串会使用第二个字符串作为分隔符来拆分第一个字符串。&lt;/p&gt;
&lt;p&gt;将两个对象相乘将递归合并它们：这类似于加法，但如果两个对象都包含相同键的值，并且值是对象，则两者将使用相同的策略合并。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;length&quot;&gt;
&lt;h3&gt;&lt;code&gt;length&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;内置函数&lt;code&gt;length&lt;/code&gt;获取各种不同类型值的长度：&lt;/p&gt;


&lt;/section&gt;
&lt;section id=&quot;utf8bytelength&quot;&gt;
&lt;h3&gt;&lt;code&gt;utf8bytelength&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;内置函数&lt;code&gt;utf8bytelength&lt;/code&gt;输出用于以 UTF-8 编码字符串的字节数。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;keys,keys_unsorted&quot;&gt;
&lt;h3&gt;&lt;code&gt;keys&lt;/code&gt;,&lt;code&gt;keys_unsorted&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;内置函数&lt;code&gt;keys&lt;/code&gt;，当给定一个对象时，会在一个数组中返回它的键。&lt;/p&gt;
&lt;p&gt;键按 unicode 代码点顺序“按字母顺序”排序。这不是在任何特定语言中都特别有意义的顺序，但您可以指望它对于具有相同键集的任何两个对象都是相同的，而不管区域设置如何。&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;keys&lt;/code&gt;给定一个数组时，它返回该数组的有效索引：从 0 到 length-1 的整数。&lt;/p&gt;
&lt;p&gt;该&lt;code&gt;keys_unsorted&lt;/code&gt;函数就像&lt;code&gt;keys&lt;/code&gt;，但如果输入是一个对象，那么键将不会被排序，而是键将大致按插入顺序排列。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;has(key)&quot;&gt;
&lt;h3&gt;&lt;code&gt;has(key)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;内置函数&lt;code&gt;has&lt;/code&gt;返回输入对象是否具有给定键，或者输入数组在给定索引处是否具有元素。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;has($key)&lt;/code&gt;&lt;code&gt;$key&lt;/code&gt; 与检查是否是由 返回的数组的成员具有相同的效果&lt;code&gt;keys&lt;/code&gt;，但&lt;code&gt;has&lt;/code&gt; 会更快。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;in&quot;&gt;
&lt;h3&gt;&lt;code&gt;in&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;内置函数&lt;code&gt;in&lt;/code&gt;返回输入键是否在给定对象中，或者输入索引是否对应于给定数组中的元素。它本质上是&lt;code&gt;has&lt;/code&gt;.&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;map(x),map_values(x)&quot;&gt;
&lt;h3&gt;&lt;code&gt;map(x)&lt;/code&gt;,&lt;code&gt;map_values(x)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;对于任何 filter &lt;code&gt;x&lt;/code&gt;，&lt;code&gt;map(x)&lt;/code&gt;将为输入数组的每个元素运行该过滤器，并在新数组中返回输出。&lt;code&gt;map(.+1)&lt;/code&gt;将递增数字数组的每个元素。&lt;/p&gt;
&lt;p&gt;同样，&lt;code&gt;map_values(x)&lt;/code&gt;将为每个元素运行该过滤器，但是当传递一个对象时它将返回一个对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map(x)&lt;/code&gt;相当于&lt;code&gt;[.[] | x]&lt;/code&gt;。事实上，这就是它的定义方式。同样，&lt;code&gt;map_values(x)&lt;/code&gt;定义为&lt;code&gt;.[] |= x&lt;/code&gt;。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;path(path_expression)&quot;&gt;
&lt;h3&gt;&lt;code&gt;path(path_expression)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;输出给定路径表达式的数组表示形式&lt;code&gt;.&lt;/code&gt;。输出是字符串数组（对象键）和/或数字（数组索引）。&lt;/p&gt;
&lt;p&gt;路径表达式是 jq 表达式，例如&lt;code&gt;.a&lt;/code&gt;, 也是&lt;code&gt;.[]&lt;/code&gt;. 有两种类型的路径表达式：一种可以完全匹配，另一种不能。例如，&lt;code&gt;.a.b.c&lt;/code&gt;is 是一个完全匹配的路径表达式，while&lt;code&gt;.a[].b&lt;/code&gt;不是。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;path(exact_path_expression)&lt;/code&gt;将产生路径表达式的数组表示，即使它不存在于&lt;code&gt;.&lt;/code&gt;, if &lt;code&gt;.&lt;/code&gt;is&lt;code&gt;null&lt;/code&gt;或数组或对象中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;path(pattern)&lt;/code&gt;如果路径&lt;code&gt;pattern&lt;/code&gt;存在于&lt;code&gt;.&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;请注意，路径表达式与普通表达式没有区别。该表达式 &lt;code&gt;path(..|select(type==&quot;boolean&quot;))&lt;/code&gt;输出 中布尔值的所有路径&lt;code&gt;.&lt;/code&gt;，并且仅输出那些路径。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;del(path_expression)&quot;&gt;
&lt;h3&gt;&lt;code&gt;del(path_expression)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;内置函数&lt;code&gt;del&lt;/code&gt;从对象中删除键及其对应的值。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;getpath(PATHS)&quot;&gt;
&lt;h3&gt;&lt;code&gt;getpath(PATHS)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;内置函数&lt;code&gt;getpath&lt;/code&gt;输出在 中&lt;code&gt;.&lt;/code&gt;的每个路径中找到的值&lt;code&gt;PATHS&lt;/code&gt;。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;setpath(PATHS;VALUE)&quot;&gt;
&lt;h3&gt;&lt;code&gt;setpath(PATHS; VALUE)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;内置函数&lt;code&gt;setpath&lt;/code&gt;将&lt;code&gt;PATHS&lt;/code&gt;in设置&lt;code&gt;.&lt;/code&gt;为&lt;code&gt;VALUE&lt;/code&gt;.&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;delpaths(PATHS)&quot;&gt;
&lt;h3&gt;&lt;code&gt;delpaths(PATHS)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;内置函数&lt;code&gt;delpaths&lt;/code&gt;设置&lt;code&gt;PATHS&lt;/code&gt;in &lt;code&gt;.&lt;/code&gt;。 &lt;code&gt;PATHS&lt;/code&gt;必须是路径数组，其中每个路径都是字符串和数字的数组。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;to_entries,from_entries,with_entries&quot;&gt;
&lt;h3&gt;&lt;code&gt;to_entries&lt;/code&gt;, &lt;code&gt;from_entries&lt;/code&gt;,&lt;code&gt;with_entries&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;这些函数在对象和键值对数组之间进行转换。如果&lt;code&gt;to_entries&lt;/code&gt;传递了一个对象，那么对于&lt;code&gt;k: v&lt;/code&gt;输入中的每个条目，输出数组包括&lt;code&gt;{&quot;key&quot;: k, &quot;value&quot;: v}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;from_entries&lt;/code&gt;进行相反的转换，并且 &lt;code&gt;with_entries(foo)&lt;/code&gt;是 的简写&lt;code&gt;to_entries | map(foo) | from_entries&lt;/code&gt;，用于对对象的所有键和值进行某些操作。&lt;code&gt;from_entries&lt;/code&gt;接受键、键、名称、名称、值和值作为键。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;select(boolean_expression)&quot;&gt;
&lt;h3&gt;&lt;code&gt;select(boolean_expression)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;如果对该输入返回 true，则该函数&lt;code&gt;select(foo)&lt;/code&gt;将产生其输入不变 &lt;code&gt;foo&lt;/code&gt;，否则不产生任何输出。&lt;/p&gt;
&lt;p&gt;它对过滤列表很有用：&lt;code&gt;[1,2,3] | map(select(. &amp;gt;= 2))&lt;/code&gt; 会给你&lt;code&gt;[2,3]&lt;/code&gt;.&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;arrays,objects,iterables,booleans,numbers,normals,finites,strings,nulls,values,scalars&quot;&gt;
&lt;h3&gt;&lt;code&gt;arrays&lt;/code&gt;, &lt;code&gt;objects&lt;/code&gt;, &lt;code&gt;iterables&lt;/code&gt;, &lt;code&gt;booleans&lt;/code&gt;, &lt;code&gt;numbers&lt;/code&gt;, &lt;code&gt;normals&lt;/code&gt;, &lt;code&gt;finites&lt;/code&gt;, &lt;code&gt;strings&lt;/code&gt;, &lt;code&gt;nulls&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt;,&lt;code&gt;scalars&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;这些内置函数分别只选择数组、对象、可迭代对象（数组或对象）、布尔值、数字、普通数、有限数、字符串、空值、非空值和非可迭代值的输入。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;empty&quot;&gt;
&lt;h3&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;empty&lt;/code&gt;不返回任何结果。一个都没有。甚至没有&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;有时它很有用。你会知道你是否需要它:)&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;error(message)&quot;&gt;
&lt;h3&gt;&lt;code&gt;error(message)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;产生错误，就像&lt;code&gt;.a&lt;/code&gt;应用于 null 和对象以外的值一样，但将给定的消息作为错误的值。可以使用 try/catch 捕获错误；见下文。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;halt&quot;&gt;
&lt;h3&gt;&lt;code&gt;halt&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;停止 jq 程序，不再输出。jq 将以退出状态退出&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;halt_error,halt_error(exit_code)&quot;&gt;
&lt;h3&gt;&lt;code&gt;halt_error&lt;/code&gt;,&lt;code&gt;halt_error(exit_code)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;停止 jq 程序，不再输出。输入将&lt;code&gt;stderr&lt;/code&gt;作为原始输出（即字符串没有双引号）打印，没有任何装饰，甚至没有换行符。&lt;/p&gt;
&lt;p&gt;给定的&lt;code&gt;exit_code&lt;/code&gt;（默认为&lt;code&gt;5&lt;/code&gt;）将是 jq 的退出状态。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;&quot;Error: somthing went wrong\n&quot;|halt_error(1)&lt;/code&gt;。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;$__loc__&quot;&gt;
&lt;h3&gt;&lt;code&gt;$__loc__&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;生成一个带有“file”键和“line”键的对象，其中&lt;code&gt;$__loc__&lt;/code&gt;出现的文件名和行号作为值。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;paths,paths(node_filter),leaf_paths&quot;&gt;
&lt;h3&gt;&lt;code&gt;paths&lt;/code&gt;, &lt;code&gt;paths(node_filter)&lt;/code&gt;,&lt;code&gt;leaf_paths&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;paths&lt;/code&gt;输出其输入中所有元素的路径（除了它不输出空列表，表示 . 本身）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;paths(f)&lt;/code&gt;输出任何&lt;code&gt;f&lt;/code&gt;为真值的路径。也就是说，&lt;code&gt;paths(numbers)&lt;/code&gt;输出所有数值的路径。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;leaf_paths&lt;/code&gt;是&lt;code&gt;paths(scalars)&lt;/code&gt;;的别名 &lt;code&gt;leaf_paths&lt;/code&gt;已 &lt;em&gt;弃用&lt;/em&gt;，将在下一个主要版本中删除。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;add&quot;&gt;
&lt;h3&gt;&lt;code&gt;add&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;过滤器&lt;code&gt;add&lt;/code&gt;将一个数组作为输入，并将数组的元素加在一起作为输出。这可能意味着求和、连接或合并，具体取决于输入数组元素的类型 - 规则与运算符的规则相同&lt;code&gt;+&lt;/code&gt;（如上所述）。&lt;/p&gt;
&lt;p&gt;如果输入是空数组，则&lt;code&gt;add&lt;/code&gt;返回&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;any,any(condition),any(generator;condition)&quot;&gt;
&lt;h3&gt;&lt;code&gt;any&lt;/code&gt;, &lt;code&gt;any(condition)&lt;/code&gt;,&lt;code&gt;any(generator; condition)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;过滤器&lt;code&gt;any&lt;/code&gt;将布尔值数组作为输入，&lt;code&gt;true&lt;/code&gt;如果数组的任何元素为 ，则将其作为输出&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果输入是空数组，则&lt;code&gt;any&lt;/code&gt;返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;该&lt;code&gt;any(condition)&lt;/code&gt;表单将给定条件应用于输入数组的元素。&lt;/p&gt;
&lt;p&gt;该&lt;code&gt;any(generator; condition)&lt;/code&gt;表格将给定条件应用于给定生成器的所有输出。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;all,all(condition),all(generator;condition)&quot;&gt;
&lt;h3&gt;&lt;code&gt;all&lt;/code&gt;, &lt;code&gt;all(condition)&lt;/code&gt;,&lt;code&gt;all(generator; condition)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;过滤器&lt;code&gt;all&lt;/code&gt;将一个布尔值数组作为输入，&lt;code&gt;true&lt;/code&gt;如果数组的所有元素都是 ，则将其作为输出&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;该&lt;code&gt;all(condition)&lt;/code&gt;表单将给定条件应用于输入数组的元素。&lt;/p&gt;
&lt;p&gt;该&lt;code&gt;all(generator; condition)&lt;/code&gt;表格将给定条件应用于给定生成器的所有输出。&lt;/p&gt;
&lt;p&gt;如果输入是空数组，则&lt;code&gt;all&lt;/code&gt;返回&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;flatten,flatten(depth)&quot;&gt;
&lt;h3&gt;&lt;code&gt;flatten&lt;/code&gt;,&lt;code&gt;flatten(depth)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;过滤器&lt;code&gt;flatten&lt;/code&gt;将嵌套数组的数组作为输入，并生成一个平面数组，其中原始数组中的所有数组都已被其值递归替换。您可以将参数传递给它以指定要展平的嵌套级别。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flatten(2)&lt;/code&gt;就像&lt;code&gt;flatten&lt;/code&gt;，但只有两个级别的深度。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;range(upto),range(from;upto)range(from;upto;by)&quot;&gt;
&lt;h3&gt;&lt;code&gt;range(upto)&lt;/code&gt;,&lt;code&gt;range(from;upto)&lt;/code&gt; &lt;code&gt;range(from;upto;by)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;range&lt;/code&gt;函数产生一系列数字。&lt;code&gt;range(4;10)&lt;/code&gt; 产生 6 个数字，从 4（包括）到 10（不包括）。这些数字作为单独的输出产生。用于&lt;code&gt;[range(4;10)]&lt;/code&gt;将范围作为数组获取。&lt;/p&gt;
&lt;p&gt;one 参数形式生成从 0 到给定数字的数字，增量为 1。&lt;/p&gt;
&lt;p&gt;两个参数形式生成从&lt;code&gt;from&lt;/code&gt;到&lt;code&gt;upto&lt;/code&gt; 以 1 为增量的数字。&lt;/p&gt;
&lt;p&gt;三自变量形式生成&lt;code&gt;from&lt;/code&gt;以&lt;code&gt;upto&lt;/code&gt; 为增量的数字&lt;code&gt;by&lt;/code&gt;。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;floor&quot;&gt;
&lt;h3&gt;&lt;code&gt;floor&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;floor&lt;/code&gt;函数返回其数字输入的下限。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;sqrt&quot;&gt;
&lt;h3&gt;&lt;code&gt;sqrt&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;sqrt&lt;/code&gt;函数返回其数字输入的平方根。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;tonumber&quot;&gt;
&lt;h3&gt;&lt;code&gt;tonumber&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;tonumber&lt;/code&gt;函数将其输入解析为数字。它会将格式正确的字符串转换为等效的数字，不理会数字，并在所有其他输入上出错。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;tostring&quot;&gt;
&lt;h3&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;tostring&lt;/code&gt;函数将其输入打印为字符串。字符串保持不变，所有其他值都是 JSON 编码的。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;type&quot;&gt;
&lt;h3&gt;&lt;code&gt;type&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;type&lt;/code&gt;函数将其参数的类型作为字符串返回，它是 null、布尔值、数字、字符串、数组或对象之一。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;infinite,nan,isinfinite,isnan,isfinite,isnormal&quot;&gt;
&lt;h3&gt;&lt;code&gt;infinite&lt;/code&gt;, &lt;code&gt;nan&lt;/code&gt;, &lt;code&gt;isinfinite&lt;/code&gt;, &lt;code&gt;isnan&lt;/code&gt;, &lt;code&gt;isfinite&lt;/code&gt;,&lt;code&gt;isnormal&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;一些算术运算可以产生无穷大和“非数字”（NaN）值。 如果其输入是无限的，则&lt;code&gt;isinfinite&lt;/code&gt;内置函数返回。&lt;code&gt;true&lt;/code&gt;如果其 输入是 NaN ，则&lt;code&gt;isnan&lt;/code&gt;内置函数返回。内置函数返回一个正无穷大值&lt;code&gt;true&lt;/code&gt;。内置函数返回一个 NaN &lt;code&gt;infinite&lt;/code&gt;。&lt;code&gt;nan&lt;/code&gt;如果其&lt;code&gt;isnormal&lt;/code&gt;输入是正常数字，则内置函数返回 true。&lt;/p&gt;
&lt;p&gt;请注意，除以零会引发错误。&lt;/p&gt;
&lt;p&gt;目前，大多数在无穷大、NaN 和次正规数上进行的算术运算都不会引发错误。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;sort,sort_by(path_expression)&quot;&gt;
&lt;h3&gt;&lt;code&gt;sort, sort_by(path_expression)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;这些&lt;code&gt;sort&lt;/code&gt;函数对其输入进行排序，该输入必须是一个数组。值按以下顺序排序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数字&lt;/li&gt;
&lt;li&gt;字符串，按字母顺序（按 unicode 代码点值）&lt;/li&gt;
&lt;li&gt;数组，按词法顺序&lt;/li&gt;
&lt;li&gt;对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对象的排序有点复杂：首先通过比较它们的键集（作为排序顺序的数组）来比较它们，如果它们的键相等，则逐个键比较值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sort&lt;/code&gt;可用于按对象的特定字段或应用任何 jq 过滤器进行排序。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sort_by(foo)&lt;/code&gt;通过比较每个元素的结果来比较两个元素 &lt;code&gt;foo&lt;/code&gt;。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;group_by(path_expression)&quot;&gt;
&lt;h3&gt;&lt;code&gt;group_by(path_expression)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;group_by(.foo)&lt;/code&gt;将数组作为输入，将具有相同&lt;code&gt;.foo&lt;/code&gt;字段的元素分组到单独的数组中，并将所有这些数组生成为更大数组的元素，并按&lt;code&gt;.foo&lt;/code&gt;字段的值排序。&lt;/p&gt;
&lt;p&gt;任何 jq 表达式，不仅仅是一个字段访问，都可以用来代替&lt;code&gt;.foo&lt;/code&gt;. &lt;code&gt;sort&lt;/code&gt;排序顺序与上面函数中描述的相同。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;min,max,min_by(path_exp),max_by(path_exp)&quot;&gt;
&lt;h3&gt;&lt;code&gt;min&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, &lt;code&gt;min_by(path_exp)&lt;/code&gt;,&lt;code&gt;max_by(path_exp)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;查找输入数组的最小或最大元素。&lt;/p&gt;
&lt;p&gt;和函数允许您指定要检查的特定字段或属性，例如 &lt;code&gt;min_by(path_exp)&lt;/code&gt;查找具有最小字段的对象。&lt;code&gt;max_by(path_exp)&lt;/code&gt;&lt;code&gt;min_by(.foo)&lt;/code&gt;&lt;code&gt;foo&lt;/code&gt;&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;unique,unique_by(path_exp)&quot;&gt;
&lt;h3&gt;&lt;code&gt;unique&lt;/code&gt;,&lt;code&gt;unique_by(path_exp)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;unique&lt;/code&gt;函数将一个数组作为输入，并按排序顺序生成一个包含相同元素的数组，并删除重复项。&lt;/p&gt;
&lt;p&gt;对于通过应用参数获得的每个值，该&lt;code&gt;unique_by(path_exp)&lt;/code&gt;函数将只保留一个元素。可以将其视为通过从&lt;code&gt;group&lt;/code&gt;.&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;reverse&quot;&gt;
&lt;h3&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;此函数反转数组。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;contains(element)&quot;&gt;
&lt;h3&gt;&lt;code&gt;contains(element)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;contains(b)&lt;/code&gt;如果 b 完全包含在输入中，则过滤器将产生 true。如果 B 是 A 的子字符串，则字符串 B 包含在字符串 A 中。如果 B 中的所有元素都包含在 A 中的任何元素中，则数组 B 包含在数组 A 中。如果所有元素都包含在对象 B 中，则对象 B 包含在对象 A 中B 中的值包含在具有相同键的 A 中的值中。如果所有其他类型相等，则假定它们相互包含。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;indices(s)&quot;&gt;
&lt;h3&gt;&lt;code&gt;indices(s)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;输出一个数组，其中包含&lt;code&gt;.&lt;/code&gt;where的索引&lt;code&gt;s&lt;/code&gt; 。输入可能是一个数组，在这种情况下，如果&lt;code&gt;s&lt;/code&gt;是一个数组，那么索引输出将是所有元素&lt;code&gt;.&lt;/code&gt;匹配的那些&lt;code&gt;s&lt;/code&gt;。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;index(s),rindex(s)&quot;&gt;
&lt;h3&gt;&lt;code&gt;index(s)&lt;/code&gt;,&lt;code&gt;rindex(s)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;index&lt;/code&gt;输出输入中第一个 ( ) 或最后一个 ( &lt;code&gt;rindex&lt;/code&gt;) 出现的索引&lt;code&gt;s&lt;/code&gt;。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;inside&quot;&gt;
&lt;h3&gt;&lt;code&gt;inside&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;inside(b)&lt;/code&gt;如果输入完全包含在 b 中，则过滤器将产生 true。它本质上是&lt;code&gt;contains&lt;/code&gt;.&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;startswith(str)&quot;&gt;
&lt;h3&gt;&lt;code&gt;startswith(str)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;输出&lt;code&gt;true&lt;/code&gt;如果。从给定的字符串参数开始。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;endswith(str)&quot;&gt;
&lt;h3&gt;&lt;code&gt;endswith(str)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;输出&lt;code&gt;true&lt;/code&gt;如果。以给定的字符串参数结束。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;combinations,combinations(n)&quot;&gt;
&lt;h3&gt;&lt;code&gt;combinations&lt;/code&gt;,&lt;code&gt;combinations(n)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;输出输入数组中数组元素的所有组合。如果给定一个参数&lt;code&gt;n&lt;/code&gt;，它会输出&lt;code&gt;n&lt;/code&gt;输入数组的所有重复组合。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;ltrimstr(str)&quot;&gt;
&lt;h3&gt;&lt;code&gt;ltrimstr(str)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;如果它以它开头，则输出它的输入并删除给定的前缀字符串。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;rtrimstr(str)&quot;&gt;
&lt;h3&gt;&lt;code&gt;rtrimstr(str)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;如果它以它结尾，则输出它的输入并删除给定的后缀字符串。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;explode&quot;&gt;
&lt;h3&gt;&lt;code&gt;explode&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;将输入字符串转换为字符串代码点编号的数组。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;implode&quot;&gt;
&lt;h3&gt;&lt;code&gt;implode&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;爆炸的反面。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;split(str)&quot;&gt;
&lt;h3&gt;&lt;code&gt;split(str)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;在分隔符参数上拆分输入字符串。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;join(str)&quot;&gt;
&lt;h3&gt;&lt;code&gt;join(str)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;使用参数作为分隔符连接作为输入给定的元素数组。它是&lt;code&gt;split&lt;/code&gt;: 的倒数，也就是说，&lt;code&gt;split(&quot;foo&quot;) | join(&quot;foo&quot;)&lt;/code&gt;在任何输入字符串上运行都会返回所述输入字符串。&lt;/p&gt;
&lt;p&gt;输入中的数字和布尔值被转换为字符串。Null 值被视为空字符串。不支持输入中的数组和对象。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;ascii_downcase,ascii_upcase&quot;&gt;
&lt;h3&gt;&lt;code&gt;ascii_downcase&lt;/code&gt;,&lt;code&gt;ascii_upcase&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;发出输入字符串的副本，并将其字母字符（az 和 AZ）转换为指定的大小写。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;while(cond;update)&quot;&gt;
&lt;h3&gt;&lt;code&gt;while(cond; update)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;while(cond; update)&lt;/code&gt;功能允许您重复应用更新，&lt;code&gt;.&lt;/code&gt;直到&lt;code&gt;cond&lt;/code&gt;为假。&lt;/p&gt;
&lt;p&gt;请注意，它&lt;code&gt;while(cond; update)&lt;/code&gt;在内部定义为递归 jq 函数。如果每个输入最多产生一个输出，则内部的递归调用&lt;code&gt;while&lt;/code&gt;不会消耗额外的内存。&lt;code&gt;update&lt;/code&gt;请参阅下面的高级主题。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;until(cond;next)&quot;&gt;
&lt;h3&gt;&lt;code&gt;until(cond; next)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;until(cond; next)&lt;/code&gt;函数允许您重复应用表达式&lt;code&gt;next&lt;/code&gt;，从最初到&lt;code&gt;.&lt;/code&gt;然后到它自己的输出，直到&lt;code&gt;cond&lt;/code&gt;为真。例如，这可用于实现阶乘函数（见下文）。&lt;/p&gt;
&lt;p&gt;请注意，它&lt;code&gt;until(cond; next)&lt;/code&gt;在内部定义为递归 jq 函数。如果每个输入最多产生一个输出，则内部的递归调用&lt;code&gt;until()&lt;/code&gt;不会消耗额外的内存。&lt;code&gt;next&lt;/code&gt;请参阅下面的高级主题。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;recurse(f),recurse,recurse(f;condition),recurse_down&quot;&gt;
&lt;h3&gt;&lt;code&gt;recurse(f)&lt;/code&gt;, &lt;code&gt;recurse&lt;/code&gt;, &lt;code&gt;recurse(f; condition)&lt;/code&gt;,&lt;code&gt;recurse_down&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;recurse(f)&lt;/code&gt;功能允许您搜索递归结构，并从各个级别提取有趣的数据。假设您的输入代表一个文件系统：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{&quot;name&quot;: &quot;/&quot;, &quot;children&quot;: [
  {&quot;name&quot;: &quot;/bin&quot;, &quot;children&quot;: [
    {&quot;name&quot;: &quot;/bin/ls&quot;, &quot;children&quot;: []},
    {&quot;name&quot;: &quot;/bin/sh&quot;, &quot;children&quot;: []}]},
  {&quot;name&quot;: &quot;/home&quot;, &quot;children&quot;: [
    {&quot;name&quot;: &quot;/home/stephen&quot;, &quot;children&quot;: [
      {&quot;name&quot;: &quot;/home/stephen/jq&quot;, &quot;children&quot;: []}]}]}]}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在假设您要提取所有存在的文件名。您需要检索&lt;code&gt;.name&lt;/code&gt;、&lt;code&gt;.children[].name&lt;/code&gt;、 &lt;code&gt;.children[].children[].name&lt;/code&gt;等。你可以这样做：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;recurse(.children[]) | .name&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不带参数调用时，&lt;code&gt;recurse&lt;/code&gt;等效于 &lt;code&gt;recurse(.[]?)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;recurse(f)&lt;/code&gt;与递归深度相同&lt;code&gt;recurse(f; . != null)&lt;/code&gt;，可以在不考虑递归深度的情况下使用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;recurse(f; condition)&lt;/code&gt;是一个以发射 开始的生成器。然后依次发出 .|f, .|f|f, .|f|f|f, ... 只要计算值满足条件。例如，要生成所有整数，至少原则上可以写成&lt;code&gt;recurse(.+1; true)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;由于遗留原因，作为不带参数&lt;code&gt;recurse_down&lt;/code&gt;调用的别名存在。&lt;code&gt;recurse&lt;/code&gt;此别名已被 &lt;em&gt;弃用&lt;/em&gt;，将在下一个主要版本中删除。&lt;/p&gt;
&lt;p&gt;只要每个输入最多产生一个输出，递归调用&lt;code&gt;recurse&lt;/code&gt;就不会消耗额外的内存。&lt;code&gt;f&lt;/code&gt;&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;walk(f)&quot;&gt;
&lt;h3&gt;&lt;code&gt;walk(f)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;walk(f)&lt;/code&gt;函数递归地应用于输入实体的每个组件。当遇到一个数组时，f首先应用于其元素，然后应用于数组本身；当遇到一个对象时，首先将 f 应用于所有值，然后再应用于该对象。在实践中，f 通常会测试其输入的类型，如下面的示例所示。第一个示例强调了在处理数组本身之前处理数组元素的有用性。第二个示例显示了如何考虑更改输入中所有对象的所有键。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;$ENV,env&quot;&gt;
&lt;h3&gt;&lt;code&gt;$ENV&lt;/code&gt;,&lt;code&gt;env&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;$ENV&lt;/code&gt;是一个对象，表示 jq 程序启动时设置的环境变量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;env&lt;/code&gt;输出一个代表 jq 当前环境的对象。&lt;/p&gt;
&lt;p&gt;目前没有用于设置环境变量的内置函数。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;transpose&quot;&gt;
&lt;h3&gt;&lt;code&gt;transpose&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;转置一个可能锯齿状的矩阵（数组的数组）。行用空值填充，因此结果始终为矩形。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;bsearch(x)&quot;&gt;
&lt;h3&gt;&lt;code&gt;bsearch(x)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;bsearch(x) 在输入数组中对 x 进行二分搜索。如果输入已排序并包含 x，则 bsearch(x) 将返回其在数组中的索引；否则，如果数组已排序，它将返回 (-1 - ix)，其中 ix 是一个插入点，因此在将 x 插入到 ix 后，该数组仍将被排序。如果数组未排序，bsearch(x) 将返回一个可能不感兴趣的整数。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;Stringinterpolation-\(foo)&quot;&gt;
&lt;h3&gt;字符串插值 -&lt;code&gt;\(foo)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;在字符串中，您可以在反斜杠后的括号内放置表达式。无论表达式返回什么，都将被插入到字符串中。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;Convertto/fromJSON&quot;&gt;
&lt;h3&gt;转换为/从 JSON&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tojson&lt;/code&gt;和builtins 分别将值转储为 JSON 文本或将&lt;code&gt;fromjson&lt;/code&gt;JSON 文本解析为值。内置 tojson 与 tostring 的不同之处在于 tostring 返回未修改的字符串，而 tojson 将字符串编码为 JSON 字符串。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;Formatstringsandescaping&quot;&gt;
&lt;h3&gt;格式化字符串和转义&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;@foo&lt;/code&gt;语法用于格式化和转义字符串，这对于构建 URL、HTML 或 XML 等语言的文档等很有用。&lt;code&gt;@foo&lt;/code&gt;可以单独用作过滤器，可能的转义是：&lt;/p&gt;

&lt;p&gt;调用&lt;code&gt;tostring&lt;/code&gt;，请参阅该函数以获取详细信息。&lt;/p&gt;

&lt;p&gt;将输入序列化为 JSON。&lt;/p&gt;

&lt;p&gt;通过将字符映射 &lt;code&gt;&amp;lt;&amp;gt;&amp;amp;&#x27;&quot;&lt;/code&gt;到它们的实体等价物&lt;code&gt;&amp;amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;amp;apos;&lt;/code&gt;,来应用 HTML/XML 转义&lt;code&gt;&amp;amp;quot;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;通过将所有保留的 URI 字符映射到一个&lt;code&gt;%XX&lt;/code&gt;序列来应用百分比编码。&lt;/p&gt;

&lt;p&gt;输入必须是一个数组，并将其呈现为 CSV，字符串带有双引号，引号通过重复转义。&lt;/p&gt;

&lt;p&gt;输入必须是一个数组，并且呈现为 TSV（制表符分隔值）。每个输入数组将打印为一行。字段由单个选项卡 (ascii &lt;code&gt;0x09&lt;/code&gt;) 分隔。输入字符换行 (ascii &lt;code&gt;0x0a&lt;/code&gt;)、回车 (ascii &lt;code&gt;0x0d&lt;/code&gt;)、制表符 (ascii &lt;code&gt;0x09&lt;/code&gt;) 和反斜杠 (ascii &lt;code&gt;0x5c&lt;/code&gt;) 将分别输出为转义 序列&lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, 。&lt;code&gt;\t&lt;/code&gt;&lt;code&gt;\\&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;输入经过转义，适合在 POSIX shell 的命令行中使用。如果输入是数组，则输出将是一系列以空格分隔的字符串。&lt;/p&gt;

&lt;p&gt;输入将转换为 RFC 4648 指定的 base64。&lt;/p&gt;

&lt;p&gt;, 的逆&lt;code&gt;@base64&lt;/code&gt;输入按照 RFC 4648 的规定进行解码。 注意\：如果解码的字符串不是 UTF-8，则结果未定义。&lt;/p&gt;
&lt;p&gt;这种语法可以以一种有用的方式与字符串插值相结合。您可以在&lt;code&gt;@foo&lt;/code&gt;标记后面加上字符串文字。字符串文字的内容&lt;em&gt;不会&lt;/em&gt;被转义。但是，在该字符串文字内进行的所有插值都将被转义。例如，&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;@uri &quot;https://www.google.com/search?q=\(.search)&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将为输入产生以下输出 &lt;code&gt;{&quot;search&quot;:&quot;what is jq?&quot;}&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;&quot;https://www.google.com/search?q=what%20is%20jq%3F&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请注意，URL 中的斜杠、问号等不会被转义，因为它们是字符串文字的一部分。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;Dates&quot;&gt;
&lt;h3&gt;日期&lt;/h3&gt;
&lt;p&gt;jq 提供了一些基本的日期处理功能，以及一些高级和低级的内置函数。在所有情况下，这些内置函数都专门处理 UTC 时间。&lt;/p&gt;
&lt;p&gt;内置函数将 ISO 8601 格式的&lt;code&gt;fromdateiso8601&lt;/code&gt;日期时间解析为自 Unix 纪元 (1970-01-01T00:00:00Z) 以来的秒数。&lt;code&gt;todateiso8601&lt;/code&gt;内置执行相反的操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fromdate&lt;/code&gt;内置解析日期时间字符串。目前 &lt;code&gt;fromdate&lt;/code&gt;仅支持 ISO 8601 日期时间字符串，但未来它将尝试解析更多格式的日期时间字符串。&lt;/p&gt;
&lt;p&gt;内置函数&lt;code&gt;todate&lt;/code&gt;是.&lt;code&gt;todateiso8601&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;now&lt;/code&gt;内置输出当前时间，以 Unix 纪元以来的秒数为单位。&lt;/p&gt;
&lt;p&gt;还提供了 C 库时间函数的低级 jq 接口：&lt;code&gt;strptime&lt;/code&gt;、&lt;code&gt;strftime&lt;/code&gt;、&lt;code&gt;strflocaltime&lt;/code&gt;、 &lt;code&gt;mktime&lt;/code&gt;、&lt;code&gt;gmtime&lt;/code&gt;和&lt;code&gt;localtime&lt;/code&gt;. &lt;code&gt;strptime&lt;/code&gt;有关和使用的格式字符串，请参阅主机操作系统的文档&lt;code&gt;strftime&lt;/code&gt;。注意：这些不一定是 jq 中的稳定接口，尤其是它们的本地化功能。&lt;/p&gt;
&lt;p&gt;内置函数消耗自 Unix 纪元以来的&lt;code&gt;gmtime&lt;/code&gt;秒数，并输出 Greenwhich Meridian 时间的“分解时间”表示，作为表示（按此顺序）的数字数组：年、月（从零开始）、日期月份（从 1 开始）、一天中的小时、小时中的分钟、分钟中的秒、一周中的一天和一年中的一天——除非另有说明，否则都是从 1 开始的。对于 1900 年 3 月 1 日之前或 2099 年 12 月 31 日之后的日期，某些系统上的星期数可能是错误的。&lt;/p&gt;
&lt;p&gt;内置函数的&lt;code&gt;localtime&lt;/code&gt;工作方式与&lt;code&gt;gmtime&lt;/code&gt;内置函数类似，但使用本地时区设置。&lt;/p&gt;
&lt;p&gt;内置使用和输出的时间的&lt;code&gt;mktime&lt;/code&gt;“分解时间”表示。&lt;code&gt;gmtime&lt;/code&gt;&lt;code&gt;strptime&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;内置解析与参数匹配的&lt;code&gt;strptime(fmt)&lt;/code&gt;输入字符串 &lt;code&gt;fmt&lt;/code&gt;。&lt;code&gt;gmtime&lt;/code&gt;输出是由 消耗和输出的“分解时间”表示&lt;code&gt;mktime&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;内置使用&lt;code&gt;strftime(fmt)&lt;/code&gt;给定格式格式化时间（GMT）。执行&lt;code&gt;strflocaltime&lt;/code&gt;相同的操作，但使用本地时区设置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;strptime&lt;/code&gt;和的格式字符串&lt;code&gt;strftime&lt;/code&gt;在典型的 C 库文档中进行了描述。ISO 8601 日期时间的格式字符串是&lt;code&gt;&quot;%Y-%m-%dT%H:%M:%SZ&quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;jq 在某些系统上可能不支持部分或全部此日期功能。特别是，macOS 不支持&lt;code&gt;%u&lt;/code&gt;and&lt;code&gt;%j&lt;/code&gt;说明符 。&lt;code&gt;strptime(fmt)&lt;/code&gt;&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;SQL-StyleOperators&quot;&gt;
&lt;h3&gt;SQL 风格的运算符&lt;/h3&gt;
&lt;p&gt;jq 提供了一些 SQL 风格的运算符。&lt;/p&gt;

&lt;p&gt;此内置函数生成一个对象，其键由应用于给定流中每个值的给定索引表达式计算。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加入（$idx；流；idx_expr；join_expr）：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此内置函数将给定流中的值连接到给定索引。通过将给定的索引表达式应用于给定流中的每个值来计算索引的键。流中的值和索引中的相应值的数组被馈送到给定的连接表达式以产生每个结果。&lt;/p&gt;

&lt;p&gt;与 相同&lt;code&gt;JOIN($idx; stream; idx_expr; .)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这个内置函数将输入连接&lt;code&gt;.&lt;/code&gt;到给定的索引，应用给定的索引表达式&lt;code&gt;.&lt;/code&gt;来计算索引键。加入操作如上所述。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;true&lt;/code&gt;如果出现在给定的流中，则此内置输出&lt;code&gt;.&lt;/code&gt;，否则输出&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果源流中的任何值出现在第二个流中，则此内置输出&lt;code&gt;true&lt;/code&gt;，否则输出&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;builtins&quot;&gt;
&lt;h3&gt;&lt;code&gt;builtins&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;返回格式为 的所有内置函数的列表&lt;code&gt;name/arity&lt;/code&gt;。由于具有相同名称但不同数量的函数被认为是单独的函数，因此&lt;code&gt;all/0&lt;/code&gt;,&lt;code&gt;all/1&lt;/code&gt;和&lt;code&gt;all/2&lt;/code&gt;都将出现在列表中。&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;Advancedfeatures&quot;&gt;
&lt;h2&gt;高级功能&lt;/h2&gt;
&lt;p&gt;变量在大多数编程语言中是绝对必要的，但它们在 jq 中被归为“高级特性”。&lt;/p&gt;
&lt;p&gt;在大多数语言中，变量是传递数据的唯一方式。如果你计算一个值，并且你想多次使用它，你需要将它存储在一个变量中。要将值传递给程序的另一部分，您需要程序的该部分定义一个变量（作为函数参数、对象成员或其他）来放置数据。&lt;/p&gt;
&lt;p&gt;也可以在 jq 中定义函数，尽管这是一个最大用途是定义 jq 的标准库的功能（许多 jq 函数，例如&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;find&lt;/code&gt;实际上是用 jq 编写的）。&lt;/p&gt;
&lt;p&gt;jq 有归约运算符，它们非常强大但有点棘手。同样，这些主要在内部使用，以定义 jq 标准库的一些有用位。&lt;/p&gt;
&lt;p&gt;一开始可能并不明显，但 jq 是关于生成器的（是的，这在其他语言中很常见）。提供了一些实用程序来帮助处理生成器。&lt;/p&gt;
&lt;p&gt;一些最小的 I/O 支持（除了从标准输入读取 JSON 并将 JSON 写入标准输出）是可用的。&lt;/p&gt;
&lt;p&gt;最后，还有一个模块/库系统。&lt;/p&gt;
&lt;section id=&quot;Variable/SymbolicBindingOperator:...as$identifier|...&quot;&gt;
&lt;h3&gt;变量/符号绑定运算符：&lt;code&gt;... as $identifier | ...&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;在 jq 中，所有过滤器都有一个输入和一个输出，因此不需要手动管道将值从程序的一个部分传递到下一个部分。许多表达式，例如&lt;code&gt;a + b&lt;/code&gt;，将它们的输入传递给两个不同的子表达式（这里&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;都传递相同的输入），因此通常不需要使用变量来两次使用一个值。&lt;/p&gt;
&lt;p&gt;例如，在大多数语言中，计算一个数字数组的平均值需要一些变量——至少有一个变量来保存数组，可能每个元素或循环计数器都有一个变量。在 jq 中，它很简单&lt;code&gt;add / length&lt;/code&gt;-&lt;code&gt;add&lt;/code&gt;表达式被赋予数组并产生其总和，&lt;code&gt;length&lt;/code&gt;表达式被赋予数组并产生其长度。&lt;/p&gt;
&lt;p&gt;因此，通常有一种比定义变量更简洁的方法来解决 jq 中的大多数问题。尽管如此，有时它们确实使事情变得更容易，因此 jq 允许您使用&lt;code&gt;expression as $variable&lt;/code&gt;. 所有变量名都以&lt;code&gt;$&lt;/code&gt;. 这是数组平均示例的一个稍微丑陋的版本：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;length as $array_length | add / $array_length&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们需要一个更复杂的问题来找到使用变量实际上使我们的生活更轻松的情况。&lt;/p&gt;
&lt;p&gt;假设我们有一个博客文章数组，其中包含“作者”和“标题”字段，以及另一个用于将作者用户名映射到真实姓名的对象。我们的输入看起来像：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{&quot;posts&quot;: [{&quot;title&quot;: &quot;Frist psot&quot;, &quot;author&quot;: &quot;anon&quot;},
           {&quot;title&quot;: &quot;A well-written article&quot;, &quot;author&quot;: &quot;person1&quot;}],
 &quot;realnames&quot;: {&quot;anon&quot;: &quot;Anonymous Coward&quot;,
               &quot;person1&quot;: &quot;Person McPherson&quot;}}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们希望生成包含真实姓名的作者字段的帖子，如下所示：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{&quot;title&quot;: &quot;Frist psot&quot;, &quot;author&quot;: &quot;Anonymous Coward&quot;}
{&quot;title&quot;: &quot;A well-written article&quot;, &quot;author&quot;: &quot;Person McPherson&quot;}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们使用变量 $names 来存储 realnames 对象，以便稍后在查找作者用户名时引用它：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;.realnames as $names | .posts[] | {title, author: $names[.author]}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表达式&lt;code&gt;exp as $x | ...&lt;/code&gt;意味着：对于表达式的每个值， &lt;code&gt;exp&lt;/code&gt;使用整个原始输入运行管道的其余部分，并&lt;code&gt;$x&lt;/code&gt;设置为该值。因此&lt;code&gt;as&lt;/code&gt;起到某种 foreach 循环的作用。&lt;/p&gt;
&lt;p&gt;就像&lt;code&gt;{foo}&lt;/code&gt;方便的写作方式一样，方便的写作方式也是&lt;code&gt;{foo: .foo}&lt;/code&gt;如此 。&lt;code&gt;{$foo}&lt;/code&gt;&lt;code&gt;{foo:$foo}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;as&lt;/code&gt;通过提供与输入结构匹配的模式（这称为“解构”），可以使用单个表达式声明多个变量：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;. as {realnames: $names, posts: [$first, $second]} | ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组模式中的变量声明（例如，&lt;code&gt;. as [$first, $second]&lt;/code&gt;）按顺序绑定到数组的元素，从索引零的元素开始。当数组模式元素的索引处没有值时，&lt;code&gt;null&lt;/code&gt;将绑定到该变量。&lt;/p&gt;
&lt;p&gt;变量的范围在定义它们的表达式的其余部分，所以&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;.realnames as $names | (.posts[] | {title, author: $names[.author]})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会工作，但是&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;(.realnames as $names | .posts[]) | {title, author: $names[.author]}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;惯于。&lt;/p&gt;
&lt;p&gt;对于编程语言理论家来说，更准确的说法是 jq 变量是词法范围的绑定。特别是没有办法改变绑定的值；只能设置一个具有相同名称的新绑定，但在旧绑定的位置不可见。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;DestructuringAlternativeOperator:?//&quot;&gt;
&lt;h3&gt;解构替代运算符：&lt;code&gt;?//&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;解构替代运算符提供了一种简洁的机制来解构可以采用多种形式之一的输入。&lt;/p&gt;
&lt;p&gt;假设我们有一个 API，它返回一个资源列表和与之关联的事件，我们想要获取每个资源的第一个事件的 user_id 和时间戳。如果资源有多个事件，API（已经笨拙地从 XML 转换）只会将事件包装在数组中：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;{&quot;resources&quot;: [{&quot;id&quot;: 1, &quot;kind&quot;: &quot;widget&quot;, &quot;events&quot;: {&quot;action&quot;: &quot;create&quot;, &quot;user_id&quot;: 1, &quot;ts&quot;: 13}},
               {&quot;id&quot;: 2, &quot;kind&quot;: &quot;widget&quot;, &quot;events&quot;: [{&quot;action&quot;: &quot;create&quot;, &quot;user_id&quot;: 1, &quot;ts&quot;: 14}, {&quot;action&quot;: &quot;destroy&quot;, &quot;user_id&quot;: 1, &quot;ts&quot;: 15}]}]}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以使用解构替代运算符来简单地处理这种结构变化：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;.resources[] as {$id, $kind, events: {$user_id, $ts}} ?// {$id, $kind, events: [{$user_id, $ts}]} | {$user_id, $kind, $id, $ts}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者，如果我们不确定输入是值数组还是对象：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;.[] as [$id, $kind, $user_id, $ts] ?// {$id, $kind, $user_id, $ts} | ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每个备选方案不需要定义所有相同的变量，但所有命名变量都可用于后续表达式。在成功的替代方案中不匹配的变量将是&lt;code&gt;null&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;.resources[] as {$id, $kind, events: {$user_id, $ts}} ?// {$id, $kind, events: [{$first_user_id, $first_ts}]} | {$user_id, $first_user_id, $kind, $id, $ts, $first_ts}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此外，如果后续表达式返回错误，则替代运算符将尝试尝试下一个绑定。在最终替代过程中发生的错误将被传递。&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;[[3]] | .[] as [$a] ?// [$b] | if $a != null then error(&quot;err: \($a)&quot;) else {$a,$b} end&lt;/code&gt;&lt;/pre&gt;

&lt;/section&gt;
&lt;section id=&quot;DefiningFunctions&quot;&gt;
&lt;h3&gt;定义函数&lt;/h3&gt;
&lt;p&gt;您可以使用“def”语法为过滤器命名：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;def increment: . + 1;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从那时起，&lt;code&gt;increment&lt;/code&gt;就可以像内置函数一样用作过滤器（实际上，这就是定义了多少个内置函数）。函数可以接受参数：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;def map(f): [.[] | f];&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数作为&lt;em&gt;过滤器&lt;/em&gt;（没有参数的函数）传递，&lt;em&gt;而不是&lt;/em&gt;作为值传递。可以使用不同的输入多次引用相同的参数（这里&lt;code&gt;f&lt;/code&gt;针对输入数组的每个元素运行）。函数的参数更像回调而不是值参数。理解这一点很重要。考虑：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;def foo(f): f|f;
5|foo(.*2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果将是 20，因为&lt;code&gt;f&lt;/code&gt;is &lt;code&gt;.*2&lt;/code&gt;，并且在第一次调用&lt;code&gt;f&lt;/code&gt; &lt;code&gt;.&lt;/code&gt;将是 5，第二次将是 10 (5 * 2)，所以结果将是 20。函数参数是过滤器，过滤器期望输入调用。&lt;/p&gt;
&lt;p&gt;如果你想要定义简单函数的值参数行为，你可以只使用一个变量：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;def addvalue(f): f as $f | map(. + $f);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者使用简写：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;def addvalue($f): ...;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;无论使用哪种定义，&lt;code&gt;addvalue(.foo)&lt;/code&gt;都会将当前输入的&lt;code&gt;.foo&lt;/code&gt;字段添加到数组的每个元素中。请注意，调用&lt;code&gt;addvalue(.[])&lt;/code&gt;将导致在调用站点&lt;code&gt;map(. + $f)&lt;/code&gt;的值中的每个值对部件进行一次评估。&lt;code&gt;.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;允许使用相同函数名的多个定义。对于相同数量的函数参数，每个重新定义都会替换先前的重新定义，但仅适用于重新定义之后的函数（或主程序）的引用。另请参阅下面有关范围界定的部分。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;Scoping&quot;&gt;
&lt;h3&gt;范围界定&lt;/h3&gt;
&lt;p&gt;jq 中有两种类型的符号：值绑定（又名“变量”）和函数。两者都是词法范围的，表达式只能引用已在它们“左侧”定义的符号。该规则的唯一例外是函数可以引用自身以便能够创建递归函数。&lt;/p&gt;
&lt;p&gt;例如，在下面的表达式中，有一个绑定在它的“右侧”可见&lt;code&gt;... | .*3 as $times_three | [. + $times_three] | ...&lt;/code&gt;，但在“左侧”不可见。现在考虑这个表达式&lt;code&gt;... | (.*3 as $times_three | [. + $times_three]) | ...&lt;/code&gt;：这里的绑定 在右括号之后&lt;code&gt;$times_three&lt;/code&gt;是&lt;em&gt;不&lt;/em&gt;可见的。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;Reduce&quot;&gt;
&lt;h3&gt;减少&lt;/h3&gt;
&lt;p&gt;jq 中的&lt;code&gt;reduce&lt;/code&gt;语法允许您通过将表达式的所有结果累积成一个答案来组合它们。例如，我们将传递&lt;code&gt;[3,2,1]&lt;/code&gt;给这个表达式：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;reduce .[] as $item (0; . + $item)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于&lt;code&gt;.[]&lt;/code&gt;产生的每个结果，&lt;code&gt;. + $item&lt;/code&gt;运行以累积从 0 开始的运行总计。在此示例中，&lt;code&gt;.[]&lt;/code&gt;产生结果 3、2 和 1，因此效果类似于运行以下内容：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;0 | (3 as $item | . + $item) |
    (2 as $item | . + $item) |
    (1 as $item | . + $item)&lt;/code&gt;&lt;/pre&gt;

&lt;/section&gt;
&lt;section id=&quot;isempty(exp)&quot;&gt;
&lt;h3&gt;&lt;code&gt;isempty(exp)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;exp&lt;/code&gt;如果不产生输出，则返回 true ，否则返回 false。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;limit(n;exp)&quot;&gt;
&lt;h3&gt;&lt;code&gt;limit(n; exp)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该&lt;code&gt;limit&lt;/code&gt;函数最多从 中提取&lt;code&gt;n&lt;/code&gt;输出&lt;code&gt;exp&lt;/code&gt;。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;first(expr),last(expr),nth(n;expr)&quot;&gt;
&lt;h3&gt;&lt;code&gt;first(expr)&lt;/code&gt;, &lt;code&gt;last(expr)&lt;/code&gt;,&lt;code&gt;nth(n; expr)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;first(expr)&lt;/code&gt;和函数分别从中&lt;code&gt;last(expr)&lt;/code&gt;提取第一个和最后一个值&lt;code&gt;expr&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;该&lt;code&gt;nth(n; expr)&lt;/code&gt;函数提取由 输出的第 n 个值 &lt;code&gt;expr&lt;/code&gt;。这可以定义为&lt;code&gt;def nth(n; expr): last(limit(n + 1; expr));&lt;/code&gt;。请注意，&lt;code&gt;nth(n; expr)&lt;/code&gt;不支持&lt;code&gt;n&lt;/code&gt;.&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;first,last,nth(n)&quot;&gt;
&lt;h3&gt;&lt;code&gt;first&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt;,&lt;code&gt;nth(n)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;first&lt;/code&gt;and函数从位于的&lt;code&gt;last&lt;/code&gt;任何数组中提取第一个和最后一个值&lt;code&gt;.&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;该&lt;code&gt;nth(n)&lt;/code&gt;函数在 处提取任何数组的第 n 个值&lt;code&gt;.&lt;/code&gt;。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;foreach&quot;&gt;
&lt;h3&gt;&lt;code&gt;foreach&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;foreach&lt;/code&gt;语法类似于&lt;code&gt;reduce&lt;/code&gt;，但旨在允许构造&lt;code&gt;limit&lt;/code&gt;和生成中间结果的化简器（参见示例）。&lt;/p&gt;
&lt;p&gt;形式是&lt;code&gt;foreach EXP as $var (INIT; UPDATE; EXTRACT)&lt;/code&gt;。像&lt;code&gt;reduce&lt;/code&gt;,&lt;code&gt;INIT&lt;/code&gt;被评估一次以产生一个状态值，然后每个输出&lt;code&gt;EXP&lt;/code&gt;绑定到&lt;code&gt;$var&lt;/code&gt;,&lt;code&gt;UPDATE&lt;/code&gt; 被评估为&lt;code&gt;EXP&lt;/code&gt;具有当前状态和&lt;code&gt;$var&lt;/code&gt;可见的每个输出。输出的每个值都会&lt;code&gt;UPDATE&lt;/code&gt; 替换先前的状态。最后，&lt;code&gt;EXTRACT&lt;/code&gt;对每个新状态进行评估以提取 的输出&lt;code&gt;foreach&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这仅对构造&lt;code&gt;reduce&lt;/code&gt;- 和 - &lt;code&gt;limit&lt;/code&gt;类似的函数非常有用。但它更通用，因为它允许部分减少（参见下面的示例）。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;Recursion&quot;&gt;
&lt;h3&gt;递归&lt;/h3&gt;
&lt;p&gt;如上所述，&lt;code&gt;recurse&lt;/code&gt;使用递归，任何jq函数都可以递归。&lt;code&gt;while&lt;/code&gt;内置函数也以递归的方式实现。&lt;/p&gt;
&lt;p&gt;只要递归调用左侧的表达式输出其最后一个值，就会优化尾调用。实际上，这意味着递归调用左侧的表达式不应为每个输入生成多个输出。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;def recurse(f): def r: ., (f | select(. != null) | r); r;

def while(cond; update):
  def _while:
    if cond then ., (update | _while) else empty end;
  _while;

def repeat(exp):
  def _repeat:
    exp, _repeat;
  _repeat;&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id=&quot;Generatorsanditerators&quot;&gt;
&lt;h3&gt;生成器和迭代器&lt;/h3&gt;
&lt;p&gt;一些 jq 运算符和函数实际上是生成器，因为它们可以为每个输入生成零、一个或多个值，正如人们在其他具有生成器的编程语言中所期望的那样。例如，&lt;code&gt;.[]&lt;/code&gt; 生成其输入中的所有值（必须是数组或对象），&lt;code&gt;range(0; 10)&lt;/code&gt;生成 0 到 10 之间的整数，等等。&lt;/p&gt;
&lt;p&gt;甚至逗号运算符也是一个生成器，它首先生成由逗号左侧的表达式生成的值，然后对于其中的每一个，生成由逗号右侧的表达式生成的值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;empty&lt;/code&gt;内置是产生零输出的生成器。&lt;code&gt;empty&lt;/code&gt;内置回溯到前面的生成器表达式。&lt;/p&gt;
&lt;p&gt;All jq functions can be generators just by using builtin generators. It is also possible to define new generators using only recursion and the comma operator. If the recursive call(s) is(are) &quot;in tail position&quot; then the generator will be efficient. In the example below the recursive call by &lt;code&gt;_range&lt;/code&gt; to itself is in tail position. The example shows off three advanced topics: tail recursion, generator construction, and sub-functions.&lt;/p&gt;

&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;Assignment&quot;&gt;
&lt;h2&gt;任务&lt;/h2&gt;
&lt;p&gt;jq 中的赋值工作与大多数编程语言中的工作方式略有不同。jq 不区分对某事物的引用和副本——两个对象或数组相等或不相等，没有任何进一步的“相同对象”或“不同对象”的概念。&lt;/p&gt;
&lt;p&gt;如果一个对象有两个字段，它们是数组&lt;code&gt;.foo&lt;/code&gt;和&lt;code&gt;.bar&lt;/code&gt;，并且你在 上附加了一些东西&lt;code&gt;.foo&lt;/code&gt;，那么&lt;code&gt;.bar&lt;/code&gt;即使你之前设置了 ，也不会变大&lt;code&gt;.bar = .foo&lt;/code&gt;。如果您习惯于使用 Python、Java、Ruby、Javascript 等语言进行编程，那么您可以将其想象为 jq 在执行分配之前对每个对象进行了完整的深度复制（出于性能考虑，它实际上并没有这样做，但这是一般的想法）。&lt;/p&gt;
&lt;p&gt;这意味着不可能在 jq 中构建循环值（例如第一个元素是自身的数组）。这是非常有意的，并确保 jq 程序可以生成的任何内容都可以用 JSON 表示。&lt;/p&gt;
&lt;p&gt;jq 中的所有赋值运算符在左侧（LHS）都有路径表达式。右侧 (RHS) 提供设置为由 LHS 路径表达式命名的路径的值。&lt;/p&gt;
&lt;p&gt;jq 中的值始终是不可变的。在内部，赋值通过使用归约来计算新的替换值，&lt;code&gt;.&lt;/code&gt;所有期望的赋值都应用于&lt;code&gt;.&lt;/code&gt;，然后输出修改后的值。这个可以说明这一点：&lt;code&gt;{a:{b:{c:1}}} | (.a.b|=3), .&lt;/code&gt;. 这将输出 &lt;code&gt;{&quot;a&quot;:{&quot;b&quot;:3}}&lt;/code&gt;，&lt;code&gt;{&quot;a&quot;:{&quot;b&quot;:{&quot;c&quot;:1}}}&lt;/code&gt;因为最后一个子表达式&lt;code&gt;.&lt;/code&gt;, 看到的是原始值，而不是修改后的值。&lt;/p&gt;
&lt;p&gt;大多数用户都希望使用修改赋值运算符，例如&lt;code&gt;|=&lt;/code&gt;or &lt;code&gt;+=&lt;/code&gt;，而不是&lt;code&gt;=&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;请注意，赋值运算符的 LHS 是指 &lt;code&gt;.&lt;/code&gt;. 因此&lt;code&gt;$var.foo = 1&lt;/code&gt;不会按预期工作（&lt;code&gt;$var.foo&lt;/code&gt;在 中不是有效或有用的路径表达式&lt;code&gt;.&lt;/code&gt;）；改为使用&lt;code&gt;$var | .foo = 1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;还要注意，&lt;code&gt;.a,.b=0&lt;/code&gt;不设置&lt;code&gt;.a&lt;/code&gt;and &lt;code&gt;.b&lt;/code&gt;，而是 &lt;code&gt;(.a,.b)=0&lt;/code&gt;设置两者。&lt;/p&gt;
&lt;section id=&quot;Update-assignment:|=&quot;&gt;
&lt;h3&gt;更新分配：&lt;code&gt;|=&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;这是“更新”运算符&#x27;|=&#x27;。它在右侧采用一个过滤器，并&lt;code&gt;.&lt;/code&gt;通过该表达式运行旧值来计算分配给的属性的新值。例如， (.foo, .bar) |= .+1 将构建一个对象，其中“foo”字段设置为输入的“foo”加 1，“bar”字段设置为输入的“bar”加 1 .&lt;/p&gt;
&lt;p&gt;左侧可以是任何通用路径表达式；见&lt;code&gt;path()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;请注意，&#x27;|=&#x27; 的左侧指的是&lt;code&gt;.&lt;/code&gt;. 因此&lt;code&gt;$var.foo |= . + 1&lt;/code&gt;不会按预期工作（&lt;code&gt;$var.foo&lt;/code&gt;在 中不是有效或有用的路径表达式&lt;code&gt;.&lt;/code&gt;）；改为使用&lt;code&gt;$var | .foo |= . + 1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果右侧不输出任何值（即&lt;code&gt;empty&lt;/code&gt;），则左侧路径将被删除，与 一样&lt;code&gt;del(path)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果右侧输出多个值，则仅使用第一个值（兼容性说明：在 jq 1.5 及更早版本中，过去是仅使用最后一个）。&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;Arithmeticupdate-assignment:+=,-=,*=,/=,%=,//=&quot;&gt;
&lt;h3&gt;算术更新赋值：&lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;,&lt;code&gt;//=&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;jq 有几个形式的运算符&lt;code&gt;a op= b&lt;/code&gt;，它们都等价于&lt;code&gt;a |= . op b&lt;/code&gt;. 因此，&lt;code&gt;+= 1&lt;/code&gt;可用于增加值，与&lt;code&gt;|= . + 1&lt;/code&gt;.&lt;/p&gt;

&lt;/section&gt;
&lt;section id=&quot;Plainassignment:=&quot;&gt;
&lt;h3&gt;简单的分配：&lt;code&gt;=&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;这是普通的赋值运算符。与其他不同的是，右侧 (RHS) 的输入与左侧 (LHS) 的输入相同，而不是 LHS 路径上的值，并且 RHS 输出的所有值都将是使用（如下图）。&lt;/p&gt;
&lt;p&gt;如果 &#x27;=&#x27; 的 RHS 产生多个值，那么对于每个这样的值 jq 将左侧的路径设置为该值，然后它将输出修改后的&lt;code&gt;.&lt;/code&gt;. 例如， &lt;code&gt;(.a,.b)=range(2)&lt;/code&gt;输出&lt;code&gt;{&quot;a&quot;:0,&quot;b&quot;:0}&lt;/code&gt;，然后 &lt;code&gt;{&quot;a&quot;:1,&quot;b&quot;:1}&lt;/code&gt;。“更新”分配表格（见上文）不这样做。&lt;/p&gt;
&lt;p&gt;这个应该显示 &#x27;=&#x27; 和 &#x27;|=&#x27; 之间的区别：&lt;/p&gt;
&lt;p&gt;向程序提供输入 &#x27;{&quot;a&quot;: {&quot;b&quot;: 10}, &quot;b&quot;: 20}&#x27;：&lt;/p&gt;
&lt;p&gt;.a = .b&lt;/p&gt;
&lt;p&gt;.a |= .b&lt;/p&gt;
&lt;p&gt;前者将输入的“a”字段设置为输入的“b”字段，并产生输出{“a”：20，“b”：20}。后者会将输入的“a”字段设置为“a”字段的“b”字段，产生{“a”：10，“b”：20}。&lt;/p&gt;
&lt;p&gt;&#x27;=&#x27; 和 &#x27;|=&#x27; 之间区别的另一个：&lt;/p&gt;
&lt;p&gt;空|(.a,.b)=范围(3)&lt;/p&gt;
&lt;p&gt;输出 &#x27;{&quot;a&quot;:0,&quot;b&quot;:0}&#x27;、&#x27;{&quot;a&quot;:1,&quot;b&quot;:1}&#x27; 和 &#x27;{&quot;a&quot;:2,&quot;b&quot;:2}&#x27;，尽管&lt;/p&gt;
&lt;p&gt;空|(.a,.b)|=范围(3)&lt;/p&gt;
&lt;p&gt;只输出&#x27;{&quot;a&quot;:0,&quot;b&quot;:0}&#x27;。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;Complexassignments&quot;&gt;
&lt;h3&gt;复杂的任务&lt;/h3&gt;
&lt;p&gt;与大多数语言相比，jq 赋值左侧允许的内容更多。我们已经在左侧看到了简单的字段访问，数组访问也同样有效也就不足为奇了：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;.posts[0].title = &quot;JQ Manual&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;令人惊讶的是，左边的表达式可能会产生多个结果，指的是输入文档中的不同点：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;.posts[].comments |= . + [&quot;this is great&quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该示例将字符串“this is great”附加到输入中每个帖子的“comments”数组（其中输入是具有字段“posts”的对象，该字段是帖子数组）。&lt;/p&gt;
&lt;p&gt;当 jq 遇到像 &#x27;a = b&#x27; 这样的赋值时，它会记录在执行 a 时选择输入文档的一部分所采用的“路径”。然后，此路径用于查找在执行分配时要更改输入的哪一部分。任何过滤器都可以用在等号的左侧——它从输入中选择的任何路径都将是执行分配的地方。&lt;/p&gt;
&lt;p&gt;这是一个非常强大的操作。假设我们想为博客文章添加评论，使用上面相同的“博客”输入。这一次，我们只想评论“stedolan”写的帖子。我们可以使用前面描述的“选择”功能找到这些帖子：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;.posts[] | select(.author == &quot;stedolan&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该操作提供的路径指向“stedolan”写的每一个帖子，我们可以像之前一样对每一个帖子进行评论：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;(.posts[] | select(.author == &quot;stedolan&quot;) | .comments) |=
    . + [&quot;terrible.&quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&quot;Modules&quot;&gt;
&lt;h2&gt;模块&lt;/h2&gt;
&lt;p&gt;jq 有一个库/模块系统。模块是名称以 . 结尾的文件&lt;code&gt;.jq&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;程序导入的模块在默认搜索路径中搜索（见下文）。和指令允许导入&lt;code&gt;import&lt;/code&gt;器&lt;code&gt;include&lt;/code&gt;更改此路径。&lt;/p&gt;
&lt;p&gt;搜索路径中的路径会受到各种替换。&lt;/p&gt;
&lt;p&gt;对于以“~/”开头的路径，用户的主目录将替换为“~”。&lt;/p&gt;
&lt;p&gt;对于以“$ORIGIN/”开头的路径，jq 可执行文件的路径将替换为“$ORIGIN”。&lt;/p&gt;
&lt;p&gt;对于以“./”开头的路径或以“.”开头的路径，包含文件的路径将替换为“.”。对于命令行上给出的顶级程序，使用当前目录。&lt;/p&gt;
&lt;p&gt;导入指令可以选择指定附加默认值的搜索路径。&lt;/p&gt;
&lt;p&gt;默认搜索路径是赋予&lt;code&gt;-L&lt;/code&gt; 命令行选项 else的搜索路径&lt;code&gt;[&quot;~/.jq&quot;, &quot;$ORIGIN/../lib/jq&quot;, &quot;$ORIGIN/../lib&quot;]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Null 和空字符串路径元素终止搜索路径处理。&lt;/p&gt;
&lt;p&gt;将在给定搜索路径的“foo/bar.jq”和“foo/bar/bar.jq”中搜索具有相对路径“foo/bar”的依赖项。这旨在允许将模块与例如版本控制文件、自述文件等一起放置在目录中，但也允许单文件模块。&lt;/p&gt;
&lt;p&gt;不允许具有相同名称的连续组件以避免歧义（例如，“foo/foo”）。&lt;/p&gt;
&lt;p&gt;例如，可以在 和中找到&lt;code&gt;-L$HOME/.jq&lt;/code&gt;一个模块。&lt;code&gt;foo&lt;/code&gt;&lt;code&gt;$HOME/.jq/foo.jq&lt;/code&gt;&lt;code&gt;$HOME/.jq/foo/foo.jq&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果“$HOME/.jq”是一个文件，它会被引入主程序。&lt;/p&gt;
&lt;section id=&quot;importRelativePathStringasNAME[&amp;lt;metadata&amp;gt;];&quot;&gt;
&lt;h3&gt;&lt;code&gt;import RelativePathString as NAME [&amp;lt;metadata&amp;gt;];&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;导入在相对于搜索路径中的目录的给定路径中找到的模块。“.jq”后缀将添加到相对路径字符串中。模块的符号以“NAME::”为前缀。&lt;/p&gt;
&lt;p&gt;可选元数据必须是常量 jq 表达式。它应该是一个带有“主页”等键的对象。此时 jq 只使用元数据的“搜索”键/值。元数据也通过 &lt;code&gt;modulemeta&lt;/code&gt;内置提供给用户。&lt;/p&gt;
&lt;p&gt;元数据中的“搜索”键（如果存在）应具有字符串或数组值（字符串数组）；这是作为顶级搜索路径前缀的搜索路径。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;includeRelativePathString[&amp;lt;metadata&amp;gt;];&quot;&gt;
&lt;h3&gt;&lt;code&gt;include RelativePathString [&amp;lt;metadata&amp;gt;];&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;导入在给定路径中找到的模块，该模块相对于搜索路径中的目录，就好像它被包含在适当位置一样。“.jq”后缀将添加到相对路径字符串中。模块的符号被导入调用者的命名空间，就好像模块的内容被直接包含在内一样。&lt;/p&gt;
&lt;p&gt;可选元数据必须是常量 jq 表达式。它应该是一个带有“主页”等键的对象。此时 jq 只使用元数据的“搜索”键/值。元数据也通过 &lt;code&gt;modulemeta&lt;/code&gt;内置提供给用户。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;importRelativePathStringas$NAME[&amp;lt;metadata&amp;gt;];&quot;&gt;
&lt;h3&gt;&lt;code&gt;import RelativePathString as $NAME [&amp;lt;metadata&amp;gt;];&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;导入在相对于搜索路径中的目录的给定路径中找到的 JSON 文件。“.json”后缀将添加到相对路径字符串中。该文件的数据将以&lt;code&gt;$NAME::NAME&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;可选元数据必须是常量 jq 表达式。它应该是一个带有“主页”等键的对象。此时 jq 只使用元数据的“搜索”键/值。元数据也通过 &lt;code&gt;modulemeta&lt;/code&gt;内置提供给用户。&lt;/p&gt;
&lt;p&gt;元数据中的“搜索”键（如果存在）应具有字符串或数组值（字符串数组）；这是作为顶级搜索路径前缀的搜索路径。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;module&amp;lt;metadata&amp;gt;;&quot;&gt;
&lt;h3&gt;&lt;code&gt;module &amp;lt;metadata&amp;gt;;&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;该指令完全是可选的。它不是正确操作所必需的。它仅用于提供可以使用&lt;code&gt;modulemeta&lt;/code&gt;内置函数读取的元数据。&lt;/p&gt;
&lt;p&gt;元数据必须是常量 jq 表达式。它应该是一个带有“主页”之类的键的对象。此时 jq 不使用此元数据，但它通过 &lt;code&gt;modulemeta&lt;/code&gt;内置提供给用户。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&quot;modulemeta&quot;&gt;
&lt;h3&gt;&lt;code&gt;modulemeta&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;将模块名称作为输入并将模块的元数据作为对象输出，模块的导入（包括元数据）作为“deps”键的数组值。&lt;/p&gt;
&lt;p&gt;程序可以使用它来查询模块的元数据，然后他们可以使用它来搜索、下载和安装缺少的依赖项。&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8d58b9ea2841dc60cff162afaac87998</guid>
<title>Three.js系列: 在元宇宙看电影，享受 VR 视觉盛宴</title>
<link>https://toutiao.io/k/gsrdl2c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;br/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由于上一次发布图片有点问题，重新更正了一下，望大家见谅。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文 gihtub 地址: https://github.com/hua1995116/Fly-Three.js&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最近元宇宙的概念很火，并且受到疫情的影响，我们的出行总是受限，电影院也总是关门，但是在家里又没有看大片的氛围，这个时候我们就可以通过自己来造一个宇宙，并在 VR 设备（Oculus 、cardboard）中来观看。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;今天我打算用 Three.js 来实现个人 VR 电影展厅，整个过程非常的简单，哪怕不会编程都可以轻易掌&lt;/span&gt;&lt;span&gt;握。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要顶级的视觉盛宴，最重要的肯定是得要一块大屏幕，首先我们就先来实现一块大屏幕。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大屏幕的实现主要有两种几何体，一种是 PlaneGeometry 和 BoxGeometry，一个是平面，一个是六面体。为了使得屏幕更加有立体感，我选择了 BoxGeometry。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老样子，在添加物体之前，我们先要初始化我们的相机、场景和灯光等一些基础的元件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; scene = &lt;span&gt;new&lt;/span&gt; THREE.Scene();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 相机&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; camera = &lt;span&gt;new&lt;/span&gt; THREE.PerspectiveCamera(&lt;br/&gt;    &lt;span&gt;75&lt;/span&gt;,&lt;br/&gt;    sizes.width / sizes.height,&lt;br/&gt;    &lt;span&gt;0.1&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;1000&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;camera.position.x = &lt;span&gt;-5&lt;/span&gt;&lt;br/&gt;camera.position.y = &lt;span&gt;5&lt;/span&gt;&lt;br/&gt;camera.position.z = &lt;span&gt;5&lt;/span&gt;&lt;br/&gt;scene.add(camera);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 添加光照&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; ambientLight = &lt;span&gt;new&lt;/span&gt; THREE.AmbientLight(&lt;span&gt;0xffffff&lt;/span&gt;, &lt;span&gt;0.5&lt;/span&gt;)&lt;br/&gt;scene.add(ambientLight)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; directionalLight = &lt;span&gt;new&lt;/span&gt; THREE.DirectionalLight(&lt;span&gt;0xffffff&lt;/span&gt;, &lt;span&gt;0.5&lt;/span&gt;)&lt;br/&gt;directionalLight.position.set(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;-1&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;scene.add(directionalLight)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 控制器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; controls = &lt;span&gt;new&lt;/span&gt; OrbitControls(camera, canvas);&lt;br/&gt;scene.add(camera);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后来写我们的核心代码，创建一个 5 * 5 的超薄长方体&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; geometry = &lt;span&gt;new&lt;/span&gt; THREE.BoxGeometry(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;0.2&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; cubeMaterial = &lt;span&gt;new&lt;/span&gt; THREE.MeshStandardMaterial({&lt;br/&gt;    &lt;span&gt;color&lt;/span&gt;: &lt;span&gt;&#x27;#ff0000&#x27;&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; cubeMesh = &lt;span&gt;new&lt;/span&gt; THREE.Mesh(geometry, cubeMaterial);&lt;br/&gt;scene.add(cubeMesh);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;效果如下:&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibGQibkduDnBl4SjqAwuW3Y0VDYibx7qzCDVia6InZPn331TSEgWey5kiclL9AibOCZwJth0TqjIRrcn5wic4BnTCHKg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;1.0734375&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后紧接着加入我们的视频内容，想要把视频放入到3d场景中，需要用到两样东西，一个是 html 的 video 标签，另一个是 Three.js 中的视频纹理 VideoTexture&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步将视频标签放入到 html 中，并设置自定播放以及不让他显示在屏幕中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;...&lt;br/&gt;&amp;lt;canvas &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;webgl&quot;&lt;/span&gt;&amp;gt;&amp;lt;&lt;span&gt;/canvas&amp;gt;&lt;br/&gt;&amp;lt;video &lt;br/&gt;  id=&quot;video&quot;&lt;br/&gt;  src=&quot;./&lt;/span&gt;pikachu.mp4&lt;span&gt;&quot;&lt;br/&gt;  playsinline&lt;br/&gt;  webkit-playsinline&lt;br/&gt;  autoplay&lt;br/&gt;  loop&lt;br/&gt;  style=&quot;&lt;/span&gt;display:none&lt;span&gt;&quot;&lt;br/&gt;  &amp;gt;&amp;lt;/video&amp;gt;&lt;br/&gt;...&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步，获取到 video 标签的内容将它传给 VideoTexture，并且纹理赋给我们的材质。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;+&lt;span&gt;const&lt;/span&gt; video = &lt;span&gt;document&lt;/span&gt;.getElementById( &lt;span&gt;&#x27;video&#x27;&lt;/span&gt; );&lt;br/&gt;+&lt;span&gt;const&lt;/span&gt; texture = &lt;span&gt;new&lt;/span&gt; THREE.VideoTexture( video );&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; geometry = &lt;span&gt;new&lt;/span&gt; THREE.BoxGeometry(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;0.2&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; cubeMaterial = &lt;span&gt;new&lt;/span&gt; THREE.MeshStandardMaterial({&lt;br/&gt;-    color: &lt;span&gt;&#x27;#ff0000&#x27;&lt;/span&gt;&lt;br/&gt;+    map: texture&lt;br/&gt;});&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; cubeMesh = &lt;span&gt;new&lt;/span&gt; THREE.Mesh(geometry, cubeMaterial);&lt;br/&gt;scene.add(cubeMesh);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.98125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibGQibkduDnBl4SjqAwuW3Y0VDYibx7qzCLAt9Kib3eE97qiaeswgzrVVU7eHsXMXwYjHEodTR9OgpFxvS3ibjtCGibQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到皮神明显被拉伸了，这里就出现了一个问题就是纹理的拉伸。这也很好理解，我们的屏幕是 1 : 1 的，但是我们的视频却是 16:9 的。想要解决其实也很容易，要么就是让我们的屏幕大小更改，要么就是让我们的视频纹理渲染的时候更改比例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种方案很简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过修改几何体的形状（也及时我们显示器的比例）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; geometry = &lt;span&gt;new&lt;/span&gt; THREE.BoxGeometry(&lt;span&gt;8&lt;/span&gt;, &lt;span&gt;4.5&lt;/span&gt;, &lt;span&gt;0.2&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; cubeMaterial = &lt;span&gt;new&lt;/span&gt; THREE.MeshStandardMaterial({&lt;br/&gt;    &lt;span&gt;map&lt;/span&gt;: texture&lt;br/&gt;});&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; cubeMesh = &lt;span&gt;new&lt;/span&gt; THREE.Mesh(geometry, cubeMaterial);&lt;br/&gt;scene.add(cubeMesh);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二种方案稍微有点复杂，需要知道一定的纹理贴图相关的知识&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/gibGQibkduDnD3V44YOhxhwZ2Za5tDjpesiaLlq1XNl8tSe0ic8KPnYUbzOdy8HrSSsLZHQ58lrGFNEuDaicfq0NichA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;Untitled&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图1-1&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们先要知道纹理坐标是由 u 和 v 两个方向组成，并且取值都为 0 - 1。通过在 fragment shader 中，查询 uv 坐标来获取每个像素的像素值，从而渲染整个图。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此如果纹理图是一张16:9 的，想要映射到一个长方形的面中，那么纹理图必要会被拉伸，就像我们上面的视频一样，上面的图为了表现出电视机的厚度所以没有那么明显，可以看一下的图。（第一张比较暗是因为 Three.js 默认贴图计算了光照，先忽略这一点）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibGQibkduDnBl4SjqAwuW3Y0VDYibx7qzCnP8R9KUB2nJyH5cBpdK7e1xicZzibKedBhVGXsoGUWLm0rdoVYNkA5QA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibGQibkduDnBl4SjqAwuW3Y0VDYibx7qzCfdE7KNOno5uNTGl0PGicO3r94cg2aicsXcDKVCO9XCFwjhhbTlZF5hlw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来捋一捋，假设我们的图片的映射是按照 图1-1，拉伸的情况下  (80,80,0) 映射的是 uv(1，1 )，但是其实我们期望的是点(80, 80 * 9/16, 0) 映射的是 uv(1,1)，所以问题变成了像素点位 (80, 80 * 9/16, 0) 的uv值 如何变成 (80, 80, 0) 的uv 值，更加简单一些就是如何让 80 * 9 / 16 变成 80，答案显而易见，就是 让 80 * 9 / 16 像素点的 v 值 乘以  16 / 9，这样就能找到了 uv(1,1) 的像素值。然后我们就可以开始写 shader 了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 在顶点着色器传递 uv&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; vshader = &lt;span&gt;`&lt;br/&gt;varying vec2 vUv;&lt;br/&gt;&lt;br/&gt;void main() {&lt;br/&gt;  vUv = uv;&lt;br/&gt;&lt;br/&gt;  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );&lt;br/&gt;}&lt;br/&gt;`&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 核心逻辑就是 vec2 uv = vUv * acept; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; fshader = &lt;span&gt;`&lt;br/&gt;varying vec2 vUv;&lt;br/&gt;&lt;br/&gt;uniform sampler2D u_tex;&lt;br/&gt;uniform vec2 acept;&lt;br/&gt;&lt;br/&gt;void main()&lt;br/&gt;{&lt;br/&gt;  vec2 uv = vUv * acept;&lt;br/&gt;  vec3 color = vec3(0.3);&lt;br/&gt;  if (uv.x&amp;gt;=0.0 &amp;amp;&amp;amp; uv.y&amp;gt;=0.0 &amp;amp;&amp;amp; uv.x&amp;lt;1.0 &amp;amp;&amp;amp; uv.y&amp;lt;1.0) color = texture2D(u_tex, uv).rgb;&lt;br/&gt;  gl_FragColor = vec4(color, 1.0);&lt;br/&gt;}&lt;br/&gt;`&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.03125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibGQibkduDnBl4SjqAwuW3Y0VDYibx7qzCU7kMCE4ibwxiceicRXjqKP1ZwygbElp4icqTA5MAV0jqDJbcr10UVwPyNw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们看到我们画面已经正常了，但是在整体屏幕的下方，所以还差一点点我们需要将它移动到屏幕的中央。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;移动到中央的思路和上面差不多，我们只需要注重边界点，假设边界点 C 就是让 80 * ( 0.5 + 9/16 * 0.5  )  变成 80 ，很快我们也可能得出算是 C * 16/9 - 16/9 * 0.5 + 0.5 = 80&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后来修改 shader，顶点着色器不用改，我们只需要修改片段着色器。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; fshader = &lt;span&gt;`&lt;br/&gt;varying vec2 vUv;&lt;br/&gt;&lt;br/&gt;uniform sampler2D u_tex;&lt;br/&gt;uniform vec2 acept;&lt;br/&gt;&lt;br/&gt;void main()&lt;br/&gt;{&lt;br/&gt;  vec2 uv = vec2(0.5) + vUv * acept - acept*0.5;&lt;br/&gt;  vec3 color = vec3(0.0);&lt;br/&gt;  if (uv.x&amp;gt;=0.0 &amp;amp;&amp;amp; uv.y&amp;gt;=0.0 &amp;amp;&amp;amp; uv.x&amp;lt;1.0 &amp;amp;&amp;amp; uv.y&amp;lt;1.0) color = texture2D(u_tex, uv).rgb;&lt;br/&gt;  gl_FragColor = vec4(color, 1.0);&lt;br/&gt;}&lt;br/&gt;`&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，到现在为止，我们的图像显示正常啦~&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.76875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibGQibkduDnBl4SjqAwuW3Y0VDYibx7qzCqEuhtibE7S84wHePqXibiceEaL92CGibicr3mbHoxuFPuaxlV99Gm8mtS2g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么 Three.js 中的 textureVideo 到底是如何实现视频的播放的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibGQibkduDnBl4SjqAwuW3Y0VDYibx7qzCMD2u1oxnNIp2ORqnicFq0jeuYthMqMT49BPmY7wasyNpZ8wev31LtUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.76875&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过查看源码（https://github.com/mrdoob/three.js/blob/6e897f9a42d615403dfa812b45663149f2d2db3e/src/textures/VideoTexture.js）源码非常的少，VideoTexture 继承了 Texture ，最大的一点就是通过 &lt;strong&gt;requestVideoFrameCallback 这个方法，&lt;/strong&gt;我们来看看它的定义，&lt;strong&gt;发现 mdn 没有相关的示例，我们来到了 w3c 规范中寻找&lt;/strong&gt; https://wicg.github.io/video-rvfc/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个属性主要是获取每一帧的图形，可以通过以下的小 demo 来进行理解&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;body&amp;gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;video&lt;/span&gt; &lt;span&gt;controls&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;video&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;canvas&lt;/span&gt; &lt;span&gt;width&lt;/span&gt;=&lt;span&gt;&quot;640&quot;&lt;/span&gt; &lt;span&gt;height&lt;/span&gt;=&lt;span&gt;&quot;360&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;canvas&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;span&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;fps_text&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&amp;lt;&lt;span&gt;/body&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;script&amp;gt;&lt;br/&gt;  function startDrawing() {&lt;br/&gt;    var video = document.querySelector(&#x27;video&#x27;);&lt;br/&gt;    var canvas = document.querySelector(&#x27;canvas&#x27;);&lt;br/&gt;    var ctx = canvas.getContext(&#x27;2d&#x27;);&lt;br/&gt;&lt;br/&gt;    var paint_count = 0;&lt;br/&gt;    var start_time = 0.0;&lt;br/&gt;&lt;br/&gt;    var updateCanvas = function(now) {&lt;br/&gt;      if(start_time == 0.0)&lt;br/&gt;        start_time = now;&lt;br/&gt;&lt;br/&gt;      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);&lt;br/&gt;&lt;br/&gt;      var elapsed = (now - start_time) /&lt;/span&gt; &lt;span&gt;1000.0&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;var&lt;/span&gt; fps = (++paint_count / elapsed).toFixed(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;      &lt;span&gt;document&lt;/span&gt;.querySelector(&lt;span&gt;&#x27;#fps_text&#x27;&lt;/span&gt;).innerText = &lt;span&gt;&#x27;video fps: &#x27;&lt;/span&gt; + fps;&lt;br/&gt;&lt;br/&gt;      video.requestVideoFrameCallback(updateCanvas);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    video.requestVideoFrameCallback(updateCanvas);&lt;br/&gt;&lt;br/&gt;    video.src = &lt;span&gt;&quot;http://example.com/foo.webm&quot;&lt;/span&gt;&lt;br/&gt;    video.play()&lt;br/&gt;  }&lt;br/&gt;&amp;lt;&lt;span&gt;/script&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上的理解，可以很容易抽象出整个过程，通过 &lt;strong&gt;requestVideoFrameCallback&lt;/strong&gt; 获取视频每一帧的画面，然后用 Texture 去渲染到物体上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1939799331103679&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/gibGQibkduDnD3V44YOhxhwZ2Za5tDjpesrH253j5j5lq4icibK6KcundcDYCrTP1CGP0VqwuUxnRgxsTaSaHnM3Hw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1196&quot;/&gt;&lt;figcaption&gt;Untitled&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们来加入 VR 代码， Three.js 默认给他们提供了建立 VR 的方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// step1 引入 VRButton&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { VRButton } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;three/examples/jsm/webxr/VRButton.js&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;// step2 将 VRButton 创造的dom添加进body &lt;/span&gt;&lt;br/&gt;&lt;span&gt;document&lt;/span&gt;.body.appendChild( VRButton.createButton( renderer ) );&lt;br/&gt;&lt;span&gt;// step3 设置开启 xr&lt;/span&gt;&lt;br/&gt;renderer.xr.enabled = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;// step4 修改更新函数&lt;/span&gt;&lt;br/&gt;renderer.setAnimationLoop( &lt;span&gt;&lt;span&gt;function&lt;/span&gt; () &lt;/span&gt;{&lt;br/&gt; renderer.render( scene, camera );&lt;br/&gt;} );&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 iphone 太拉胯不支持 webXR ，特地借了台安卓机（安卓机需要下载 Google Play、Chrome 、Google VR），添加以上步骤后，就会如下显示：&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.222&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibGQibkduDnBl4SjqAwuW3Y0VDYibx7qzCkJ7ERS7ZzGycAhW9F1Yg28eczysPzibrdQfz0icElIcUroflfBcEOz6g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击 &lt;code&gt;ENTER XR&lt;/code&gt; 按钮后，即可进入 VR 场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibGQibkduDnBl4SjqAwuW3Y0VDYibx7qzClEXJamWdfZibcBAly1BDbnPI4VXjCAvdAXDyNoJMtBM5aKRWrgXlBOQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.45&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;br/&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们我们可以再花20块钱就可以买个谷歌眼镜 cardboard。体验地址如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://fly-three-js.vercel.app/lesson03/code/index4.html&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibGQibkduDnBl4SjqAwuW3Y0VDYibx7qzC2EXGqXwrs6TkpHSkFbuCGAwzLibX6n5WK4bNgia1v0iagvhPbP9qZmsXQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者也可以像我一样买一个 Oculus  然后躺着看大片&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibGQibkduDnBl4SjqAwuW3Y0VDYibx7qzCRSO46WlzU4Ho9YRPIw1fk2GWTlGbo3BNsl1FJj5fhPR4AJvlUZwYVQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;系列文章&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyOTIxMDAzNw==&amp;amp;mid=2247492415&amp;amp;idx=1&amp;amp;sn=e721d4d15b4158dd71d6606c5ff1a585&amp;amp;chksm=c20fa8e5f57821f359318c6afea1034384eaa3c0f440b10557d9350607c5adbd847b9e0b146d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;造个海洋球池来学习物理引擎【Three.js系列】&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;span&gt;造个海洋球池来学习物理引擎【Three.js系列】&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyOTIxMDAzNw==&amp;amp;mid=2247491969&amp;amp;idx=1&amp;amp;sn=b37d8f181c7989a23d71db5d589a49fe&amp;amp;chksm=c20faa5bf578234d9a2e42dc5e67a4610a777ecb03845c49ef1341cacecfeadecb9a3eaff30c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Three.js系列:   游戏中的第一/三人称视角&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Three.js系列:   游戏中的第一/三人称视角&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>