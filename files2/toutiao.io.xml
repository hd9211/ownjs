<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>24a5ec41b78794f73ea98540e4c60286</guid>
<title>如何记住所学的东西？｜码农周刊VIP会员专属邮件周报 Vol.088</title>
<link>https://toutiao.io/k/zyo6ijj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;logged-out env-production page-responsive page-blob global-focus-styles&quot; id=&quot;readabilityBody&quot;&gt;
    

    

  &lt;p id=&quot;start-of-content&quot; class=&quot;show-on-focus&quot;/&gt;







    


    

  &lt;include-fragment class=&quot;js-notification-shelf-include-fragment&quot; data-base-src=&quot;https://github.com/notifications/beta/shelf&quot;/&gt;





  &lt;div class=&quot;application-main &quot; data-commit-hovercards-enabled=&quot;&quot; data-discussion-hovercards-enabled=&quot;&quot; data-issue-and-pr-hovercards-enabled=&quot;&quot;&gt;
        &lt;div itemscope=&quot;&quot; itemtype=&quot;http://schema.org/SoftwareSourceCode&quot; class=&quot;&quot;&gt;
    &lt;main id=&quot;js-repo-pjax-container&quot; data-pjax-container=&quot;&quot;&gt;
      

    
    








  



&lt;div id=&quot;repo-content-pjax-container&quot; class=&quot;repository-content &quot;&gt;
  
  


  
      
  &lt;div class=&quot;clearfix container-xl px-3 px-md-4 px-lg-5 mt-4&quot;&gt;
    
    
&lt;div&gt;
  




    
&lt;a class=&quot;d-none js-permalink-shortcut&quot; data-hotkey=&quot;y&quot; href=&quot;/toutiaoio/weekly.manong.io/blob/d3e6eab8472ca7b3eca8d5a0815eaaa7c6f561eb/docs/vol.088.md?hmsr=toutiao.io&amp;amp;utm_campaign=toutiao.io&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=toutiao.io&quot;&gt;Permalink&lt;/a&gt;







    &lt;div id=&quot;spoof-warning&quot; class=&quot;mt-0 pb-3&quot; hidden=&quot;&quot; aria-hidden=&quot;&quot;&gt;
  &lt;div data-view-component=&quot;true&quot; class=&quot;flash flash-warn mt-0 clearfix&quot;&gt;
  
  
    &lt;svg aria-hidden=&quot;true&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; data-view-component=&quot;true&quot; class=&quot;octicon octicon-alert float-left mt-1&quot;&gt;
    &lt;path fill-rule=&quot;evenodd&quot; d=&quot;M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z&quot;/&gt;
&lt;/svg&gt;

      &lt;p class=&quot;overflow-hidden&quot;&gt;This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.&lt;/p&gt;


  
&lt;/div&gt;&lt;/div&gt;

    &lt;include-fragment src=&quot;/toutiaoio/weekly.manong.io/spoofed_commit_check/d3e6eab8472ca7b3eca8d5a0815eaaa7c6f561eb&quot; data-test-selector=&quot;spoofed-commit-check&quot;/&gt;

    &lt;div class=&quot;Box d-flex flex-column flex-shrink-0 mb-3&quot;&gt;
  
  

  &lt;div class=&quot;Box-body d-flex flex-items-center flex-auto border-bottom-0 flex-wrap&quot;&gt;
    &lt;details class=&quot;details-reset details-overlay details-overlay-dark lh-default color-fg-default float-left mr-3&quot; id=&quot;blob_contributors_box&quot;&gt;
      &lt;summary class=&quot;Link--primary&quot;&gt;
        &lt;svg text=&quot;gray&quot; aria-hidden=&quot;true&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; data-view-component=&quot;true&quot; class=&quot;octicon octicon-people&quot;&gt;
    &lt;path fill-rule=&quot;evenodd&quot; d=&quot;M5.5 3.5a2 2 0 100 4 2 2 0 000-4zM2 5.5a3.5 3.5 0 115.898 2.549 5.507 5.507 0 013.034 4.084.75.75 0 11-1.482.235 4.001 4.001 0 00-7.9 0 .75.75 0 01-1.482-.236A5.507 5.507 0 013.102 8.05 3.49 3.49 0 012 5.5zM11 4a.75.75 0 100 1.5 1.5 1.5 0 01.666 2.844.75.75 0 00-.416.672v.352a.75.75 0 00.574.73c1.2.289 2.162 1.2 2.522 2.372a.75.75 0 101.434-.44 5.01 5.01 0 00-2.56-3.012A3 3 0 0011 4z&quot;/&gt;
&lt;/svg&gt;
        &lt;strong&gt;1&lt;/strong&gt;
        
        contributor
      &lt;/summary&gt;
      &lt;details-dialog class=&quot;Box Box--overlay d-flex flex-column anim-fade-in fast&quot; aria-label=&quot;Users who have contributed to this file&quot; src=&quot;/toutiaoio/weekly.manong.io/contributors-list/master/docs/vol.088.md&quot; preload=&quot;&quot;&gt;
        &lt;div class=&quot;Box-header&quot;&gt;
          &lt;button class=&quot;Box-btn-octicon btn-octicon float-right&quot; type=&quot;button&quot; aria-label=&quot;Close dialog&quot; data-close-dialog=&quot;&quot;&gt;
            &lt;svg aria-hidden=&quot;true&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; data-view-component=&quot;true&quot; class=&quot;octicon octicon-x&quot;&gt;
    &lt;path fill-rule=&quot;evenodd&quot; d=&quot;M3.72 3.72a.75.75 0 011.06 0L8 6.94l3.22-3.22a.75.75 0 111.06 1.06L9.06 8l3.22 3.22a.75.75 0 11-1.06 1.06L8 9.06l-3.22 3.22a.75.75 0 01-1.06-1.06L6.94 8 3.72 4.78a.75.75 0 010-1.06z&quot;/&gt;
&lt;/svg&gt;
          &lt;/button&gt;
          &lt;h3 class=&quot;Box-title&quot;&gt;
            Users who have contributed to this file
          &lt;/h3&gt;
        &lt;/div&gt;
        &lt;include-fragment&gt;
          &lt;svg viewbox=&quot;0 0 16 16&quot; fill=&quot;none&quot; data-view-component=&quot;true&quot; class=&quot;my-3 mx-auto d-block anim-rotate&quot;&gt;
  &lt;circle cx=&quot;8&quot; cy=&quot;8&quot; r=&quot;7&quot; stroke=&quot;currentColor&quot; stroke-opacity=&quot;0.25&quot; stroke-width=&quot;2&quot; vector-effect=&quot;non-scaling-stroke&quot;/&gt;
  &lt;path d=&quot;M15 8a7.002 7.002 0 00-7-7&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; vector-effect=&quot;non-scaling-stroke&quot;/&gt;
&lt;/svg&gt;
        &lt;/include-fragment&gt;
      &lt;/details-dialog&gt;
    &lt;/details&gt;
  &lt;/div&gt;
&lt;/div&gt;







    &lt;readme-toc&gt;

    &lt;div data-target=&quot;readme-toc.content&quot; class=&quot;Box mt-3 position-relative&quot;&gt;
      
  &lt;div class=&quot;Box-header js-blob-header blob-header js-sticky js-position-sticky top-0 p-2 d-flex flex-shrink-0 flex-md-row flex-items-center&quot;&gt;

      &lt;details data-target=&quot;readme-toc.trigger&quot; data-menu-hydro-click=&quot;{&amp;quot;event_type&amp;quot;:&amp;quot;repository_toc_menu.click&amp;quot;,&amp;quot;payload&amp;quot;:{&amp;quot;target&amp;quot;:&amp;quot;trigger&amp;quot;,&amp;quot;repository_id&amp;quot;:193332705,&amp;quot;originating_url&amp;quot;:&amp;quot;https://github.com/toutiaoio/weekly.manong.io/blob/master/docs/vol.088.md?hmsr=toutiao.io&amp;amp;utm_campaign=toutiao.io&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=toutiao.io&amp;quot;,&amp;quot;user_id&amp;quot;:null}}&quot; data-menu-hydro-click-hmac=&quot;8aa4248431d54c2bc9e32fc838f3d2024ffff6157d04d061931a359ddb3cb80f&quot; class=&quot;dropdown details-reset details-overlay&quot;&gt;
  &lt;summary class=&quot;btn btn-octicon m-0 mr-2 p-2&quot; aria-haspopup=&quot;true&quot; aria-label=&quot;Table of Contents&quot;&gt;
    &lt;svg aria-hidden=&quot;true&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; data-view-component=&quot;true&quot; class=&quot;octicon octicon-list-unordered&quot;&gt;
    &lt;path fill-rule=&quot;evenodd&quot; d=&quot;M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z&quot;/&gt;
&lt;/svg&gt;
  &lt;/summary&gt;


  &lt;details-menu class=&quot;SelectMenu&quot; role=&quot;menu&quot;&gt;
    
  &lt;/details-menu&gt;
&lt;/details&gt;


  &lt;p class=&quot;text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1&quot;&gt;

      83 lines (53 sloc)
      &lt;span class=&quot;file-info-divider&quot;/&gt;
    4.2 KB
  &lt;/p&gt;

  

    
&lt;/div&gt;


        &lt;div id=&quot;readme&quot; class=&quot;Box-body readme blob js-code-block-container p-5 p-xl-6 gist-border-0&quot;&gt;
    &lt;article class=&quot;markdown-body entry-content container-lg&quot; itemprop=&quot;text&quot;&gt;&lt;h2 data-sourcepos=&quot;1:1-1:83&quot; dir=&quot;auto&quot;&gt;&lt;a id=&quot;user-content-如何记住所学的东西码农周刊vip会员专属邮件周报-vol088&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#如何记住所学的东西码农周刊vip会员专属邮件周报-vol088&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;如何记住所学的东西？｜码农周刊VIP会员专属邮件周报 Vol.088&lt;/h2&gt;
&lt;blockquote data-sourcepos=&quot;3:1-3:112&quot;&gt;
&lt;p data-sourcepos=&quot;3:3-3:112&quot; dir=&quot;auto&quot;&gt;本文内容节选自「码农周刊VIP会员专属邮件周报 Vol.088」，每周五发送，欢迎订阅！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-sourcepos=&quot;5:1-5:224&quot; dir=&quot;auto&quot;&gt;&lt;a href=&quot;#%E7%AE%80%E4%BB%8B&quot;&gt;码农周刊简介&lt;/a&gt;｜&lt;a href=&quot;#VIP%E4%BC%9A%E5%91%98%E7%89%B9%E6%9D%83&quot;&gt;VIP会员特权&lt;/a&gt;｜&lt;a href=&quot;#%E6%88%90%E4%B8%BA%E7%A0%81%E5%86%9C%E5%91%A8%E5%88%8AVIP%E4%BC%9A%E5%91%98&quot;&gt;成为码农周刊VIP会员&lt;/a&gt;｜&lt;a href=&quot;#VIP%E4%BC%9A%E5%91%98%E4%B8%93%E5%B1%9E%E9%82%AE%E4%BB%B6%E5%91%A8%E6%8A%A5&quot;&gt;VIP会员专属邮件周报&lt;/a&gt;｜&lt;a href=&quot;#%E5%BE%80%E6%9C%9F%E5%AD%98%E6%A1%A3&quot;&gt;往期存档&lt;/a&gt;&lt;/p&gt;
&lt;h2 data-sourcepos=&quot;7:1-7:90&quot; dir=&quot;auto&quot;&gt;&lt;a id=&quot;user-content-本期首先分享的是如何记住所学的东西摘录几条供参考&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#本期首先分享的是如何记住所学的东西摘录几条供参考&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;本期，首先分享的是如何记住所学的东西？，摘录几条，供参考。&lt;/h2&gt;
&lt;ul data-sourcepos=&quot;8:1-14:0&quot; dir=&quot;auto&quot;&gt;
&lt;li data-sourcepos=&quot;8:1-8:77&quot;&gt;学习要以时间为基础，定期休息，了解你好奇的是什么；&lt;/li&gt;
&lt;li data-sourcepos=&quot;9:1-9:113&quot;&gt;学习的时候要清理工作记忆，应用元认知，用问题去“围攻”学习对象，改善理解；&lt;/li&gt;
&lt;li data-sourcepos=&quot;10:1-10:110&quot;&gt;课后要写高度概括的总结，细化，交叉学习，转化，并选出永远不能忘记的东西；&lt;/li&gt;
&lt;li data-sourcepos=&quot;11:1-11:113&quot;&gt;课余跟朋友讨论自己学了什么，应用间隔重复来防止遗忘，并养成每天回忆的习惯；&lt;/li&gt;
&lt;li data-sourcepos=&quot;12:1-12:77&quot;&gt;应用综合练习，通过对复杂环境的模式匹配来掌握知识。&lt;/li&gt;
&lt;li data-sourcepos=&quot;13:1-14:0&quot;&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 data-sourcepos=&quot;15:1-15:18&quot; dir=&quot;auto&quot;&gt;&lt;a id=&quot;user-content-内容节选&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#内容节选&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;内容节选 &lt;/h2&gt;
&lt;p data-sourcepos=&quot;16:1-16:84&quot; dir=&quot;auto&quot;&gt;1、&lt;a href=&quot;https://mp.weixin.qq.com/s/qSNURmWMfep20o-AwOoEFg&quot; rel=&quot;nofollow&quot;&gt;中国云市场的新逻辑&lt;/a&gt;&lt;/p&gt;
&lt;p data-sourcepos=&quot;18:1-18:138&quot; dir=&quot;auto&quot;&gt;市场环境和政策环境都在变化，云公司的商业模型、技术模型、政策法规模型，以及自身定位均需重构。&lt;/p&gt;
&lt;p data-sourcepos=&quot;20:1-20:99&quot; dir=&quot;auto&quot;&gt;2、&lt;a href=&quot;https://mp.weixin.qq.com/s/m71kjgIy3m4hKTgRXqzOqQ&quot; rel=&quot;nofollow&quot;&gt;深度起底赵长鹏和他的数字货币&lt;/a&gt;&lt;/p&gt;
&lt;p data-sourcepos=&quot;22:1-22:45&quot; dir=&quot;auto&quot;&gt;全球流浪的“华人首富”无房无车&lt;/p&gt;
&lt;p data-sourcepos=&quot;24:1-24:73&quot; dir=&quot;auto&quot;&gt;3、&lt;a href=&quot;https://toutiao.io/k/acuovgh&quot; rel=&quot;nofollow&quot;&gt;从 VSCode 看大型 IDE 技术架构&lt;/a&gt;&lt;/p&gt;
&lt;p data-sourcepos=&quot;26:1-26:98&quot; dir=&quot;auto&quot;&gt;VSCode 开发团队从 10 来个人开始，早期成员大多有 Eclipse 开发团队的背景。&lt;/p&gt;
&lt;p data-sourcepos=&quot;28:1-28:90&quot; dir=&quot;auto&quot;&gt;4、&lt;a href=&quot;https://toutiao.io/k/0up430p&quot; rel=&quot;nofollow&quot;&gt;知乎的用户画像与实时数据的架构与实践&lt;/a&gt;&lt;/p&gt;
&lt;p data-sourcepos=&quot;30:1-30:27&quot; dir=&quot;auto&quot;&gt;实践经验和心得体会&lt;/p&gt;
&lt;p data-sourcepos=&quot;32:1-32:140&quot; dir=&quot;auto&quot;&gt;5、&lt;a href=&quot;https://github.com/opensumi/core/blob/main/README-zh_CN.md&quot;&gt;阿里巴巴开源的，帮助你快速搭建本地和云端 IDE 的框架&lt;/a&gt;&lt;/p&gt;
&lt;p data-sourcepos=&quot;34:1-34:124&quot; dir=&quot;auto&quot;&gt;旨在解决阿里经济体内部 IDE 产品研发的重复建设问题，满足 IDE 在更多垂直场景的定制能力。&lt;/p&gt;
&lt;p data-sourcepos=&quot;36:1-36:135&quot; dir=&quot;auto&quot;&gt;6、&lt;a href=&quot;https://github.com/macacajs/macaca-datahub/blob/master/README.zh.md&quot;&gt;一个开箱即用的，全周期的数据环境解决方案&lt;/a&gt;&lt;/p&gt;
&lt;p data-sourcepos=&quot;38:1-38:114&quot; dir=&quot;auto&quot;&gt;支持从本地开发阶段，到集成测试阶段，以及上线前验证阶段的一系列数据环境需求。&lt;/p&gt;
&lt;p data-sourcepos=&quot;40:1-40:83&quot; dir=&quot;auto&quot;&gt;7、&lt;a href=&quot;https://toutiao.io/k/6kwaapq&quot; rel=&quot;nofollow&quot;&gt;成为一名优秀Java开发人员的7个步骤&lt;/a&gt;&lt;/p&gt;
&lt;p data-sourcepos=&quot;42:1-42:9&quot; dir=&quot;auto&quot;&gt;供参考&lt;/p&gt;
&lt;p data-sourcepos=&quot;44:1-44:80&quot; dir=&quot;auto&quot;&gt;8、&lt;a href=&quot;https://toutiao.io/k/3f3i7ey&quot; rel=&quot;nofollow&quot;&gt;万字长文教你用Go开发区块链应用&lt;/a&gt;&lt;/p&gt;
&lt;p data-sourcepos=&quot;46:1-46:15&quot; dir=&quot;auto&quot;&gt;一步步教你&lt;/p&gt;
&lt;p data-sourcepos=&quot;48:1-48:89&quot; dir=&quot;auto&quot;&gt;9、&lt;a href=&quot;/toutiaoio/weekly.manong.io/blob/master/docs/%E3%80%8A%E9%9D%9E%E5%B8%B8%E6%97%B6%E6%9C%9F%E5%9B%A4%E8%B4%A7%E6%89%8B%E5%86%8C%E3%80%8B&quot;&gt;https://github.com/toutiaoio/A-Guide-To-Stockpiling&lt;/a&gt;&lt;/p&gt;
&lt;p data-sourcepos=&quot;50:1-50:57&quot; dir=&quot;auto&quot;&gt;一个可供选择的居家封闭情况下的商品列表&lt;/p&gt;
&lt;p data-sourcepos=&quot;52:1-52:117&quot; dir=&quot;auto&quot;&gt;10、&lt;a href=&quot;https://github.com/slowmist/Blockchain-dark-forest-selfguard-handbook&quot;&gt;《区块链黑暗森林自救手册》&lt;/a&gt;&lt;/p&gt;
&lt;p data-sourcepos=&quot;54:1-54:9&quot; dir=&quot;auto&quot;&gt;供参考&lt;/p&gt;
&lt;h2 data-sourcepos=&quot;57:1-57:9&quot; dir=&quot;auto&quot;&gt;&lt;a id=&quot;user-content-简介&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#简介&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;简介&lt;/h2&gt;
&lt;ul data-sourcepos=&quot;58:1-62:0&quot; dir=&quot;auto&quot;&gt;
&lt;li data-sourcepos=&quot;58:1-58:108&quot;&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;/li&gt;
&lt;li data-sourcepos=&quot;59:1-59:83&quot;&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万&lt;/li&gt;
&lt;li data-sourcepos=&quot;60:1-60:182&quot;&gt;专业、简单、有用，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;/li&gt;
&lt;li data-sourcepos=&quot;61:1-62:0&quot;&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「码农周刊VIP会员」服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 data-sourcepos=&quot;63:1-63:18&quot; dir=&quot;auto&quot;&gt;&lt;a id=&quot;user-content-vip会员特权&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#vip会员特权&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;VIP会员特权&lt;/h2&gt;
&lt;ul data-sourcepos=&quot;64:1-68:0&quot; dir=&quot;auto&quot;&gt;
&lt;li data-sourcepos=&quot;64:1-64:83&quot;&gt;52 期码农周刊VIP会员专属邮件周报，让你及时掌握技术动向；&lt;/li&gt;
&lt;li data-sourcepos=&quot;65:1-65:77&quot;&gt;只限VIP会员加入的交流圈子，让你与技术大牛切磋学习；&lt;/li&gt;
&lt;li data-sourcepos=&quot;66:1-66:71&quot;&gt;VIP会员独享的工作机会，为你介绍好公司的好机会；&lt;/li&gt;
&lt;li data-sourcepos=&quot;67:1-68:0&quot;&gt;更多会员特权，持续更新……&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 data-sourcepos=&quot;69:1-69:30&quot; dir=&quot;auto&quot;&gt;&lt;a id=&quot;user-content-成为码农周刊vip会员&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#成为码农周刊vip会员&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;成为码农周刊VIP会员&lt;/h2&gt;
&lt;ol data-sourcepos=&quot;70:1-73:0&quot; dir=&quot;auto&quot;&gt;
&lt;li data-sourcepos=&quot;70:1-70:200&quot;&gt;微信扫描下方二维码，加入码农周刊VIP会员知识星球。促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/3bec7a23a8e3a8db753f5664ebe0979b29115a4dc348968d4acd1181bfdcff7a/68747470733a2f2f696d672e746f757469616f2e696f2f6164732f7669705f6769746875622e6a706567&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/3bec7a23a8e3a8db753f5664ebe0979b29115a4dc348968d4acd1181bfdcff7a/68747470733a2f2f696d672e746f757469616f2e696f2f6164732f7669705f6769746875622e6a706567&quot; data-canonical-src=&quot;https://img.toutiao.io/ads/vip_github.jpeg&quot;/&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li data-sourcepos=&quot;71:1-71:105&quot;&gt;加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;/li&gt;
&lt;li data-sourcepos=&quot;72:1-73:0&quot;&gt;客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 data-sourcepos=&quot;74:1-74:30&quot; dir=&quot;auto&quot;&gt;&lt;a id=&quot;user-content-vip会员专属邮件周报&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#vip会员专属邮件周报&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;VIP会员专属邮件周报&lt;/h2&gt;

&lt;h2 data-sourcepos=&quot;77:1-77:15&quot; dir=&quot;auto&quot;&gt;&lt;a id=&quot;user-content-往期存档&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#往期存档&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;往期存档&lt;/h2&gt;

&lt;/article&gt;
  &lt;/div&gt;

    &lt;/div&gt;

  &lt;/readme-toc&gt;

  

  &lt;details class=&quot;details-reset details-overlay details-overlay-dark&quot; id=&quot;jumpto-line-details-dialog&quot;&gt;
    &lt;summary data-hotkey=&quot;l&quot; aria-label=&quot;Jump to line&quot;/&gt;
    &lt;details-dialog class=&quot;Box Box--overlay d-flex flex-column anim-fade-in fast linejump&quot; aria-label=&quot;Jump to line&quot;&gt;
          &lt;/details-dialog&gt;
  &lt;/details&gt;


&lt;/div&gt;

  &lt;/div&gt;


&lt;/div&gt;

    &lt;/main&gt;
  &lt;/div&gt;

  &lt;/div&gt;

          &lt;footer class=&quot;footer width-full container-xl p-responsive&quot; role=&quot;contentinfo&quot;&gt;


  
  &lt;p class=&quot;d-flex flex-justify-center pb-6&quot;&gt;
    &lt;span class=&quot;f6 color-fg-muted&quot;/&gt;
  &lt;/p&gt;
&lt;/footer&gt;




  &lt;div id=&quot;ajax-error-message&quot; class=&quot;ajax-error-message flash flash-error&quot; hidden=&quot;&quot;&gt;
    &lt;svg aria-hidden=&quot;true&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; data-view-component=&quot;true&quot; class=&quot;octicon octicon-alert&quot;&gt;
    &lt;path fill-rule=&quot;evenodd&quot; d=&quot;M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z&quot;/&gt;
&lt;/svg&gt;
    &lt;button type=&quot;button&quot; class=&quot;flash-close js-ajax-error-dismiss&quot; aria-label=&quot;Dismiss error&quot;&gt;
      &lt;svg aria-hidden=&quot;true&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; data-view-component=&quot;true&quot; class=&quot;octicon octicon-x&quot;&gt;
    &lt;path fill-rule=&quot;evenodd&quot; d=&quot;M3.72 3.72a.75.75 0 011.06 0L8 6.94l3.22-3.22a.75.75 0 111.06 1.06L9.06 8l3.22 3.22a.75.75 0 11-1.06 1.06L8 9.06l-3.22 3.22a.75.75 0 01-1.06-1.06L6.94 8 3.72 4.78a.75.75 0 010-1.06z&quot;/&gt;
&lt;/svg&gt;
    &lt;/button&gt;&lt;p&gt;
    You can’t perform that action at this time.
  &lt;/p&gt;&lt;/div&gt;

  &lt;div class=&quot;js-stale-session-flash flash flash-warn flash-banner&quot; hidden=&quot;&quot;&gt;
    &lt;svg aria-hidden=&quot;true&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; data-view-component=&quot;true&quot; class=&quot;octicon octicon-alert&quot;&gt;
    &lt;path fill-rule=&quot;evenodd&quot; d=&quot;M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z&quot;/&gt;
&lt;/svg&gt;
    &lt;span class=&quot;js-stale-session-flash-signed-in&quot; hidden=&quot;&quot;&gt;You signed in with another tab or window. &lt;a href=&quot;&quot;&gt;Reload&lt;/a&gt; to refresh your session.&lt;/span&gt;
    &lt;span class=&quot;js-stale-session-flash-signed-out&quot; hidden=&quot;&quot;&gt;You signed out in another tab or window. &lt;a href=&quot;&quot;&gt;Reload&lt;/a&gt; to refresh your session.&lt;/span&gt;
  &lt;/div&gt;
    &lt;template id=&quot;site-details-dialog&quot;&gt;
  &lt;details class=&quot;details-reset details-overlay details-overlay-dark lh-default color-fg-default hx_rsm&quot; open=&quot;&quot;&gt;
    &lt;summary role=&quot;button&quot; aria-label=&quot;Close dialog&quot;/&gt;
    &lt;details-dialog class=&quot;Box Box--overlay d-flex flex-column anim-fade-in fast hx_rsm-dialog hx_rsm-modal&quot;&gt;
      &lt;button class=&quot;Box-btn-octicon m-0 btn-octicon position-absolute right-0 top-0&quot; type=&quot;button&quot; aria-label=&quot;Close dialog&quot; data-close-dialog=&quot;&quot;&gt;
        &lt;svg aria-hidden=&quot;true&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; data-view-component=&quot;true&quot; class=&quot;octicon octicon-x&quot;&gt;
    &lt;path fill-rule=&quot;evenodd&quot; d=&quot;M3.72 3.72a.75.75 0 011.06 0L8 6.94l3.22-3.22a.75.75 0 111.06 1.06L9.06 8l3.22 3.22a.75.75 0 11-1.06 1.06L8 9.06l-3.22 3.22a.75.75 0 01-1.06-1.06L6.94 8 3.72 4.78a.75.75 0 010-1.06z&quot;/&gt;
&lt;/svg&gt;
      &lt;/button&gt;
      &lt;p class=&quot;octocat-spinner my-6 js-details-dialog-spinner&quot;/&gt;
    &lt;/details-dialog&gt;
  &lt;/details&gt;
&lt;/template&gt;

    

    &lt;template id=&quot;snippet-clipboard-copy-button&quot;&gt;
  
&lt;/template&gt;




  &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2577b43a53aaef5003111fe1cc17d3b5</guid>
<title>Go netpoll大解析</title>
<link>https://toutiao.io/k/k3hg8lk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wxicPoYsPLia7RuF7m5HYXeByuJbX9ugsIwQ5FbF51DERicDuwutIrUYXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图片拍摄于2022年4月3日 杭州&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n68&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;开篇&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n68&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;之前简单看过一点go原生netpoll，没注意太多细节。&lt;/span&gt;&lt;span&gt;最近从头到尾看了一遍，特写篇文章记录下。&lt;/span&gt;&lt;span&gt;文章很长，请耐心看完，一定有所收获。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n972&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 md-src-pos=&quot;261..277&quot; data-darkmode-bgcolor-16499522379759=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16499522379759=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16499522379759=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16499522379759=&quot;#fff|rgb(0, 0, 0)&quot; data-style=&quot;margin-top: 1em; margin-bottom: 16px; font-weight: bold; line-height: 1.4; font-size: 17px; color: rgb(0, 0, 0); font-family: Helvetica, Arial, freesans, sans-serif; text-align: start; white-space: normal; background-color: rgb(255, 255, 255);&quot; class=&quot;js_darkmode__29&quot;&gt;&lt;span&gt;内核空间和用户空间&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n111&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在linux中，经常能看到两个词语:User space(用户空间)和Kernel space (内核空间)。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n111&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n116&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;简单&lt;/span&gt;&lt;span&gt;地&lt;span&gt;说， Kernel space是linux内核运行的空间，User space是用户程序运行的空间。&lt;/span&gt;&lt;span&gt;它们之间是相互隔离的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n116&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n124&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;现代操作系统都是采用虚拟存储器。那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n124&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n124&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n124&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n124&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;为了保证用户进程不能直接操作内核，保证内核的安全，系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n124&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n124&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。空间分配如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n129&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5468227424749164&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9waNV3NicYA0Duia7CkaEeAn6VyPzebksdc7FmneW6Luzyyia8lrwIJRgiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;598&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n135&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Kernel space可以调用系统的一切资源。User space 不能直接调用系统资源，在 Linux系统中，所有的系统资源管理都是在内核空间中完成的。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n135&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n135&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;比如读写磁盘文件、分配回收内存、从网络接口读写数据等等。应用程序无法直接进行这样的操作，但是用户程序可以通过内核提供的接口来完成这样的任务。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n135&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37386363636363634&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wWBYZwOAkwzMMjTT7M7SdSDYX6bmrDuRWUibdut64XzybicVkSpNVzkkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;880&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n122&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n122&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;像下面这样，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n973&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1733203505355404&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wgIfhu97Rn9L0qJ5eIGia6eD5yo4ELic2nTt0yeicWgZU2VAKZkWI2QGqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2054&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n975&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n975&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;应用程序要读取磁盘上的一个文件，它可以向内核发起一个 “系统调用” 告诉内核：”我要读取磁盘上的某某文件”。其实就是通过一个特殊的指令让进程从用户态进入到内核态。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n975&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n975&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在内核空间中，CPU 可以执行任何的指令，当然也包括从磁盘上读取数据。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n975&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n975&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;具体过程是先把数据读取到内核空间中，然后再把数据拷贝到用户空间并从内核态切换到用户态。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n975&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n975&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;此时应用程序已经从系统调用中返回并且拿到了想要的数据，继续往下执行用户空间执行逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n975&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n149&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这样的话，一旦涉及到对I/O的处理，就必然会涉及到在用户态和内核态之间来回切换。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n149&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n149&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h4 cid=&quot;n148&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;io模型&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n97&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;网上有太多关于I/O模型的文章，看着看着有可能就跑偏了，所以我还是从 &amp;lt;&amp;lt;UNIX 网络编程&amp;gt;&amp;gt; 中总结的5中I/O模型说起吧。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n97&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n159&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Unix可用的5种I/O模型。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; cid=&quot;n161&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n164&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;阻塞I/O&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n165&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;非阻塞I/O&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n168&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;I/O复用&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n171&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;信号驱动式I/O(SIGIO)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n174&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;异步I/O(POSIX的aio_系列函数)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n194&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h5 cid=&quot;n195&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;&lt;strong&gt;阻塞I/O&lt;/strong&gt;&lt;/span&gt;&lt;/h5&gt;&lt;p cid=&quot;n188&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://cdn.syst.top/截屏2022-04-09 上午10.29.31.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4365904365904366&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wHmh12ibZK222LGMKW2vX02EcVbhgayaDMj0p8yv4SZH08KVHqQK1UHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;962&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n190&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;阻塞式I/O下，进程调用recvfrom，直到数据到达且被复制到应用程序的缓冲区中或者发生错误才返回，在整个过程进程都是被阻塞的&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h5 cid=&quot;n200&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;&lt;span&gt;非阻塞I/O&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p cid=&quot;n213&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5110619469026548&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wAmJnn1mZwUV0tlH7XkWSjptQF3hbFkCYnlhXib1ibroiaoQ9d6ZPYT41Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;904&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n205&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n205&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;从图中可以看出，前三次调用recvfrom中没有数据可返回，因此内核转而立即返回一个EWOULDBLOCK错误。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n205&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n205&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;第四次调用recvfrom时已有一个数据报准备好，它被复制到应用程序缓冲区，于是recvfrom成功返回。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n205&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n207&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当一个应用程序像这样对一个非阻塞描述符循环调用recvfrom时，我们通常称为轮询(polling)，持续轮询内核，以这种方式查看某个操作是否就绪。&lt;/span&gt;&lt;/p&gt;&lt;h5 cid=&quot;n216&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5 cid=&quot;n216&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;&lt;span&gt;I/O多路复用&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p cid=&quot;n217&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4437984496124031&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wbPHkFh3bCp7OxLmDFSDluvYR863tHnBacvmzBLGvHXhfXKSkhaEiaXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1032&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n103&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n103&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;有了I/O多路复用(I/O multiplexing)，我们就可以调用 select 或者 poll，阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的I/O系统调用上。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n103&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n223&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;上面这句话难理解是吧。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n223&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n223&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;说白了这里指的是，在第一步中，我们只是阻塞在select调用上，直到数据报套接字变为可读，返回可读条件，这里并没有发生I/O事件，所以说这一步，并没有阻塞在真正的I/O系统调用上。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n223&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n227&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其他两种就不过多介绍了。&lt;/span&gt;还有一点，我们会经常提到同步I/O和异步I/O。&lt;/p&gt;&lt;p cid=&quot;n227&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n237&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;POSIX 把这两种术语定义如下:&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n250&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n250&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;基于上面的定义，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n252&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4603174603174603&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wRkCbzDTWL2UIRNKEcaUfYd8yqAUQBoAowlzQoabFwN8U96hh6aDqUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;630&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n229&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n229&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;异步I/O的关键在于第二步的recrfrom是否会阻塞住用户进程，如果不阻塞，那它就是异步I/O。从上面汇总图中可以看出，只有异步I/O满足POSIX中对异步I/O的定义。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n229&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n260&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4 cid=&quot;n260&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Go netpoller&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n277&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n277&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Go netpoller 底层就是对I/O多路复用的封装。不同平台对I/O多路复用有不同的实现方式。比如Linux的select、poll和epoll。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n277&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n277&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在MacOS则是kqueue,而Windows是基于异步I/O实现的icop......，基于这些背景，Go针对不同的平台调用实现了多版本的netpoller。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n278&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5406162464985994&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wAibh5K9hhEhiaGZcDlkAZIQo8Ba6hMA43eo597QuF2TBPq4zRYo0IHqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;714&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n819&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n819&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;下面我们通过一个demo开始讲解。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n292&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.9174757281553398&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wicAN3Qj0vBuwXSrpV4PQdjYib8c34seqMhtvEuPJGwKNL16uGBeJibxHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;824&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n288&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n288&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;很简单一个demo，开启一个tcp服务。然后每来一个连接，就启动一个g去处理连接。处理完毕，关闭连接。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n288&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n832&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;而且我们使用的是同步的模式去编写异步的逻辑，一个连接对应一个g处理，极其简单和易于理解。go标准库中的http.server也是这么干的。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n834&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1057007125890737&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9w3nMynhgTw39adF3SGsrMy433Iiae5oNXCUhrw2ibjoalTcrT5C0bFafw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1684&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n836&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n836&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;针对上面的tcp服务demo，我们需要关注这段代码底层都发生了什么。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n836&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n282&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;上面代码中主要涉及底层的一些结构。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n264&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6517073170731708&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wKzW3h9uM7Xnuqd2lRHaqAP3Q5gg3YDM1T1SCicicasoRXh3KibLVwibuDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2050&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n275&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n275&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;先简单解释一波。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; cid=&quot;n294&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n297&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;TCPListener:我们开启的是一个TCP服务，那当然就是TCP服务的网络监听器。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n298&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;netFD:网络描述符。Go中所有的网络操作都是以netFD实现的，它和底层FD做绑定。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n301&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;FD:文件描述符。net和os包把这个类型作为一个网络连接或者操作系统文件。其中里面一个字段Sysfd就是具体文件描述符值。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n304&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;pollDesc:I/O轮询器。说白了它就是底层事件驱动的封装。其中的runtimeCtx是一个指针类型，具体指向runtime/netpoll 中的pollDesc.&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n99&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n99&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当然图上面结构字段都是阉割版的，但是不影响我们这篇文章。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n99&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n320&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;还有一个问题，为什么结构上需要一层一层嵌入呢？&lt;/span&gt;我的理解是每下一层都是更加抽象的一层。它是可以作为上一层具体的一种应用体现。&lt;/p&gt;&lt;p cid=&quot;n320&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n326&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;是不是跟没说一样？哈哈。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n326&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n328&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;举例，比如这里的netFD表示网络描述符。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n328&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n844&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;它的上一层可以是用于TCP的网络监听器TCPListener，那么对应的接口我们能想到的有两个Accept以及close。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n844&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n840&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;对于Accept 动作，一定是返回一个连接类型 Conn ，针对这个连接，它本身也存在一个自己的netFD，那么可想而知一定会有 Write和Read两个操作。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n840&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n848&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;而所有的网络操作都是以netFD实现的。这样，netFD在这里就有两种不&lt;/span&gt;&lt;span&gt;同&lt;/span&gt;&lt;span&gt;&lt;span&gt;的上层应用体现了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n850&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n330&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;好了,我们需要搞清楚几件事：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; cid=&quot;n332&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n337&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;一般我们用其他语言写一个tcp服务，必然会写这几步：socket-&amp;gt;bind-&amp;gt;listen，但是Go就一个Listen，那就意味着底层包装了这些操作。它是在哪一步完成的？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n341&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Go是在什么时候初始化netpoll的，比如linux下初始化epoll实例。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n344&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当对应fd没有可读或者可写的IO事件而对应被挂起的g，是如何知道fd上的I/O事件已ready，又是如何唤醒对应的g的？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n852&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h5 cid=&quot;n977&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5 cid=&quot;n977&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Listen解析&lt;/span&gt;&lt;/h5&gt;&lt;p cid=&quot;n856&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n856&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;带着这些问题，我们接着看流程。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n363&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.116279069767442&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wGmjypxAy5LSibWZgw48GtPbdB5NNP8ke9qChsxpwPQnfvt4KlKicY72w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1978&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n353&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;上图已经把当你调用Listen操作的完整流程全部罗列出来了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n353&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n353&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;就像我上面列出的结构关系一样，从结构层次来说，每调用下一层，都是为了创建并获取下一层的依赖，因为内部的高度抽象与封装，才使得使用者往往只需调用极少数简单的API接口。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n353&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n359&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;现在我们已经知道事例代码涉及到的结构以及对应流程了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n359&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n377&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在传统印象中，创建一个网络服务。需要经过:创建一个socket、bind 、listen这基本的三大步。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n377&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n369&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;前面我们说过，Go中所有的网络操作都是以netFD实现的。&lt;/span&gt;go也是在这一层封装这三大步的。所以我们直接从netFD逻辑开始说。&lt;/p&gt;&lt;p cid=&quot;n369&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n381&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;上图是在调用socket函数这一步返回的netFD，可想而&lt;/span&gt;&lt;span&gt;知&lt;/span&gt;&lt;span&gt;&lt;span&gt;核心逻辑都在这里面。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n387&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7553879310344828&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9whysJzw3D4Xpf5hNIT6iaicJaIzX91JHyZKK3AWjhwpd9ibDz8vQ1fic3Dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;928&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n383&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n383&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;我们可以把这个函数核心点看成三步。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; cid=&quot;n392&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n395&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;调用sysSocket函数创建一个socket，返回一个文件描述符(file descriptor)，简称fd下文。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n399&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;通过sysSocket返回的fd，调用newFD函数创建一个新的netFD。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n396&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;调用netFD自身的方法listenStream函数，做初始化动作，具体详情下面再说。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n385&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n858&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在sysSocket函数中，首先会通过socketFunc来创建一个socket，通过层层查看，最终是通过system call来完成这一步。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n858&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n858&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当获取到对应fd时，会通过syscall.SetNonblock函数把当前这个fd设置成非阻塞模式，这样当这个Listener调用accept函数就不会被阻塞了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n371&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.8641655886157826&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wxWEklHiafp3gvmnMdtaDMRscY2dL4kUqkQDiba0QNRkziaXvUsokW7Mfw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1546&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n365&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;第二步，通过第一步创建socket拿到的fd，创建一个新的netFD。这段代码没啥好解释的。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n365&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n406&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;第三步，也就是最核心的一步，调用netFD自身的listenStream方法。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n408&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4811218985976268&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9w4OOl2BOSSgzYt2GoR4HFZEib0hKzscVevdLiaRFpmRYSBjBTxdtTpwEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;927&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n434&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n434&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;listenStream里面也有核心的三步:&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n355&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n355&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;我们主要看fd.init逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n445&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.308970099667774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wBWPDic6Ju4e4zgj4jicYFtffR4dBgmaJ3qfmSayRao7q9JzjO45MpVfg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1204&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n347&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n347&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;最终是调用的pollDesc的init函数。这个函数有重要的两步。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n860&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n860&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;更具体的流程，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n860&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n453&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;首先serviceInit.Do 保证当中的runtime_pollServerInit只会初始化一次。这很好理解，类似epoll实例全局初始化一次即可。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n453&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n531&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;接着我们看下runtime_pollServerInit函数，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n457&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20170940170940171&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wITHlr01PfAiacyYuFicBOJLSaIt3fmiazSiasico8Zael0r5a9k3sspkFoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1170&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n322&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n322&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这是咋回事，和我们平常看过的函数长的不太一样，执行体呢？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n322&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n864&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其实这个函数是通过 go:linkname连接到具体实现的函数poll_runtime_pollServerInit。找起来也很简单，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n462&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5122699386503068&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wNCQiasqFFicwEn8rZicIFXXyEY1DwcafxnvRVAUj3HmfEAleSolSvb0QA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1956&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n533&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n533&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;看到poll_runtime_pollServerInit()上面的 //go:linkname xxx 了吗？不了解的可以看看Go官方文档`go:linkname。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n533&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n866&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;所以最终runtime_pollServerInit调用的是，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n468&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5431034482758621&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9w9qPJtWicugYLTmePUjFAiaKrGDdt56iaeb8UzDSWyegHKpibxsfWegAiapQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;696&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n470&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n470&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;通过调用poll_runtime_pollServerInit-&amp;gt;netpollGenericInit，netpollGenericInit里调用netpollinit函数完成初始化。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n470&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n868&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;注意。这里的netpollinit，是基于当前系统来调用对应系统的netpollinit函数的。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n868&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n539&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;什么意思？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n539&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n537&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;文章开始有提到Go底层网络模型是基于I/O多路复用。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n537&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n870&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;不同平台对I/O多路复用有不同的实现方式。比如Linux的epoll，MacOS的kqueue,而Windows的icop。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n870&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n473&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;所以对应，如果你当前是Linux，那么最终调用的是src/runtime/netpoll_epoll.go下的 netpollinit函数，然后会创建一个epoll实例，并把值赋给epfd，作为整个runtime中唯一的event-loop使用。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n477&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0012674271229405&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wsNMMaTMUW8NbUs4YibxuawicMyiafvOjmIETKlQT2hll0OJrNY3xyxJCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;789&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n475&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n475&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其他的，比如MacOS下的kqueue,也存在netpollinit函数。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n485&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8964285714285715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wefNcY5ib64cGmmebicZlWdyH6NETQwuFSicCHwjnORXXStELEOVaP9iaiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;560&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n491&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n491&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;以及Windows下的icop。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n493&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21170610211706103&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wetnrTHpdlQ0AsMbPonHQH2Q9C84BqkLDcbTsoQo95XCF5AlzHLreCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;803&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n495&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n495&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;我们回到pollDesc.init 操作，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n497&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4432576769025367&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wVM52ySpR2E6LxCt5pAdLyRUnu4ib6aDcRD4rFNL4maBMQUDHEe7CHEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1498&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n545&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n545&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;完成第一步初始化操作后，第二步就是调用runtime_pollOpen。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n545&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n873&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;老套路通过//go:linkname找到对应的实现，实际上是调用的poll_runtime_pollOpen函数。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n873&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n873&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这个函数里面再调用netpollopen函数，netpollopen函数和上面的netpollinit函数一样，不同平台都有它的实现。linux平台下，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n547&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7986754966887417&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wuKIiasnt9WJicDQWSmOiaVIX0gJGOWZWYNBDu8k8stHLcWahTfTWAFtzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;755&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n549&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n549&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;netpollopen函数，首先会通过指针把pollDesc保存到epollevent的一个字节数组data里。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n549&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n553&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;然后会把传递进来的fd(刚才初始化完成的那个Listener监听器)注册到epoll当中，且通过指定 _EPOLLET将epoll设置为边缘触发(Edge Triggered)模式。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n553&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n553&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;如果让我用一句话来说明epoll水平触发和边缘触发的区别，那就是,&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n553&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n875&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;水平触发下epoll_wait在文件描述符没有读写完会一直触发，而边缘触发只在是在变成可读写时触发一次。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n875&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n881&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;到这里整个Listen 动作也就结束了，然后层层返回。最终到业务返回的是一个 Listener，按照本篇的例子，本质上还是一个TCPListener。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n982&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h5 cid=&quot;n988&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Accept解析&lt;/span&gt;&lt;/h5&gt;&lt;p cid=&quot;n562&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;接着当我们调用listen.Accept的时候，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n566&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2873711340206186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wuzZ7ibHmTXQ85RBWPWHb05PRgLOffHibzzQZF7gASQ4zCgRwERHwziaMQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1552&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n564&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n564&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;最终netFD的accept函数。netFD中通过调用fd.pfd(实际上是FD)的Accept函数获取到socket fd，通过这个fd创建新的netFD表示这是一个新连接的fd。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n564&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n564&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;并且会和Listen时一样调用netFD.init做初始化，因为当前epoll已经初始化一次了，所以这次只是把这个新连接的fd也加入到epoll事件队列当中，用于监听conn fd的读写I/O事件。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n564&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n580&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;具体我们看FD.Accept是咋么执行的。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n578&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.8002560819462228&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wC7zZxKcKibxVaPHqLH0kaZPAicVGibiaa5ib84wOjqoIibcZLic3pj4zCIYWw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1562&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n608&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n608&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;首先是一个死循环for，死循环里调用了accept函数，本质上通过systcall调用系统accept接收新连接。当有新连接时，最终返回一个文件描述符fd。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n608&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n608&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当accept获取到一个fd，会调用systcall.SetNonblock把这个fd设置成非阻塞的I/O。然后返回这个连接fd。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n608&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n612&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;因为我们在Listen的时候已经把对应的Listener fd设置成非阻塞I/O了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n612&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n612&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;所以调用accept这一步是不会阻塞的。只是下面会进行判断，根据判断 err ==syscall.EAGAIN 来调用fd.pd.waitRead阻塞住用户程序。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n612&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n885&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;直到I/O事件ready，被阻塞在fd.pd.waitRead的代码会继续执行continue，重新一轮的accept, 此时对应fd上的 I/O已然ready，最终就返回一个conn类型的fd。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n885&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n620&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;我刚才说的调用fd.pd.waitRead会被阻塞，直到对应I/O事件ready。我们来看它具体逻辑，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n887&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7473997028231798&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wSibHqsRH3GS2AjFIBBxejiaU7usU1eKMRiaWaHibK5RKCMsgJ1YbqlfcJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1346&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n889&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n894&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;最终到runtime_pollWait函数，老套路了，我们找到具体的实现函数。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n624&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.487907465825447&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wv5OhyWFImIYHflbAeIl2wHFDMsPOvIga1xSruBYFQZdHXfO5mF3Emw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1902&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n630&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n630&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;poll_runtime_pollWait 里的for循环就是为了等待对应的I/O ready才会返回，否则的话一直调用netpollblock函数。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n630&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n630&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;pollDesc结构我们之前提到，它就是底层事件驱动的封装。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n630&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n630&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其中有两个重要字段: rg和wg，都是指针类型，实际这两个字段存储的就是Go底层的g，更具体点是等待i/O ready的g。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n630&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n896&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;比如当创建完一个Listener，调用Accept开始接收客户端连接。如果没有对应的请求，那么最终会把g放入到pollDesc的rg。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n896&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n648&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; 如果是一个conn类型的fd等待可写I/O，那么会把g放入到pollDesc的wg中。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n898&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;具体就是根据mode来判断当前是什么类型的等待事件。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n898&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n654&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;netpollblock里也有一个for循环，如果已经ready了，那么直接返回给上一层就行了。否则的话，设置gpp为等待状态pdWait。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n654&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n900&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这里还有一点atomic.Loaduintptr(gpp)，这是为了防止异常情况下出现死循环问题。比如如果gpp的值不是pdReady也不是0，那么意味着值是pdWait，那就成了double wait，必然导致死循环。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n900&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n668&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;如果gpp未ready且成功设置成pdWait，正常情况下，最终会调用gopark，会挂起g且把对应的g放入到pollDesc 的wg|rg 当中。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n668&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n671&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;进入gopark。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n675&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7451171875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wx1ibqPQBzA0pdB9jhzCtmS4qkl6S2uEw0qWWf1EBerB1XjdzI467SlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2048&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n657&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n657&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这一块代码不是很难，基本的字段打了备注，核心还是要看park_m这个函数。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n683&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.149802890932983&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wJsecNIFAK4XwttEfjBiaVtp2aImKicoGrhz3ba8DzDtGPiceSe4kKdAmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1522&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n685&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n685&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在park_m函数中，首先会通过CAS并发安全&lt;/span&gt;&lt;span&gt;地&lt;span&gt;修改g的状态。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n685&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n685&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;然后调用dropg解绑g和m的关系，也就是m把当前运行的g置空，g把当前绑定的m置空。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n685&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n902&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;后面的代码是根据当前场景来解释的。我们知道此时m的waitunlockf 其实就是netpollblockcommit。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n681&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5690045248868778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wto7WI0CJIzwf45iaaqHjXQq4utRNYfcymdWsP3iaCVZOrAAhNSTCGmQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1768&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n677&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n677&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;netpollblockcommit会把当前已经是_Gwaiting状态下的g赋值给gpp。如果赋值成功，netpollWaiters会加1。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n677&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n677&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这个全局变量表示当前等待I/O事件ready的g数量，调度器再进行调度的时候可以根据此变量判断是否存在等待I/O事件的g。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n677&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n677&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span/&gt;如果此时当前gpp下的fd的I/O已经ready。那么gpp的状态必然已不是pdWait，赋值失败。返回false。&lt;/p&gt;&lt;p cid=&quot;n703&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n703&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;回到park_m，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n703&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n703&quot; mdtype=&quot;paragraph&quot;&gt;如果netpollblockcommit返回true，那么直接触发新一轮的调度。&lt;/p&gt;&lt;p cid=&quot;n703&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n703&quot; mdtype=&quot;paragraph&quot;&gt;如果netpollblockcommit返回false，意味着当前g已经不需要被挂起了，所以需要把状态调整为_Grunnable，然后安排g还是在当前m上执行。&lt;/p&gt;&lt;p cid=&quot;n706&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n716&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当I/O事件ready，会一层层返回，获取到新的socket fd，创建conn类型的netFD，初始化netFD(其实就是把这个conn类型的fd也加入epoll事件队列，用于监听)，最终最上游会获取到一个Conn类型的网络连接，就可以基于这个连接做Read、Write等操作了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n710&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5866666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wElzssv5OTarKu28NceB3HsIQ0xOOnYV8F04O67P2XQrwg2Khpg8qPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1650&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n652&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h5 cid=&quot;n997&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5 cid=&quot;n997&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5 cid=&quot;n997&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Read/Write 解析&lt;/span&gt;&lt;/h5&gt;&lt;p cid=&quot;n995&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n995&quot; mdtype=&quot;paragraph&quot;&gt;后续的Conn.Read 和 Conn.Write 原理和Accept 类似。&lt;/p&gt;&lt;p cid=&quot;n723&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.5450819672131149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wibtZhbS8d7NGBWPJr5Xsv0hoO3l9WsO9yJOn9tu6MBvSnia7htvibScMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1952&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n644&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n644&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;上图给出了Write操作，可以看出核心部分和accept操作时一样的。对于Read操作，就不再重复了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n644&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n741&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;从上面的分析中我们已经知道，Go的netpoller底层通过对epoll|kqueue|iocp的封装，使用同步的编程手法达到异步执行的效果，无论是一个Listener还是一个Conn，它的核心都是netFD。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n741&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n741&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;netFD又和底层的PollDesc结构绑定，当读写出现EAGAIN错误时，会通过调用gopark把当前g给park住，同时会将当前的g存储到对应netFD的PollDesc的wg|rg当中。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n741&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n741&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;直到这个netFD再次发生对应的读写事件，才会重新把当前g放入到调度系统进行调度。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n741&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n745&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;还有最后一个问题，我们咋么知道哪些FD发生读写事件了？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1000&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h4 cid=&quot;n1002&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4 cid=&quot;n1002&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;I/O已就绪&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n751&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;答案就是netpoll()函数。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n754&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7812828601472135&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9waqkqX9JFCY0NjFqeicBQeJCyx4SU1I3dCGwJGgRqsvdgdBsfLvln2VQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1902&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n758&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n758&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;此函数会调用epollwait函数，本质上就是Linux中epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n758&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n766&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在之前调用epoll_ctl，注册fd对应的I/O事件到epoll实例当中。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n766&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n766&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这里的epoll_wait实际上会阻塞监听epoll实例上所有fd的I/O事件，通过传入的第二个参数(用户内存地址events)。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n766&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n904&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当有对应的I/O事件到来时，内核就会把发生事件对应的fd复制到这块用户内存地址(events)，&lt;/span&gt;解除阻塞。&lt;/p&gt;&lt;p cid=&quot;n904&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n904&quot; mdtype=&quot;paragraph&quot;&gt;然后我们遍历这个events，去获取到对应的事件类型、pollDesc，再通过调用netpollready函数获取到pollDesc对应被gopark的g，最终把这些g加入到一个链表当中，返回。&lt;/p&gt;&lt;p cid=&quot;n904&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n771&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;也就是说只要调用这个函数，我们就能获取到之前因为I/O未ready而被gopark挂起，现在I/O已ready的g链表了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n771&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n775&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;我们可以找到四个调用处，如下，&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; cid=&quot;n777&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n780&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;startTheWorldWithSema&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n781&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;findrunnable&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n786&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;pollWork&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n791&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;sysmon&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n727&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n727&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这和go的调度有关，当然这不是本章的内容。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n727&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n727&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当这四种方法调用netpoll函数得到一个可运行的g链表时，都会调用同一个函数injectglist。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n727&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n727&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这个函数本质上就是把链表中所有g的状态从Gwaiting-&amp;gt;Grunnable。然后按照策略，把这些g推送到本地处理器p或者全家运行队列中等待被调度器执行。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n809&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7212681638044913&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wqRjiagiaiaYPCL6DZ69thsibhjicqpGk3r8BlSX3LNJvpd6iclIbImYTibsow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1514&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n803&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n803&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;到这里，整个流程就已经剖析完毕。不能再写了。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n607&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4 cid=&quot;n607&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4 cid=&quot;n607&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n908&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Go netpoller通过在底层对epoll/kqueue/iocp这些不同平台下对I/O多路复用实现的封装，加上自带的goroutine(上文我一直用g表达)，从而实现了使用同步编程模式达到异步执行的效果。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n908&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n908&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;代码很长，涉及到的模块也很多，整体看完代码还是非常爽的。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n908&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n917&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;另外早有人提出，由于一个连接对应一个goroutine，瞬时并发场景下，大量的goroutine会被不断创建。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n917&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n917&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span/&gt;原生netpoller无法提供足够的性能和控制力，如无法感知连接状态、连接数量多导致利用率低、无法控制协程数量等。针对这些问题，可以参考下gnet以及 KiteX 这两个项目的网络模型。&lt;/p&gt;&lt;p cid=&quot;n919&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h4 cid=&quot;n101&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-1&quot; data-darkmode-color-16485725445993=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16485725445993=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n939&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;http://man7.org/linux/man-pages/man7/epoll.7.html&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n965&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&amp;lt;UNIX网络编程:卷1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n944&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;https://github.com/panjf2000/gnet&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n953&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;https://strikefreedom.top/go-netpoll-io-multiplexing-reactor&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n956&quot; mdtype=&quot;paragraph&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&amp;amp;mid=2247485756&amp;amp;idx=1&amp;amp;sn=4d2712e4bfb9be27a790fa15159a7be1&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;https://mp.weixin.qq.com/s/wSaJYg-HqnYY4SdLA2Zzaw&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n959&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;https://ninokop.github.io/2018/02/18/go-net/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n962&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;https://github.com/cloudwego/kitex&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n962&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span&gt;&lt;strong&gt;福利&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span/&gt;&lt;span&gt;我为大家整理了一份&lt;/span&gt;&lt;span&gt;从入门到进阶的Go学习资料礼包&lt;/span&gt;&lt;span&gt;，包含学习建议：入门看什么，进阶看什么。&lt;/span&gt;&lt;span&gt;关注公众号 「polarisxu」，回复 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;ebook&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 获取；还可以回复「&lt;strong&gt;进群&lt;/strong&gt;」，和数万 Gopher 交流学习。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMqm8cgtrMXjG1BLGg46vQNmUompBL02uYYwic9RicPbCnlKdZiacBF5Wv6RLgmGIqnBnwuWyP82ibYusiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e32fcba52c13f01b34d9c10a2e57e608</guid>
<title>京东云、百度云、金山云曾商谈合并，以失败告终；字节跳动以每股142美元回购期权；个人养老金制度即将出炉｜开发者头条</title>
<link>https://toutiao.io/k/kw8g7eo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;我爱程序员&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;developerWorks&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;我们的产品：《码农周刊》 http://manong.io/ 、《开发者头条》 http://toutiao.io/&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>44072b62af6e23d9013cf9be1188c8e0</guid>
<title>想要实现在时序场景下“远超”通用数据库，需要做到哪几点？</title>
<link>https://toutiao.io/k/g6bnbpp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.15625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YriaiaJPb26VPQqHC66RJFpttVIMWG83T3lWHahUD4bvhxlKSayjeV2ibvC5ydqklP9QHDPD3qHJM07TV3IfHstjA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;section&gt;作者 | 刘继聪&lt;/section&gt;&lt;section&gt;
小 T 导读：近年来，随着物联网技术和市场的快速发展、企业业务的加速扩张，时序数据的处理难题也越来越受到行业和企业的重视，时序场景下通用型数据库步履维艰，各种时序数据库产品应运而起。但是，做一个优质的时序数据库真的很容易吗？本篇文章将从数据库开发者的角度，解剖时序场景下的数据处理需求、分析时序数据库设计思路，给到读者一些硬核技术思考。&lt;/section&gt;&lt;section&gt;
&lt;span&gt;1&lt;/span&gt; 如何实现时序场景下对通用数据库的“远超”？&lt;/section&gt;&lt;p&gt;做一个 Prototype 或者 Demo 很简单，但做出一个真正好的时序数据库产品却很难。&lt;/p&gt;&lt;p&gt;之所以说做 Prototype 简单，是因为时序数据库天生就不擅长处理一些数据，比如带事务的交易数据。基于此，我们可以大刀阔斧地砍掉一些在通用型数据库中很重要的特性，例如事务、MVCC、ACID（在 Facebook 的 Gorilla 中甚至提出不需要保证 Duration）。某些时序数据库的存储引擎，甚至不能处理乱序数据，在无乱序的前提下，存储引擎几乎可以退化为带 Index 的 Log。所以，从这个角度来看，时序数据库可以做得很简单。&lt;/p&gt;&lt;p&gt;但是，从另一方面来说，做一个好的时序数据库产品又很难。试想一下，在时序数据库的设计上，我们大刀阔斧地砍掉了比如事务、ACID 等特性之后，如果依然不能使其在时序场景下的表现远超通用型数据库，那做一个专门的时序数据库就毫无意义了。这样的话，还不如不做，就直接用通用型数据库好了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;所谓“在时序场景下的远超”，应该是全方位的，比如写入的延迟与吞吐量、查询性能、处理的实时性、甚至包括集群方案的运维成本等，都应该有一个跨越式的提升。&lt;/strong&gt;另一方面，从时序数据量大、价值偏低等特点出发，压缩率就显得比较重要了，而通用型数据库却很少强调压缩率，由此可见，压缩率是在时序场景下真实生长出来的需求。&lt;/p&gt;&lt;p&gt;高压缩率的实现没有什么黑科技，也不需要自己重新发明压缩算法——无非就是列存并对各个类型使用其最好的压缩算法；更多是工程实现的问题——好好写代码，认真做优化，平衡好写入性能与压缩比之间的关系。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;此外，在时序数据场景下的“远超”是建立在时序数据的写入与查询分布特点极其明显的基础上，当数据本身 key 的特征分布十分明显时，自然可以充分利用其特征来打造截然不同的存储引擎与索引结构。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;先说写入。时序数据库的吞吐量远超一般的通用型数据库，尤其是 IoT 设备，其设备规模可能达到千万甚至上亿，数据均为自动生成，假设 1s 采样一次，那每秒就能产生千万、亿级别的数据写入，这并不是普通数据库能承受的，在这样大的吞吐量的情况下，数据如何分区分片、如何实时地构建索引，都是具有挑战性的问题。在写入链路上，时序数据库在时序场景下替代的是 OLTP 数据库的位置，而后者在事务与强一致的模型下产生的读写延迟很难支撑时序数据库的高吞吐量写入。&lt;/p&gt;&lt;p&gt;再说查询。在大写入吞吐量的情况下，数据对实时性的要求也很高。例如，我们将时序数据的统计量关联做监控、报警，能容忍的延迟可能在秒级。查询的模式通常是聚合查询，例如某时间段内的统计值，而不是精确的单条记录。总的来说，时序数据库的查询模式通常是交互式分析，这不同于 T+1 的离线数仓，也区别于经常运行数小时的 OLAP 查询，交互式分析查询的响应时间通常是秒级、亚秒级。&lt;/p&gt;&lt;p&gt;以上，在明确了写入与查询需求的同时，下面我们以存储引擎为例，来看一看一个时序数据库的某一个部分应该如何设计。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;2&lt;/span&gt; 存储引擎想做到极致，还得自研&lt;/section&gt;&lt;p&gt;目前，数据库的存储引擎可以粗略分为两大类：一类是基于 B-Tree 的，另一类是基于 LSM-Tree 的。前者常见于传统 OLTP 数据库，比如 MySQL、PQ 这类的默认引擎，更适用于读多写少的场景；如 HBase、LevelDB、RocksDB 一类数据库使用的是 LSM-Tree，在写多读少的场景下比较适合。实际上，现代数据库的存储引擎，基本都会在某种程度下对这两者融合。LSM Tree 上怎么就不可以建 B-Tree Index 了？（HBase 在 region 上也有 B-Tree Index）B-Tree 怎么就一定要直写硬盘，不能先写 WAL 和走内存 Cache 呢？&lt;/p&gt;&lt;p&gt;对于存储引擎，时序数据库的先行者 InfluxDB 曾经做过很多尝试，在各个存储引擎（LevelDB、RocksDB、BoltDB 等）之间反复横跳，遇到过的问题也有很多，比如 BoltDB 中 mmap+BTree 模型中随机 IO 导致的吞吐量低、RocksDB 这类纯 LSM Tree 存储引擎没办法很优雅快速地按时间分区删除、多个 LevelDB + 划分时间分区的方法又会产生大量句柄……踩了这一系列的坑后，最终 InfluxDB  换成了自研的存储引擎 TSM。可见对时序数据库来说，一个好的存储引擎有多么重要，又是多么难得，要想做到极致，还得自己研发。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;不同于 InfluxDB，TDengine 的存储引擎从一开始就是自研的——从 LSM Tree 中汲取了 WAL、先写内存的 skip list 等等技术，但把 LSM Tree 的树层级结构去掉了，而只是按时间段分区、按表分块的 log 块。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;读到这里，细心的读者可能会发现，按表分块的设计和 OpenTSDB 的行聚合有些相似。OpenTSDB 的行聚合是把相同 tag 以一小时为时间范围，将这些数据都放到一行中存储，这样大大减少了聚合查询要扫描的数据量。不过不同的是，TDengine 是多列模型，而 OpenTSDB 是单列模型，单列模型下是多行的聚合，多列模型下聚合会自然形成数据块。&lt;/p&gt;&lt;p&gt;而熟悉 LSM Tree 的 KV 分离设计的朋友应该也能够从 TDengine 的存储引擎设计中看到一些熟悉的影子。如果把数据块作为存储引擎的 value，那么 key 就应该是块的起止时间 ，把 key 提出来自然就得到了 TDengine 的 BRIN 索引。从这种视角来看，TDengine 的 .head 文件就是 key，而 .data 和 .last 文件就是 value，而 key 自身又可以结合时序数据的特征组合成有序文件。在时序场景下，有了 BRIN 索引，也就可以不需要 bloom filter，这样一看，TDengine 的存储引擎设计就很清晰了。&lt;/p&gt;&lt;p&gt;此外，TDengine 会将 tag 数据和时序数据分离开来，这样就能够大大减少 tag 数据占用的存储空间，在数据量大的情况下尤其显著。&lt;/p&gt;&lt;p&gt;TDengine 的 tag 与时序数据的划分，和数仓的维度建模里面维度表与事实表的划分有些类似，tag 数据类似维度表，而时序数据类似事实表。但又有所不同，因为 TDengine 中表的数目是和设备数目相同的，上亿设备就是上亿张表（在正在开发的 TDengine 3.0 中，我们要支持 100 亿张表），这样频繁创建、又极其庞大的表，并不容易处理，主要的麻烦是其产生了大量的元数据，超过了单点的处理能力，这就要求 TDengine 能将这部分元数据也进行分片存储。&lt;/p&gt;&lt;p&gt;当数据与元数据进行分片、多副本操作时，就自然涉及到一致性与可用性的问题。在时序数据库中，时序数据通常是最终一致同步的，因为最终一致算法的吞吐量高延迟低、可用性也比强一致算法好，比如 InfluxDB 的集群版会用 Dynamo 这种无主风格的数据同步。但元数据（也就是我们上面提到的标签和表数据）需要强一致，强一致通常会用 Raft、Paxos 这类算法来保证正确性。&lt;/p&gt;&lt;p&gt;由于元数据量的巨大需要分片，而当时序数据与元数据都做分片（甚至时序数据和其关联的元数据应该在同一分片），但又有截然不同的一致性要求，这就导致 TDengine 的副本复制并不是简单地使用 Raft 这类算法就能够驾驭得了的，除非牺牲时序数据的写入吞吐和可用性，也做强一致复制。这就是 TDengine 使用自研复制算法的根本原因。当然，这些算法在复杂的分布式环境下的一致性保证又是另外的问题了，也是我们要着重解决的挑战。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;3&lt;/span&gt; 写在最后&lt;/section&gt;&lt;p&gt;一个好的时序数据库，起源于对时序数据领域的数据特征的洞察，成长于大量真实场景的考验与用户的反馈，又在数据库领域的最先进技术中吸取经验得以完善。只有这样，最终才能做到在时序场景下“远超”通用型数据库，成为此场景下的优选数据库。而要做到这一步，其实并不容易。&lt;/p&gt;&lt;p&gt;最后预告一下我们正在开发的 TDengine 3.0。在 3.0 版本中，我们对现在的 2.x 版本存在的一些待解问题做了重新设计与彻底重构，敬请期待。另外关于在 3.0 开发中踩过的坑，以后有机会再和大家慢慢道来。&lt;/p&gt;&lt;section&gt;&lt;span&gt;今日好文推荐&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651113603&amp;amp;idx=1&amp;amp;sn=60035ad667425424046fd9478d2757a5&amp;amp;chksm=bdb930d08aceb9c6052469a6624fe0759c3caf5a280b2eab5669fbe75007265ba761f954c3b0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;五年官司终败诉，万亿爬虫大军蠢蠢欲动&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;五年官司终败诉，万亿爬虫大军蠢蠢欲动&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651113533&amp;amp;idx=1&amp;amp;sn=42bccbb69c86536eec498ec9bb750d2e&amp;amp;chksm=bdb9306e8aceb9789a0172709fa89b835c79c984933b914b1355f773f3c77eb25d12631c17de&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;自由软件之父抨击苹果电脑变成“监狱”，不建议用Ubuntu&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;自由软件之父抨击苹果电脑变成“监狱”，不建议用Ubuntu&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651113328&amp;amp;idx=1&amp;amp;sn=4c14c00b1fddeed0bdec605db53fd21a&amp;amp;chksm=bdb93f238aceb6352c4baaa19c0cfe298971d0acc75ccb9f4a0a83f91dcb7eef9d73a44b82b5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;今天的应用架构，正处在一个不可测的阶段&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;今天的应用架构，正处在一个不可测的阶段&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651113230&amp;amp;idx=1&amp;amp;sn=c156d97bb8a49df3b7bccd9baa5757f7&amp;amp;chksm=bdb93f5d8aceb64b8234413052826cda94f8b136eac53868b524b845740012d1e2fd34217829&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2022 年 Java 将何去何从？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;2022 年 Java 将何去何从？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1515625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YriaiaJPb26VNBX66P2F9dF2yuYfbcibGMuaBYgvK62MGPE9HhgU2vptFAUZdaO2cGKCsP4h1DnibIGywKSkFv9b6g/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点个在看少个 bug&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;👇&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fd3eb4e0fa09edc51b39430e039986e4</guid>
<title>几道高频的JVM面试题</title>
<link>https://toutiao.io/k/zgzh3st</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是&lt;strong&gt;程序员田螺&lt;/strong&gt;。整理了几道高频的JVM面试题，小伙伴们加油呀！&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;JVM内存为什么要分成新生代，老年代&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新生代中为什么要分为Eden和Survivor&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JVM中一次完整的GC流程是怎样的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CMS收集器和G1收集器的区别&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JVM 调优&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CPU飙升如何排查&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg3NTY2NDMwMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/iaPU220ia3N7QfHsbKk3mGa1lsrNh9kID5jJsopIGBnric9v4xKcFOv50y6N3A3CVRteuJ9tQI0IAIh37R3dpvGog/0?wx_fmt=png&quot; data-nickname=&quot;程序员田螺&quot; data-alias=&quot;&quot; data-signature=&quot;专注分享后端面试题，包括计算机网络、MySql数据库、Redis缓存、操作系统、Java后端、大厂面试真题等领域。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. JVM内存为什么要分成新生代，老年代？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 JVM共享内存划分&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;共享内存区 = 持久代 + 堆（jdk1.8及以上jvm废弃了持久代）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;持久代 = 方法区 + 其他&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Java堆 = 老年代 + 新生代&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新生代 = Eden + S0 + S1&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 为什么分年老代和新生代&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;新生代：主要存放新创建的对象，内存大小一般会比较小，垃圾回收会比较频繁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老年代(Tenured Gen)：主要存放JVM认为生命周期比较长的对象（经过几次的Young GC的垃圾回收后仍然存在），或者大对象，垃圾回收也相对没有那么频繁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么划分老年代和新生代，主要&lt;strong&gt;对象大小不一样，对象生命周期不一样。划分后，提供垃圾回收效率，节省资源，提升对象利用率&lt;/strong&gt;等等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 新生代为何划分Eden和Survivor？为什么设置两个Survivor&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多,所以需要分为Eden和Survivor。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置两个Survivor区最大的好处就是解决了碎片化，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. JVM中一次完整的GC流程是怎样的&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Java堆划分为老年代和新生代&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新生代 划分为Eden和两个Survivor(S0、S1)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当 Eden区的空间满了， Java虚拟机会触发一次Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年态；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。即长期存活的对象进入老年态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，Full GC  清理整个内存堆 – 包括年轻代和年老代。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Major GC 发生在老年代的GC，清理老年区，经常会伴随至少一次Minor GC，比Minor GC慢10倍以上。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. CMS收集器和G1收集器的区别&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;CMS收集器是老年代的收集器，一般配合新生代的Serial和ParNew收集器一起使用；G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CMS收集器是一种以获取&lt;strong&gt;最短回收停顿时间&lt;/strong&gt;为目标的收集器， G1收集器&lt;strong&gt;可预测垃圾回收的停顿时间&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片；而G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CMS和G1的回收过程不一样，垃圾回收的过程不一样。CMS是&lt;strong&gt;初始标记、并发标记、重新标记、并发清理&lt;/strong&gt;;G1是初始标记、并发标记、最终标记、筛选回收。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. JVM 调优&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM调优其实就是通过调节JVM参数，即对垃圾收集器和内存分配的调优，以达到更高的吞吐和性能。JVM调优主要调节以下参数&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.812962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaPU220ia3N7QVQPA9q1mfQcasOEw6Ta5IibMCz0uq4MVo9EC2AbFVaZIcBCcZrPFMX380XPIf5UIrH08uTaicTNRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;堆栈内存相关&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;-Xms 设置初始堆的大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-Xmx 设置最大堆的大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-Xmn 设置年轻代大小，相当于同时配置-XX:NewSize和-XX:MaxNewSize为一样的值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-Xss  每个线程的堆栈大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:NewSize 设置年轻代大小(for 1.3/1.4)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:MaxNewSize 年轻代最大值(for 1.3/1.4)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:NewRatio 年轻代与年老代的比值(除去持久代)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:SurvivorRatio Eden区与Survivor区的的比值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:PretenureSizeThreshold 当创建的对象超过指定大小时，直接把对象分配在老年代。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:MaxTenuringThreshold设定对象在Survivor复制的最大年龄阈值，超过阈值转移到老年代&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;垃圾收集器相关&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;-XX:+UseParallelGC：选择垃圾收集器为并行收集器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:ParallelGCThreads=20：配置并行收集器的线程数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseConcMarkSweepGC：设置年老代为并发收集。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:CMSFullGCsBeforeCompaction=5 由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行5次GC以后对内存空间进行压缩、整理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;辅助信息相关&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;-XX:+PrintGCDetails 打印GC详细信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+HeapDumpOnOutOfMemoryError让JVM在发生内存溢出的时候自动生成内存快照,排查问题用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+DisableExplicitGC禁止系统System.gc()，防止手动误触发FGC造成问题.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+PrintTLAB 查看TLAB空间的使用情况&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. CPU飙升如何排查&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;输入jps，获得进程号。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;top -Hp pid 获取本进程中所有线程的CPU耗时性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;printf %x cpu最高的线程（即转为16进制）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jstack 命令查看当前java进程的堆栈状态 | grep 那个16进制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;或者 jstack -l &amp;gt; /tmp/output.txt 把堆栈信息打到一个txt文件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg3NTY2NDMwMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/iaPU220ia3N7QfHsbKk3mGa1lsrNh9kID5jJsopIGBnric9v4xKcFOv50y6N3A3CVRteuJ9tQI0IAIh37R3dpvGog/0?wx_fmt=png&quot; data-nickname=&quot;程序员田螺&quot; data-alias=&quot;&quot; data-signature=&quot;专注分享后端面试题，包括计算机网络、MySql数据库、Redis缓存、操作系统、Java后端、大厂面试真题等领域。&quot; data-from=&quot;0&quot;/&gt;&lt;span/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>