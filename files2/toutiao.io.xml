<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>9e93aa60f713e266d5e5d49a56d170bd</guid>
<title>Redis 集群 JedisCluster的pipeline 自定义实现</title>
<link>https://toutiao.io/k/y3b2owg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h1&gt;前言&lt;/h1&gt;

&lt;p&gt;2020年4月30日，Redis 6.0.0正式发布，标志着redis从此告别单线程。在此之前，在大数据生产环境中使用的是一个30个节点的Codis集群，SparkStreaming以此作为缓存，QPS高峰大概在2000w/s。&lt;/p&gt;

&lt;p&gt;因为Codis不再更新迭代，于是在Redis 6.0.6版本发布的时候搭建了Redis Cluster，新的应用将不再使用Codis。之前连接Codis使用的Java客户端是Jedis，通过Pipeline方式批次执行命令，以此来提高效率。而Redis Cluster的客户端JedisCluster没有提供Pipeline方式，只能单条执行命令，于是开始考虑其他的Java客户端。&lt;/p&gt;

&lt;p&gt;这里备选了两个客户端：&lt;strong&gt;lettuce&lt;/strong&gt;和&lt;strong&gt;Redisson&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;pipeline原理&lt;/h2&gt;

&lt;p&gt;这里先说一下Jedis的pipeline的原理。通过pipeline对redis的所有操作命令，都会先放到一个List中，当pipeline直接执行或者通过jedis.close()调用sync()的时候，所有的命令都会一次性地发送到客户端，并且每个操作命令返回一个response，通过get来获取操作结果。&lt;/p&gt;

&lt;h1&gt;lettuce&lt;/h1&gt;

&lt;p&gt;lettuce提供了async异步方式来实现pipeline的功能，来测试一下是否可按批次处理命令。&lt;/p&gt;

&lt;p&gt;测试代码：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public static void main(String[] args) throws Exception {
        RedisURI uri = RedisURI.builder()
                .withHost(&quot;47.102.xxx.xxx&quot;)
                .withPassword(&quot;Redis6.0.6&quot;.toCharArray())
                .withPort(10001)
                .build();
        RedisClusterClient client = RedisClusterClient.create(uri);
        StatefulRedisClusterConnection&amp;lt;String, String&amp;gt; connect = client.connect();
        RedisAdvancedClusterAsyncCommands&amp;lt;String, String&amp;gt; async = connect.async();
        // 断点1
        async.set(&quot;key1&quot;, &quot;v1&quot;);
        Thread.sleep(1000 * 3);
        // 断点2
        async.set(&quot;key2&quot;, &quot;v2&quot;);
        // 断点3
        async.flushCommands();
        Thread.sleep(1000 * 3);
        connect.close();
        client.shutdown();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在程序中设置三个断点。如果是pipeline的话，只有执行完断点3，两条set命令才会执行。
运行结果：
&lt;img src=&quot;https://img-blog.csdnimg.cn/20201214092218858.png&quot; alt=&quot;运行结果&quot;/&gt;
结果表明还未到flushCommands()，第一个set命令已经执行。到这你可能就会以为lettuce其实还是逐条命令执行，只是开启了异步请求模式。其实不然，在lettuce异步操作中，默认开启了&lt;strong&gt;命令自动刷新&lt;/strong&gt;功能，所以给你的假象还是逐条执行，在此需要&lt;strong&gt;禁用自动刷新&lt;/strong&gt;来开启pipeline功能。&lt;/p&gt;

&lt;p&gt;在set()之前加上一行代码：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;async.setAutoFlushCommands(false);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：
&lt;img src=&quot;https://img-blog.csdnimg.cn/20201214094221395.png&quot; alt=&quot;运行结果&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;Redisson&lt;/h1&gt;

&lt;p&gt;redisson提供了batch来实现pipeline的功能。&lt;/p&gt;

&lt;p&gt;测试代码:&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt; Config config = new Config();
 config.useClusterServers()
       .addNodeAddress(&quot;redis://47.102.219.86:10001&quot;)
       .setPassword(&quot;Redis@6.0.6&quot;);
 RedissonClient redisson = Redisson.create(config);
 RBatch batch = redisson.createBatch();
 String key = &quot;test&quot;;
 for (int i = 1; i &amp;lt; 3; i++) {
      batch.getMap(key + i).putAsync(String.valueOf(i), String.valueOf(i));
    }
 // 打上断点
 batch.execute();
 redisson.shutdown();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们在execute()处打上断点，debug运行程序。
运行结果：
&lt;img src=&quot;https://img-blog.csdnimg.cn/202012140047268.png&quot; alt=&quot;执行结果&quot;/&gt;
结果表明Redisson会将命令放在一个batch中，当执行execute()时，会将命令一次性发送到redis执行。虽然Redisson实现了pipeline的功能，但是我最后还是放弃了它。原因很简单，它的方法不像jedis和lettuce一样简单明了，和redis的操作命令相差太多，导致使用起来比较繁琐。&lt;/p&gt;

&lt;h1&gt;Jedis Cluster Pipeline&lt;/h1&gt;

&lt;h2&gt;原因&lt;/h2&gt;

&lt;p&gt;开头也提到了，Jedis对Redis Cluster提供了JedisCluster客户端，但是没有Pipeline模式，那么JedisCluster为什么不支持Pipeline？&lt;/p&gt;

&lt;p&gt;在redis中一共有16384个Slot，每个节点负责一部分Slot，当对Key进行操作时，redis会通过&lt;em&gt;CRC16&lt;/em&gt;计算出key对应的Slot，将Key映射到Slot所在节点上执行操作。&lt;/p&gt;

&lt;p&gt;因为不同Key映射的节点不同，所以JedisCluster需要持有Redis Cluster每个节点的连接才能执行操作，而Pipeline是面向于一个redis连接的执行模式，所以JedisCluster无法支持Pipeline。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;那么我们自己有没有办法利用JedisCluster去封装一个具有Pipeline模式的客户端？&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;思路&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;刚刚提到，JedisCluster会持有Redis Cluster所有节点的连接&lt;/strong&gt;。那么，如果我们可以获取到所有节点的连接，对每个节点的连接都开启Pipeline。首先计算出每个Key所在的Slot，再找到Slot对应节点，就可以将Key放到对应节点连接的Pipeline上，这样不就实现了集群版的Pipeline了么！&lt;/p&gt;

&lt;p&gt;我们要做的工作就是找到对应关系，将每个Key分配到对应的节点连接中。&lt;/p&gt;

&lt;p&gt;秉着不重复造轮子的观点，我们先看看JedisCluster是如何执行命令的？&lt;/p&gt;

&lt;h2&gt;JedisCluster&lt;/h2&gt;

&lt;p&gt;先写样例，并在get()处打断点。
&lt;img src=&quot;https://img-blog.csdnimg.cn/2020121509471542.png&quot; alt=&quot;JedisCluster&quot;/&gt;
 &lt;img src=&quot;https://img-blog.csdnimg.cn/2020121510133387.png&quot; alt=&quot;run()&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;CRC16&lt;/h3&gt;

&lt;p&gt;进入run()，可以看到JedisClusterCRC16提供了getSlot()方法，&lt;strong&gt;可以计算出Key所在的Slot&lt;/strong&gt;。
&lt;img src=&quot;https://img-blog.csdnimg.cn/20201215102154264.png&quot; alt=&quot;run()&quot;/&gt;&lt;/p&gt;

&lt;p&gt;run()里面调用了runWithRetries()，这是核心方法之一，Step into&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;// 据方法调用参数删除了部分代码
private T runWithRetries(final int slot, int attempts, boolean tryRandomNode, JedisRedirectionException redirect) {
    Jedis connection = null;
    try {
        // false
        if (tryRandomNode) {
            connection = connectionHandler.getConnection();
        } else {
            // 重点：从方法名看，是根据slot来获取jedis连接！！
            connection = connectionHandler.getConnectionFromSlot(slot);
        }
        return execute(connection);
    } catch (JedisNoReachableClusterNodeException jnrcne) {
      throw jnrcne;
    } catch (JedisConnectionException jce) {
      // 释放连接
      releaseConnection(connection);
      connection = null;
      if (attempts &amp;lt;= 1) {
        // 刷新slots
        this.connectionHandler.renewSlotCache();
      }
      return runWithRetries(slot, attempts - 1, tryRandomNode, redirect);
    } 
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从runWithRetries()可以看到，JedisCluster通过调用getConnectionFromSlot(slot)来获取jedis连接，这里&lt;strong&gt;实现了Slot和Jedis的关系&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;那么connectionHandler为什么可以提供redis连接？&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;connectionHandler&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;查看connectionHandler变量信息&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201215145801307.png&quot; alt=&quot;connectionHandler&quot;/&gt;
可以看到它有一个JedisClusterInfoCache类型的成员变量cache，cache有两个HashMap类型的成员变量nodes和slots，nodes保存节点和JedisPool的映射关系，slots保存16384个slot和JedisPool的映射关系，这里&lt;strong&gt;slot和节点实现了映射关系&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;接着看一下getConnectionFromSlot()&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201215155826851.png&quot; alt=&quot;getConnectionFromSlot()&quot;/&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20201215162754242.png&quot; alt=&quot;getSlotPool()&quot;/&gt;
可以看出，cache调用getSlotPool()，从成员变量slots中通过slot取到了相应节点的JedisPool。&lt;/p&gt;

&lt;p&gt;简单的画一下流程图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/202012151706329.png&quot; alt=&quot;流程图&quot;/&gt;&lt;/p&gt;

&lt;p&gt;至此，所有轮子都已经具备，开始造车。
&lt;img src=&quot;https://img-blog.csdnimg.cn/20201216160632824.jpg&quot; alt=&quot;Pipeline&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;实现Pipeline&lt;/h1&gt;

&lt;p&gt;我们只要获取到connectionHandler变量，就可以使用它的成员变量cache来获取Jedis。&lt;/p&gt;

&lt;p&gt;connectionHandler是JedisCluster的成员变量，在其父类BinaryJedisCluster中找到了此变量。
&lt;img src=&quot;https://img-blog.csdnimg.cn/20201215174630762.png&quot; alt=&quot;BinaryJedisCluster&quot;/&gt;
cache是connectionHandler的成员变量，在其父类JedisClusterConnectionHandler找到了此变量。
&lt;img src=&quot;https://img-blog.csdnimg.cn/20201215175345852.png&quot; alt=&quot;JedisClusterConnectionHandler&quot;/&gt;
connectionHandler和cache都是protected变量，外部类无法直接访问，所以需要定义子类访问变量。&lt;/p&gt;

&lt;h2&gt;自定义ConnectionHandler&lt;/h2&gt;

&lt;p&gt;目的：使用cache保存的Cluster信息，用其来获取JedisPool。&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class JedisSlotConnectionHandlerImp extends JedisSlotBasedConnectionHandler implements Serializable {
    public JedisSlotConnectionHandlerImp(Set&amp;lt;HostAndPort&amp;gt; nodes, GenericObjectPoolConfig poolConfig, int connectionTimeout, int soTimeout, String password) {
        super(nodes, poolConfig, connectionTimeout, soTimeout, password);
    }

    // 自定义通过slot获取JedisPool的方法
    // 为了保证后面一个JedisPool只取一个Jedis
    public JedisPool getJedisPoolFromSlot(int slot) {
        JedisPool jedisPool = cache.getSlotPool(slot);
        if (jedisPool != null) {
            return jedisPool;
        } else {
            renewSlotCache();
            jedisPool = cache.getSlotPool(slot);
            if (jedisPool != null) {
                return jedisPool;
            } else {
                throw new JedisNoReachableClusterNodeException(&quot;No reachable node in cluster for slot &quot; + slot);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;自定义ClusterPipeline&lt;/h2&gt;

&lt;p&gt;目的：使用connectionHandler来建立key、slot以及JedisPool之间关系映射&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class JedisClusterPipeline extends JedisCluster implements Serializable {
    // 覆盖父类中的connectionHandler
    protected JedisSlotConnectionHandlerImp connectionHandler;
    public JedisClusterPipeline(HashSet node, int connectionTimeout, int soTimeout, int maxAttempts, String password, GenericObjectPoolConfig poolConfig) {
        super(node, connectionTimeout, soTimeout, maxAttempts, password, poolConfig);
        connectionHandler = new JedisSlotConnectionHandlerImp(node, poolConfig, connectionTimeout, soTimeout, password);
    }
    // 通过key转换成slot，再获取JedisPool
    public JedisPool getJedisPoolFromSlot(String key) {
        return connectionHandler.getJedisPoolFromSlot(JedisClusterCRC16.getSlot(key));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;使用&lt;/h2&gt;

&lt;p&gt;使用自定义的JedisClusterPipeline，需要自己实现set、get、hget等方法来覆盖父类JedisCluster对应的方法。最初的目的是应用于Spark将维度信息存入Redis Cluster，当时是用scala面向RDD的partition实现了集群版的hmset()方法。&lt;/p&gt;

&lt;p&gt;这里临时用Java实现一下Pipeline的set()方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现set()&lt;/strong&gt;&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class JedisClusterPipelineCommand {
    /**
     * 自定义的pipeline模式set方法
     * @param key 存放的key
     * @param value 存放的value
     * @param clusterPipeline 用来获取JedisPool
     * @param pipelines 建立JedisPool和pipeline映射，保证一个JedisPool只开启一个pipeline
     * @param jedisMap 建立pipeline和Jedis映射，用来释放Jedis
     * @param nums 记录每个pipeline放入key的条数
     * @param threshold pipeline进行sync的阈值
     */
    public static void setByPipeline(String key, String value, JedisClusterPipeline clusterPipeline, ConcurrentHashMap&amp;lt;JedisPool, Pipeline&amp;gt; pipelines, ConcurrentHashMap&amp;lt;Pipeline, Jedis&amp;gt; jedisMap,  ConcurrentHashMap&amp;lt;Pipeline, Integer&amp;gt; nums, int threshold) {
        JedisPool jedisPool = clusterPipeline.getJedisPoolFromSlot(key);
        // 查看对应节点是否已经开启了pipeline
        Pipeline pipeline = pipelines.get(jedisPool);
        if (pipeline == null) {
            Jedis jedis = jedisPool.getResource();
            pipeline = jedis.pipelined();
            // 构建映射关系，保证每个节点只有一个jedis来开启pipeline
            jedisMap.put(pipeline, jedis);
            pipelines.put(jedisPool, pipeline);
            nums.put(pipeline, 0);
        }else {
            int num = nums.get(pipeline);
            nums.put(pipeline, num + 1);
            if (num % threshold == 0) {
                pipeline.sync();
            }
        }
        pipeline.set(key, value);
    }

    /**
     * 释放jedis并强制pipeline sync
     */
    public static void releaseConnection(ConcurrentHashMap&amp;lt;Pipeline, Jedis&amp;gt; jedisMap) {
        for (Jedis jedis : jedisMap.values()) {
            jedis.close();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;执行类&lt;/strong&gt;&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;    public static void main(String[] args) throws Exception {
        JedisPoolConfig config = new JedisPoolConfig();
        HashSet jedisClusterNodes = new java.util.HashSet&amp;lt;HostAndPort&amp;gt;();
        jedisClusterNodes.add(new HostAndPort(&quot;47.102.xxx.xx&quot;, 10001));
        JedisClusterPipeline jedisClusterPipeline = new JedisClusterPipeline(jedisClusterNodes, 1000, 1000, 10, &quot;Redis6&quot;, config);
        ConcurrentHashMap&amp;lt;JedisPool, Pipeline&amp;gt; pipelines = new ConcurrentHashMap&amp;lt;&amp;gt;();
        ConcurrentHashMap&amp;lt;Pipeline, Jedis&amp;gt; jedisMap = new ConcurrentHashMap&amp;lt;&amp;gt;();
        ConcurrentHashMap&amp;lt;Pipeline, Integer&amp;gt; nums = new ConcurrentHashMap&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; 1000; i++) {
            JedisClusterPipelineCommand.setByPipeline(&quot;k&quot; + i, &quot;v&quot; + i, jedisClusterPipeline, pipelines, jedisMap, nums, 100 );
        }
        JedisClusterPipelineCommand.releaseConnection(jedisMap);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;执行结果&lt;/strong&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20201216182558100.png&quot; alt=&quot;执行结果&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;性能测试&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;本机环境1000条数据&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;pipeline模式：2.32s&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JedisCluster：68.6s&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Spark on Yarn 128w条 Hash&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;本机环境测试结果受限于网络和主机配置，仅供比较参考。&lt;/p&gt;

&lt;h1&gt;结语&lt;/h1&gt;

&lt;p&gt;最后选择自己实现pipeline，首先是因为比较了解pipeline的原理，说白了就是用习惯了。其次是在本机测试letttuce时，出现了一些意料之外的问题，目前还在探索中。下一步的工作就是慢慢的将Pipeline其他的方法实现，逐步优化，用于生产。&lt;/p&gt;

&lt;p/&gt;

&lt;hr/&gt;

&lt;p&gt;95后小程序员，写的都是日常工作中的亲身实践，置身于初学者的角度从0写到1，保证能够真正让大家看懂。&lt;/p&gt;

&lt;p&gt;文章会在公众号 [&lt;strong&gt;入门到放弃之路&lt;/strong&gt;] 首发，期待你的关注。
&lt;img src=&quot;https://img-blog.csdnimg.cn/20210519233121183.png&quot; alt=&quot;感谢每一份关注&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5f9fdc0ffcb46679d9f498d16d1fb322</guid>
<title>消息队列解耦是骗小孩儿的</title>
<link>https://toutiao.io/k/szkr8sy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;有一个观点已经被说烂了：使用 MQ 可以帮助业务系统解耦。&lt;/p&gt;&lt;p&gt;想法很简单，在业务状态流转时，如果没有 MQ，那么其它系统想要知道状态变了，那就需要核心流程系统去主动做通知。&lt;/p&gt;&lt;p&gt;比如电商系统里订单从创建到处理中状态切换了，客服系统需要知道，风控系统需要知道，用户系统也需要知道。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.48671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbdflATJWdgiay3CIlhor3dgT38iaUtchvVtx9OZcTdiaiaCknSYibM5nE1L4jicUJqpzIg6ZcTRwB10Sh2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;一个典型的依赖关系&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这里的通知通过 RPC 来进行，下游系统需要的数据可以在这次 RPC 里携带上，也可以在请求的时候让下游系统自己去查。&lt;/p&gt;&lt;p&gt;下游系统增加的时候，核心业务的代码也需要修改，比如新做了一个积分系统，现在订单状态流转积分系统也想知道。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.48828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbdflATJWdgiay3CIlhor3dgT25fwzicUU79WDDYEIsTxeSJgdFVCg97ib8SxuhftqfAL9w8vTuFN7KVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;下游增加新系统时&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;核心系统需要不停地增加调用关系来迎合下游新增的业务方需求。这些边边角角的计算逻辑和订单系统本身没啥关系，但是因为下游需要拿到这些数据，我们就需要自己用 RPC 去调用下游的接口。这确实不太合理。&lt;/p&gt;&lt;p&gt;当下游系统发生事故时，很容易让核心系统也跟着一起躺了：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.48868778280542985&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Lq0XA1b7xbdflATJWdgiay3CIlhor3dgTicnnFibq5niaSKpJe7FqDpzTgcibo7GfwqCQcycykh5bNequo20UE1wCUQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;2210&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;下游炸了上游也得炸&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这种情况下，核心系统对下游系统的依赖主要是因为 &lt;strong&gt;core system&lt;/strong&gt; mentions &lt;strong&gt;downstream system&lt;/strong&gt;，和单系统内的耦合是一样的。&lt;/p&gt;&lt;p&gt;解决这种耦合的最简单的方法，在单模块的情况是用依赖反转，在分布式场景下，就是引入消息队列：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.48671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbdflATJWdgiay3CIlhor3dgTqxwAFJa7rRxTDmgpqmXI5E9FyJvNUHrciaXPXjkoLN3yGaH1ic3EbYDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;用消息队列解除上游对下游的依赖&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在修改之后，每次订单流转只要将 domain event 发送到消息队列就可以了。下游系统有计算需求，自己去订阅相关的 topic 即可。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.44765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbdflATJWdgiay3CIlhor3dgTeNrHVJCBeg66157XERVBc2LvghaibicodrFWt7XtsbicKyfc2Zda7YgwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;有了消息队列时下游增加新系统&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;讲到这里就结束，那就是童话故事了。在一开始的图中，我们存在的依赖是双向的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.77265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbdflATJWdgiay3CIlhor3dgToqXeXprjcxUnibW9hST0MXQ6ZiamibewMIEnTyKmJYmoDzvgMibicM9ibDoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;双向依赖&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;核心系统依赖下游系统是因为调用关系，下游系统依赖核心系统是因为下游系统要使用核心系统的数据。&lt;/p&gt;&lt;p&gt;我们使用 MQ 只是解开了单个方向上的依赖，核心系统没有对下游系统的调用了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7266666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Lq0XA1b7xbdflATJWdgiay3CIlhor3dgTSQicTBzLo6QWz3DBLZhdjhuw7PJexvRFDugWhN91Ypm59L7rrxhllZw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;有一个方向的依赖被解除了&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这样下游系统在崩溃的时候，也就不太容易影响到核心系统的稳定性。&lt;/p&gt;&lt;h2&gt;隐式依赖导致事故&lt;/h2&gt;&lt;p&gt;但下游系统对核心系统的数据依赖是不可能解除的，如果核心系统修改了产生 domain event 的代码，还是会导致下游系统出故障，很多情况下出故障都是一死死一片：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4755905511811024&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Lq0XA1b7xbdflATJWdgiay3CIlhor3dgT0NZ1mUy2eCWhibIkHG0ufLaaGEmP6Kzn9dhiakQOVqxK8zr6PvHfO4HA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1270&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;上游的 domain event 出问题的时候&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;大点的互联网公司经常是核心服务一做重构，下游服务哀鸿遍野。&lt;/p&gt;&lt;p&gt;数据依赖对于核心系统来说并不是一个可以显式看到的依赖，所以对于核心系统来说，这是外部对我的隐式依赖。&lt;/p&gt;&lt;p&gt;看不见的依赖是很可怕的，所有人都会慢慢地逐渐忽视它，直到事故发生的那一天。&lt;/p&gt;&lt;h2&gt;核心系统对下游系统重新建立依赖&lt;/h2&gt;&lt;p&gt;虽然梦做的很好，但核心系统在服务用户的过程中，往往也是要给用户返回一些实时计算的数据的，这部分数据从哪里来？&lt;/p&gt;&lt;p&gt;很多就是从下游计算系统来，比如说，我的订单流转系统，现在要在用户积分达到某个条件的时候，做一些特殊逻辑。&lt;/p&gt;&lt;p&gt;随着业务的发展，我们最初解除掉的依赖，又重新被建立了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7397260273972602&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Lq0XA1b7xbdflATJWdgiay3CIlhor3dgTFBs7XpcKibMfLgYdXZtM7Vpdrh9Zhic6jeSZJ6znb6tPcSjNLgCcXibiaA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;876&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;回到原点&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;环形依赖回来了！这下两个系统可能又会变成你挂我也挂的情况了。兜兜转转，我们重新回到了原点。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a15716414d6fe7b54ae9cba0deca719f</guid>
<title>面试侃集合：SynchronousQueue 公平模式篇</title>
<link>https://toutiao.io/k/bv8je05</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面试官：呦，小伙子来的挺早啊！&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：那是，不能让您等太久了啊（别废话了快开始吧，还赶着去下一场呢）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面试官：前面两轮表现还不错，那我们今天继续说说队列中的&lt;/strong&gt;&lt;/span&gt;&lt;code&gt;SynchronousQueue&lt;/code&gt;&lt;span&gt;&lt;strong&gt;吧。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：好的，&lt;code&gt;SynchronousQueue&lt;/code&gt;和之前介绍过的队列相比，稍微有一些特别，必须等到队列中的元素被消费后，才能继续向其中添加新的元素，因此它也被称为无缓冲的等待队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我还是先写一个例子吧，创建两个线程，生产者线程&lt;code&gt;putThread&lt;/code&gt;向&lt;code&gt;SynchronousQueue&lt;/code&gt;中放入元素，消费者线程&lt;code&gt;takeThread&lt;/code&gt;从中取走元素：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SynchronousQueue&amp;lt;Integer&amp;gt; queue=&lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;&amp;gt;(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;Thread putThread=&lt;span&gt;new&lt;/span&gt; Thread(()-&amp;gt;{&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= &lt;span&gt;2&lt;/span&gt;; i++) {&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;put thread put:&quot;&lt;/span&gt;+i);&lt;br/&gt;            queue.put(i);&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;put thread put:&quot;&lt;/span&gt;+i+&lt;span&gt;&quot; awake&quot;&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;});&lt;br/&gt;Thread takeThread=&lt;span&gt;new&lt;/span&gt; Thread(()-&amp;gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(j&amp;lt;&lt;span&gt;2&lt;/span&gt;){&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            j=queue.take();&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;take from putThread:&quot;&lt;/span&gt;+j);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;putThread.start();&lt;br/&gt;Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;takeThread.start();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行上面的代码，查看结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;put thread put:0&lt;br/&gt;take from putThread:0&lt;br/&gt;put thread put:0 awake&lt;br/&gt;put thread put:1&lt;br/&gt;take from putThread:1&lt;br/&gt;put thread put:1 awake&lt;br/&gt;put thread put:2&lt;br/&gt;take from putThread:2&lt;br/&gt;put thread put:2 awake&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，生产者线程在执行&lt;code&gt;put&lt;/code&gt;方法后就被阻塞，直到消费者线程执行&lt;code&gt;take&lt;/code&gt;方法对队列中的元素进行了消费，生产者线程才被唤醒，继续向下执行。简单来说运行流程是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicbGc3kYsT3lpcicdvCVLO1DUj5dW0TxTG9L0OrKprMcWdyPCnuRVnQcR0uYlS6oBkDicmP6g5PqGWZg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-ratio=&quot;0.3780487804878049&quot; data-w=&quot;820&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面试官：就这？应用谁不会啊&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;，不讲讲底层原理就想蒙混过&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;关？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：别急啊，我们先从它的构造函数说起，根据参数不同，&lt;code&gt;SynchronousQueue&lt;/code&gt;分为公平模式和非公平模式，默认情况下为非公平模式&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;SynchronousQueue&lt;/span&gt;(&lt;span&gt;boolean&lt;/span&gt; fair) &lt;/span&gt;{&lt;br/&gt;    transferer = fair ? &lt;span&gt;new&lt;/span&gt; TransferQueue&amp;lt;E&amp;gt;() : &lt;span&gt;new&lt;/span&gt; TransferStack&amp;lt;E&amp;gt;();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看看公平模式吧，该模式下底层使用的是&lt;code&gt;TransferQueue&lt;/code&gt;队列，内部节点由&lt;code&gt;QNode&lt;/code&gt;构成，定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;volatile&lt;/span&gt; QNode next;          &lt;span&gt;// next node in queue&lt;/span&gt;&lt;br/&gt;&lt;span&gt;volatile&lt;/span&gt; Object item;         &lt;span&gt;// CAS&#x27;ed to or from null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;volatile&lt;/span&gt; Thread waiter;       &lt;span&gt;// to control park/unpark&lt;/span&gt;&lt;br/&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isData;&lt;br/&gt;QNode(Object item, &lt;span&gt;boolean&lt;/span&gt; isData) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.item = item;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.isData = isData;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;item&lt;/code&gt;用来存储数据，&lt;code&gt;isData&lt;/code&gt;用来区分节点是什么类型的线程产生的，&lt;code&gt;true&lt;/code&gt;表示是生产者，&lt;code&gt;false&lt;/code&gt;表示是消费者，是后面用来进行节点&lt;strong&gt;匹配&lt;/strong&gt;（&lt;code&gt;complementary&lt;/code&gt; ）的关键。在&lt;code&gt;SynchronousQueue&lt;/code&gt;中匹配是一个非常重要的概念，例如一个线程先执行&lt;code&gt;put&lt;/code&gt;产生了一个节点放入队列，另一个线程再执行&lt;code&gt;take&lt;/code&gt;产生了一个节点，这两个不同类型的节点就可以匹配成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面试官：可是我看很多资料里说&lt;/strong&gt;&lt;/span&gt;&lt;code&gt;SynchronousQueue&lt;/code&gt;&lt;span&gt;&lt;strong&gt;是一个不存储元素的阻塞队&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;列，这点你是怎么理解的？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：通过上面节点中封装的属性，可以看出&lt;code&gt;SynchronousQueue&lt;/code&gt;的队列中封装的节点更多针对的不是数据，而是要执行的操作，个人猜测这个说法的出发点就是队列中存储的节点更多偏向于操作这一属性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;试官：好吧，接着往下说队列的结构吧。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：&lt;code&gt;TransferQueue&lt;/code&gt;中主要定义的属性有下面这些：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;transient&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; QNode head;&lt;br/&gt;&lt;span&gt;transient&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; QNode tail;&lt;br/&gt;&lt;span&gt;transient&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; QNode cleanMe;&lt;br/&gt;TransferQueue() {&lt;br/&gt;    QNode h = &lt;span&gt;new&lt;/span&gt; QNode(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;); &lt;span&gt;// initialize to dummy node.&lt;/span&gt;&lt;br/&gt;    head = h;&lt;br/&gt;    tail = h;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较重要的有头节点&lt;code&gt;head&lt;/code&gt;、尾节点&lt;code&gt;tail&lt;/code&gt;、以及用于标记下一个要删除的节点的&lt;code&gt;cleanMe&lt;/code&gt;节点。在构造函数初始化中创建了一个节点，注释中将它称为&lt;code&gt;dummy node&lt;/code&gt;，也就是伪造的节点，它的作用类似于&lt;code&gt;AQS&lt;/code&gt;中的头节点的作用，实际操作的节点是它的下一个节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要说&lt;code&gt;SynchronousQueue&lt;/code&gt;，真是一个神奇的队列，不管你调用的是&lt;code&gt;put&lt;/code&gt;和&lt;code&gt;offer&lt;/code&gt;，还是&lt;code&gt;take&lt;/code&gt;和&lt;code&gt;poll&lt;/code&gt;，它都一概交给核心的&lt;code&gt;transfer&lt;/code&gt;方法去处理，只不过参数不同。今天我们抛弃源码，通过画图对它进行分析，首先看一下方法的定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;E &lt;span&gt;transfer&lt;/span&gt;(E e, &lt;span&gt;boolean&lt;/span&gt; timed, &lt;span&gt;long&lt;/span&gt; nanos)&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;试官：呦呵，就一个方法？我倒要看看它是怎么区分实现的入队和出队操作…&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：在方法的参数中，&lt;code&gt;timed&lt;/code&gt;和&lt;code&gt;nanos&lt;/code&gt;用于标识调用&lt;code&gt;transfer&lt;/code&gt;的方法是否是能够超时退出的，而&lt;code&gt;e&lt;/code&gt;是否为空则可以说明是生产者还是消费者调用的此方法。如果&lt;code&gt;e&lt;/code&gt;不为&lt;code&gt;null&lt;/code&gt;，是生产者调用，如果&lt;code&gt;e&lt;/code&gt;为&lt;code&gt;null&lt;/code&gt;则是消费者调用。方法的整体逻辑可以分为下面几步：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;、若队列为空，或队列中的尾节点类型和自己的类型相同，那么准备封装一个新的&lt;code&gt;QNode&lt;/code&gt;添加到队列中。在添加新节点到队尾的过程中，并没有使用&lt;code&gt;synchronized&lt;/code&gt;或&lt;code&gt;ReentrantLock&lt;/code&gt;，而是通过&lt;code&gt;CAS&lt;/code&gt;来保证线程之间的同步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在添加新的&lt;code&gt;QNode&lt;/code&gt;到队尾前，会首先判断之前取到的尾节点是否发生过改变，如果有改变的话那么放弃修改，进行自旋，在下一次循环中再次判断。当检查队尾节点没有发生改变后，构建新的节点&lt;code&gt;QNode&lt;/code&gt;，并将它添加到队尾。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicbGc3kYsT3lpcicdvCVLO1DUy4ibuEKt2q4zpfAqIrg1wDkLjfBEYKn1PUoPhiaiaWJWZXA8nTqZtSVjQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-ratio=&quot;0.5697674418604651&quot; data-w=&quot;860&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;、当新节点被添加到队尾后，会调用&lt;code&gt;awaitFulfill&lt;/code&gt;方法，会根据传递的参数让线程进行自旋或直接挂起。方法的定义如下，参数中的&lt;code&gt;timed&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;时，表示这是一个有等待超时的方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;Object &lt;span&gt;awaitFulfill&lt;/span&gt;(QNode s, E e, &lt;span&gt;boolean&lt;/span&gt; timed, &lt;span&gt;long&lt;/span&gt; nanos)&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;awaitFulfill&lt;/code&gt;方法中会进行判断，如果新节点是&lt;code&gt;head&lt;/code&gt;节点的下一个节点，考虑到可能很快它就会完成匹配后出队，先不将它挂起，进行一定次数的自旋，超过自旋次数的上限后再进行挂起。如果不是&lt;code&gt;head&lt;/code&gt;节点的下一个节点，避免自旋造成的资源浪费，则直接调用&lt;code&gt;park&lt;/code&gt;或&lt;code&gt;parkNanos&lt;/code&gt;挂起线程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicY21VhDjK3Faf4WjynvibMcqc1Uw3cGF4UBib7DKMruHQZzocgOicyem0hMOxxKVzwXRvGkoEnDW1dpA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-ratio=&quot;0.4883720930232558&quot; data-w=&quot;860&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3&lt;/strong&gt;、当挂起的线程被中断或到达超时时间，那么需要将节点从队列中进行移除，这时会执行&lt;code&gt;clean()&lt;/code&gt;方法。如果要被删除的节点不是链表中的尾节点，那么比较简单，直接使用&lt;code&gt;CAS&lt;/code&gt;替换前一个节点的&lt;code&gt;next&lt;/code&gt;指针。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.37681159420289856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicbvib2dIHQAiaKBhgn6ykEhw8UM2xqX1etXlJ9qYWuLo8UHclgaJjtHibtAic28EbPBcIB3QafnVS87qQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;690&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要删除的节点是链表中的尾节点，就会有点复杂了，因为多线程环境下可能正好有其他线程正在向尾节点后添加新的节点，这时如果直接删除尾节点的话，会造成后面节点的丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候就会用到&lt;code&gt;TransferQueue&lt;/code&gt;中定义的&lt;code&gt;cleanMe&lt;/code&gt;标记节点了，&lt;code&gt;cleanMe&lt;/code&gt;的作用就是当要被移除的节点是队尾节点时，用它来标记队尾节点的前驱节点。具体在执行过程中，又会分为两种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;cleanMe&lt;/code&gt;节点为&lt;code&gt;null&lt;/code&gt;，说明队列在之前没有标记需要删除的节点。这时会使用&lt;code&gt;cleanMe&lt;/code&gt;来标识该节点的前驱节点，标记完成后退出&lt;code&gt;clean&lt;/code&gt;方法，当下一次执行&lt;code&gt;clean&lt;/code&gt;方法时才会删除&lt;code&gt;cleanMe&lt;/code&gt;的下一个节点。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicbvib2dIHQAiaKBhgn6ykEhw8LrjJO9x2YtdQRt4T275hbGQWeSqsJnibgyqmRfnUcBbtyAOF9qqnuQg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;cleanMe&lt;/code&gt;节点不为&lt;code&gt;null&lt;/code&gt;，那么说明之前已经标记过需要删除的节点。这时删除&lt;code&gt;cleanMe&lt;/code&gt;的下一个节点，并清除当前&lt;code&gt;cleanMe&lt;/code&gt;标记，并再将当前节点&lt;strong&gt;未修改前的&lt;/strong&gt;前驱节点标记为&lt;code&gt;cleanMe&lt;/code&gt;。注意，当前要被删除的节点的前驱节点不会发生改变，即使这个前驱节点已经在逻辑上从队列中删除掉了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicbvib2dIHQAiaKBhgn6ykEhw8h8VWxgSlHNYcWLFJatp51ib3pFnbqnKUkMVD82YsHuIianv1tbyAPPmw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-ratio=&quot;0.46511627906976744&quot; data-w=&quot;860&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行完成&lt;code&gt;clean&lt;/code&gt;方法后，&lt;code&gt;transfer&lt;/code&gt;方法会直接返回&lt;code&gt;null&lt;/code&gt;，说明入队操作失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;试官：讲了这么多，入队的还都是一个类型的节点吧？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：是的，&lt;code&gt;TransferQueue&lt;/code&gt;队列中，只会存在一个类型的节点，如果有另一个类型的节点过来，那么就会执行出队的操作了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;试官：好吧，那你接着再说说出队方法吧。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：相对入队来说，出队的逻辑就比较简单了。因为现在使用的是公平模式，所以当队列不为空，且队列的&lt;code&gt;head&lt;/code&gt;节点的下一个节点与当前节点匹配成功时，进行出队操作，唤醒&lt;code&gt;head&lt;/code&gt;节点的下一个节点，进行数据的传递。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据队列中节点类型的不同，可以分为两种情况进行分析：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;、如果&lt;code&gt;head&lt;/code&gt;节点的下一个节点是&lt;code&gt;put&lt;/code&gt;类型，当前新节点是&lt;code&gt;take&lt;/code&gt;类型。&lt;code&gt;take&lt;/code&gt;线程取出&lt;code&gt;put&lt;/code&gt;节点的&lt;code&gt;item&lt;/code&gt;的值，并将其&lt;code&gt;item&lt;/code&gt;变为&lt;code&gt;null&lt;/code&gt;，然后推进头节点，唤醒被挂起的&lt;code&gt;put&lt;/code&gt;线程，&lt;code&gt;take&lt;/code&gt;线程返回&lt;code&gt;item&lt;/code&gt;的值，完成数据的传递过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;head&lt;/code&gt;节点的下一个节点被唤醒后，会推进&lt;code&gt;head&lt;/code&gt;节点，虽然前面说过队列的&lt;code&gt;head&lt;/code&gt;节点是一个&lt;code&gt;dummy&lt;/code&gt;节点，并不存储数据，理论上应该将第二个节点直接移出队列，但是源码中还是将&lt;code&gt;head&lt;/code&gt;节点出队，将原来的第二个节点变成了新的&lt;code&gt;head&lt;/code&gt;节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicbvib2dIHQAiaKBhgn6ykEhw8e16N2Pd3jZxSkn75ibzHKt5M9dhG9b5mKkfoZoULCza8DUITibMk9mjA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-ratio=&quot;0.4186046511627907&quot; data-w=&quot;860&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;、同理，如果&lt;code&gt;head&lt;/code&gt;节点的下一个节点是&lt;code&gt;take&lt;/code&gt;类型，当前新节点是&lt;code&gt;put&lt;/code&gt;类型。&lt;code&gt;put&lt;/code&gt;线程会将&lt;code&gt;take&lt;/code&gt;节点的&lt;code&gt;item&lt;/code&gt;设为自己的数据值，然后推进头节点，并唤醒挂起的&lt;code&gt;take&lt;/code&gt;线程，唤醒的&lt;code&gt;take&lt;/code&gt;线程最终返回从&lt;code&gt;put&lt;/code&gt;线程获得的&lt;code&gt;item&lt;/code&gt;的值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicbvib2dIHQAiaKBhgn6ykEhw8779MENPI1Duunw4gzNPpf2W24Uz6XGH46OrcV66P65mV1CicXmRrvug/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-ratio=&quot;0.4186046511627907&quot; data-w=&quot;860&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，在&lt;code&gt;take&lt;/code&gt;线程唤醒后，会将自己&lt;code&gt;QNode&lt;/code&gt;的&lt;code&gt;item&lt;/code&gt;指针指向自己，并将&lt;code&gt;waiter&lt;/code&gt;中保存的线程置为&lt;code&gt;null&lt;/code&gt;，方便之后被&lt;code&gt;gc&lt;/code&gt;回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;试官：也就是说，在代码中不一定非要生产者先去生产产品，也可以由消费者先到达后进行阻塞等待？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：是的，两种线程都可以先进入队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;试官：好了，公平模式下我是明白了，我去喝口水，给你十分钟时间，回来我们聊聊非公平模式的实现&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;吧。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：……&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6ffacc57280c00895ff5f402a54ecc8c</guid>
<title>数仓的元数据管理和上下游约定</title>
<link>https://toutiao.io/k/2rxc164</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;/&gt;&lt;/h3&gt;&lt;section class=&quot;mp_profile_iframe_wrp custom_select_card_wrp wx-edui-media-wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA5MjUyMzY0MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/p8gfFXwpDiaXcxxApaRvsQofotxXJ4IVm3bYSdwibibLBThIDcWe5JBVvpr6ytxubv52DMs0Lz37MibjgvILo2h9Ww/0?wx_fmt=png&quot; data-nickname=&quot;白程序员的自习室&quot; data-alias=&quot;dabaispace&quot; data-signature=&quot;数据人的日常分享空间，在这里有个人的生活感悟，学习心得，工作的实践和方法论等。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;数仓元数据管理&lt;/span&gt;&lt;span class=&quot;suffix&quot;/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;/&gt;&lt;span class=&quot;content&quot;&gt;一、元数据定义&lt;/span&gt;&lt;span class=&quot;suffix&quot;/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;元数据（Meta Data）狭义的来说可以理解为描述数据的数据，广义的来看是除了业务逻辑直接读写处理外的业务数据，所有用来维持整个系统运转所需的信息及数据都可以叫作元数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何理解上面这句话呢？我告诉你小头儿子的信息，如果你没见过动画片你肯定是不能理解的，但是如果按照下面的文字进行描述呢？&lt;/p&gt;&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;小头儿子是一个高150cm的男孩子，重100斤，出生在2008年，现在13岁，爸爸的名字是小头爸爸，现在在上中学。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文在描述小头儿子，那么是怎样描述的？从身高，体重，性别，家庭关系，年龄等。这些描述的信息可以理解为元数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，现在我告诉你一个数字175，看到这个你除了可以确定他具备一定的度量意义外，还是有很多疑问，无法立即，比如度量的什么，谁度量的等等问题，但是如果按照下面这些信息度量呢？&lt;/p&gt;&lt;section class=&quot;table-container&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;数据类型&lt;/th&gt;&lt;th&gt;数据内容&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;数据值&lt;/td&gt;&lt;td&gt;175&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;单位&lt;/td&gt;&lt;td&gt;cm&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;指标&lt;/td&gt;&lt;td&gt;平均身高&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;统计时间&lt;/td&gt;&lt;td&gt;2020年&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;区域范围&lt;/td&gt;&lt;td&gt;全国&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;人群范围&lt;/td&gt;&lt;td&gt;成年男性&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;范围&lt;/td&gt;&lt;td&gt;80-260&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;数据库类型&lt;/td&gt;&lt;td&gt;Mysql&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;数据库链接&lt;/td&gt;&lt;td&gt;jdbc:mysql://127.0.0.1:3306/info&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;表名&lt;/td&gt;&lt;td&gt;human_stat&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;字段&lt;/td&gt;&lt;td&gt;height_avg&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;创建人&lt;/td&gt;&lt;td&gt;李四&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;创建时间&lt;/td&gt;&lt;td&gt;2020-10-01&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;修改时间&lt;/td&gt;&lt;td&gt;2020-10-01&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;数据权限&lt;/td&gt;&lt;td&gt;公开&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;安全等级&lt;/td&gt;&lt;td&gt;安全&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;质量等级&lt;/td&gt;&lt;td&gt;极高&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样是不是就很清楚了？175 的意思是：2020 年统计的全国成年男性平均身高，该值的合理范围是 80-260cm，数据目前存在 MySQL中，访问连接是 jdbc:mysql://127.0.0.1:3306/info，由国家统计局的李四在 2020 年 10 月 1 日创建，数据目前是公开的，很安全，质量经过多重确认无误的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上表在描述 175 这个数据，用了哪些描述项呢？单位、指标、统计时间、统计范围、合理范围、数据库、表、字段、创建人、创建时间、数据权限、质量等级等等。这些都是在描述 175 这个数据。我们把描述 175 这个数据的其他数据称之为“元数据”。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;/&gt;&lt;span class=&quot;content&quot;&gt;二、元数据类型&lt;/span&gt;&lt;span class=&quot;suffix&quot;/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;元数据可分为技术元数据、业务元数据和管理过程元数据等几类。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;技术元数据
为开发和管理数据仓库的 IT 人员使用，它描述了与数据仓库开发、管理和维护相关的数据，包括数据源信息、数据转换描述、数据仓库模型、数据清洗与更新规则、数据映射和访问权限等；如表结构、文件路径/格式。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;业务元数据
为管理层和业务分析人员服务，从业务角度描述数据，包括商务术语、数据仓库中有什么数据、数据的位置和数据的可用性等，帮助业务人员更好地理解数据仓库中哪些数据是可用的以及如何使用；如责任人、归属的业务、血缘关系。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;管理过程元数据
指描述管理领域相关的概念、关系和规则的数据，主要包括管理流程、人员组织、角色职责等信息；如表每天的行数、大小、更新时间。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对元数据的类型上更容易理解，对上述例子中的元数据类型，进行归类划分：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务元数据&lt;/p&gt;&lt;section class=&quot;table-container&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;数据类型&lt;/th&gt;&lt;th&gt;数据内容&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;数据值&lt;/td&gt;&lt;td&gt;175&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;单位&lt;/td&gt;&lt;td&gt;cm&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;指标&lt;/td&gt;&lt;td&gt;平均身高&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;统计时间&lt;/td&gt;&lt;td&gt;2020年&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;区域范围&lt;/td&gt;&lt;td&gt;全国&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;人群范围&lt;/td&gt;&lt;td&gt;成年男性&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;范围&lt;/td&gt;&lt;td&gt;80-260&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技术元数据&lt;/p&gt;&lt;section class=&quot;table-container&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;数据类型&lt;/th&gt;&lt;th&gt;数据内容&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;数据库类型&lt;/td&gt;&lt;td&gt;Mysql&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;数据库链接&lt;/td&gt;&lt;td&gt;jdbc:mysql://127.0.0.1:3306/info&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;表名&lt;/td&gt;&lt;td&gt;human_stat&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;字段&lt;/td&gt;&lt;td&gt;height_avg&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;管理过程元数据&lt;/p&gt;&lt;section class=&quot;table-container&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;数据类型&lt;/th&gt;&lt;th&gt;数据内容&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;创建人&lt;/td&gt;&lt;td&gt;李四&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;创建时间&lt;/td&gt;&lt;td&gt;2020-10-01&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;修改时间&lt;/td&gt;&lt;td&gt;2020-10-01&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;数据权限&lt;/td&gt;&lt;td&gt;公开&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;安全等级&lt;/td&gt;&lt;td&gt;安全&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;质量等级&lt;/td&gt;&lt;td&gt;极高&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;/&gt;&lt;span class=&quot;content&quot;&gt;三、元数据功能&lt;/span&gt;&lt;span class=&quot;suffix&quot;/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;血缘分析&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“表”是元数据系统的后台逻辑核心，数据仓库是构建在 Hive 之上，而 Hive 的原始数据往往来自于生产系统，也可能会把计算结果导出到外部存储，所以我们认为 Hive 表、mysql 表、hbase 表、BI 报表都是“表”，这些“表”间关系是一个 DAG，也就是血缘关系。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.2509124087591241&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p8gfFXwpDiaVe8ERxjwQhrib5qbU8SFrU6YdJPQxugTib5GJCKrnrgGtCMHhehBeQJ2JMwKNeIjOwwpYE85XbsRPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2192&quot;/&gt;&lt;figcaption&gt;血缘关系案例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了血缘关系，优化可视化展示，可以让用户清楚看到一张表的上下游，更方便地查找表。基于血缘关系可以做很多事情，例如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;结合表的更新时间，还可以找到调度 DAG 的关键路径，协助定位性能瓶颈；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当表出现变更时，可以通知下游责任人，以及自动对下游任务做 SQL 的静态检查；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;辅助生命周期管理，找到没有被使用的表/字段；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;辅助维护字段的一致性，如注释、校验规则复用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;影响分析
向下追溯元数据对象对下游的影响。影响分析可以让您轻松应对变更可能产生的影响，自动识别与其相关的依赖项和潜在的影响还可以跟踪所有对象及其依赖关系，最后我们还提供数据全生命周期的可视化显示。例如，如果您的某一信息系统中准备将“销售额”从包含税费更改为不包括税费，则SE-DWA将自动显示所有使用了“销售金额”字段，以便您可以确定有哪些工作需要完成，并且建议您在更改前完成该工作。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;同步检查
检查源表到目标表的数据结构是否发生变更。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;指标一致性分析
定期分析指标定义是否和实际情况一致。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;实体关联查询
事实表与维度表的代理键自动关联&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;/&gt;&lt;span class=&quot;content&quot;&gt;四、元数据应用&lt;/span&gt;&lt;span class=&quot;suffix&quot;/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ETL自动化管理：使用元数据信息自动生成物理模型，ETL程序脚本，任务依赖关系和调度程序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据质量管理：使用数据质量规则元数据进行数据质量测量。数据质量根据设定的规则帮助您过滤出有问题的数据，并智能分析数据质量缺陷。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据安全管理：的安全性会更进一步，可以限制特定的组成员只可以访问表中特定的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据标准管理：使用元数据信息生成标准的维度模型。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据接口管理：使用元数据信息进行接口统一管理。多种数据源接入，并提供多种插件对接最流行的源系统。应该可以简单方便获取数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;项目文档管理：使用元数据可以自动、方便的生成的健壮全面的项目文档，其以帮助您应对各种对于数据合规性要求。读取元数据模型，并生成pdf格式的描述文件。生成文档您查看每个对象的名称、设置、描述和代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据语义管理：业务用户在自助服务分析中面临的挑战他们不了解数据仓库从而无法正确解释数据，使用元数据可以语义层建模，使用易于业务用户理解的描述来转换数据。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;/&gt;&lt;span class=&quot;content&quot;&gt;五、总结&lt;/span&gt;&lt;span class=&quot;suffix&quot;/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由上可见，元数据（Meta Data），不仅记录数据仓库中模型的定义、各层级间的映射关系、监控数据仓库的数据状态及 ETL 的任务运行状态。元数据把数据仓库系统中各个松散的组件联系起来，组成了一个整体数据仓库解决方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构建数据仓库的主要步骤之一是 ETL。此时元数据将发挥重要的作用，它定义了源数据系统到数据仓库的映射、数据转换的规则、数据仓库的逻辑结构、数据更新的规则、数据导入历史记录以及装载周期等相关内容。数据抽取和转换的专家以及数据仓库管理员正是通过元数据高效地构建数据仓库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户在使用数据仓库时，通过元数据访问数据，明确数据项的含义以及定制报表。数据仓库的规模及其复杂性离不开正确的元数据管理，包括增加或移除外部数据源，改变数据清洗方法，控制出错的查询以及安排备份等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;/&gt;&lt;span class=&quot;content&quot;&gt;数据仓库上下游以及上下游约定&lt;/span&gt;&lt;span class=&quot;suffix&quot;/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于数据仓库的特性和定位，数仓强依赖于上游的业务系统，下游的报表、可视化平台又强依赖于数仓。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;/&gt;&lt;span class=&quot;content&quot;&gt;一、数仓的上游约定&lt;/span&gt;&lt;span class=&quot;suffix&quot;/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库最重要的数据源主要来源于业务系统，故而数据需要不断的从业务系统导入数仓中。由此上游业务系统的变动，将会非常直接的影响下游。所以制定严谨的上游约定是极其重要的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见约定形式如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;表结构变更&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表字段的枚举值定义变化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;create_time和update_time，业务数据与数仓系统的数据同步，对新增和修改的触发tongue，一般依托于这两个字段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;is_delete 和 is_valid的定义规约&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;/&gt;&lt;span class=&quot;content&quot;&gt;二、数仓的下游约定&lt;/span&gt;&lt;span class=&quot;suffix&quot;/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对数仓来说，下游系统一般为接口，报表、可视化平台等使用。所以针对数仓平台的优化改动，都需要及时沟通同步。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3310344827586207&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p8gfFXwpDiaVe8ERxjwQhrib5qbU8SFrU6NwvHUuYOcVicibf4zMDr0icwQkFMqeicicA8vE2hAniaDdRNuJ0sMa045ibCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1885&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3eba941bcd920656cf65d307dbc040e6</guid>
<title>拯救祭天的程序员：事件溯源模式</title>
<link>https://toutiao.io/k/jj02es0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;一、事前&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你相信吗？曾经有一段日子，我几乎没接到过合格的产品需求。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;开局几句话，技术全靠猜。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总是以为简单的需求&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;曾经，我从产品那里接到过这么一个需求:&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;对系统的用户进行分级，不同级别的用户有不同的福利。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;依然如常，无图无文档，只是这么一句话。我知道，需求一句话，分析五日功嘛。为了项目能持续发展，我只好自己分析自己搞了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从业务上看，目前的&lt;strong&gt;用户&lt;/strong&gt;对象尚无等级一说，我们先为&lt;strong&gt;用户&lt;/strong&gt;对象加上个级别属性。又因为不同的用户等级，可享受到不同的福利。比如：达到 3 级的用户，可以享受购物 9.5 折优惠，物流费用全免，客服快速回复等。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，我做出设计如下:&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，我把每个等级用户该享受的福利放到一个列表里。这个用来供前端展示用户当前可享受到的福利。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2972972972972973&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KS04A7libuL1MGyqrwPJkzkFlicibQK7rUiaEjPUl0ckRDbM2IHQftfVcHTHBOCTujmLSSobPSDymYpbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;925&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后，在每一项福利中，我去设定一个可享受此福利的最低级别。只有用户的级别超过这个最低级别的时候，才可以享受到此项福利。比如，支付优惠 9.5 折，我只需要在支付服务中打包个支付权利 9.5 折这种东西，然后设定个最低级别即可。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.47877758913412566&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KS04A7libuL1MGyqrwPJkzkFgJF3E5zhmPK5e7UBFrCBqYrDkxyznh9ZGqaP8lAUIxNHZ2QmsNIoqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1178&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这事儿看着是如此简单，所以，实现方案也没什么特殊的。当用户每次升级的时候，我只需要更新用户级别即可。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0036452004860268&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KS04A7libuL1MGyqrwPJkzkFtKFoueuf9pvI7gdCs80GDnUyQkvbibsaU0JVu9AGWCXCP11ZoStHruw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;823&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个时候，需求比较初级，要求也不高。在满足升级条件后，需要用户主动点击升级。同时，再填写一些相关信息，申请一些专属的福利就可以了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好，设计，开发，上线一条龙走起来！&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;需求变成坑&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;过了一阵子，我们的运营们勇于探索，勤于开拓，去搞了一堆资源互换回来。当我听说此事时，心里已经预感不妙了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;果然，没两天，我们的产品高高兴兴地通知我，由于兄弟团队愿意和我们的项目进行合作，因此用户的福利将得到极大的丰富，那些更加丰富的福利全都由兄弟团队提供。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，请我简单的搞一下，对接上这些合作方，进一步提升我们系统的粘性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如常，依然没有任何文档，我依然只能自己分析。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在，根据我丰富的被折腾经验，我知道开始有坑了。当我对接合作方接口的时候，他们都需要我传入一些特定的用户标识过去，可以让双方共享用户。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;需求开始复杂了，不过庆幸的是，我改改代码就可以了，还好还好，我松了口气……&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好，设计，开发，上线一条龙走起！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可惜，我们的业务就像一群群的蜜蜂一样，你永远不知道他们会给你带来什么样的花朵。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;没过过久，产品告诉我，几个兄弟团队想和我们一起搞一次超级大活动。我觉得天黑了……&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;没文档没有产品原型，依然就是微信中的来来往往。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我知道此时，我得往深里想想了。需求是可以肆意妄为的，而我能阻止业务需求的肆意妄为吗？不能，所以，我要考虑一整套弹性的方案，能应对这些千变万化，又漫天飞舞的需求。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;二、初见&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;隐患的伊始&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;来看看这个见鬼的大活动吧。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，按照设计，如果合作方们想要和我们一起大联欢，那么我们就要把用户升级的信息告诉他们。这样，合作方们才能进行验证，并提供用户级别对应的福利。所以，当我们的用户升级的时候，我需要每次都把这件事同步给我们的合作方。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;又因为我们是和多个兄弟团队合作，比如，和物流团队合作，和支付团队合作。在这种情况下，不同合作方的互动逻辑是分布在不同的服务中的。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6987551867219917&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KS04A7libuL1MGyqrwPJkzkFy2peeL6N54ny9hI3y0MkKVQjCtWZic7qORE96uXxCHLArdmTICzibxzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1205&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此时，我有两种方案可供选择:&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 在用户服务里，用户升级时，立即主动的通过接口去调用分布在不同的服务上的相关逻辑，把用户升级这件事同步到合作方那里。但是，这个方案有个很大的问题——因为我们需要调用其他服务的接口，这就造成服务和服务之间耦合起来了。将来有点小改动，可能都需要我们改代码。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6773378264532435&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KS04A7libuL1MGyqrwPJkzkFtnaxKqj4zibTW8u94hHMOjFZmcl5ye9m6RvRj8kff7Ytnz5iaCWhtCKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1187&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 在微服务里，其实是很推崇使用消息队列的。当用户升级时，我只需发送消息到消息队列中，然后让相关的服务去订阅这个消息即可。这个方案，使用消息队列可以解耦服务之间的关系。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6355421686746988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KS04A7libuL1MGyqrwPJkzkFbiaHs6qbhW97Fpib0veRjNyXRWEibKq03H6k0BNu7cOrE4fpkyud4XnZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1328&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为微服务本身的目的就是解耦和灵活，并且第二个方案和我们架构是适配的，因此我选择了第二个方案。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在第二个方案中，正因为消息可以把服务之间进行解耦，所以，当用户升级的时候，我只需要操作用户服务数据库中的用户表进行升级，并把升级这事儿包裹成消息扔到消息队列中即可。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我甚至可以把&lt;strong&gt;更新用户表&lt;/strong&gt;和&lt;strong&gt;发送升级消息到队列&lt;/strong&gt;包装成一个事务。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.39689119170984455&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KS04A7libuL1MGyqrwPJkzkFgEjJ3S0ibmLa1d6jUliacDy52QuZibeJdloyRqyvqnqWO5B1o14Pp965w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;965&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好，设计，开发，上线一条龙走起！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这就是能应对后续不断变化的技术方案吗？事实证明，并不能，因为，这套方案即将会被变化的需求给彻底击垮。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;问题的大爆发&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;斗转星移，时空变幻。需求如滚滚的流水般涌来，而我们的技术方案如同一套无论如何增强也不够健壮的大坝。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;经过几度需求的变换，此时用户升级已经变成了满足条件后自动升级；我们合作的兄弟团队也日益增多；我们的服务也越拆越多……在这些汩汩涌出的变化中，问题已经如同潜伏在水底的鳄鱼，即将爬上岸来猎取几个程序员来祭天了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;问题的迹象一开始出现在用户升级的数据上。那时，我们接连被运营们提的问题所困扰。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有些运营人员发现，某些用户升级过快了，用户的升级速度已经远远超出了当初设计时预估的速度了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而这种过快的升级不仅使得运营人员无法及时构思和设计后续的运营活动，还使得我们的运营成本快速的上涨，并因此给公司经营带来了一定的损失。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然，如同以往一样，业务是从来不会出错的，出错的永远是技术。这不，出问题的原因都给我们安排的明明白白了：&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;很可能是程序出了 bug，因为出了某些技术性的故障，导致用户升级的时候没有一级级的升上去，出现了跳跃性的升级…………&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在追踪问题的时候，我们猛然发现了这个技术方案的一个缺陷：由于根本没有预料到用户升级的重要性，我们的很多用户升级相关的日志并未开启，并且没有存储任何用户升级的历史记录。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这瞬间成了一笔糊涂账，我无 fuck 可说。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;雪上加霜的是，又有用户们投诉，他们总是在某些时候会出现一些卡顿。我们再一查，发现是用户升级导致的数据库问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最早的设计是用户升级直接更新数据库表，但是大意了：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当用户数量出现大涨的时候。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;新用户初期升级难度小，所以升级很频繁。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;忽略了这两个因素，这就造成了我们的数据库有点承受不住这种频繁的更新。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而且，在查这些问题的时候，以前有些用户投诉的问题也随之被挖了出来。比如，用户升级后有些福利却没有给他们，悲催的是这些痕迹也没有被完整的留下来……&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;糊涂账加糊涂账成了笔烂账。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;啊，我要被祭天了吗？&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;跺脚后智商重新占领高地&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在来看看我们要面临的问题吧。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先出场的是用户升级没法追根溯源的问题。因为我们每次用户升级，需要通知相关的服务，然后还得保证每个相关的服务处理成功了，到此时，用户升级才算真正的成功。所以，为了能还技术们一个清白，能别搞得成为烂账，就必须把用户的每次升级给记录下来，并且还得把每个相关服务对升级事件的处理也记录在案。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下一个要解决的小兄弟是数据库更新的问题。这个数据库更新该怎么办？缓存后同步？那缓存本身的更新出现了问题怎么办？验证呗！怎么验证？每次升级时候去和历史记录核对一遍吗？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这时候，我的脑袋里开始进入了混沌状态。不知道该怎么办了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有点着急啊，怎么办呢？只好去看看网上有没有什么方案可以提供一些思路。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最终，这就促成了我对事件溯源(Event Sourcing)模式的初见。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当我看到事件溯源的时候，我脚一跺，我感觉我的智商回来了。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;事件溯源拯救快被祭天的我&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，咱们看看事件溯源是什么样的。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.39634146341463417&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KS04A7libuL1MGyqrwPJkzkFh4w2DT7tstQJcU0mue9RVxzdWb96fTm6SsIbHg2r9xtOQSkxeOm8icw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以咱们现在搞得用户升级为例，说一下事件溯源模式：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;用户升级时，我们只需要把用户升级这件事通过 Event Store 这个中间件传给支付服务、物流服务等这些相关的服务。然后，支付服务、物流服务之类的处理完用户升级通知给他们的事件后，会也创建一个事件对象，放到 Event Store 里。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里的 Event Store 其实主要是用来做两件事:&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么，事件溯源是怎么来搞定我面临的这些问题的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，如果我们要追根溯源，就需要把用户升级和用户升级后相关服务做得处理都要存起来，形成一个完整的业务链条。有了这个链条，才能被称为追根溯源。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;事件溯源模式正好告诉大家，有事儿就要存起来！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其次，当我们用户升级的时候把事件存储下来之后，我们还需要实时去更新级别吗？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们来分析一下:用户升级的真正目的是什么？从业务角度来说，其实就是通过提供各种福利去提升用户的活跃度。那么，这件事需要实时吗？似乎不必须，因为用户几乎不太可能升级后马上去使用对应的福利。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好，如果可以不实时，那么用户升级这件事儿就能避免实时更新数据库了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果我们在开始把历史事件存储下来了之后，其实可以在凌晨的时候去定时根据用户级别发生的事件，去把用户的级别升级到正确的级别。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以可以看到了，事件溯源在这事儿上把我的两个问题全解决了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这就是我和事件溯源模式的初见。而在今后的技术生涯中，它将会经常陪伴着我。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;三、认识&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;真正认识下事件溯源模式吧&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;事件溯源总结下来其实只有如下二个核心特点:&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 把触发业务数据变化的原因包装成了事件对象——如果把这件事儿抽象的看待一下，就是我们可以把业务中任何需要注意的情况发生变化时，都可以包装成事件。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 这些包装成事件的业务数据会按照事件发生的顺序，被持久化存储到专门的地方——需要专门说一下这个事件按照顺序存放的问题，在事件溯源模式中，按照事件发生的顺序持久化存储是非常重要的一件事。如果一个模式中的事件没有严格按照事件顺序进行持久化存储，其实很难说这个模式会是一个合格的事件溯源模式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以事件溯源模式就做了两件事：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;定义什么样的业务逻辑可以被定义为事件；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;把定义好的事件在发生后给按顺序记录下来。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;事件溯源常伴吾身&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;认识到了事件溯源的核心特点后，我在后面的开发生涯里反复的使用了这个模式去帮我解决不同业务的特定场景的问题。比如订单的状态更新，再比如秒杀活动的性能问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在不断地使用事件溯源过程中，我总结出了需要使用事件溯源的一些场景。当遇到类似的场景时，我总是会第一时间尝试用事件溯源模式来解决问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这些场景是:&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;想知道关键数据被更改时，意图、原因或者目的时；&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;更新数据确实性能出现了问题，一时之间也没办法通过硬件升级或者大规模集群去解决这个问题；&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;还原某些现场，或者想通过一些数据重复的还原线上环境是非常重要的事情；&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而事实证明，在这些场景中使用事件溯源也确实不负我望，并且还带来了很多额外的好处:&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 由于事件可以按照顺序存储，所以可以搞成追加方式去持久化，而这种追加操作来持久化事件的方式可以放到前台，对用户体验或者性能要求很高的地方。这样不会引发前台卡顿。同时呢，可以让事件能跟水流一样，被引入到后台任务中慢慢处理。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 事件本身是一种场景记录，所以，利用这些记录的时候，可以根据自身情况，在任何合适的时间，合适的环境，去根据事件去实施或者复现某些业务状态。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 事件的存储本身可以被当成一种审计日志，只要记录的信息够全，事件溯源本身就会天然的变成可靠安全的审计数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. 事件溯源本身可以和各种事件驱动的系统相融合，非常适合扩展和对接各类靠事件驱动的应用和系统。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5. 事件溯源不会给已经非常复杂的业务对象增加复杂度。比如，一个订单对象，根据订单对象设计订单表的时候，可能还得搞个备注字段用来存储一些更新时的说明；可能还得搞个最近更新时间记录下最近更新发生在什么时候；甚至可能由于本身业务状态的复杂，还得特意拆解成几个不同的状态字段……&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总之，随着我对事件溯源认识的逐渐加深，我觉得自身已经开始有了微服务专家的气质。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;四、不满&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然，太阳底下没啥新鲜事儿。任何新东西的引入总会带来一些不足，同时呢，随着使用事件溯源模式的次数增多，我也愈发认识到了这个模式的不足。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 要存储的事件数据太多了，导致查询得引入另一个查询职责分离模式（CQRS），才能解决大部分的查询问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 使用事件溯源的时候由于事件发生的顺序存储非常重要，所以，使用多线程，多进程，集群的时候，就必须要严格保证事件顺序存储的正确性，一般来说，得给事件对象搞个时间戳不说，可能还得引入全局唯一标识符产生器去产生事件 ID。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 由于事件本身是个业务对象了，所以，你知道了，它自身一定会进化的。所以，还得考虑老版本新版本的共存问题，这种一般至少得给事件结构弄个版本字段去标识事件对象的版本。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. 事件存下来了，而且大部分时候都是附加形式的顺序存储。这就导致查询事件的时候没办法，只能按照事件标识符和事件的时间之类的做查询，而这样的话，其实就是查询出来了一个事件流。如果要场景重现和分析业务对象状态的时候，就非得把这个事件流给整个重新处理一遍。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5. 事件溯源这事儿其实就是人为的松绑了业务的一致性要求。但是，业务需要的一致性问题依然还是需要另外的处理。比如，我们搞了电商网站，同时呢，又通过事件溯源模式去落地了库存商品数量更新的业务，又恰巧把库存的存货减少的各种原因给设计成了不同的事件，那么，当库存因为非客户下单减少发生时，又恰好客户在下单，这时候，就需要单独的处理他们之间的冲突，去保证状态的一致性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6. 事件这东西本身可能因为业务原因需要各种传递，而在这期间，不管使用什么方式去传播事件，没人会给你保证事件不会重复传播。这时候，就得考虑处理事件的幂等性。这也是事件溯源带来的麻烦。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;五、结尾&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;事件溯源模式虽然解决了我的很多问题，但是同时又因为引入这个模式，我又增加了很大的工作量。真是金无足赤啊。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;也许这世上根本不存在什么溯源模式，有的只是防止背锅的无奈罢了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你好，我是四猿外。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一家上市公司的技术总监，管理的技术团队一百余人。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我从一名非计算机专业的毕业生，转行到程序员，一路打拼，一路成长。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我会通过公众号，&lt;br/&gt;把自己的成长故事写成文章，&lt;br/&gt;把枯燥的技术文章写成故事。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我建了一个读者交流群，里面大部分是程序员，一起聊技术、工作、八卦。欢迎加我微信，拉你入群。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>