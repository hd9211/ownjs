<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0a84402385f13817982978ace28e0e6b</guid>
<title>利用 Redsocks 解决透明代理的远程抓包问题</title>
<link>https://toutiao.io/k/xdc60me</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;toc-content post no-image&quot;&gt;
      &lt;h2 id=&quot;%E8%83%8C%E6%99%AF&quot;&gt;背景&lt;/h2&gt;&lt;p&gt;最近在做一些远程设备的抓包能力建设。具体来说是设备（基于 Docker 的 Redroid 云手机）在服务器上，抓包工具在本地（ Mitmproxy , Charles, Fiddler 等类似工具），希望通过某种方法将远程设备上的流量打到本地的抓包工具上，并且流量通过本地的 IP 出到公网。&lt;/p&gt;&lt;p&gt;这样做的目的主要有两个：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;可以做到抓包工具和待抓包设备的分离。既能利用上强大的第三方抓包工具，又无需本地部署待抓包的设备。毕竟如果在远程服务器上部署抓包工具，操作起来就不那么方便，甚至可能还需要自行开发管控界面；如果在本地部署待抓包设备，很可能会遇到例如芯片架构、操作系统、环境依赖、系统资源消耗等问题。&lt;/li&gt;&lt;li&gt;可以方便进行 IP 出口的调整。在调试一些不可言说的功能时，服务器上部署的设备很可能是走一些代理 IP 池，有时候这些 IP 池本身可能有点问题，导致远程设备被封。这时候如果我们能够将设备的流量导到本地的正常 IP 出公网，可能会更方便我们验证是 IP 问题还是其他的设备问题。&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;%E8%AE%A1%E5%88%92&quot;&gt;计划&lt;/h2&gt;&lt;p&gt;为了打通远程设备本地抓包的这套链路，我们需要考虑如下技术点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;远程设备需要能够安装本地抓包工具的证书。&lt;/li&gt;&lt;li&gt;远程设备的流量需要通过某种内网穿透能力打到本地的代理工具上。&lt;/li&gt;&lt;li&gt;远程设备的流量需要保证不遗漏地进行转发。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;由于我们的远程设备是有 root 权限的云手机，因此证书安装并不难。只要将本地的证书通过 openssl 命令转换成指定格式的证书文件，传到服务器上，在云手机启动时 bind 到 &lt;code&gt;/system/etc/security/cacerts/&lt;/code&gt;  目录下即可。&lt;/p&gt;&lt;p&gt;同理，由于远程设备是云手机，通过暴露 adb 的 tcpip 端口，我们可以用本地的 adb 客户端进行连接，再通过 adb reverse 就可以构建一个云手机访问本机代理端口的信道。&lt;/p&gt;&lt;p&gt;而要保证云手机的流量（这里特指 HTTP/HTTPS 流量）不遗漏的进行转发，我们就不能采用配置全局正向代理的方法（ &lt;code&gt;adb shell settings put global http_proxy xxxx&lt;/code&gt;  ），因为个别 app 可以配置强制 NO_PROXY 不走系统代理。一个简单的方法是通过云手机自带的 iptables 工具进行转发，将云手机中所有目的端口为 80/443 的流量转发到 adb reverse 命令转发过来的、映射到本地抓包工具的代理端口即可。&lt;/p&gt;&lt;p&gt;理想的架构图如下：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2022/05/---.excalidraw.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot; srcset=&quot;https://blog.mythsman.com/content/images/size/w600/2022/05/---.excalidraw.png 600w, https://blog.mythsman.com/content/images/size/w1000/2022/05/---.excalidraw.png 1000w, https://blog.mythsman.com/content/images/2022/05/---.excalidraw.png 1079w&quot; sizes=&quot;(min-width: 720px) 720px&quot;/&gt;&lt;/figure&gt;&lt;h2 id=&quot;%E9%97%AE%E9%A2%98&quot;&gt;问题&lt;/h2&gt;&lt;p&gt;架构图谁都会画，但是真正实操起来才发现有一堆坑。这套流程对 HTTP 请求的确是有用的，透明代理的工具无论是使用 Charles 还是 Mitmproxy 等中间人代理工具都能正常抓到包。但是对与 HTTPS 的流量则都出现了问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Charles 会报 &lt;code&gt;invalid first line in request&lt;/code&gt; 的错。&lt;/li&gt;&lt;li&gt;Mitmproxy 会报 &lt;code&gt;Could not resolve original destination&lt;/code&gt; 的错。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;当然，个别代理工具可能不支持解 HTTPS ，出现问题可以理解。但是各种代理工具都不能抓，那显然应当是流程上出了问题。经过实验我们发现，使用正向代理或非 HTTPS 的透明代理再加上端口转发都是能通的，唯一不能通的是 HTTPS 的透明代理模式。那么我们就需要先辨析一下这些模式的区别。&lt;/p&gt;&lt;h2 id=&quot;%E5%88%86%E6%9E%90&quot;&gt;分析&lt;/h2&gt;&lt;h3 id=&quot;%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86&quot;&gt;正向代理&lt;/h3&gt;&lt;p&gt;正向代理是由客户端主动发起，主动将流量打给一个代理服务器，由代理服务器代替请求的过程。下图主要展示正向代理过程中 IP 报文的变化：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2022/05/-------.excalidraw.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot; srcset=&quot;https://blog.mythsman.com/content/images/size/w600/2022/05/-------.excalidraw.png 600w, https://blog.mythsman.com/content/images/size/w1000/2022/05/-------.excalidraw.png 1000w, https://blog.mythsman.com/content/images/2022/05/-------.excalidraw.png 1265w&quot; sizes=&quot;(min-width: 720px) 720px&quot;/&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;Alice 代表发起请求的客户端&lt;/li&gt;&lt;li&gt;Flank 代表代理服务器（Forward Proxy）&lt;/li&gt;&lt;li&gt;Bob 代表客户端需要请求到的服务器&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86&quot;&gt;透明代理&lt;/h3&gt;&lt;p&gt;透明代理是客户端本身无感知的，由路由转发工具强行进行流量转发（Linux 下可以用 iptables ，Windows 下可以用 netsh ，Mac 下可以用 pfctl）。下图主要展示透明代理过程中 IP 报文的变化：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2022/05/------.excalidraw.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot; srcset=&quot;https://blog.mythsman.com/content/images/size/w600/2022/05/------.excalidraw.png 600w, https://blog.mythsman.com/content/images/size/w1000/2022/05/------.excalidraw.png 1000w, https://blog.mythsman.com/content/images/size/w1600/2022/05/------.excalidraw.png 1600w, https://blog.mythsman.com/content/images/2022/05/------.excalidraw.png 2266w&quot; sizes=&quot;(min-width: 720px) 720px&quot;/&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;Alice 代表发起请求的客户端&lt;/li&gt;&lt;li&gt;Ivan 代表转发流量的路由工具（Iptables之类的工具）&lt;/li&gt;&lt;li&gt;Tom 代表透明代理服务器（Transparent Proxy）&lt;/li&gt;&lt;li&gt;Bob 代表客户端需要请求到的服务器&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在透明代理模式下，路由工具会非常暴力地将客户端发来的包的目的地址直接改为透明代理服务器，这会导致当数据包到了透明代理服务器中时，代理服务器是无法直接获取客户端真正想要到达的服务器地址。而正向代理服务器则不同，客户端会明确告知代理服务器他想访问谁。&lt;/p&gt;&lt;p&gt;那么透明代理服务器要如何在报文中获得真实的目的地址呢？这时候就需要分情况讨论了。&lt;/p&gt;&lt;h4 id=&quot;http&quot;&gt;HTTP&lt;/h4&gt;&lt;p&gt;我们知道 HTTP 报文是纯明文，就像一个没有封口的信封。只要打开来看就会发现，HTTP 请求报文会在 Header 中带上一个 Host 头表明当前的信期望到达的地方。透明代理服务器可以非常方便地解析到这个信息，从而知道报文需要被发送到的目的地址（Bob）。&lt;/p&gt;&lt;h4 id=&quot;https&quot;&gt;HTTPS&lt;/h4&gt;&lt;p&gt;HTTPS 这里就比较尴尬了。我们知道 HTTPS 在第四层有一个 TLS 加密层，如果想和 HTTP 一样从 Header 中获取 Host 头的话，则需要先进行 TLS 解密；但是，如果想进行 TLS 解密，则必须和实际的服务器进行 TLS 握手；可是你都不知道实际的服务器在哪，如果握手呢？这竟然变成了一个鸡生蛋还是蛋生鸡的问题。&lt;/p&gt;&lt;p&gt;那么问题最终会怎么解决呢？目光还得回到路由工具。&lt;/p&gt;&lt;p&gt;既然报文是你路由工具传给透明代理的，那显然路由工具这边是记录了报文原先实际需要访问的目的地址的，我直接请求你不就好了么？在 Linux 下，我们有一个用户工具 conntrack 可以展示当前网络连接的链路追踪信息：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sudo conntrack -L
tcp      6 60 TIME_WAIT src=192.168.32.1 dst=192.168.32.3 sport=40298 dport=8080 src=192.168.32.3 dst=192.168.32.1 sport=8080 dport=40298 [ASSURED] mark=0 use=1
tcp      6 56 TIME_WAIT src=192.168.32.1 dst=192.168.32.7 sport=54398 dport=2368 src=192.168.32.7 dst=192.168.32.1 sport=2368 dport=54398 [ASSURED] mark=0 use=1
tcp      6 60 TIME_WAIT src=192.168.32.5 dst=172.17.0.1 sport=52992 dport=5001 src=172.17.0.1 dst=192.168.32.5 sport=5001 dport=52992 [ASSURED] mark=0 use=1
tcp      6 79 TIME_WAIT src=10.0.0.4 dst=168.63.129.16 sport=39414 dport=80 src=168.63.129.16 dst=10.0.0.4 sport=80 dport=39414 [ASSURED] mark=0 use=1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而透明代理程序则可以通过 getsockopt 等方法直接向内核查询 socket 的链路信息：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;static int getdestaddr(int fd, struct sockaddr_storage *destaddr)
{
    socklen_t socklen = sizeof(*destaddr);
    int error         = 0;

    error = getsockopt(fd, SOL_IPV6, IP6T_SO_ORIGINAL_DST, destaddr, &amp;amp;socklen);
    if (error) { // Didn&#x27;t find a proper way to detect IP version.
        error = getsockopt(fd, SOL_IP, SO_ORIGINAL_DST, destaddr, &amp;amp;socklen);
        if (error) {
            return -1;
        }
    }
    return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样一来，透明代理服务就能在 TLS 握手前就能拿到真实的目的 IP 了。&lt;/p&gt;&lt;p&gt;然而有了 IP 就够了么？并不是。路由工具中我们只能拿到目的 IP ，但是并没有域名！现代服务端的网关层基本都需要通过域名来进行转发。如何解决这个问题呢？这就引入了 SNI （&lt;strong&gt;Server Name Indication&lt;/strong&gt;）头。在 TLS 握手阶段，客户端会在握手报文里额外增加 SNI 信息（这个已经是TLS标准了，但是有些客户端可能没有加），这样服务端或者透明代理服务器就能获取到实际的域名了。&lt;/p&gt;&lt;p&gt;最后我们再来看下 Mitmproxy 文档中提供的透明代理的流程图：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2022/05/image-1.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;&lt;h2 id=&quot;%E8%A7%A3%E5%86%B3&quot;&gt;解决&lt;/h2&gt;&lt;p&gt;了解了代理服务器的工作细节，我们再来尝试回答下开头的问题。为什么把远端的 HTTPS 流量通过路由工具+端口映射转发到本地的透明代理服务器中会报错呢？&lt;/p&gt;&lt;p&gt;答案已经很明显了，那就是&lt;strong&gt;本地的透明代理工具无法查询到远端服务器中的路由链路信息，导致无法获取真实的目的地址&lt;/strong&gt;。（也就是为什么 mitmproxy 会报 &lt;code&gt;Could not resolve original destination&lt;/code&gt;的原因。&lt;/p&gt;&lt;p&gt;解决这个问题的思路也很清晰，&lt;strong&gt;既然希望走透明代理的流量无法跨主机，那我们就将透明代理服务部署在本机，然后转换成正向代理出去即可&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;具体操作中，由于 mitmproxy 默认不支持在透明代理模式下再配置一个上游正向代理，因此我们可以选择简单魔改一下代码，在透明代理模式下的出口处请求另一个正向代理。&lt;/p&gt;&lt;p&gt;如果懒得改代码，我找到了一个 &lt;a href=&quot;https://github.com/darkk/redsocks&quot;&gt;Redsocks&lt;/a&gt; 工具。这个工具可以直接作为透明代理服务器，并将流量转发给一个上游的正向代理。Ubuntu 下可以直接用 apt 安装，配置一下 /etc/redsocks.conf 就能直接使用。&lt;/p&gt;&lt;p&gt;如此，架构图修改成下图即可：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2022/05/---2.excalidraw.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot; srcset=&quot;https://blog.mythsman.com/content/images/size/w600/2022/05/---2.excalidraw.png 600w, https://blog.mythsman.com/content/images/size/w1000/2022/05/---2.excalidraw.png 1000w, https://blog.mythsman.com/content/images/2022/05/---2.excalidraw.png 1237w&quot; sizes=&quot;(min-width: 720px) 720px&quot;/&gt;&lt;/figure&gt;&lt;h2 id=&quot;%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99&quot;&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.mitmproxy.org/stable/concepts-howmitmproxyworks/#transparent-https&quot;&gt;Mitmproxy Docs - Transparent HTTPS&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://yemablog.com/posts/transparent-proxy&quot;&gt;如何使用透明代理抓 HTTPS&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.ichenfu.com/2019/04/09/istio-inbond-interception-and-linux-transparent-proxy/&quot;&gt;Istio的流量劫持和Linux下透明代理实现&lt;/a&gt;&lt;/p&gt;
    &lt;/section&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4f771bf62e553be1c95997fd8746bd7c</guid>
<title>JVM 类加载器与双亲委派模型</title>
<link>https://toutiao.io/k/f1pa9jb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 类加载器&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，虚拟机在加载类的过程中需要使用类加载器进行加载，而在 Java 中，类加载器有很多，那么当 JVM 想要加载一个 &lt;code&gt;.class&lt;/code&gt; 文件的时候，到底应该由哪个类加载器加载呢？这时候就需要双亲委派机制来告诉 JVM 使用哪个类加载器加载。在讲解什么是双亲委派机制之前，我们先看一下有哪些加载器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 Java 虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器 Bootstrap ClassLoader，这个类加载器使用 C++ 语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。从 Java 开发人员的角度来看，类加载器还可以划分得更细致一些，分为用户级别和系统级别类加载器。用户级别的类加载器我们统一称为自定义类加载器，而系统级别的类加载器有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;启动类加载器：Bootstrap ClassLoader&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扩展类加载器：Extention ClassLoader&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用程序类加载器：Application ClassLoader&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 启动类加载器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动类加载器 Bootstrap ClassLoader 使用 C/C++ 语言实现，负责将存放在 &lt;code&gt;&amp;lt;JAVA_HOME&amp;gt;\lib&lt;/code&gt; 目录中的，或者被 &lt;code&gt;-Xbootclasspath&lt;/code&gt; 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用 null 代替即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过如下代码查看启动类加载器可以加载哪些路径的 jar：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String bootStrapPath = System.getProperty(&lt;span&gt;&quot;sun.boot.class.path&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(&lt;span&gt;&quot;启动类加载器加载的路径: &quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (String paths : bootStrapPath.split(&lt;span&gt;&quot;;&quot;&lt;/span&gt;)){&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (String path : paths.split(&lt;span&gt;&quot;:&quot;&lt;/span&gt;)) {&lt;br/&gt;        System.out.println(path);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 扩展类加载器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩展类加载器 Extension ClassLoader 由 Java 语言编写，并由 &lt;code&gt;sun.misc.Launcher$ExtClassLoader&lt;/code&gt; 实现，父类加载器为启动类加载器。负责加载 &lt;code&gt;&amp;lt;JAVA_HOME&amp;gt;\lib\ext&lt;/code&gt; 目录中的，或者被 &lt;code&gt;java.ext.dirs&lt;/code&gt; 系统变量所指定的路径中的所有类库。开发者可以直接使用扩展类加载器，如果用户创建的 JAR 放在扩展目录下，也会自动由扩展类加载器加载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过如下代码查看扩展类加载器可以加载哪些路径的 jar：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String extClassLoaderPath = System.getProperty(&lt;span&gt;&quot;java.ext.dirs&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(&lt;span&gt;&quot;拓展类加载器加载的路径: &quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (String paths : extClassLoaderPath.split(&lt;span&gt;&quot;;&quot;&lt;/span&gt;)){&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (String path : paths.split(&lt;span&gt;&quot;:&quot;&lt;/span&gt;)) {&lt;br/&gt;        System.out.println(path);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3 应用程序类加载器&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用程序类加载器 Application ClassLoader 由 Java 语言编写，并由 &lt;code&gt;sun.misc.Launcher$App-ClassLoader&lt;/code&gt; 实现，父类加载器为扩展类加载器。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径 ClassPath 或系统属性 &lt;code&gt;java.class.path&lt;/code&gt; 指定路径下的类库。开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过如下代码查看应用程序类加载器可以加载哪些路径的 jar：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String appClassLoaderPath = System.getProperty(&lt;span&gt;&quot;java.class.path&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (String paths : appClassLoaderPath.split(&lt;span&gt;&quot;;&quot;&lt;/span&gt;)){&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;应用程序类加载器加载的路径: &quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (String path : paths.split(&lt;span&gt;&quot;:&quot;&lt;/span&gt;)) {&lt;br/&gt;        System.out.println(path);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.4 自定义类加载器&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Java 的日常应用程序开发中，类的加载几乎是由上述 3 种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。那么什么场景下需要自定义类加载器呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发人员可以通过继承抽象类 java.lang.ClassLoader 类的方式，实现自己的类加载器，以满足一些特殊的需求。在 JDK 1.2 之前，在自定义类加载器时，总会去继承 ClassLoader 类并重写 loadClass() 方法，从而实现自定义的类加载类，但是在 JDK 1.2 之后已不再建议用户去覆盖 loadClass() 方法，而是建议把自定义的类加载逻辑写在 findclass() 方法中。下面我们来实现一个自定义类加载器并演示如何使用。第一步自定义一个实体类 Car.java：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 测试对象 Car&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Car&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Car&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;welcome you&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;this is a car&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步自定义一个类加载器，我们定义的 CustomClassLoader 继承自 java.lang.ClassLoader，且只实现 findClass 方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 自定义加载器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CustomClassLoader&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ClassLoader&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String path;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;CustomClassLoader&lt;/span&gt;&lt;span&gt;(String path)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.path = path;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt; findClass(String name) &lt;span&gt;throws&lt;/span&gt; ClassNotFoundException {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;CustomClassLoader: &quot;&lt;/span&gt; + name);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            String fileName = path + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + name.substring(name.lastIndexOf(&lt;span&gt;&quot;.&quot;&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;) + &lt;span&gt;&quot;.class&quot;&lt;/span&gt;;&lt;br/&gt;            FileInputStream inputStream = &lt;span&gt;new&lt;/span&gt; FileInputStream(fileName);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (inputStream == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.findClass(name);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[inputStream.available()];&lt;br/&gt;            inputStream.read(bytes);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; defineClass(name, bytes, &lt;span&gt;0&lt;/span&gt;, bytes.length);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException ex) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ClassNotFoundException(name, ex);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三步演示自定义类加载器如何使用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CustomClassLoader myClassLoader = &lt;span&gt;new&lt;/span&gt; CustomClassLoader(&lt;span&gt;&quot;/opt/data&quot;&lt;/span&gt;);&lt;br/&gt;Class&amp;lt;?&amp;gt; myClass = myClassLoader.loadClass(&lt;span&gt;&quot;com.common.example.bean.Car&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 创建对象实例&lt;/span&gt;&lt;br/&gt;Object o = myClass.newInstance();&lt;br/&gt;&lt;span&gt;// 调用方法&lt;/span&gt;&lt;br/&gt;Method print = myClass.getDeclaredMethod(&lt;span&gt;&quot;print&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;print.invoke(o, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 输出类加载器&lt;/span&gt;&lt;br/&gt;System.out.println(&lt;span&gt;&quot;ClassLoader: &quot;&lt;/span&gt; + o.getClass().getClassLoader());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接运行上述代码，会输出如下结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;welcome you&lt;br/&gt;this is a car&lt;br/&gt;ClassLoader: sun.misc.Launcher&lt;span&gt;$AppClassLoader&lt;/span&gt;@49476842&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面看到输出结果并不符合我们的预期，Car 类使用的应用程序类加载器加载的，并不是我们自定义的类加载器。这个问题主要是因为 Idea 编译后会存放在 target/classes 目录下&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8093994778067886&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6LrrHRRxT1xEvMEVoibekmGq1x9s6vKCEflPfTTnKDaA7ZZO63BKmtD5TDrpEN9qdve8Eqiceuib7sejqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;383&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这个目录正好是应用程序类加载的路径，可以使用ClassLoaderPathExample代码验证。为了解决这个问题，我们可以把 Car.class 手动移动到 /opt/data 目录下（删除 target/classes 目录下的 Car.class 文件，避免由应用程序类加载器加载）。再次运行输出如下结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CustomClassLoader: com.common.example.bean.Car&lt;br/&gt;welcome you&lt;br/&gt;this is a car&lt;br/&gt;ClassLoader: com.common.example.jvm.classLoader.CustomClassLoader@4617c264&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样 Car 类就使用我们自定义的类加载器加载了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 什么是双亲委派模型&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述四种类加载器之间存在着一种层次关系，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.978494623655914&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6LrrHRRxT1xEvMEVoibekmGq1xIKpFeYaVibn3NgVGTzJZBv7WCibs8XVlAib2w8LgOnKhsLiaIYmfoNx2jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般认为上一层加载器是下一层加载器的父类加载器，除了启动类加载器 BootstrapClassLoader 之外，所有的加载器都是有父类加载器。我们可以先通过如下代码来看一下类加载器的层级结构：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 应用程序类加载器(系统类加载器)&lt;/span&gt;&lt;br/&gt;ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();&lt;br/&gt;System.out.println(systemClassLoader); &lt;span&gt;// sun.misc.Launcher$AppClassLoader@49476842&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 获取上层加载器:扩展类加载器&lt;/span&gt;&lt;br/&gt;ClassLoader extClassLoader = systemClassLoader.getParent();&lt;br/&gt;System.out.println(extClassLoader); &lt;span&gt;// sun.misc.Launcher$ExtClassLoader@5acf9800&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 获取上层加载器:启动类加载器&lt;/span&gt;&lt;br/&gt;ClassLoader bootstrapClassLoader = extClassLoader.getParent();&lt;br/&gt;System.out.println(bootstrapClassLoader); &lt;span&gt;// null&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上述代码中依次输出当前类的类加载器，父类加载器以及父类的父类加载器。可以看到当前类的加载器是应用程序类加载器，它的父类亲加载器是扩展类加载器，扩展类加载器的父类输出了一个 null，这个 null 会去调用启动类加载器。后续通过 ClassLoader 类的源码我们可以知道这一点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那到底什么是双亲委派模型呢？其实我们把上述类加载器之间的这种层次关系，我们称为类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类加载器的双亲委派模型是在 JDK 1.2 期间被引入并被广泛应用于之后几乎所有的 Java 程序中。但它并不是一个强制性的约束模型，而是 Java 设计者推荐给开发者的一种类加载器实现方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们从概念上知道了什么是双亲委派模型，那它到底是如何工作的呢？双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都委派到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 为什么需要双亲委派模型&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上面我们提到的，因为类加载器之间有严格的层次关系，那么也就使得 Java 类也随之具备了一种带有优先级的层次关系。例如类 java.lang.Object，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，但最终都委派给最顶层的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面我们可以知道双亲委派模型的核心是保障类加载的唯一性和安全性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;唯一性：可以避免类的重复加载，当父类加载器已经加载过某一个类时，子加载器就不会再重新加载这个类。例如上述提及的 java.lang.Object 类，最终都委派给最顶层的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安全性：保证了 Java 的核心 API 不被篡改。因为启动类加载器 Bootstrap ClassLoader 在加载的时候，只会加载 JAVA_HOME 中的 jar 包里面的类，如 java.lang.Object，那么就可以避免加载自定义的有破坏能力的 java.lang.Object。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 双亲委派模型是怎么实现的&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型对于保证 Java 程序的稳定运作很重要，但它的实现却非常简单，实现双亲委派的代码都集中在 java.lang.ClassLoader 的 loadClass() 方法之中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt; loadClass(String name, &lt;span&gt;boolean&lt;/span&gt; resolve) &lt;span&gt;throws&lt;/span&gt; ClassNotFoundException {&lt;br/&gt;    &lt;span&gt;synchronized&lt;/span&gt; (getClassLoadingLock(name)) {&lt;br/&gt;        &lt;span&gt;// 首先检查类是否已经被加载过&lt;/span&gt;&lt;br/&gt;        Class&amp;lt;?&amp;gt; c = findLoadedClass(name);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;long&lt;/span&gt; t0 = System.nanoTime();&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (parent != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;// 若没有加载过并且有父类加载器则调用父类加载器的 loadClass() 方法&lt;/span&gt;&lt;br/&gt;                    c = parent.loadClass(name, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;                } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;// 调用启动类加载器&lt;/span&gt;&lt;br/&gt;                    c = findBootstrapClassOrNull(name);&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (ClassNotFoundException e) {&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;// 如果仍未找到，则调用 findClass 以查找该类。&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;long&lt;/span&gt; t1 = System.nanoTime();&lt;br/&gt;                c = findClass(name);&lt;br/&gt;                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);&lt;br/&gt;                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);&lt;br/&gt;                sun.misc.PerfCounter.getFindClasses().increment();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (resolve) {&lt;br/&gt;            resolveClass(c);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; c;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先检查类是否已经被加载过，若没有加载过并且有父类加载器则调用父类加载器的 loadClass() 方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出 ClassNotFoundException 异常后，再调用自己的 findClass() 方法进行加载。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 如何破坏双亲委派模型&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型并不是一个强制性的约束模型，而是 Java 设计者推荐给开发者的类加载器实现方式。在 Java 的世界中大部分的类加载器都遵循这个模型，但也有例外，到目前为止，双亲委派模型主要出现过 3 较大规模的&#x27;被破坏&#x27;情况。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 JDK 1.2 历史原因&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的第一次&#x27;被破坏&#x27;其实发生在双亲委派模型出现之前，即 JDK 1.2 发布之前。由于双亲委派模型在 JDK 1.2 之后才被引入，而类加载器和抽象类 java.lang.ClassLoader 则在 JDK 1.0 时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java 设计者引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK 1.2 之后的 java.lang.ClassLoader 添加了一个新的 protected 方法 findClass()，在此之前，用户去继承 java. lang.ClassLoader 的唯一目的就是为了重写 loadClass() 方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法 loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的 loadClass()。上一节我们已经看过 loadClass() 方法的代码，双亲委派的具体逻辑就实现在这个方法之中，JDK 1.2之 后已不提倡用户再去覆盖 loadClass() 方法，而应当把自己的类加载逻辑写到 findClass() 方法中，在 loadClass() 方法的逻辑里如果父类加载失败，则会调用自己的 findClass() 方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 SPI&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的第二次&#x27;被破坏&#x27;是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的 API，但世事往往没有绝对的完美，如果基础类又要调用回用户的代码，那该怎么办？这并非是不可能的事情，一个典型的例子便是 JNDI 服务，JNDI 现在已经是 Java 的标准服务，它的代码由启动类加载器去加载（在 JDK 1.3 时放进去的 rt.jar 中），但 JNDI 的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序 ClassPath 下的 JNDI 接口提供者（SPI，Service Provider Interface）的代码，但启动类加载器不可能&#x27;认识&#x27;这些代码。为了解决这个问题，Java 设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoaser() 方法进行设置，如果创建线程时还未设置，将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。有了线程上下文类加载器，就可以做一些&#x27;舞弊&#x27;的事情了，JNDI 服务使用这个线程上下文类加载器去加载所需要的 SPI 代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java 中所有涉及 SPI 的加载动作基本上都采用这种方式，例如 JNDI、JDBC、JCE、JAXB和JBI等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 模块化&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的第三次&#x27;被破坏&#x27;是由于用户对程序动态性的追求而导致的，这里所说的&#x27;动态性&#x27;指的是当前一些非常&#x27;热门&#x27;的名词：代码热替换（HotSwap）、模块热部署（Hot Deployment）等。Sun 公司所提出的JSR-294、JSR-277 规范在与 JCP 组织的模块化规范之争中落败给 JSR-291（即OSGi R4.2），虽然 Sun 不甘失去 Java 模块化的主导权，独立在发展 Jigsaw 项目，但目前 OSGi 已经成为了业界事实上的 Java 模块化标准，而 OSGi 实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考：&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cf82ed9955b2bb6aa8f0515a7ccfca9e</guid>
<title>解密支付系统，来看如何构建理想的支付系统架构</title>
<link>https://toutiao.io/k/ohbhiwn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;markdown-body detail-content&quot;&gt;&amp;#13;
                &amp;#13;
                &lt;p&gt;&lt;strong&gt;【本文原创：苏博亚】&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;货币是人类发展史上一个极为重要的角色，它不仅是市场上物品交换的媒介，更是人类文明发展史上里程碑式的代表物。&lt;/p&gt;&amp;#13;
&lt;p&gt;几千年前人类在贸易市场上使用实物交换，可以想象一下我们的祖先进行市场贸易：一个人手上有羊奶，另一个人手上有牛肉，如果两个人都需要对方的物品，那么交换一下就可以了，这是最早的贸易。&lt;/p&gt;&amp;#13;
&lt;p&gt;但是随着人类文明的发展，这种实物交换已经无法满足人类的市场需求，比如拥有牛肉的人不喜欢羊奶，交易就无法进行。&lt;/p&gt;&amp;#13;
&lt;p&gt;这时候智慧的古人学会了使用媒介，大家所熟知的古时候的媒介是金、银、铜等。使用媒介给每种物品定价，所有的物品都可以通过媒介来购买和出售。&lt;/p&gt;&amp;#13;
&lt;p&gt;到了近代，金、银、铜的弊端也逐渐浮现出来，比如携带不便，大量金银放在身上会有安全隐患。在这种情况下，纸币应运而生，纸币的诞生解决了大部分金属货币的弊端，成本也非常低，并且携带方便。&lt;/p&gt;&amp;#13;
&lt;p&gt;随着科技的飞速发展，人类更加依赖电子产品，就出现了电子货币。货币发展经历的四大阶段如图1所示。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/2205651a5ec464e8d420&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图1&amp;#13;
&lt;/p&gt;&lt;p&gt;每一种货币的发展都经历了漫长的过程，每一种货币能够生存下来都经历了严格的考验。现在电子货币深入我们生活的方方面面，我们去商场购物，去餐厅吃饭，搭乘交通工具等，带一部手机就可以解决所有的支付问题。使用手机支付需要依靠互联网，&lt;strong&gt;通过互联网实现支付能力催生出了一大批支付机构。&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;h3-1-&quot;&gt;&lt;a name=&quot;1 支付牌照的诞生&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;1 支付牌照的诞生&lt;/h3&gt;&lt;p&gt;支付机构诞生之初市场是非常混乱的，没有统一的管理，没有统一的规范，所有的支付机构可以直接对接银行，可以实现资金留存，这样操作存在极大的风险，比如支付机构“跑路”了会造成很多人的资金损失。&lt;/p&gt;&amp;#13;
&lt;p&gt;所有行业的发展都要经历从混乱到有序的过程，2005年6月中国人民银行（简称央行）出台《支付清算组织管理办法（征求意见稿）》，在一定程度上规范了支付行业。2010年6月《非金融机构支付服务管理办法》的出台使整个支付行业终于有据可依，行业发展得以规范化。2011年5月央行开始发行支付牌照，从事支付行业的人士都非常了解支付牌照（也称支付业务许可证）的重要性，&lt;strong&gt;有支付牌照的机构做三方支付业务才是合规的，不然就是所谓的无证机构，是央行严厉打击的对象。&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;目前全国有支付牌照的企业只有200多家，这200多家在央行是有备付金账户的，即客户资金是安全有保障的，且支付机构可以在此基础上为客户提供资金清算和管理的服务。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;是不是只有有支付牌照的企业才能做支付业务？&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;答案是否定的，没有牌照的也可以，但是没有央行的备付金账户，所以不能进行资金的清算和管理，只能做支付信息服务，我们称之为聚合支付。&lt;/p&gt;&amp;#13;
&lt;p&gt;这样做的目的是保护消费者的财产安全，使市场更加合规稳定。有支付牌照的支付机构的业务流程如图2所示。&lt;br/&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/220593f72f0ea4b2a05f&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图2&amp;#13;
&lt;/p&gt;&lt;p&gt;没有支付牌照的支付机构的业务流程如图3所示。&lt;br/&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/2205acb38d7f574456be&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图3&amp;#13;
&lt;/p&gt;&lt;p&gt;可以看出，有牌照和没有牌照的业务处理流程是不一样的，没有牌照的支付机构需要通过有牌照的支付机构实现资金的流转，并且有牌照的支付机构直接把钱结算给商户，资金不经过聚合支付机构。接下来出现的“支付机构”指的都是有支付牌照的三方支付机构。&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;h3-2-&quot;&gt;&lt;a name=&quot;2 支付业务架构&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;2 支付业务架构&lt;/h3&gt;&lt;p&gt;支付机构核心的两个职责&lt;strong&gt;一个是帮助商户把钱收上来，另一个是把收到的钱结算给商户。&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;这两个职责对应的两个过程分别是入金和出金，&lt;strong&gt;入金&lt;/strong&gt;是指能够支撑客户的支付能力，把钱从C端客户的账户入账到支付机构的账户，&lt;strong&gt;出金&lt;/strong&gt;是把收到的C端客户的钱结算给商户。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;通俗地讲，支付机构就是帮助商户管好钱。&lt;/strong&gt;支付的过程一定要做到高效且安全，C端客户在支付的过程中按照一般人的习惯不会等待超过7秒，7秒之内一定要支付完成，否则会给客户造成很不好的体验。&lt;/p&gt;&amp;#13;
&lt;p&gt;一笔支付要经过商户、支付机构、银联/网联，接着到达银行，然后银行再把结果返回，最终展示给用户，这个过程是非常漫长的。如果订单量比较少，几秒内完成这些工作完全没有问题，如果支付机构每天有上千万或者上亿的支付单量（比如支付宝、微信），保证支付的高效就非常难了。&lt;/p&gt;&amp;#13;
&lt;p&gt;支付的过程中有很多影响支付速度的因素，比如带宽、硬件设备等，这些因素对于开发人员来说应该考虑，但是并不能起到决定性的作用，开发人员能做的是使用最少的资源，实现最高的效率。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;如何设计一套高效且安全的支付体系呢？&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;首先业务架构要清晰，支付体系的业务架构如图4所示。&lt;br/&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/2205b7e568ae1c86e5db&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图4&amp;#13;
&lt;/p&gt;&lt;p&gt;我们常使用的支付方式除了微信、支付宝，还有快捷支付（即绑定银行卡支付）。&lt;/p&gt;&amp;#13;
&lt;p&gt;微信支付包含扫码支付、JSAPI支付、Native支付、APP支付、H5支付、小程序支付等。&lt;/p&gt;&amp;#13;
&lt;p&gt;支付宝支付包含手机网站支付、APP支付、电脑网站支付等。&lt;/p&gt;&amp;#13;
&lt;p&gt;聚合支付机构要具备这些支付能力就需要对接对应的接口。合规的支付机构之间不能相互对接，只能和银联/网联对接。如果要具有微信、支付宝支付能力，则需要通过银联/网联来对接微信和支付宝。&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;h3-3-&quot;&gt;&lt;a name=&quot;3 支付系统架构发展历程&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;3 支付系统架构发展历程&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;随着支付业务的发展，线上支付单量的增加，支付系统架构也经历了几次演进。&lt;/strong&gt;早先使用线上支付的人非常少，一个支付机构的日单量可能只有十几万甚至几万笔。这时候不需要太多的系统资源，也不需要太复杂的架构设计，一个系统基本“搞定”所有的事情，如图5所示。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/22050c017e1b808d9367&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图5&amp;#13;
&lt;/p&gt;&lt;p&gt;同一个系统里的业务分不同的模块来处理，支付系统不外乎API接入、交易逻辑处理、商户维护、账务记录等。如果订单量小，那么这个架构没有问题，但是随着支付业务复杂性增加，订单笔数增多，系统的弊端就逐渐暴露出来了。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;系统容灾能力弱：&lt;/strong&gt;所有的模块都在一个系统中，某一个模块出现问题，会影响其他的模块，比如退款本身是可以异步执行的，如果因为退款业务的原因把正常支付的资源使用完或者拖垮系统就得不偿失了。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;开发成本高，团队协作不灵活：&lt;/strong&gt;所有的开发者都用同一套代码，编码版本维护成本高，调优发布风险大。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;复杂业务扩展性差：&lt;/strong&gt;随着业务复杂性的增加，系统的业务扩展能力会受到架构的严重影响，无法灵活修改系统的业务模块。&lt;/p&gt;&amp;#13;
&lt;p&gt;基于这些问题，流量大的支付机构就开始思考设计扩展性更好的支付架构来支撑不断增长的业务量和业务复杂度，首先考虑的是如何把系统拆得可用性强一些，系统的模块中的账务管理、商户管理、渠道对接是非常重要并且独立的，可以拆分出来，拆分后的系统结构如图6所示。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/220547e81c85786be51e&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图6&amp;#13;
&lt;/p&gt;&lt;p&gt;这样拆分后系统扩展性相对来说就比较高了，但技术永远都是向前发展的，微服务思想大大提升了系统的可扩展性，接下来分析使用微服务设计支付系统架构的思路。&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;h3-4-&quot;&gt;&lt;a name=&quot;4 理想的支付系统架构&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;4 理想的支付系统架构&lt;/h3&gt;&lt;p&gt;微服务的核心思想是把复杂的系统拆分为多个简单的子系统。明确了支付业务模型之后，需要把确定的支付产品转化为系统，以支撑我们的业务需求。支付体系架构经过多次演进，根据业务架构我们需要把系统拆解一下，每个小系统只负责一个业务模块。按照微服务的思想把支付系统拆分为多个小模块，如图7所示。&lt;br/&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/2205832c90222810e34a&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图7&amp;#13;
&lt;/p&gt;&lt;p&gt;每个模块都可以单独作为一个微服务的小系统，每个小系统负责不同的业务，某一个模块出现问题不会影响其他的业务模块。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;支付网关&lt;/strong&gt;是支付的入口，所有的交易都要经过支付网关再分发给各个系统，对支付机构起到门户的作用，给接入的商户提供统一的入口，方便商户的接入。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;商户中心&lt;/strong&gt;负责管理商户信息，商户想要使用支付平台，就要先提交入驻申请，把营业执照、法人信息、收款账户等上传到支付机构，支付机构存储并管理这些信息，在支付、结算的时候都需要用到这些信息。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;支付核心系统&lt;/strong&gt;（简称支付核心）负责处理业务逻辑，相当于一个系统的Service层，交易经过支付网关之后首先到达支付核心，支付核心根据交易报文的内容去“商户中心”收集信息，去请求“渠道”完成支付或者退款，去调用“账务”完成记账等。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;账务系统&lt;/strong&gt;负责管理商户的资金，商户入驻支付机构的时候，需要开通一个或多个管理资金的账户，商户使用支付渠道支付的每一笔资金都会在账户中体现，最终结算的时候也从账户中把资金结算给商户。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;清结算系统&lt;/strong&gt;负责把收到的资金结算给商户，结算的时候以支付、退款的明细为依据，把商户在支付机构的余额账户中的资金划转到商户的银行卡中。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;计费系统&lt;/strong&gt;负责收取渠道的手续费，一方面银联和网联要收取支付机构的手续费，另一方面支付机构会从中获利，是支付机构收入的主要来源。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;渠道系统&lt;/strong&gt;负责对接入金和出金的渠道，所有的支付机构不能和银行直接交互，需要通过银联/网联与银行交互。聚合支付机构可以对接三方支付机构。&lt;/p&gt;&amp;#13;
&lt;p&gt;一笔支付单在支付系统之间流转的过程如图8所示。&lt;br/&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/22056eb1ddf6ea674337&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图8&amp;#13;
&lt;/p&gt;&lt;p&gt;所有的交易都要先经过支付网关，支付网关收到交易报文之后会进行验签、解密等相关的操作，校验完成之后转发报文到支付核心，支付核心会对业务字段进行验证、数据落库，然后请求渠道系统进行路由筛选，筛选出外部的交易渠道（使用银联还是网联），选定之后转发报文到银联或者网联，然后把支付结果返回到支付核心，支付核心把支付结果通过支付网关返回给商户。支付核心发送支付成功消息，清结算系统监听支付成功消息并把支付成功的记录落入数据库，等待发起结算。账务系统接收支付成功消息进行记账。支付的各个系统拆分之后，每个系统负责不同的职责，系统划分之后，就可以进行技术选型了。&lt;/p&gt;&amp;#13;
&lt;p&gt;本文节选自&lt;strong&gt;《支付架构实战》&lt;/strong&gt;一书，欢迎阅读本书继续了解技术选型等支付架构设计的内容。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/2205fada72242c9f2227&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;strong&gt;扫码了解本书详情&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;http://download.broadview.com.cn/Original/2205c833275bc22454cb&quot;/&gt;&amp;#13;
&amp;#13;
            &lt;/p&gt;&lt;/div&gt;&amp;#13;
&amp;#13;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>926ccff739bdfa49382ccf10673bc743</guid>
<title>了解虚拟列表背后原理，轻松实现虚拟列表</title>
<link>https://toutiao.io/k/swzlkyj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;比如&lt;code&gt;umy-ui&lt;/code&gt;(ux-table)虚拟列表table组件，&lt;code&gt;vue-virtual-scroller&lt;/code&gt;以及&lt;code&gt;react-virtualized &lt;/code&gt;这些优秀的插件快速满足业务需要。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了理解插件背后的原理机制，我们实现一个自己简易版的虚拟列表，希望在实际业务项目中能带来一些思考和帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正文开始...&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.0970873786407767&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/njBmfXMicXibpcniaFhJ3vTjribkSkMu9jFxmIa8sYfuq3whdj7pljwic7FibucLWTNq8ibmoiay1pjKGMuLl4soNj3kicQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;103&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;虚拟列表是什么&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在大数据渲染中，选择一段可视区域显示对应数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先初步看一个图&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5363881401617251&quot; data-type=&quot;png&quot; data-w=&quot;2226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0jXCeiaibicNx4aU4a0Hm8CA4pUueuQo51exUIHhAUq5SFk19F29OQKbmCIp5LNXXaAQAo4mIAO6IOgJZfia9ev5LQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这张展示图中，我们可以看到我们展示的始终是&lt;code&gt;红色线虚线&lt;/code&gt;展示的部分，每一个元素固定高度，被一个&lt;code&gt;很大高度的元素&lt;/code&gt;包裹着，并且&lt;code&gt;最外层&lt;/code&gt;有一个固定的高度容器，并且设置可以滚动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新建一个&lt;code&gt;index.html&lt;/code&gt;对应结构如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;vitual-list-wrap&quot;&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;listWrap&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;content&quot;&lt;/span&gt; &lt;span&gt;:style&lt;/span&gt;=&lt;span&gt;&quot;contentStyle&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;item&quot;&lt;/span&gt; &lt;span&gt;v-for&lt;/span&gt;=&lt;span&gt;&quot;(item, index) in list&quot;&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;:key&lt;/span&gt;=&lt;span&gt;&quot;index&quot;&lt;/span&gt; &lt;span&gt;:style&lt;/span&gt;=&lt;span&gt;&quot;item.style&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        {{item.content}}&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应的&lt;code&gt;css&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;*{&lt;br/&gt;  &lt;span&gt;padding&lt;/span&gt;:&lt;span&gt;0px&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;margin&lt;/span&gt;: &lt;span&gt;0px&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;#app&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;width&lt;/span&gt;:&lt;span&gt;300px&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;border&lt;/span&gt;: &lt;span&gt;1px&lt;/span&gt; solid &lt;span&gt;#e5e5e5&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/*外部容器给一个固定的可视高度，并且设置可以滚动*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;.vitual-list-wrap&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;position&lt;/span&gt;: relative;&lt;br/&gt;  &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;800px&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;overflow-y&lt;/span&gt;: auto;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/*真实容器的区域*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;.content&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;position&lt;/span&gt;: relative;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/*固定高度的每个元素*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;.item&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;60px&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;padding&lt;/span&gt;: &lt;span&gt;10px&lt;/span&gt; &lt;span&gt;5px&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;border-bottom&lt;/span&gt;: &lt;span&gt;1px&lt;/span&gt; solid &lt;span&gt;#111&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;position&lt;/span&gt;: absolute;&lt;br/&gt;  &lt;span&gt;left&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;right&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;line-height&lt;/span&gt;: &lt;span&gt;60px&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从对应页面结构与&lt;code&gt;css&lt;/code&gt;中我们的思路大致是这样&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;确定外层固定的高度，并且设置纵向滚动条&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;真实容器设置相对定位，并且根据显示总数动态设置一个装载容器的高度&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个元素设置绝对定位，且是固定高度&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了对应设置的结构，因为我们每个元素是绝对定位的，所以我们现在的思路就是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、确定可视区域&lt;code&gt;item&lt;/code&gt;显示的条数&lt;code&gt;limit&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、向上滑动的当前位置&lt;code&gt;起始位&lt;/code&gt;与&lt;code&gt;最后位置&lt;/code&gt;，确定显示元素范围&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、确定每个元素的&lt;code&gt;top&lt;/code&gt;，当向上滑动时，确定当前的位置与最后元素的位置索引，根据当前位置与最后元素位置，渲染&lt;code&gt;可视区域&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体逻辑代码如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;app&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;h3&lt;/span&gt;&amp;gt;&lt;/span&gt;虚拟列表&lt;span&gt;&amp;lt;/&lt;span&gt;h3&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;vitual-list-wrap&quot;&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;list-wrap&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;content&quot;&lt;/span&gt; &lt;span&gt;:style&lt;/span&gt;=&lt;span&gt;&quot;contentStyle&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;item&quot;&lt;/span&gt; &lt;span&gt;v-for&lt;/span&gt;=&lt;span&gt;&quot;(item, index) in list&quot;&lt;/span&gt; &lt;br/&gt;                  &lt;span&gt;:key&lt;/span&gt;=&lt;span&gt;&quot;index&quot;&lt;/span&gt; &lt;span&gt;:style&lt;/span&gt;=&lt;span&gt;&quot;item.style&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                    {{item.content}}&lt;br/&gt;                &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;!--引入vue3组件库--&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;&quot;https://cdn.bootcdn.net/ajax/libs/vue/3.2.33/vue.global.min.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;&quot;./index.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们具体看下&lt;code&gt;index.js&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;// index.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { createApp, reactive, toRefs, computed, onMounted, ref } = Vue;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; vm = createApp({&lt;br/&gt;  setup() {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; listWrap = ref(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; viewData = reactive({&lt;br/&gt;        &lt;span&gt;list&lt;/span&gt;: [],&lt;br/&gt;        &lt;span&gt;total&lt;/span&gt;: &lt;span&gt;1000&lt;/span&gt;, &lt;span&gt;// 数据总条数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;600&lt;/span&gt;, &lt;span&gt;// 可视区域的高度&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;rowHeight&lt;/span&gt;: &lt;span&gt;60&lt;/span&gt;, &lt;span&gt;// 每条item的高度&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;startIndex&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;// 初始位置&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;endIndex&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;// 结束位置&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;timer&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;bufferSize&lt;/span&gt;: &lt;span&gt;5&lt;/span&gt; &lt;span&gt;// 做一个缓冲&lt;/span&gt;&lt;br/&gt;        &lt;br/&gt;      });&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; contentStyle = computed(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;`&lt;span&gt;${viewData.total * viewData.rowHeight}&lt;/span&gt;px`&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;position&lt;/span&gt;: &lt;span&gt;&#x27;relative&#x27;&lt;/span&gt;,&lt;br/&gt;        }&lt;br/&gt;      });&lt;br/&gt;      &lt;span&gt;// todo 设置数据&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; renderData = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        viewData.list = [];&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; {rowHeight, height, startIndex, total, bufferSize} = viewData;&lt;br/&gt;        &lt;span&gt;// 当前可视区域的row条数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; limit = &lt;span&gt;Math&lt;/span&gt;.ceil(height/rowHeight);&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(limit, &lt;span&gt;&#x27;=limit&#x27;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 可视区域的最后一个位置&lt;/span&gt;&lt;br/&gt;        viewData.endIndex = &lt;span&gt;Math&lt;/span&gt;.min(startIndex + limit + bufferSize, total &lt;span&gt;-1&lt;/span&gt;);&lt;br/&gt;          &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i=startIndex; i&amp;lt;viewData.endIndex; i++) {&lt;br/&gt;            viewData.list.push({&lt;br/&gt;            &lt;span&gt;content&lt;/span&gt;: i,&lt;br/&gt;            &lt;span&gt;style&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;top&lt;/span&gt;: &lt;span&gt;`&lt;span&gt;${i * rowHeight}&lt;/span&gt;px`&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;          })&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;// todo 监听滚动，设置statIndex与endIndex&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; handleScroll = &lt;span&gt;(&lt;span&gt;callback&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// console.log(listWrap.value)&lt;/span&gt;&lt;br/&gt;        listWrap.value &amp;amp;&amp;amp; listWrap.value.addEventListener(&lt;span&gt;&#x27;scroll&#x27;&lt;/span&gt;, (e) =&amp;gt; {&lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.timer) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;          }&lt;br/&gt;          &lt;span&gt;const&lt;/span&gt; { rowHeight, startIndex, bufferSize } = viewData;&lt;br/&gt;          &lt;span&gt;const&lt;/span&gt; { scrollTop } = e.target;&lt;br/&gt;          &lt;span&gt;// 计算当前滚动的位置，获取当前开始的起始位置&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;const&lt;/span&gt; currentIndex = &lt;span&gt;Math&lt;/span&gt;.floor(scrollTop / rowHeight); &lt;br/&gt;          viewData.timer = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;          &lt;span&gt;// console.log(startIndex, currentIndex);&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;// 做一个简单的节流处理&lt;/span&gt;&lt;br/&gt;          setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            viewData.timer = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;               &lt;span&gt;// 如果滑动的位置不是当前位置&lt;/span&gt;&lt;br/&gt;               &lt;span&gt;if&lt;/span&gt; (currentIndex !== startIndex) {&lt;br/&gt;                viewData.startIndex = &lt;span&gt;Math&lt;/span&gt;.max(currentIndex - bufferSize, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;                callback();&lt;br/&gt;               }&lt;br/&gt;            }, &lt;span&gt;500&lt;/span&gt;)&lt;br/&gt;        })&lt;br/&gt;      }&lt;br/&gt;      onMounted(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        renderData();&lt;br/&gt;        handleScroll(renderData);&lt;br/&gt;      })&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;        ...toRefs(viewData),&lt;br/&gt;        contentStyle,&lt;br/&gt;        renderData,&lt;br/&gt;        listWrap&lt;br/&gt;      }&lt;br/&gt;  },&lt;br/&gt;})&lt;br/&gt;vm.mount(&lt;span&gt;&#x27;#app&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下页面，已经ok了，每次上滑都只会固定高度加载对应的数据&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45582047685834504&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0jXCeiaibicNx4aU4a0Hm8CA4pUueuQo51eDyJ78MatXdPHDicsMr451AdtUTu2Qz8zdB2xnhdaTSIubFod2BcS1eA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2852&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意我们在&lt;code&gt;css&lt;/code&gt;中有一段这样的代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#app&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;width&lt;/span&gt;:&lt;span&gt;300px&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;border&lt;/span&gt;: &lt;span&gt;1px&lt;/span&gt; solid &lt;span&gt;#e5e5e5&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;...&lt;br/&gt;&lt;span&gt;[data-v-app]&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt; &lt;span&gt;!important&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样处理主要是为了插值表达式在未渲染的时候，让用户看不到未渲染前的模版内容。如果不先隐藏，那么会打开页面的时候会有插值表达式，&lt;code&gt;vue&lt;/code&gt;中提供了一个&lt;code&gt;v-cloak&lt;/code&gt;,但是貌似这里不管用，在&lt;code&gt;vue2&lt;/code&gt;中是可以的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇是非常简易的虚拟列表实现，了解虚拟列表背后的实现思想，更多可以参考&lt;span&gt;vue-virtual-scroller&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;与&lt;span&gt;react-virtualized&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;源码的实现，具体应用示例可以查看之前写的一篇偏应用的文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzk0ODMxODIzNw==&amp;amp;mid=2247486014&amp;amp;idx=1&amp;amp;sn=4fb22eb3cc18b08d5d7ec8ffeed63587&amp;amp;chksm=c368334cf41fba5ab89d61af3ae16d7753c3ebb61aa6a7720fb6e78a29c080a7e8841da8db02&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;测试脚本把页面搞崩了 &lt;/a&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;了解虚拟列表到底是什么，在大数据渲染中，选择一段可视区域显示对应数据&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;实现虚拟列表的背后原理，最外层给定一个固定的高度，然后设置纵向&lt;code&gt;Y轴&lt;/code&gt;滚动，然后每个元素的父级设置相对定位，设置真实展示数据的高度，根据&lt;code&gt;item&lt;/code&gt;固定高度(&lt;code&gt;rowHeight&lt;/code&gt;)，根据可视区域和&lt;code&gt;rowHeight&lt;/code&gt;计算可显示的&lt;code&gt;limit&lt;/code&gt;数目。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当滚动条上滑时，计算出滚动的距离&lt;code&gt;scrollTop&lt;/code&gt;，通过&lt;code&gt;currentIndex = Math.floor(scrollTop/rowHeight)&lt;/code&gt;计算出当前起始索引&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;endIndex = Math.min(currentIndex+limit, total-1)&lt;/code&gt;计算出最后可显示的索引&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;最后根据&lt;code&gt;startIndex&lt;/code&gt;与结束位置&lt;code&gt;endIndex&lt;/code&gt;，根据&lt;code&gt;startIndex&lt;/code&gt;与&lt;code&gt;endIndex&lt;/code&gt;渲染可视区域&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;本文示例代码&lt;span&gt;code example&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;本文参考相关文章&lt;span&gt;如何实现一个高度自适应的虚拟列表&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;,这是&lt;code&gt;react&lt;/code&gt;版本的&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;vue-virtual-scroller: &lt;em&gt;https://github.com/Akryum/vue-virtual-scroller&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;react-virtualized: &lt;em&gt;https://github.com/bvaughn/react-virtualized&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;code example: &lt;em&gt;https://github.com/maicFir/lessonNote/tree/master/javascript/08-%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;如何实现一个高度自适应的虚拟列表: &lt;em&gt;https://juejin.cn/post/6948011958075392036&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b235eff711a5c82a16c9999d6d9a3f21</guid>
<title>继Python之后，Go也顺利在浏览器上运行</title>
<link>https://toutiao.io/k/oqes14y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;文 | 局长&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;出品 | OSC开源社区（ID：oschina2013)&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;Anaconda 开发商最近发布了 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzM0MjcyMQ==&amp;amp;mid=2650144570&amp;amp;idx=1&amp;amp;sn=e0bce6b9f78f6b24418aba0b5cdd4c8f&amp;amp;chksm=beda245489adad42c2f53106e9c949f033ccddfdeeccabf9db9534a6774cbe338175c15d4505&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;PyScript&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;PyScript&lt;/a&gt;，这是一个可以让开发者在 HTML 中混写 Python 代码的框架，有人将其称为 “Python 版 JSP”。事实上，PyScript 底层采用了 WebAssembly， 因为它基于 Pyodide 构建，Pyodide 由编译成 WebAssembly 的 CPython 3.8 解释器组成，允许在网页浏览器中运行 Python。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.640074211502783&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKic7joUkwHYuRwcgZCsxZpsGwib8MwCzBxtV5JSriaiaRDu0uyGoEUJLweBTtJF29CRcNb7ISZmFqUfww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1078&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;无独有偶，开发者采用相同的思路让 Go 也顺利在浏览器上运行。&lt;span&gt;https://goscript.dev&lt;/span&gt; 网站支持在浏览器端直接运行 Go 代码，这是一个 Go playground，底层采用 Goscript，通过 WASM 实现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKic7joUkwHYuRwcgZCsxZpsGiaGianNlew710qm0JC2y4UOLvvrVumE24RbcorXwQjMuqtNibeBHYkNOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;875&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Goscript 是 Go 语言规范的非官方实现，&lt;span&gt;用于 Rust 项目的内嵌或封装&lt;/span&gt;，提供了更简单的方式封装和调用底层的 Rust 代码。&lt;span&gt;就像 Lua 之于 Redis/WoW，或者 Python 之于 NumPy。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Goscript 包含六个项目：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;parser&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;把源代码变成 AST，移植自 Go 官方代码。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;type checker&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;基于 AST 做类型推倒和类型检查，也移植自 Go 官方代码。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;codegen&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;基于 AST 和类型信息生成字节码。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;vm&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;运行字节码。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;std&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;官方库，移植自 Go 官方库。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;engine&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;包含官方库的 native 部分，再加上简单封装。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;Goscript 实现了 Go 的几乎所有特性（pre 1.18，因此不包括泛型），并移植了部分官方库，已通过的相关测试用例查看 https://github.com/oxfeeefeee/goscript/tree/master/engine/tests。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Goscript 项目代码：https://github.com/oxfeeefeee/goscript&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86032&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span data-brushtype=&quot;text&quot;&gt;推荐阅读&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9574468085106383&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZP3JEv2BgJ7cx4oxeYNNqh2oytepen4zyw43jGnqXCiaAYWgK59RF4HTukPFrHF7FJarvFzETH87kr3It44zLmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;94&quot;/&gt;&lt;span&gt;觉得不错，请点个&lt;/span&gt;&lt;span&gt;在看&lt;/span&gt;&lt;span&gt;呀&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>