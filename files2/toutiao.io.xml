<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f2a0b4646d1b3f07b8b165fdc20d25d6</guid>
<title>Redis 在 Linux 系统的配置优化</title>
<link>https://toutiao.io/k/cgfim2o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常来看，Redis开发和运维人员更加关注的是Redis本身的一些配置优化，例如AOF和RDB的配置优化、数据结构的配置优化等，但是对于操作系统是否需要针对Redis做一些配置优化不甚了解或者不太关心，然而事实证明一个良好的系统操作配置能够为Redis服务良好运行保驾护航。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知Redis的作者对于Windows操作系统并不感冒，目前大部分公司都会将Web服务器、数据库服务器等部署在Linux操作系统上，Redis也不例外。所以接下来介绍Linux操作系统如何优化Redis，包含如下七个方面。&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;一. 内存分配控制&lt;/h2&gt;&lt;h3&gt;&lt;span/&gt;1. vm.overcommit_memory&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;Redis在启动时可能会出现这样的日志：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#x27;vm.overcommit_memory = 1&#x27; to /etc/sysctl.conf and then reboot or run the &lt;/span&gt;&lt;br/&gt;&lt;span&gt;command&lt;/span&gt; &lt;span&gt;&#x27;sysctl vm.overcommit_memory=1&#x27;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; this to take effect.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在分析这个问题之前，首先要弄清楚什么是overcommit？Linux操作系统对大部分申请内存的请求都回复yes，以便能运行更多的程序。因为申请内存后，并不会马上使用内存，这种技术叫做overcommit。如果Redis在启动时有上面的日志，说明vm.overcommit_memory=0，Redis提示把它设置为1。&lt;/p&gt;&lt;p&gt;vm.overcommit_memory用来设置内存分配策略，它有三个可选值，如下表所示。&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;vm.overcommit_memory&lt;/th&gt;&lt;th&gt;含义&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;表示内核将检查是否有足够的可用内存。如果有足够的可用内存，内存申请通过，否则内存申请失败，并把错误返回给应用进程&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;表示内核允许超量使用内存直到用完为止&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;表示内核决不过量的(&quot;never overcommit&quot;)使用内存，即系统整个内存地址空间不能超过swap+50%的RAM值，50%是overcommit_ratio默认值，此参数同样支持修改&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;注意：本文的可用内存代表物理内存与swap之和。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;日志中的Background save代表的是bgsave和bgrewriteaof，如果当前可用内存不足，操作系统应该如何处理fork。如果vm.overcommit_memory=0，代表如果没有可用内存，就申请内存失败，对应到Redis就是fork执行失败，在Redis的日志会出现：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Cannot allocate memory &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Redis建议把这个值设置为1，是为了让fork能够在低内存下也执行成功。&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;2. 获取和设置&lt;span/&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span/&gt;获取：&lt;span/&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;cat /proc/sys/vm/overcommit_memory&lt;br/&gt;0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span/&gt;设置：&lt;span/&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;vm.overcommit_memory=1&quot;&lt;/span&gt; &amp;gt;&amp;gt; /etc/sysctl.conf&lt;br/&gt;sysctl vm.overcommit_memory=1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span/&gt;3. 最佳实践&lt;span/&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Redis设置合理的maxmemory，保证机器有20%~30%的闲置内存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;集中化管理aof重写和rdb的bgsave。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置vm.overcommit_memory=1，防止极端情况下，会造成fork失败。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span/&gt;二. swappiness&lt;/h2&gt;&lt;h3&gt;&lt;span/&gt;1. 参数说明&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;swap对于操作系统来比较重要，当物理内存不足时，可以swap out一部分内存页，以解燃眉之急。但世界上没有免费午餐，swap空间由硬盘提供，对于需要高并发、高吞吐的应用来说，磁盘IO通常会成为系统瓶颈。在Linux中，并不是要等到所有物理内存都使用完才会使用到swap，系统参数swppiness会决定操作系统使用swap的倾向程度。swappiness的取值范围是0~100，swappiness的值越大，说明操作系统可能使用swap的概率越高，swappiness值越低，表示操作系统更加倾向于使用物理内存。swap的默认值是60，了解这个值的含义后，有利于Redis的性能优化。下表对swappiness的重要值进行了说明。&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;swapniess&lt;/th&gt;&lt;th&gt;策略&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;Linux3.5以及以上：宁愿OOM killer也不用swap&lt;br/&gt;Linux3.4以及更早：宁愿swap也不要OOM killer&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;Linux3.5以及以上：宁愿swap也不要OOM killer&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;60&lt;/td&gt;&lt;td&gt;默认值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;100&lt;/td&gt;&lt;td&gt;操作系统会主动地使用swap&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;运维提示：OOM(Out Of Memory) killer机制是指Linux操作系统发现可用内存不足时，强制杀死一些用户进程（非内核进程），来保证系统有足够的可用内存进行分配。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从下表中可以看出，swappiness参数在Linux 3.5版本前后的表现并不完全相同，Redis运维人员在设置这个值需要关注当前操作系统的内核版本。&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;2. 设置方法&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;swappiness设置方法如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;echo&lt;/span&gt; {bestvalue} &amp;gt; /proc/sys/vm/swappiness&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是上述方法在系统重启后就会失效，为了让配置在重启Linux操作系统后立即生效，只需要在/etc/sysctl.conf追加 vm.swappiness={bestvalue}即可。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;echo&lt;/span&gt; vm.swappiness={bestvalue} &amp;gt;&amp;gt; /etc/sysctl.conf&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意/proc/sys/vm/swappiness是设置操作，/etc/sysctl.conf是追加操作。&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;3. 如何监控swap&lt;span/&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span/&gt;(1) 查看swap的总体情况&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;Linux提供了free命令来查询操作系统的内存使用情况，其中也包含了swap的相关使用情况。下面是某台Linux服务器执行free –m(以兆为到位)的结果，其中需要重点关注的是最后一行的swap统计，从执行结果看，swap一共有4095M，使用了0M，空闲了4095M。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;             total       used       free     shared    buffers     cached&lt;br/&gt;Mem:         64385      31573      32812          0        505      10026&lt;br/&gt;-/+ buffers/cache:      21040      43344&lt;br/&gt;Swap:         4095          0       4095&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在另一台Linux服务器同样执行free -m，这台服务器开启了8189M swap，其中使用了5241M。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;             total       used       free     shared    buffers     cached&lt;br/&gt;Mem:         24096       8237      15859          0        136       2483&lt;br/&gt;-/+ buffers/cache:       5617      18479&lt;br/&gt;Swap:         8189       5241       2947&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span/&gt;(2) 实时查看swap的使用&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;Linux提供了vmstat命令查询系统的相关性能指标，其中包含负载、CPU、内存、swap、IO的相关属性。但其中和swap有关的指标是si和so，它们分别代表了操作系统的swap in和swap out。下面是执行vmstat 1（每隔一秒输出）的效果，可以看到si和so都为0，代表当前没有使用swap。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# vmstat  1&lt;/span&gt;&lt;br/&gt;procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----&lt;br/&gt; r  b   swpd   free   buff  cache   si   so    bi    bo   &lt;span&gt;in&lt;/span&gt;   cs us sy id wa st&lt;br/&gt; 1  0      0 33593468 517656 10271928    0    0     0     1    0    0  8  0 91  0  0 &lt;br/&gt; 4  0      0 33594516 517656 10271928    0    0     0     0 10606 9647 10  1 90  0  0 &lt;br/&gt; 1  0      0 33594392 517656 10271928    0    0     0     0 11490 10244 11  1 89  0  0 &lt;br/&gt; 6  0      0 33594292 517656 10271928    0    0     0    36 12406 10681 13  1 87  0  0 &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span/&gt;(3) 查看指定进程的swap使用情况&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;Linux操作系统中，/proc/{pid}目录是存储指定进程的相关信息，其中/proc/{pid}/smaps是记录了当前进程所对应的内存映像信息，这个信息对于查询指定进程的swap使用情况很有帮助。下面以一个Redis实例进行说明
通过info server获取Redis的进程号process_id:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;redis-cli -h ip -p port info server | grep process_id&lt;br/&gt;process_id:986&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过cat /proc/986/smaps查询Redis的smaps信息，由于有多个内存块信息，这里只输出一个内存块镜像信息进行观察。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;2aab0a400000-2aab35c00000 rw-p 2aab0a400000 00:00 0 &lt;br/&gt;Size:            712704 kB&lt;br/&gt;Rss:             617872 kB&lt;br/&gt;Shared_Clean:         0 kB&lt;br/&gt;Shared_Dirty:         0 kB&lt;br/&gt;Private_Clean:    15476 kB&lt;br/&gt;Private_Dirty:   602396 kB&lt;br/&gt;Swap:             58056 kB&lt;br/&gt;Pss:             617872 kB&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中Swap字段代表该内存块存在swap分区的数据大小。通过执行如下命令，就可以找到每个内存块镜像信息中，这个进程使用到的swap量，通过求和就可以算出总的swap用量。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;cat /proc/986/smaps | grep Swap&lt;br/&gt;Swap:                 0 kB&lt;br/&gt;Swap:                 0 kB&lt;br/&gt;…&lt;br/&gt;Swap:                 0 kB&lt;br/&gt;Swap:            478320 kB&lt;br/&gt;…&lt;br/&gt;Swap:               624 kB&lt;br/&gt;Swap:                 0 kB&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span/&gt;4. 最佳实践&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;如果Linux&amp;gt;3.5，vm.swapniess=1，否则vm.swapniess=0，从而实现如下两个目标：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;物理内存充足时候，使Redis足够快。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;物理内存不足时候，避免Redis死掉(如果当前Redis为高可用，死掉比阻塞更好)。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span/&gt;三. Transparent Huge Pages&lt;/h2&gt;&lt;p&gt;Redis在启动时可能会看到如下日志：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;WARNING you have Transparent Huge Pages (THP) support enabled &lt;span&gt;in&lt;/span&gt; your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the &lt;span&gt;command&lt;/span&gt; &lt;span&gt;&#x27;echo never &amp;gt; /sys/kernel/mm/transparent_hugepage/enabled&#x27;&lt;/span&gt; as root, and add it to your /etc/rc.local &lt;span&gt;in&lt;/span&gt; order to retain the setting after a reboot. Redis must be restarted after THP is disabled.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从提示看Redis建议修改Transparent Huge Pages (THP)的相关配置，Linux kernel在2.6.38内核增加了Transparent Huge Pages (THP)特性 ，支持大内存页(2MB)分配，默认开启。当开启时可以降低fork子进程的速度，但fork之后，每个内存页从原来4KB变为2MB，会大幅增加重写期间父进程内存消耗。同时每次写命令引起的复制内存页单位放大了512倍，会拖慢写操作的执行时间，导致大量写操作慢查询。例如简单的incr命令也会出现在慢查询中。因此Redis日志中建议将此特性进行禁用，禁用方法如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;echo&lt;/span&gt; never &amp;gt;  /sys/kernel/mm/transparent_hugepage/enabled&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而且为了使机器重启后THP配置依然生效，可以在/etc/rc.local中追加echo never &amp;gt; /sys/kernel/mm/transparent_hugepage/enabled。&lt;/p&gt;&lt;p&gt;在设置THP配置时需要注意：有些Linux的发行版本没有将THP放到/sys/kernel/mm/transparent_hugepage/enabled中，例如Red Hat 6以上的THP配置放到/sys/kernel/mm/redhat_transparent_hugepage/enabled中。而Redis源码中检查THP时，把THP位置写死。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;FILE *fp = fopen(&lt;span&gt;&quot;/sys/kernel/mm/transparent_hugepage/enabled&quot;&lt;/span&gt;,&lt;span&gt;&quot;r&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (!fp) &lt;span&gt;return&lt;/span&gt; 0;   &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以在发行版中，虽然没有THP的日志提示，但是依然存在THP所带来的问题。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;echo&lt;/span&gt; never &amp;gt;  /sys/kernel/mm/redhat_transparent_hugepage/enabled&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span/&gt;四. OOM killer&lt;/h2&gt;&lt;p&gt;OOM killer会在可用内存不足时选择性的杀掉用户进程，它的运行规则是怎样的，会选择哪些用户进程“下手”呢？OOM killer进程会为每个用户进程设置一个权值，这个权值越高，被“下手”的概率就越高，反之概率越低。每个进程的权值存放在/proc/{progress_id}/oom_score中，这个值是受/proc/{progress_id}/oom_adj的控制，oom_adj在不同的Linux版本的最小值不同，可以参考Linux源码中oom.h(从-15到-17)。当oom_adj设置为最小值时，该进程将不会被OOM killer杀掉，设置方法如下。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;echo&lt;/span&gt; {value} &amp;gt; /proc/&lt;span&gt;${process_id}&lt;/span&gt;/oom_adj&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于Redis所在的服务器来说，可以将所有Redis的oom_adj设置为最低值或者稍小的值，降低被OOM killer杀掉的概率。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; redis_pid &lt;span&gt;in&lt;/span&gt; $(pgrep -f &lt;span&gt;&quot;redis-server&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;do&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;echo&lt;/span&gt; -17 &amp;gt; /proc/&lt;span&gt;${redis_pid}&lt;/span&gt;/oom_adj&lt;br/&gt;&lt;span&gt;done&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span/&gt;运维提示：&lt;span/&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;有关OOM killer的详细细节，可以参考Linux源码mm/oom_kill.c中oom_badness函数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;笔者认为oom_adj参数只能起到辅助作用，合理的规划内存更为重要。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通常在高可用情况下，被杀掉比僵死更好，因此不要过多依赖oom_adj配置&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span/&gt;五. 使用NTP&lt;/h2&gt;&lt;p&gt;NTP(Network Time Protocol)网络时间协议，一种保证不同机器时钟一致性的服务。我们知道像Redis Sentinel和Redis Cluster这两种需要多个Redis实例的类型，可能会涉及多台服务器。虽然Redis并没有对多个服务器的时钟有严格的要求，但是假如多个Redis实例所在的服务器时钟不一致，对于一些异常情况的日志排查是非常困难的，例如Redis Cluster的故障转移，如果日志时间不一致，对于我们排查问题带来很大的困扰(注：但不会影响集群功能，集群节点依赖各自时钟)。一般公司里都会有NTP服务用来提供标准时间服务，从而达到纠正时钟的效果(如下图所示)，为此我们可以每天定时去同步一次系统时间，从而使得集群中的时间是统一。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.546448087431694&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZULLb8I10cworkT0sBrUjPbJmc44SlraLFpjdxuOU1RSseBnUy4csFP7yFEkQj61fJwVfvakVKIaYxlqj3nibfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1098&quot;/&gt;&lt;/figure&gt;&lt;p&gt;例如每小时的同步1次NTP服务&lt;/p&gt;&lt;pre&gt;&lt;code&gt;0 * * * * /usr/sbin/ntpdate ntp.xx.com &amp;gt; /dev/null 2&amp;gt;&amp;amp;1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span/&gt;六. ulimit&lt;/h2&gt;&lt;p&gt;在Linux中，可以通过ulimit查看和设置系统的当前用户进程的资源数。其中ulimit -a命令包含的open files参数，是单个用户同时打开的最大文件个数。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# ulimit –a&lt;/span&gt;&lt;br/&gt;…&lt;br/&gt;max locked memory       (kbytes, -l) 64&lt;br/&gt;max memory size         (kbytes, -m) unlimited&lt;br/&gt;open files                      (-n) 1024&lt;br/&gt;pipe size            (512 bytes, -p) 8&lt;br/&gt;…&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Redis允许同时有多个客户端通过网络进行连接，可以通过配置maxclients来限制最大客户端连接数。对Linux操作系统来说这些网络连接都是文件句柄。假设当前open files是4096，那么启动Redis时会看到如下日志。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# You requested maxclients of 10000 requiring at least 10032 max file descriptors.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Redis can’t set maximum open files to 10032 because of OS error: Operation not permitted.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Current maximum open files is 4096. Maxclients has been reduced to 4064 to compensate for low ulimit. If you need higher maxclients increase ‘ulimit –n’.&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的日志解释如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一行：Redis建议把open files至少设置成10032，那么这个10032是如何来的呢？因为maxclients的默认是10000，这些是用来处理客户端连接的，除此之外，Redis内部会使用最多32个文件描述符，所以这里的10032 = 10000 + 32。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二行：Redis不能将open files设置成10032，因为它没有权限设置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三行：当前系统的open files是4096，所以maxclients被设置成4096-32=4064个，如果你想设置更高的maxclients，请使用ulimit -n来设置。从上面的三行日志分析可以看出open files的限制优先级比maxclients大。open files的设置方法如下：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;ulimit&lt;/span&gt; –Sn {max-open-files}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span/&gt;七. TCP backlog&lt;/h2&gt;&lt;p&gt;Redis默认的tcp-backlog为511，可以通过修改配置tcp-backlog进行调整，如果Linux的tcp-backlog小于Redis设置的tcp-backlog，那么在Redis启动时会看到如下日志：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看方法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;cat /proc/sys/net/core/somaxconn&lt;br/&gt;128&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改方法：.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;echo&lt;/span&gt; 511 &amp;gt; /proc/sys/net/core/somaxconn&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8755ca13301825f624dd5a9d6b0ccf93</guid>
<title>深入 Spring Boot（十六）：从源码分析自动配置原理</title>
<link>https://toutiao.io/k/wnr557l</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h2&gt;切换Druid连接池&lt;/h2&gt;&lt;p&gt;在分析SpringBoot自动配置实现原理之前，先来看一下在使用SpringBoot开发的项目代码中如何将数据库连接池切换成Druid。&lt;/p&gt;&lt;p&gt;对于数据库连接池的选择，SpringBoot官方更偏向于推荐使用HikariCP，原因是他们认为HikariCP的性能和并发性比较好，如果当前代码的classpath路径下存在HikariCP的jar包，则会优先使用HikariCP数据库连接池；如果当前代码的classpath路径下不存在HikariCP的jar包，存在Tomcat数据库连接池的jar包，则会使用Tomcat数据库连接池；如果HikariCP的jar包和Tomcat数据库连接池的jar包都不存在，存在Commons DBCP2的jar包，则会使用DBCP2数据库连接池；如果上述三种数据库连接池的jar包都不存在，而Oracle UCP(Oracle Universal Connection Pool)相关jar包存在，则使用Oracle UCP数据库连接池。&lt;/p&gt;&lt;p&gt;既然，SpringBoot对数据库连接池的选择是使用上面的算法，是动态选择的，那为什么本文最开始说的是“如何将数据库连接池切换成Druid”呢？那是因为如果你的依赖管理中使用到了spring-boot-starter-jdbc或spring-boot-starter-data-jpa这两个starters，依赖列表中会自动依赖HikariCP，也就是说，此时默认使用的是HikariCP数据库连接池。&lt;/p&gt;&lt;p&gt;关于数据库连接池的性能和并发性，本文不做阐述，连接池的选择仁者见仁智者见智。接下来，我们看一下如何将默认的HikariCP切换成Druid，完整示例代码地址：https://github.com/wind7rui/SpringBoot2.x-example/tree/main/DataSource-Druid。&lt;/p&gt;&lt;h3&gt;排除HikariCP&lt;/h3&gt;&lt;p&gt;首先，删除依赖管理中的HikariCP依赖、排除依赖管理中的HikariCP传递依赖，spring-boot-starter-jdbc或spring-boot-starter-data-jpa这两个starters依赖中会传递依赖HikariCP，需要排除，以下以Maven构建管理工具为例。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4444444444444444&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKRciculGUcMDyyqka6cjTQqCfOONQqgzZibBa0N3E67yribiaabkTJnmswU0Mq8Fp7JfQqPjuL3ZiaDEhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1116&quot;/&gt;&lt;/p&gt;&lt;h3&gt;添加Druid依赖&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;添加Druid的jar包依赖，使用druid的starters：druid-spring-boot-starter。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.24691358024691357&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKRciculGUcMDyyqka6cjTQqCpuRdPAOvxG1IlRwjClXpjYgf8XWA79TuTvZMmUHavPic6iafiatWohoog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1134&quot;/&gt;&lt;/p&gt;&lt;h3&gt;配置Druid连接池参数&lt;/h3&gt;&lt;p&gt;在application.properties中添加Druid数据库连接池参数配置，以下为示例配置。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.71640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKRciculGUcMDyyqka6cjTQqCGzn7slmmuI07NPNkQ9CQnsLRGtf2nXwicCgIopnqhQzMzVgZtGOnDjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;完成以上步骤即完成了Druid连接池的切换，代码运行时就可以使用Druid数据库连接池了，是不是很简单！&lt;/p&gt;&lt;h2&gt;自动配置原理&lt;/h2&gt;&lt;p&gt;上述的示例通过简单的操作即完成了Druid连接池的切换，这其中就用到了SpringBoot的自动配置特性，官方说自动配置是聪明且智能的，下面我们一起来看一下这个聪明且智能的自动配置是如何实现的。&lt;/p&gt;&lt;p&gt;基于SpringBoot开发的代码一般都会有一个包含main()方法的应用启动类，并且会使用@SpringBootApplication注解标注在这个类上，例如如下代码。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.33460076045627374&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKRciculGUcMDyyqka6cjTQqCpgsbQWnfW0GzNEqRNxueotJApDzn5tvyzD4VUicqjvZzUGFDNbIwrwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1052&quot;/&gt;&lt;/p&gt;&lt;p&gt;分析自动配置原理的入口就从SpringApplication.run()开始，接下来的源码分析以重点代码为主，对于不重要的代码忽略分析。SpringApplication是SpringBoot提供用于通过Java main方法的方式启动Spring应用的启动类。进入SpringApplication类的run()方法，具体代码如下。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8046875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKRciculGUcMDyyqka6cjTQqCWQibLIib3R1EkfL9dX9NPaVbuG0YQWMXxLAwL9jhEic91zBkmsz5Pfxow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;上面的代码我们重点关注refreshContext(context)，这个方法的执行会进入Spring应用上下文里bean解析和bean对象的创建的方法，即AbstractApplicationContext中的refresh()方法，代码如下。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.31328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKRciculGUcMDyyqka6cjTQqCYzic9CmVzljt5je0VluBGjFrLl4IIFjWlReoHdE9Vg1rjttEgibj8bNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;看过Spring源码的对这个方法应该不陌生，这个方法是Spring Ioc容器启动时的核心方法，主要用于bean的解析、实例化、初始化、依赖注入、激活BeanFactory处理器、注册BeanPostProcessors等，这里我们重点关注invokeBeanFactoryPostProcessors(beanFactory)方法，这个方法用于激活各种BeanFactory处理器，即激活BeanFactoryPostProcessor接口的实现类，BeanFactoryPostProcessor可以在Spring Ioc容器实例化任何其它bean时读取bean的元数据和修改元数据，我们所熟知的PropertyPlaceholderConfigurer就是基于BeanFactoryPostProcessor接口实现的。invokeBeanFactoryPostProcessors(beanFactory)的执行会进入如下代码。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.27734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKRciculGUcMDyyqka6cjTQqCp1y9Ao9r9cdzNfibpn4qROfbbu7fVy96aSEJdCias21CLozM5MVj0iagg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors()方法会执行所有的BeanFactoryPostProcessors，这个方法内容很长，我们重点关注invokeBeanFactoryPostProcessors方法中调用的invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup())代码，具体代码如下。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.259375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKRciculGUcMDyyqka6cjTQqCFBNksPjiaBia9GOibdjycZQNv2OCWTnAaQxLsbbthxJWfFL3ZECdg8LJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;在这个for循环执行的时候会遍历执行ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry()方法，ConfigurationClassPostProcessor类实现了BeanFactoryPostProcessor接口，用于解析@Configuration注解标记的类，ConfigurationClassPostProcessor类的postProcessBeanDefinitionRegistry方法具体代码如下。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.29765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKRciculGUcMDyyqka6cjTQqCXWF8ibibhnwM5GQuszibKyYCwMUuBzMyiaok5TicQgJuAjAuYicYl3MwAibzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;上图中的代码，重点关注最后一行processConfigBeanDefinitions(registry)，这个方法执行的时候会通过ConfigurationClassParser的parse方法解析@Configuration注解标记的类，具体代码如下。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.50546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKRciculGUcMDyyqka6cjTQqCYoy5bVVoicDw1D55ibkf9lmRBfmJD3fkhrYMb6Rr9Roc8D0EQlfTtAaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里我们重点关注最后一行代码，deferredImportSelectorHandler.process()方法的执行会进入如下代码。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.34140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKRciculGUcMDyyqka6cjTQqCMprQ0bEHud9tBpfY0e9z5dBdT13AJ0RsibwJVZDp1Le0gunrBib9EhHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;上图的代码重点关注handler.processGroupImports()，这个方法的执行会解析@Configuration注解标记的类上的@Import注解，解析的过程中会调用@Import注解中value属性值类的process方法。&lt;/p&gt;&lt;p&gt;分析到这里，我们先回到应用启动类BootApplication，这个类被@SpringBootApplication注解标注，我们看一下这个注解的源码。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.23203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKRciculGUcMDyyqka6cjTQqCfpLJba0lt2XgLpyFR19z4t42XicG6LNahliafeRRzdbVCMIxFwnKREUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;它被@SpringBootConfiguration注解和@EnableAutoConfiguration注解标注，而@SpringBootConfiguration被@Configuration注解标注，@EnableAutoConfiguration被@Import注解标注，同时指定了@Import注解的value=AutoConfigurationImportSelector.class。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4074074074074074&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKRciculGUcMDyyqka6cjTQqCJKw0qicTeLunI5FIIicKCb35YXDZj5blSlSfR76CwgpQsxOkMxql2uwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们继续分析源码，此时我们可以看到前面对@Configuration注解标注的类进行解析的操作，其实就是对BootApplication，对@Import注解的解析就是对BootApplication上的@EnableAutoConfiguration中的@Import，所以，handler.processGroupImports()方法的执行最终会执行到AutoConfigurationImportSelector类中的AutoConfigurationGroup的process方法，具体代码如下。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.29453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKRciculGUcMDyyqka6cjTQqCghZAdc6SYfoHCh2nR2hpHlHTqT3pENwHKoPh1GIlsVTbNdiaIPDL7Mg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;上面的代码重点关注getAutoConfigurationEntry的执行，这里会调用AutoConfigurationImportSelector类的getAutoConfigurationEntry方法，具体代码如下。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.57578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKRciculGUcMDyyqka6cjTQqCkKUpu5cxuAnv6V44UuPjsiaWq0JAF6nDiaEBvWzBvwLRokVvO79XibTOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;getAutoConfigurationEntry方法的执行，最终会搜索类路径下所有jar包中META-INF/spring.factories文件中的所有EnableAutoConfiguration指定的类，这是什么意思呢，看下图就知道了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.35859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKRciculGUcMDyyqka6cjTQqC45SFiaibL6O57yMNOYpXlWeibcg8LMtyzKp2dZAkJDqBDciblVgOHcVhcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;从上图可以看到，SpringBoot的jar包中已经预设好了一些自动配置的类，这些自动配置的类会被getAutoConfigurationEntry方法检索到，返回一个自动配置类的列表，后续的流程将这些自动配置类解析成BeanDefinition，通过AbstractApplicationContext类refresh()方法中的finishBeanFactoryInitialization(beanFactory)完成自动配置类的实例化和初始化。那这些自动配置类都做了什么呢？我们以DispatcherServletAutoConfiguration为例，看一下它都自动帮我们做了什么，部分代码如下。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.0171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKRciculGUcMDyyqka6cjTQqC4FjOFibuwr0E0QF5ueUbv3TDUqcbxuStXFU6xK7NiaXlhDTn2wia5iaqaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;通过上图中的代码解释，可以看到DispatcherServletAutoConfiguration会自动实例化一个dispatcherServlet，但是必须满足一定的条件，如当前是web应用、存在spring-webmvc的jar包、当前Spring应用上下文中不存在DispatcherServlet实例、存在servlet的jar包等，自动配置类只有在被满足条件的情况下才可以被触发，执行一些bean的实例化操作，代替一些我们经常通过代码或配置实现的初始化或实例化bean的操作。&lt;/p&gt;&lt;p&gt;既然，SpringBoot自动配置是这样实现的，那Druid连接池的自动配置是不是这样的呢？我们打开druid-spring-boot-starter jar包META-INF路径下spring.factories文件看一下就明白了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.25078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKRciculGUcMDyyqka6cjTQqCd1Nu5NKFLGK36HiasgTiaN9bnY1JyK0hBydNg2Yicb98uPeuSRZFsECdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.34765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKRciculGUcMDyyqka6cjTQqCFic5B4IwyvRXoFKGBPCO8uBVFAaziaupsMObOQ4QWOE0RzVYGyELzKtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;通过上图可以看到，Druid的自动配置也是基于上述的原理实现的。SpringBoot提供了自动配置可扩展的口子，开发人员只要在jar包中META-INF/spring.factories文件中使用org.springframework.boot.autoconfigure.EnableAutoConfiguration作为key指定自定义的自动配置类，在SpringBoot应用启动时会自动触发自定义自动配置类的自动配置操作。&lt;/p&gt;&lt;p&gt;最后，对SpringBoot的自动配置原理做一个小结。使用SpringBoot开发的代码在运行时会搜索类路径下所有jar包中META-INF/spring.factories文件中所有以EnableAutoConfiguration为key指定的自动配置类，执行自动配置类的实例化和初始化，这些自动配置类是否会被实例化，需要满足一定条件，例如当前类路径下是否含有相应类的jar包等，满足条件则执行自动配置类中的一些实例化操作。&lt;/p&gt;&lt;h2&gt;自定义一个starter&lt;/h2&gt;&lt;p&gt;通过上面的分析，我们已经知道了SpringBoot中自动配置是如何玩转的，我们按照这个套路也来实现一个简单的starter：custom-starter，完整示例代码地址：https://github.com/wind7rui/SpringBoot2.x-example/tree/main/Custom-Starter。&lt;/p&gt;&lt;h3&gt;创建custom-starter项目&lt;/h3&gt;&lt;p&gt;新建项目custom-starter，在pom.xml中添加spring-boot-autoconfigure依赖：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.springframework.boot&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;spring-boot-autoconfigure&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;2.4.0&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;新增spring.factories文件&lt;/h3&gt;&lt;p&gt;在代码的resources目录下新建META-INF目录，然后在这个目录下新建spring.factories文件，文件内容以EnableAutoConfiguration为key指定的自动配置类。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;org&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;springframework&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;boot&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;autoconfigure&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;EnableAutoConfiguration&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;org&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;example&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;custom&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;spring&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;boot&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;autoconfigure&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;CustomAutoConfigure&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;新建Service&lt;/h3&gt;&lt;p&gt;创建HelloService接口和接口的实现类HelloServiceImpl，实现类的sayHello()方法只简单输出一行日志，代码如下。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;HelloService&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; sayHello&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;HelloServiceImpl&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;HelloService&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Logger&lt;/span&gt;&lt;span&gt; LOGGER &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;LoggerFactory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getLogger&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;HelloServiceImpl&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; sayHello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        LOGGER&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;hello&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;新建自动配置类CustomAutoConfigure&lt;/h3&gt;&lt;p&gt;自动配置类CustomAutoConfigure用于实例化一个HelloServiceImpl类的对象，创建bean实例时会输出初始化日志，具体代码如下。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;@ConditionalOnClass&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;HelloServiceImpl&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;CustomAutoConfigure&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Logger&lt;/span&gt;&lt;span&gt; LOGGER &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;LoggerFactory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getLogger&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;CustomAutoConfigure&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;@Bean&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;@ConditionalOnMissingBean&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;HelloService&lt;/span&gt;&lt;span&gt; helloService&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        LOGGER&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Init helloService&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;HelloServiceImpl&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;打Starter jar包&lt;/h3&gt;&lt;p&gt;将当前项目代码打包成jar包。&lt;/p&gt;&lt;h3&gt;引入自定义custom-starter&lt;/h3&gt;&lt;p&gt;在使用的项目代码的pom.xml中添加custom-starter jar包依赖。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.example&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;custom-starter&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;1.0-SNAPSHOT&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;验证custom-starter&lt;/h3&gt;&lt;p&gt;编写单元测试类CustomStarterTest.java，验证Starter是否可以正常使用，具体代码如下。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;@RunWith&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;SpringRunner&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;@SpringBootTest&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;CustomStarterTest&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;HelloService&lt;/span&gt;&lt;span&gt; helloService&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; test&lt;/span&gt;&lt;span&gt;(){&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        helloService&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.07578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKRciculGUcMDyyqka6cjTQqCjjbzYc852GaD064u6MuGKbhZ9NIzQZoTUxFX2CiazxLmOWiaYawHibX2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;从上图的执行结果可以看到，单元测试类启动的时候会通过CustomAutoConfigure实例化一个HelloServiceImpl对象。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;往期推荐&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484919&amp;amp;idx=1&amp;amp;sn=42d5db381f05f954e72b1334055f1cfe&amp;amp;chksm=e9bf5769dec8de7fa90e512ad91aff17c60d394c52bfa1cd8477753a53455cec8adfbb2cd09a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;深入Spring Boot (十五)：web.xml去哪了&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484919&amp;amp;idx=1&amp;amp;sn=42d5db381f05f954e72b1334055f1cfe&amp;amp;chksm=e9bf5769dec8de7fa90e512ad91aff17c60d394c52bfa1cd8477753a53455cec8adfbb2cd09a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484903&amp;amp;idx=1&amp;amp;sn=71e5df964c90d71c3e757ed2272bc6c6&amp;amp;chksm=e9bf5779dec8de6f6de0566e374de74529571c1fa07884bf9fc881b5d4a819621fc6d51da68a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;深入Spring Boot (十四)：jar/war打包解决方案&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484878&amp;amp;idx=1&amp;amp;sn=daee4e4702b0d3a44daf8599501d72e8&amp;amp;chksm=e9bf5750dec8de4656a9aaf85ada2ca8042921c8e52b57c494cc9af52e615e19fb101a485103&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;Java开发人员必知的常用类库，这些你都知道吗？&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484871&amp;amp;idx=1&amp;amp;sn=74ede98f0281459c8ded84bd5178caa0&amp;amp;chksm=e9bf5759dec8de4fa24d29ada560d50e73dd35264a02fdd85aab44c4a931af8f1f6e47d1b683&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;聊一聊Redis官方置顶推荐的Java客户端Redisson&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484828&amp;amp;idx=1&amp;amp;sn=bbdfbbed2c5e97dd58386df08fc011db&amp;amp;chksm=e9bf5702dec8de14016f5468ee387d8b326cdec0eca0013e8b5b95d945897f64a6cb817793d3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;我画了25张图展示线程池工作原理和实现原理，原创干货，建议先收藏再阅读&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484763&amp;amp;idx=1&amp;amp;sn=a67f151b04967d149c2b60ed648e5dbf&amp;amp;chksm=e9bf57c5dec8ded33ccfc6cd269c4736eec528b8e6ab4cc6c2beb11deb744e7f78d7b61ec72b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;Spring框架你敢写精通，面试官就敢问@Autowired注解的实现原理&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484742&amp;amp;idx=1&amp;amp;sn=54e9e3e9de14d3681a8d426d90f5d687&amp;amp;chksm=e9bf57d8dec8decec68531bd74f92a6dba3fb4e74564c27fa9933ece75290d27ffa317a4a8ae&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;面试被问为什么使用Spring Boot？答案好像没那么简单&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484730&amp;amp;idx=1&amp;amp;sn=dd043e8eb2fbf4ca7df266aabed45443&amp;amp;chksm=e9bf57a4dec8deb2e7162250c559dd4d2189681f6e08b37da371d04867698a26b9be062fc24b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;Spring声明式事务处理的实现原理，来自面试官的穷追拷问&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484712&amp;amp;idx=1&amp;amp;sn=982a0801e878700b42b48f7fae3e5f30&amp;amp;chksm=e9bf57b6dec8dea04544c551c8206897f66efb81f49532b65df4ff878ad284c261b48ad9e3dd&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;没使用加号拼接字符串，面试官竟然问我为什么&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484707&amp;amp;idx=1&amp;amp;sn=3eea7537f43fcf0cd646d9bc64fd657f&amp;amp;chksm=e9bf57bddec8deab4ffea25c68197d82c1b46ba58ad0963c9fc0ee6d79f9c47c29660875187f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;面试官一步一步的套路你，为什么SimpleDateFormat不是线程安全的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484701&amp;amp;idx=1&amp;amp;sn=67ba3d2cedbd7a475371acfc474210e1&amp;amp;chksm=e9bf5783dec8de95e76115bc1fbd14401f8b41030d7aa5ebd42894eba56f138fd03f153718a4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;都说ThreadLocal被面试官问烂了，可为什么面试官还是喜欢继续问&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484696&amp;amp;idx=1&amp;amp;sn=54c8b5ad9373d88564032c8bc4bc0926&amp;amp;chksm=e9bf5786dec8de90506632f193789cc088165985e35320a5e2a64f6a1230f5d74c9118a811af&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;Java注解是如何玩转的，面试官和我聊了半个小时&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;学之多，而后知之少&lt;/strong&gt;&lt;span&gt;！朋友们点【在看】是我持续更新的最大动力!&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-type=&quot;png&quot; data-ratio=&quot;0.5555555555555556&quot; data-w=&quot;900&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKSxTAD3licFmGltOsliao1ZVHCicnRtbiarMjXCkm2y0FjRlsJ596O4ibOAoOib1XWGhXlYX8x0wYXIPfxg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>141790ee85b3d8e205ff0c14c67d866a</guid>
<title>一文告诉你 Java 日期时间 API 到底有多烂</title>
<link>https://toutiao.io/k/9pfrirv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKIoOYDuC4PxWUI2D7BefiaCyAjRgfbOEfUcQQ6DvmLI4lze2fUI0wAE9ZicUSexzJzyKvLGNLAqicQIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，我是A哥(YourBatman)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好看的代码，千篇一律！难看的代码，卧槽卧槽~其实没有什么代码是“史上最烂”的，要有也只有“史上更烂”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日期是商业逻辑计算的一个&lt;strong&gt;关键部分&lt;/strong&gt;，任何企业的程序都需要正确的处理日期时间问题，否则很可能带来事故和损失。为此本系列仅着眼于这一个点就写了好几篇文章，目的是帮助你系统化的搞定所有问题/难题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;平时我们都热衷于吐槽同事的代码有多烂，今天我们就来玩点狠的：吐槽吐槽JDK，看看它的日期时间API设计得到底有多烂。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;说明：本文指的日期时间API是Date/Calendar系列，而非Java 8新的API。毕竟一般我们称后者为JSR 310日期时间，请注意区分哈&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;本文提纲&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6238437821171634&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKIoOYDuC4PxWUI2D7BefiaCyaxBIuTxc7MSWoibBM11MrjgCloNiaskJzjEVhSF7O8xUcDpg0mXlvDBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;973&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;版本约定&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;正文&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;诚然，Java的API绝大多数设计得都是非常优秀且成功的，否则Java也不可能成为编程语言界的常青藤，并且还常年霸榜。&lt;strong&gt;但是&lt;/strong&gt;，JDK也有失手的地方，存在设计得非常烂的API，先来了解下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最烂API投票&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;谈到对Java API不满意程度的调研，最出名的当属2010年国外一个大佬Tiago Fernandez发起的一个很有意思的投票，投票结果的数据统计图表如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.437125748502994&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKIoOYDuC4PxWUI2D7BefiaCy2MF41wOic1PnkObFIkbp3uVFfsfGPUkdicV0Bw9rLOfotRsWruPnZficw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;835&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对横向标题栏的各个单词解释一下，从左到右依次为：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKIoOYDuC4PxWUI2D7BefiaCyAp6FnwjDibQM0uibIMLJFg50ib0mbC0uW29bMIQPBl5c1OzdpNkdRGJ3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;585&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算最终得分的公式为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Score = (I can live with) + (Painful * &lt;span&gt;2&lt;/span&gt;) + (Crappy * &lt;span&gt;3&lt;/span&gt;) + (Hellish * &lt;span&gt;4&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照此公式，计算出各API的得分，画成直方图直观的展示出来：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.761118170266836&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKIoOYDuC4PxWUI2D7BefiaCy1UbMicor3JIpg3qMs4D83qTfMLvnHvt6qrzYY40O6FZ1abojBcTiaDww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;787&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好，排名出来了。从最烂 -&amp;gt; 最好的名次依次为：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;EJB 2.x，简直“遥遥领先”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Date/Time/Calendar，今天的猪脚&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;XML/DOM&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AWT/Swing&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;...&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;烂归烂，想一想什么样的烂API对你的产生影响会是最大的呢？答：&lt;strong&gt;很常用却很烂的&lt;/strong&gt;。倘若一个API设计得很烂但你很少用或者几乎不用接触，你也不会对它产生很大厌恶感。打个比方，一堆屎本身很臭，但若你并不需要走到它身旁也就闻不到，自然就不会觉得它有多碍眼了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到这个统计结果来，EJB 2.x的API设计得最烂这个结果无可厚非，但站在时间维度的现在(2021年)回头来看，是可以完全忽略它了，毕竟现在的我们绝无可能再接触到它，再烂又有何干呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;EJB 2.x这个老古董，相信在看文章的绝大部分同学都没见过甚至没听过它吧，A哥2015年入行，一上来Spring 4.x嘎嘎就是干，从未接触过EJB。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;说明：这个统计是2010年做的，那会EJB2.x的使用量还比较大，因此上了“榜首”&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;XML/DOM设计得也不好，但已完全被第三库（如dom4j）取代，后者成为了事实的标准；AWT/Swing是市场的抉择，你用Java开发界面才会用到，否则不会接触，属于正常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后再看“屈居”第二名的Date/Time/Calendar日期时间API，它就不得了了。毕竟此API有个很大的特点：哪怕到了现在(2021年)依旧非常常用。所以，它设计得烂带来的实际影响是蛮大的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面就来具体了解下它有哪些坑爹的设计和槽点，一起不吐不快。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;日期时间API的七宗罪&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKIoOYDuC4PxWUI2D7BefiaCyHkBNI10XHboWg3WJA6ibiasv4ib0sGfZDjuZekrGibf35BPUNka0CZpTXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;罪状一：Date同时表示日期和时间&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java.util.Date被设计为日期 + 时间的结合体。也就是说如果只需要日期，或者只需要单纯的时间，用Date是做不到的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    System.out.println(&lt;span&gt;new&lt;/span&gt; Date());&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;输出：&lt;br/&gt;Fri Jan &lt;span&gt;22&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;:&lt;span&gt;06&lt;/span&gt; CST &lt;span&gt;2021&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就导致语义非常的不清晰，比如说：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 是否是假期&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isHoliday&lt;/span&gt;&lt;span&gt;(Date date)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;  ...;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;判断某一天是否是假期，只和日期有关，和具体时间没有关系。如果代码这样写语义只能靠注释解释，方法本身无法达到自描述的效果，也无法通过强类型去约束，因此容易出错。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;说明：本文所有例子不考虑时区问题，下同&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;罪状二：坑爹的年月日&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Date date = &lt;span&gt;new&lt;/span&gt; Date();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;当前日期时间：&quot;&lt;/span&gt; + date);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;年份：&quot;&lt;/span&gt; + date.getYear());&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;月份：&quot;&lt;/span&gt; + date.getMonth());&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;输出：&lt;br/&gt;当前日期时间：Fri Jan &lt;span&gt;22&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt; CST &lt;span&gt;2021&lt;/span&gt;&lt;br/&gt;年份：&lt;span&gt;121&lt;/span&gt;&lt;br/&gt;月份：&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;what？年份是121年，这什么鬼？月份返回0，这又是什么鬼？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无奈，看看这两个方法的Javadoc：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2869198312236287&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKIoOYDuC4PxWUI2D7BefiaCy381qUy9Ot4gCWsKOef71YGdefAADNtBciaP9d9gic6eAb6rLx4okicY1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;474&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.27431906614785995&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKIoOYDuC4PxWUI2D7BefiaCyN352wOgea1SaXxNIaYuBzdCDOT6DltxnoZLricviaic7qzD5JE1tzKMUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;514&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尼玛，原来 2021 - 1900 = 121是这么来的。那么问题来了，为何是1900这个数字呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;月份，竟然从0开始，这是学的谁呢？简直打破了我认为的只有index索引值才是从0开始的认知啊，这种做法非常的不符合人类思维有木有。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;索引值从0开始就算了，毕竟那是给计算机看的无所谓，但是你这月份主要是给人看的呀&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;罪状三：Date是可变的&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;oh my god，也就是说我把一个Date日期时间对象传给你，你竟然还能给我改掉，真是太没安全感可言了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Date currDate = &lt;span&gt;new&lt;/span&gt; Date();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;当前日期是①：&quot;&lt;/span&gt; + currDate);&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; holiday = isHoliday(currDate);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;是否是假期：&quot;&lt;/span&gt; + holiday);&lt;br/&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;当前日期是②：&quot;&lt;/span&gt; + currDate);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 是否是假期&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isHoliday&lt;/span&gt;&lt;span&gt;(Date date)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 架设等于这一天才是假期，否则不是&lt;/span&gt;&lt;br/&gt;    Date holiday = &lt;span&gt;new&lt;/span&gt; Date(&lt;span&gt;2021&lt;/span&gt; - &lt;span&gt;1900&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt; - &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (date.getTime() == holiday.getTime()) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 模拟写代码时不注意，使坏&lt;/span&gt;&lt;br/&gt;        date.setTime(holiday.getTime());&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;输出：&lt;br/&gt;当前日期是①：Fri Jan &lt;span&gt;22&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;41&lt;/span&gt;:&lt;span&gt;59&lt;/span&gt; CST &lt;span&gt;2021&lt;/span&gt;&lt;br/&gt;是否是假期：&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;当前日期是②：Fri Oct &lt;span&gt;01&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; CST &lt;span&gt;2021&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我就像让你帮我判断下遮天是否是假期，然后你竟然连我的日期都给我改了？过分了啊。这是多么可怕的事，存在重大安全隐患有木有。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这种case，一般来说我们函数内部操作的参数只能是&lt;strong&gt;副本&lt;/strong&gt;：要么调用者传进来的就是副本，要么内部自己生成一个副本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本利中提高程序健壮性只需在isHoliday首行加入这句代码即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isHoliday&lt;/span&gt;&lt;span&gt;(Date date)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    date = (Date) date.clone();&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再次运行程序，输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;当前日期是①：Fri Jan &lt;span&gt;22&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;44&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt; CST &lt;span&gt;2021&lt;/span&gt;&lt;br/&gt;是否是假期：&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;当前日期是②：Fri Jan &lt;span&gt;22&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;44&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt; CST &lt;span&gt;2021&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bingo。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是呢，Date作为高频使用的API，并不能要求每个程序员都有这种安全意识，毕竟即使百密也会有一疏。所以说，把Date设计为一个可变的类是非常糟糕的设计。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;罪状四：无法理喻的java.sql.Date&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来，看看java.util.Date类的继承结构：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3926553672316384&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKIoOYDuC4PxWUI2D7BefiaCydBrzxwMlnGHkA8DgYJ3OkjW6L5ysTCwW2LvscMnNicaibjcULxKSHurg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;354&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的三个子类均处于java.sql包内。且先不谈这种垮包继承的合理性问题，直接看下面这个使用例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 竟然还没有空构造器&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// java.util.Date date = new java.sql.Date();&lt;/span&gt;&lt;br/&gt;    java.util.Date date = &lt;span&gt;new&lt;/span&gt; java.sql.Date(System.currentTimeMillis());&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 按到当前的时分秒&lt;/span&gt;&lt;br/&gt;    System.out.println(date.getHours());&lt;br/&gt;    System.out.println(date.getMinutes());&lt;br/&gt;    System.out.println(date.getSeconds());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行程序，暴雷了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java.lang.IllegalArgumentException&lt;br/&gt; at java.sql.Date.getHours(Date.java:&lt;span&gt;187&lt;/span&gt;)&lt;br/&gt; at com.yourbatman.formatter.DateTester.test3(DateTester.java:&lt;span&gt;65&lt;/span&gt;)&lt;br/&gt; ...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;what？又是一打破认知的结果啊，第一句getHours()就报错啦。走进java.sql.Date的方法源码进去一看，握草重写了父类方法：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.13367609254498714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKIoOYDuC4PxWUI2D7BefiaCyHtWtVpQibSyfNqn4V85VDHvgcIeO1mtqo7AGGAGpLZnz0qRXHMvvd9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;389&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有这么重写父类方法的？还有王法吗？这也算是JDK能干出来的事？赤裸裸的违背里氏替换原则等众多设计原则，子类能力竟然比父类小，使用起来简直让人云里雾里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java.util.Date的三个子类均位于java.sql包内，他们三是通过Javadoc描述来进行分工的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;java.sql.Date：只表示日期&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;java.sql.Time：只表示时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;java.sql.Timestamp：表示日期 + 时间&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么一来，似乎可以“理解”java.sql.Date为何重写父类的getHours()方法改为抛出IllegalArgumentException异常了，毕竟它只能表示日期嘛。但是这种通过继承再阉割的实现手法你们接受得了？反正我是不能的~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;罪状五：无法处理时区&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为日期时间的特殊性，不同的国家地区在&lt;strong&gt;同一时刻&lt;/strong&gt;显示的日期时间应该是不一样的，但Date做不到，因为它底层代码是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6878787878787879&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKIoOYDuC4PxWUI2D7BefiaCyZhAGiby7US7jBZa1PHaXWHYfwcicGMm6v82ZqibCaeUDzYznEQzSAnIGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;330&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说它表示的是一个具体时刻（时间戳），这个数值放在全球任何地方都是一模一样的，也就是说new Date()和System.currentTimeMillis()没啥两样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK提供了TimeZone表示时区的概念，但它在Date里并无任何体现，只能使用在格式化器上，这种设计着实让我再一次看不懂了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;罪状六：线程不安全的格式化器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于Date的格式化，站在架构设计的角度来看，首先不得不吐槽的是Date明明属于java.util包，那么它的格式化器DateFormat为毛却跑到java.text里去了呢？这种依赖管理的什么鬼？是不是有点太过于随意了呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，JDK提供了一个DateFormat的子类实现SimpleDateFormat专门用于格式化日期时间。&lt;strong&gt;但是&lt;/strong&gt;它却被设计为了线程不安全的，一个定位为模版组件的API竟然被设计为线程不安全的类，实属瞎整。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就因为这个坑的存在，让多少初中级工程师泪洒职场，算了说多了都是泪。另外，因为线程不安全问题并非必现问题，因此在黑盒/白盒测试、功能测试阶段都可能测不出来，留下潜在风险。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;这就是“灵异事件”：测试环境测试得好好的，为何到线上就出问题了呢？&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;罪状七：Calendar难当大任&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从JDK 1.1 开始，Java日期时间API似乎进步了些，引入了Calendar类，并且对职责进行了划分：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Calendar类：日期和时间字段之间转换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DateFormat类：格式化和解析字符串&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Date类：&lt;strong&gt;只&lt;/strong&gt;用来承载日期和时间&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了Calendar后，原有Date中的大部分方法均标记为废弃，交由Calendar代替。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2402044293015333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKIoOYDuC4PxWUI2D7BefiaCyy2NpOYW19AAicwj56CLbdAVEU7EQiaOH1nwfeibBHSb99l6mjKgLv2N5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;587&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Date终于单纯了些：只需要展示日期时间而无需再顾及年月日操作、格式化操作等等了。值得注意的是，这些方法只是被标记为过期，并未删除。即便如此，请在实际开发中也&lt;strong&gt;一定不要使用&lt;/strong&gt;它们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入了一个Calendar似乎分离了职责，但Calendar难当大任，设计上依旧存在很多问题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test4&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Calendar calendar = Calendar.getInstance(TimeZone.getDefault());&lt;br/&gt;    calendar.set(&lt;span&gt;2021&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;); &lt;span&gt;// -&amp;gt; 依旧是可变的&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    System.out.println(calendar.get(Calendar.YEAR));&lt;br/&gt;    System.out.println(calendar.get(Calendar.MONTH));&lt;br/&gt;    System.out.println(calendar.get(Calendar.DAY_OF_MONTH));&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;输出：&lt;br/&gt;&lt;span&gt;2021&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;年月日的处理上似乎可以接受没有问题了。从结果中可以发现，Calendar年份的传值不用再减去1900了，这和Date是不一样的，不知道这种行为不一致会不会让有些人抓狂。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;说明：Calendar相关的API是由IBM捐过来的，所以和Date不一样貌似也“情有可原”&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，还有个重点是Calendar依旧是可变的，所以存在不安全因素，参与计算改变值时请使用其副本变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总的来说，Calendar在Date的基础上做了改善，但仅限于修修补补，&lt;strong&gt;并未从根本上解决问题&lt;/strong&gt;。最重要的是Calendar的API使用起来真的很不方便，而且该类在语义上也完全不符合日期/时间的含义，使用起来更显尴尬。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之，无论是Date，还是Calendar，还是格式化DateFormat都用着太方便，且存在各式各样的安全隐患、线程安全问题等等，这是API没有设计好的地方。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;并不孤单&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日期时间API属于基础API，在各个语言中都是必备的。然而不仅仅是Java面临着API设计很烂的处境，有些其它流行语言一样如此，涌现出1个(1堆)三方库比乙方库设计更好的情况，比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Python&lt;/strong&gt;：日期时间处理库Arrow&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;JavaScript&lt;/strong&gt;：日期时间处理库Moment.js&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;.Net&lt;/strong&gt;：日期时间处理库Joda-Time&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以说，Java它并不孤单（自我安慰一把）&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;自我救赎：JSR 310&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为原生的Date日期时间体系存在“&lt;strong&gt;七宗罪&lt;/strong&gt;”，催生了第三方Java日期时间库的诞生，如大名鼎鼎的Joda-Time的流行甚至一度成为标配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于Java来说，如此重要的API模块岂能被第三方库给占据，开发者本就想简单的处理个日期时间还得导入第三方库，使用也太不方便了吧。当时的Java如日中天，因此就开启了“收编”Joda-Time之旅。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2013年9月份，具有划时代意义的Java 8大版本正式发布，该版本带来了非常多的新特性，其中最引入瞩目之一便是全新的日期时间API：JSR 310。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.117391304347826&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKIoOYDuC4PxWUI2D7BefiaCyqSxnaNgFtEAq3iay834XCM38ckN0vlZ6bQYed2nFA045AKYjWUtbgng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;460&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JSR 310规范的领导者是Stephen Colebourne，此人也是Joda-Time的缔造者。不客气的说JSR 310是在Joda-Time的基础上建立的，参考了其绝大部分的API实现，因此若你之前是Joda-Time的重度使用者，现在迁移到Java 8原生的JSR 310日期时间上来几乎无缝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即便这样，也并不能说JSR 310就完全等于Joda-Time的官方版本，还是有些许诧异的，例举如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先当然是包名的差别，org.joda.time -&amp;gt; java.time标准日期时间包&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;JSR 310不接受null值，Joda-Time把Null值当0处理&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JSR 310所有抛出的异常是DateTimeException，它是个RuntimeException，而Joda-Time都是checked exception&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单感受下JSR 310 API：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test5&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    System.out.println(LocalDate.now(ZoneId.systemDefault()));&lt;br/&gt;    System.out.println(LocalTime.now(ZoneId.systemDefault()));&lt;br/&gt;    System.out.println(LocalDateTime.now(ZoneId.systemDefault()));&lt;br/&gt;&lt;br/&gt;    System.out.println(OffsetTime.now(ZoneId.systemDefault()));&lt;br/&gt;    System.out.println(OffsetDateTime.now(ZoneId.systemDefault()));&lt;br/&gt;    System.out.println(ZonedDateTime.now(ZoneId.systemDefault()));&lt;br/&gt;&lt;br/&gt;    System.out.println(DateTimeFormatter.ISO_LOCAL_DATE.format(LocalDate.now()));&lt;br/&gt;    System.out.println(DateTimeFormatter.ISO_LOCAL_TIME.format(LocalTime.now()));&lt;br/&gt;    System.out.println(DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(LocalDateTime.now()));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JSR 310的所有对象都是&lt;strong&gt;不可变&lt;/strong&gt;的，所以线程安全。和老的日期时间API相比，&lt;strong&gt;最主要&lt;/strong&gt;的特征对比如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt; JSR 310&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;Date/Calendar&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;流畅的API&lt;/td&gt;&lt;td&gt;难用的API&lt;/td&gt;&lt;td&gt;API设计的好坏最直接影响编程体验，前者大大大大优于后者&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;实例不可变&lt;/td&gt;&lt;td&gt;实例可变&lt;/td&gt;&lt;td&gt;对于日期时间实例，设计为可变确实不合理也不安全。都不敢放心的传递给其它函数使用&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;线程安全&lt;/td&gt;&lt;td&gt;线程不安全&lt;/td&gt;&lt;td&gt;此特性直接决定了编码方式和健壮性&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于JSR 310日期时间更多介绍此处就不展开了，毕竟前面文章啰嗦过好多次了。总之它是Java的新一代日期时间API，设计得非常好，&lt;strong&gt;几乎没有缺点可言&lt;/strong&gt;，可用于100%替代老的日期时间API。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你到现在2021年了还没拥抱它，那么请问你还在等啥呢？&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日期时间API因为过于常用，因此你可能都觉得它毫不起眼。坦白的说，如果你没有复杂的日期时间需求要处理，如涉及到时区、偏移量、跨时区转换、国际化显示等等，那么可能觉得Date也能将就。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果你不想做个将就的人，如果你想拥有更好的日期时间编程体验，弃用Date，拥抱JSR 310吧。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;本文思考题&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;看完了不一定懂，看懂了不一定会&lt;/strong&gt;。来，文末3个思考题帮你复盘：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;偏移量Z代表什么含义？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ZoneId和ZoneOffset是如何建立对应关系的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若某个城市不在ZoneId列表里面，想要获取其UTC偏移量该怎么破？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0MTUwOTgyOQ==&amp;amp;mid=2247491787&amp;amp;idx=1&amp;amp;sn=37e8b0af5a7ffda54003d4280a70d638&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;GMT UTC CST ISO 夏令时 时间戳，都是些什么鬼？&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0MTUwOTgyOQ==&amp;amp;mid=2247491866&amp;amp;idx=1&amp;amp;sn=f33a4dc680f031891a4cf3d43459aff5&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;全网最全！彻底弄透Java处理GMT/UTC日期时间&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0MTUwOTgyOQ==&amp;amp;mid=2247492014&amp;amp;idx=1&amp;amp;sn=2c4e23376ae3e9ae405a840f6eb02395&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;LocalDateTime、OffsetDateTime、ZonedDateTime互转，这一篇绝对喂饱你&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关注我&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分享、成长，拒绝浅藏辄止。关注【BAT的乌托邦】回复关键字&lt;strong&gt;专栏&lt;/strong&gt;有Spring技术栈、中间件等小而美的纯原创专栏。本文已被 https://www.yourbatman.cn 收录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文所属专栏：&lt;strong&gt;JDK日期时间&lt;/strong&gt;，公号后台回复专栏名即可获取全部内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;A哥(YourBatman)：Spring Framework/Boot开源贡献者，Java架构师。&lt;strong&gt;非常注重基本功修养&lt;/strong&gt;，相信底层基础决定上层建筑，坚实基础才能焕发程序员更强生命力。文章特点为以小而美专栏形式重构知识体系，抽丝剥茧，致力于做人人能看懂的最好的专栏系列。可加我好友(&lt;strong&gt;fsx1056342982&lt;/strong&gt;)共勉哦！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9831460674157303&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/crPesQVeyKIoOYDuC4PxWUI2D7BefiaCyofsA8iaJMhEq32NmWrPEymYOmQpicicbuZ0icpnwicmHdmgkWibvLxBR1soA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;178&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4902cb2f8dc2971e54756cf313117d54</guid>
<title>Go：httpclient 常用操作</title>
<link>https://toutiao.io/k/occ7kwj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;模块介绍&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;httpclient&lt;/code&gt; 是基于 &lt;code&gt;net/http&lt;/code&gt; 封装的 Go HTTP 客户端请求包，支持常用的请求方式、常用设置，比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;支持设置 Mock 信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持设置失败时告警&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持设置失败时重试&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持设置项目内部的 Trace&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持设置超时时间、Header 等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;请求说明&lt;/span&gt;&lt;/h2&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法名&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;httpclient.Get()&lt;/td&gt;&lt;td&gt;GET 请求&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;httpclient.Post()&lt;/td&gt;&lt;td&gt;POST 请求&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;httpclient.PostForm()&lt;/td&gt;&lt;td&gt;POST 请求，form 形式&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;httpclient.PostJSON()&lt;/td&gt;&lt;td&gt;POST 请求，json 形式&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;httpclient.PutForm()&lt;/td&gt;&lt;td&gt;PUT 请求，form 形式&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;httpclient.PutJSON()&lt;/td&gt;&lt;td&gt;PUT 请求，json 形式&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;httpclient.PatchForm()&lt;/td&gt;&lt;td&gt;PATCH 请求，form 形式&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;httpclient.PatchJSON()&lt;/td&gt;&lt;td&gt;PATCH 请求，json 形式&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;httpclient.Delete()&lt;/td&gt;&lt;td&gt;DELETE 请求&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置说明&lt;/span&gt;&lt;/h2&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;配置项&lt;/th&gt;&lt;th&gt;配置方法&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;设置 TTL 本次请求最大超时时间&lt;/td&gt;&lt;td&gt;httpclient.WithTTL(ttl time.Duration)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;设置 Header 信息&lt;/td&gt;&lt;td&gt;httpclient.WithHeader(key, value string)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;设置 Logger 信息&lt;/td&gt;&lt;td&gt;httpclient.WithLogger(logger *zap.Logger)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;设置 Trace 信息&lt;/td&gt;&lt;td&gt;httpclient.WithTrace(t trace.T)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;设置 Mock 信息&lt;/td&gt;&lt;td&gt;httpclient.WithMock(m Mock)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;设置失败时告警&lt;/td&gt;&lt;td&gt;httpclient.WithOnFailedAlarm(alarmTitle string, alarmObject AlarmObject, alarmVerify AlarmVerify)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;设置失败时重试&lt;/td&gt;&lt;td&gt;httpclient.WithOnFailedRetry(retryTimes int, retryDelay time.Duration, retryVerify RetryVerify)&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;设置 TTL&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 设置本次请求最大超时时间为 5s&lt;/span&gt;&lt;br/&gt;httpclient.WithTTL(time.Second*&lt;span&gt;5&lt;/span&gt;),&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;设置 Header 信息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以调用多次进行设置多对 key-value 信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 设置多对 key-value 信息，比如这样：&lt;/span&gt;&lt;br/&gt;httpclient.WithHeader(&lt;span&gt;&quot;Authorization&quot;&lt;/span&gt;, &lt;span&gt;&quot;xxxx&quot;&lt;/span&gt;),&lt;br/&gt;httpclient.WithHeader(&lt;span&gt;&quot;Date&quot;&lt;/span&gt;, &lt;span&gt;&quot;xxxx&quot;&lt;/span&gt;),&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;设置 Logger 信息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传递的 logger 便于 httpclient 打印日志。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 使用上下文中的 logger，比如这样：&lt;/span&gt;&lt;br/&gt;httpclient.WithLogger(ctx.Logger()),&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;设置 Trace 信息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传递的 trace 便于记录使用 httpclient 调用第三方接口的链路日志。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 使用上下文中的 trace，比如这样：&lt;/span&gt;&lt;br/&gt;httpclient.WithTrace(ctx.Trace()),&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;设置 Mock 信息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Mock 类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Mock &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(body []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 需实现 Mock 方法，比如这样：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;MockDemoPost&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(body []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; res := &lt;span&gt;new&lt;/span&gt;(demoPostResponse)&lt;br/&gt; res.Code = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt; res.Msg = &lt;span&gt;&quot;ok&quot;&lt;/span&gt;&lt;br/&gt; res.Data.Name = &lt;span&gt;&quot;mock_Name&quot;&lt;/span&gt;&lt;br/&gt; res.Data.Job = &lt;span&gt;&quot;mock_Job&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; body, _ = json.Marshal(res)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; body&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 使用时：&lt;/span&gt;&lt;br/&gt;httpclient.WithMock(MockDemoPost),&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传递的 Mock 方式便于设置调用第三方接口的 Mock 数据。只要约定了接口文档，即使对方接口未开发时，也不影响数据联调。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;设置失败时告警&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// alarmTitle 设置失败告警标题 String&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// AlarmObject 告警通知对象，可以是邮件、短信或微信&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; AlarmObject &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; Send(subject, body &lt;span&gt;string&lt;/span&gt;) error&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 需要去实现 AlarmObject 接口，比如这样：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; _ httpclient.AlarmObject = (*AlarmEmail)(&lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; AlarmEmail &lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(a *AlarmEmail)&lt;/span&gt; &lt;span&gt;Send&lt;/span&gt;&lt;span&gt;(subject, body &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; options := &amp;amp;mail.Options{&lt;br/&gt;  MailHost: &lt;span&gt;&quot;smtp.163.com&quot;&lt;/span&gt;,&lt;br/&gt;  MailPort: &lt;span&gt;465&lt;/span&gt;,&lt;br/&gt;  MailUser: &lt;span&gt;&quot;xx@163.com&quot;&lt;/span&gt;,&lt;br/&gt;  MailPass: &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;  MailTo:   &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;  Subject:  subject,&lt;br/&gt;  Body:     body,&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; mail.Send(options)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// AlarmVerify 定义符合告警的验证规则&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; AlarmVerify &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(body []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(shouldAlarm &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 需要去实现 AlarmVerify 方法，比如这样：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;alarmVerify&lt;/span&gt;&lt;span&gt;(body []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(shouldalarm &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(body) == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;type&lt;/span&gt; Response &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;  Code &lt;span&gt;int&lt;/span&gt; &lt;span&gt;`json:&quot;code&quot;`&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; resp := &lt;span&gt;new&lt;/span&gt;(Response)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err := json.Unmarshal(body, resp); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 当第三方接口返回的 code 不等于约定的成功值（1）时，就要进行告警&lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; resp.Code != &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 使用时：&lt;/span&gt;&lt;br/&gt;httpclient.WithOnFailedAlarm(&lt;span&gt;&quot;接口告警&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;(third_party_request.AlarmEmail), alarmVerify),&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;设置失败时重试&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// retryTimes 设置重试次数 Int，默认：3&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// retryDelay 设置重试前延迟等待时间 time.Duration，默认：time.Millisecond * 100&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// RetryVerify 定义符合重试的验证规则&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; RetryVerify &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(body []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(shouldRetry &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 需要去实现 RetryVerify 方法，比如这样：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;retryVerify&lt;/span&gt;&lt;span&gt;(body []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(shouldRetry &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(body) == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;type&lt;/span&gt; Response &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;  Code &lt;span&gt;int&lt;/span&gt; &lt;span&gt;`json:&quot;code&quot;`&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; resp := &lt;span&gt;new&lt;/span&gt;(Response)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err := json.Unmarshal(body, resp); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 当第三方接口返回的 code 等于约定值（10010）时，就要进行重试&lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; resp.Code = &lt;span&gt;10010&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// RetryVerify 也可以为 nil , 当为 nil 时，默认重试规则为 http_code 为如下情况：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// http.StatusRequestTimeout, 408&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// http.StatusLocked, 423&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// http.StatusTooEarly, 425&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// http.StatusTooManyRequests, 429&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// http.StatusServiceUnavailable, 503&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// http.StatusGatewayTimeout, 504&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 使用时：&lt;/span&gt;&lt;br/&gt;httpclient.WithOnFailedRetry(&lt;span&gt;3&lt;/span&gt;, time.Second*&lt;span&gt;1&lt;/span&gt;, retryVerify),&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;示例代码&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 以 httpclient.PostForm 为例&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;api := &lt;span&gt;&quot;http://127.0.0.1:9999/demo/post&quot;&lt;/span&gt;&lt;br/&gt;params := url.Values{}&lt;br/&gt;params.Set(&lt;span&gt;&quot;name&quot;&lt;/span&gt;, name)&lt;br/&gt;body, err := httpclient.PostForm(api, params,&lt;br/&gt; httpclient.WithTTL(time.Second*&lt;span&gt;5&lt;/span&gt;),&lt;br/&gt; httpclient.WithTrace(ctx.Trace()),&lt;br/&gt; httpclient.WithLogger(ctx.Logger()),&lt;br/&gt; httpclient.WithHeader(&lt;span&gt;&quot;Authorization&quot;&lt;/span&gt;, &lt;span&gt;&quot;xxxx&quot;&lt;/span&gt;),&lt;br/&gt; httpclient.WithMock(MockDemoPost),&lt;br/&gt;    httpclient.WithOnFailedRetry(&lt;span&gt;3&lt;/span&gt;, time.Second*&lt;span&gt;1&lt;/span&gt;, retryVerify),&lt;br/&gt;    httpclient.WithOnFailedAlarm(&lt;span&gt;&quot;接口告警&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;(third_party_request.AlarmEmail), alarmVerify),                             &lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;res = &lt;span&gt;new&lt;/span&gt;(demoPostResponse)&lt;br/&gt;err = json.Unmarshal(body, res)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, errors.Wrap(err, &lt;span&gt;&quot;DemoPost json unmarshal error&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; res.Code != &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, errors.New(fmt.Sprintf(&lt;span&gt;&quot;code err: %d-%s&quot;&lt;/span&gt;, res.Code, res.Msg))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; res, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;以上代码在 &lt;code&gt;go-gin-api&lt;/code&gt; 项目中，地址：https://github.com/xinliangnote/go-gin-api&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>eab0a9d3af10132a11520719aff65e92</guid>
<title>“什么是编程” 连接机器和人心的媒介</title>
<link>https://toutiao.io/k/npcwldf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section&gt;&lt;h3&gt;&lt;section&gt;什么是编程?&lt;/section&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;小白学编程 | 普通人都能读懂的计算机编程科普读物&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;随着互联网科技的发展，越来越多的人开始接触互联网，开始使用互联网，甚至离不开互联网。比如我们用微信聊天，看抖音视频，微博刷热搜，百度查问题，淘宝买东西。各种各样的互联网应用在我们的生活中，层出不穷。这么多的互联网产品背后都离不开一门技术，也可以称为艺术「 &lt;strong&gt;编程&lt;/strong&gt; 」。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那到底什么是编程呢?&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;开始讲编程之前，抛开这个问题，我们先想一想人与人之间是如何交流的？&lt;/span&gt;&lt;/section&gt;&lt;figure&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4945oNIw2ulFLI43ERNfNE4wCP9XHIHmSbOQnpOicjKorZ64BYPo2ntEsE0cuEVmWmHicgmiclOkH71r49E0RaiazQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; title=&quot;&quot; data-ratio=&quot;0.4737704918032787&quot; data-w=&quot;610&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;首先想到的当然是&lt;strong&gt;语言&lt;/strong&gt;，我们通过语言与人交流，通过文字记录我们的语言。在人类世界中，每个国家，每个民族都有自己的语言，比如不同国家有汉语，英语，法语，俄语等，在我们的国家，除了汉语，还有藏语，维吾尔语，闽南语等等。虽然各种各样的语言说出来不同，听起来不同，甚至书写的文字完全不同，但却可以表示&lt;/span&gt;&lt;span&gt;相同&lt;/span&gt;&lt;span&gt;的意思。&lt;/span&gt;&lt;/section&gt;&lt;figure&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4945oNIw2ulFLI43ERNfNE4wCP9XHIHmzKwvHyh1peGNcBBHZJlecUn2PlskER5Q3hXeVChYr6nd49lR4Nkklw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; title=&quot;&quot; data-ratio=&quot;0.75&quot; data-w=&quot;620&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;语言是人与人之间交流的工具，而&lt;strong&gt;编程&lt;/strong&gt;就是人与电脑之间交流的工具，也是电脑与电脑之间交流的工具。我们都知道不同的国家和民族之间，有不同的语言，同样编程也有各种各样的语言，比如 &lt;/span&gt;&lt;code&gt;&lt;span&gt;PHP&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ， &lt;/span&gt;&lt;code&gt;&lt;span&gt;Go&lt;/span&gt;&lt;/code&gt;&lt;span&gt;， &lt;/span&gt;&lt;code&gt;&lt;span&gt;C&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ， &lt;/span&gt;&lt;code&gt;&lt;span&gt;C++&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ， &lt;/span&gt;&lt;code&gt;&lt;span&gt;JAVA&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ， &lt;/span&gt;&lt;code&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ， &lt;/span&gt;&lt;code&gt;&lt;span&gt;Javascript&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 等等，当然各种编程语言，书写起来也是五花八门。就像下面这样：&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;PHP&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;Hello World&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;Go&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;fmt&lt;/span&gt;.Println(&lt;span&gt;&quot;Hello World&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;C&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Hello World&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;C++&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;std&lt;/span&gt;::out &amp;lt;&amp;lt; &lt;span&gt;&quot;&#x27;Hello World&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;JAVA&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;Hello World&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;Hello World&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;Javascript&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;Hello World&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;虽然各种编程语言书写起来不同，但他们都表示了相同的意思，在电脑屏幕上输出 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 这个字符串，中文意思是「 你好世界 」。如果你是一开始学习编程，不论学习哪门语言，写下的第一行代码，都应该是从 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 开始的。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;section&gt;编程的基本逻辑&lt;/section&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;平时我们用我们的眼睛观察世界，用我们的耳朵聆听世界，感受这个世界的五彩缤纷，鸟语花香，这是我们人的&lt;strong&gt;输入&lt;/strong&gt;。当我们看到些景色，听到些声音，总想着分享出去，这时候就需要通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;语言&lt;/span&gt;&lt;/code&gt;&lt;span&gt;来表达，通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;文字&lt;/span&gt;&lt;/code&gt;&lt;span&gt;来记录，这就是我们人的&lt;strong&gt;输出&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;计算机世界中，也需要输入输出。键盘和鼠标就是电脑的输入，显示器和音响等就是输出，而编程就是连接电脑输入和输出的媒介。我们通过键盘将我们的编程语言输入电脑，告诉电脑去干什么，电脑通过自己的大脑（&lt;/span&gt;&lt;code&gt;&lt;span&gt;CPU&lt;/span&gt;&lt;/code&gt;&lt;span&gt;）进行计算，然后把输出结果打印到屏幕上（或让电脑去做什么）。这就是用电脑进行编程的基本逻辑。总结一句就是：「 通过编程，获取输入，进行计算，然后输出 」。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;section&gt;编程能干什么&lt;/section&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;了解了编程的基本逻辑之后，我们还需要了解编程能干什么？可以说和电脑相关的技术都离不开编程。比如平时我们刷抖音，刷微博，刷知乎，背后都离不开网络编程。我们买的手机，用的电脑离不开操作系统，操作系统也是用编程创造的。现在的智能硬件，智能音响同样离不开编程。汽车中的蓝牙系统，导航系统离不开编程，无人驾驶也需要编程实现。甚至在航天技术方中，比如神州上天，嫦娥登月，都离不开编程技术。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;说了这么多，那么编程到底能干什么呢？其实编程能干很多，其中最重要的就是 「 创造的能力 」，抽象一点编程是能够「连接机器和人心的媒介」。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;section&gt;写在最后&lt;/section&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;未来世界，科技进步，编程会像英语一样重要。编程并不神秘，编程就在我们身边。蛇叔在这里准备讲点「 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;普通人都能看懂的计算机编程科普读物&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 」。让从未接触过编程的人，也能培养编程思维，万丈高楼平地起，我们一起学习，一起进步，冲冲冲。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;记得&lt;/span&gt;&lt;span&gt;关注&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;点赞&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;转发&lt;/span&gt;&lt;span&gt;哦，我们下期再见。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;您的支持，是我持续创作的动力&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>