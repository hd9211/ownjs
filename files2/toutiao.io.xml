<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>27a9b15aa01c6e1468b446ec04554e4e</guid>
<title>[推荐] 谈谈 Git 存储原理及相关实现</title>
<link>https://toutiao.io/k/mzszqf0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;post-intro&quot;&gt;摘要：Git 是目前最流行的版本控制系统，从本地开发到生产部署，我们每天都在使用 Git 进行我们的版本控制，除了日常使用的命令之外，如果想要对 Git 有更深一步的了解，那么研究下 Git 的底层存储原理将会对理解 Git 及其使用非常有帮助，就算你不是一个 Git 开发者，也推荐你了解下 Git 的底层原理，你会对 Git 的强大有一个全新的认识，并且将会在日常的 Git 使用过程中更加得心应手。&lt;/p&gt;&lt;div class=&quot;markdown-body&quot;&gt;&lt;p&gt;&lt;img src=&quot;https://zoker.io/uploads/images/2021/0221/232751_a88e9997.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;这篇文章面向的读者主要是对 Git 有一定的了解的群体，并不会介绍具体 Git 的作用及其使用，也不会介绍与其它版本控制系统如 Subversion 之间的差异，主要是介绍下 Git 的本质以及他的存储实现的相关原理，旨在帮助 Git 使用者更加清晰的了解在使用 Git 进行版本控制的时候其内部实现。&lt;/p&gt;&amp;#13;
&lt;h2 id=&quot;git-本质是什么&quot;&gt;Git 本质是什么&lt;/h2&gt;&amp;#13;
&lt;p&gt;Git 本质上是一个内容寻址的 Key-Value 数据库，我们可以向 Git 仓库内插入任意类型的内容，Git 会返回给我们一个唯一的键值，可以通过这个键取出当时我们插入的值，我们可以通过底层命令&lt;code&gt;git hash-object&lt;/code&gt;命令来尝试：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ &lt;span class=&quot;hljs-keyword&quot;&gt;cat&lt;/span&gt; testfile&amp;#13;
Hello Git&amp;#13;
➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git hash-object testfile -&lt;span class=&quot;hljs-keyword&quot;&gt;w&lt;/span&gt;&amp;#13;
&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;f4d96d5b00d98959ea9960f069585ce42b1349a&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到我们目录下有一个名为&lt;code&gt;testfile&lt;/code&gt;的文件，内容是&lt;code&gt;Hello Git!&lt;/code&gt; 我们使用&lt;code&gt;git hash-object&lt;/code&gt;命令将这个文件的内容写入到 Git 仓库，&lt;code&gt;-w&lt;/code&gt; 选项告诉 Git 把这个内容写到 Git 的&lt;code&gt;.git/objects&lt;/code&gt;对象数据库目录，并且 Git 返回了一个 SHA 值，这个 SHA 值就是后续我们要取出这个文件的键值：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;cat&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt; -&lt;span class=&quot;hljs-keyword&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;f4d96d5b00d98959ea9960f069585ce42b1349a&amp;#13;
Hello Git&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们使用了&lt;code&gt;git cat-file&lt;/code&gt;命令取回刚刚存入到 Git 仓库的内容，虽然不像&lt;code&gt;Redis&lt;/code&gt;的命令&lt;code&gt;get&lt;/code&gt; &lt;code&gt;set&lt;/code&gt; 那么直观，但是它确实是一个 KV 数据库，不是吗？&lt;/p&gt;&amp;#13;
&lt;p&gt;我们刚刚尝试插入的这种数据是基础的&lt;code&gt;blob&lt;/code&gt;类型的对象，Git 还有其它如 &lt;code&gt;tree&lt;/code&gt;、&lt;code&gt;commit&lt;/code&gt;等对象类型，这些不同的对象类型之间有特定的关联关系，它们将不同的对象有逻辑的关联起来，才能够帮我们进行不同版本的控制和检出。稍后会展开讲解这几种不同的对象类型，我们先来了解下 Git 的目录结构，看看在 Git 中数据是如何存放的。&lt;/p&gt;&amp;#13;
&lt;h2 id=&quot;git-目录结构&quot;&gt;Git 目录结构&lt;/h2&gt;&amp;#13;
&lt;p&gt;通过上一节的介绍，我们知道了 Git 本质就是一个 KV 数据库，而且还提到了内容都是写到 &lt;code&gt;.git/objects&lt;/code&gt;对象目录，那么这个目录放在哪里？Git 又是如何存储这些数据的呢？本节我们重点介绍一下 Git 的存储目录结构，了解下 Git 是如何存放不同类型的数据的。&lt;/p&gt;&amp;#13;
&lt;blockquote&gt;&amp;#13;
&lt;p&gt;更详细的介绍参见：&lt;a href=&quot;https://github.com/git/git/blob/master/Documentation/gitrepository-layout.txt&quot;&gt;https://github.com/git/git/blob/master/Documentation/gitrepository-layout.txt&lt;/a&gt;&lt;/p&gt;&amp;#13;
&lt;/blockquote&gt;&amp;#13;
&lt;p&gt;通过 &lt;code&gt;git init&lt;/code&gt; 我们可以在当前目录初始化一个空的 Git 仓库，Git 会自动生成 &lt;code&gt;.git&lt;/code&gt; 目录，这个 &lt;code&gt;.git&lt;/code&gt; 目录就是后续所有的 Git 元数据的存储中心，我们来看一下它的目录结构：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker git init&amp;#13;
Initialized empty Git repository &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; /Users/zoker/tmp/Zoker/.git/&amp;#13;
➜  Zoker git:(master) ✗ tree &lt;span class=&quot;hljs-class&quot;&gt;.git&lt;/span&gt;&amp;#13;
&lt;span class=&quot;hljs-class&quot;&gt;.git&lt;/span&gt;&amp;#13;
├── HEAD              &lt;span class=&quot;hljs-comment&quot;&gt;// 是一个符号引用，指明当前工作目录的版本引用信息，我们平时执行 checkout 命令时就会改变 HEAD 的内容&lt;/span&gt;&amp;#13;
├── config             &lt;span class=&quot;hljs-comment&quot;&gt;// 配置当前存储库的一些信息，如：Proxy、用户信息、引用等，此处的配置项相对于全局配置权重更高&lt;/span&gt;&amp;#13;
├── description      &lt;span class=&quot;hljs-comment&quot;&gt;// 仓库描述信息&lt;/span&gt;&amp;#13;
├── hooks             &lt;span class=&quot;hljs-comment&quot;&gt;// 钩子目录，执行 Git 相关命令后的回调脚本，默认会有一些模板&lt;/span&gt;&amp;#13;
│   ├── update&lt;span class=&quot;hljs-class&quot;&gt;.sample&lt;/span&gt;&amp;#13;
│   ├── pre-receive&lt;span class=&quot;hljs-class&quot;&gt;.sample&lt;/span&gt;&amp;#13;
│   └── ...&amp;#13;
├── info                &lt;span class=&quot;hljs-comment&quot;&gt;// 存储一些额外的仓库信息如 refs、exclude、attributes 等&lt;/span&gt;&amp;#13;
│   └── exclude&amp;#13;
├── objects           &lt;span class=&quot;hljs-comment&quot;&gt;// 元数据存储中心&lt;/span&gt;&amp;#13;
│   ├── info&amp;#13;
│   └── pack&amp;#13;
└── refs               &lt;span class=&quot;hljs-comment&quot;&gt;// 存放引用信息，也就是分支、标签&lt;/span&gt;&amp;#13;
    ├── heads&amp;#13;
    └── tags&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;默认初始化生成的 Git 仓库就只有这些文件，除此之外还存在一些其它类型的文件和目录如&lt;code&gt;packed-refs&lt;/code&gt; &lt;code&gt;modules&lt;/code&gt; &lt;code&gt;logs&lt;/code&gt;等，这些文件都有特定的用途，都是在特定的操作或者配置后才会出现，这里我们只关注核心存储的实现，这些额外文件或目录的作用及使用场景再可自行翻阅文档，这里仅介绍核心的一些文件。&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;hooks-目录&quot;&gt;hooks 目录&lt;/h3&gt;&amp;#13;
&lt;p&gt;hooks 目录主要存储的是 Git 钩子，Git 钩子可以在很多事件发生后或者发生前触发，能够提供给我们非常灵活的使用方式，默认情况下全部都是带&lt;code&gt;.sample&lt;/code&gt;后缀的，需要移除这个后缀并赋予可执行权限方可生效，下面列举下常用的一些钩子及其常见的用途：&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;客户端钩子&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;ul&gt;&amp;#13;
&lt;li&gt;pre-commit：提交前触发，比如检查提交信息是否规范，测试是否运行完毕，代码格式是否符合要求&lt;/li&gt;&amp;#13;
&lt;li&gt;post-commit：相反，这个是整个提交完成后触发，可以用来发通知&lt;/li&gt;&amp;#13;
&lt;/ul&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;服务端钩子&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;ul&gt;&amp;#13;
&lt;li&gt;pre-receive：服务端接收推送请求首先被调用的脚本，可以检测这些被推送的引用是否符合要求&lt;/li&gt;&amp;#13;
&lt;li&gt;update：与 pre-receive 相似，但是 pre-receive 只会运行一次，而 update 将会为每一个推送的分支分别运行一次&lt;/li&gt;&amp;#13;
&lt;li&gt;post-receive：整个推送过程完成后触发，可以用来发送通知、触发构建系统等&lt;/li&gt;&amp;#13;
&lt;/ul&gt;&amp;#13;
&lt;h3 id=&quot;objects-目录&quot;&gt;objects 目录&lt;/h3&gt;&amp;#13;
&lt;p&gt;如上一节我们提到的，Git 将所有接收到的内容生成对象文件存储在这个目录下，我们通过&lt;code&gt;git hash-object&lt;/code&gt;生成了一个对象并写入了 Git 仓库，这个对象的键值是&lt;code&gt;9f4d96d5b00d98959ea9960f069585ce42b1349a&lt;/code&gt;，这个时候我们来查看下 &lt;code&gt;objects&lt;/code&gt; 目录的结构：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker git:(master) ✗ git hash-object testfile -w&amp;#13;
&lt;span class=&quot;hljs-number&quot;&gt;9f&lt;/span&gt;4d96d5b00d98959ea9960f069585ce42b1349a&amp;#13;
➜  Zoker git:(master) ✗ tree .git/objects&amp;#13;
.git/objects&amp;#13;
├── &lt;span class=&quot;hljs-number&quot;&gt;9f&lt;/span&gt;&amp;#13;
│   └── &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;d96d5b00d98959ea9960f069585ce42b1349a&amp;#13;
├── info&amp;#13;
└── pack&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到&lt;code&gt;objects&lt;/code&gt;目录已经有了新的内容，多了一个&lt;code&gt;9f&lt;/code&gt;的文件夹以及其中的文件，这个文件就是插入到 Git 仓库的内容的对象文件，Git 取其键值的前两个字母作为文件夹，将后面的字母作为对象文件的文件名进行存储，这里（也就是&lt;code&gt;objects/[0-9a-f][0-9a-f]&lt;/code&gt;）所存储的对象我们一般称为&lt;code&gt;loose objects&lt;/code&gt;或者&lt;code&gt;unpacked objects&lt;/code&gt;，也就是松散对象。&lt;/p&gt;&amp;#13;
&lt;p&gt;除了对象的存储文件夹，细心的同学应该已经注意到了&lt;code&gt;objects/pack&lt;/code&gt;文件夹的存在，这里对应的是打包后的文件，为了节省空间和提升效率，当存储库中有过多的松散对象文件或者手动执行&lt;code&gt;git gc&lt;/code&gt;命令时，亦或是推送拉取的传输过程中，Git 都会将这些松散的对象文件打包成&lt;code&gt;pack&lt;/code&gt;文件来提升效率，这里存放的就是这些打包后的文件:&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  objects git:(master) git gc&amp;#13;
&lt;span class=&quot;hljs-keyword&quot;&gt;...&lt;/span&gt;&amp;#13;
Compressing objects: &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;% (&lt;span class=&quot;hljs-number&quot;&gt;75&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;75&lt;/span&gt;), done.&amp;#13;
&lt;span class=&quot;hljs-keyword&quot;&gt;...&lt;/span&gt;&amp;#13;
➜  objects git:(master) tree&amp;#13;
.&amp;#13;
├─ pack&amp;#13;
    ├── pack-fe24a22b0313342a6732cff4759bedb25c2ea55d.idx&amp;#13;
    └── pack-fe24a22b0313342a6732cff4759bedb25c2ea55d.pack&amp;#13;
└── &lt;span class=&quot;hljs-keyword&quot;&gt;...&lt;/span&gt;&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到&lt;code&gt;objects&lt;/code&gt;目录已经没有了松散对象，取而代之的是&lt;code&gt;pack&lt;/code&gt;目录的两个文件，一个是打包后的文件，另一个是对这个打包的内容进行索引的&lt;code&gt;idx&lt;/code&gt;文件，方便查询某个对象是否在这个对应的&lt;code&gt;pack&lt;/code&gt;包内。&lt;/p&gt;&amp;#13;
&lt;p&gt;需要注意的是，如果在刚刚我们手动创建的一个&lt;code&gt;blob&lt;/code&gt;对象的仓库进行 GC，将不会产生任何效果，因为这个时候整个 Git 仓库并没有任何一个引用指向这个对象，我们说这个对象是游离的，下面我们来介绍下存储引用的目录。&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;refs-目录&quot;&gt;refs 目录&lt;/h3&gt;&amp;#13;
&lt;p&gt;refs 目录存储我们的引用（references），引用可以看做是对一个版本号的别名，它存储的实际就是某一个 Commit 的 SHA 值，上面我们用来测试的仓库并没有任何一个提交，所以只有一个空的目录结构&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;└── refs&amp;#13;
    ├── heads&amp;#13;
    └── &lt;span class=&quot;hljs-keyword&quot;&gt;tags&lt;/span&gt;&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们随便找一个包含提交的仓库查看他的默认分支&lt;code&gt;master&lt;/code&gt;&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  .git &lt;span class=&quot;hljs-string&quot;&gt;git:&lt;/span&gt;(master) cat refs&lt;span class=&quot;hljs-regexp&quot;&gt;/heads/&lt;/span&gt;master&amp;#13;
&lt;span class=&quot;hljs-number&quot;&gt;87e917616712189&lt;/span&gt;ecac8c4890fe7d2dc2d554ac6&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到这个&lt;code&gt;master&lt;/code&gt;的引用只是存储了一个 Commit 的 SHA 值，好处当然就是我们不需要记着那长长的一串 SHA 值，我们只需要用&lt;code&gt;master&lt;/code&gt;这个别名就可以获取到这个版本。同样的 tags 目录下存储的就是我们的标签，与分支不同的是，标签的所记录的引用值一般是不会变化的，而分支可以我们的版本变化而变化。除此之外，还可能会看到&lt;code&gt;refs/remotes&lt;/code&gt; &lt;code&gt;refs/fetch&lt;/code&gt; 等目录，这些里面存储的是特定命名空间的引用。&lt;/p&gt;&amp;#13;
&lt;p&gt;还有一种情况，就是上面我们讲到的 GC 机制，如果一个仓库执行了 GC，那么不仅&lt;code&gt;objects&lt;/code&gt;目录下的松散对象会被打包，&lt;code&gt;refs&lt;/code&gt;下面的引用同样也会被打包，只不过它存放在裸仓库的根目录下&lt;code&gt;.git/packed-refs&lt;/code&gt;&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  .git&lt;span class=&quot;hljs-function&quot;&gt; git:(&lt;/span&gt;master&lt;span class=&quot;hljs-function&quot;&gt;)&lt;/span&gt; cat&lt;span class=&quot;hljs-instruction&quot;&gt; packed-refs&amp;#13;
&lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# pack-refs with: peeled fully-peeled sorted&lt;/span&gt;&amp;#13;
87e917616712189ecac8c4890fe7d2dc2d554ac6 refs/heads/master&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当我们需要访问分支&lt;code&gt;master&lt;/code&gt;的时候，Git 会首先去&lt;code&gt;refs/heads&lt;/code&gt;里面进行查找，如果找不到就会前往&lt;code&gt;.git/packed-refs&lt;/code&gt;进行查找，将所有的引用打包到一个文件无疑提升了不少效率。需要注意的是，如果我们在这个时候往&lt;code&gt;master&lt;/code&gt;分支上更新了一些提交，这个时候 Git 并不会直接修改 &lt;code&gt;.git/packed-refs&lt;/code&gt;文件，它会直接在&lt;code&gt;refs/heads/&lt;/code&gt;下重新创建一个&lt;code&gt;master&lt;/code&gt;引用，包含最新的提交的 SHA 值，根据刚刚我们介绍的 Git 的机制，Git 会首先在&lt;code&gt;refs/heads/&lt;/code&gt;查找，找不到才会去&lt;code&gt;.git/packed-refs&lt;/code&gt;查找。&lt;/p&gt;&amp;#13;
&lt;p&gt;那么引用里面存储的 Commit 的 这串 SHA 值到底是指向什么内容呢，我们可以使用之前查看&lt;code&gt;blob&lt;/code&gt;对象内容的&lt;code&gt;cat-file&lt;/code&gt;命令进行查看：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  .git git:(master) git cat-&lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt; -p &lt;span class=&quot;hljs-number&quot;&gt;87e917616712189&lt;/span&gt;ecac8c4890fe7d2dc2d554ac6&amp;#13;
tree aab1a9217aa6896ef46d3e1a90bc64e8178e1662 &lt;span class=&quot;hljs-comment&quot;&gt;// 指向的tree对象&lt;/span&gt;&amp;#13;
&lt;span class=&quot;hljs-keyword&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;d000309cb780fa27898b4d103afcfa95a8c04db &lt;span class=&quot;hljs-comment&quot;&gt;// 父提交&lt;/span&gt;&amp;#13;
author Zoker &amp;lt;kaixuanguiqu&lt;span class=&quot;hljs-variable&quot;&gt;@gmail&lt;/span&gt;.com&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1607958804&lt;/span&gt; +&lt;span class=&quot;hljs-number&quot;&gt;0800&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;// 作者信息&lt;/span&gt;&amp;#13;
committer Zoker &amp;lt;kaixuanguiqu&lt;span class=&quot;hljs-variable&quot;&gt;@gmail&lt;/span&gt;.com&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1607958804&lt;/span&gt; +&lt;span class=&quot;hljs-number&quot;&gt;0800&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;// 提交者信息&lt;/span&gt;&amp;#13;
&amp;#13;
test ssh &lt;span class=&quot;hljs-comment&quot;&gt;// 提交信息&lt;/span&gt;&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它是一个&lt;code&gt;commit&lt;/code&gt;类型的对象，主要的属性是它指向的&lt;code&gt;tree&lt;/code&gt;对象，它的父提交（如果它是第一个提交，那么这里是0000000...），以及作者和提交信息。&lt;/p&gt;&amp;#13;
&lt;p&gt;那么&lt;code&gt;commit&lt;/code&gt;对象是什么？它所指向的&lt;code&gt;tree&lt;/code&gt;对象又是什么？与之前我们手工创建的&lt;code&gt;blob&lt;/code&gt;对象有什么差别？接下来我们来谈谈 Git 存储对象。&lt;/p&gt;&amp;#13;
&lt;h2 id=&quot;git-存储对象&quot;&gt;Git 存储对象&lt;/h2&gt;&amp;#13;
&lt;p&gt;在 Git 的世界里，一共有四种类型的存储对象： 文件（blob）、树（tree）、提交（commit）、标签（tag），这里我们主要探讨头三种类型，因为这三种是最基础的 Git 元数据，而标签对象只是一个包含了额外属性信息的 Tag 而已，也就是附注标签（annotated tag），这里不再过多的介绍。&lt;/p&gt;&amp;#13;
&lt;blockquote&gt;&amp;#13;
&lt;p&gt;轻量标签（lightweight）与附注标签（annotated）介绍：&lt;a href=&quot;https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE&quot;&gt;https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE&lt;/a&gt;&lt;/p&gt;&amp;#13;
&lt;/blockquote&gt;&amp;#13;
&lt;h3 id=&quot;blob-对象&quot;&gt;Blob 对象&lt;/h3&gt;&amp;#13;
&lt;p&gt;在介绍 Git 本质的时候，为了演示 Git 是一个基于内容寻址的 KV 数据库，我们向 Git 仓库插入了一个文件的内容：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ &lt;span class=&quot;hljs-keyword&quot;&gt;cat&lt;/span&gt; testfile&amp;#13;
Hello Git&amp;#13;
➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git hash-object testfile -&lt;span class=&quot;hljs-keyword&quot;&gt;w&lt;/span&gt;&amp;#13;
&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;f4d96d5b00d98959ea9960f069585ce42b1349a&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个 Key 为&lt;code&gt;9f4d96d5b00d98959ea9960f069585ce42b1349a&lt;/code&gt;的 Git 对象实际上就是一个 Blob 对象，他存储了这个&lt;code&gt;testfile&lt;/code&gt;文件的值，我们可以使用&lt;code&gt;cat-file&lt;/code&gt;命令来进行查看：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;cat&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt; -&lt;span class=&quot;hljs-keyword&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;f4d96d5b00d98959ea9960f069585ce42b1349a&amp;#13;
Hello Git&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;每一次我们修改文件，Git 都会完整的保存一份这个文件的快照而非记录差异，所以如果我们修改了&lt;code&gt;testfile&lt;/code&gt;文件的内容再次存入到 Git 仓库中的时候，Git 会基于当前最新的内容来生成它的 Key，需要注意的是当内容不变的时候，它的 Key 值是固定的，毕竟我们前面也说了，Git 是一个基于内容寻址的 KV 数据库。&lt;/p&gt;&amp;#13;
&lt;p&gt;另外，这里的 Blob 对象存储的是文本内容，它还可以是二进制内容，但是这里并不建议使用 Git 管理二进制文件的版本。我们 Gitee 平台在日常运营过程中遇到最多的问题就是用户仓库过大，这种情况一般都是用户提交了大的二进制文件导致的，因为每次文件的变更记录的是快照，所以这个二进制文件如果变更频繁，它占用的空间是倍增的。而且对于文本内容的 Blob，Git 在 GC 的过程中会只保存两次提交之间的文件差异，是可以达到节省空间的效果的，但是对于二进制内容的 Blob 是无法像文本内容的 Blob 那样处理的，所以尽量不要把频繁变动的二进制内容存储到 Git 仓库，可以使用 LFS 的方式进行存储。如果已经存在了大量的二进制文件，可以使用&lt;code&gt;filter-branch&lt;/code&gt;进行瘦身，新加入的同事在首次 Clone 仓库的时候肯定会感激你的。&lt;/p&gt;&amp;#13;
&lt;blockquote&gt;&amp;#13;
&lt;p&gt;LFS 的使用：&lt;a href=&quot;https://gitee.com/help/articles/4235&quot;&gt;https://gitee.com/help/articles/4235&lt;/a&gt;&amp;#13;
大仓库的瘦身：&lt;a href=&quot;https://gitee.com/help/articles/4232&quot;&gt;https://gitee.com/help/articles/4232&lt;/a&gt;&amp;#13;
filter-branch：&lt;a href=&quot;https://github.com/git/git/blob/master/Documentation/git-filter-branch.txt&quot;&gt;https://github.com/git/git/blob/master/Documentation/git-filter-branch.txt&lt;/a&gt;&lt;/p&gt;&amp;#13;
&lt;/blockquote&gt;&amp;#13;
&lt;p&gt;到了这里是不是觉得哪里不对劲？没错，这个 Blob 对象只存储了这个文件的内容，却没有记录文件名，那我们该怎么知道这个内容是属于哪个文件的啊？答案是 Git 的另外一个重要的对象：Tree 对象。&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;tree-对象&quot;&gt;Tree 对象&lt;/h3&gt;&amp;#13;
&lt;p&gt;在 Git 中，Tree 对象主要的作用是将多个 Blob 或者 子 Tree 对象组织到一起，所有的内容都是通过 Tree 和 Blob 类型的对象进行存储的。一个 Tree 对象包含了一个或者多个 Tree Entry（树对象记录），每个树对象记录都包含了一个指向 Blob 或者子 Tree SHA 值的指针，还有它们对应的文件名等信息，其实就可以理解为索引文件系统中的&lt;code&gt;inode&lt;/code&gt;和&lt;code&gt;block&lt;/code&gt;的关系，图示一个 Tree 对象的话，如下图：&amp;#13;
&lt;img src=&quot;https://zoker.io/uploads/images/2021/0221/232855_c0f2e4e8.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;/&gt;&amp;#13;
这个 Tree 对象对应的目录结构就是下面这样的：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;.&amp;#13;
├── LICENSE&amp;#13;
├── readme&lt;span class=&quot;hljs-class&quot;&gt;.md&lt;/span&gt;&amp;#13;
└── src&amp;#13;
    ├── libssl&lt;span class=&quot;hljs-class&quot;&gt;.so&lt;/span&gt;&amp;#13;
    └── logo.png&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过这种方式，我们可以像组织 Linux 下目录的方式一样来结构化的存储我们仓库的内容，把 Tree 看作目录结构，把 Blob 看作具体的文件内容。&lt;/p&gt;&amp;#13;
&lt;p&gt;那么该如何创建一个 Tree 对象呢？在 Git 中是根据暂存区的状态来创建对应的 Tree 对象的，这里的暂存区其实就是我们日常在使用 Git 的过程中所理解的暂存区（Staged），一般我们使用&lt;code&gt;git add&lt;/code&gt;命令将某些文件添加到暂存区待提交。在没有任何提交的空仓库里，这个暂存区的状态就是你通过&lt;code&gt;git add&lt;/code&gt;所添加的那些文件，如：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker git:(master) ✗ git status&amp;#13;
&lt;span class=&quot;hljs-keyword&quot;&gt;On&lt;/span&gt; branch master&amp;#13;
&amp;#13;
No commits yet&amp;#13;
&amp;#13;
Changes &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; be committed:&amp;#13;
  (&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;git rm --cached &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; unstage)&amp;#13;
    &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt;:   LICENSE&amp;#13;
    &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt;:   readme.md&amp;#13;
&amp;#13;
Untracked files:&amp;#13;
  (&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;git add &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; include &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; what will be committed)&amp;#13;
    src/&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里当前的暂存区状态就是在根目录有两个文件，暂存区的状态是保存在&lt;code&gt;.git/index&lt;/code&gt;文件的，我们使用&lt;code&gt;file&lt;/code&gt;命令来看看它是什么：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker git:(master) ✗ &lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt; .git/&lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt;&amp;#13;
.git/&lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt;: Git &lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt;, version &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; entries&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以发现在&lt;code&gt;index&lt;/code&gt;文件中有两个&lt;code&gt;entry&lt;/code&gt;，也就是根目录的两个文件&lt;code&gt;LICENSE&lt;/code&gt;和&lt;code&gt;readme.md&lt;/code&gt;。对于已经有提交的仓库，如果暂存区没有任何内容，那么这个&lt;code&gt;index&lt;/code&gt;表示的就是当前版本的目录树状态，如果修改或者增删了文件，并且加入了暂存区，那么&lt;code&gt;index&lt;/code&gt;就会发生改变，将相关文件的指针指向该文件新的 Blob 对象的 SHA 值。&lt;/p&gt;&amp;#13;
&lt;p&gt;所以如果想要创建一个 Tree 对象，我们需要往暂存区放点东西，除了使用&lt;code&gt;git add&lt;/code&gt;，我们还可以使用底层命令&lt;code&gt;update-index&lt;/code&gt;来创建一个暂存区。接下来我们根据上面已经创建好的&lt;code&gt;testfile&lt;/code&gt;文件来创建一个树对象，首先就是将文件&lt;code&gt;testfile&lt;/code&gt;加入到暂存区：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker git:(master) ✗ git &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;update&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;--add testfile // 与 git add testfile 一样&lt;/span&gt;&amp;#13;
➜  Zoker git:(&lt;span class=&quot;hljs-keyword&quot;&gt;master&lt;/span&gt;) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;status&lt;/span&gt;&amp;#13;
&lt;span class=&quot;hljs-keyword&quot;&gt;On&lt;/span&gt; branch &lt;span class=&quot;hljs-keyword&quot;&gt;master&lt;/span&gt;&amp;#13;
&amp;#13;
&lt;span class=&quot;hljs-keyword&quot;&gt;No&lt;/span&gt; commits yet&amp;#13;
&amp;#13;
Changes &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; be committed:&amp;#13;
  (&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;git rm --cached &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; unstage)&amp;#13;
    new file:   testfile&lt;/span&gt;&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个过程 Git 主要是先把&lt;code&gt;testfile&lt;/code&gt;的内容以 Blob 的形式插入到 Git 仓库，然后将返回的这个 Blob 的 SHA 值记录到&lt;code&gt;index&lt;/code&gt;中，告诉暂存区目前这个文件的内容是哪个。&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ tree .git/objects&amp;#13;
.git/objects&amp;#13;
├── &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;f&lt;/span&gt;&amp;#13;
│   └── &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;d96d5b00d98959ea9960f069585ce42b1349a&amp;#13;
├── info&amp;#13;
└── pack&amp;#13;
&amp;#13;
&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; directories, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt;&amp;#13;
➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;cat&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt; -&lt;span class=&quot;hljs-keyword&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;f4d96d5b00d98959ea9960f069585ce42b1349a&amp;#13;
Hello Git&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Git 在执行&lt;code&gt;update-index&lt;/code&gt;命令的时候，把指定文件的内容存储为 Blob 对象，并且记录在&lt;code&gt;index&lt;/code&gt;文件状态内。由于在之前我们已经通过&lt;code&gt;git hash-object&lt;/code&gt;命令将这个文件的内容插入过了，并且我们可以发现因为内容不变，所以生成的这个 Blob 对象的 SHA 值也是一致的，如果像我们这样已经做过插入的动作，下面的命令是等效的：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;git &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;update&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;--add --cacheinfo 9f4d96d5b00d98959ea9960f069585ce42b1349a testfile&lt;/span&gt;&lt;/span&gt;&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个命令其实就是把之前已经生成的 Blob 对象放到暂存区，并且指定它的文件名字是&lt;code&gt;testfile&lt;/code&gt;。由于我们的暂存区已经有一个文件&lt;code&gt;testfile&lt;/code&gt;，所以我接下来我们可以使用&lt;code&gt;git write-tree&lt;/code&gt;命令来基于当前暂存区的状态来创建一个 Tree 对象了：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;write&lt;/span&gt;-tree&amp;#13;
aa406ee8804971cf8edfd8c89ff431b0462e250c&amp;#13;
➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ tree .git/objects&amp;#13;
.git/objects&amp;#13;
├── &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;f&lt;/span&gt;&amp;#13;
│   └── &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;d96d5b00d98959ea9960f069585ce42b1349a&amp;#13;
├── aa&amp;#13;
│   └── &lt;span class=&quot;hljs-number&quot;&gt;406&lt;/span&gt;ee8804971cf8edfd8c89ff431b0462e250c&amp;#13;
├── info&amp;#13;
└── pack&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行完命令后，Git 会基于当前暂存区的状态生成一个 SHA 值为&lt;code&gt;aa406ee8804971cf8edfd8c89ff431b0462e250c&lt;/code&gt;的 Tree 对象，并把这个 Tree 对象像 Blob 对象一样存储在&lt;code&gt;.git/objects&lt;/code&gt;目录下。&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;cat&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt; -&lt;span class=&quot;hljs-keyword&quot;&gt;p&lt;/span&gt; aa406ee8804971cf8edfd8c89ff431b0462e250c&amp;#13;
&lt;span class=&quot;hljs-number&quot;&gt;100644&lt;/span&gt; blob &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;f4d96d5b00d98959ea9960f069585ce42b1349a    testfile&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用&lt;code&gt;cat-file&lt;/code&gt;命令查看这个 Tree 对象，可以看到这个对象下只有一个文件，名为&lt;code&gt;testfile&lt;/code&gt;&amp;#13;
&lt;img src=&quot;https://zoker.io/uploads/images/2021/0221/232928_772a3f62.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;/&gt;&amp;#13;
我们继续创建第二个 Tree 对象，我们需要第二个 Tree 对象下有修改后的&lt;code&gt;testfile&lt;/code&gt;文件，有新增的 &lt;code&gt;testfile2&lt;/code&gt;文件，并且需要把第一个 Tree 对象作为 第二个 Tree 对象的&lt;code&gt;duplicate&lt;/code&gt;目录。首先我们先把修改后的&lt;code&gt;testfile&lt;/code&gt;和新增的&lt;code&gt;testfile2&lt;/code&gt;文件加入到暂存区：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker git:(master) ✗ git &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;update&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt; testfile&amp;#13;
➜  Zoker git:(&lt;span class=&quot;hljs-keyword&quot;&gt;master&lt;/span&gt;) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;update&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;--add testfile2&lt;/span&gt;&amp;#13;
➜  Zoker git:(&lt;span class=&quot;hljs-keyword&quot;&gt;master&lt;/span&gt;) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;status&lt;/span&gt;&amp;#13;
&lt;span class=&quot;hljs-keyword&quot;&gt;On&lt;/span&gt; branch &lt;span class=&quot;hljs-keyword&quot;&gt;master&lt;/span&gt;&amp;#13;
&amp;#13;
&lt;span class=&quot;hljs-keyword&quot;&gt;No&lt;/span&gt; commits yet&amp;#13;
&amp;#13;
Changes &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; be committed:&amp;#13;
  (&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;git rm --cached &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; unstage)&amp;#13;
    new file:   testfile&amp;#13;
    new file:   testfile2&lt;/span&gt;&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;紧接着我们需要把第一个 Tree 对象挂到&lt;code&gt;duplicate&lt;/code&gt;目录下，我们可以使用&lt;code&gt;read-tree&lt;/code&gt;命令来实现：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker git:(master) ✗ git read-tree &lt;span class=&quot;hljs-comment&quot;&gt;--prefix=duplicate aa406ee8804971cf8edfd8c89ff431b0462e250c &lt;/span&gt;&amp;#13;
➜  Zoker git:(master) ✗ git status&amp;#13;
&lt;span class=&quot;hljs-keyword&quot;&gt;On&lt;/span&gt; branch master&amp;#13;
&amp;#13;
No commits yet&amp;#13;
&amp;#13;
Changes &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; be committed:&amp;#13;
  (&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;git rm --cached &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; unstage)&amp;#13;
    &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt;:   duplicate/testfile&amp;#13;
    &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt;:   testfile&amp;#13;
    &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt;:   testfile2&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后我们执行&lt;code&gt;write-tree&lt;/code&gt;并通过&lt;code&gt;cat-file&lt;/code&gt;查看第二个 Tree 对象：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;write&lt;/span&gt;-tree&amp;#13;
&lt;span class=&quot;hljs-number&quot;&gt;64&lt;/span&gt;d62cef754e6cc995ed8d34f0d0e233e1dfd5d1&amp;#13;
➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;cat&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt; -&lt;span class=&quot;hljs-keyword&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;64&lt;/span&gt;d62cef754e6cc995ed8d34f0d0e233e1dfd5d1&amp;#13;
&lt;span class=&quot;hljs-number&quot;&gt;040000&lt;/span&gt; tree aa406ee8804971cf8edfd8c89ff431b0462e250c    duplicate&amp;#13;
&lt;span class=&quot;hljs-number&quot;&gt;100644&lt;/span&gt; blob &lt;span class=&quot;hljs-number&quot;&gt;106287&lt;/span&gt;c47fd25ad9a0874670a0d5c6eacf1bfe4e    testfile&amp;#13;
&lt;span class=&quot;hljs-number&quot;&gt;100644&lt;/span&gt; blob &lt;span class=&quot;hljs-number&quot;&gt;098&lt;/span&gt;ffe6f84559f4899edf119c25d276dc70607cf    testfile2&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;成功完成了，我们不仅修改了&lt;code&gt;testfile&lt;/code&gt;的文件内容，还新增了一个&lt;code&gt;testfile2&lt;/code&gt;文件，并且还把第一个 Tree 对象当作第二个 Tree 对象的&lt;code&gt;duplicate&lt;/code&gt;目录了，这个时候 Tree 对象看起来应该是这样的：&amp;#13;
&lt;img src=&quot;https://zoker.io/uploads/images/2021/0221/232948_54b120f4.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;/&gt;&amp;#13;
至此，我们知道了如何手动创建一个 Tree 对象，但是后面如果我需要这两个不同的 Tree 的快照该怎么办？总不能都记住这三个 Tree 对象的 SHA 值吧？没错，记起来费老大劲了，关键是还不知道是谁在什么时间为了什么而创建的这个快照，而 Commit 对象（提交对象）就能够帮我们解决这个问题。&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;commit-对象&quot;&gt;Commit 对象&lt;/h3&gt;&amp;#13;
&lt;p&gt;Commit 对象主要是为了记录快照的一些附加信息，并且维护快照之间的线性关系。我们可以通过&lt;code&gt;git commit-tree&lt;/code&gt;命令来创建一个提交，这个命令看字面意思就知道，它是用来将 Tree 对象提交为一个 Commit 对象的命令：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker git:(master) ✗ git commit-tree -h&amp;#13;
usage: git commit-tree [(-p &amp;lt;parent&amp;gt;)&lt;span class=&quot;hljs-keyword&quot;&gt;...&lt;/span&gt;] [-S[&amp;lt;keyid&amp;gt;]] [(-m &amp;lt;message&amp;gt;)&lt;span class=&quot;hljs-keyword&quot;&gt;...&lt;/span&gt;] [(-&lt;span class=&quot;hljs-literal&quot;&gt;F&lt;/span&gt; &amp;lt;file&amp;gt;)&lt;span class=&quot;hljs-keyword&quot;&gt;...&lt;/span&gt;] &amp;lt;tree&amp;gt;&amp;#13;
&amp;#13;
    -p &amp;lt;parent&amp;gt;           id of a parent commit object&amp;#13;
    -m &amp;lt;message&amp;gt;          commit message&amp;#13;
    -&lt;span class=&quot;hljs-literal&quot;&gt;F&lt;/span&gt; &amp;lt;file&amp;gt;             read commit log message from file&amp;#13;
    -S, --gpg-sign[=&amp;lt;key-id&amp;gt;]&amp;#13;
                          GPG sign commit&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关键的两个参数是&lt;code&gt;-p&lt;/code&gt;和&lt;code&gt;-m&lt;/code&gt;，&lt;code&gt;-p&lt;/code&gt;是指定这个提交的父提交，如果是初始的第一个提交，那这里可以忽略；&lt;code&gt;-m&lt;/code&gt;则是指定本次提交的信息，主要是用来描述提交的原因。我们来把第一个 Tree 对象作为我们的初始提交：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker git:&lt;span class=&quot;hljs-comment&quot;&gt;(master)&lt;/span&gt; ✗ git commit-tree -m &lt;span class=&quot;hljs-string&quot;&gt;&quot;init commit&quot;&lt;/span&gt; aa&lt;span class=&quot;hljs-number&quot;&gt;406&lt;/span&gt;ee&lt;span class=&quot;hljs-number&quot;&gt;8804971&lt;/span&gt;cf&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;edfd&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;c&lt;span class=&quot;hljs-number&quot;&gt;89&lt;/span&gt;ff&lt;span class=&quot;hljs-number&quot;&gt;431&lt;/span&gt;b&lt;span class=&quot;hljs-number&quot;&gt;0462&lt;/span&gt;e&lt;span class=&quot;hljs-number&quot;&gt;250&lt;/span&gt;c&amp;#13;
&lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;ae&lt;span class=&quot;hljs-number&quot;&gt;181&lt;/span&gt;bd&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;c&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;e&lt;span class=&quot;hljs-number&quot;&gt;703&lt;/span&gt;df&lt;span class=&quot;hljs-number&quot;&gt;7851&lt;/span&gt;c&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;f&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;ea&lt;span class=&quot;hljs-number&quot;&gt;01&lt;/span&gt;d&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;e&lt;span class=&quot;hljs-number&quot;&gt;33&lt;/span&gt;a&lt;span class=&quot;hljs-number&quot;&gt;675&lt;/span&gt;b&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用&lt;code&gt;cat-file&lt;/code&gt;来查看这个提交：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;tree&lt;/span&gt; aa406ee8804971cf8edfd8c89ff431b0462e250c&amp;#13;
author Zoker &amp;lt;kaixuanguiqu&lt;span class=&quot;hljs-variable&quot;&gt;@gmail&lt;/span&gt;.com&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1613225370&lt;/span&gt; +&lt;span class=&quot;hljs-number&quot;&gt;0800&lt;/span&gt;&amp;#13;
committer Zoker &amp;lt;kaixuanguiqu&lt;span class=&quot;hljs-variable&quot;&gt;@gmail&lt;/span&gt;.com&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1613225370&lt;/span&gt; +&lt;span class=&quot;hljs-number&quot;&gt;0800&lt;/span&gt;&amp;#13;
&amp;#13;
init commit&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Commit 所存储的内容是一个 Tree 对象，并且记录了提交者、提交时间以及提交信息。我们基于这个 Commit 将第二个 Tree 对象作为引用：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git commit-tree -&lt;span class=&quot;hljs-keyword&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;ae181bd -&lt;span class=&quot;hljs-keyword&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;add dir&quot;&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;64&lt;/span&gt;d62cef754e6cc995ed8d34f0d0e233e1dfd5d1&amp;#13;
de96a74725dd72c10693c4896cb74e8967859e58&amp;#13;
➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;cat&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt; -&lt;span class=&quot;hljs-keyword&quot;&gt;p&lt;/span&gt; de96a74725dd72c10693c4896cb74e8967859e58&amp;#13;
tree &lt;span class=&quot;hljs-number&quot;&gt;64&lt;/span&gt;d62cef754e6cc995ed8d34f0d0e233e1dfd5d1&amp;#13;
parent &lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;ae181bd6c3e703df7851c0f7ea01d9e33a675b&amp;#13;
author Zoker &amp;lt;kaixuanguiqu@gmail.&lt;span class=&quot;hljs-keyword&quot;&gt;com&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1613225850&lt;/span&gt; +&lt;span class=&quot;hljs-number&quot;&gt;0800&lt;/span&gt;&amp;#13;
committer Zoker &amp;lt;kaixuanguiqu@gmail.&lt;span class=&quot;hljs-keyword&quot;&gt;com&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1613225850&lt;/span&gt; +&lt;span class=&quot;hljs-number&quot;&gt;0800&lt;/span&gt;&amp;#13;
&amp;#13;
&lt;span class=&quot;hljs-built_in&quot;&gt;add&lt;/span&gt; dir&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以使用&lt;code&gt;git log&lt;/code&gt;来查看这两个提交，这里添加&lt;code&gt;--stat&lt;/code&gt;参数查看文件变更记录：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;commit&lt;/span&gt; de96a74725dd72c10693c4896cb74e8967859e58&amp;#13;
Author: Zoker &amp;lt;kaixuanguiqu@gmail.com&amp;gt;&amp;#13;
&lt;span class=&quot;hljs-built_in&quot;&gt;Date&lt;/span&gt;:   Sun Feb &lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2021&lt;/span&gt; +&lt;span class=&quot;hljs-number&quot;&gt;0800&lt;/span&gt;&amp;#13;
&amp;#13;
    &lt;span class=&quot;hljs-keyword&quot;&gt;add&lt;/span&gt; dir&amp;#13;
&amp;#13;
 duplicate/testfile | &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; +&amp;#13;
 testfile           | &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; +-&amp;#13;
 testfile2          | &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; +&amp;#13;
 &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; files &lt;span class=&quot;hljs-keyword&quot;&gt;changed&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; insertions(+), &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; deletion(-)&amp;#13;
&amp;#13;
&lt;span class=&quot;hljs-keyword&quot;&gt;commit&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;ae181bd6c3e703df7851c0f7ea01d9e33a675b&amp;#13;
Author: Zoker &amp;lt;kaixuanguiqu@gmail.com&amp;gt;&amp;#13;
&lt;span class=&quot;hljs-built_in&quot;&gt;Date&lt;/span&gt;:   Sun Feb &lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;09&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2021&lt;/span&gt; +&lt;span class=&quot;hljs-number&quot;&gt;0800&lt;/span&gt;&amp;#13;
&amp;#13;
    init &lt;span class=&quot;hljs-keyword&quot;&gt;commit&lt;/span&gt;&amp;#13;
&amp;#13;
 testfile | &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; +&amp;#13;
 &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; file &lt;span class=&quot;hljs-keyword&quot;&gt;changed&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; insertion(+)&lt;/span&gt;&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个时候整个对象的结构如下图：&amp;#13;
&lt;img src=&quot;https://zoker.io/uploads/images/2021/0221/233021_a6ed134f.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;练习：使用底层命令创建一个提交&quot;&gt;练习：使用底层命令创建一个提交&lt;/h3&gt;&amp;#13;
&lt;p&gt;仅使用我们上面提到的&lt;code&gt;hash-object&lt;/code&gt; &lt;code&gt;write-tree&lt;/code&gt; &lt;code&gt;read-tree&lt;/code&gt; &lt;code&gt;commit-tree&lt;/code&gt;等底层命令来创建一个提交，思考哪些过程是与&lt;code&gt;git add&lt;/code&gt; &lt;code&gt;git commit&lt;/code&gt;等价的。&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;对象存储方式&quot;&gt;对象存储方式&lt;/h3&gt;&amp;#13;
&lt;p&gt;我们通过前面的介绍，知道了 Git 是将数据以不同的对象类型归纳，并且根据内容计算出一个 SHA 值用来作为寻址，那么到底是如何计算的呢？以 Blob 对象为例，Git 主要是做了如下几步：&lt;/p&gt;&amp;#13;
&lt;ol&gt;&amp;#13;
&lt;li&gt;识别对象的类型，构造头部信息，以&lt;code&gt;类型+内容字节数+空字节&lt;/code&gt;作为头部信息如&lt;code&gt;blob 151\u0000&lt;/code&gt;&lt;/li&gt;&amp;#13;
&lt;li&gt;将头部信息与内容拼接，并且计算 SHA-1 校验和&lt;/li&gt;&amp;#13;
&lt;li&gt;通过 zlib 压缩内容&lt;/li&gt;&amp;#13;
&lt;li&gt;通过 SHA 值将其内容放到对应的&lt;code&gt;objects&lt;/code&gt;目录&lt;/li&gt;&amp;#13;
&lt;/ol&gt;&amp;#13;
&lt;p&gt;整个过程就做了这些事情，Tree 对象和 Commit 对象也差不多，只是头部类型有所差异而已，这里不再赘述，《Pro Git 2》在 Git 内部原理章节中有介绍如何使用 Ruby 来实现同等的逻辑，感兴趣的可以自行翻阅。&lt;/p&gt;&amp;#13;
&lt;blockquote&gt;&amp;#13;
&lt;p&gt;Git-内部原理：&lt;a href=&quot;https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1&quot;&gt;https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1&lt;/a&gt;&lt;/p&gt;&amp;#13;
&lt;/blockquote&gt;&amp;#13;
&lt;h2 id=&quot;git-引用&quot;&gt;Git 引用&lt;/h2&gt;&amp;#13;
&lt;p&gt;我们在上面通过&lt;code&gt;git log --stat 17ae181b&lt;/code&gt;能够查看第一个版本的相关信息，并且可以通过这串 SHA 值拿到这个快照的内容，但是还是挺麻烦的，因为我们要记住一串毫无意义的字符串，这个时候 Git 的引用就派上用场了，在 Git 目录结构章节我们已经介绍了&lt;code&gt;refs&lt;/code&gt;目录，我们知道在引用中存储的就是 Commit 对象的键值，也就是这个对象的 SHA 值，既然如此，我们就给我们当前的版本起一个有意义的名字，一般我们会拿&lt;code&gt;master&lt;/code&gt;作为默认分支引用：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ &lt;span class=&quot;hljs-keyword&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;17ae181bd6c3e703df7851c0f7ea01d9e33a675b&quot;&lt;/span&gt; &amp;gt;&amp;gt; .git/refs/heads/master&amp;#13;
➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ tree .git/refs&amp;#13;
.git/refs&amp;#13;
├── heads&amp;#13;
│   └── master&amp;#13;
└── &lt;span class=&quot;hljs-keyword&quot;&gt;tags&lt;/span&gt;&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个时候，&lt;code&gt;master&lt;/code&gt;里面存储了我们的第一个 Commit 的 SHA 值，我们可以使用&lt;code&gt;master&lt;/code&gt;来代替&lt;code&gt;17ae181b&lt;/code&gt;这串毫无意义的字符串了&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;cat&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt; -&lt;span class=&quot;hljs-keyword&quot;&gt;p&lt;/span&gt; master&amp;#13;
tree aa406ee8804971cf8edfd8c89ff431b0462e250c&amp;#13;
author Zoker &amp;lt;kaixuanguiqu@gmail.&lt;span class=&quot;hljs-keyword&quot;&gt;com&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1613916447&lt;/span&gt; +&lt;span class=&quot;hljs-number&quot;&gt;0800&lt;/span&gt;&amp;#13;
committer Zoker &amp;lt;kaixuanguiqu@gmail.&lt;span class=&quot;hljs-keyword&quot;&gt;com&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1613916447&lt;/span&gt; +&lt;span class=&quot;hljs-number&quot;&gt;0800&lt;/span&gt;&amp;#13;
&amp;#13;
init commit&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是，这个并不是我们最新的版本，我们最新的版本是第二个提交&lt;code&gt;de96a74725dd72c10693c4896cb74e8967859e58&lt;/code&gt;，同样的，我们可以把&lt;code&gt;refs/heads/master&lt;/code&gt;的内容更改为这个提交的 SHA 值，但是这里我们使用一个底层命令来完成&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  &lt;span class=&quot;hljs-type&quot;&gt;Zoker&lt;/span&gt; git:(master) ✗ git update-&lt;span class=&quot;hljs-keyword&quot;&gt;ref&lt;/span&gt; refs/heads/master de96a74725dd72c10693c4896cb74e8967859e58&amp;#13;
➜  &lt;span class=&quot;hljs-type&quot;&gt;Zoker&lt;/span&gt; git:(master) ✗ cat .git/refs/heads/master&amp;#13;
de96a74725dd72c10693c4896cb74e8967859e58&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个时候，分支&lt;code&gt;master&lt;/code&gt;就指向了我们最新的版本&amp;#13;
&lt;img src=&quot;https://zoker.io/uploads/images/2021/0221/233032_874f10d4.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&amp;#13;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;&amp;#13;
&lt;p&gt;以上主要讨论了 Git 基础的存储原理以及一些实现，还有一些如 Pack 的打包、传输协商机制以及存储格式等，限于篇幅并没有说到，后面根据一些场景再另行讨论。&lt;/p&gt;&amp;#13;
&lt;blockquote&gt;&amp;#13;
&lt;p&gt;永远不要停下提升的脚步，想想还贷的压力、小孩的压力、渐渐老去的父母的压力，你是想要那种滥竽充数的心惊胆战，还是要怀才不遇的怆然涕下？&lt;/p&gt;&amp;#13;
&lt;/blockquote&gt;&amp;#13;
&lt;p&gt;&lt;img src=&quot;https://zoker.io/uploads/images/2021/0125/003521_d71b3ff1.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;转载请保留出处：微信公众号「Zoker 随笔」（zokersay）&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1c0499b61f2bd4240156fbb7919d2ffe</guid>
<title>[推荐] 带你深入理解 Java 内存模型理论</title>
<link>https://toutiao.io/k/0ic2o68</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3529480&quot; data-style-type=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3356876&quot; data-style-type=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.18170426065162906&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;798&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qMicvibdvl7p0KEd3bHYcm99nBiclZbia548oyvliaq8PrrmrcyuT3QS3urMcfaXDPEumnHP9KYcMV3Fad5Pepzic81Q/640?wx_fmt=jpeg&quot;/&gt;&lt;img data-ratio=&quot;0.23416666666666666&quot; data-type=&quot;gif&quot; data-w=&quot;1200&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/qMicvibdvl7p0shmw7MKGyutc63KZyibndlEzXkYJiaS1fUicrkRRKdOhPHMOic2dB36fnECUbaN0h6EJNcYU0HuY49g/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3335002&quot; data-style-type=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;本文字数：&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;5036 &lt;/strong&gt;&lt;/span&gt;字&lt;/p&gt;&lt;p&gt;预计阅读时间：&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;30&lt;/strong&gt;&lt;/span&gt;分钟&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Java并发是一个很大的主题，包含很多方面的知识。&lt;/span&gt;&lt;span&gt;本文从内存模型的角度分析，从概念理论上尽量精确理解Java内存模型，及其对并发的影响。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;h3&gt;文章目录&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;一. 引入&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;二. 内存模型的理解&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;1. 什么叫内存模型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;2. 顺序一致性模型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;3. happens-before 模型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;4. Java内存模型 及 “因果关系”（Causality）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;三. 提炼理念&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;1. 技术层次观念与思想方法的互通&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;2. executed 和 exhibit 的区别，及双向视图&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;一. 引入&lt;/h2&gt;&lt;h3&gt;1. 并发的概念&lt;/h3&gt;&lt;p&gt;&lt;span&gt;并发听起来是一个计算机术语，但计算机技术毕竟才发展百年，起初理念一定是来源于生活的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如在打饭窗口排队打饭，顾客排队的时候是空闲的，而打饭阿姨是忙碌的。没有并发的情况下，一个阿姨对应所有顾客，效率很慢。如果增加窗口同时进行，会成倍提高效率。当然，严格来讲这个情景可以叫“并行”，当每个菜盆在同一时间只有一个勺子可以打饭的时候才叫做“并发”。其中便包含了并发与并行的区别。由此可见，并发最原始的动力就是：充分利用长板，补齐短板，把空闲的东西利用起来，提高效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;特别的，在计算机技术领域。从冯·诺依曼提出计算机的五大组成部分开始，后来进一步抽象到主要由CPU、内存和I/O组成运转的体系，一直存在的问题就是速度差异巨大且一直存在，表现为 CPU 的速度 &amp;gt; 内存的速度 &amp;gt; I/O 设备的速度。为了充分开发利用计算机的潜能，体系结构、操作系统、编译程序等都做出了改变，比如CPU多核、流水线技术、进程线程概念、数据库中的事务处理等，足见这是一个普适的理念。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有得必有失。在成倍提高效率的同时，并发也引入了新的问题。主要包括：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;缓存导致的可见性问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;切换执行导致的原子性问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;重排序导致的有序性问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;这三个问题在很多文章中都有介绍，在此就不多赘述。为了解决这些问题，就引出了本文重点内存模型的概念。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;二. 内存模型的理解&lt;/h2&gt;&lt;h3&gt;1. 什么叫内存模型&lt;/h3&gt;&lt;section&gt;&lt;span&gt;还是先要明晰概念。内存模型是什么，用途是什么。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们已经知道，没有并发的程序执行起来效率是极慢的。于是在计算机技术的硬件软件各个层次对程序执行进行了大量的优化，比如缓存、并发、重排序等，但是这样会出现类似上一节中提到的安全性问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“究其原因在于“共享内存”的方式，即线程之间通过读写内存中的公共状态来隐式进行通信。但是如果没有一个执行顺序的规则，这些公共状态就会被以随机或者无法预知的顺序规则进行修改，程序执行结果也就无法保证。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;内存模型就是应用于此的一种规则，一种标准，用来保证程序的最终执行结果是符合代码期望逻辑的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;引用 JSR-133 中，笔者觉得最经典的一句话：&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;“These semantics do not describe how a multithreaded program &lt;/span&gt;&lt;span&gt;&lt;strong&gt;should be executed&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;. Rather, they describe the behaviors that multithreaded programs are &lt;strong&gt;allowed to exhibit&lt;/strong&gt;.”&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;顺便来提一下JSR-133是什么。JCP（Java Community Process Program）是管理 java 技术的官方组织，JCP制定的技术规范称为JSR（Java Specification Requests），可以翻译为Java规范提案。在 JDK5.0 中，加入了JSR-133的内容，JSR-133的全称是《Java Memory Model and Thread Specification》。这个提案更正了 volatile 和 final 语义的问题，也明确定义了Java内存模型的概念和规范，是直到现在Java并发编程的准则。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;原文中，should be executed，意思是应该如何执行，是实现层面的东西。而 be allowed to exhibit，意思是允许如何展示。由此可见，内存模型并不管底层是如何具体执行的，只是向上层形成了一个“视图”。在接下来的学习中可以慢慢体会这句原文。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;2. 顺序一致性模型&lt;/h3&gt;&lt;section&gt;&lt;span&gt;要理解Java内存模型，首先要理解顺序一致性模型：&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;在顺序一致性模型里，所有动作以全序（程序顺序）的顺序发生，与程序顺序一致；而且，每个对变量 v 的读操作 r 都将看到写操作 w 写入 v 的值，只要符合：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;执行顺序上 w 在 r 之前&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;执行顺序上不存在这样一个 w’ ，w 在 w’ 之前且 w’ 在 r 之前。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;以上是顺序一致性模型的定义，但是比较枯燥难懂。形象化地类比一下就像这张图：&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;img data-ratio=&quot;0.2859259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0eibqKmf1FgaH3M64V7YBVPibDby2W85gUARhzIUrLBuko5YVhzZUhEUCIA3uNqx8I2BC13eazZreg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1350&quot;/&gt;&lt;section&gt;&lt;span&gt;在顺序一致性模型里，所有动作都存在一个全序关系，与程序顺序一致，每辆车都是有编号的，想让他第几个过去必须按照编号排队；每一个动作都是原子的，不存在一辆车分成两半通过的情况，中间也不能插队；每个动作执行后立即对所有线程可见，一个通过之后立马有个大喇叭向后面所有车喊：“XXX已经过去了”。而且拒绝了一切的优化，不管车的大小胖瘦，都不可以并排通过。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;术语表述就是：保证了有序性、原子性和可见性，且拒绝一切优化。由此可见，顺序一致性模型好像回到了最原始的阶段，所以只能是一种理想模型。因为如果实际采用的话，L1  L2 Cache、流水线技术等都将变为非法（硬件工程师几十年的努力就拜拜了）。现实中的处理器和语言都是在顺序一致性模型的基础上，为了执行效率优化，做了不同程度的实现变通。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;3. happens-before 模型&lt;/h3&gt;&lt;p&gt;&lt;span&gt;happens-before 是我们提及JMM最常讨论的一个词，happens-before 规则在JSR-133中是通过 synchronized-with 边缘来辅助定义的。许多资料上将其总结为6条规则，实际上JSR-133中有更多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先来说 Synchronizes-With 边缘的规则定义。关于“边缘”这个词，英文原文中就是用的“Synchronizes-With Edges”来表述的，我意会的意思就像如果没有这个边缘，语句的执行是在一个平面上的，是可以来回换且不影响的，但是一旦出现这个边缘，就上了一个台阶，和前一个平面是不能互通的。或者理解成“border”这个词，有点界限的意思。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果存在以下七种情况，就认为存在Synchronizes-With 边缘。而只要存在Synchronizes-With 边缘，就存在happens-before关系。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;“monitor锁定规则”：某个monitor上的解锁动作 synchronizes-with 所有后续在其上的锁定动作；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;“volatile变量规则”：对volatile变量v的写操作 synchronizes-with 所有后续任意线程对v的读操作；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;“线程启动规则”：用于启动一个线程的动作 synchronizes-with 该新启动线程中的第一个动作；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;“线程终止规则”：线程T1的最后一个动作 synchronizes-with 线程T2中任一用于探测T1是否终止的动作；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;“线程中断规则”：如果线程T1中断了线程T2，T1的中断操作 synchronizes-with 任意时刻任何其它线程（包括 T2）用于确定 T2 是否被中断的操作；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;“默认值规则”：为每个变量写默认值（0，false或null）的动作 synchronizes-with 该线程中的第一个动作；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;“对象终结规则”：调用对象的终结方法时，会隐式的读取该对象的引用。从一个对象的构造器末尾到该引用的读取之间存在一个 synchronizes-with 边缘；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;在Synchronizes-With 边缘的基础上，还加入了两条，程序顺序规则和传递性规则，这两条是最基本的。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;ol start=&quot;8&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;“程序顺序规则”：如果 x 和 y 是 同一个线程中的动作，且在程序顺序上 x 在 y 之前，那么有 x happens-before y；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;“传递性规则”：happens-before 是传递闭包的。换而言之，如果 x happens-before y，且 y happens-before z，那么可以得到 x happens-before z。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;这9条共同定义了happens-before规则，满足这些的就可以说满足happens-before规则，具有了happens-before关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果一个动作 happens-before 另一个动作，则第一个对第二个可见，且第一个排在第二个之前。这在JSR-133中是一种非正式语义（Informal Semantics），是易于理解的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;happens-before已经是一种很强的保证了，所以我们经常说，一个操作是happens-before另一个操作的，就说明是可见的、顺序的、原子的。但是很多网上的理解都说happens-before就是Java内存模型的规则，这个当然是错误的。happens-before也是一种模型而已，它离真正的Java内存模型还差那么一点点。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;4. Java内存模型 及 “因果关系”（Causality）&lt;/h3&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;span&gt;终于到了主角。Java内存模型在JSR-133中有详细的定义，截取如下图：&lt;/span&gt;&lt;br/&gt;&lt;img data-ratio=&quot;0.8121178432462479&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0eibqKmf1FgaH3M64V7YBVPMqibSibQjPpLolH9Tf0GM24u7utjwoZy8P19KGYUBfyvp95uyzCWQkhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1799&quot;/&gt;&lt;section&gt;&lt;br/&gt;&lt;span&gt;其中用了很多符号和公式以及集合知识来表示线程的行为和行为之间的关系，但是太过复杂。确实只有这样他才能称之为一个规范、一个标准，是严密的经得起推敲验证的，有兴趣的读者可以自行研究。当然了，JSR-133也知道大多数人看不懂，给了一些解释，我们已经有了刚才两个模型的知识铺垫，可以迂回地去理解Java内存模型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Java内存模型和happens-before模型的那“一点点”差距，在于“因果关系”（Causality）。这是大部分博客都没有提过的，也比较绕。原文说的是，“Happens-Before is too Weak”。“因果关系”的表述是：一个写操作不能发生在一个其依赖的读操作之前，因为它涉及写操作是否会触发自身发生的问题。&lt;br/&gt;JSR-133原文目录如下图：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;img data-ratio=&quot;0.20935672514619882&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0eibqKmf1FgaH3M64V7YBVP36y3T3FPulDtbu7hVVWbLx7at1gLg8ToRib1k1QwdACqJHmnbGqECEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1710&quot;/&gt;&lt;p&gt;&lt;span&gt;举一个JSR -133给出的官方示例，如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5842894969108562&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0eibqKmf1FgaH3M64V7YBVPibN96ubGqbcQibI0JtMOS2qAN6cUrch9TiaVibEbPuhzVdStCPteoKlfVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2266&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;按照我们通常的理解，r1 == r2 == 0 是唯一合法结果。但是&lt;strong&gt;在 happens-before 内存模型下&lt;/strong&gt;，存在执行结果是 r1 == r2 == 1 的可能性，其原理如下图：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3722627737226277&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0eibqKmf1FgaH3M64V7YBVPhn2Olcv94ptI3rUXicfUt2rHOMew4lfFZpbHOAic6737e0oOWfm6nTGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1644&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;happens-before 内存模型下，这里在执行 r1 = x 的时候，已经看到了 x = 1 的执行结果。我们会感到奇怪，赋值在 if 里，为什么会已经看到了x = 1的写操作结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为程序这样表现没有违反 synchronizes-with 或 happens-before 边缘，是完全符合happens-before模型规定的，允许每个读操作看到其它线程写的值。读者可能会对上一节第8条程序顺序规则产生疑问，但是上述执行顺序确实已经遵守了单线程中的程序顺序规则。&lt;strong&gt;因为 r1 = x 并没有看到 y = 1 的执行结果，r2 = y 也没有看到 x = 1 的执行结果，这才是单线程的程序顺序规则。&lt;/strong&gt;这个问题笔者当时也纠结了一周，直到读了很多遍原文才明白。r1 = x 读操作 和 x = 1 写操作是两个线程的事情，按照happens-before模型单线程的程序顺序规则是不相互制约的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;顺便一提，这里是解释“标准”或者说“规范”的一个绝佳的例子。还记得那句话吗， should be executed 和 are allowed to exhibit。happens-before 包括JMM都只是一种规范理论，而不去管能不能实现或者怎么样实现（真实情况可能由于多级缓存可能由于重排序也可能先执行再决定是否回滚等，这些都是实现层面的事情）。在此处，由于遵守了 happens-before 规则的约定，所以此顺序的任意读操作可以看到任意写操作的结果，也就看到了x = 1的写操作结果。总的来说，要从一个内存模型而不是内存模型实现的角度去理解它。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;说回JMM，这种执行顺序是 happens-before 允许的，但JMM不允许，也就是上述的因果关系。所以，happens-before 模型可以理解为JMM的真子集，它们的差别就是因果关系（Causality）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因果关系正式的表述是：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;因果关系解决 什么时候一个顺序靠前的读操作 被允许看到 顺序靠后的写操作的执行结果（在 happens-before 基础上）：&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;具体到我们的代码，什么样的操作算是因果关系呢。其实我们的程序也就三种过程结构，顺序结构、选择结构、循环结构。在其中用到判断因果关系的地方，比如 if else, switch case等，用语义去理解就可以。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如如果感到幸福你就拍拍手，拍手的前提是感到幸福，这就是因果关系，是符合我们正常认知的，不用在写代码的时候刻意在意。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综上，对JMM的理解总结如下图：&lt;/span&gt;&lt;br/&gt;&lt;img data-ratio=&quot;0.6016771488469602&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0eibqKmf1FgaH3M64V7YBVPVVibLxFnD8TCbas2oTqVVfFexqY6YNUHh6JyzU18wTBBVJ53MGQuSqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;954&quot;/&gt;&lt;br/&gt;&lt;span&gt;我们终于可以比较全面地来理解Java内存模型了。Java内存模型是什么？上图是笔者总结JSR-133之后认为的干货。首先Java内存模型是一种共享内存方式的内存模型，它比起顺序一致性模型这种理想化模型要宽松很多，从编译到底层执行部分各个层次都做了不同程度的优化。和它最贴近的是happens-before内存模型，两者只相差一个因果关系的约束。在因果关系的前提下，只要它满足happens-before，就是JMM允许的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在我们的编程中，尤其要注意上一节所说的 happens-before 的第 1- 7 条规则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;了解JMM之后，我引用一个网上流传类似的图，看一下JMM在各种内存模型中处于什么样的位置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5470514429109159&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0eibqKmf1FgaH3M64V7YBVPZ88SgIpyMvPmfjd29fp9cqGmibc9gXbF2fJr2QEeFjicrzFDB0kjSVAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3188&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有两个可以说互斥的指标在约束着内存模型们。一般来说，易编程性越好，就是要注意的并发的坑越少，这个内存模型的执行性能就会越差。最极端的例子是顺序一致性模型，完全不用考虑这个变量会不会同时被两个线程操作之类的问题。当然我们不可能用这样的理想模型，因为我们对于执行性能是有很大要求的。菱形的是语言级别的内存模型，JMM相比C的内存模型会更严格一些，执行性能也会差一些。虽然语言级别的内存模型已经做了一些优化，但是处理器级别的内存模型还是会秒杀他们，对于用户不能感知的优化会更多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;三. 提炼理念&lt;/h2&gt;&lt;h3&gt;1. 技术层次观念与思想方法的互通&lt;/h3&gt;&lt;p&gt;&lt;span&gt;类似并发这样的思想在计算机技术的每一个层次都会用到。比如在CPU层为了并发用到了多级缓存，会产生不一致的问题，MESI协议在这一层解决了这个问题，给了CPU使用者一个统一的视图。但是在上层，如操作系统、汇编语言、高级语言等层次也会用到缓存等提高效率，这时候MESI不能解决这些层次的问题，需要该层次对应的解决办法，如高级语言层次的Java内存模型。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;2. executed 和 exhibit 的区别，及双向视图&lt;/h3&gt;&lt;p&gt;&lt;span&gt;内存模型对于开发者强调的概念是如何&lt;strong&gt;表现&lt;/strong&gt;，就像一个黑盒展现给人们的输入输出视图。JMM协调了底层硬件和上层开发者之间相反的需求，形象表示如下图：&lt;/span&gt;&lt;br/&gt;&lt;img data-ratio=&quot;0.33560864618885095&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0eibqKmf1FgaH3M64V7YBVPT3Etzicz78WkIjKYcPpKM6Q8o67xOQBDia4eInibx2ApHghdJib9lyYic9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1758&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JMM做出了双向承诺：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从Java开发者的视角，希望内存模型易于理解、易于编程，所以希望基于一个强内存模型来编写代码。JMM向开发者提供保证，只要程序是正确同步的（满足A happens-before B 和因果关系），那么A的操作结果一定对B可见，且A的执行顺序排在B之前。虽然这么说是骗我们的，但是我们心甘情愿被骗了。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从编译器和处理器的视角，希望内存模型对其优化的束缚越小越好，这样就可以尽可能提高性能，所以希望实现一个弱内存模型。JMM遵循一个基本原则：只要不改变程序的执行结果（单线程程序和&lt;strong&gt;正确同步的&lt;/strong&gt;多线程程序），编译器和处理器可以随意优化。这里的“正确同步”就是指如volatile、synchronized等规定的具体规则，不多赘述。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;本文主要从内存模型理论的角度，分析了内存模型的概念和侧重点，运用逼近的方法理解Java内存模型，尤其深入了“因果关系”的概念，帮助大家了解 happens-before 模型和JMM的区别。同时浅析了JMM中涉及的技术理念。具体实践方面有更多的问题需要学习探究，如volatile、synchronized底层原理与应用方法、并发相关JUC类库等，可以继续深入研究。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-ratio=&quot;0.2777777777777778&quot; data-s=&quot;300,640&quot; data-type=&quot;gif&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/qMicvibdvl7p15cy8dCBsQ3qGTK2dseYLWrVLkN9aFvGpjpnjDGxz1LCUaNpQvHGPvkzokhibu8B66J5uOhiaHFslg/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;a class=&quot;weapp_image_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wx17eb4d48e11ce306&quot; data-miniprogram-path=&quot;interbar/pages/topic?id=179189&amp;amp;type=2&quot; data-miniprogram-nickname=&quot;小互动助手&quot; href=&quot;&quot; data-miniprogram-type=&quot;image&quot; data-miniprogram-servicetype=&quot;&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.64&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p3iaGw410lUuf12ZXwtXKiaMyATYBpLfibvBvpmicsegZnX7JUe5T3eEzrOkbHibicd3em145Y5soC9Z0Lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.41875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qMicvibdvl7p3emlMBeH8cjIR9M42WeicHrLqtvW5kllgTtwrO1eCibhhfYn20Lkiagb0xibNBk6JibBaNiazVDicQicDK4w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>77468a6042677575b66f7843d3c67836</guid>
<title>[推荐] 21 大软件架构特点的全面解析</title>
<link>https://toutiao.io/k/2n0entj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section&gt;作者 | sergiuoltean&lt;/section&gt;&lt;section&gt;策划 | 万佳&lt;/section&gt;&lt;p&gt;众所周知，架构特点多以&quot;ility&quot;结尾（例如 scalability、deployability），也被称为 NFR（非功能需求）、质量属性。架构的特点没有固定清单，但标准是有的，就是 ISO25010：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.28203125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erqVFrDFzHyB9k3US7k8UdllGNpeuibRBMD0f4C6UbOe1k2Qw9hmzNQa9Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们从业务需求（业务特征）、我们期望的系统运营方式（运营特征）中总结出这些特点，它们是隐式的、贯穿各领域，是架构师在字里行间能看出来的特点。《软件架构基础》书中的这张表是隐藏特点的一个例子。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.24406224406224405&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1221&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erqiaO89N3PN3Quvvn5oz6zDXIZTD4ZhyXibWHoMibiauodxZ2yzzdVF5IiaVg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;《实践中的软件架构》一书中对架构特点解释得很清楚。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4306640625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erq6zECHjPicDPLxm41ZeTiaI08emicaFDcofcYTlNBLibMlgPflviawQ16K3g/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;刺激的来源（Source of Stiumulus）可以是角色、触发事件的东西等。刺激（Stimulus）是实际产生的事件。环境（Environment）代表事件发生的系统条件。工件（Artifact）是系统中正在被刺激的部分。响应（Response）就是工件在我们应该度量（measure）的刺激下的行为方式。背景了解完毕，让我们来看具体的特点。&lt;/p&gt;&lt;section&gt;&lt;span&gt;1&lt;/span&gt;性能&lt;/section&gt;&lt;p&gt;根据 Smith 所说，“性能是指响应能力：响应特定事件所需的时间，或给定时间间隔内处理的事件数”。性能可以有以下指标：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;延迟&lt;/strong&gt; 。表示获得响应之前经过的时间，这里指的是一段时间。我们有最小延迟（开始时间）和 &lt;strong&gt;截止日期&lt;/strong&gt; （结束时间）。衡量延迟的其他因素包括 &lt;strong&gt;优先级&lt;/strong&gt;（我们在其中查看响应的顺序）和 &lt;strong&gt;抖动&lt;/strong&gt; （随时间观察到的延迟波动）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;吞吐量&lt;/strong&gt;。是指在固定时间间隔内获得的响应数。但为了提高精度，我们应该度量多个时间间隔。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;可用容量&lt;/strong&gt;。以上度量的结合体。在不超出延迟要求的情况下可实现的最大吞吐量。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;可调度的利用率&lt;/strong&gt;。利用率是资源繁忙时间的百分比，而可调度的利用率是满足一定时间要求的最大利用率。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;数据丢失&lt;/strong&gt;。如果使用缓存来提高性能，那么缓存未命中将成为性能指标。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span/&gt; 提高性能的技术&lt;/section&gt;&lt;p&gt;首先我们要了解影响性能的因素。&lt;/p&gt;&lt;p&gt;我们需要控制需求，为此我们可以使用队列、节流和背压机制。通过改进算法，我们可以减少资源需求。通过设置最大响应时间（超时）和某种优先级，我们可以进一步控制需求。&lt;/p&gt;&lt;p&gt;可以使用垂直缩放来获得更好的响应时间。提高性能的另一种方法是并发。还需要注意阿姆达尔定律。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7503105590062111&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;805&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erqkHkGgQ2nGKvvCoiaTV5nlOb4ltrOxItm0MqrEjIVqCAwChaEtpcRV6Q/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;加速效果的瓶颈是程序的串行部分。例如，如果 95％的代码可以并行化，则并行计算的理论最大加速比将是 20 倍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;限制你的资源、对所有内容（线程、队列）实施固定的生产限制、规划资源使用并尽可能避免争用……这些说起来容易，做起来难。还可以充分利用缓存、水平缩放、添加多个处理单元等。&lt;/p&gt;&lt;p&gt;你应该了解你的框架和你的数据库，并优化它们。&lt;/p&gt;&lt;section&gt;&lt;span&gt;2&lt;/span&gt;可靠性&lt;/section&gt;&lt;p&gt;根据《牛津词典》，可靠意味着质量或性能始终如一，且能够被信任。可靠性可以用平均故障间隔时间（MTBF）来表示，可靠性 =exp（-t/MTBF）。&lt;/p&gt;&lt;p&gt;可靠性很难用数字度量。我们可以用一些软件指标衡量复杂度和代码覆盖率，以了解可靠性的边缘情况。适应度函数也可用于度量可靠性。未解决问题的数量、成功的构建和部署的数量也是一些可用指标。ISO-9001 是衡量可靠性的另一种方法。&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://sergiuoltean.com/2020/04/29/fitness-functions/&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 提高可靠性的技术&lt;/section&gt;&lt;p&gt;遵循最佳工程实践将产生更好的产品。使用更好的管理实践和流程，可以实现更高的可靠性。突变测试技术会让系统考虑边缘情况。混沌测试是提高可靠性的另一个重要工具。总之我们要强化系统来提高可靠性。&lt;/p&gt;&lt;section&gt;&lt;span&gt;3&lt;/span&gt;可用性&lt;/section&gt;&lt;p&gt;表示可用系统时间与总工作时间的比率。这是可靠性之上的另一层。它是系统掩盖或修复特定阈值（例如时间间隔）内故障的能力。可用性可以表示为&lt;/p&gt;&lt;p&gt;在公众号互联网架构师后台回复“2T”，获取Java面试题和答案惊喜礼包。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.30526315789473685&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;380&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erqtkqWLJibqaGVWw8aKuxrCLAFYVIxu4hOw7q8wVB9dswQb54Tcq4U8aw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;MTBF= 平均无故障时间；MTTR= 平均修复时间&lt;/p&gt;&lt;p&gt;于是我们计算出下表：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2532894736842105&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1216&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erq5viaev7W7cZ6Fiaicc4OgLcfWGeVZEaKBwicZI4dXxOWvdVQdtd2HzZfaw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 提高可用性的技术&lt;/section&gt;&lt;p&gt;为了提升它，首先我们需要检测潜在的故障。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.21428571428571427&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1218&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erq6guAullicqfZVgjtTuh4SefwcHC6OIeqr9zKMbmb4mJl48OWsH2Zc5Q/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;检测到异常情况后，我们可以进行干预。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3235053235053235&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1221&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erqHHiaLlc8VHJvliaNFm3hVS1icpKgiaxHKuetLkhAPqmdjly309jJz9oNyQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;4&lt;/span&gt;弹性&lt;/section&gt;&lt;p&gt;弹性指的是系统遇到问题时可以降级（而非中断服务），等待问题修复完成，表示的是系统在遇到严重故障时的持续运行能力。为实现弹性，需要提前设置防御机制（断路器模式）。弹性有时被称为&lt;strong&gt;容错性&lt;/strong&gt; 。弹性系统指的是可以适应压力并持续运行的系统。很难用数字指标来度量弹性。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 增强弹性的技术&lt;/section&gt;&lt;p&gt;首先是确定潜在风险：系统有哪些关键功能？哪些硬件至关重要？然后我们需要实施保护策略，为此需要检查哪些事件可能导致这些重要部件发生故障。找出风险因素后就需要确定容忍阈值。具体的保护策略包括对请求数和线程数施加限制、缓存相同的请求、批量发送请求等。&lt;/p&gt;&lt;section&gt;&lt;span&gt;5&lt;/span&gt;可信赖性&lt;/section&gt;&lt;p&gt;它包括&lt;strong&gt;可靠性&lt;/strong&gt; 、&lt;strong&gt;可用性&lt;/strong&gt; 、&lt;strong&gt;弹性&lt;/strong&gt; 、&lt;strong&gt;可持续性&lt;/strong&gt; （可用性 / 弹性的比值）、&lt;strong&gt;可恢复性&lt;/strong&gt; （弹性函数）和 &lt;strong&gt;稳健性&lt;/strong&gt; （可靠性函数）。我们应该始终将它们视为一个整体。&lt;/p&gt;&lt;p&gt;拿一辆汽车来说，如果它是新车并且是知名的可靠品牌（例如梅赛德斯），我们可以说它是可靠的。它有备用轮胎，所以有一些可用性。四轮驱动意味着弹性，其中两轮出故障还有两轮能工作（但性能会下降）。可持续性是可用性（备用轮胎）和弹性（四轮驱动）的综合。健壮性在这里可以指道路通过能力。如果汽车是电动的，那么充电速度就是一个可恢复性指标。&lt;/p&gt;&lt;section&gt;&lt;span&gt;6&lt;/span&gt;可伸缩性&lt;/section&gt;&lt;p&gt;它是系统在重负载下在可接受的阈值内的执行能力。它分为手动和自动可伸缩性两种，后者也叫 &lt;strong&gt;灵活性&lt;/strong&gt; 。当负载突增时，系统会做出反应并水平缩放（添加 / 删除更多实例）。我们可以查看 CPU 和内存来观察这些突发事件。这些突发操作完成后，系统将杀死不必要的实例，从而降低成本。垂直伸缩意味着我们向系统添加了更多物理资源（例如更多的内存、更好的 cpu）。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 实现可伸缩性的技术&lt;/section&gt;&lt;p&gt;这里涉及到 devops，最好使用 aws fargate 之类的云服务。&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://aws.amazon.com/fargate/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;下图中可以看到放大和缩小策略。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3251953125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erqictxBRPIvNIDX5kz4Fg7qEJk6VdYhfT3DTxjlgbUx7USx7QJU3uvsibw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;7&lt;/span&gt;安全性&lt;/section&gt;&lt;p&gt;它实际上是许多特点的集合：&lt;strong&gt;机密性&lt;/strong&gt; 是指系统保护用户数据安全的能力；&lt;strong&gt;完整性&lt;/strong&gt; 是保护外部资源免遭篡改的能力；&lt;strong&gt;身份验证&lt;/strong&gt; 允许用户访问系统；&lt;strong&gt;授权&lt;/strong&gt; 则告诉用户可以访问系统的哪些部分。授权通常使用 RBAC、ACL 或 ABAC 来实现。&lt;strong&gt;不可否认性&lt;/strong&gt; 保证了消息的发送者不能否认自己发送了消息，并且接收者也不能否认自己接收了消息。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 增强安全性的技术&lt;/section&gt;&lt;p&gt;首先我们需要检测。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1722723543888433&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1219&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erqnGXRrSgAyiacrwUFzmKc3p7as8nV0Dju5txibtFXWlONeP5kMFhtawMQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;针对攻击行为，我们需要制定灵活的应对策略。大多数情况下我们可以撤消访问权限，在某些极端情况下我们可以关闭系统，当然最好还是避免后一种情况出现。最好使用成熟的安全解决方案，自行实现往往不是好办法。&lt;/p&gt;&lt;section&gt;&lt;span&gt;8&lt;/span&gt;互操作性&lt;/section&gt;&lt;p&gt;它表示系统与外部系统通信的能力。合约接口是互操作性中最重要的概念，其涵盖了通信的所有方面，包括错误处理。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 改善互操作性的技术&lt;/section&gt;&lt;p&gt;最好的策略是使用企业集成模式。如果用到多个通信协议，这种策略就是最佳方法。&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://learning.oreilly.com/library/view/enterprise-integration-patterns/0321200683/&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;9&lt;/span&gt;可调整性&lt;/section&gt;&lt;p&gt;也称为 &lt;strong&gt;可变性&lt;/strong&gt; ，其描述了系统变化的难易程度。一般来说它是一个隐含的特征。作为架构师，你要知道系统变化的概率是未知的，但一旦出现变化，系统应该能够优雅地应对。变化是软件世界中唯一确定的事物。话虽如此，我们不能将整个系统都设计为可变组件。如果每个组件都是即插即用组件，设计就做不完了。因此我们需要找到那些变化概率很高的部分。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 改进可调整性的技术&lt;/section&gt;&lt;p&gt;有两个维度。作为一名架构师，你需要确定哪些部分具有较高的变化概率；作为软件工程师，你必须确保这些部分容易改动。遵循 SOLID 原则是一个很好的开始。可以使用适应度函数度量传入和传出耦合。我们需要计算变化成本。比如要构建一个 UI 表单，它需要的位置比我们最初想像的要多，则我们可以复制粘贴代码并进行必要的调整，也可以构建一个新组件并插进来。然后我们得到了变化的成本：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;N x 编写代码的成本（复制粘贴）&amp;lt;= 编写组件 +（N x 将其插进来的成本）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;还需要考虑时间，观察较长的时间才能得到可靠的观察结果。&lt;/p&gt;&lt;section&gt;&lt;span&gt;10&lt;/span&gt;可部署性&lt;/section&gt;&lt;p&gt;所有系统都应封装在某种工件中，可以是 war、jar、ear、apk、dll、gem 等。它们被部署在能够运行它们的环境中。由于 docker 的进化，现在我们可以在一台机器上拥有多个环境。可部署性是一种将代码转换为客户可用产品的机制。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 改善可部署性的技术&lt;/section&gt;&lt;p&gt;最有效的是实施持续集成 / 持续部署（CI/CD）。认真的话，每次代码推送都将触发一个生产部署。为此，应通过适应度函数和自动化测试来保护你的代码。它是抗脆弱性的关键部分。我们希望能按需部署，一键完成工作。我们也会部署硬件。使用基础架构即代码之类的技术可以提高效率。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erqzn6VSE0NOrhUxApjTwYtAhCpu6Okwo1AQPicVU2MFOiapYbS2KiazAAsg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;11&lt;/span&gt;可测试性&lt;/section&gt;&lt;p&gt;在所有系统中它都是一个重要特征。我们必须确保构建的系统尊重了客户的需求。复杂的系统很难测试。以微服务架构为例，我们有很多独立开发的活动部件。这个特征经常会让步给其他特征。为了使系统可测试，我们需要能控制每个组件的输入和输出。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 改善可测试性的技术&lt;/section&gt;&lt;p&gt;请尽量控制系统的复杂性。我们应该构建较小的组件，不要重新发明轮子；还应该编写可测试的代码，在适当的位置应用 TDD。&lt;/p&gt;&lt;section&gt;&lt;span&gt;12&lt;/span&gt;简单性&lt;/section&gt;&lt;p&gt;这条特征是很难实现的。一切都是权衡取舍，而大多数情况下这一条都会被牺牲掉。但如果我们需要在有限的时间内快速构建某些东西，那么就应该优先考虑简单性。在构建 MVP（最小可行产品）时，我们关心的只有简单性。但请注意，实现目标之后，我们不应丢掉所有东西。不要与 PoC（概念验证）或某种 R&amp;amp;D 混淆。&lt;strong&gt;可重用性&lt;/strong&gt; 在这里也很重要。在公众号互联网架构师后台回复“2T”，获取一份惊喜礼包。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 改善简单性的技术&lt;/section&gt;&lt;p&gt;可以构建粗粒度的组件；使用 RAD 框架，例如 ApacheIsis、Vaadin 或 JHipster；牺牲简单性之前请确保自己能承受对应的代价；遵循 KISS 原则。记住时间是关键：先跑起来，再考虑美观和性能。&lt;/p&gt;&lt;section&gt;&lt;span&gt;13&lt;/span&gt;可移植性&lt;/section&gt;&lt;p&gt;指的是系统从一个操作系统移植到另一个的能力，它会影响编程语言的选择。例如，我们知道为了运行 Java 代码需要一个 JVM，因此问题就是“JVM 是否可移植？”答案是肯定的。另一个例子是 golang：它打包为二进制文件，不需要外部依赖项，因此是可移植的。一些微软专属技术就不行，它们只能运行在微软操作系统中。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 改善可移植性的技术&lt;/section&gt;&lt;p&gt;一个显而易见的选项就是容器化、docker。一个 docker 引擎能够运行多个隐藏了实现细节的 docker 容器。&lt;/p&gt;&lt;section&gt;&lt;span&gt;14&lt;/span&gt;易用性&lt;/section&gt;&lt;p&gt;谈到易用性时通常会提到 &lt;strong&gt;可配置性&lt;/strong&gt; ，即用户自定义系统的能力，比如通过 UI 主题更改外观和配置系统行为（例如控制用户访问权限等）。还有 &lt;strong&gt;本地化&lt;/strong&gt;，也称为 i18n（internationalization）。它指的是系统支持多种标准的能力，一般是通过用户体验（UX）实现的。这里的标准指的是语言、货币、公制单位、字符编码等。本地化资源通常是静态的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可访问性&lt;/strong&gt; 是另一个易用性特征。世界上有些人是残疾的（失明、听力受损、色盲），我们如何确保这些人可以受益于我们的系统呢？对于色盲来说，选择颜色会花很多时间。Siri/Alexa 是盲人的好帮手。考虑可访问性时，请想到我们的祖父母是不是能方便地使用我们的系统。&lt;/p&gt;&lt;p&gt;另外还有 &lt;strong&gt;可支持性&lt;/strong&gt; ，比如说帮助页面或者 24x7 技术支持。我们应该努力让系统直观易用，这会影响可学习性，也就是用户习惯系统所需的时间。用户培训和帮助页面之类的策略很好用。&lt;/p&gt;&lt;section&gt;&lt;span&gt;15&lt;/span&gt;可扩展性&lt;/section&gt;&lt;p&gt;它是描述系统对即插即用组件需求程度的特征。对于使用内核架构的系统来说，这是很重要的特征。Eclipse Platform 和 OSGI 标准就是经典的例子。&lt;/p&gt;&lt;section&gt;&lt;span&gt;16&lt;/span&gt;抗脆弱性&lt;/section&gt;&lt;p&gt;它是系统应对压力、冲击、波动、噪声、错误、故障或攻击的能力。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8887993553585818&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1241&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erqRaQgOWhjpJNO9eeIc9UNz8y2TKtUCnDexX76UqjHoSfYmBvANTGtgg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 改善抗脆弱性的技术&lt;/section&gt;&lt;p&gt;首先我们要敲打敲打系统。可以使用 CI/CD，它们本来就是做这种事的。每次代码更改都必须投入生产。当然，我们也要有防御机制，适应度函数就是个好方法；Simian Army 也是个不错的工具。&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://github.com/Netflix/SimianArmy&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;17&lt;/span&gt;可升级性&lt;/section&gt;&lt;p&gt;它是指系统无缝升级自身的能力。对于非 Web 产品（例如 App Store 和 Google Play），这很容易实现，因为它们的升级能力是嵌入到 OS 中的；涉及到 Web 应用时，事情就麻烦多了。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 改善可升级性的技术&lt;/section&gt;&lt;p&gt;首先我们需要为服务提供版本控制。下一步是使用蓝绿部署或金丝雀部署等策略进行零停机的时间部署。&lt;/p&gt;&lt;section&gt;&lt;span&gt;18&lt;/span&gt;合规性&lt;/section&gt;&lt;p&gt;不管我们需要的是哪种第三方工具和框架，都应该得到它们的合法授权。我们需要重视开源软件的合规性因素，因为它们可能会附带一些我们不想要的额外约束。没有人愿意暴露自己的源代码，因此我们应该远离 GPL 许可证。在欧盟，《GDPR》已成为强制规定，因此我们需要确保系统符合其规定。还要考虑一些 ISO 标准，公司可能需要遵循某些流程才能符合它们的要求。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.66640625&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erqc34toXzc9KFA2TNLzt6Tt6j9FNNDQZGbPg2ZMISO78AHNjcTeoxARA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 改善合规性的技术&lt;/section&gt;&lt;p&gt;理想情况下，每家公司都应该有一个法律部门，但现实并非如此。适应度函数（例如许可证检查）可以保护我们免受列入黑名单的许可证的影响。在设计系统时，我们必须找到一种保护用户数据隐私的方法。&lt;/p&gt;&lt;section&gt;&lt;span&gt;19&lt;/span&gt;成本&lt;/section&gt;&lt;p&gt;可能是最重要的架构特点。一切都有成本，虚拟的、还是现实的都一样。任何成本都可以换算成金钱。如果我们需要购买某些工具（IDE）、云服务（例如 AWS）、第三方框架（例如 new-relic）的许可证，则总会产生财务成本。开发团队也要发工资，学习新技术或培训团队成员需要花钱。不尊重敏捷宣言是有代价的；错误的代码要付出代价；缺少单元测试会有代价；缺少 CI/CD 会有代价；没有基础架构即代码也会有代价……这个列表是没有尽头的。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 降低成本的技术&lt;/section&gt;&lt;p&gt;帮助客户控制成本是我们的责任。我们需要区分单纯的成本和投资，并让客户相信投资是划算的。&lt;/p&gt;&lt;p&gt;以 Scrum 流程为例，我个人认为它没什么用。在一个固定的周期（通常为两周）中，我们有这么多的仪式（计划、站会、演示、回顾），然后根据（猜出来的）估计值做计算，结果 Sprint 完成度 100％只是偶然而非必然。我们需要敏捷和适应，而不是盲目地遵循流程。我们应该减少会议和仪式，这样成本就会下降。我们应该专注于完成工作的本质要素。&lt;/p&gt;&lt;p&gt;测试是必要的投资，快速前进的唯一方法就是正确前进。我们必须说服客户，从长远来看，成本是会下降的。测试会减少错误的数量，从而减少成本。&lt;/p&gt;&lt;p&gt;代码质量是另一项投资。好的代码将带来更好的测试，提高稳健性、可维护性、可调整性等。与难以维护的系统相比，我们的更改花费的时间会更少，成本会下降。&lt;/p&gt;&lt;section&gt;&lt;span&gt;20&lt;/span&gt;可存档性&lt;/section&gt;&lt;p&gt;指系统保留历史数据记录的能力。在数据是一等公民的系统中（例如财务系统），这个特征非常重要。数据绝不会删除，而只会归档，这主要是考虑到法律要求。可归档性是对可审计性的支持。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 实现可归档性的技术&lt;/section&gt;&lt;p&gt;首先是在数据上使用时间戳（例如 updatedOn、createdOn）。然后要有一个 cron 作业，将所有低于特定阈值的数据移入历史表中。另一种技术是将数据标记为软删除，但这会影响查询性能。&lt;/p&gt;&lt;section&gt;&lt;span&gt;21&lt;/span&gt;可审核性 / 可跟踪性&lt;/section&gt;&lt;p&gt;这是支持重构历史的系统特征。我们必须记录所有关键操作（尤其是在安全场景中），以便重现问题并从错误中学习经验。我们也可以将这些记录用作法律依据。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 实现可审核性的技术&lt;/section&gt;&lt;p&gt;记录每个关键操作并集中存放这些记录。可以使用 ELK，或 sleuth-zipkin 具。&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.elastic.co/what-is/elk-stack&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://sergiuoltean.com/2017/10/04/zipkin-sleuth/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原文链接：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://sergiuoltean.com/2020/06/26/architecture-characteristics/&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9a908d85c771cf68a7c5f0e7df02613f</guid>
<title>[推荐] 8 张图带你了解大型应用架构演进历程</title>
<link>https://toutiao.io/k/xuv7rlf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;几乎所有的大型应用都是从一个小应用开始的，好的互联网产品是慢慢运营出来的，不是一开始就开发好的，所以本篇我们来聊聊应用架构的演进历程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何打造一个高可用，高性能，易扩展的应用？首先我们了解一下大型应用的特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;高可用：系统需要不间断的提供服务，不能出现单点故障&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高并发：在大流量的冲击下，系统依然稳定提供服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大数据：应用每天都会产生大量的数据，需要存储和管理好这些数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最简单的架构&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚开始应用没有太多访问量，所以只需要一台服务器，这时候的架构如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.49375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQnhRK7RWJs1RJBAsCylY5WYZqKUibUtt1IHr52b7QqeQ7gEsJxiaJSKTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;最简单的架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用程序、文件、数据库往往都部署在一台服务器上。应用程序可以采用Java开发，部署在Tomcat服务器上，数据库可以使用开源的MySQL&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;应用与数据服务分隔&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着应用的业务越来越复杂，应用访问量越来越大，导致性能越来越差，存储空间严重不足，这时候我们考虑把服务增加到三台（能通过加机器解决的问题都不是问题）；分离出应用服务器、数据库服务器、文件服务器。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;应用服务器需要处理大量的访问，所以需要性能更好的CPU&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据库服务器需要存储大量的数据以及快速的检索，所以需磁盘的检索速度较快以及存储空间大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;文件服务器需要存储上传的文件，需要更大的磁盘；现在通常情况下会选择第三方的存储服务&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.465&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQjQYNRwSLTtGmJU0mqtSiciae0QrC31XdGAtIyNtXeKDq78A5ibKGej99w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;应用与数据访问服务分隔&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据每个服务器对应的场景，配置服务器后应用的性能能够大大提高，更好的支持业务的发展。但是随之业务的发展，访问量的增大，这种架构又将再次面临挑战，应用服务器处理能力下降，存储空间不足&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;应用服务器集群&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发，大流量的情况下，一台服务器是肯定处理不过来的，这个时候增加服务器，部署集群提供服务，来分担每台服务器的压力。部署集群的另一个好处是可伸缩性，比如当遇到了双11大流量的场景下，可以增加服务器分摊流量，等双11过后，减少服务器节约成本。架构如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQWicNMqzicoMC1HHaxaz8hU18d75CRCibvX9V1pg3f7UuuicNywX80licbpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;应用服务器集群&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果应用服务器是Tomcat，那么可以部署一个Tomcat的集群，外部在部署一个负载均衡器，可以采用随机、轮询或者一致性哈希算法达将用户的请求分发到不同应用服务集群；通常选择的免费的负载均衡是nginx。在这种架构下，应用服务器的负载将不会是整个应用的瓶颈点；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然应用程序的处理速度在这种架构下提升了许多，但是又会暴露一个问题，数据库的压力大大增大，导致访问响应延迟，影响整个应用的性能。这种架构还有个问题，通常应用是有状态的，需要记录用户的登录信息，如果每次用户的请求都是随机路由到后端的应用服务器，那么用户的会话将会丢失；解决这个问题两个方案：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;采用一致性hash把用户的请求路由到同一个Tomcat，如果有一台服务器跪了，那么这台服务器上面的用户信息将会丢失&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Tomcat集群之间通过配置session复制，达到共享，此方案效率较低&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个方案都不是很好，那么还有其他的方案吗？请继续往下看&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;缓存&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据二八原则，80%的的业务都是集中访问20%的数据，这20%的数据通常称为热点数据，但是这20%的数据占用的内存也不会小，如果每个应用服务器都存放一份，有些浪费存储空间，所以这时候需要考虑加入分布式缓存服务器（常用的是Redis）；当引入了分布式缓存服务器，再来看上面那个方案的问题，就可以解决了，把用户的会话存放到缓存服务器，不仅可以防止用户数据丢失，效率也不低；架构图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.52&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQPwuUagZ0h3Jz3w7lDgwV8YtoACOZsr2wbTIR9K6x7cHXaib05yNN4nA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;缓存&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于分布式缓存服务器毕竟存放在远程，需要经过网络，所以取数据还是要花一点时间；本地缓存访问速度更快，但是内存空间有限，并且还会出现和应用程序争抢资源；所以这种架构搭配了分布式缓存和本地缓存，本地缓存存放少量常用热点数据，当本地缓存中没有命中时在去集中式缓存取&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在引进缓存之后，数据库的访问压力可以的一定的缓解&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据库读写分离&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然在加入了缓存之后，部分数据可以直接走缓存，不需要访问数据库，但是任然会有一些请求，会访问数据库，比如：缓存失效，缓存未命中；当流量大的时候，数据库的访问量也不小。这时候我们需要考虑搭建数据库集群，读写分离&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQruU99JpAljqiaYjHbZ9KmcCQX4PFdicBuFiaNV6FW9D6ptiaXZBnoEhHXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;数据库读写分离&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当应用服务器有写操作时，访问主库，当应用程序有读操作时，访问从库；大多数的应用都是读的操作远远大于写的操作，所以可以配置数据库一主多从来分担数据库的压力；为了让应用程序对应主库和从库无感知，通常需要引入一些读写分离的框架做一个统一的数据访问模块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种架构通常需要警惕的一个问题是主从延迟，当在高并发的场景下，主库刚写成功，数据库还未成功同步完从库，这时候另一个请求进入读取数据发现不存在；解放方案是在应用程序中高并发的场景下设置强制走主库查询&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;兄弟们，请不要白嫖哦，文章看一半，请先点个赞&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;反向代理和CDN&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如随着业务的不断扩大，全国各地都会使用到我们的应用，由于各地区的网络情况不同，所以有的人请求响应速度快，有的人请求响应速度慢，这会严重的影响到用户的体验。为了提高响应速度需要引入反向代理和CDN；CDN和反向代理都是采用的缓存，目的：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.50125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQ9r7nTCb9u4zPRzhvmxmDqBx82gUT6NzlAJuqvfZWTRXTgFicV2GOibiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;反向代理和CDN&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CDN: 部署在网络提供商的机房，当用户来访问的时候，从距离用户最近的服务器返回数据，尽快呈现给用户；通常情况下在CDN中缓存的是静态资源（html,js,css），达到动静分离；但是有时候遇到了某些数据访问量特别大的时候，后端会生成静态资源放入到CDN，比如：商城的首页，每个用户进入都需要访问的页面，如果每次请求都进入到后端，那么服务器的压力肯定不小，这种情况下会把首页生成静态的文件缓存到cdn和反向代理服务器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反向代理：部署在应用的中心机房，通常也是缓存的静态资源，当用户通过CDN未请求到需要的数据时，先进入反向代理服务器，如果有缓存用户访问的数据，那么直接返回给用户；这里也有特殊情况，对于有些场景下的热点数据，在这里根据用户的请求去分布式缓存服务器中获取，能拿到就直接返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种架构已经把缓存做到了4级&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一级：CDN 缓存静态资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二级：反向代理缓存静态资源以及部分热点数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三级：应用服务器的本地缓存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第四级：分布式缓存服务器&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下经过了这4级缓存，能够进入到数据库的请求也不多了，很好的释放了数据库的压力&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;搜索引擎和NoSQL&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着业务的不断扩大，对于数据的存储和查询的需求也越来越复杂，通常情况我们需要引入非关系型数据库，比如搜索引擎和NoSQL数据库&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.60375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQ6Wcj8ynjq3PjCVPKib7Q7YanbrbdsicibgYIViaKB2tz0xDGI9lf8fFrUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;搜索引擎和NoSQL&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候我们的查询场景很复杂，需要查询很多数据表，经过一系列的计算才能完成，这时候可以考虑通过数据同步工具（比如canal）拉去数据到大数据平台，使用批处理框架离线计算，把输出的结果存放到搜索引擎或者NoSQL数据库中，应用程序直接查询计算的结果返回给用户。也有可能我们需要汇总多个表的数据做一张宽表，方便应用程序查询&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于引入的数据存储方式增多，为了减轻应用程序的管理多个数据源的麻烦，需要封装统一数据访问模块，如果使用的时Java，可以考虑spring-data&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;业务纵向拆分&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;互联网公司通常的宗旨是小步迭代试错快跑，当业务发展到足够大，对于单体应用想要达到这个宗旨是有难度的，随着业务的发展，应用程序越来越大，研发、维护、发布的成本也越来越大，这时候就需要考虑根据业务把单体应用拆分为多个服务，服务之间可以通过RPC远程调用和消息队列来一起完成用户的请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于业务的拆分，通常情况下也会相应的对数据库进行拆分，达到一个服务对应一个数据库的理想状态&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6025&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQ9uwLFeiafJtWW25fVEcQlibwTYtqGO7IiaQNNNjXZh9PHgInmg234BQbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;业务纵向拆分&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入MQ的好处：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;提高系统的可用性：当消费服务器发送故障时，消息还在消息队列中，数据不会丢失&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加快请求的响应：当用户请求到达服务器后，把请求中可以异步处理的数据放入到MQ，让系统逐一消费，不需要用户等待，加快了响应速度&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;削峰填谷：当大量请求都同时进入到系统之后，会全部放入到消息队列，系统逐一消费，不会对系统造成很大的冲击&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个情况未谈及到，就是数据库的水平拆分，这也是数据库拆分的最后手段，只有当单表数据特别大，不能满足业务的需要才使用。使用最多的还是进行数据库的业务纵向拆分，把数据库中不同业务的数据放到不同的物理服务器上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用当前到底选择什么架构，一定要根据实际业务的需求进行灵活的选择，驱动技术架构发展的主要动力还是在于业务的发展，不要为了技术而技术。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;写在最后&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先感谢大家可以耐心地读到这里。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当然，文中或许会存在或多或少的不足、错误之处，有建议或者意见也非常欢迎大家在评论交流。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后，&lt;strong&gt;「白嫖不好，创作不易」&lt;/strong&gt;，希望朋友们可以&lt;strong&gt;「点赞」&lt;/strong&gt;，因为这些就是我分享的全部动力来源🙏&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bcef6c56513b00078523040ec46a5cdf</guid>
<title>[推荐] 面试被吊打：Redis 原理</title>
<link>https://toutiao.io/k/pmxukkm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;小张兴冲冲去面试，结果被面试官吊打！&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官，你好。我是来参加面试的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，小张。我看了你的简历，熟练掌握Redis，那么我就随便问你几个Redis相关的问题吧。首先我的问题是，&lt;strong&gt;Redis是单线程还是多线程呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis不同版本之间采用的线程模型是不一样的，在Redis4.0版本之前使用的是单线程模型，在4.0版本之后增加了多线程的支持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在4.0之前虽然我们说Redis是单线程，也只是说它的网络I/O线程以及Set 和 Get操作是由一个线程完成的。但是Redis的持久化、集群同步还是使用其他线程来完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4.0之后添加了多线程的支持，主要是体现在大数据的异步删除功能上，例如 &lt;code&gt;unlink key&lt;/code&gt;、&lt;code&gt;flushdb async&lt;/code&gt;、&lt;code&gt;flushall async&lt;/code&gt; 等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回答的很好，&lt;strong&gt;那为什么Redis在4.0之前会选择使用单线程？而且使用单线程还那么快？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择单线程个人觉得主要是使用简单，不存在锁竞争，可以在无锁的情况下完成所有操作，不存在死锁和线程切换带来的性能和时间上的开销，但同时单线程也不能完全发挥出多核CPU的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于为什么单线程那么快我觉得主要有以下几个原因：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Redis 的大部分操作都在内存中完成，内存中的执行效率本身就很快，并且采用了高效的数据结构，比如哈希表和跳表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用单线程避免了多线程的竞争，省去了多线程切换带来的时间和性能开销，并且不会出现死锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;采用 I/O 多路复用机制处理大量客户端的Socket请求，因为这是基于非阻塞的 I/O 模型，这就让Redis可以高效地进行网络通信，I/O的读写流程也不再阻塞。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不错，&lt;strong&gt;那Redis是如何实现数据不丢失的呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis数据是存储在内存中的，为了保证Redis数据不丢失，那就要把数据从内存存储到磁盘上，以便在服务器重启后还能够从磁盘中恢复原有数据，这就是Redis的数据持久化。Redis数据持久化有三种方式。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;AOF 日志（Append Only File，文件追加方式）：记录所有的操作命令，并以文本的形式追加到文件中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RDB 快照（Redis DataBase）：将某一个时刻的内存数据，以二进制的方式写入磁盘。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;混合持久化方式：Redis 4.0 新增了混合持久化的方式，集成了 RDB 和 AOF 的优点。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那你分别说说 &lt;strong&gt;AOF和 RDB的实现原理吧。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AOF采用的是写后日志的方式，Redis先执行命令把数据写入内存，然后再记录日志到文件中。AOF日志记录的是操作命令，不是实际的数据，如果采用AOF方法做故障恢复时需要将全量日志都执行一遍。&lt;img data-ratio=&quot;0.4425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jO7IqBicQ3GSO5A7UCoVnPDUErCW7ZkcymMUSm9zD8Vzm6cWypLcibJGyYWmZJQacUEGFRgJWOnF7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RDB采用的是内存快照的方式，它记录的是某一时刻的数据，而不是操作，所以采用RDB方法做故障恢复时只需要直接把RDB文件读入内存即可，实现快速恢复。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你刚提到了AOF采用的是 “写后日志” 的方式，我们平时用的MySQL则采用的是 “写前日志”，那 &lt;strong&gt;Redis为什么要先执行命令，再把数据写入日志呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：额头开始冒汗，问的是些啥问题呀。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;额，这个主要是由于Redis在写入日志之前，不对命令进行语法检查，所以只记录执行成功的命令，避免出现记录错误命令的情况，而且在命令执行后再写日志不会阻塞当前的写操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那 &lt;strong&gt;后写日志又有什么风险呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我... 这个我不会。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好吧，后写日志主要有两个风险可能会发生：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据可能会丢失：如果 Redis 刚执行完命令，此时发生故障宕机，会导致这条命令存在丢失的风险。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可能阻塞其他操作：AOF 日志其实也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我还有个问题是 &lt;strong&gt;RDB做快照时会阻塞线程吗？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 提供了两个命令来生成 RDB 快照文件，分别是 &lt;code&gt;save&lt;/code&gt; 和 &lt;code&gt;bgsave&lt;/code&gt;。&lt;code&gt;save&lt;/code&gt; 命令在主线程中执行，会导致阻塞。而 &lt;code&gt;bgsave&lt;/code&gt; 命令则会创建一个子进程，用于写入 RDB 文件的操作，避免了对主线程的阻塞，这也是 Redis RDB 的默认配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;RDB 做快照的时候数据能修改吗？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;save是同步的会阻塞客户端命令，bgsave的时候是可以修改的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那Redis是怎么解决在bgsave做快照的时候允许数据修改呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：（你咋还问。。。我™不会啊！）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;额，这个我不太清楚...&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8897849462365591&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jO7IqBicQ3GSO5A7UCoVnPDRmmiaUsIMpo0WmPuIHLmia60lZ6IG2R2BmyT9HRFJoP3pY9BaiappqecQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;372&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要是利用 &lt;code&gt;bgsave&lt;/code&gt;的子线程实现的，具体操作如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果主线程执行读操作，则主线程和 &lt;code&gt;bgsave&lt;/code&gt; 子进程互相不影响；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果主线程执行写操作，则被修改的数据会复制一份副本，然后 &lt;code&gt;bgsave&lt;/code&gt;子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jO7IqBicQ3GSO5A7UCoVnPD77lQMwvWt1J3AVR80gGQ8y6QEhXa0icp4gzy4pMn9f8xsmyMXEpmicAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;要注意，Redis 对 RDB 的执行频率非常重要，因为这会影响快照数据的完整性以及 Redis 的稳定性，所以在 Redis 4.0 后，&lt;strong&gt;增加了 AOF 和 RDB 混合的数据持久化机制：&lt;/strong&gt; 把数据以 RDB 的方式写入文件，再将后续的操作命令以 AOF 的格式存入文件，既保证了 Redis 重启速度，又降低数据丢失风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学到了学到了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那你再跟我说说Redis如何实现高可用吧？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis实现高可用主要有三种方式：主从复制、哨兵模式，以及 Redis 集群。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主从复制&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将从前的一台 Redis 服务器，同步数据到多台从 Redis 服务器上，即一主多从的模式，这个跟MySQL主从复制的原理一样。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5723684210526315&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jO7IqBicQ3GSO5A7UCoVnPDImufrmEtAUtj0eeEC8mNIibMS4obtqEhXtBcc0de8E6stySr3UwwzPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;608&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;br/&gt;哨兵模式&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Redis 主从服务的时候，会有一个问题，就是当 Redis 的主从服务器出现故障宕机时，需要手动进行恢复，为了解决这个问题，Redis 增加了哨兵模式（因为哨兵模式做到了可以监控主从服务器，并且提供自动容灾恢复的功能）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.84125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jO7IqBicQ3GSO5A7UCoVnPDFwbYPmzRhSlwEhtYXu1sDml50K179hnWiaYEadFTnqBNUwv7sqXjjfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;br/&gt;Redis Cluster（集群）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis Cluster 是一种分布式去中心化的运行模式，是在 Redis 3.0 版本中推出的 Redis 集群方案，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.325&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jO7IqBicQ3GSO5A7UCoVnPDMRaD2kNBqnyoqS9icUQCXNHkFgGqhkvSahoTeTG3Uv0ibibn12ice0ibwfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用哨兵模式在数据上有副本数据做保证，在可用性上又有哨兵监控，一旦master宕机会选举salve节点为master节点，这种已经满足了我们的生产环境需要，&lt;strong&gt;那为什么还需要使用集群模式呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;额，哨兵模式归根节点还是主从模式，在主从模式下我们可以通过增加slave节点来扩展读并发能力，但是没办法扩展写能力和存储能力，存储能力只能是master节点能够承载的上限。所以为了扩展写能力和存储能力，我们就需要引入集群模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;集群中那么多Master节点，redis cluster在存储的时候如何确定选择哪个节点呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这应该是使用了某种hash算法，但是我不太清楚。。。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6432291666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jO7IqBicQ3GSO5A7UCoVnPDzlCRiaaCqGsVlhcAKbkQE7m5iajwZjf3dI3yOTeKn93g1VwwoYBOqPGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;384&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那好，今天的面试就到这里吧，你先回去等我们的面试通知。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的，谢谢面试官，你能告诉我redis cluster怎么实现节点选择的吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis Cluster采用的是&lt;strong&gt;类一致性哈希算法实现节点选择的&lt;/strong&gt;，至于什么是一致性哈希算法你自己回去看看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis Cluster将自己分成了16384个&lt;strong&gt;Slot&lt;/strong&gt;（槽位），哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;根据键值对的 key，按照 CRC16 算法计算一个 16 bit 的值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再用 16bit 值对 16384 取模，得到 &lt;code&gt;0~16383&lt;/code&gt; 范围内的模数，每个模数代表一个相应编号的哈希槽。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个Redis节点负责处理一部分槽位，假如你有三个master节点 ABC，每个节点负责的槽位如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;节点&lt;/th&gt;&lt;th&gt;处理槽位&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;A&lt;/td&gt;&lt;td&gt;0-5000&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;B&lt;/td&gt;&lt;td&gt;5001 - 10000&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;10001 - 16383&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就实现了cluster节点的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，各位看官朋友们，Redis原理的这些面试点你们记住了吗？希望你们的面试不会被这个问题难倒哟~&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>