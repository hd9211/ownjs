<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>5602a7fbbd4399ee7fd2f37520746177</guid>
<title>我用 Kafka 两年踩过的一些非比寻常的坑</title>
<link>https://toutiao.io/k/95yxept</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;前言&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的上家公司是做餐饮系统的，每天中午和晚上用餐高峰期，系统的并发量不容小觑。为了保险起见，公司规定各部门都要在吃饭的时间轮流值班，防止出现线上问题时能够及时处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我当时在后厨显示系统团队，该系统属于订单的下游业务。用户点完菜下单后，订单系统会通过发&lt;code&gt;kafka&lt;/code&gt;消息给我们系统，系统读取消息后，做业务逻辑处理，持久化订单和菜品数据，然后展示到划菜客户端。这样厨师就知道哪个订单要做哪些菜，有些菜做好了，就可以通过该系统出菜。系统自动通知服务员上菜，如果服务员上完菜，修改菜品上菜状态，用户就知道哪些菜已经上了，哪些还没有上。这个系统可以大大提高后厨到用户的效率。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4534313725490196&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqoWtdHmibk2ibtpqzdfibDdylu1Ke7qClwkEqT1kzibiabPSjQM88XkKrpqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;816&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实证明，这一切的关键是消息中间件：&lt;code&gt;kafka&lt;/code&gt;，如果它有问题，将会直接影响到后厨显示系统的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我跟大家一起聊聊使用&lt;code&gt;kafka&lt;/code&gt;两年时间踩过哪些坑？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;顺序问题&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 为什么要保证消息的顺序？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚开始我们系统的商户很少，为了快速实现功能，我们没想太多。既然是走消息中间件&lt;code&gt;kafka&lt;/code&gt;通信，订单系统发消息时将订单详细数据放在消息体，我们后厨显示系统只要订阅&lt;code&gt;topic&lt;/code&gt;，就能获取相关消息数据，然后处理自己的业务即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过这套方案有个关键因素：&lt;strong&gt;要保证消息的顺序&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;订单有很多状态，比如：下单、支付、完成、撤销等，不可能&lt;code&gt;下单&lt;/code&gt;的消息都没读取到，就先读取&lt;code&gt;支付&lt;/code&gt;或&lt;code&gt;撤销&lt;/code&gt;的消息吧，如果真的这样，数据不是会产生错乱？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好吧，看来保证消息顺序是有必要的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.如何保证消息顺序？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道&lt;code&gt;kafka&lt;/code&gt;的&lt;code&gt;topic&lt;/code&gt;是无序的，但是一个&lt;code&gt;topic&lt;/code&gt;包含多个&lt;code&gt;partition&lt;/code&gt;，每个&lt;code&gt;partition&lt;/code&gt;内部是有序的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5851851851851851&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqOzug1A48UnG15tonQ3wBkbB5yicVnHpydn5Hq2PwiawKTVj8Vk6DB7sQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如此一来，思路就变得清晰了：只要保证生产者写消息时，按照一定的规则写到同一个&lt;code&gt;partition&lt;/code&gt;，不同的消费者读不同的&lt;code&gt;partition&lt;/code&gt;的消息，就能保证生产和消费者消息的顺序。&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们刚开始就是这么做的，同一个&lt;code&gt;商户编号&lt;/code&gt;的消息写到同一个&lt;code&gt;partition&lt;/code&gt;，&lt;code&gt;topic&lt;/code&gt;中创建了&lt;code&gt;4&lt;/code&gt;个&lt;code&gt;partition&lt;/code&gt;，然后部署了&lt;code&gt;4&lt;/code&gt;个消费者节点，构成&lt;code&gt;消费者组&lt;/code&gt;，一个&lt;code&gt;partition&lt;/code&gt;对应一个消费者节点。从理论上说，这套方案是能够保证消息顺序的。&lt;img data-ratio=&quot;0.40813464235624125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqrza43TUBKePfwRPaSrtSJiclN6ibdof2qKwyhIfGoicR4Z6C2icQP5vWuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1426&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一切规划得看似“天衣无缝”，我们就这样”顺利“上线了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.出现意外&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该功能上线了一段时间，刚开始还是比较正常的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，好景不长，很快就收到用户投诉，说在划菜客户端有些订单和菜品一直看不到，无法划菜。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我定位到了原因，公司在那段时间网络经常不稳定，业务接口时不时报超时，业务请求时不时会连不上数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况对&lt;code&gt;顺序消息&lt;/code&gt;的打击，可以说是&lt;code&gt;毁灭性&lt;/code&gt;的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么这么说？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设订单系统发了：”下单“、”支付“、”完成“ 三条消息。&lt;img data-ratio=&quot;0.30303030303030304&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqlNAGCa9TQnogCS0zxjEdib4ta0Upia4NZLxe9KibnLKu2buS1In7qT27Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;726&quot;/&gt;而”下单“消息由于网络原因我们系统处理失败了，而后面的两条消息的数据是无法入库的，因为只有”下单“消息的数据才是完整的数据，其他类型的消息只会更新状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加上，我们当时没有做&lt;code&gt;失败重试机制&lt;/code&gt;，使得这个问题被放大了。问题变成：一旦”下单“消息的数据入库失败，用户就永远看不到这个订单和菜品了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这个紧急的问题要如何解决呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.解决过程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最开始我们的想法是：在消费者处理消息时，如果处理失败了，立马重试3-5次。但如果有些请求要第6次才能成功怎么办？不可能一直重试呀，这种同步重试机制，会阻塞其他商户订单消息的读取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然用上面的这种&lt;code&gt;同步重试机制&lt;/code&gt;在出现异常的情况，会严重影响消息消费者的消费速度，降低它的吞吐量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如此看来，我们不得不用&lt;code&gt;异步重试机制&lt;/code&gt;了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用异步重试机制，处理失败的消息就得保存到&lt;code&gt;重试表&lt;/code&gt;下来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有个新问题立马出现：&lt;strong&gt;只存一条消息如何保证顺序？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存一条消息的确无法保证顺序，假如：”下单“消息失败了，还没来得及异步重试。此时，”支付“消息被消费了，它肯定是不能被正常消费的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，”支付“消息该一直等着，每隔一段时间判断一次，它前面的消息都有没有被消费?&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果真的这么做，会出现两个问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;”支付“消息前面只有”下单“消息，这种情况比较简单。但如果某种类型的消息，前面有N多种消息，需要判断多少次呀，这种判断跟订单系统的耦合性太强了，相当于要把他们系统的逻辑搬一部分到我们系统。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;影响消费者的消费速度&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时有种更简单的方案浮出水面：消费者在处理消息时，先判断该&lt;code&gt;订单号&lt;/code&gt;在&lt;code&gt;重试表&lt;/code&gt;有没有数据，如果有则直接把当前消息保存到&lt;code&gt;重试表&lt;/code&gt;。如果没有，则进行业务处理，如果出现异常，把该消息保存到&lt;code&gt;重试表&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来我们用&lt;code&gt;elastic-job&lt;/code&gt;建立了&lt;code&gt;失败重试机制&lt;/code&gt;，如果重试了&lt;code&gt;7&lt;/code&gt;次后还是失败，则将该消息的状态标记为&lt;code&gt;失败&lt;/code&gt;，发邮件通知开发人员。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;终于由于网络不稳定，导致用户在划菜客户端有些订单和菜品一直看不到的问题被解决了。现在商户顶多偶尔延迟看到菜品，比一直看不菜品好太多。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;消息积压&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着销售团队的市场推广，我们系统的商户越来越多。随之而来的是消息的数量越来越大，导致消费者处理不过来，经常出现消息积压的情况。对商户的影响非常直观，划菜客户端上的订单和菜品可能半个小时后才能看到。一两分钟还能忍，半个消息的延迟，对有些暴脾气的商户哪里忍得了，马上投诉过来了。我们那段时间经常接到商户投诉说订单和菜品有延迟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽说，加&lt;code&gt;服务器节点&lt;/code&gt;就能解决问题，但是按照公司为了省钱的惯例，要先做系统优化，所以我们开始了&lt;code&gt;消息积压&lt;/code&gt;问题解决之旅。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 消息体过大&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽说&lt;code&gt;kafka&lt;/code&gt;号称支持&lt;code&gt;百万级的TPS&lt;/code&gt;，但从&lt;code&gt;producer&lt;/code&gt;发送消息到&lt;code&gt;broker&lt;/code&gt;需要一次网络&lt;code&gt;IO&lt;/code&gt;，&lt;code&gt;broker&lt;/code&gt;写数据到磁盘需要一次磁盘&lt;code&gt;IO&lt;/code&gt;（写操作），&lt;code&gt;consumer&lt;/code&gt;从&lt;code&gt;broker&lt;/code&gt;获取消息先经过一次磁盘&lt;code&gt;IO&lt;/code&gt;（读操作），再经过一次网络&lt;code&gt;IO&lt;/code&gt;。&lt;img data-ratio=&quot;0.5047619047619047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlq0tlViaqySicoAnwRJmPPPqQgnd89BrW3YyiaQUqAx3uLPicVmwpoeSq1dQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1050&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一次简单的消息从生产到消费过程，需要经过&lt;code&gt;2次网络IO&lt;/code&gt;和&lt;code&gt;2次磁盘IO&lt;/code&gt;。如果消息体过大，势必会增加IO的耗时，进而影响kafka生产和消费的速度。消费者速度太慢的结果，就会出现消息积压情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上面的问题之外，&lt;code&gt;消息体过大&lt;/code&gt;，还会浪费服务器的磁盘空间，稍不注意，可能会出现磁盘空间不足的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，我们已经到了需要优化消息体过大问题的时候。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何优化呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们重新梳理了一下业务，没有必要知道订单的&lt;code&gt;中间状态&lt;/code&gt;，只需知道一个&lt;code&gt;最终状态&lt;/code&gt;就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如此甚好，我们就可以这样设计了：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;订单系统发送的消息体只用包含：id和状态等关键信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后厨显示系统消费消息后，通过id调用订单系统的订单详情查询接口获取数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后厨显示系统判断数据库中是否有该订单的数据，如果没有则入库，有则更新。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46782178217821785&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqib2hB0qSIXBPjxAH1vZQbn97tcMKQBmWBDL1Rc1ytjLXoXcCPic301pQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;808&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;果然这样调整之后，消息积压问题很长一段时间都没再出现。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2. 路由规则不合理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还真别高兴的太早，有天中午又有商户投诉说订单和菜品有延迟。我们一查kafka的topic竟然又出现了消息积压。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这次有点诡异，不是所有&lt;code&gt;partition&lt;/code&gt;上的消息都有积压，而是只有一个。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.369620253164557&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqdaENvsBRclJSZ2zvNoXxfpDS9IgJvpM6icibHB8Y32Jt4khMicw7wictmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1580&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚开始，我以为是消费那个&lt;code&gt;partition&lt;/code&gt;消息的节点出了什么问题导致的。但是经过排查，没有发现任何异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就奇怪了，到底哪里有问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来，我查日志和数据库发现，有几个商户的订单量特别大，刚好这几个商户被分到同一个&lt;code&gt;partition&lt;/code&gt;，使得该&lt;code&gt;partition&lt;/code&gt;的消息量比其他&lt;code&gt;partition&lt;/code&gt;要多很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时我们才意识到，发消息时按&lt;code&gt;商户编号&lt;/code&gt;路由&lt;code&gt;partition&lt;/code&gt;的规则不合理，可能会导致有些&lt;code&gt;partition&lt;/code&gt;消息太多，消费者处理不过来，而有些&lt;code&gt;partition&lt;/code&gt;却因为消息太少，消费者出现空闲的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了避免出现这种分配不均匀的情况，我们需要对发消息的路由规则做一下调整。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们思考了一下，用订单号做路由相对更均匀，不会出现单个订单发消息次数特别多的情况。除非是遇到某个人一直加菜的情况，但是加菜是需要花钱的，所以其实同一个订单的消息数量并不多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调整后按&lt;code&gt;订单号&lt;/code&gt;路由到不同的&lt;code&gt;partition&lt;/code&gt;，同一个订单号的消息，每次到发到同一个&lt;code&gt;partition&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3888888888888889&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqoJO69ia8Fv9p1uc0HEHaJcYg85VaBlsHm25ubexHCFmmicbVWsN6IACA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1548&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调整后，消息积压的问题又有很长一段时间都没有再出现。我们的商户数量在这段时间，增长的非常快，越来越多了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 批量操作引起的连锁反应&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发的场景中，消息积压问题，可以说如影随形，真的没办法从根本上解决。表面上看，已经解决了，但后面不知道什么时候，就会冒出一次，比如这次：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有天下午，产品过来说：有几个商户投诉过来了，他们说菜品有延迟，快查一下原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次问题出现得有点奇怪。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么这么说？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先这个时间点就有点奇怪，平常出问题，不都是中午或者晚上用餐高峰期吗？怎么这次问题出现在下午？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据以往积累的经验，我直接看了&lt;code&gt;kafka&lt;/code&gt;的&lt;code&gt;topic&lt;/code&gt;的数据，果然上面消息有积压，但这次每个&lt;code&gt;partition&lt;/code&gt;都积压了&lt;code&gt;十几万&lt;/code&gt;的消息没有消费，比以往加压的消息数量增加了&lt;code&gt;几百倍&lt;/code&gt;。这次消息积压得极不寻常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我赶紧查服务监控看看消费者挂了没，还好没挂。又查服务日志没有发现异常。这时我有点迷茫，碰运气问了问订单组下午发生了什么事情没？他们说下午有个促销活动，跑了一个JOB批量更新过有些商户的订单信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，我一下子如梦初醒，是他们在JOB中批量发消息导致的问题。怎么没有通知我们呢？实在太坑了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽说知道问题的原因了，倒是眼前积压的这&lt;code&gt;十几万&lt;/code&gt;的消息该如何处理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，如果直接调大&lt;code&gt;partition&lt;/code&gt;数量是不行的，历史消息已经存储到4个固定的&lt;code&gt;partition&lt;/code&gt;，只有新增的消息才会到新的&lt;code&gt;partition&lt;/code&gt;。我们重点需要处理的是已有的&lt;span&gt;partition&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接加服务节点也不行，因为&lt;code&gt;kafka&lt;/code&gt;允许同组的多个&lt;code&gt;partition&lt;/code&gt;被一个&lt;code&gt;consumer&lt;/code&gt;消费，但不允许一个&lt;code&gt;partition&lt;/code&gt;被同组的多个&lt;code&gt;consumer&lt;/code&gt;消费，可能会造成资源浪费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看来只有用多线程处理了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了紧急解决问题，我改成了用&lt;code&gt;线程池&lt;/code&gt;处理消息，核心线程和最大线程数都配置成了&lt;code&gt;50&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调整之后，果然，消息积压数量不断减少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但此时有个更严重的问题出现：我收到了报警邮件，有两个订单系统的节点down机了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不久，订单组的同事过来找我说，我们系统调用他们订单查询接口的并发量突增，超过了预计的好几倍，导致有2个服务节点挂了。他们把查询功能单独整成了一个服务，部署了6个节点，挂了2个节点，再不处理，另外4个节点也会挂。订单服务可以说是公司最核心的服务，它挂了公司损失会很大，情况万分紧急。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，只能先把线程数调小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幸好，线程数是可以通过&lt;code&gt;zookeeper&lt;/code&gt;动态调整的，我把核心线程数调成了&lt;code&gt;8&lt;/code&gt;个，核心线程数改成了&lt;code&gt;10&lt;/code&gt;个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面，运维把订单服务挂的2个节点重启后恢复正常了，以防万一，再多加了2个节点。为了确保订单服务不会出现问题，就保持目前的消费速度，后厨显示系统的消息积压问题，1小时候后也恢复正常了。&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5266821345707656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqt9gnrBjrNqmrxqjJlghuZszz8ibdGic6KbthGAdYX8yqkSibxFlH1ibFeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;862&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来，我们开了一次复盘会，得出的结论是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;订单系统的批量操作一定提前通知下游系统团队。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;下游系统团队多线程调用订单查询接口一定要做压测。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这次给订单查询服务敲响了警钟，它作为公司的核心服务，应对高并发场景做的不够好，需要做优化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对消息积压情况加监控。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;顺便说一下，对于要求严格保证消息顺序的场景，可以将线程池改成多个队列，每个队列用单线程处理。&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 表过大&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了防止后面再次出现消息积压问题，消费者后面就一直用多线程处理消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有天中午我们还是收到很多报警邮件，提醒我们kafka的topic消息有积压。我们正在查原因，此时产品跑过来说：又有商户投诉说菜品有延迟，赶紧看看。这次她看起来有些不耐烦，确实优化了很多次，还是出现了同样的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在外行看来：&lt;strong&gt;为什么同一个问题一直解决不了？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;其实技术心里的苦他们是不知道的。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表面上问题的症状是一样的，都是出现了菜品延迟，他们知道的是因为消息积压导致的。但是他们不知道深层次的原因，导致消息积压的原因其实有很多种。这也许是使用消息中间件的通病吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我沉默不语，只能硬着头皮定位原因了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来我查日志发现消费者消费一条消息的耗时长达&lt;code&gt;2秒&lt;/code&gt;。以前是&lt;code&gt;500毫秒&lt;/code&gt;，现在怎么会变成&lt;code&gt;2秒&lt;/code&gt;呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;奇怪了，消费者的代码也没有做大的调整，为什么会出现这种情况呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查了一下线上菜品表，单表数据量竟然到了&lt;code&gt;几千万&lt;/code&gt;，其他的划菜表也是一样，现在单表保存的数据太多了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们组梳理了一下业务，其实菜品在客户端只展示最近&lt;code&gt;3天&lt;/code&gt;的即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就好办了，我们服务端存着&lt;code&gt;多余的数据&lt;/code&gt;，不如把表中多余的数据归档。于是，DBA帮我们把数据做了归档，只保留最近&lt;code&gt;7天&lt;/code&gt;的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如此调整后，消息积压问题被解决了，又恢复了往日的平静。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;主键冲突&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;别高兴得太早了，还有其他的问题，比如：报警邮件经常报出数据库异常：&lt;code&gt; Duplicate entry &#x27;6&#x27; for key &#x27;PRIMARY&#x27;&lt;/code&gt;，说主键冲突。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出现这种问题一般是由于有两个以上相同主键的sql，同时插入数据，第一个插入成功后，第二个插入的时候会报主键冲突。表的主键是唯一的，不允许重复。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我仔细检查了代码，发现代码逻辑会先根据主键从表中查询订单是否存在，如果存在则更新状态，不存在才插入数据，没得问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种判断在并发量不大时，是有用的。但是如果在高并发的场景下，两个请求同一时刻都查到订单不存在，一个请求先插入数据，另一个请求再插入数据时就会出现主键冲突的异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决这个问题最常规的做法是：&lt;code&gt;加锁&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我刚开始也是这样想的，加数据库悲观锁肯定是不行的，太影响性能。加数据库乐观锁，基于版本号判断，一般用于更新操作，像这种插入操作基本上不会用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;剩下的只能用分布式锁了，我们系统在用redis，可以加基于redis的分布式锁，锁定订单号。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但后面仔细思考了一下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;加分布式锁也可能会影响消费者的消息处理速度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者依赖于redis，如果redis出现网络超时，我们的服务就悲剧了。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我也不打算用分布式锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而是选择使用mysql的&lt;code&gt;INSERT INTO ...ON DUPLICATE KEY UPDATE&lt;/code&gt;语法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; (column_list)&lt;br/&gt;&lt;span&gt;VALUES&lt;/span&gt; (value_list)&lt;br/&gt;&lt;span&gt;ON&lt;/span&gt; &lt;span&gt;DUPLICATE&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;UPDATE&lt;/span&gt;&lt;br/&gt;c1 = v1, &lt;br/&gt;c2 = v2,&lt;br/&gt;...;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它会先尝试把数据插入表，如果主键冲突的话那么更新字段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把以前的&lt;code&gt;insert&lt;/code&gt;语句改造之后，就没再出现过主键冲突问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据库主从延迟&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不久之后的某天，又收到商户投诉说下单后，在划菜客户端上看得到订单，但是看到的菜品不全，有时甚至订单和菜品数据都看不到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题跟以往的都不一样，根据以往的经验先看&lt;code&gt;kafka&lt;/code&gt;的&lt;code&gt;topic&lt;/code&gt;中消息有没有积压，但这次并没有积压。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再查了服务日志，发现订单系统接口返回的数据有些为空，有些只返回了订单数据，没返回菜品数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就非常奇怪了，我直接过去找订单组的同事。他们仔细排查服务，没有发现问题。这时我们不约而同的想到，会不会是数据库出问题了，一起去找&lt;code&gt;DBA&lt;/code&gt;。果然，&lt;code&gt;DBA&lt;/code&gt;发现数据库的主库同步数据到从库，由于网络原因偶尔有延迟，有时延迟有&lt;code&gt;3秒&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们的业务流程从发消息到消费消息耗时小于&lt;code&gt;3秒&lt;/code&gt;，调用订单详情查询接口时，可能会查不到数据，或者查到的不是最新的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题非常严重，会导致直接我们的数据错误。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，我们也加了&lt;code&gt;重试机制&lt;/code&gt;。调用接口查询数据时，如果返回数据为空，或者只返回了订单没有菜品，则加入&lt;code&gt;重试表&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调整后，商户投诉的问题被解决了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;重复消费&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;kafka&lt;/code&gt;消费消息时支持三种模式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;at most onece模式
最多一次。保证每一条消息commit成功之后，再进行消费处理。消息可能会丢失，但不会重复。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;at least onece模式
至少一次。保证每一条消息处理成功之后，再进行commit。消息不会丢失，但可能会重复。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;exactly onece模式
精确传递一次。将offset作为唯一id与消息同时处理，并且保证处理的原子性。消息只会处理一次，不丢失也不会重复。但这种方式很难做到。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;kafka&lt;/code&gt;默认的模式是&lt;code&gt;at least onece&lt;/code&gt;，但这种模式可能会产生重复消费的问题，所以我们的业务逻辑必须做幂等设计。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而我们的业务场景保存数据时使用了&lt;code&gt;INSERT INTO ...ON DUPLICATE KEY UPDATE&lt;/code&gt;语法，不存在时插入，存在时更新，是天然支持幂等性的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;多环境消费问题&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们当时线上环境分为：&lt;code&gt;pre&lt;/code&gt;(预发布环境) 和 &lt;code&gt;prod&lt;/code&gt;(生产环境)，两个环境共用同一个数据库，并且共用同一个kafka集群。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，在配置&lt;code&gt;kafka&lt;/code&gt;的&lt;code&gt;topic&lt;/code&gt;的时候，要加前缀用于区分不同环境。pre环境的以pre_开头，比如：pre_order，生产环境以prod_开头，比如：prod_order，防止消息在不同环境中串了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有次运维在&lt;code&gt;pre&lt;/code&gt;环境切换节点，配置&lt;code&gt;topic&lt;/code&gt;的时候，配错了，配成了&lt;code&gt;prod&lt;/code&gt;的&lt;code&gt;topic&lt;/code&gt;。刚好那天，我们有新功能上&lt;code&gt;pre&lt;/code&gt;环境。结果悲剧了，&lt;code&gt;prod&lt;/code&gt;的有些消息被&lt;code&gt;pre&lt;/code&gt;环境的&lt;code&gt;consumer&lt;/code&gt;消费了，而由于消息体做了调整，导致&lt;code&gt;pre&lt;/code&gt;环境的&lt;code&gt;consumer&lt;/code&gt;处理消息一直失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其结果是生产环境丢了部分消息。不过还好，最后生产环境消费者通过重置&lt;code&gt;offset&lt;/code&gt;，重新读取了那一部分消息解决了问题，没有造成太大损失。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;后记&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上述问题之外，我还遇到过：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;kafka&lt;/code&gt;的&lt;code&gt;consumer&lt;/code&gt;使用自动确认机制，导致&lt;code&gt;cpu使用率100%&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;kafka&lt;/code&gt;集群中的一个&lt;code&gt;broker&lt;/code&gt;节点挂了，重启后又一直挂。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个问题说起来有些复杂，我就不一一列举了，有兴趣的朋友可以关注我的公众号，加我的微信找我私聊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常感谢那两年使用消息中间件&lt;code&gt;kafka&lt;/code&gt;的经历，虽说遇到过挺多问题，踩了很多坑，走了很多弯路，但是实打实的让我积累了很多宝贵的经验，快速成长了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实&lt;code&gt;kafka&lt;/code&gt;是一个非常优秀的消息中间件，我所遇到的绝大多数问题，都并非&lt;code&gt;kafka&lt;/code&gt;自身的问题（除了cpu使用率100%是它的一个bug导致的之外）。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;各位亲爱的朋友，我的文章一周才更新一到两篇。很有可能在你不经意间，就发文了，导致你错过精彩内容。在公众号中扩展右上角“&lt;/span&gt;&lt;span&gt;设为星标&lt;/span&gt;&lt;span&gt;”能第一时间看到我的好文章喔，纯干货分享，错过真的可惜。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;2.149090909090909&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFmRHPf6poYmQMHiapibW6zTsMBkVItGxCDERfT1kr913Z5mjS9OMpUrTlOMZZCiaSSiabvd79icMYeRxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d40e72ecd8f5632eb5a8976844ac2fc9</guid>
<title>Java 中 NullPointerException 的完美解决方案</title>
<link>https://toutiao.io/k/st1q2rx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;null在Java中带来的麻烦&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我相信所有的Java程序猿一定都遇到过&lt;code&gt;NullPointerException&lt;/code&gt;，空指针在Java程序中是最常见的，也是最烦人的；它让我们很多程序猿产生了根深蒂固的感觉，所有可能产生空指针的地方都得加上&lt;code&gt;if-else&lt;/code&gt;检查，但是这带给我们很多麻烦&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Java本身是强类型的，但是null破坏了这个规则，它可以被赋值给任何对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Java的设计是让程序猿对指针无感知，但是null指针是个例外&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;它会是代码变得很臃肿，到处都充斥着&lt;code&gt;if-else&lt;/code&gt;的空检查，甚至是多层嵌套，代码可读性下降&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;null本身毫无意义，表示不了&lt;code&gt;无&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前两点不需要特别的说明，后两点举个例子来说明一下：假如一个人拥有一个手机，每个手机都有生成厂商，每个厂商都会有个名字，用类表示的话：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class Person {&lt;br/&gt;    private Phone phone;&lt;br/&gt;&lt;br/&gt;    public Phone &lt;span&gt;&lt;span&gt;getPhone&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; phone;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public class Phone {&lt;br/&gt;    private Producer producer;&lt;br/&gt;&lt;br/&gt;    public Producer &lt;span&gt;&lt;span&gt;getProducer&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; producer;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public class Producer {&lt;br/&gt;    private String name;&lt;br/&gt;&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;getName&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; name;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个例子中，假如我们需要取到手机生成厂商的名字&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public String getPhoneProducerName(Person person) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; person.getPhone().getProducer().getName();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于不一定每个人都会有一个手机，所有在调用&lt;code&gt;getProducer()&lt;/code&gt;时可能会出现&lt;code&gt;NullPointerException&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一门设计语言本来就是来描述世界的，在这个事例中有的人有手机，有的人也可能没有手机，所以在调用&lt;code&gt;person.getPhone()&lt;/code&gt;返回的值就应该包含有和无这两种情况，现在通过返回&lt;code&gt;null&lt;/code&gt;来表示无，但是在调用&lt;code&gt;getProducer()&lt;/code&gt;却又会抛出异常，这样就不太符合现实逻辑；所以把&lt;code&gt;null&lt;/code&gt;来用来表示&lt;code&gt;无&lt;/code&gt;不合适&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在遇到这种情况通常的做法是做null检查,甚至是每个地方可能发生null指针的做检查。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public String getPhoneProducerName(Person person) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (person.getPhone() == null) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;无名字&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (person.getPhone().getProducer() == null) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;无名字&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; person.getPhone().getProducer().getName();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我已经试图在减少代码的层级，如果使用的是&lt;code&gt;if-else&lt;/code&gt;，代码的层级会更深，代码可读性下降。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Optional的简单介绍&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;吐槽了那么多现状的不好，现在可以祭出我们的解决方案了 &lt;code&gt;Optional&lt;/code&gt;；千呼万唤始出来，犹抱琵琶半遮面；那&lt;code&gt;Optional&lt;/code&gt;到底是个什么东西，我们一起来逐步解开它的面纱。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46742209631728043&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQ29K0BGwYqetWT2bJ5OtKAdC8Vn6C1u2tqxTw4GEjuosLYic9kJXdukQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;706&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Optional&lt;/code&gt;本身只是对对象的简单包装，如果对象为空，那么会构建一个空的&lt;code&gt;Optional&lt;/code&gt;；这样一来&lt;code&gt;Optional&lt;/code&gt;就包含了存在和不存在两个情况, 接下来可以看下上面的例子改过之后&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class Person {&lt;br/&gt;    private Optional&amp;lt;Phone&amp;gt; phone;&lt;br/&gt;&lt;br/&gt;    public Optional&amp;lt;Phone&amp;gt; &lt;span&gt;&lt;span&gt;getPhone&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; phone;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public class Phone {&lt;br/&gt;    private Producer producer;&lt;br/&gt;&lt;br/&gt;    public Producer &lt;span&gt;&lt;span&gt;getProducer&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; producer;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public class Producer {&lt;br/&gt;    private String name;&lt;br/&gt;&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;getName&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; name;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于有的人可能没有手机，有的人有，所以&lt;code&gt;Phone&lt;/code&gt;需要用&lt;code&gt;Optional&lt;/code&gt;包装起来；手机本身一定会有生产的厂商，厂商一定会有一个名字，所以这两个不需要用&lt;code&gt;Optional&lt;/code&gt;包装起来。这里我们会发现使用了&lt;code&gt;Optional&lt;/code&gt;会丰富代码的语义，让代码更加符合现实。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而当我们在调用&lt;code&gt;phone.getProducer().getName()&lt;/code&gt;的时候不需要做null指针的检查，如果说在这里发生了&lt;code&gt;NullPointerException&lt;/code&gt;，说明这里数据本身是有问题的，不符合现实，就应该让问题暴露出来，而不是像上面的代码一样把问题掩盖。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Optional的常用方法使用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;1. Optional的创建方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Optional&amp;lt;Person&amp;gt; empty = Optional.empty();  //申明一个空的Optional&lt;br/&gt;Optional&amp;lt;Person&amp;gt; person = Optional.of(new Person()); //包装Person&lt;br/&gt;Optional&amp;lt;Person&amp;gt; person2 = Optional.of(null); //不允许的操作，传入null 会抛出空指针异常&lt;br/&gt;Optional&amp;lt;Person&amp;gt; optionalPerson = Optional.ofNullable(null); //允许传null, 返回一个空的Optional&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;2. Optional值的获取方式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;map、flatMap
首先我们重新定义一下Phone类，除了有生产厂商之外，还有个型号；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class Phone {&lt;br/&gt;    private String model;&lt;br/&gt;    private Producer producer;&lt;br/&gt;&lt;br/&gt;    public Producer &lt;span&gt;&lt;span&gt;getProducer&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; producer;&lt;br/&gt;    }&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;getModel&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; model;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们需要获取到手机的型号的时候可以这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Optional&amp;lt;Phone&amp;gt; optionalPhone = Optional.of(new Phone());&lt;br/&gt;Optional&amp;lt;String&amp;gt; model = optionalPhone.map(Phone::getModel);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们需要通过Person对象获取到Phone的型号，会想到这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Optional&amp;lt;Person&amp;gt; optionalPerson = Optional.of(new Person());&lt;br/&gt;optionalPerson.map(Person::getPhone).map(Phone::getModel);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们写出来的时候发现编译器不能通过。是因为&lt;code&gt;Person::getPhone&lt;/code&gt;返回的是一个&lt;code&gt;Optional&amp;lt;Phone&amp;gt;&lt;/code&gt;，调用&lt;code&gt;optionalPerson.map(Person::getPhone)&lt;/code&gt;返回的就是&lt;code&gt;Optional&amp;lt;Optional&amp;lt;Phone&amp;gt;&amp;gt;&lt;/code&gt;，所以再&lt;code&gt;.map&lt;/code&gt;的就无法拿到手机型号，那如何能够让返回的结果不是&lt;code&gt;Optional&amp;lt;Optional&amp;lt;Phone&amp;gt;&amp;gt;&lt;/code&gt;，而是&lt;code&gt;Optional&amp;lt;Phone&amp;gt;&lt;/code&gt;呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要用到另一个方法&lt;code&gt;flatMap&lt;/code&gt;。&lt;code&gt;flatMap&lt;/code&gt;和&lt;code&gt;map&lt;/code&gt;的区别，我在刚开始学习的时候，看到了网上的各种解释都很绕，看的很晕，最后直接打开源码来看，发现实现很简单，很容易理解，来看下源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public&amp;lt;U&amp;gt; Optional&amp;lt;U&amp;gt; map(Function&amp;lt;? super T, ? extends U&amp;gt; mapper) {&lt;br/&gt;    Objects.requireNonNull(mapper);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!isPresent())&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; empty();&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Optional.ofNullable(mapper.apply(value));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;public&amp;lt;U&amp;gt; Optional&amp;lt;U&amp;gt; flatMap(Function&amp;lt;? super T, Optional&amp;lt;U&amp;gt;&amp;gt; mapper) {&lt;br/&gt;    Objects.requireNonNull(mapper);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!isPresent())&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; empty();&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Objects.requireNonNull(mapper.apply(value));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;map&lt;/code&gt;方法在返回的时候会包装一层&lt;code&gt;Optional&lt;/code&gt; ；&lt;code&gt;flatMap&lt;/code&gt;在返回的时候直接把函数的返回值返回了，函数的结果必须是&lt;code&gt;Optional&lt;/code&gt;；那么在前面的例子中我们直接调用&lt;code&gt;flatMap&lt;/code&gt;返回的结果就是&lt;code&gt;Optional&amp;lt;Phone&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Optional&amp;lt;Person&amp;gt; optionalPerson = Optional.of(new Person());&lt;br/&gt;optionalPerson.flatMap(Person::getPhone).map(Phone::getModel);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;取出&lt;code&gt;Optional&lt;/code&gt;中的值对象：get、orElse、orElseGet、orElseThrow、ifPresent&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;get() : 当你明确知道Optional中有值的话可以直接调用该方法，当Optional中没有值是该方法会抛出异常&lt;code&gt;NoSuchElementException&lt;/code&gt;;所以当如果存在空值的话建议就不要调用该方法，因为这样和做null检查就没有区别了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;orElse(T other) : 提供一个默认值，当值不存在是返回这个默认值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;orElseGet(Supplier&amp;lt;? extends T&amp;gt; other) : 当值不存在的时候会调用supper函数，如果说返回这个默认值的逻辑较多，那么调用这个方法比较合适；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;orElseThrow(Supplier&amp;lt;? extends X&amp;gt; exceptionSupplier) : 当值为空时会抛出一个自定义的异常&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ifPresent(Consumer&amp;lt;? super T&amp;gt; consumer) : 当值不为空是会调用&lt;code&gt;consumer&lt;/code&gt;函数，如果值为空，那么这个方法什么都不做&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;filter 过滤出满足条件的对象
假如我们需要过滤出手机型号&lt;code&gt;IOS&lt;/code&gt;的手机，并打印出型号，代码如下：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Person person = new Person(Optional.of(new Phone(&lt;span&gt;&quot;IOS&quot;&lt;/span&gt;)));&lt;br/&gt;        Optional&amp;lt;Person&amp;gt; optionalPerson = Optional.of(person);&lt;br/&gt;        optionalPerson.flatMap(Person::getPhone)&lt;br/&gt;                .filter(phone -&amp;gt; &lt;span&gt;&quot;IOS&quot;&lt;/span&gt;.equals(phone.getModel()))&lt;br/&gt;                .map(Phone::getModel)&lt;br/&gt;                .ifPresent(System.out::println);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我们讨论了null在Java程序的问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;介绍Java8中引入了&lt;code&gt;Optional&lt;/code&gt;来表示有和无的情况以及初始化的方式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;举例说明了&lt;code&gt;Optional&lt;/code&gt;中经常使用到的方法&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d632fa9f2831201356ef5f56c592afd9</guid>
<title>从零开始写 KV 数据库：基于哈希索引</title>
<link>https://toutiao.io/k/h0zw3k5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;h2&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;新的KV数据库层出不穷，我们经常听说的KV数据库如RocksDb、Hbase等都是基于日志结构的存储引擎。最近我在看《数据密集型应用系统设计》，里面有一章专门在讲日志结构的存储引擎的演进过程，纯看理论不过瘾，所以我决定根据书里的理论动手自己实现一个KV数据库。同时，为了能顺便学习Rust，所以我使用了Rust来实现数据库。&lt;/p&gt;&lt;p&gt;除了参考《数据密集型应用系统设计》，我还参考了《pingcap/talent-plan》中使用Rust实现KV数据库的源码，恰好它的实现就是基于哈希索引和日志压缩的原理，跟书中的描述不谋而合。通过实现一个迷你数据库来学习和理解数据库的原理是一种学以致用的方式，能够帮助我们更加深入理解数据库原理。闲话不多说，开始正文。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;最简单的数据库&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在上正菜之前先来一道甜点，你知道最简单的数据库只需要几行代码吗？只需要两行，一行读取，一行写入。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#!/bin/bash&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;db_set&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;span&gt;$1&lt;/span&gt;,&lt;span&gt;$2&lt;/span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt; database&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;db_get&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        grep &lt;span&gt;&quot;^&lt;span&gt;$1&lt;/span&gt;,&quot;&lt;/span&gt; database | sed -e &lt;span&gt;&quot;s/^&lt;span&gt;$1&lt;/span&gt;,//&quot;&lt;/span&gt; | tail -n 1&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以尝试保存脚本，然后在shell中试一下。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;➜  ~ &lt;span&gt;source&lt;/span&gt; db.sh&lt;br/&gt;➜  ~ db_set key1 value1&lt;br/&gt;➜  ~ db_set key2 value2&lt;br/&gt;➜  ~ db_set key1 value1&lt;br/&gt;➜  ~ db_set key1 value2&lt;br/&gt;➜  ~ db_get key1&lt;br/&gt;value2&lt;br/&gt;➜  ~ cat database&lt;br/&gt;key1,value1&lt;br/&gt;key2,value2&lt;br/&gt;key1,value1&lt;br/&gt;key1,value2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;是不是很神奇，其实原理很简单，set的操作是将数据追加到文件末尾，get的操作是先grep找到所有key的数据，然后再取最后一条数据（tail -n 1）作为结果。仔细思考一下，这个数据库逻辑是正确的，而且还是持久化的。&lt;/p&gt;&lt;p&gt;这个数据库原理虽然简单，但是其中set使用日志追加的方式写入数据却是很多数据库的常用方式，因为日志追加性能非常好。相对的，get的方式性能就比较差了，需要从头到尾扫描整个文件，查询的开销是O(n)。&lt;/p&gt;&lt;p&gt;为了提高读取的性能，我们需要用到索引，基本的思路就是通过保存额外的元数据，根据这些元数据作为路标来快速定位到想要的数据。但是天下没有免费的午餐，维护索引需要在写入的时候额外写入其他数据，这会影响写入的性能。这里就涉及到存储系统中重要的权衡设计：&lt;strong&gt;适当的索引可以加速读取，但是每个索引都会减慢写入的速度。&lt;/strong&gt;下面我们就给我们简单的数据库加上最简单的索引方式：哈希索引。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;基于哈希索引的数据库&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;回想一下我们经常使用HashMap数据结构，哈希索引就是基于内存的HashMap来实现的，不同的是我们在内存里面使用HashMap的时候value都是直接存储原始数据的，对于数据库来说，如果你把所有的原始数据都直接存储到内存的话，这是不现实的。那怎么办呢？想想我们在编程里面常用的指针，是不是得到启发了？我们可以在内存里面保存原始数据的“指针”，即文件的字节偏移量和数据的长度。指针的占用量很小，这样我们完全可以把整个数据库的key的索引都放到内存里面，读取的时候直接找到key在文件中的偏移量，直接去磁盘读取数据。&lt;/p&gt;&lt;p&gt;借用书中的图示&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4684385382059801&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ph2O4rDx4Lg6icSR9MvXSuPaxgt6CdQ1ibrTJCTonTWLPHyk36XuE1cyIhlAmOHwRJlTID8REibR7GibcvpfAaZsug/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1204&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;-w602&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这个哈希索引的原理听起来很简单，但是这可是在生产中被实际使用过的Bitcask数据库的核心原理。只要保证所有key都能放到内存里面，Bitcask就能提供高性能的读写，因为它的索引结构简单，写入也是内存操作，可以说索引的代价可以忽略不计，而读取只需要一次内存寻址，在有文件系统缓存时甚至不需要IO操作。在某些场景中这个数据库可以完爆其他所有数据库。&lt;/p&gt;&lt;p&gt;了解了基本原理之后，下面开始实操环节。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;数据命令&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;首先定义一下我们数据库的基本功能：&lt;/p&gt;&lt;p&gt;如果基于日志追加来做，我们的存储结构要怎么设计呢？肯定不能按照前面的简单数据库那样搞，因为光把数据存进去不能支持删除数据的功能。回想一下MySQL的RedoLog，我们可以得到一些启发。如果我们不记录原始数据，而是记录数据命令呢？例如，我们按照下面的格式来记录数据。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;set: key1,value1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;set: key2,value2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;set: key1,value1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;rm: key1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为写入的操作只有两个：set和rm，所以我们可以定义两个数据命令，每次都把这些数据命令记录到日志里面，这样读取的时候读取到的就是数据命令，假设我们现在读取key2，实际上从磁盘读取到的数据是：&lt;code&gt;set: key2,value2&lt;/code&gt;，这样我们就知道key2现在的最新值是value2，当读取key1的时候，从磁盘读取到的数据是&lt;code&gt;rm: key1&lt;/code&gt;，那么意味着key1已经被删除了。&lt;/p&gt;&lt;p&gt;在Rust中数据命令的定义如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;pub &lt;span&gt;enum&lt;/span&gt; Command {&lt;br/&gt;    &lt;span&gt;Set&lt;/span&gt; { key: &lt;span&gt;String&lt;/span&gt;, value: &lt;span&gt;String&lt;/span&gt; },&lt;br/&gt;    Remove { key: &lt;span&gt;String&lt;/span&gt; },&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;数据写入&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;接下来定义我们的数据库对象，成员变量只有三个，一个读取器、一个写入器、一个索引。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;pub&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;KvStore&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;reader&lt;/span&gt;: BufReaderWithPos&amp;lt;File&amp;gt;,&lt;br/&gt;    writer: BufWriterWithPos&amp;lt;File&amp;gt;,&lt;br/&gt;    index: HashMap&amp;lt;String, CommandPos&amp;gt;,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;CommandPos&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;pos&lt;/span&gt;: u64,&lt;br/&gt;    len: u64,&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么写入操作具体要做什么呢？看一下的代码注释&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    pub fn set(&amp;amp;mut &lt;span&gt;self&lt;/span&gt;, key: String, value: String) -&amp;gt; Result&amp;lt;()&amp;gt; {&lt;br/&gt;        &lt;span&gt;//构造一个写入命令&lt;/span&gt;&lt;br/&gt;        let cmd = Command::set(key, value);&lt;br/&gt;        &lt;span&gt;//获取当前写入句柄的位置&lt;/span&gt;&lt;br/&gt;        let pos = &lt;span&gt;self&lt;/span&gt;.writer.pos;&lt;br/&gt;        &lt;span&gt;//通过serde把set命令序列化成json写入到文件中&lt;/span&gt;&lt;br/&gt;        serde_json::to_writer(&amp;amp;mut &lt;span&gt;self&lt;/span&gt;.writer, &amp;amp;cmd)?;&lt;br/&gt;        &lt;span&gt;//文件刷盘持久化&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;self&lt;/span&gt;.writer.flush()?;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; let Command::Set { key, .. } = cmd {&lt;br/&gt;        &lt;span&gt;//记录写入命令的开始位置和长度&lt;/span&gt;&lt;br/&gt;            let cmd_pos = CommandPos { pos, len: &lt;span&gt;self&lt;/span&gt;.writer.pos - pos };&lt;br/&gt;            &lt;span&gt;//把当前key的最新命令位置记录到索引里面&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;self&lt;/span&gt;.index.insert(key, cmd_pos);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        Ok(())&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除操作也是类似的：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    pub fn remove(&amp;amp;mut &lt;span&gt;self&lt;/span&gt;, key: String) -&amp;gt; Result&amp;lt;()&amp;gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;self&lt;/span&gt;.index.contains_key(&amp;amp;key) {&lt;br/&gt;            &lt;span&gt;//构造删除命令&lt;/span&gt;&lt;br/&gt;            let cmd = Command::remove(key);&lt;br/&gt;            &lt;span&gt;//写入到文件&lt;/span&gt;&lt;br/&gt;            serde_json::to_writer(&amp;amp;mut &lt;span&gt;self&lt;/span&gt;.writer, &amp;amp;cmd)?;&lt;br/&gt;            &lt;span&gt;self&lt;/span&gt;.writer.flush()?;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; let Command::Remove { key } = cmd {&lt;br/&gt;                &lt;span&gt;//从索引中删除key，这样就读取不到了。&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;self&lt;/span&gt;.index.remove(&amp;amp;key).expect(&lt;span&gt;&quot;key not found&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;            Ok(())&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            Err(KvsError::KeyNotFound)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;数据读取&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;数据读取主要是从索引里面获取命令位置，然后从磁盘读取命令返回结果。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    pub fn get(&amp;amp;mut &lt;span&gt;self&lt;/span&gt;, &lt;span&gt;key:&lt;/span&gt; String) -&amp;gt; Result&amp;lt;Option&amp;lt;String&lt;span&gt;&amp;gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//&lt;/span&gt;从索引中读取key的命令位置，如果读取不到说明key不存在&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; let Some(cmd_pos) = &lt;span&gt;self&lt;/span&gt;.index.get(&amp;amp;key) {&lt;br/&gt;            let reader = &amp;amp;mut &lt;span&gt;self&lt;/span&gt;.reader;&lt;br/&gt;            &lt;span&gt;//&lt;/span&gt;把读取器游标设置到命令的起始位置&lt;br/&gt;            reader.seek(SeekFrom::Start(cmd_pos.pos))?;&lt;br/&gt;            &lt;span&gt;//&lt;/span&gt;指定读取的长度&lt;br/&gt;            let cmd_reader = reader.take(cmd_pos.len);&lt;br/&gt;            &lt;span&gt;//&lt;/span&gt;读取命令&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; let Command::Set {value, ..} = serde_json::from_reader(cmd_reader)? {&lt;br/&gt;                Ok(Some(value))&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                Err(KvsError::UnexpectedCommandType)&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            Ok(None)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;数据加载&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;数据库每次启动都需要从文件中命令回放一遍，然后构建出内存索引才能开始使用。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;fn load(reader: &amp;amp;mut BufReaderWithPos&amp;lt;File&amp;gt;, index: &amp;amp;mut HashMap&amp;lt;String, CommandPos&amp;gt;) -&amp;gt; Result&amp;lt;()&amp;gt; {&lt;br/&gt;    &lt;span&gt;//设置文件游标到0，从开始遍历到文件末尾&lt;/span&gt;&lt;br/&gt;    let mut pos = reader.seek(SeekFrom::Start(&lt;span&gt;0&lt;/span&gt;))?;&lt;br/&gt;    let mut stream = Deserializer::from_reader(reader).into_iter::&amp;lt;Command&amp;gt;();&lt;br/&gt;    &lt;span&gt;//遍历命令&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; let Some(cmd) = stream.next() {&lt;br/&gt;        let new_pos = stream.byte_offset() &lt;span&gt;as&lt;/span&gt; u64;&lt;br/&gt;        match cmd? {&lt;br/&gt;            &lt;span&gt;//如果是set命令就插入到索引中&lt;/span&gt;&lt;br/&gt;            Command::Set {key, ..} =&amp;gt; {&lt;br/&gt;                index.insert(key, CommandPos{pos, len: new_pos - pos});&lt;br/&gt;            },&lt;br/&gt;            &lt;span&gt;//如果是rm命令就从索引中删除key&lt;/span&gt;&lt;br/&gt;            Command::Remove {key} =&amp;gt; {&lt;br/&gt;                index.remove(&amp;amp;key);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        pos = new_pos;&lt;br/&gt;    }&lt;br/&gt;    Ok(())&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;至此，一个简单的基于哈希索引的数据库就完成了。完整代码可以参考：log_base&lt;/p&gt;&lt;h3&gt;&lt;span&gt;日志文件压缩&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;上面我们实现的数据库有一个明细的缺陷：如果使用时间很长的情况下，日志文件会非常大，可能把磁盘用光了。所以要想办法对日志文件进行压缩，可以发现对于相同的key在日志文件中会重复保存，而且实际上我们只会使用最新的命令。这部分没用的命令是可以删除掉的。因此，一个简单的日志压缩方式就是把重复的key删除掉只保留每个key最近的更新。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5247524752475248&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ph2O4rDx4Lg6icSR9MvXSuPaxgt6CdQ1ib1ibvtAu9dM0Uv25icHgywvfRa9DPn7NG9PtaYm6hMuYU5yUU7HSndPPw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1212&quot; title=&quot;-w606&quot;/&gt;&lt;figcaption&gt;-w606&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;压缩日志文件实现会比较复杂，核心思路就是要将日志进行分段处理，当日志大小超过某个阈值时，新建一个日志用于写入，然后再新建一个日志将之前的全部日志遍历一遍进行压缩，最后将原始日志删除。&lt;br/&gt;由于加入了分段日志的设计，所以现在要寻找一个key在磁盘的位置，需要增加一个维度：日志文件的序号。即命令位置的数据结构需要新增一个gen字段用于标识文件的序号。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;CommandPos&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;gen&lt;/span&gt;: u64,&lt;br/&gt;    pos: u64,&lt;br/&gt;    len: u64,&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;数据库的成员对象也需要修改，具体见注释。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;pub &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;KvStore&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//记录日志文件的目录&lt;/span&gt;&lt;br/&gt;    path: PathBuf,&lt;br/&gt;    &lt;span&gt;//从单个读取器修改为多个日志读取器的集合，key是日志文件的序号&lt;/span&gt;&lt;br/&gt;    readers: HashMap&amp;lt;u64, BufReaderWithPos&amp;lt;File&amp;gt;&amp;gt;,&lt;br/&gt;    writer: BufWriterWithPos&amp;lt;File&amp;gt;,&lt;br/&gt;    index: HashMap&amp;lt;String, CommandPos&amp;gt;,&lt;br/&gt;    &lt;span&gt;//记录当前写入的文件序号，压缩时写入的文件序号会自增切换到新的文件上&lt;/span&gt;&lt;br/&gt;    current_gen: u64,&lt;br/&gt;    &lt;span&gt;//记录当前未压缩的命令大小&lt;/span&gt;&lt;br/&gt;    uncompacted: u64,&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;压缩日志的代码实现如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    pub fn compact(&amp;amp;mut &lt;span&gt;self&lt;/span&gt;) -&amp;gt; Result&amp;lt;()&amp;gt; {&lt;br/&gt;        &lt;span&gt;//新增一个压缩日志序号，为当前序号+1&lt;/span&gt;&lt;br/&gt;        let compaction_gen = &lt;span&gt;self&lt;/span&gt;.current_gen + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//当前写入的日志序号+2，作为新的日志写入序号&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;self&lt;/span&gt;.current_gen += &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;self&lt;/span&gt;.writer = &lt;span&gt;self&lt;/span&gt;.new_log_file(&lt;span&gt;self&lt;/span&gt;.current_gen)?;&lt;br/&gt;&lt;br/&gt;        let mut new_pos = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//根据压缩日志序号创建一个写入器&lt;/span&gt;&lt;br/&gt;        let mut compaction_writer = &lt;span&gt;self&lt;/span&gt;.new_log_file(compaction_gen)?;&lt;br/&gt;        &lt;span&gt;//遍历当前索引的所有key&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; cmd_pos in &amp;amp;mut &lt;span&gt;self&lt;/span&gt;.index.values_mut() {&lt;br/&gt;            &lt;span&gt;//获取当前key的关联的文件读取器&lt;/span&gt;&lt;br/&gt;            let reader = &lt;span&gt;self&lt;/span&gt;.readers.get_mut(&amp;amp;cmd_pos.gen)&lt;br/&gt;                .expect(format!(&lt;span&gt;&quot;Can&#x27;t find reader: {}&quot;&lt;/span&gt;, &amp;amp;cmd_pos.gen).as_str());&lt;br/&gt;            &lt;span&gt;//将读取器的游标切换到命令的起始位置&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; reader.pos != cmd_pos.pos {&lt;br/&gt;                reader.seek(SeekFrom::Start(cmd_pos.pos))?;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//设置读取器读取的数据长度&lt;/span&gt;&lt;br/&gt;            let mut cmd_reader = reader.take(cmd_pos.len);&lt;br/&gt;            &lt;span&gt;//把命令拷贝到压缩日志写入器中&lt;/span&gt;&lt;br/&gt;            let len = io::copy(&amp;amp;mut cmd_reader, &amp;amp;mut compaction_writer)?;&lt;br/&gt;            &lt;span&gt;//更新索引中key的命令位置数据&lt;/span&gt;&lt;br/&gt;            *cmd_pos = CommandPos {gen: compaction_gen, pos: new_pos, len };&lt;br/&gt;            new_pos += len;&lt;br/&gt;        }&lt;br/&gt;        compaction_writer.flush()?;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//因为日志序号是从小到大增长的，要删除之前的日志只需要把小于压缩日志序号的文件都删除掉就行&lt;/span&gt;&lt;br/&gt;        let stale_gens: Vec&amp;lt;_&amp;gt; = &lt;span&gt;self&lt;/span&gt;.readers.keys()&lt;br/&gt;            .filter(|&amp;amp;&amp;amp;gen| gen &amp;lt; compaction_gen)&lt;br/&gt;            .cloned().collect();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; stale_gen in stale_gens {&lt;br/&gt;            &lt;span&gt;self&lt;/span&gt;.readers.remove(&amp;amp;stale_gen);&lt;br/&gt;            fs::remove_file(log_path(&amp;amp;&lt;span&gt;self&lt;/span&gt;.path, stale_gen))?;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;self&lt;/span&gt;.uncompacted = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        Ok(())&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看代码可能不太好理解日志压缩的过程，下面我们举一个日志文件压缩的例子&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.537007874015748&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ph2O4rDx4Lg6icSR9MvXSuPaxgt6CdQ1ibULr0nZ06RIhbicF90Abc2shGRLYib5ibAhh28hk0bCLCch5jgtlqnctmQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1270&quot; title=&quot;-w635&quot;/&gt;&lt;figcaption&gt;-w635&lt;/figcaption&gt;&lt;/figure&gt;&lt;br/&gt;压缩过程中让当前写入切换到3.log，可以保证写入不受影响，同时新增一个2.log作为压缩日志进行拷贝，边拷贝边更新索引，可以保证读取不受影响，等压缩完成之后，把1.log删除，平滑切换到新的日志上面。&lt;p&gt;&lt;/p&gt;&lt;p&gt;完整的源码可以参考：log_compact，这里的实现为了简单起见没有按照书里面使用异步线程去做，是在set的时候判断未压缩的大小是否超过阈值进行同步压缩的，即会阻塞写入操作，这是一个可优化点，在后续的更新中会优化掉，但是日志压缩思路是一致的。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;哈希索引的优缺点&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;哈希索引使用顺序写入的日志来追加式地记录每一个命令，看起来非常浪费存储空间：为什么不是直接原地更新文件，用新数据覆盖老数据呢？实际上追加式的设计是非常优秀的，主要原因有以下几个：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;追加式主要使用顺序写入，性能非常高，比起覆盖式的随机写入要快得多。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;追加式的写入在处理并发和崩溃恢复时要简单得多，例如不需要担心在重写值时发生崩溃的情况，追加式写入时如果崩溃了，只需要丢弃文件末尾有问题的数据，而覆盖式更新崩溃，你都不知道哪些数据是脏数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;追加式的日志写入可以通过合并旧的日志文件解决碎片化的问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;说了优点之后，也要说一下缺点：&lt;/p&gt;&lt;h2&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;本文主要说明了基于哈希索引的KV数据库的实现原理，同时给出了代码实现。基于追加式日志写入的哈希索引非常简单高效，同时也有一定的局限性。哈希索引只是KV数据库的起步，后续我们还会看到解决哈希索引缺点的新索引结构（LSM-tree），这些索引设计的思想是很多先进KV数据库（如Hbase、Cassandra）的基石。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a9884696d7b747f9efe69618983f33ce</guid>
<title>Spring Boot 整合 OAuth 2</title>
<link>https://toutiao.io/k/ttniazg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;1、什么是OAuth&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2、OAuth 角色&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3、OAuth 授权流程&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4、OAuth授权模式&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;4.1、授权码&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.2、隐藏式&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.3、密码式&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.4、凭证式&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;1、密码模式&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2、授权码模式&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、OAuth 简介&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9971428571428571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMsSHIX8UjDx592Eu0SSVAswtEYccicx41Pl1kxCLaES2Iib2rxVqyFgrJu1aDsngoe5XaBHybowmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;350&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、什么是OAuth&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开放授权（Open Authorization,OAuth）是一种资源提供商用于授权第三方应用代表资源所有者获取有限访问权限的授权机制。由于在整个授权过程中，第三方应用都无须触及用户的密码就可以取得部分资源的使用权限，所以OAuth是安全开放的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如，用户想通过 QQ 登录csdn，这时csdn就是一个第三方应用，csdn要访问用户的一些基本信息就需要得到用户的授权，如果用户把自己的 QQ 用户名和密码告诉csdn，那么csdn就能访问用户的所有数据，井且只有用户修改密码才能收回授权，这种授权方式安全隐患很大，如果使用 OAuth ，就能很好地解决这一问题。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4724612736660929&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMsSHIX8UjDx592Eu0SSVAaibxILDhzib4eicuoPU3Tf4jPXUzPXQJJf3hPe84mvrkuuUHCHNfZZDeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1162&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OAuth第一个版本诞生于2007年12月，并于2010年4月正式被IETF作为标准发布（编号RFC 5849）。由于OAuth1.0复杂的签名逻辑以及单一的授权流程存在较大缺陷，随后标准工作组又推出了 OAuth2.0草案，并在2012年10月正式发布其标准（编号RFC 6749）。OAuth2.0放弃了OAuth1.0中让开发者感到痛苦的数字签名和加密方案，使用已经得到验证并广泛使用的HTTPS技术作为安全保障手 段。OAuth2.0与OAuth1.0互不兼容，由于OAuth1.0已经基本退出历史舞台，所以下面提到的OAuth都是指OAuth2.0。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、OAuth 角色&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要理解OAuth的运行流程，则必须要认识4个重要的角色。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Resource Owner：资源所有者，通常指用户，例如每一个QQ用户。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Resource Server：资源服务器，指存放用户受保护资源的服务器，通常需要通过Access Token（访问令牌）才能进行访问。例如，存储QQ用户基本信息的服务器，充当的便是资源服务器的 角色。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Client：客户端，指需要获取用户资源的第三方应用，如CSDN网站。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Authorization Server：授权服务器，用于验证资源所有者，并在验证成功之后向客户端发放相关访问令牌。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、OAuth 授权流程&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是 个大致的流程，因为 OAuth2 中有 种不同的授权模式，每种授权模式的授权流程又会有差异，基本流程如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;客户端（第三方应用）向资源所有者请求授权。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端返回一个授权许可凭证给客户端。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端拿着授权许可凭证去授权服务器申请令牌。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;授权服务器验证信息无误后，发放令牌给客户端。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端拿着令牌去资源服务器访问资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;资源服务器验证令牌无误后开放资源。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5955265610438024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMsSHIX8UjDx592Eu0SSVAXebibxNSHorw1djvDyDsYaxwQj8Xst1fRMMnibUMRTBp4T9CtUDWF05A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1073&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4、OAuth授权模式&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OAuth 协议的授权模式共分为4种。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1、授权码&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一步，A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;https:&lt;span&gt;//b.com/oauth/authorize?&lt;/span&gt;&lt;br/&gt;  response_type=code&amp;amp;&lt;br/&gt;  client_id=CLIENT_ID&amp;amp;&lt;br/&gt;  redirect_uri=CALLBACK_URL&amp;amp;&lt;br/&gt;  scope=read&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面 URL 中，response_type参数表示要求返回授权码（code），client_id参数让 B 知道是谁在请求，redirect_uri参数是 B 接受或拒绝请求后的跳转网址，scope参数表示要求的授权范围（这里是只读）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMsSHIX8UjDx592Eu0SSVAEQ6URibOEzegqDm9r0j4vJSpkDQa8cyS70rAEgB9hlGUh1r4k8AMZAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回redirect_uri参数指定的网址。跳转时，会传回一个授权码，就像下面这样。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;https:&lt;span&gt;//a.com/callback?code=AUTHORIZATION_CODE&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面 URL 中，code参数就是授权码。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMsSHIX8UjDx592Eu0SSVAYJLLWCEC8eRicATcWicoFIiceuQKmMBJ18N4nt0vOxHn9bGD9ic3W2Wicng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;https:&lt;span&gt;//b.com/oauth/token?&lt;/span&gt;&lt;br/&gt; client_id=CLIENT_ID&amp;amp;&lt;br/&gt; client_secret=CLIENT_SECRET&amp;amp;&lt;br/&gt; grant_type=authorization_code&amp;amp;&lt;br/&gt; code=AUTHORIZATION_CODE&amp;amp;&lt;br/&gt; redirect_uri=CALLBACK_URL&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面 URL 中，client_id 参数和 client_secret 参数用来让 B 确认 A 的身份（client_secret参数是保密的，因此只能在后端发请求），grant_type参数的值是 AUTHORIZATION_CODE，表示采用的授权方式是授权码，code参数是上一步拿到的授权码，redirect_uri 参数是令牌颁发后的回调网址。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMsSHIX8UjDx592Eu0SSVAujcempwUdRjAPM3iandeQ7pBBqRezzHbqxgc1padPBSCneXRKKmkibuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向redirect_uri指定的网址，发送一段 JSON 数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;    {    &lt;br/&gt;      &lt;span&gt;&quot;access_token&quot;&lt;/span&gt;:&lt;span&gt;&quot;ACCESS_TOKEN&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;token_type&quot;&lt;/span&gt;:&lt;span&gt;&quot;bearer&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;expires_in&quot;&lt;/span&gt;:&lt;span&gt;2592000&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;refresh_token&quot;&lt;/span&gt;:&lt;span&gt;&quot;REFRESH_TOKEN&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;scope&quot;&lt;/span&gt;:&lt;span&gt;&quot;read&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;uid&quot;&lt;/span&gt;:&lt;span&gt;100101&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;info&quot;&lt;/span&gt;:{...}&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面 JSON 数据中，access_token字段就是令牌，A 网站在后端拿到了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMsSHIX8UjDx592Eu0SSVAVLmJVVn9ngricCSFjZdHp9u7DWs3QAedccQdra75fJdNthZ7RV63ftQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2、隐藏式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。&lt;strong&gt;RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）&quot;隐藏式&quot;（implicit）。&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一步，A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;https:&lt;span&gt;//b.com/oauth/authorize?&lt;/span&gt;&lt;br/&gt;  response_type=token&amp;amp;&lt;br/&gt;  client_id=CLIENT_ID&amp;amp;&lt;br/&gt;  redirect_uri=CALLBACK_URL&amp;amp;&lt;br/&gt;  scope=read&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面 URL 中，response_type参数为token，表示要求直接返回令牌。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第二步，用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回redirect_uri参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;https:&lt;span&gt;//a.com/callback#token=ACCESS_TOKEN&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面 URL 中，token参数就是令牌，A 网站因此直接在前端拿到令牌。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在&quot;中间人攻击&quot;的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMsSHIX8UjDx592Eu0SSVAZfwfPBwfENmfBTLMok0OpUnJRHf7RvRmAMLcMsoicibic0KNGSAvZIzicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3、密码式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为&quot;密码式&quot;（password）。&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一步，A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;https:&lt;span&gt;//oauth.b.com/token?&lt;/span&gt;&lt;br/&gt;  grant_type=password&amp;amp;&lt;br/&gt;  username=USERNAME&amp;amp;&lt;br/&gt;  password=PASSWORD&amp;amp;&lt;br/&gt;  client_id=CLIENT_ID&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面 URL 中，grant_type参数是授权方式，这里的password表示&quot;密码式&quot;，username和password是 B 的用户名和密码。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第二步，B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4、凭证式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最后一种方式是凭证式（client credentials），适用于没有前端的命令行应用，即在命令行下请求令牌。&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;https:&lt;span&gt;//oauth.b.com/token?&lt;/span&gt;&lt;br/&gt;  grant_type=client_credentials&amp;amp;&lt;br/&gt;  client_id=CLIENT_ID&amp;amp;&lt;br/&gt;  client_secret=CLIENT_SECRET&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面 URL 中，grant_type参数等于client_credentials表示采用凭证式，client_id和client_secret用来让 B 确认 A 的身份。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、实践&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、密码模式&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是自建单点服务，一般都会使用密码模式。资源服务器和授权服务器
可以是同一台服务器，也可以分开。这里我们学习分布式的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;授权服务器和资源服务器分开，项目结构如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2430555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMsSHIX8UjDx592Eu0SSVAmv1fkT9gxd74rLFPbeBxGNXGbN8zHM1vG90WcyaToJJlBgFfYzncYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;576&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1、授权服务器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;授权服务器的职责：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;管理客户端及其授权信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;管理用户及其授权信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;管理Token的生成及其存储&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;管理Token的校验及校验Key&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1.1、依赖&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        &amp;lt;!--security--&amp;gt;&lt;br/&gt;        &amp;lt;dependency&amp;gt;&lt;br/&gt;            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;            &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;&lt;br/&gt;        &amp;lt;/dependency&amp;gt;&lt;br/&gt;        &amp;lt;!--oauth2--&amp;gt;&lt;br/&gt;        &amp;lt;dependency&amp;gt;&lt;br/&gt;            &amp;lt;groupId&amp;gt;org.springframework.security.oauth&amp;lt;/groupId&amp;gt;&lt;br/&gt;            &amp;lt;artifactId&amp;gt;spring-security-oauth2&amp;lt;/artifactId&amp;gt;&lt;br/&gt;            &amp;lt;version&amp;gt;&lt;span&gt;2.3&lt;/span&gt;&lt;span&gt;.6&lt;/span&gt;.RELEASE&amp;lt;/version&amp;gt;&lt;br/&gt;        &amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1.2、授权服务器配置&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;授权服务器配置通过继承AuthorizationServerConfigurerAdapter的配置类实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@Author&lt;/span&gt; 三分恶&lt;br/&gt; * &lt;span&gt;@Date&lt;/span&gt; 2020/5/20&lt;br/&gt; * &lt;span&gt;@Description&lt;/span&gt;  授权服务器配置&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@EnableAuthorizationServer&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AuthorizationServerConfig&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AuthorizationServerConfigurerAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; AuthenticationManager authenticationManager;&lt;span&gt;//密码模式需要注入认证管理器&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; PasswordEncoder passwordEncoder;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//配置客户端&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;configure&lt;/span&gt;&lt;span&gt;(ClientDetailsServiceConfigurer clients)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        clients.inMemory()&lt;br/&gt;                .withClient(&lt;span&gt;&quot;client-demo&quot;&lt;/span&gt;)&lt;br/&gt;                .secret(passwordEncoder.encode(&lt;span&gt;&quot;123&quot;&lt;/span&gt;))&lt;br/&gt;                .authorizedGrantTypes(&lt;span&gt;&quot;password&quot;&lt;/span&gt;) &lt;span&gt;//这里配置为密码模式&lt;/span&gt;&lt;br/&gt;                .scopes(&lt;span&gt;&quot;read_scope&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;configure&lt;/span&gt;&lt;span&gt;(AuthorizationServerEndpointsConfigurer endpoints)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        endpoints.authenticationManager(authenticationManager);&lt;span&gt;//密码模式必须添加authenticationManager&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;configure&lt;/span&gt;&lt;span&gt;(AuthorizationServerSecurityConfigurer security)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        security.allowFormAuthenticationForClients()&lt;br/&gt;                .checkTokenAccess(&lt;span&gt;&quot;isAuthenticated()&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;客户端的注册：这里通过inMemory的方式在内存中注册客户端相关信息；实际项目中可以通过一些管理接口及界面动态实现客户端的注册&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;校验Token权限控制：资源服务器如果需要调用授权服务器的/oauth/check_token接口校验token有效性，那么需要配置checkTokenAccess(&quot;isAuthenticated()&quot;)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;authenticationManager配置：需要通过endpoints.authenticationManager(authenticationManager)将Security中的authenticationManager配置到Endpoints中，否则，在Spring Security中配置的权限控制将不会在进行OAuth2相关权限控制的校验时生效。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1.3、Spring Security配置&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过Spring Security来完成用户及密码加解密等配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@Author&lt;/span&gt; 三分恶&lt;br/&gt; * &lt;span&gt;@Date&lt;/span&gt; 2020/5/20&lt;br/&gt; * &lt;span&gt;@Description&lt;/span&gt; SpringSecurity 配置&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@EnableWebSecurity&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SecurityConfig&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;WebSecurityConfigurerAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; PasswordEncoder &lt;span&gt;passwordEncoder&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BCryptPasswordEncoder();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; AuthenticationManager &lt;span&gt;authenticationManager&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.authenticationManager();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;configure&lt;/span&gt;&lt;span&gt;(AuthenticationManagerBuilder auth)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        auth.inMemoryAuthentication()&lt;br/&gt;                .withUser(&lt;span&gt;&quot;fighter&quot;&lt;/span&gt;)&lt;br/&gt;                .password(passwordEncoder().encode(&lt;span&gt;&quot;123&quot;&lt;/span&gt;))&lt;br/&gt;                .authorities(&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;0&lt;/span&gt;));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;configure&lt;/span&gt;&lt;span&gt;(HttpSecurity http)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//所有请求必须认证&lt;/span&gt;&lt;br/&gt;        http.authorizeRequests().anyRequest().authenticated();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2、资源服务器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;资源服务器的职责：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2.1、资源服务器配置&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;资源服务器依赖一样，而配置则通过继承自ResourceServerConfigurerAdapter的配置类来实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@Author&lt;/span&gt; 三分恶&lt;br/&gt; * &lt;span&gt;@Date&lt;/span&gt; 2020/5/20&lt;br/&gt; * &lt;span&gt;@Description&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@EnableResourceServer&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ResourceServerConfig&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ResourceServerConfigurerAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RemoteTokenServices &lt;span&gt;remoteTokenServices&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; RemoteTokenServices tokenServices = &lt;span&gt;new&lt;/span&gt; RemoteTokenServices();&lt;br/&gt;        tokenServices.setClientId(&lt;span&gt;&quot;client-demo&quot;&lt;/span&gt;);&lt;br/&gt;        tokenServices.setClientSecret(&lt;span&gt;&quot;123&quot;&lt;/span&gt;);&lt;br/&gt;        tokenServices.setCheckTokenEndpointUrl(&lt;span&gt;&quot;http://localhost:8090/oauth/check_token&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; tokenServices;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;configure&lt;/span&gt;&lt;span&gt;(ResourceServerSecurityConfigurer resources)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        resources.stateless(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;configure&lt;/span&gt;&lt;span&gt;(HttpSecurity http)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//session创建策略&lt;/span&gt;&lt;br/&gt;        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED);&lt;br/&gt;        &lt;span&gt;//所有请求需要认证&lt;/span&gt;&lt;br/&gt;        http.authorizeRequests().anyRequest().authenticated();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要进行了如下配置：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;TokenService配置：在不采用JWT的情况下，需要配置RemoteTokenServices来充当tokenServices，它主要完成Token的校验等工作。因此需要指定校验Token的授权服务器接口地址&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同时，由于在授权服务器中配置了/oauth/check_token需要客户端登录后才能访问，因此也需要配置客户端编号及Secret；在校验之前先进行登录&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过ResourceServerSecurityConfigurer来配置需要访问的资源编号及使用的TokenServices&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2.2、资源服务接口&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口比较简单：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@Author&lt;/span&gt; 三分恶&lt;br/&gt; * &lt;span&gt;@Date&lt;/span&gt; 2020/5/20&lt;br/&gt; * &lt;span&gt;@Description&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ResourceController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/user/{username}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;user&lt;/span&gt;&lt;span&gt;(@PathVariable String username)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Hello !&quot;&lt;/span&gt;+username;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3、测试&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;授权服务器使用8090端口启动，资源服务器使用默认端口。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3.1、获取token&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;访问/oauth/token端点，获取token：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;url:      http://localhost:8090/oauth/token?username=fighter&amp;amp;password=123&amp;amp;scope=read_scope&amp;amp;grant_type=password&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34311328443357786&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMsSHIX8UjDx592Eu0SSVAnRUf6SqYzydHmgmVQEJDGnhIkFsh5D63TK2CmRpGUzwNjbBEr8aC3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1227&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.35093419983753044&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMsSHIX8UjDx592Eu0SSVAUlJBaeN3MAvMZHGAn9ARxCc7xLCqh9UYCxW5XtJibeanktaPJRNX7Yg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1231&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;返回的token&lt;br/&gt;&lt;img data-ratio=&quot;0.27713815789473684&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMsSHIX8UjDx592Eu0SSVAeyaBQvVN5GdGXUkf2yRas4MTyMeLAdLXWBTywzqykIZVKaL4icjjcaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1216&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3.2、使用获取到的token访问资源接口&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用token调用资源，访问http://localhost:8080/user/fighter，注意使用token添加Bearer请求头&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4254633360193392&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMsSHIX8UjDx592Eu0SSVAtGNJyNibzDvKBSXILwyicMWhhbq5UcxM90aDFeibAJq6nicnF3sO6ZQribw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1241&quot;/&gt;相当于在Headers中添加 Authorization:Bearer 4a3c351d-770d-42aa-af39-3f54b50152e9。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OK，可以看到资源正确返回。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里仅仅是密码模式的精简化配置，在实际项目中，某些部分如：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;资源服务访问授权服务去校验token这部分可能会换成Jwt、Redis等tokenStore实现，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;授权服务器中的用户信息与客户端信息生产环境从数据库中读取，对应Spring Security的UserDetailsService实现类或用户信息的Provider&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、授权码模式&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多网站登录时，允许使用第三方网站的身份，这称为&quot;第三方登录&quot;。所谓第三方登录，实质就是 OAuth 授权。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如用户想要登录 A 网站，A 网站让用户提供第三方网站的数据，证明自己的身份。获取第三方网站的身份数据，就需要 OAuth 授权。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以A网站使用GitHub第三方登录为例，流程示意如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMsSHIX8UjDx592Eu0SSVA3sVticicPMCZywc3J0o0CXqoxO3ywGN86BBsNooHlCibvUN3TUfVQGJMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1008&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，简单地实现GitHub登录流程。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1、应用注册&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用之前需要先注册一个应用，让GitHub可以识别。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;访问地址：https://github.com/settings/applications/new，填写注册表&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9778933680104032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMsSHIX8UjDx592Eu0SSVANDYJxOY9vhG8wgXPWWRGNEgABiaFbnz8sPOS2HjP1Rxy7J9Uw620icBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;769&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用的名称随便填，主页 URL 填写http://localhost:8080，回调地址填写 http://localhost:8080/oauth/redirect。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;提交表单以后，GitHub 应该会返回客户端 ID（client ID）和客户端密钥（client secret），这就是应用的身份识别码&lt;img data-ratio=&quot;0.9673278879813302&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMsSHIX8UjDx592Eu0SSVAqvUQ1nPtP9oezj7CAnlQdvgW1TRWug42BvY4CSntqdL8o8DP1rJXeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;857&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2、具体代码&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        &amp;lt;dependency&amp;gt;&lt;br/&gt;            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;&lt;br/&gt;        &amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;github.client.clientId=&lt;span&gt;29&lt;/span&gt;d127aa0753c12263d7&lt;br/&gt;github.client.clientSecret=f3cb9222961efe4c2adccd6d3e0df706972fa5eb&lt;br/&gt;github.client.authorizeUrl=https:&lt;span&gt;//github.com/login/oauth/authorize&lt;/span&gt;&lt;br/&gt;github.client.accessTokenUrl=https:&lt;span&gt;//github.com/login/oauth/access_token&lt;/span&gt;&lt;br/&gt;github.client.redirectUrl=http:&lt;span&gt;//localhost:8080/oauth/redirect&lt;/span&gt;&lt;br/&gt;github.client.userInfoUrl=https:&lt;span&gt;//api.github.com/user&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@ConfigurationProperties&lt;/span&gt;(prefix = &lt;span&gt;&quot;github.client&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GithubProperties&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String clientId;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String clientSecret;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String authorizeUrl;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String redirectUrl;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String accessTokenUrl;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String userInfoUrl;&lt;br/&gt;    &lt;span&gt;//省略getter、setter&lt;/span&gt;&lt;br/&gt;}    &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;index.html：首页比较简单,一个链接向后端发起登录请求&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br/&gt;&amp;lt;html lang=&lt;span&gt;&quot;en&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;    &amp;lt;meta charset=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;title&amp;gt;网站首页&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;    &amp;lt;div style=&lt;span&gt;&quot;text-align: center&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;        &amp;lt;a href=&lt;span&gt;&quot;http://localhost:8080/authorize&quot;&lt;/span&gt;&amp;gt;Login in with GitHub&amp;lt;/a&amp;gt;&lt;br/&gt;    &amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;GithubLoginController.java： * 使用RestTemplate发送http请求
 *  使用Jackson解析返回的json，不用引入更多依赖
 *  快捷起见，发送http请求的方法直接写在控制器中，实际上应该将工具方法分离出去
 *  同样是快捷起见，返回的用户信息没有做任何解析&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Controller&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GithubLoginController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    GithubProperties githubProperties;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 登录接口，重定向至github&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; 跳转url&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/authorize&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;authorize&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String url =githubProperties.getAuthorizeUrl() +&lt;br/&gt;                &lt;span&gt;&quot;?client_id=&quot;&lt;/span&gt; + githubProperties.getClientId() +&lt;br/&gt;                &lt;span&gt;&quot;&amp;amp;redirect_uri=&quot;&lt;/span&gt; + githubProperties.getRedirectUrl();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;redirect:&quot;&lt;/span&gt; + url;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 回调接口，用户同意授权后，GitHub会将授权码传递给此接口&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; code GitHub重定向时附加的授权码，只能用一次&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/oauth/redirect&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@ResponseBody&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;redirect&lt;/span&gt;&lt;span&gt;(@RequestParam(&lt;span&gt;&quot;code&quot;&lt;/span&gt;)&lt;/span&gt; String code) &lt;span&gt;throws&lt;/span&gt; JsonProcessingException &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;code:&quot;&lt;/span&gt;+code);&lt;br/&gt;        &lt;span&gt;// 使用code获取token&lt;/span&gt;&lt;br/&gt;        String accessToken = &lt;span&gt;this&lt;/span&gt;.getAccessToken(code);&lt;br/&gt;        &lt;span&gt;// 使用token获取userInfo&lt;/span&gt;&lt;br/&gt;        String userInfo = &lt;span&gt;this&lt;/span&gt;.getUserInfo(accessToken);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; userInfo;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 使用授权码获取token&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; code&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; String &lt;span&gt;getAccessToken&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; JsonProcessingException &lt;/span&gt;{&lt;br/&gt;        String url = githubProperties.getAccessTokenUrl() +&lt;br/&gt;                &lt;span&gt;&quot;?client_id=&quot;&lt;/span&gt; + githubProperties.getClientId() +&lt;br/&gt;                &lt;span&gt;&quot;&amp;amp;client_secret=&quot;&lt;/span&gt; + githubProperties.getClientSecret() +&lt;br/&gt;                &lt;span&gt;&quot;&amp;amp;code=&quot;&lt;/span&gt; + code +&lt;br/&gt;                &lt;span&gt;&quot;&amp;amp;grant_type=authorization_code&quot;&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;// 构建请求头&lt;/span&gt;&lt;br/&gt;        HttpHeaders requestHeaders = &lt;span&gt;new&lt;/span&gt; HttpHeaders();&lt;br/&gt;        &lt;span&gt;// 指定响应返回json格式&lt;/span&gt;&lt;br/&gt;        requestHeaders.add(&lt;span&gt;&quot;accept&quot;&lt;/span&gt;, &lt;span&gt;&quot;application/json&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 构建请求实体&lt;/span&gt;&lt;br/&gt;        HttpEntity&amp;lt;String&amp;gt; requestEntity = &lt;span&gt;new&lt;/span&gt; HttpEntity&amp;lt;&amp;gt;(requestHeaders);&lt;br/&gt;        RestTemplate restTemplate = &lt;span&gt;new&lt;/span&gt; RestTemplate();&lt;br/&gt;        &lt;span&gt;// post 请求方式&lt;/span&gt;&lt;br/&gt;        ResponseEntity&amp;lt;String&amp;gt; response = restTemplate.postForEntity(url, requestEntity, String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        String responseStr = response.getBody();&lt;br/&gt;        &lt;span&gt;// 解析响应json字符串&lt;/span&gt;&lt;br/&gt;        ObjectMapper objectMapper = &lt;span&gt;new&lt;/span&gt; ObjectMapper();&lt;br/&gt;        JsonNode jsonNode = objectMapper.readTree(responseStr);&lt;br/&gt;        String accessToken = jsonNode.get(&lt;span&gt;&quot;access_token&quot;&lt;/span&gt;).asText();&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;accessToken:&quot;&lt;/span&gt;+accessToken);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; accessToken;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; accessToken 使用token获取userInfo&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; String &lt;span&gt;getUserInfo&lt;/span&gt;&lt;span&gt;(String accessToken)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String url = githubProperties.getUserInfoUrl();&lt;br/&gt;        &lt;span&gt;// 构建请求头&lt;/span&gt;&lt;br/&gt;        HttpHeaders requestHeaders = &lt;span&gt;new&lt;/span&gt; HttpHeaders();&lt;br/&gt;        &lt;span&gt;// 指定响应返回json格式&lt;/span&gt;&lt;br/&gt;        requestHeaders.add(&lt;span&gt;&quot;accept&quot;&lt;/span&gt;, &lt;span&gt;&quot;application/json&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// AccessToken放在请求头中&lt;/span&gt;&lt;br/&gt;        requestHeaders.add(&lt;span&gt;&quot;Authorization&quot;&lt;/span&gt;, &lt;span&gt;&quot;token &quot;&lt;/span&gt; + accessToken);&lt;br/&gt;        &lt;span&gt;// 构建请求实体&lt;/span&gt;&lt;br/&gt;        HttpEntity&amp;lt;String&amp;gt; requestEntity = &lt;span&gt;new&lt;/span&gt; HttpEntity&amp;lt;&amp;gt;(requestHeaders);&lt;br/&gt;        RestTemplate restTemplate = &lt;span&gt;new&lt;/span&gt; RestTemplate();&lt;br/&gt;        &lt;span&gt;// get请求方式&lt;/span&gt;&lt;br/&gt;        ResponseEntity&amp;lt;String&amp;gt; response = restTemplate.exchange(url, HttpMethod.GET, requestEntity, String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        String userInfo = response.getBody();&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;userInfo:&quot;&lt;/span&gt;+userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; userInfo;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3、测试&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;访问localhost:8080，点击链接，重定向至GitHub&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.15272496831432192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMsSHIX8UjDx592Eu0SSVA7HqKQgB081oA3AxV7mt6fUjbfO2H095wEFttayJL5RUX0LrMXMfrGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1578&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46795580110497237&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMsSHIX8UjDx592Eu0SSVA9lK5T3vhcxunaQmulZxN937xdxPNtQzKoKWYKEcpcPaYnu2PWgoMqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1810&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;登录成功后，GitHub 就会跳转到redirect_uri指定的跳转网址，并且带上授权码&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http:&lt;span&gt;//localhost:8080/oauth/redirect?code=d45683eded3ac7d4e6ed&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OK,用户信息也一并返回了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.14895833333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMsSHIX8UjDx592Eu0SSVA0jPm8WQiavicCwualUPH2SydNOGosxZpfoUVkwz9ad1cXib0lRNia5iafwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文为学习笔记类博客，学习资料见参考！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【1】：《SpringSecurity 实战》
【2】：《SpringBoot Vue全栈开发实战》
【3】：理解OAuth 2.0【4】：OAuth 2.0 的一个简单解释【5】：OAuth 2.0 的四种方式【6】：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;amp;mid=2247488214&amp;amp;idx=1&amp;amp;sn=5601775213285217913c92768d415eca&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;这个案例写出来，还怕跟面试官扯不明白 OAuth2 登录流程？&lt;/a&gt;【7】：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;amp;mid=2247488209&amp;amp;idx=2&amp;amp;sn=19b1e44fbb1f4c1210f0fa92a618d871&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;做微服务绕不过的 OAuth2，松哥也来和大家扯一扯 &lt;/a&gt;【8】：GitHub OAuth 第三方登录示例教程【9】：OAuth 2.0 认证的原理与实践【10】：Spring Security OAuth2 Demo —— 密码模式（Password）【11】：Spring Security OAuth专题学习-密码模式及客户端模式实例【12】：Spring Boot and OAuth2【13】：Spring Boot+OAuth2使用GitHub登录自己的服务&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7186f52fe6ec819a2b9b03503468d79e</guid>
<title>联网数据库 IoTDB：存储引擎原理篇</title>
<link>https://toutiao.io/k/9bo4ivw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6671641791044776&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8uJ0ic6nAag9pH7ewjNYafx6bribyYqa9vB3ic8UcxRhp2EN1Y6X0v3S4ckozP4XxvETFFelS9VeKl3hffHTyrGyA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;670&quot;/&gt;&lt;/p&gt;&lt;h1 cid=&quot;n0&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;前言&lt;/span&gt;&lt;/h1&gt;&lt;p cid=&quot;n34&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n139&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;没过正月都是年，在此给大家拜个晚年，衷心的祝福诸位读者朋友们晚年幸福 : ）&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n139&quot; mdtype=&quot;paragraph&quot;&gt;&lt;strong&gt;新年伊始，谈谈今年的写作计划吧。&lt;/strong&gt;&lt;/p&gt;&lt;p cid=&quot;n89&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;So let&#x27;s begin ...&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n45&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h1 cid=&quot;n12&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;IotDB简介&lt;/span&gt;&lt;/h1&gt;&lt;p mdtype=&quot;paragraph&quot; cid=&quot;n31&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n49&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Apache IoTDB（物联网数据库）是一体化收集、存储、管理与分析物联网时序数据的软件系统。Apache IoTDB 采用轻量式架构，具有高性能和丰富的功能，并与Apache Hadoop、Spark和Flink等进行了深度集成，可以满足工业物联网领域的海量数据存储、高速数据读取和复杂数据分析需求。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n52&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag9pH7ewjNYafx6bribyYqa9vX5jRnKhGVOBq3XsmVeoeQHxpWwIC2RbczVbeh7s87MHZ7Ccr0Zkx6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2180&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n52&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;/&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;home-Slide1.png&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n54&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h1 cid=&quot;n58&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;应用场景&lt;/span&gt;&lt;/h1&gt;&lt;p cid=&quot;n62&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h3 cid=&quot;n74&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;高端设备&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n75&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在高端制造业中，有很多设备配备有传感器来收集工作状态数据，例如气象站，风力涡轮机是常见的高端设备。这些设备如果支持Java或Go（正在开发中），则可以运行TsFile在本地存储数据。通过这种方式，TsFile可以提供具有高吞吐、高压缩率和毫秒级查询延迟的数据管理功能。结合TsFile-Sync工具，可以将TsFiles同步到数据中心。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n77&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h3 cid=&quot;n81&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;本地控制器&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n82&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在工厂现场，LAN网络下有数十台设备。IoTDB可以安装在工厂的本地控制器服务器上，以从这些设备接收数据。安装有IoTDB的本地服务器（普通PC或工作站）可以使用类SQL存储和查询数据。此外，使用TsFile-Sync工具，可以将本地控制器上的TsFile文件传输到云上安装有IoTDB实例的数据中心。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n69&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h3 cid=&quot;n84&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;云数据管理&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n85&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在高速网络（车联网等）的场景中，安装有传感器的汽车可以以一定频率收集自身的监视信息（行驶状态等）。通常，这些汽车设备的硬件配置有限，并且难以进行复杂的应用。轻量级的IoTDB（IoTDB客户端）应运而生。借助JDBC API（或MQTT），它可以使用窄带IoT或4G/5G发送数据，从而将设备和云连接在一起。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n64&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h1 cid=&quot;n56&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;存储架构&lt;/span&gt;&lt;/h1&gt;&lt;p cid=&quot;n29&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5704989154013015&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag9pH7ewjNYafx6bribyYqa9vvADmEvQ7bUx4JHDIx4niaGubke88tkicia1Bicg1WiapNLLQzrxwibkhqhWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;461&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n15&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;IoTDB 存储引擎基于 LSM Tree 结构设计，写入的数据先记录 WAL，再写到内存 memtable，在后台逐步刷到磁盘 TsFile；磁盘上的 TsFile 通过一定的规则进行 Compaction，保证查询效率。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n99&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n16&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;那么我们就先从LSM Tree 说起吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8uJ0ic6nAag9pH7ewjNYafx6bribyYqa9vSZIic4b5St7yXUAah2qzcxZmNaIgiaz9eJTVW4axcgQM0FUiczb8aoUYQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;h2 cid=&quot;n17&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;LSM Tree&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p cid=&quot;n18&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;LSM Tree(Log Structured Merge Tree) 并不像B+树、红黑树一样是一颗严格的树状数据结构，其实它是一种存储结构，目前HBase,LevelDB,RocksDB这些NoSQL存储都是采用的LSM树。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5368938861560084&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag9pH7ewjNYafx6bribyYqa9vSqPZzS0sL6sxFEqS9auxpSt1Z7bHPfFv59yM5ye2pbQMY3JtKKdWfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1423&quot;/&gt;&lt;/p&gt;&lt;h3 mdtype=&quot;heading&quot; cid=&quot;n213&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Mentable&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p cid=&quot;n221&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;MemTable是在内存中的数据结构，用于保存最近更新的数据，会按照Key有序地组织这些数据，LSM树对于具体如何组织有序地组织数据并没有明确的数据结构定义，例如Hbase使跳跃表来保证内存中key的有序。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n222&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;因为数据暂时保存在内存中，内存并不是可靠存储，如果断电会丢失数据，因此通常会通过WAL(Write-ahead logging，预写式日志)的方式来保证数据的可靠性。&lt;/span&gt;&lt;/p&gt;&lt;h3 mdtype=&quot;heading&quot; cid=&quot;n217&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;SSTable(Sorted String Table)&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n219&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;有序键值对集合，是LSM树组在磁盘中的数据结构。为了加快SSTable的读取，可以通过建立key的索引以及布隆过滤器来加快key的查找。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n230&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;我们在写入数据时，首先将对数据的修改增量保存Memtable中，同时会提交wal,当Memtable达到指定大小限制之后批量把数据刷到磁盘(SSTable)中，磁盘中树定期可以做merge操作，合并成一棵大树，以优化读性能。不过读取的时候稍微麻烦一些，读取时看这些数据在内存中，如果未能命中内存，则需要访问较多的磁盘文件。极端的说，基于LSM树实现的hbase写性能比mysql高了一个数量级，读性能却低了一个数量级。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n233&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;综上所述，LSM树会将数据的所有增、删、改等操作，记录到内存中，再顺序刷新到磁盘里，这就造成了其与B+树最大的不同，B+树会直接在数据的位置更新，而LSM树则可能追到到不同的SSTable中，当然，最新的那条记录才是准确的。这样设计的虽然大大提高了写性能，但同时也会带来一些问题：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n239&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;1）冗余存储，对于某个key，实际上除了最新的那条记录外，其他的记录都是冗余无用的，但是仍然占用了存储空间。因此需要进行Compact操作(合并多个SSTable)来清除冗余的记录。&lt;/span&gt;&lt;span md-inline=&quot;softbreak&quot;/&gt;&lt;span md-inline=&quot;plain&quot;&gt;2）读取时需要从最新的倒着查询，直到找到某个key的记录。最坏情况需要查询完所有的SSTable，这里可以通过前面提到的索引/布隆过滤器来优化查找速度。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n235&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h2 cid=&quot;n228&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;压缩(Compact)策略&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n243&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在正式介绍压缩策略以前，我们有必要先了解一下这3个基础概念，这也是以下压缩策略需要权衡的关键：&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;读放大(Read Amplifier)、写放大(Write Amplifier)、空间放大(Space Amplifier)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n268&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n258&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;读放大(Read Amplifier):是指我们要找到一个我们所需的数据，需要进行多少次磁盘的读操作。例如我们出门前需要找钥匙，你可能要每个房间，每件衣服口袋翻一遍。这并不应该是一个正常操作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n270&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;写放大(Write Amplifier):写入数据时实际写入的数据量大于真正的数据量。例如在LSM树中写入时可能触发Compact操作，导致实际写入的数据量远大于该key的数据量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n273&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;空间放大(Space Amplifier):数据实际占用的磁盘空间比数据的真正大小更多。上面提到的冗余存储，对于一个key来说，只有最新的那条记录是有效的，而之前的记录都是可以被清理回收的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n260&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h3 cid=&quot;n247&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;size-tiered 策略&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n278&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;size-tiered策略相对简单粗暴，其主旨保证每层SSTable的大小相近，同时限制每层SSTable的数量。如下图所示，每层限制SSTable为N，当每层SSTable达到N后，则触发Compact操作合并这些SSTable，并将合并后的结果写入到下一层成为一个更大的sstable。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n279&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;由此可以看出，当层数达到一定数量时，最底层的单个SSTable的大小会变得非常大。并且size-tiered策略会导致空间放大比较严重。即使对于同一层的SSTable，每个key的记录是可能存在多份的，只有当该层的SSTable执行compact操作才会消除这些key的冗余记录。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n281&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4848851269649335&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag9pH7ewjNYafx6bribyYqa9vXuL4sapSnIsabaHF9sxpk1LrHa8aQuHckOhiaoLOsJ5ZIKteWkOMwjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;827&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n251&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n253&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h3 cid=&quot;n255&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;leveled策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.47769953051643194&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag9pH7ewjNYafx6bribyYqa9vkhawl6DR7HtInd0Jv6FpYNoicLm4Vqiamwbs4ewGeEicIzNoic9EZIpTog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;852&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n211&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n372&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;leveled策略也是采用分层的思想，每一层限制总文件的大小。但与size-tiered策略不同的是，leveled会将每一层切分成多个大小相近的SSTable。这些SSTable是这一层是&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;全局有序&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;的，这意味着一个key在每一层至多只有1条记录，不存在冗余记录。并且每层维持“&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;唯一一个&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;” Run。我们来了解一下Run这个LSM里面重要的概念，以下摘自Wiki：&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n380&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n381&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Each run contains data &lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;*sorted&lt;/span&gt;&lt;span md-inline=&quot;escape&quot;&gt;*&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; by the index key. A run can be represented on disk as a single file, or alternatively as a collection of files with &lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;*non-overlapping&lt;/span&gt;&lt;span md-inline=&quot;escape&quot;&gt;*&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; key ranges.&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p cid=&quot;n384&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;run需要满足什么条件呢？&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;第一sorted，第二non-overlapping key ranges&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n386&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag9pH7ewjNYafx6bribyYqa9vGcR99jnG5ZMvdqIq7wUo67OpB0egcoiamRliaPWrTuIMGib4wjxuzialdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2428&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n178&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;每层的大小是上一级的T（下图是10） 倍，层数越高，data越多但是也越旧.每层都有target size&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n288&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;level_targets.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3464384828862165&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag9pH7ewjNYafx6bribyYqa9v2j63ypewu4RbCF2QSiaxpX7icCiaTpCr1mDPFMZDx5EsfDmWibtN2gic4Rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2162&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n292&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n294&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;整个的过程可以简化成：in memory的table写满了，那么就flush到第一级的Disk SStable并且做compaction，要是第一级又满了，就又开始flush到第二级做compaction，以此类推直到max level, 下面几张图描述了整个过程。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n297&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n388&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;假设如下图是起始状态&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5267710049423394&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag9pH7ewjNYafx6bribyYqa9vtdfv9BMuxTvFoL3UEu1rnbjzXiaLKjbczgtUWM1fDQb7q32OXIJlerg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2428&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n394&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;level0 有数据写入，这个时候触发level0到level1的compact&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6522222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag9pH7ewjNYafx6bribyYqa9vJRK3l7wte598xqQ0ibqOZxEpjvrE17sHUvaXU36EZ0nJwu1gicsZHZEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n325&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;level1 超出限制，触发level1到level2compact&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4061111111111111&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag9pH7ewjNYafx6bribyYqa9vSP5F9VBrCQjJzbEzokWCy0UZXpRfYibkshTftQscOFQmOwexuPwg35w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n186&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;此时会从level1中选择至少一个文件，然后把它跟level2&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;em&quot;&gt;&lt;em&gt;有交集的部分(非常关键)&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;进行合并。生成的文件会放在level2&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n397&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;由于level1第二SSTable的key的范围覆盖了level2中前三个SSTable，那么就需要将level1中第二个SSTable与level2中前三个SSTable执行Compact操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4872222222222222&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag9pH7ewjNYafx6bribyYqa9v3nm2iceaQTEByIgjxUbjI4aiaN9jsrycctKSQEdSGLptDHSY1e829XKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n192&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;level2合并完成后，如果其超出了level2阈值的限制，那么会触发level2到level3的compact&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n187&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4061111111111111&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag9pH7ewjNYafx6bribyYqa9vl3umxQtzWnZArZic0Wr2UsZPSGhJMIPJBEwUG5FAvYVJlIJ8gIhYRtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4061111111111111&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag9pH7ewjNYafx6bribyYqa9vvfSXe8sbTxzAgkVGaiaxo7Uu2sU8FfezKiaWOJuN8r487tCYNYzHM1Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4061111111111111&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag9pH7ewjNYafx6bribyYqa9vicgYfACh4uhIuu0PUkldbpHj83s8nmicgjkxctPuWbSroE3VLAaaXwHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n339&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n198&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;以此类推，上一层达到阈值以后，就出触发到下一层的compact操作。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n400&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;值得一提的是，无论是同级还是不同级，不重叠的key，可以并行进行。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p cid=&quot;n316&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5144444444444445&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag9pH7ewjNYafx6bribyYqa9vwR5Z7uOqkJMx3Dvw0jDaDdEKiaYedOib9tYfpyO7g2RIz7hTvEajjIxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n166&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;简单总结，Level compaction目标就是维持每个level都保持住&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;one data sorted run&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;，所以每个level都可以和下一个level做compaction，同时很有可能会被上一个level做compaction。这样做好处就是level之间的compaction可以multithread来做（除了memory到level0），提高效率。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n306&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h2 cid=&quot;n343&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;LSM Tree vs. B+ Tree vs. Hash&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n308&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n19&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;对比三种引擎的实现：　　&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n20&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n22&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;hash存储引擎：哈希表持久化的实现，可以快速支持增删改查等随机操作，且时间复杂度为o(1)，但是不支持顺序读取扫描，对应的存储系统为k-v存储系统的实现。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n24&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;b树存储引擎是b树的持久化实现，不仅支持单条记录的增删改查操作，还支持顺序扫描，对应的存储系统就是mysql。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n26&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;lsm树存储引擎和b树存储引擎，一样支持，增删改查，也支持顺序扫描操作。LSM牺牲了读性能，提高写性能。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n112&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n113&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h2 cid=&quot;n149&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Iotdb写入流程&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n150&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;相关代码&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n151&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n153&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;org.apache.iotdb.db.engine.StorageEngine&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n154&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;负责一个 IoTDB 实例的写入和访问，管理所有的 StorageGroupProsessor。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n156&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;org.apache.iotdb.db.engine.storagegroup.StorageGroupProcessor&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n157&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;负责一个存储组一个时间分区内的数据写入和访问。管理所有分区的TsFileProcessor。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n159&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;org.apache.iotdb.db.engine.storagegroup.TsFileProcessor&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n160&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;负责一个 TsFile 文件的数据写入和访问。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0229007633587786&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag9pH7ewjNYafx6bribyYqa9vqvTIUI2CxVQVYseBTZGQjM7TvogXdwYDicZEekUkAhpia9IdZ4D3mCxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;262&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n348&quot; mdtype=&quot;paragraph&quot;&gt;这篇文章，我们先介绍到这里，下一篇文章再见。&lt;/p&gt;&lt;p cid=&quot;n350&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h1 cid=&quot;n117&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;参考链接&lt;/span&gt;&lt;/h1&gt;&lt;p cid=&quot;n136&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n119&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;http://iotdb.apache.org/zh/SystemDesign/StorageEngine/StorageEngine.html&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n121&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;http://iotdb.apache.org/zh/SystemDesign/TsFile/Format.html&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n123&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;http://iotdb.apache.org/zh/SystemDesign/StorageEngine/DataPartition.html&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n125&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://www.scylladb.com/2018/01/31/compaction-series-leveled-compaction/&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n127&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/facebook/rocksdb/wiki/Leveled-Compaction&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n129&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://www.cnblogs.com/yankang/p/11041173.html&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n131&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://zhuanlan.zhihu.com/p/181498475&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n133&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://zhuanlan.zhihu.com/p/151234708&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n137&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://zhuanlan.zhihu.com/p/112574579&lt;/span&gt;&lt;/p&gt;&lt;h1 cid=&quot;n0&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关注 【&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;麒思妙想&lt;/span&gt;&lt;span&gt;】解锁更多硬核。&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;历史文章导读&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果文章对您有那么一点点帮助，我将倍感荣幸&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;欢迎  &lt;span&gt;&lt;strong&gt;关注、在看、点赞、转发 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8uJ0ic6nAag8EItgzqIEhe3GbK3ibibrSC3kGNLaCYoEXEEEV8vatdHqibkazrs7oLJERAG1cldW9pbVmcTKvXL3fA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>