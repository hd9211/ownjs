<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3d118c2e31438a47014e34138dfd3c44</guid>
<title>精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期</title>
<link>https://toutiao.io/k/3ininot</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第324期（2020-11-11）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;双十一，买它买它买它！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_324.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;基于 Kubernetes 的云原生批量计算平台&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;对以 Transformer 为基础的序列特征提取器 (Encoder) 和自回归的序列解码器 (Decoder) 做了深度优化&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;技术雷达是 ThoughtWorks 每半年发布一次的技术趋势报告&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;这是德勤第 11 年发布技术趋势年度报告&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;个人经历&lt;/p&gt;
        
        &lt;p&gt;你知道吗？&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验总结&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;适合入门&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;深入探讨&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;基于 Swift 推出的函数响应框架&lt;/p&gt;
        
        &lt;p&gt;使用 JavaScript 来自动化 iOS&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;实践总结&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;细致讲解&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;7年工作经验，技术总监&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 451915 即可&lt;/p&gt;
        
        &lt;p&gt;坚持原创，持续分享技术，包括但不限于：分布式、微服务架构，spring cloud、Dubbo微服务框架，Java核心技术，Redis缓存、Kafka消息队列中间件等。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 450130 即可&lt;/p&gt;
        
        &lt;p&gt;一个工作10年的程序猿，分享技术干货及内心的声音。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 413084 即可&lt;/p&gt;
        
        &lt;p&gt;详解数据结构与算法&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 142771 即可&lt;/p&gt;
        
        &lt;p&gt;Web前端、服务端、小程序、App、学习资料、工具、资讯&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 125297 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=20115&amp;amp;url=http%3A%2F%2Fproduct.dangdang.com%2F29132383.html&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/book_324.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;一个技术总监的忠告&lt;/p&gt;
        
        &lt;p&gt;写作不易&lt;/p&gt;
        
        &lt;p&gt;同理心&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e4e991ca71a7b58901bdbb9c9e7748d2</guid>
<title>[推荐] Guava：拯救垃圾代码，写出优雅高效，效率提升 N 倍</title>
<link>https://toutiao.io/k/3u67plz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;最近在看一个同学代码的时候，发现代码中大量使用了 Google 开源的 Guava 核心库中的内容，让代码简单清晰了不少，故学习分享出 Guava 中我认为最实用的功能。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Guava&lt;/strong&gt; 项目是 Google 公司开源的 Java 核心库，它主要是包含一些在 Java 开发中经常使用到的功能，如&lt;strong&gt;数据校验&lt;/strong&gt;、&lt;strong&gt;不可变集合&lt;/strong&gt;、计数集合，集合增强操作、I/O、缓存、字符串操作等。并且 &lt;strong&gt;Guava&lt;/strong&gt; 广泛用于 Google 内部的 Java 项目中，也被其他公司广泛使用，甚至在新版 JDK 中直接引入了 &lt;strong&gt;Guava&lt;/strong&gt; 中的优秀类库，所以质量毋庸置疑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用方式直接 mavan 依赖引入。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;!-- https://mvnrepository.com/artifact/com.google.guava/guava --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.google.guava&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;guava&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;30.0-jre&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据校验&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据校验说来十分简单，一是&lt;strong&gt;非空判断&lt;/strong&gt;，二是&lt;strong&gt;预期值判断&lt;/strong&gt;。非空判断我想每一个 Java 开发者都很熟悉，一开始都经常和 &lt;code&gt;NullPointException&lt;/code&gt; 打交道。处理的方式我们自然是一个 &lt;code&gt;if( xx == null)&lt;/code&gt; 就能轻松解决。预期值判断也是类似，检查数据值是不是自己想要的结果即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使这么简单的操作，我们是不是还经常出错呢？而且写起来的代码总是一行判断一行异常抛出，怎么看都觉得那么优雅。还好，现在就来尝试第一次使用 Guava 吧。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;非空判断&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String param = &lt;span&gt;&quot;未读代码&quot;&lt;/span&gt;;&lt;br/&gt;String name = Preconditions.checkNotNull(param);&lt;br/&gt;System.out.println(name); &lt;span&gt;// 未读代码&lt;/span&gt;&lt;br/&gt;String param2 = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;String name2 = Preconditions.checkNotNull(param2); &lt;span&gt;// NullPointerException&lt;/span&gt;&lt;br/&gt;System.out.println(name2);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入了 Guava 后可以直接使用 &lt;code&gt;Preconditions.checkNotNull&lt;/code&gt; 进行非空判断，好处为觉得有两个，一是语义清晰代码优雅；二是你也可以自定义报错信息，这样如果参数为空，报错的信息清晰，可以直接定位到具体参数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String param2 = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;String name2 = Preconditions.checkNotNull(param2,&lt;span&gt;&quot;param2 is null&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// java.lang.NullPointerException: param2 is null&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;预期值判断&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和非空判断类似，可以比较当前值和预期值，如果不相等可以自定义报错信息抛出。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String param = &lt;span&gt;&quot;www.wdbyte.com2&quot;&lt;/span&gt;;&lt;br/&gt;String wdbyte = &lt;span&gt;&quot;www.wdbyte.com&quot;&lt;/span&gt;;&lt;br/&gt;Preconditions.checkArgument(wdbyte.equals(param), &lt;span&gt;&quot;[%s] 404 NOT FOUND&quot;&lt;/span&gt;, param);&lt;br/&gt;&lt;span&gt;// java.lang.IllegalArgumentException: [www.wdbyte.com2] 404 NOT FOUND&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;是否越界&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Preconditions&lt;/code&gt; 类还可以用来检查数组和集合的元素获取是否越界。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Guava 中快速创建ArrayList&lt;/span&gt;&lt;br/&gt;List&amp;lt;String&amp;gt; list = Lists.newArrayList(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;&quot;d&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 开始校验&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; index = Preconditions.checkElementIndex(&lt;span&gt;5&lt;/span&gt;, list.size());&lt;br/&gt;&lt;span&gt;// java.lang.IndexOutOfBoundsException: index (5) must be less than size (4)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码中快速创建 List 的方式也是 Guava 提供的，后面会详细介绍 Guava 中集合创建的超多姿势。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不可变的集合&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建不可变集合是我个人最喜欢 Guava 的一个原因，因为创建一个&lt;strong&gt;不能删除、不能修改、不能增加元素&lt;/strong&gt;的集合实在是太实用了。这样的集合你完全不用担心发生什么问题，总的来说有下面几个优点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程安全，因为不能修改任何元素，可以随意多线程使用且没有并发问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以无忧的提供给第三方使用，反正修改不了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;减少内存占用，因为不能改变，所以内部实现可以最大程度节约内存占用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以用作常量集合。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;创建方式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了那么多，那么到底怎么使用呢？赶紧撸起代码来。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 创建方式1：of&lt;/span&gt;&lt;br/&gt;ImmutableSet&amp;lt;String&amp;gt; immutableSet = ImmutableSet.of(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;immutableSet.forEach(System.out::println);&lt;br/&gt;&lt;span&gt;// a&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// b&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// c&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 创建方式2：builder&lt;/span&gt;&lt;br/&gt;ImmutableSet&amp;lt;String&amp;gt; immutableSet2 = ImmutableSet.&amp;lt;String&amp;gt;builder()&lt;br/&gt;    .add(&lt;span&gt;&quot;hello&quot;&lt;/span&gt;)&lt;br/&gt;    .add(&lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;未读代码&quot;&lt;/span&gt;))&lt;br/&gt;    .build();&lt;br/&gt;immutableSet2.forEach(System.out::println);&lt;br/&gt;&lt;span&gt;// hello&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 未读代码&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 创建方式3：从其他集合中拷贝创建&lt;/span&gt;&lt;br/&gt;ArrayList&amp;lt;String&amp;gt; arrayList = &lt;span&gt;new&lt;/span&gt; ArrayList();&lt;br/&gt;arrayList.add(&lt;span&gt;&quot;www.wdbyte.com&quot;&lt;/span&gt;);&lt;br/&gt;arrayList.add(&lt;span&gt;&quot;https&quot;&lt;/span&gt;);&lt;br/&gt;ImmutableSet&amp;lt;String&amp;gt; immutableSet3 = ImmutableSet.copyOf(arrayList);&lt;br/&gt;immutableSet3.forEach(System.out::println);&lt;br/&gt;&lt;span&gt;// www.wdbyte.com&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// https&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;都可以正常打印遍历结果，但是如果进行增删改，会直接报 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; .&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实 JDK 中也提供了一个不可变集合，可以像下面这样创建。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ArrayList&amp;lt;String&amp;gt; arrayList = &lt;span&gt;new&lt;/span&gt; ArrayList();&lt;br/&gt;arrayList.add(&lt;span&gt;&quot;www.wdbyte.com&quot;&lt;/span&gt;);&lt;br/&gt;arrayList.add(&lt;span&gt;&quot;https&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// JDK Collections 创建不可变 List&lt;/span&gt;&lt;br/&gt;List&amp;lt;String&amp;gt; list = Collections.unmodifiableList(arrayList);&lt;br/&gt;list.forEach(System.out::println);&lt;span&gt;// www.wdbyte.com https&lt;/span&gt;&lt;br/&gt;list.add(&lt;span&gt;&quot;未读代码&quot;&lt;/span&gt;); &lt;span&gt;// java.lang.UnsupportedOperationException&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;注意事项&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用 Guava 创建的不可变集合是拒绝 &lt;code&gt;null&lt;/code&gt; 值的，因为在 Google 内部调查中，95% 的情况下都不需要放入 &lt;code&gt;null&lt;/code&gt; 值。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用 JDK 提供的不可变集合创建成功后，原集合添加元素会体现在不可变集合中，而 Guava 的不可变集合不会有这个问题。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   List&amp;lt;String&amp;gt; arrayList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;   arrayList.add(&lt;span&gt;&quot;a&quot;&lt;/span&gt;);&lt;br/&gt;   arrayList.add(&lt;span&gt;&quot;b&quot;&lt;/span&gt;);&lt;br/&gt;   List&amp;lt;String&amp;gt; jdkList = Collections.unmodifiableList(arrayList);&lt;br/&gt;   ImmutableList&amp;lt;String&amp;gt; immutableList = ImmutableList.copyOf(arrayList);&lt;br/&gt;   arrayList.add(&lt;span&gt;&quot;ccc&quot;&lt;/span&gt;);&lt;br/&gt;   jdkList.forEach(System.out::println);&lt;span&gt;// result: a b ccc&lt;/span&gt;&lt;br/&gt;   System.out.println(&lt;span&gt;&quot;-------&quot;&lt;/span&gt;);&lt;br/&gt;   immutableList.forEach(System.out::println);&lt;span&gt;// result: a b&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果不可变集合的元素是引用对象，那么引用对象的属性是可以更改的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;其他不可变集合&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不可变集合除了上面演示的 &lt;code&gt;set&lt;/code&gt; 之外，还有很多不可变集合，下面是 Guava 中不可变集合和其他集合的对应关系。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;可变集合接口&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;属于JDK还是Guava&lt;/th&gt;&lt;th&gt;&lt;strong&gt;不可变版本&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Collection&lt;/td&gt;&lt;td&gt;JDK&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableCollection&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;List&lt;/td&gt;&lt;td&gt;JDK&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableList&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Set&lt;/td&gt;&lt;td&gt;JDK&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableSet&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SortedSet/NavigableSet&lt;/td&gt;&lt;td&gt;JDK&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableSortedSet&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;JDK&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableMap&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SortedMap&lt;/td&gt;&lt;td&gt;JDK&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableSortedMap&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Multiset&lt;/td&gt;&lt;td&gt;Guava&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableMultiset&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SortedMultiset&lt;/td&gt;&lt;td&gt;Guava&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableSortedMultiset&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Multimap&lt;/td&gt;&lt;td&gt;Guava&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableMultimap&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ListMultimap&lt;/td&gt;&lt;td&gt;Guava&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableListMultimap&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SetMultimap&lt;/td&gt;&lt;td&gt;Guava&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableSetMultimap&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BiMap&lt;/td&gt;&lt;td&gt;Guava&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableBiMap&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ClassToInstanceMap&lt;/td&gt;&lt;td&gt;Guava&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableClassToInstanceMap&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Table&lt;/td&gt;&lt;td&gt;Guava&lt;/td&gt;&lt;td&gt;&lt;code&gt;ImmutableTable&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;集合操作工厂&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这里只会介绍一个创建方法，但是为什么还是单独拿出来介绍了呢？看下去你就会&lt;strong&gt;大呼好用&lt;/strong&gt;。虽然 JDK 中已经提供了大量的集合相关的操作方法，用起来也是非常的方便，但是 Guava 还是增加了一些十分好用的方法，保证让你用上一次就爱不释手，&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;创建集合。&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 创建一个 ArrayList 集合&lt;/span&gt;&lt;br/&gt;List&amp;lt;String&amp;gt; list1 = Lists.newArrayList();&lt;br/&gt;&lt;span&gt;// 创建一个 ArrayList 集合，同时塞入3个数据&lt;/span&gt;&lt;br/&gt;List&amp;lt;String&amp;gt; list2 = Lists.newArrayList(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 创建一个 ArrayList 集合，容量初始化为10&lt;/span&gt;&lt;br/&gt;List&amp;lt;String&amp;gt; list3 = Lists.newArrayListWithCapacity(&lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;LinkedList&amp;lt;String&amp;gt; linkedList1 = Lists.newLinkedList();&lt;br/&gt;CopyOnWriteArrayList&amp;lt;String&amp;gt; cowArrayList = Lists.newCopyOnWriteArrayList();&lt;br/&gt;&lt;br/&gt;HashMap&amp;lt;Object, Object&amp;gt; hashMap = Maps.newHashMap();&lt;br/&gt;ConcurrentMap&amp;lt;Object, Object&amp;gt; concurrentMap = Maps.newConcurrentMap();&lt;br/&gt;TreeMap&amp;lt;Comparable, Object&amp;gt; treeMap = Maps.newTreeMap();&lt;br/&gt;&lt;br/&gt;HashSet&amp;lt;Object&amp;gt; hashSet = Sets.newHashSet();&lt;br/&gt;HashSet&amp;lt;String&amp;gt; newHashSet = Sets.newHashSet(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Guava 为每一个集合都添加了工厂方法创建方式，上面已经展示了部分集合的工厂方法创建方式。是不是十分的好用呢。而且可以在创建时直接扔进去几个元素，这个简直太赞了，再也不用一个个 &lt;code&gt;add&lt;/code&gt; 了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;集合交集并集差集&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过于简单，直接看代码和输出结果吧。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Set&amp;lt;String&amp;gt; newHashSet1 = Sets.newHashSet(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;Set&amp;lt;String&amp;gt; newHashSet2 = Sets.newHashSet(&lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;&quot;d&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 交集&lt;/span&gt;&lt;br/&gt;SetView&amp;lt;String&amp;gt; intersectionSet = Sets.intersection(newHashSet1, newHashSet2);&lt;br/&gt;System.out.println(intersectionSet); &lt;span&gt;// [b, c]&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 并集&lt;/span&gt;&lt;br/&gt;SetView&amp;lt;String&amp;gt; unionSet = Sets.union(newHashSet1, newHashSet2);&lt;br/&gt;System.out.println(unionSet); &lt;span&gt;// [a, b, c, d]&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// newHashSet1 中存在，newHashSet2 中不存在&lt;/span&gt;&lt;br/&gt;SetView&amp;lt;String&amp;gt; setView = Sets.difference(newHashSet1, newHashSet2);&lt;br/&gt;System.out.println(setView); &lt;span&gt;// [a]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;有数量的集合&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个真的太有用了，因为我们经常会需要设计可以计数的集合，或者 value 是 &lt;code&gt;List&lt;/code&gt; 的 &lt;code&gt;Map&lt;/code&gt; 集合，如果说你不太明白，看下面这段代码，是否某天夜里你也这样写过。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;统计相同元素出现的次数（下面的代码我已经尽可能精简写法了）。&lt;/p&gt;&lt;p&gt;JDK 原生写法：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   &lt;span&gt;// Java 统计相同元素出现的次数。&lt;/span&gt;&lt;br/&gt;   List&amp;lt;String&amp;gt; words = Lists.newArrayList(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;&quot;d&quot;&lt;/span&gt;, &lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;   Map&amp;lt;String, Integer&amp;gt; countMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Integer&amp;gt;();&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; (String word : words) {&lt;br/&gt;       Integer count = countMap.get(word);&lt;br/&gt;       count = (count == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;1&lt;/span&gt; : ++count;&lt;br/&gt;       countMap.put(word, count);&lt;br/&gt;   }&lt;br/&gt;   countMap.forEach((k, v) -&amp;gt; System.out.println(k + &lt;span&gt;&quot;:&quot;&lt;/span&gt; + v));&lt;br/&gt;   &lt;span&gt;/**&lt;br/&gt;    * result:&lt;br/&gt;    * a:2&lt;br/&gt;    * b:1&lt;br/&gt;    * c:2&lt;br/&gt;    * d:1&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管已经尽量优化代码，代码量还是不少的，那么在 Guava 中有什么不一样呢？在 Guava. 中主要是使用 &lt;code&gt;HashMultiset&lt;/code&gt; 类，看下面。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   ArrayList&amp;lt;String&amp;gt; arrayList = Lists.newArrayList(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;&quot;d&quot;&lt;/span&gt;, &lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;   HashMultiset&amp;lt;String&amp;gt; multiset = HashMultiset.create(arrayList);&lt;br/&gt;   multiset.elementSet().forEach(s -&amp;gt; System.out.println(s + &lt;span&gt;&quot;:&quot;&lt;/span&gt; + multiset.count(s)));&lt;br/&gt;   &lt;span&gt;/**&lt;br/&gt;    * result:&lt;br/&gt;    * a:2&lt;br/&gt;    * b:1&lt;br/&gt;    * c:2&lt;br/&gt;    * d:1&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是的，只要把元素添加进去就行了，不用在乎是否重复，最后都可以使用 &lt;code&gt;count&lt;/code&gt; 方法统计重复元素数量。看着舒服，写着优雅，&lt;code&gt;HashMultiset&lt;/code&gt; 是 Guava 中实现的 &lt;code&gt;Collection&lt;/code&gt; 类，可以轻松统计元素数量。&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;一对多，value 是 &lt;code&gt;List&lt;/code&gt; 的 &lt;code&gt;Map&lt;/code&gt; 集合。&lt;/p&gt;&lt;p&gt;假设一个场景，需要把很多动物按照种类进行分类，我相信最后你会写出类似的代码。&lt;/p&gt;&lt;p&gt;JDK 原生写法：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   HashMap&amp;lt;String, Set&amp;lt;String&amp;gt;&amp;gt; animalMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;   HashSet&amp;lt;String&amp;gt; dogSet = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();&lt;br/&gt;   dogSet.add(&lt;span&gt;&quot;旺财&quot;&lt;/span&gt;);&lt;br/&gt;   dogSet.add(&lt;span&gt;&quot;大黄&quot;&lt;/span&gt;);&lt;br/&gt;   animalMap.put(&lt;span&gt;&quot;狗&quot;&lt;/span&gt;, dogSet);&lt;br/&gt;   HashSet&amp;lt;String&amp;gt; catSet = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();&lt;br/&gt;   catSet.add(&lt;span&gt;&quot;加菲&quot;&lt;/span&gt;);&lt;br/&gt;   catSet.add(&lt;span&gt;&quot;汤姆&quot;&lt;/span&gt;);&lt;br/&gt;   animalMap.put(&lt;span&gt;&quot;猫&quot;&lt;/span&gt;, catSet);&lt;br/&gt;   System.out.println(animalMap.get(&lt;span&gt;&quot;猫&quot;&lt;/span&gt;)); &lt;span&gt;// [加菲, 汤姆]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后一行查询猫得到了猫类的 &quot;加菲&quot; 和 ”汤姆“。这个代码简直太烦做了，如果使用 Guava 呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   &lt;span&gt;// use guava&lt;/span&gt;&lt;br/&gt;   HashMultimap&amp;lt;String, String&amp;gt; multimap = HashMultimap.create();&lt;br/&gt;   multimap.put(&lt;span&gt;&quot;狗&quot;&lt;/span&gt;, &lt;span&gt;&quot;大黄&quot;&lt;/span&gt;);&lt;br/&gt;   multimap.put(&lt;span&gt;&quot;狗&quot;&lt;/span&gt;, &lt;span&gt;&quot;旺财&quot;&lt;/span&gt;);&lt;br/&gt;   multimap.put(&lt;span&gt;&quot;猫&quot;&lt;/span&gt;, &lt;span&gt;&quot;加菲&quot;&lt;/span&gt;);&lt;br/&gt;   multimap.put(&lt;span&gt;&quot;猫&quot;&lt;/span&gt;, &lt;span&gt;&quot;汤姆&quot;&lt;/span&gt;);&lt;br/&gt;   System.out.println(multimap.get(&lt;span&gt;&quot;猫&quot;&lt;/span&gt;)); &lt;span&gt;// [加菲, 汤姆]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HashMultimap 可以扔进去重复的 key 值，最后获取时可以得到所有的 value 值，可以看到输出结果和 JDK 写法上是一样的，但是代码已经无比清爽。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;字符串操作&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为开发中最长使用的数据类型，字符串操作的增强可以让开发更加高效。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;字符拼接&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 8 中其实已经内置了字符串拼接方法，但是它只是简单的拼接，没有额外操作，比如过滤掉 null 元素，去除前后空格等。先看一下 JDK 8 中字符串拼接的几种方式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// JDK 方式一&lt;/span&gt;&lt;br/&gt;ArrayList&amp;lt;String&amp;gt; list = Lists.newArrayList(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;String join = String.join(&lt;span&gt;&quot;,&quot;&lt;/span&gt;, list);&lt;br/&gt;System.out.println(join); &lt;span&gt;// a,b,c,null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// JDK 方式二&lt;/span&gt;&lt;br/&gt;String result = list.stream().collect(Collectors.joining(&lt;span&gt;&quot;,&quot;&lt;/span&gt;));&lt;br/&gt;System.out.println(result); &lt;span&gt;// a,b,c,null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// JDK 方式三&lt;/span&gt;&lt;br/&gt;StringJoiner stringJoiner = &lt;span&gt;new&lt;/span&gt; StringJoiner(&lt;span&gt;&quot;,&quot;&lt;/span&gt;);&lt;br/&gt;list.forEach(stringJoiner::add);&lt;br/&gt;System.out.println(stringJoiner.toString()); &lt;span&gt;// a,b,c,null&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到 null 值也被拼接到了字符串里，这有时候不是我们想要的，那么使用 Guava 有什么不一样呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ArrayList&amp;lt;String&amp;gt; list = Lists.newArrayList(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;String join = Joiner.on(&lt;span&gt;&quot;,&quot;&lt;/span&gt;).skipNulls().join(list);&lt;br/&gt;System.out.println(join); &lt;span&gt;// a,b,c&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;String join1 = Joiner.on(&lt;span&gt;&quot;,&quot;&lt;/span&gt;).useForNull(&lt;span&gt;&quot;空值&quot;&lt;/span&gt;).join(&lt;span&gt;&quot;旺财&quot;&lt;/span&gt;, &lt;span&gt;&quot;汤姆&quot;&lt;/span&gt;, &lt;span&gt;&quot;杰瑞&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;System.out.println(join1); &lt;span&gt;// 旺财,汤姆,杰瑞,空值&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到使用 &lt;code&gt;skipNulls()&lt;/code&gt; 可以跳过空值，使用 &lt;code&gt;useFornull(String)&lt;/code&gt; 可以为空值自定义显示文本。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;字符串分割&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 中是自带字符串分割的，我想你也一定用过，那就是 String 的 split 方法，但是这个方法有一个问题，就是如果最后一个元素为空，那么就会丢弃，奇怪的是第一个元素为空却不会丢弃，这就十分迷惑，下面通过一个例子演示这个问题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String str = &lt;span&gt;&quot;,a,,b,&quot;&lt;/span&gt;;&lt;br/&gt;String[] splitArr = str.split(&lt;span&gt;&quot;,&quot;&lt;/span&gt;);&lt;br/&gt;Arrays.stream(splitArr).forEach(System.out::println);&lt;br/&gt;System.out.println(&lt;span&gt;&quot;------&quot;&lt;/span&gt;);&lt;br/&gt;/**&lt;br/&gt; *&lt;br/&gt; * a&lt;br/&gt; * &lt;br/&gt; * b&lt;br/&gt; * ------&lt;br/&gt; */&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你也可以自己测试下，最后一个元素不是空，直接消失了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用 Guava 是怎样的操作方式呢？Guava 提供了 Splitter 类，并且有一系列的操作方式可以直观的控制分割逻辑。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String str = &lt;span&gt;&quot;,a ,,b ,&quot;&lt;/span&gt;;&lt;br/&gt;Iterable&amp;lt;String&amp;gt; split = Splitter.on(&lt;span&gt;&quot;,&quot;&lt;/span&gt;)&lt;br/&gt;    .omitEmptyStrings() &lt;span&gt;// 忽略空值&lt;/span&gt;&lt;br/&gt;    .trimResults() &lt;span&gt;// 过滤结果中的空白&lt;/span&gt;&lt;br/&gt;    .split(str);&lt;br/&gt;split.forEach(System.out::println);&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * a&lt;br/&gt; * b&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;缓存&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开发中我们可能需要使用小规模的缓存，来提高访问速度。这时引入专业的缓存中间件可能又觉得浪费。现在可以了， Guava 中提供了简单的缓存类，且可以根据预计容量、过期时间等自动过期已经添加的元素。即使这样我们也要预估好可能占用的内存空间，以防内存占用过多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在看一下在 Guava 中缓存该怎么用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testCache&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ExecutionException, InterruptedException &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    CacheLoader cacheLoader = &lt;span&gt;new&lt;/span&gt; CacheLoader&amp;lt;String, Animal&amp;gt;() {&lt;br/&gt;        &lt;span&gt;// 如果找不到元素，会调用这里&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Animal &lt;span&gt;load&lt;/span&gt;&lt;span&gt;(String s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    };&lt;br/&gt;    LoadingCache&amp;lt;String, Animal&amp;gt; loadingCache = CacheBuilder.newBuilder()&lt;br/&gt;        .maximumSize(&lt;span&gt;1000&lt;/span&gt;) &lt;span&gt;// 容量&lt;/span&gt;&lt;br/&gt;        .expireAfterWrite(&lt;span&gt;3&lt;/span&gt;, TimeUnit.SECONDS) &lt;span&gt;// 过期时间&lt;/span&gt;&lt;br/&gt;        .removalListener(&lt;span&gt;new&lt;/span&gt; MyRemovalListener()) &lt;span&gt;// 失效监听器&lt;/span&gt;&lt;br/&gt;        .build(cacheLoader); &lt;span&gt;//&lt;/span&gt;&lt;br/&gt;    loadingCache.put(&lt;span&gt;&quot;狗&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Animal(&lt;span&gt;&quot;旺财&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;    loadingCache.put(&lt;span&gt;&quot;猫&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Animal(&lt;span&gt;&quot;汤姆&quot;&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;));&lt;br/&gt;    loadingCache.put(&lt;span&gt;&quot;狼&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Animal(&lt;span&gt;&quot;灰太狼&quot;&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    loadingCache.invalidate(&lt;span&gt;&quot;猫&quot;&lt;/span&gt;); &lt;span&gt;// 手动失效&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    Animal animal = loadingCache.get(&lt;span&gt;&quot;狼&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(animal);&lt;br/&gt;    Thread.sleep(&lt;span&gt;4&lt;/span&gt; * &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;// 狼已经自动过去，获取为 null 值报错&lt;/span&gt;&lt;br/&gt;    System.out.println(loadingCache.get(&lt;span&gt;&quot;狼&quot;&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * key=猫,value=Animal{name=&#x27;汤姆&#x27;, age=3},reason=EXPLICIT&lt;br/&gt;     * Animal{name=&#x27;灰太狼&#x27;, age=4}&lt;br/&gt;     * key=狗,value=Animal{name=&#x27;旺财&#x27;, age=1},reason=EXPIRED&lt;br/&gt;     * key=狼,value=Animal{name=&#x27;灰太狼&#x27;, age=4},reason=EXPIRED&lt;br/&gt;     *&lt;br/&gt;     * com.google.common.cache.CacheLoader$InvalidCacheLoadException: CacheLoader returned null for key 狼.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 缓存移除监听器&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyRemovalListener&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;RemovalListener&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Animal&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onRemoval&lt;/span&gt;&lt;span&gt;(RemovalNotification&amp;lt;String, Animal&amp;gt; notification)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String reason = String.format(&lt;span&gt;&quot;key=%s,value=%s,reason=%s&quot;&lt;/span&gt;, notification.getKey(), notification.getValue(), notification.getCause());&lt;br/&gt;        System.out.println(reason);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer age;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Animal{&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;name=&#x27;&quot;&lt;/span&gt; + name + &lt;span&gt;&#x27;\&#x27;&#x27;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;, age=&quot;&lt;/span&gt; + age +&lt;br/&gt;            &lt;span&gt;&#x27;}&#x27;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt;&lt;span&gt;(String name, Integer age)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.age = age;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子中主要分为 CacheLoader、MyRemovalListener、LoadingCache。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CacheLoader 中重写了 &lt;code&gt;load&lt;/code&gt; 方法，这个方法会在查询缓存没有命中时被调用，我这里直接返回了 &lt;code&gt;null&lt;/code&gt;，其实这样会在没有命中时抛出 &lt;code&gt;CacheLoader returned null for key&lt;/code&gt; 异常信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MyRemovalListener 作为缓存元素失效时的监听类，在有元素缓存失效时会自动调用 &lt;code&gt;onRemoval&lt;/code&gt; 方法，这里需要注意的是这个方法是同步方法，如果这里耗时较长，会阻塞直到处理完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LoadingCache 就是缓存的主要操作对象了，常用的就是其中的 &lt;code&gt;put&lt;/code&gt; 和 &lt;code&gt;get&lt;/code&gt; 方法了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面介绍了我认为最常用的 Guava 功能，Guava 作为 Google 公司开源的 Java 开发核心库，个人觉得实用性还是很高的。引入后不仅能快速的实现一些开发中常用的功能，而且还可以让代码更加的优雅简洁。我觉得适用于每一个 Java 项目。Guava 的其他的功能你也可以自己去发现。它的 Github 地址是：https://github.com/google/guava.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;https://github.com/google/guava/wiki&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;订阅&lt;/h2&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1105f2d72fce32c238bcffed38e431fd</guid>
<title>[推荐] 网易云音乐基于 Flink + Kafka 的实时数仓建设实践</title>
<link>https://toutiao.io/k/rtixudv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6f8d185fd5a0627344cdc836c03f3721</guid>
<title>[推荐] 爱了！一个现代化的 Git CLI 客户端，一堆命令不用记了</title>
<link>https://toutiao.io/k/s3pgs9r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;span&gt;关注公众号 “&lt;/span&gt;&lt;span&gt;&lt;span&gt;转角遇到GitHub&lt;/span&gt;&lt;/span&gt;&lt;span&gt;” ，每天推荐给你优秀开源项目&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是欧盆索思（opensource），每天为你带来优秀的开源项目！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看一张动图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.290625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/lkYNiaZsfpqbfTtJ24frNJpobbiczdSTj9oD67Zl7o7Jk1yKia0KoosN5fe77camiatzBGX10WR5lR4IMErePVoWtQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天推荐的这个工具是：bit，它是构建在 git 之上的实验性现代化 git CLI，可提供令人满意的默认值和其他优点。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;命令和 flag 建议，以帮助你浏览 git 为您提供的众多选项；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bit add、bit checkout 能自动完成分支名和文件名；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动获取（fetch）和分支快速转发（fast-forwarding），减少合并冲突的可能性；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;建议与 git 别名一起使用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一些新命令，如 bit sync 等，能极大地简化了工作流程；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;来自 git-extras 的命令，例如 bit release &amp;amp; bit info；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;与 git 完全兼容，允许您在需要时回退到 git。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目地址：https://github.com/chriswalz/bit，Star 数：2.7k+。这是一个 Go 项目。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;安装&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）最简单的安装方式&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ curl -sf https://gobinaries.com/chriswalz/bit | sh; curl -sf https://gobinaries.com/chriswalz/bit/bitcomplete | sh &amp;amp;&amp;amp; &lt;span&gt;echo&lt;/span&gt; y | COMP_INSTALL=1 bitcomplete&lt;br/&gt;$ bit&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）也可以直接从这里下载&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/chriswalz/bit/releases&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）如果安装了 Go，则可以从源码编译&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;确保使用了 go module。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ go get github.com/chriswalz/bit&lt;br/&gt;$ bit&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，bit 依赖 git。所以你本地需要安装 git。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前支持如下平台：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;iTerm2 (macOS)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Terminal.app (macOS)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Command Prompt (Windows)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WSL/Windows Subsystem for Linux (Windows)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gnome-terminal (Ubuntu)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;bit 特有的命令&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、bit save [commit message]&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个新的提交。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、bit sync&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步对 origin 分支的更改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大部分时候，bit sync 相当于 &lt;code&gt;bit commit -m &quot;I can still use git commands&quot;&lt;/code&gt;, &lt;code&gt;bit pull -r origin master&lt;/code&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;bit 常见工作流&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过例子演示 bit 常见工作流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、切换分支&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ bit&lt;br/&gt;&amp;gt; bit switch example-branch&lt;br/&gt;? Branch does not exist. Do you want to create it? Yes&lt;br/&gt;Switched to a new branch &lt;span&gt;&#x27;example-branch&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、做一些改动&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ bit add *&lt;br/&gt;$ bit save &lt;span&gt;&quot;add important feature&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、做其他改动&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ bit save&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、push 改变到 origin&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ bit sync&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、一段时间后，可以再同步别人的修改&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ bit sync&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般都直接输入 bit，然后回车。接着输入会自动提示，如开始的动图。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;文末&lt;strong&gt;「阅读原文」&lt;/strong&gt;可直达项目首页。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;今天的项目大家觉得怎么样吗？如果你喜欢，请在文章底部留言、点赞或关注转发，你的支持就是我持续更新的最大动力！&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;转角遇到GitHub - 送给爱开源的你&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;258&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;258&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lkYNiaZsfpqYm0bG0MRgJIZRoicricTQsNEEbzuja1veleica9PFicSiayqmibQZzSRZBNufMjJIq2tKXpb4VK0DjbibZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;344&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Git · GitHub · GitLab · Gitee&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>299d10bffe87bf60d12659e945e29bcb</guid>
<title>[推荐] 13 张图彻底搞懂分布式系统服务注册与发现原理</title>
<link>https://toutiao.io/k/f9kkb5t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;引入服务注册与发现组件的原因&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来看一个问题，假如现在我们要做一个商城项目，作为架构师的你应该怎样设计系统的架构？你心里肯定在想：这还不容易直接照搬淘宝的架构不就行了。但在现实的创业环境中一个项目可能是九死一生，如果一开始投入巨大的人力和财力，一旦项目失败损失就很大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为一位有经验的架构师需要结合公司财力、人力投入预算等现状选择最适合眼下的架构才是王道。大型网站都是从小型网站发展而来，架构也是一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任何一个大型网站的架构都不是从一开始就一层不变的，而是随着用户量和数据量的不断增加不断迭代演进的结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在架构不断迭代演进的过程中我们会遇到很多问题，&lt;strong&gt;技术发展的本质就是不断发现问题再解决问题，解决问题又发现问题&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;单体架构&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在系统建立之初可能不会有特别多的用户，将所有的业务打成一个应用包放在tomcat容器中运行，与数据库共用一台服务器，这种架构一般称之为单体架构。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8589743589743589&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1Yy1lpDpnSgrIUzMCUAShjPozEcMOJlPM9KEZoViblj0qF7TJs70DibHFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;780&quot;/&gt;&lt;figcaption&gt;单体架构-应用和数据库共同部署&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在初期这种架构的效率非常高，根据用户的反馈可以快速迭代上线。但是随着用户量增加，一台服务的内存和CPU吃紧，很容易造成瓶颈，新的问题来了怎么解决呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;应用与数据分离&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着用户请求量增加，一台服务器的内存和CPU持续飙升，用户请求响应时间变慢。这时候可以考虑将应用与数据库拆开，各自使用一台服务器，你看问题又解决了吧。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0881542699724518&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1YoL2Pibpkhp9Wo5grIzjFXia28tSHKjqHia8W2Gh58wxBuCJdgJlNKDwHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;726&quot;/&gt;&lt;figcaption&gt;单体架构-应用和数据库分离&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;突然有一天扫地阿姨不小心碰了电线，其中一台服务器掉电了，用户所有的请求都报错，随之而来的是一系列投诉电话。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;集群部署&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单实例很容易造成单点问题，比如遇到服务器故障或者服务能力瓶颈，那怎么办？聪明的你肯定想到了，用集群呀。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8782287822878229&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1YBIgyiasm5iamgdAvJEn18AR1xPlfjcicLIPibyR1bPpYEbncPS2xibOzYVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1084&quot;/&gt;&lt;figcaption&gt;应用集群部署&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;集群部署是指将应用部署在多个服务器或者虚机上，用户通过服务均衡随机访问其中的一个实例，从而使多个实例的流量均衡，如果一个实例出现故障可以将其下线，其他实例不受影响仍然可以对外提供服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着用户数量快速增加，老板决定增加投入扩大团队规模。开发团队壮大后效率并没有得到显著的提高，以前小团队可以一周迭代上线一次，现在至少需要两到三周时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务逻辑越来越复杂，代码间耦合很严重，修改一行代码可能引入几个线上问题。架构师意识到需要进行架构重构。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;微服务架构&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当单体架构演进到一定阶段后开发测试的复杂性都会成本增加，团队规模的扩大也会使得各自工作耦合性更严重，牵一发而动全身就是这种场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单体架构遇到瓶颈了，微服务架构就横空出世了。微服务就是将之前的单体服务按照业务维度进行拆分，拆分粒度可大可小，拆分时机可以分节奏进行。最佳实践是先将一些独立的功能从单体中剥离出来抽成一个或多个微服务，这样可以保障业务的连续性和稳定性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8771929824561403&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1YvlySHf3wnCtdbvSDx4JBV4YJJuXbvrF1DXmN3hMLBcHLGvOk4zFTEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1368&quot;/&gt;&lt;figcaption&gt;微服务架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图将一个商用应用拆分为六个独立微服务。六个微服务可以使用Docker容器化进行多实例部署。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构演化到这里遇到了一个难题，如果要查询用户所有的订单，用户服务可能会依赖订单服务，用户服务如何与订单服务交互呢？订单服务有多个实例该访问哪一个？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常有几种解决办法：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）服务地址硬编码&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务的地址写死在数据库或者配置文件，通过访问DNS域名进行寻址路由。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.68561872909699&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1Yw9zpILmDibILP43qdWrBaQuOiaLV5HlRssCmaMEV2yPzHY2ksgQ6FrQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1196&quot;/&gt;&lt;figcaption&gt;服务元数据硬编码&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务B的地址硬编码在数据库或者配置文件中，服务A首先需要拿到服务B的地址，然后通过DNS服务器解析获取其中一实例的真实地址，最后可以向服务B发起请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果遇到大促活动需要对服务实例扩容，大促完需要对服务实例进行下线，运维人员要做大量的手工操作，非常容易误操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）服务动态注册与发现&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务地址硬编码还有一个非常致命的问题，如果一台实例挂了，运维人员可能不能及时感知到，导致一部分用户的请求会异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入服务注册与发现组件可以很好解决上面遇到的问题，避免过多的人工操作。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;架构演进总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在单体架构中一个应用程序就是一个服务包，包内的模块通过函数方法相互调用，模型足够简单，根本没有服务注册和发现一说。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在微服务架构中会将一个应用程序拆分为多个微服务，微服务会部署在不同的服务器、不同的容器、甚至多数据中心，微服务间要相互调用，服务注册和发现成为了一个不可或缺的组件。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务注册与发现基本原理&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务注册与发现是分为注册和发现两个关键的步骤。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;服务注册&lt;/strong&gt;：服务进程在注册中心注册自己的元数据信息。通常包括主机和端口号，有时还有身份验证信息，协议，版本号，以及运行环境的信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;服务发现&lt;/strong&gt;：客户端服务进程向注册中心发起查询，来获取服务的信息。服务发现的一个重要作用就是提供给客户端一个可用的服务列表。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务注册&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务注册有两种形式：客户端注册和代理注册。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;客户端注册&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端注册是服务自己要负责注册与注销的工作。当服务启动后注册线程向注册中心注册，当服务下线时注销自己。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.22934232715008432&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1YibU8A8rBNr7YzicTNU6vT2xhtzmDGb4yIZvU6xmK2CtRUadT3NIujl4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1186&quot;/&gt;&lt;figcaption&gt;客户端注册&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式的缺点是注册注销逻辑与服务的业务逻辑耦合在一起，如果服务使用不同语言开发，那需要适配多套服务注册逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代理注册&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代理注册由一个单独的代理服务负责注册与注销。当服务提供者启动后以某种方式通知代理服务，然后代理服务负责向注册中心发起注册工作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.32371794871794873&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1YiavZKfZPwyWXibjiaWVtQP1mb8hFXKpX5KHibMtTbvFAQV0Nc5rwknLx8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1248&quot;/&gt;&lt;figcaption&gt;代理注册&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式的缺点是多引用了一个代理服务，并且代理服务要保持高可用状态。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务发现&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务发现也分为客户端发现和代理发现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;客户端发现&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端发现是指客户端负责向注册中心查询可用服务地址，获取到所有的可用实例地址列表后客户端根据负载均衡算法选择一个实例发起请求调用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4648729446935725&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1Y604U6SEL81XhRYpuubvaB1B89eZUNHYz0wnvVGrRqFIZB8yRGRIhyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1338&quot;/&gt;&lt;figcaption&gt;客户端发现&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式非常直接，客户端可以控制负载均衡算法。但是缺点也很明显，获取实例地址、负载均衡等逻辑与服务的业务逻辑耦合在一起，如果服务发现或者负载平衡有变化，那么所有的服务都要修改重新上线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代理发现&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代理发现是指新增一个路由服务负责服务发现获取可用的实例列表，服务消费者如果需要调用服务A的一个实例可以直接将请求发往路由服务，路由服务根据配置好的负载均衡算法从可用的实例列表中选择一个实例将请求转发过去即可，如果发现实例不可用，路由服务还可以自行重试，服务消费者完全不用感知。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3880407124681934&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1YKK0I3aW4URJEb3uibncYDb70BQbRDsiasGw6WTuiaY0ARaeayY8p6xStQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1572&quot;/&gt;&lt;figcaption&gt;代理路由服务注册&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;心跳机制&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果服务有多个实例，其中一个实例出现宕机，注册中心是可以实时感知到，并且将该实例信息从列表中移出，也称为摘机。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何实现摘机？业界比较常用的方式是通过心跳检测的方式实现，心跳检测有&lt;strong&gt;主动&lt;/strong&gt;和&lt;strong&gt;被动&lt;/strong&gt;两种方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;被动检测&lt;/strong&gt;是指服务主动向注册中心发送心跳消息，时间间隔可自定义，比如配置5秒发送一次，注册中心如果在三个周期内比如说15秒内没有收到实例的心跳消息，就会将该实例从列表中移除。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5235294117647059&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1Ysqr2CSsoNpReXCmg2zFTLCMuyuibSheOibTQlDNO4mDuiapEzkAiaiaV6wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1020&quot;/&gt;&lt;figcaption&gt;心跳机制-被动检测&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图中服务A的实例2已经宕机不能主动给注册中心发送心跳消息，15秒之后注册就会将实例2移除掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主动检测&lt;/strong&gt;是注册中心主动发起，每隔几秒中会给所有列表中的服务实例发送心跳检测消息，如果多个周期内未发送成功或未收到回复就会主动移除该实例。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5185185185185185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1Y7lK6NlTicv232833icKoG9ZIrhVIeQFK8GuvML8E6nGPibjEtrpVBPNuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1026&quot;/&gt;&lt;figcaption&gt;心跳机制-主动检测&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;业界常用的服务注册与发现组件对比&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解服务注册与发现的基本原理后，如果你要在项目中使用服务注册与发现组件，当面对众多的开源组件该如何进行技术选型？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在互联网公司里，有研发实力的大公司一般会选择自研或者基于开源组件进行二次开发，但是对于中小型公司来说直接选用一款开源软件会是一个不错的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的注册与发现组件有eureka，zookeeper，consul，etcd等，由于eureka在2018年已经宣布放弃维护，这里就不再推荐使用了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.32325141776937616&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1YK9wPaIDydpE0A60bJV2GdnHRsvjZmgAibumCQjjRwdYON2GLvGaROLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1058&quot;/&gt;&lt;figcaption&gt;业界开源组件&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面结合各个维度对比一下各组件。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table data-sort=&quot;sortDisabled&quot; interlaced=&quot;disabled&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;组件&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;接口类型&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;一致性算法&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;zookeeper&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;1.功能强大，不仅仅只是服务发现；&lt;br/&gt;2.提供watcher机制可以实时获取服务提供者的状态；&lt;br/&gt;3.广泛使用，dubbo等微服务框架已支持；&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;1.没有健康检查；&lt;br/&gt;2.需要在服务中引入sdk，集成复杂度高；&lt;br/&gt;3.不支持多数据中心；&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;sdk&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;Paxos&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;consul&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;1.开箱即用，方便集成；&lt;br/&gt;2.带健康检查；&lt;br/&gt;3.支持多数据中心；&lt;br/&gt;4.提供web管理界面；&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;不能实时获取服务变换通知&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;restful/dns&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;Raft&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;etcd&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;1.开箱即用，方便集成；&lt;br/&gt;2.可配置性强&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;1.没有健康检查；&lt;br/&gt;2.需配合三方工具完成服务发现功能；&lt;br/&gt;3.不支持多数据中心；&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;restful&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;Raft&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从整体上看consul的功能更加完备和均衡。接下来以consul为例详细介绍一下。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Consul——值得推荐的服务注册与发现开源组件&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;简单认识一下Consul&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consul是HashiCorp公司推出的开源工，使用Go语言开发，具有开箱即可部署方便的特点。Consul是分布式的、高可用的、 可横向扩展的用于实现分布式系统的服务发现与配置。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Consul有哪些优势？&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;服务注册发现：Consul提供了通过DNS或者restful接口的方式来注册服务和发现服务。服务可根据实际情况自行选择。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;健康检查：Consul的Client可以提供任意数量的健康检查，既可以与给定的服务相关联，也可以与本地节点相关联。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多数据中心：Consul支持多数据中心，这意味着用户不需要担心Consul自身的高可用性问题以及多数据中心带来的扩展接入等问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Consul的架构图&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7142857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1YOIpiclpFn79C0xhaicN8eKZIhMGBIibgTxicxZm6UuBVWic4JWXuEOQ3vEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;figcaption&gt;Consul架构&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consul 实现多数据中心依赖于gossip protocol协议。这样做的目的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不需要使用服务器的地址来配置客户端；服务发现是自动完成的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;健康检查故障的工作不是放在服务器上，而是分布式的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Consul的使用场景&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consul的应用场景包括&lt;strong&gt;服务注册发现&lt;/strong&gt;、&lt;strong&gt;服务隔离&lt;/strong&gt;、&lt;strong&gt;服务配置&lt;/strong&gt;等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;服务注册发现场景&lt;/strong&gt;中consul作为注册中心，服务地址被注册到consul中以后，可以使用consul提供的dns、http接口查询，consul支持health check。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;服务隔离场景&lt;/strong&gt;中consul支持以服务为单位设置访问策略，能同时支持经典的平台和新兴的平台，支持tls证书分发，service-to-service加密。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;服务配置场景&lt;/strong&gt;中consul提供key-value数据存储功能，并且能将变动迅速地通知出去，借助Consul可以实现配置共享，需要读取配置的服务可以从Consul中读取到准确的配置信息。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>