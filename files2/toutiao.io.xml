<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>dc05c13cb0614d6cdcae7b43cb9c5e2c</guid>
<title>文末送福利｜十一长假干嘛呢？快来吧！</title>
<link>https://toutiao.io/k/8pbs9cx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;34&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ6h6x4EnYInRLic6PibFNWw4zSv28rAxcJu9dumVJF03PwHGOWxOzeJKIsydVa7UJuTo4jOjrct9NZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4180568d6f91fb3539eea4409c75a203</guid>
<title>深入浅出 Performance 工具 &amp; API</title>
<link>https://toutiao.io/k/4n7i89u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p class=&quot;js_reprint_biz_profile_description&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkxNTIwMzU5OQ==&amp;amp;mid=2247487883&amp;amp;idx=1&amp;amp;sn=32994040ecf88dbe2dca49eba8cfb7fd&amp;amp;chksm=c163e2ebf6146bfd60fde4ab8b32a4e2ebd7ce9e99cc403479cc7eab991be98539237221aa9c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;深入浅出 Performance 工具 &amp;amp; API&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;概述&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日常开发任务中，对于性能优化或多或少会接触到一些内容，可能也参照过&lt;span&gt;雅虎 35 条军规&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;进行过相关的性能优化，但是具体的优化结果以及实际的页面速度如何，我们怎么去看呢？以及出现性能问题了，我们如何通过现有工具进行定位&amp;amp;解决？也就是今天我要给大家介绍的内容主题了「Performance」，主题偏向工具介绍，主要从下面 4 个方面介绍今天的内容。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Chrome Perormance 工具使用：介绍如何使用浏览器提供的工具定位&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Performance Api 监测网页性能：介绍如何自己去做性能数据的提取&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;现存检测工具：三方性能检测工具介绍&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Performance 工具小试：通过一个小例子运用 Performance&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Chrome Performance 工具使用&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7419962335216572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASibiaquXSTMYDMmyqGuyFKvuWPf6xeQWH1Rqx1sma1XBUD9R6UX0wAP7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2124&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome 中 Performance 可以在上图中看到，主要分了几个板块&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;控制面板（Controls）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开启记录，停止记录，配置记录期间需要记录的内容。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.14015151515151514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASnKPUiaic98HfyuY1uXoZpbNHTU5Ericd00iaBV3JNCp93NM5AlcIS8gBAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2112&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作主要分了 2 个区域，操作 1 区从左到右依次是 &quot;Record/Stop&quot;、&quot;Reload&quot;和&quot;Clear&quot;，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&quot;Record/Stop&quot;：一般用于录制页面交互过程的性能变化数据，选择任意想要测试的过程，点击&quot;Record&quot;，并在测量结束之后，点击&quot;Stop&quot;，之后 Chrome 就会自动解析这段时间内抓取的数据，并生成报告。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&quot;Reload&quot;：一般用于录制首屏加载的性能变化数据，它会自动刷新整个页面，并开始记录性能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&quot;Clear&quot;：用于清除性能报告数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作 2 区可以选择报告展示内容，从左到右依次是 Screenshots、Memory、Web Vitals&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Screenshots：打开后可以在概览区看到屏幕的截图&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Memory：打开内存监控&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WebVitals&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;概览面板（Overview）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要是对页面表现行为的一个概述，区域由三个图形记录组成。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;FPS（Frames Per Second）:绿色的柱越高， FPS 值也越高。FPS 图表上方的红色小块指明了长帧(long frame)，这些可能是卡顿。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.265625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszAS3vey6xmBTFtqI6vUJLbp5B7p24WZPMTV66nncDkq5lOINh4eW4WWrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CPU(CPU Resources):这个面积图(area chart)表明了哪种事件在消耗 CPU 资源。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;NET:每种不同颜色的条代表一种资源。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每个条中的浅色部分代表等待时间（资源请求被发送到收到第一个响应字节的时间），深色部分代表文件传输时间（从收到第一个字节到这个资源完全被下载好）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;蓝色 代表 HTML 文件，黄色 代表 Script 文件，紫色 代表 Stylesheets 文件， 绿色 代表 Media 文件，灰色 代表其他资源。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;火焰图（Flame Chart）&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;火焰图（Flame Chart）: 可视化 CPU 堆栈(stack)信息记录。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从不同的角度分析框选区域 。例如：Network，Frames, Interactions, Main 等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在火焰图面板上你可能看到三根垂直的线，蓝线代表 DOMContentLoaded 事件，绿线代表渲染开始的时间( time to first paint)，红线代表 load 事件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38984375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASnkgSWZwVV6RUibAe9dib20ibSQ3piblSz4NfTHWzhautD3qKkib3uEa6SfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这里我们主要需要关注 Main，因为他是主线程的一个执行情况的监控。点开后，我们可以看当前线程里面一些任务的执行堆栈耗时，我们需要重点关注一些标红（也就是有较高耗时）的任务。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;详细信息（Detail）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当有具体事件被选择时，该面板展示这个事件的更多详细信息。如果没有事件被选择，该面板展示当前所选时间段的一些信息。详细面板支持精确到毫秒级别的分析，详细面板主要分了&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5731922398589065&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASsricNSFPAtnzXtcjOrDP1KGDicticSHx1kiaDxsJMSUaKpFL6NDoliaJGHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1134&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Summary 面板：从宏观层面概括了浏览器加载的总时间，主要记录了各个阶段的名称、占用时间、颜色信息。这里一般来说，需要着重关注的有两个：一是黄色的区域，代表脚本执行时间，另一个是紫色的渲染时间。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;颜色：蓝色 ；英文：Loading；含义：加载&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;颜色：黄色 ；英文：Scripting；含义：脚本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;颜色：紫色 ；英文：Rendering；含义：渲染&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;颜色：绿色 ；英文：Painting；含义：绘制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;颜色：深灰 ；英文：Other；含义：其他&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;颜色：浅灰 ；英文：Idle；含义：空闲&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Bottom-Up 面板：Bottom-Up 中一共三列数据&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Self Time：代表任务自身执行所消耗的时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Total Time：代表此任务及其调用的附属子任务一共消耗的时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Activity：具体的活动，部分带有 Source Map 链接，可以直接定位到花费时间的具体源码，方便我们进行定位和优化。Activity 中也有标注各自的颜色，和 Summary 中颜色是对应的。可以根据颜色快速判断是脚本执行、加载、还是渲染过程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASRh24ZzItrbYcupdyTYQ4QtkT3QGZK402dln7VWUrlUtgeY3cdcUN8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Call-Tree 面板：Bottom-Up 类似事件冒泡，Call Tree 类似事件捕获。自上而下的 Call-Tree 更符合我们的人类正常思维，可以更直观地分析浏览器对页面的 build 精确到毫秒级的情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Event-Log 面板：展示所有阶段包括 loading、javascripting、rendering、painting 中各事件的耗时情况，并提供了 filter 输入框和按钮供你快速过滤，常见的优化级别中一般用不到它。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASRh24ZzItrbYcupdyTYQ4QtkT3QGZK402dln7VWUrlUtgeY3cdcUN8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Performance Api 监测网页性能&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了浏览器为我们提供的 Performance 性能检测调试工具外，W3C 也定义了一套 Performance 标准，各个浏览器厂商基于标准提供了监控网络性能的一系列基础 Api，这些 Api 可以提供检测白屏时间、首屏时间、用户可操作的时间节点，页面总下载的时间、DNS 查询的时间、TCP 链接的时间等。我们完全可以利用这个搭建一个简易的性能监控工具，当然监控系统包含了数据采集-&amp;gt;数据存储-&amp;gt;清洗-&amp;gt;监控几个过程，不过目前我们这里简单运用一下 Performance Api 就只考虑采集阶段。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;提供的能力&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;属性篇&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;performance 的所有 Api&amp;amp;property 挂载在 window 下面的 performance 属性中，可以看到目前提供的一系列属性，关于各个属性的介绍，参照网上对 aip 的解释，有大量资料可供查询。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2703125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASC8E5WNibFrs4XSGyzib5DVXzOQVzBthECF04IymN9B6GM6HKjcnC7Pww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所展现，performance 包含三个对象，分别为&lt;strong&gt;memory、navigation、timing&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;memory：是和内存相关的，其提供对内存使用情况的描述，我们可以使用这个属性来订阅页面内存变化情况&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;jsHeapSizeLimit：堆内存大小的限制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;totalJSHeapSize：总堆内存的大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;usedJSHeapSize：已经使用的堆内存大小&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;navigation：含义是页面的来源信息，表述页面怎么跳转过来的，该对象有 2 个属性值&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;redirectCount**：**记录重定向次数，如果有重定向的话，页面通过几次重定向跳转而来，默认为 0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;type**：**页面打开的方式，默认为 0，可取值为「0：表示正常进入该页面(非刷新、非重定向)」、「1：表示通过 window.location.reload 刷新的页面」、「2：表示通过浏览器的前进、后退按钮进入的页面」、「255：表示非以上的方式进入页面的」&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;timing：提供页面加载过程中一系列关键时间点的高精度测量，它包含了网络、解析、加载等一系列的时间数据，我们监控网页性能也是基于此提供的属性。为了方便理解，从网上找了一张图片来解释关键节点的含义。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7046875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASGPMlCXtvzVn1JkYuE3vTTTN6R1KYEpk8Oh8eMajNxJ49QQ9ShYaBhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;navigationStart**：**一个页面卸载结束时的时间戳。如果没有上一个页面的话，那么该值会和 fetchStart 的值相同&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;redirectStart**:**第一个 http 重定向开始的时间戳，如果没有重定向，或者重定向到一个不同源的话，那么该值返回为 0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;redirectEnd**:**最后一个 HTTP 重定向完成时的时间戳。如果没有重定向，或者重定向到一个不同的源，该值也返回为 0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;fetchStart**:**浏览器准备好使用 http 请求抓取文档的时间(发生在检查本地缓存之前)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;domainLookupStart**:**DNS 域名查询开始的时间，如果使用了本地缓存话，或持久链接，该值则与 fetchStart 值相同&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;domainLookupEnd**:**DNS 域名查询完成的时间，如果使用了本地缓存话，或 持久链接，该值则与 fetchStart 值相同&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;connectStart**:**HTTP 开始建立连接的时间，如果是持久链接的话，该值则和 fetchStart 值相同，如果在传输层发生了错误且需要重新建立连接的话，那么在这里显示的是新建立的链接开始时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;secureConnectionStart**:**HTTPS 连接开始的时间，如果不是安全连接，则值为 0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;connectEnd：HTTP 完成建立连接的时间(完成握手)。如果是持久链接的话，该值则和 fetchStart 值相同，如果在传输层发生了错误且需要重新建立连接的话，那么在这里显示的是新建立的链接完成时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;requestStart**:**http 请求读取真实文档开始的时间，包括从本地读取缓存，链接错误重连时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;responseStart**:**开始接收到响应的时间(获取到第一个字节的那个时候)。包括从本地读取缓存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;responseEnd**：**HTTP 响应全部接收完成时的时间(获取到最后一个字节)。包括从本地读取缓存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;unloadEventStart**:**前一个网页（和当前页面同域）unload 的时间戳，如果没有前一个网页或前一个网页是不同的域的话，那么该值为 0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;unloadEventEnd**:**和 unloadEventStart 相对应，返回是前一个网页 unload 事件绑定的回调函数执行完毕的时间戳。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;domLoading**:**开始解析渲染 DOM 树的时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;domInteractive**:**完成解析 DOM 树的时间（只是 DOM 树解析完成，但是并没有开始加载网页的资源）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;domContentLoadedEventStart**：**DOM 解析完成后，网页内资源加载开始的时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;domContentLoadedEventEnd**:**DOM 解析完成后，网页内资源加载完成的时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;domComplete**:**DOM 树解析完成，且资源也准备就绪的时间。Document.readyState 变为 complete，并将抛出 readystatechange 相关事件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;loadEventStart**:**load 事件发送给文档。也即 load 回调函数开始执行的时间，如果没有绑定 load 事件，则该值为 0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;loadEventEnd**:**load 事件的回调函数执行完毕的时间，如果没有绑定 load 事件，该值为 0&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;方法篇&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34765625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASibiakEclDcfD7QDVfWwZoBick6kO1wSO2VFCia4rZ3KqY2oabA759vEuXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图，截取的图片，Performance 提供了一些，这里我主要介绍一下 now()方法和 getEntries()方法。其他的网上资料也比较多和全，可以查阅 https://juejin.cn/post/6844903801518981133#heading-54&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;now 方法：提供精度相对较高的时间计算主要有下面两个特点&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;和 JavaScript 中其他可用的时间类函数（比如&lt;code&gt;Date.now&lt;/code&gt;）不同的是，&lt;code&gt;window.performance.now()&lt;/code&gt;返回的时间戳没有被限制在一毫秒的精确度内，相反，它们以浮点数的形式表示时间，精度最高可达微秒级。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另外一个不同点是，&lt;code&gt;window.performance.now()&lt;/code&gt;是以一个恒定的速率慢慢增加的，它不会受到系统时间的影响（系统时钟可能会被手动调整或被 NTP 等软件篡改）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以用这个方法来衡量函数执行的时间，达到监控函数执行效率的效果&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;`const fun = () =&amp;gt; {&lt;br/&gt;&lt;br/&gt;// do something&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;const startExcuteTime = window.performance.now();&lt;br/&gt;&lt;br/&gt;fun();&lt;br/&gt;&lt;br/&gt;const endExcuteTime = window.performance.now();&lt;br/&gt;&lt;br/&gt;console.log(&quot;fun 函数执行了&quot; + (endExcuteTime - startExcuteTime) + &quot;毫秒.&quot;)  &lt;br/&gt;`&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;getEntries 方法：通过该方法，我们能够拿到页面所有资源请求的详细情况，这个方法返回值根据传入的参数不同会有不同。但返回值的结构都是一样的，都是一个对象数组，每个对象是对资源的请求过程的描述，在 console 调用 performance.getEntries()，可以直接看到当前页面所有资源的加载过程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszAS1zTGZI3aLNwLtSqBduuwbz7YxiaH3JHBDyh2hiaYRVMwV4vIoOC1GuHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点开数组中的元素，每个元素详细记录了资源请求关键节点的时间，所以我们完全可以利用这个来实现对资源的请求监控。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.50234375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASqTFRAvTe58mGwgaG3RvcUhOqqcdN8Q0icC0W8APLbjFMwybBiaqP1NUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多 Api 细节，可以参考司内文章&lt;span&gt;再看一次 Performance 接口&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;简单实现指标计算&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个监控系统大致可以分为这个下面阶段，我们这里就先关注一下数据的采集阶段。数据采集阶段设计到两点，一个是数据的搜集，一个是数据的上报。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.12732919254658384&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASMwgfI6pm2NY5FtNOMpmwFYZnQib63JDvOkxOJJ0Bic0EnZBFkibgzOzicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1288&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据的搜集：数据搜集依赖于 Performance Api 拿到性能数据，我们参照一定的计算指标，得到计算值的集合。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据的上报：将搜集到的数据上报到服务器，上报使用的方式也就是发送一个 http 请求， 不过目前因为监控数据采用 XHR 的请求上报，受到条件限制比较多，数据容易丢失，容易漏报，且对页面性能有一定的影响。而 sendBecan 是浏览器为了解决这些问题，它会使用户代理在有机会时异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能。这就解决了提交分析数据时的所有的问题：数据可靠，传输异步并且不会影响下一页面的加载。具体可以参考：https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是 Slardar 源码截图，可以看到他们上报监控数据优先采用的 sendBecan，降级策略为 XHR 请求。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.56328125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASDEEeMNxkcGFveaffNxkr6yLDUbnvLGm3RWgfsIL6pvHYJ5eqrY5rbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过 performance api 来实现我们经常关注的一些指标的计算和上报&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;`重定向耗时  = redirectEnd - redirectStart;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DNS 查询耗时  = domainLookupEnd - domainLookupStart;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP 链接耗时  = connectEnd - connectStart;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 请求耗时  = responseEnd - responseStart;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解析 dom 树耗时  = domComplete - domInteractive;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;白屏时间  = responseStart - navigationStart;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DOMready 时间  = domContentLoadedEventEnd - navigationStart;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;onload 时间  = loadEventEnd - navigationStart;&lt;br/&gt;`&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;现存的一些网页性能检测工具&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了前面两种方式能够检测页面性能外，还有一些三方的工具 or 平台为我们提供了检测能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是使用 LightHouse 的截图，Lighthouse 生成的不仅仅是一些性能相关的数据，他除了能给我们提供页面性能检测外，还为我们列出了一系列的优化建议，我们对网站或者页面的优化，可以参照建议一步步进行优化。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48359375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszAS9SoMcvR9GGNObic6Qk6eph0RC7Mn7uUGPgNDFsvcib5MRpfd8b4l8Hibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提供组件级别的渲染分析&lt;span&gt;React 性能测量和分析&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;span&gt;React Profiler 介绍 – React Blog&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Performance 工具小试&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学浪老师端项目代码目前跑在两个大的宿主环境中「CEF 套壳」「浏览器」，项目一期的时候，整体项目是采用的单入口多路有方式，并且来说项目的打包也没有优化，整体上呈现出&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;访问混乱（浏览器能访问 CEF 壳子内的一系列路由）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;打包混乱（出现多种重复打包，导致编译慢）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引用混乱（因为是是一套入口，很多只是在 CEF 内引用的文件，在单入口文件中引用了，导致浏览器加载了一系列不必要的静态资源）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的一系列问题，导致学浪整体页面加载速度非常的慢，后续学浪侧专门组织了一次大的重构优化，进行了项目入口的拆分&amp;amp;打包过程的的拆分，整体上现的学浪项目结构是多入口多路由，且区分宿主环境的。从目前的表现来看，页面的加载速度相对于以前提升了非常多。目前的加载时长度在我当前网络情况下 DomContentLoad 大概在 2S 左右&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.546875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszAShj5xeludLZYc8UdxZzrGyTonPsAtta1CFSDcQZJelicMVPSTNNYoRfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是否还有优化空间，将页面加载时间降得更低？我们可以通过 Performance 的 NetWork 火焰图看看到底是哪些文件的加载耗时长，延长了 DomContentLoad 触发时机。首先 DomContentLoad 事件触发影响因素有 html 下载、dom 解析、js 脚本下载&amp;amp;执行，都会影响 DomContentLoad 触发。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38671875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASSibshAkqONSKsuogUQJ8Hx6jBXibyf1CiazyAdXibIsFyKuRiaZqWicvx1hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过观察 NetWork 的情况，很明显看到 DCL 的时机，在一个 encoding.js 文件加载完成后，再触发的，而这个文件的加载时间长达 2.13s，可谓是占据了首页加载的 80%左右的时间，那么就想如何优化这个脚本的加载时长？有几种思路&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;压缩 encoding.js 使得体积减小（前提是没有压缩的情况下）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;看是否是首页强依赖文件（如果是后续依赖，可以采用异步脚本 defer or async 来解决下载阻塞了 DomContentLoad 问题）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;看是否真正有使用（最好的办法就是不用 😈，这样就完全省去了时间）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当然还有其他一系列客户端缓存、cdn 加速等一系列策略&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;找到了原因和思路，于是开始先对文件背景溯源，发现由于这个文件是为了处理一些教室内 sdk 在不同浏览器內的 pollfiy，但是目前因为通过阶段一的大包&amp;amp;入口的拆分，教室内 sdk 的相关资源不会出现在浏览器环境加载了，因此在浏览器环境内实际不再使用，godless 我们可以直接删除，看下效果。（实际看 encoding.js 文件也是没有压缩过的，如果实际文件有在用，我们可以采取使用压缩文件）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5328125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASWEPA0QCOtDIy8dHpsCBQQD9eemp1FS88WQHsyfgalZlF6bF34CZebA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5484375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASeJy0gjSWfdnXiaKQfGNt7FdsmZFjfKXsyPu32QiaSePliaKgNhDRCEtbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体上 DCL 的触发时间由 2.13s 降低为 972ms，效果还是比较明显的。通过一个很小的分析案例+很小的优化说明下 Performance 面板中相关模块的使用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要介绍了通过工具的使用来定位性能问题以及通过 Performance Api 来自己做一些指标的计算统计，目前公司内的 Sladar 已经为我们提供了比较全面的数据分析，但是对于一些定位页面性能的基础工具和基础能力的了解对于日常的工作中也是有帮助的&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[1]雅虎 35 条军规:&lt;em&gt;https://juejin.cn/post/6844903657318645767&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[2]再看一次 Performance 接口:&lt;em&gt;https://bytedance.feishu.cn/docs/doccnZoHj24ab8HVh42aQEowZGh#&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[3]React 性能测量和分析:&lt;em&gt;https://juejin.cn/post/6844903869378641933#heading-4&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[4]React Profiler 介绍 – React Blog:&lt;em&gt;https://zh-hans.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[5]React 性能测量和分析:&lt;em&gt;https://juejin.cn/post/6844903869378641933#heading-4&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[6]React Profiler 介绍 – React Blog:&lt;em&gt;https://zh-hans.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/lP9iauFI73zicqIKtS2GZJAscn2mSicDf8VE06OjPC9K6ibFHdqwh1bjnd7wia6ib70giazDoeVoxBg5ibxQl8jq8n1qsw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;p&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d8943d26063876746f16d6591cc61118</guid>
<title>在 WebRTC 应用中，通过 Capture Handle 识别共享标签页</title>
<link>https://toutiao.io/k/6n33tkn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;elementor-widget-container&quot;&gt;

&lt;p&gt;我一直不太赞同在演示的同时共享屏幕。大家进入视频会议应用程序，跟大家打招呼，然后开始分享自己在另一个标签或窗口的ppt。那你要看什么呢？ppt吗？但我更想面对观众并与其互动。确实，有些工具可以让你预览所分享的内容，但你仍然需要来回滑动每张ppt。理应采用一个更好的办法，那就是capture handle。&lt;/p&gt;



&lt;p&gt;Capture Handle是origin trial中一个用于屏幕共享（getDisplayMedia）的新的API。它可以让屏幕共享app识别，与用户选择的标签相协调。&lt;/p&gt;



&lt;p&gt;Elad Alon是一位对接webrtc.org团队的谷歌员工。他负责整理capture handle规范，并推动其通过W3C的标准化过程。&lt;/p&gt;



&lt;p&gt;在这篇文章中，Elad向我们介绍了capture handle，并列举了一些关于防止“镜室 （hall of mirrors）效应”的例子。另外他也回答了我在文章开头所说，屏幕共享时切换幻灯片的问题。capture handle也有很多其他用途。下面会对此进行详述。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://webrtc.org.cn/wp-content/uploads/2021/09/1.jpeg&quot; alt=&quot;&quot; class=&quot;wp-image-3099&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;在过去的一年里，屏幕共享逐渐成为大家生活中必不可少的一部分。其原因自然不言而喻。对于基于Web的产品，该操作通常是通过调用getDisplayMedia来实现的。一旦getDisplayMedia被调用，浏览器就会向用户展示他们自己的媒体选择器。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://webrtc.org.cn/wp-content/uploads/2021/09/2.jpeg&quot; alt=&quot;&quot; class=&quot;wp-image-3100&quot;/&gt;&lt;figcaption&gt;不同浏览器中，&lt;a href=&quot;https://webrtc.github.io/samples/src/content/getusermedia/getdisplaymedia/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;getDisplayMedia示例页面&lt;/a&gt;上的屏幕共享选择器&lt;/figcaption&gt;&lt;/figure&gt;



&lt;p&gt;目前，该API允许捕获三种不同的界面展示选项——屏幕、窗口或标签。用户拥有该选择权。（这种选择可能受到用户选择的浏览器的限制。比如Firefox还不支持标签捕捉，而Safari只提供全屏捕捉。）&lt;/p&gt;



&lt;p&gt;getDisplayMedia返回一个Promise。当用户做出选择后，Promise被解决，应用程序可以开始使用返回的MediaStream，该stream有一个视频轨道，可能还有一个音频轨道。但是，应用程序还能较容易地发现捕获界面的哪些内容呢？为什么需要应用程序这样做呢？让我们来解决这两个问题。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;识别捕获的显示界面&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;以前，应用程序只能区分屏幕/窗口/标签捕获。&lt;/p&gt;







&lt;p&gt;所以，并没有标准的方法来真正识别捕获的web应用。被捕获的标签是一个YouTube视频？还是一个演示文稿？如果是演示文稿的话，它又来自哪个应用呢？如果捕获的应用程序和被捕获的应用程序甚至不能识别对方，那么它们如何进行协作？是否应该通过嵌入二维码的方式进行&lt;a href=&quot;https://en.wikipedia.org/wiki/Steganography&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;隐写&lt;/a&gt;？&lt;/p&gt;



&lt;p&gt;输入“&lt;a href=&quot;https://github.com/wicg/capture-handle/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot; title=&quot;https://github.com/wicg/capture-handle/&quot;&gt;Capture Handle&lt;/a&gt;”。让我们看几个示例来说明Capture Handle如何工作。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;检测自我抓取&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;我们可以从最简单的Capture Handle示例讲起——一个单一标签（应用程序里预期是两个）。设想现在有一个将捕获的视频呈现给本地用户的应用程序。自我捕获会导致镜厅效应。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://webrtc.org.cn/wp-content/uploads/2021/09/3.jpeg&quot; alt=&quot;&quot; class=&quot;wp-image-3101&quot;/&gt;&lt;figcaption&gt;显示被捕获屏幕时出现的镜室效应&lt;/figcaption&gt;&lt;/figure&gt;



&lt;p&gt;如果web应用能够检测到这一点，它就可以避免将视频回放给本地用户，从而避免令人不适的这种效果。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;const TOTALLY_RANDOM_ID = “42”;  // Or actually randomize...
const ownId = TOTALLY_RANDOM_ID;

// Set the capture handle of the web application.
navigator.mediaDevices.setCaptureHandleConfig(
  { handle: ownId, permittedOrigins: [&quot;*&quot;] }
);
// ...
const stream = await navigator.mediaDevices.getDisplayMedia();
const [track] = stream.getVideoTracks();

// Check to see if the captured tab has the same handle.
const isSelfCapture =
    track.getCaptureHandle &amp;amp;&amp;amp;
    track.getCaptureHandle() &amp;amp;&amp;amp;
    track.getCaptureHandle().handle == ownId;
// Then mitigate the hall-of-mirrors as you see fit,
// e.g. hide the element using CSS.&lt;/pre&gt;



&lt;p&gt;在这种情况下，Web应用程序可以很轻易地在当前标签上设置一个ID。然后这个captureHandle().handle可以用来检查用户是否在屏幕共享选择器中选择了他们自己的标签。&lt;/p&gt;



&lt;p&gt;点击&lt;a href=&quot;https://wicg.github.io/capture-handle/demos/self_capture_detection/index.html&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;此处&lt;/a&gt;，你可以看到这个概念的完整演示。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;引导协作&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;如果一个应用程序可以识别它正在捕获的应用程序，它就可以与之协作。它们之间无论使用多传统的方法，都可以进行消息交流，并添加包括任何种类的语义。例如，一个VC应用可以远程控制幻灯片。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://webrtc.org.cn/wp-content/uploads/2021/09/4.jpeg&quot; alt=&quot;&quot; class=&quot;wp-image-3102&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;如需观看演示请点击&lt;a href=&quot;https://wicg.github.io/capture-handle/demos/remote_control/capturer.html&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;此处&lt;/a&gt;。请注意，它是由一个C++开发人员制作的，并不是一个web开发人员。TL;DR是指，被捕获的应用程序设置一个handle，而捕获的应用程序从中提取会话ID。可以想象一个名为Slides 3000的幻灯片web应用程序：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;////////////////////////////////////////
// Captured application (Slides 3000) //
////////////////////////////////////////

function getLoonySessionId() {
  ...  // Returns some ID which is meaningful using loonyAPI.
}

function onPageLoaded() {
  // Expose and add info as you like, including the origin.
  ...
  setCaptureHandleConfig({
    exposeOrigin: true,
    handle: JSON.stringify({
      description: &quot;See slides-3000.com for our API.&quot;,
      protocol: &quot;loonyAPI&quot;,
      version: &quot;1.983&quot;,
      sessionId: getLoonySessionId(),
    }),
    permittedOrigins = [&#x27;*&#x27;]
  });
  ...
}&lt;/pre&gt;



&lt;p&gt;和一个名为VC-MAX的视频通话web应用：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;////////////////////////////////////
// Capturing application (VC-MAX) //
////////////////////////////////////

async function startCapture() {
  // ...
  const stream = await navigator.mediaDevices.getDisplayMedia();
  const [track] = stream.getVideoTracks();
  if (track.getCaptureHandle) {  // Feature detection.
    // Subscribe to notifications of the capture-handle changing.
    track.oncapturehandlechange = (event) =&amp;gt; {
      onNewCaptureHandle(event.captureHandle());
    };
    // Read the current capture-handle.
    onNewCaptureHandle(track.getCaptureHandle());
  }
  ...
}

function onNewCaptureHandle(captureHandle) {
  if (captureHandle.origin == &#x27;slides-3000.com&#x27;) {
    const parsed = JSON.parse(captureHandle.handle);
    onNewSlides300Session(parsed.protocol, parsed.version, parsed.sessionId);
  }
}

function onNewSlides300Session(protocol, version, sessionId) {
  if (protocol != &quot;loonyAPI&quot; || version &amp;gt; &quot;2.02&quot;) {
    return;
  }
  // Exposes prev/next buttons to the user. When clicked, these send
  // a message to some REST API, where |sessionId| indicates that the
  // message has to be relayed to the Slides 3000 session in question.
  ExposeSlides300Controls(sessionId);
}&lt;/pre&gt;



&lt;p&gt;&lt;strong&gt;选择你自己的信令&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;capture handle可以提供识别，但并不提供通信。它并不涉及两个标签之间如何交换消息。你可以设想是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;BroadcastChannel&lt;/a&gt;，或者共享云基础设施被启用，即信令服务器（在比通常使用WebRTC情景更广泛的情况里）。所有合理的通信手段都有一个共同特点——它们要求捕获者知道被捕获的应用程序的ID，而这正是capture handle所能提供的。&lt;/p&gt;



&lt;p&gt;这为开发者实现其应用提供了方式上的灵活性。比如，如果用户打开多个幻灯片标签，多个标签是否都会被指示翻到下一张幻灯片呢？不可思议！&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;使用capture handle&lt;/strong&gt;&lt;strong&gt;优化capture&lt;/strong&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;假设有两个用户，一个用户正在和朋友分享一个1080p的预告片，提议大家一起看这部电影。另一个用户正在向同事们展示一个基本都是静态的文件。这两个用户都使用了同一种视频通话应用程序来分享另一个标签。那么在这两个capture场景中，是否应该使用相同的帧率和分辨率呢？&lt;/p&gt;



&lt;p&gt;将来，可以直接提示内容类型的机制才是主流。但作为现在的一种权宜之计，Capture Handle能帮助用户检查标签的来源是否是已知的视频服务网站、已知的生产力套装等。然后，应用程序就可以设置帧速率、分辨率属性以及&lt;a href=&quot;https://webrtc.github.io/samples/src/content/capture/video-contenthint/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;contentHint&lt;/a&gt;了。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;Capture Handle&lt;/strong&gt;&lt;strong&gt;何时能用？&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;从M92版开始，Chrome进行Capture Handle &lt;a href=&quot;https://developer.chrome.com/blog/origin-trials/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;origin trial&lt;/a&gt;。&lt;/p&gt;



&lt;p&gt;M92版和M93版相比，API有细微差别：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://webrtc.org.cn/wp-content/uploads/2021/09/5.png&quot; alt=&quot;&quot; class=&quot;wp-image-3103&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;除此之外，Chrome目前没有计划进行额外的修改。如果有，我们可以在&lt;a href=&quot;https://github.com/WICG/capture-handle/blob/main/CHANGELOG.md&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;变更日志&lt;/a&gt;中找到。然而，我们确实在计划进行一项扩展，将该API扩展到窗口级capture。&lt;/p&gt;



&lt;p&gt;Chrome浏览器正在收集公共web开发人员的支持意见，以说服其他浏览器供应商了解这一功能的重要性。&lt;/p&gt;



&lt;blockquote class=&quot;wp-block-quote&quot;&gt;&lt;p&gt;文章地址：&lt;a href=&quot;https://webrtchacks.com/capture-handle/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;https://webrtchacks.com/capture-handle/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;



&lt;blockquote class=&quot;wp-block-quote&quot;&gt;&lt;p&gt;原文作者：&lt;a href=&quot;https://www.linkedin.com/in/elad-alon/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Elad Alon&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>318b487fca4bb225e379d223788acd17</guid>
<title>独立开发变现周刊（第 22 期）：回复消息来辨别鞋子真假，年收入 20 万美金？</title>
<link>https://toutiao.io/k/x7k8vny</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MjM5OTM3NzAwNg==&amp;amp;action=getalbum&amp;amp;album_id=1857680644290478080#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1857680644290478080&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#独立开发变现周刊&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;22个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;strong&gt;&lt;span&gt;分享独立开发产品变现相关有价值的内容，每周五发布。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;1、Notion-avatar：一个生成 Notion 风格头像的在线工具&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;2、WxPusher：微信消息实时推送服务&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;3、Ch Daniel: 回复消息来辨别鞋子真假，年收入20万美金？&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;4、Anne-Laure Le Cunff: 100天发布100篇文章挑战，年收入10万美金&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;5、AI拟声: 5秒内克隆您的声音并生成任意语音内容&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;1、Notion-avatar：一个生成 Notion 风格头像的在线工具&lt;/h2&gt;&lt;p&gt;这是一个开源项目，可以在线生成Notion风格的头像，网站搭建用：Nextjs、Tailwind、Vercel。这个小工具虽然功能简单，但是很受欢迎。其实实现这个小产品更重要的是头像的素材。作者找到一位设计师，并获得了他的授权，而这些头像可以从gumroad上花$10买到，购买后可以用于任何用途。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.47333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/G4umk62oPLpYia2ckKG1Iicofps1HD99BaA3wN6QYrNlUdjDjmZmEeH2ia09rexZX6ibevGEBtV1BXzrgeiaxTo62Og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;Notion-avatar开源代码地址&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;h2&gt;2、WxPusher：微信消息实时推送服务&lt;/h2&gt;&lt;p&gt;先说下我为什么会找到这个产品？发现这个产品是因为我个人做产品的过程中，有一个需求痛点，就是想收到用户付款的通知提醒。我想找到一个可以在用户给我的产品付款后，能及时的收到付款通知，这样我就会感觉很爽~。&lt;/p&gt;&lt;p&gt;WxPusher (微信推送服务)是一个使用微信公众号作为通道的，实时信息推送平台，你可以通过调用API的方式，把信息推送到微信上，无需安装额外的软件，即可做到信息实时通知。你可以使用WxPusher来做服务器报警通知、抢课通知、抢票通知，信息更新提示等。&lt;/p&gt;&lt;p&gt;这些功能基本满足我的需求，而且是免费的，只需要在它的后台配置好Key，然后通过http请求就可以了。而且有其它语言Java、Go、Phyton、PHP的SDK。如果你也有类似我这样的需求，可以加入自己的收藏夹，以备后用。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.48333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/G4umk62oPLpYia2ckKG1Iicofps1HD99Ba9ec4deRLiaR8iaPtaW4vUbMCVGlvyUypiaSicpEb5ibA19KoTF3YWo0toaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;One more thing...&lt;/span&gt;&lt;/p&gt;&lt;p&gt;基于好奇心理，我又搜了搜相关资料，也有人有我类似的痛点，发现了一个帖子，感觉讨论还是挺有价值的，如何实现在手机通知Push上实现个人即时的消息通知呢？现有的解决方案貌似没有一个令人满意的。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;邮箱：拉取有延迟，发送不便&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Server 酱的 APP，基本残废，无法使用&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;PushOver 收费&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Slark，钉钉：太重，我只想要一个消息栏通知&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;短信接口，不想上传各种身份证户口本&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;下面评论给出的解决方案也有很多：&lt;/p&gt;&lt;section&gt;1、ifttt+telegram&lt;/section&gt;&lt;section&gt;2、mipush 自己写个空壳 app&lt;/section&gt;&lt;section&gt;3、Chrome webpush 做的一个&lt;/section&gt;&lt;section&gt;4、Pushover or Bark&lt;/section&gt;&lt;p&gt;不过这些解决方案都不是很好，要么鸡肋，要么国内使用不够友好。&lt;/p&gt;&lt;p&gt;WxPusher微信推送服务&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;手机Push个人通知讨论实现&lt;sup&gt;[3]&lt;/sup&gt;&lt;/p&gt;&lt;h2&gt;3、Ch Daniel: 回复消息来辨别鞋子真假，年收入20万美金？&lt;/h2&gt;&lt;p&gt;我叫Ch Deniel，简单来说，用户付费，我通过回复一些消息告诉用户购买的商品是真品还是假的，类似下面这样的，一年收入了20万美金。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5633333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/G4umk62oPLpYia2ckKG1Iicofps1HD99BaSgLZbzQom8g25FZSeLM6ZbZvQQyibbBmjTyVPficZwwYtiaFibv1QccTcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;这样一条消息, 从20美金到100美金不等~&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;semantics&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;20，最高的时候一条&lt;/annotation&gt;&lt;/semantics&gt;&lt;span&gt;&lt;span&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&lt;span&gt;&lt;span&gt;候&lt;/span&gt;&lt;span&gt;一&lt;/span&gt;&lt;span&gt;条&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;100，取决于商品的价格高低。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那我们是怎么做到的呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2017年的时候，我19岁，我想做个App，这个App很简单，用户只是选择品牌，然后引导用户到我的个人网站上去查看辨别真假指导手册。&lt;/p&gt;&lt;p&gt;这样的App+website组合，然后将这个产品发布在了Reddit上，不断的有新用户来浏览，用户数不断的增长5,000、10,000、40,000、300,000&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5633333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/G4umk62oPLpYia2ckKG1Iicofps1HD99BaLLchBm64pQRjJVOEDsU3TtgtTegXXlyuwxiavxFjAXYMkCZmXeHGicVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;到350,000用户的用户的时候，每天都会收到3~10封邮件，让我帮他们鉴定产品真假，一开始我还是免费回复，后来觉得我需要通过向用户收取一定的费用，来安排用户优先级，并验证这样模式是否可持续的。并叫了我15岁的弟弟过来帮忙。&lt;/p&gt;&lt;p&gt;后来就在指导手册上加上了Stripe的付款链接，就不断的有收到付款。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5633333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/G4umk62oPLpYia2ckKG1Iicofps1HD99BaB2HNhN33xkZSlZEgeiazLJgxcL1vzGgSskTvYrAHUiaL6kOOf5wDu4vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;为的看起来更像一个产品，做了现在的网站 legitcheck.app&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4166666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/G4umk62oPLpYia2ckKG1Iicofps1HD99Ba82LUpFjeicxWvibcLfOPG5jVibBpc0cWdzXeYTkOay9fwtdef1fj2RObw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们是如何获取流量并保持增长的呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我们每个月有30 -40万独立用户。&lt;/p&gt;&lt;p&gt;我很幸运做了下面的事情。&lt;/p&gt;&lt;p&gt;1、当我什么都没做的时候，流量一直在增长。我甚至在不知道SEO的情况下就找到了一个SEO金矿&lt;/p&gt;&lt;p&gt;2、我学习了SEO，在“假vs真(物品名称)”搜索中保持排名第一的位置 3、用户对物品认证的需求不断增长&lt;/p&gt;&lt;p&gt;4、我们用它打造了一个品牌，并尽最大努力让它变得更加可信和专业&lt;/p&gt;&lt;p&gt;5、高利润率、低批量、基于时间的服务(如果需要，利润率为95%)&lt;/p&gt;&lt;p&gt;6、提供出色的客户支持，在必要的时候做正确的事情(退款)，为客户超额交付服务等等。&lt;/p&gt;&lt;p&gt;Ch Deniel和弟弟的故事&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;h2&gt;4、Anne-Laure Le Cunff: 100天发布100篇文章挑战，年收入10万美金&lt;/h2&gt;&lt;p&gt;Anne-Laure Le Cunff是一个移民的孩子，在Google工作让她觉得眼前的工作一眼就能看到底，这不是她想要的，于是辞职做开始做自己的事，那一年压力很大，因为不想让自己的妈妈失望，但还是失败了。那时Anne-Laure可以继续回大公司上班，但是内心深处知道那不是自己想要的，于是决定继续往前走。&lt;/p&gt;&lt;p&gt;Ness Labs最初在2019年9月份开始的一个订阅服务，社区功能上线是在2020年的3月份。希望能提供一个大家互相连接，共同学习提高，有共同话题的空间。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.765&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/G4umk62oPLpYia2ckKG1Iicofps1HD99BaEUhHrOHWJww43yr5LgpsL5qs4jM8R1oPic4eX9icib7PgQHtLW6cPOaEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;在2019年的时候，Anne-Laure想做一个挑战，100天写100篇文章，练习用英语写作，并将过程公开。这样既是对自己的促进，同时也吸引了很多人的关注。后来有很多的媒体、播客也开始采访Anne-Laure。&lt;/p&gt;&lt;p&gt;一开始需要调整自己的心态，觉得有压力，后面逐渐就变成了一种习惯，再后来就逐渐享受这个过程了。虽然感到害怕，但仍然追求你相信的东西。&lt;/p&gt;&lt;p&gt;Anne-Laure说：”我妈妈没有接受过正规教育，但每当她看到有人在做有趣的事情，她就会想，如果他们能做，为什么我不能?“&lt;/p&gt;&lt;p&gt;100天发布100篇文章挑战故事&lt;sup&gt;[5]&lt;/sup&gt;&lt;/p&gt;&lt;h2&gt;5、AI拟声: 5秒内克隆您的声音并生成任意语音内容&lt;/h2&gt;&lt;p&gt;借助深度学习算法，通过个人输入的语音，然后通过算法生成完全模拟某个人的声音，而且由机器合成的语音连情绪都能够完美表达出来，基本可以以假乱真。&lt;/p&gt;&lt;p&gt;MockingBird已经登上Github热榜，收获3.5K的Star.&lt;/p&gt;&lt;p&gt;MockingBird具有如下特性：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/G4umk62oPLpYia2ckKG1Iicofps1HD99Ba2I8uRGJ8rXkUAXa8FFxaP3xdhpbHmpu1wG6yZeOYRk7GFQGy4Nibiahg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;MockingBird开源项目地址&lt;sup&gt;[6]&lt;/sup&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Notion-avatar开源代码地址: https://github.com/Mayandev/notion-avatar&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;WxPusher微信推送服务: https://wxpusher.zjiecode.com/docs/#/&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;手机Push个人通知讨论实现: https://www.v2ex.com/t/529852&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Ch Deniel和弟弟的故事: https://www.simple.ink/blog/200-000-year-writing-order-messages&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;100天发布100篇文章挑战故事: https://www.indiehackers.com/post/on-publishing-100-articles-in-100-days-and-crossing-100k-arr-anne-laure-le-cunffs-story-f99d8130c9&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;MockingBird开源项目地址: https://github.com/babysor/MockingBird&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5OTM3NzAwNg==&amp;amp;mid=2649283222&amp;amp;idx=1&amp;amp;sn=0946d478eb9afeac75e0bdbef6df8949&amp;amp;chksm=bf201b9788579281980f390cac97fce54b349a03e4792ba0175e7aefd84c5e07505af4ecc314&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;（第 21 期）：辞职后做了3个产品，终于不用回去上班了&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5OTM3NzAwNg==&amp;amp;mid=2649283209&amp;amp;idx=1&amp;amp;sn=6f8863653b61f32fae5ffce1f4d60eca&amp;amp;chksm=bf201b888857929e6537475f47d3c742540e903247754cf24dbb9ad6366054f1a5bd423e8f62&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;（第 20 期）：和2个朋友做的产品以8位数美金的价格卖给了微软&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5OTM3NzAwNg==&amp;amp;mid=2649283080&amp;amp;idx=1&amp;amp;sn=e19b3a6d3951d1abd4a13ac54360b130&amp;amp;chksm=bf201b098857921fee8a38d135674b6aeaacc02ebd3bd88ceec8df48e41de7f00407495b173e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Electron实战开发课程上线&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.52&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/G4umk62oPLreAJeFqhwhr5x2CVZkgNaIjhHdL2SZTB8x8677GL0gtaYrNM0Qia7ibAeBwheB9q01RURlChwR4GibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;加入知识星球，和我一起做自己产品的独立变现&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8a6bc93f8a2c4df7e374c7a75e8260bb</guid>
<title>写给互联网工程师的 5G 书（五）：高级功能</title>
<link>https://toutiao.io/k/e3t6mny</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote&gt;&lt;p&gt;&lt;em&gt;早就想写一个系列，给互联网行业的朋友介绍一下移动通信网络，特别是5G移动通信系统，但一直没想好怎么写。最近看到ONF发布的开源书《5G Mobile Networks：A Systems Approach》，其目标读者正是互联网从业者，因此打算将全书翻译为中文，希望能让有兴趣的朋友们能够了解移动通信网络的一些基本概念、网络架构和演进方向。原文：5G Mobile Networks: A Systems Approach&lt;span&gt;[1]&lt;/span&gt;。中文版Github仓库：https://github.com/yuff100/5GSystemApproachCHN。&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;5. 高级功能（Advanced Capabilities）&lt;/h1&gt;&lt;p&gt;本章将探讨三个例子，尝试解释为什么需要解耦蜂窝网络，有什么好处。在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTgxODgwNA==&amp;amp;mid=2247484051&amp;amp;idx=1&amp;amp;sn=9128b9f0060d0c56aff2e6450fb048b5&amp;amp;chksm=fc73bf48cb04365ee1ac85932b35c2569ab1f245c04a42db9c1f9052ef69eb9aa2978a84d3e8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第三章（体系架构）&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;第三章（体系架构）&lt;/a&gt;中，我们介绍了“what is”（基于3GPP的基础知识），在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTgxODgwNA==&amp;amp;mid=2247484054&amp;amp;idx=1&amp;amp;sn=dfd8d78dea61d39d7eb5164bf8ea8bc9&amp;amp;chksm=fc73bf4dcb04365b0565b342caf24741145302e00e6094f770c3669ff93ee916d140424ac564&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第四章（RAN内部详解）&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;第四章（RAN内部详解）&lt;/a&gt;中，我们介绍了“what will be”（行业正在演进的方向），而这一章我们将介绍“what might be”（未来最终会达到的可能性）。&lt;/p&gt;&lt;h2&gt;5.1. 数据面优化（Optimized Data Plane）&lt;/h2&gt;&lt;p&gt;对功能进行拆分的原因有很多，其中最引人注目的原因之一是解耦控制和数据代码路径，从而允许对它们分别进行优化。例如，数据路径可以通过将其编程到专门的硬件中来优化。具有可编程分组转发管道的现代白盒交换机是我们可以在蜂窝网络中开发的专门硬件的一个完美例子。图25显示了拆分的第一步，包含了到目前为止我们所介绍的所有元素。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4106145251396648&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WRd8NR5h2Ssib8U2bjAA2qPjnIywXsrEkIr1y8aHYiaib8RoFWP9B08cOnHW791e8p2sJgbicK8MsD4g/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;716&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图25. 端到端解耦系统，包括移动核心网和分布式RAN。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;关于这个图表有几点需要注意。首先，该图结合了移动核心网和RAN组件，并根据主要的子系统进行组织：移动核心网、中央单元（CU）、分布式单元（DU）和无线电单元（RU）。该图还显示了这些子系统到物理位置的一种可能的映射，前两个子系统共同位于一个机房，后两个共同位于一个铁塔，当然也可以部署为其他模式。&lt;/p&gt;&lt;p&gt;其次，图中显示了移动核心网的两个用户面组件（PGW, SGW），CU的用户面组件（PDCP）也被进一步分解为一对控制/用户平面，分别表示为PGW-C/PGW-U、SGW-C/SGW-U和PDCP-C/PDCP-U。确切地说，如何实现解耦是一个实现选择问题（3GPP并没有做出指定），但其思想是将用户面组件减少到可以接收/处理/发送数据包的最小内核，并将所有与控制相关的功能都提升到控制面组件中。&lt;/p&gt;&lt;p&gt;第三，在DU和RU之间分割RAN处理流水线中的PHY（物理层）组件，PHY的细节不在本书范围之内。3GPP规范定义了PHY层元素作为一组功能的集合，其中一些可以以软件的方式有效的运行在通用处理器上，而另一些最好基于专用硬件实现（比如基于DSP实现）。这两个块功能分别映射为PHY Upper（DU的一部分）和PHY Lower（RU的一部分）。&lt;/p&gt;&lt;p&gt;第四，让人困惑的是，在图25中，PCDP-C和Control Plane（Forwarding）组成了一个单一的功能块，与RLC和MME相连。如何实现这对功能是一个实现选择（例如，可以映射为两个或多个微服务），但最终的结果是，它们是端到端路径的一部分，通过这个路径，MME可以向UE发送控制报文。注意，这意味着在控制面和用户面之间解码数据包的责任落到了RLC身上。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.394109396914446&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WRd8NR5h2Ssib8U2bjAA2qPysfNeMGnQ7lygNPFII3EORbyn1qiaojYg1ibl4boEI4bZkDEofteiaTSQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;713&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图26. 在可编程交换机中实现用户面组件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;图26展示了我们解耦这些组件的原因：这样我们就可以在交换硬件中实现用户面组件（PGW-U、SGW-U、PDCP-U）。可以使用面向可编程网络报文转发流水线定制的语言（例如P4）和独立于协议的交换架构（例如英特尔的Tofino）的组合来实现。目前一个重要的结论是，RAN和移动核心网用户面可以直接映射到SDN支持的数据面。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;延伸阅读：&lt;/span&gt;&lt;br/&gt;有关P4和可编程交换芯片的更多信息，我们推荐阅读《软件定义网络：系统方法(Software-Defined Networking: A Systems Approach)》中的白盒交换机章节&lt;span&gt;[2]&lt;/span&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;由于某些术语的冲突，在交换硬件中实现RAN和移动核心网的转发功能可能会让人感到困惑。5G将功能分成控制面和用户面，而SDN将功能分成控制面和数据面。重叠的部分来自于我们将5G用户面的实现分为基于SDN的控制和数据平面。作为一种简化，我们将Control Plane（Forwarding）和PDCP-C组合起来，称为CU-C（Central Unit - Control）。&lt;/p&gt;&lt;p&gt;最后，SDN定义的控制/数据平面分离附带了一个隐含的实现策略，即使用可伸缩和高可用的NOS（Network Operating System，网络操作系统。跟传统操作系统一样，NOS位于应用程序（控制程序）和底层硬件设备（白盒交换机）之间，为这些应用程序提供更高层次的抽象（例如，网络拓扑），同时隐藏底层硬件的实现细节。为了使讨论更加具体，我们以ONOS（Open Network Operating System，开放网络操作系统）为例，其中PGW-C、SGW-C和PDCP-C都实现为运行在ONOS之上的控制应用程序。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4772727272727273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WRd8NR5h2Ssib8U2bjAA2qPU3rwNwjBjRttTofwcXn2AzC6zEWOqZicanOER9O2xc8xfnmTYpd4jOQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;484&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图27. 控制面组件实现为运行在SDN控制器(例如，ONOS)上的控制应用程序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;图27展示了一种可能的配置，其中底层交换机以叶脊（leaf-spine）网络架构相互连接。请记住，图26所示的交换机线性拓扑只是逻辑上的，并不能将实际的硬件配置为相同的拓扑。我们使用叶脊网络的原因与构建边缘云的最终目标有关，叶脊是这种基于云的集群的原型架构。三个控制应用程序必须协同工作，基于网络实现端到端路径，这实际上是在其他能够感知网络的控制应用程序的帮助下实现的（图中以“…”表示)。我们将在下一章中介绍更多细节，但目前最重要的是，5G上层控制面组件可以实现为基于SDN的控制应用程序。&lt;/p&gt;&lt;h2&gt;5.2. 多云部署（Multi-Cloud）&lt;/h2&gt;&lt;p&gt;功能解耦的另一个结果是，不同的功能可以部署在不同的物理位置上。当我们拆分RAN时，已经看到了这一点，可以将一些功能（如PCDP和RRC）放在CU，而将其他功能（如RLC和MAC）放在DU。这样我们就可以在机房条件、电力供应、制冷条件都不太好的偏远地区使用更简单（更便宜）的硬件。&lt;/p&gt;&lt;p&gt;我们可以在多个不同的云上重复部署不同组件的过程，从而受益于已经具备了弹性和规模效益的大型数据中心。图28展示了移动核心网的多云部署。我们将用户面部署在网络边缘（例如，在网络机房），将控制面部署到中央云上，甚至可以是像谷歌或亚马逊这样的公有云。不仅可以部署MME、PCRF和HSS，还可以部署我们在前一节中解耦出来的PGW-C和SGW-C（注意，图28将之前图表中的PDCP-U重命名为CU-U，两个术语表示的是一个意思)。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.45050215208034433&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WRd8NR5h2Ssib8U2bjAA2qPppLPxD8YgKxWEVKribIHlInAbzeicu1kibNHRDO753gGgxAFohXkKvkog/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;697&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图28. 多云部署，PGW/SGW的控制组件和MME、HSS、PCRF部署在中央云中运行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这么做有什么价值？和DU/RU一样，边缘云（Edge Cloud）的资源也很有限。如果我们想要在那里腾出空间来运行新的边缘服务，那么将任何没有必要部署在本地的组件转移到资源更丰富、更大的设施中是有帮助的。如果信息分布在多个位置，就很难收集分析，因此集中化部署还有助于跨多个边缘位置收集和分析数据（对数据执行分析也可以受益于丰富的可用计算资源）。&lt;/p&gt;&lt;p&gt;另一个值得关注的原因是，它降低了任何人（不仅仅是拥有和运营RAN基础设施的公司）向客户提供移动服务的门槛。这些实体被称为MVNOs（Mobile Virtual Network Operators，移动虚拟网络运营商），运营MVNO的一个简单方法就是在你选择的云中运行你自己的移动核心网。&lt;/p&gt;&lt;p&gt;但是，最大的动机是将移动核心网的用户面组件部署在网络边缘，从而可以分流（break out）本地流量，而不必经过中心节点转发，这有可能极大的减少边缘托管服务的网络延时。我们将在第7章回到这个话题。&lt;/p&gt;&lt;h2&gt;5.3. 网络切片（Network Slicing）&lt;/h2&gt;&lt;p&gt;5G最引人注目的价值主张之一是为不同应用和客户提供不同水平服务的能力。当然，差异化是向某些用户收取更高费用的关键，但收费只是这个故事的一部分，它还必须支持广泛的具有不同需求的应用程序。例如，流媒体视频需要高的带宽，但可以容忍更大的延迟，而物联网的带宽需求很小，但有时需要极低和可预测的延迟，并需要连接&lt;em&gt;大量可伸缩（massively scalable）&lt;/em&gt;的设备。&lt;/p&gt;&lt;p&gt;支持这种差异化的机制被称为网络切片，其核心可以归结为调度，包括RAN（决定传输哪个分片）的调度，以及移动核心网（缩放微服务实例并将这些实例放置在可用的服务器上）的调度。下面从RAN开始介绍基本思想。&lt;/p&gt;&lt;p&gt;但在深入讨论细节之前，我们注意到网络切片是前面讨论的QCI（QoS Class Index，QoS类标识符）的实现。3GPP定义了一组标准的网络片，称为&lt;em&gt;SST（Standardized Slice Type，标准切片类型）&lt;/em&gt;。例如，SST 1对应移动宽带，SST 2对应超可靠低时延通信，SST 3对应海量物联网，等等。还可以用额外的切片行为扩展这个标准集，或者为每个SST定义多个切片（例如，根据优先级进一步区分客户）。&lt;/p&gt;&lt;p&gt;当然，定义所需的切片集和实现切片机制是完全不同的两码事。下面简单介绍一下如何实现切片。&lt;/p&gt;&lt;h3&gt;&lt;em&gt;RAN切片（RAN Slicing）&lt;/em&gt;&lt;/h3&gt;&lt;p&gt;我们首先回顾一下&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTgxODgwNA==&amp;amp;mid=2247484016&amp;amp;idx=1&amp;amp;sn=009a01ea6da0cf702796f97c29819b43&amp;amp;chksm=fc73bfabcb0436bd7b1eb96567cd1f9a27babd3255a3db1179eb2ae5faf204d856a11a1629b1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第2章&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;第2章&lt;/a&gt;中提到的基本调度问题。如图29所示，可以将无线电频谱抽象为一个二维RB（Resource Blocks，资源块）网格，调度程序的工作是根据来自终端的CQI反馈，决定如何把用每个用户传输队列中的可用分片填充到网格中。重申一下，OFDMA的强大之处在于它在如何执行映射方面非常灵活。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5487364620938628&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WRd8NR5h2Ssib8U2bjAA2qPeg0SYx1yrMYUVJcGvsqog9YdMTzWWw3EEXwsfuwylPkncaGtYA8Dag/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图29. 调度器为UE分配资源块。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;虽然理论上我们可以定义一个uber scheduler（指的是集合了多个参数并可以通过配置开关或切换的调度器）把几十个不同的因素都集成进来，但网络切片的关键是添加一个如图30所示的中间层，实现虚拟RB（Virtual RBs）到物理RB（Physical RBs）的映射。这种虚拟化策略在计算系统的资源分配器中很常见，可以将分配给每个用户的资源数量与实际分配的物理资源分开。这种虚拟到物理的映射是由一个通常被称为Hypervisor的层执行的，而它完全不知道每个转换会影响到哪个用户分片。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.512539184952978&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WRd8NR5h2Ssib8U2bjAA2qPwTCIBxGXs7VianibQg3TPXia0D5SGlDGHgwOg9JwQO6Sk0qNa1WsV8y4g/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;638&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图30. 无线Hypervisor将虚拟资源块映射到物理资源块。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;将虚拟RB与物理RB解耦后，可以定义多个大小不同的虚拟RB集，每个都有自己的调度器，图31给出了两个相同大小RB集的示例。将物理RB划分为两个相等分区后，与每个分区相关联的调度器就可以自由分配完全独立的虚拟RB了。例如，一个调度器可能被设计用于处理高带宽的视频流量，而另一个调度器可能被优化用于低延迟的物联网流量。或者，可用容量的一部分可以预留给高级客户或其他高优先级流量（例如公共安全），其余部分由其他人共享。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.47480916030534354&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WRd8NR5h2Ssib8U2bjAA2qPA9xkpiau593nD8kpqBRYPic4M2iaWNnSLJecxXjyYs655It2icH6Y476zg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;655&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图31. 在无线hypervisor上运行多个调度程序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;再深入一层实现细节，如图32所示，DU中的实时调度器从CU中的近实时调度器接收高级指令，DU按照这些指令&lt;em&gt;基于每个切片（on a per-slice basis）&lt;/em&gt;做出调度决策。单个RAN的切片控制程序通过在一组切片之间分配资源来负责宏观调度决策。理解这个实现细节是很重要的，因为所有这些控制决策都是由软件模块实现的，因此很容易更改或定制。在5G中这些控制模块并没有被“锁定”在底层系统中，而在4G中是被预置在eNodeB中的，很难被修改。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.0157232704402517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WRd8NR5h2Ssib8U2bjAA2qPpOhdf5ol7lviahkHkfbRNruhhTTgLcxZ1ichFqsxVzmjCrX4KKT1ibnqA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;318&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图32. 与分布式实时RAN调度器协作的集中式近实时控制应用程序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;总而言之，RAN切片的目标是通过可编程的方式创建虚拟RAN节点（基站），这些节点在相同的硬件上操作，并根据不同应用程序、服务、用户等的给定策略共享频谱资源。将RAN切片与解耦联系起来，考虑到切片之间所需的隔离级别，可以想象到有几种可能的配置。图33给出了四个例子，所有例子都假设切片共享天线和射频组件（RU）：（a）RAN切片共享RU、DU、CU-U和CU-C；（b）RAN切片共享RU和DU，但有自己的CU-U和CU-C；（c）RAN切片共享RU、CU-U和CU-C，但有自己的DU；和（d）RAN切片共享RU，但有自己的DU、CU-U和CU-C。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.49135446685878964&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WRd8NR5h2Ssib8U2bjAA2qPxNHg5zXGvMTfm6Z1tXvcnRNRTQjA6rIm2Mr9xflicicicVlKumdM2WSPQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;694&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图33. 支持切片的分布式RAN的四种可能配置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;em&gt;核心网切片（Core Slicing）&lt;/em&gt;&lt;/h3&gt;&lt;p&gt;除了对RAN进行切片，我们还需要对移动核心网进行切片。这也很容易理解，网络交换机中的QoS机制（确保每个切片能够获得承诺的带宽）和集群处理器（确保每个微服务的容器被分配了足够的CPU以保证相应切片的包转发速率）也需要满足切片的要求。&lt;/p&gt;&lt;p&gt;但是包调度和CPU调度都是底层机制，要满足切片的需求，也需要虚拟化和部署移动核心网服务的多个副本。如果将一个切片视为一个系统抽象，那么该抽象需要跟踪实现每个切片的互连微服务集合，然后指示底层包调度器为切片的数据流分配足够的网络带宽，并指示底层CPU调度器为切片的容器分配足够的计算周期。&lt;/p&gt;&lt;p&gt;例如，如果有两个网络切片（和图31、图32所示的两个调度器类似），那么就需要有两个移动核心网服务组，两组AMF，SMF，UPF等组成的微服务集合，分别处理两个切片。这两个服务组可以独立伸缩（即包含不同数量的容器实例），由它们各自的工作负载和QoS保证决定。这两个切片也可以各自做出不同的实现选择，例如，一个针对大规模物联网应用进行优化，另一个针对高带宽AR/VR应用进行优化。&lt;/p&gt;&lt;p&gt;我们还需要一个能够将给定的数据流（例如UE和某些互联网应用之间的数据）映射到合适的服务实例上的解复用功能。这是在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTgxODgwNA==&amp;amp;mid=2247484051&amp;amp;idx=1&amp;amp;sn=9128b9f0060d0c56aff2e6450fb048b5&amp;amp;chksm=fc73bf48cb04365ee1ac85932b35c2569ab1f245c04a42db9c1f9052ef69eb9aa2978a84d3e8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第3章&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;第3章&lt;/a&gt;中描述的NSSF的工作：它负责选择为给定切片的流量提供服务的实例。&lt;/p&gt;&lt;p&gt;切片和备受争议的网络QoS之间的相似之处可能会让人得出以下结论：切片不会成功，因为QoS似乎从未在大型网络中提供足够的好处，而只是引入了复杂性。但是当带宽不足时，QoS就能够提供价值，而在最后一英里链路中就有可能存在这样的情况。切片允许对蜂窝网络频谱这一相对稀缺的资源进行有效的分割，因此可能是有价值的。&lt;/p&gt;&lt;p&gt;最后，请注意，切片可以被视为在蜂窝网络上启用虚拟网络（overlay）的一种方式。互联网很早之前就开始通过使用overlay来支持创新，比如多播和内容交付网络就是以这种方式发展起来的。因此，虽然我们可能不知道切片将如何被使用，但它是促进创新的一个重要因素。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;Reference:&lt;/span&gt;&lt;br/&gt;[1] https://5g.systemsapproach.org/index.html&lt;br/&gt;[2] https://sdn.systemsapproach.org/switch.html&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。&lt;br/&gt;微信公众号：DeepNoMind&lt;/p&gt;&lt;/blockquote&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>