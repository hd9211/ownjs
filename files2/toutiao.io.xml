<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>74ac97a80f1c58ba45a80842d2e3896a</guid>
<title>MySQL 索引连环 18 问</title>
<link>https://toutiao.io/k/x7420rp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-topic-des nc-post-content&quot;&gt;
&lt;p&gt;MySQL作为互联网中非常热门的数据库，现在大厂面试题横竖绕不开MySQL，其中MySQL索引是大厂必考面试题。今天带来了MySQL索引的常考面试题，看看你能答对多少~ &lt;/p&gt; 
&lt;p&gt;这是本期的MySQL索引面试题目录，不会的快快查漏补缺~&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;目录&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752025/image-20210411230042052.png&quot;/&gt;&lt;/p&gt; 
&lt;h2&gt;1. 索引是什么？&lt;/h2&gt; 
&lt;p&gt;索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;索引是一种数据结构。数据库索引，是数据库管理系统中一个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。而且索引是一个文件，它是要占据物理空间的。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。比如我们在查字典的时候，前面都有检索的拼音和偏旁、笔画等，然后找到对应字典页码，这样然后就打开字典的页数就可以知道我们要搜索的某一个key的全部值的信息了。&lt;/p&gt; 
&lt;h2&gt;2. 索引有哪些优缺点？&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;索引的优点&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 &lt;/li&gt;
 &lt;li&gt;通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;索引的缺点&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率； &lt;/li&gt;
 &lt;li&gt;空间方面：索引需要占物理空间。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;3. MySQL有哪几种索引类型？&lt;/h2&gt; 
&lt;p&gt;1、从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式，&lt;/p&gt; 
&lt;p&gt;2、从应用层次来分：普通索引，唯一索引，复合索引。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;普通索引：即一个索引只包含单个列，一个表可以有多个单列索引&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;唯一索引：索引列的值必须唯一，但允许有空值&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;非聚簇索引： 不是聚簇索引，就是非聚簇索引&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;3、根据中数据的物理顺序与键值的逻辑（索引）顺序关系： 聚集索引，非聚集索引。&lt;/p&gt; 
&lt;h2&gt;4. 说一说索引的底层实现？&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;Hash索引&lt;/strong&gt; &lt;/p&gt; 
&lt;p&gt;&lt;span&gt;基于&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;哈希表&lt;/a&gt;实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;图片来源：&lt;a href=&quot;https://www.javazhiyin.com/40232.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://www.javazhiyin.com/40232.html&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752261/image-20210411215012443.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;B-Tree索引&lt;/strong&gt;（MySQL使用B+Tree）&lt;/p&gt; 
&lt;p&gt;B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752112/image-20210411215023820.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;B+Tree索引&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。&lt;/p&gt; 
&lt;p&gt;B+tree性质：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;B+ 树中，数据对象的插入和删除仅在叶节点上进行。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752195/image-20210411215044332.png&quot;/&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span&gt;5. 为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E4%BA%8C%E5%8F%89%E6%A0%91&quot; target=&quot;_blank&quot;&gt;二叉树&lt;/a&gt;，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;？&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;B-tree： 从两个方面来回答&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B(B-)树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对&lt;code&gt;IO读写次数就降低&lt;/code&gt;了。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在&lt;code&gt;区间查询&lt;/code&gt;的情况，所以通常B+树用于数据库索引。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;Hash： &lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;虽然可以快速定位，但是没有顺序，IO复杂度高；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;基于Hash表实现，只有Memory存储引擎显式支持哈希索引 ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;适合&lt;strong&gt;等值查询&lt;/strong&gt;，如=、in()、&amp;lt;=&amp;gt;，不支持范围查询 ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;因为不是按照索引值顺序存储的，就不能像B+Tree索引一样利用索引完成&lt;a target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;排序&lt;/a&gt; ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;Hash索引在查询等值时非常快 ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;因为Hash索引始终索引的&lt;strong&gt;所有列的全部内容&lt;/strong&gt;，所以不支持部分索引列的匹配查找 ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题 。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E4%BA%8C%E5%8F%89%E6%A0%91&quot; target=&quot;_blank&quot;&gt;二叉树&lt;/a&gt;： 树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;： 树的高度随着数据量增加而增加，IO代价高。&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;6. 讲一讲聚簇索引与非聚簇索引？&lt;/h2&gt; 
&lt;p&gt;在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引，即将数据存储与索引放到了一块，找到索引也就找到了数据。&lt;/p&gt; 
&lt;p&gt;而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引、二级索引。&lt;/p&gt; 
&lt;p&gt;聚簇索引与非聚簇索引的区别：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键（行号） &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;对于InnoDB来说，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为&lt;strong&gt;回表&lt;/strong&gt;。第一次索引一般是顺序IO，回表的操作属于随机IO。需要回表的次数越多，即随机IO次数越多，我们就越倾向于使用全表扫描 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;通常情况下， 主键索引（聚簇索引）查询只会查一次，而非主键索引（非聚簇索引）需要回表查询多次。当然，如果是覆盖索引的话，查一次即可 &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;注意：MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;7. 非聚簇索引一定会回表查询吗？&lt;/h2&gt; 
&lt;p&gt;不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。一个索引包含（覆盖）所有需要查询字段的值，被称之为&quot;覆盖索引&quot;。&lt;/p&gt; 
&lt;p&gt;举个简单的例子，假设我们在学生表的成绩上建立了索引，那么当进行&lt;code&gt;select score from student where score &amp;gt; 90&lt;/code&gt;的查询时，在索引的叶子节点上，已经包含了score 信息，不会再次进行回表查询。&lt;/p&gt; 
&lt;h2&gt;8. 联合索引是什么？为什么需要注意联合索引中的顺序？&lt;/h2&gt; 
&lt;p&gt;MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。&lt;/p&gt; 
&lt;p&gt;具体原因为:&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;MySQL使用索引时需要索引有序，假设现在建立了&quot;name，age，school&quot;的联合索引，那么索引的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;为: 先按照name&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;，如果name相同，则按照age&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;，如果age的值也相等，则按照school进行&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。&lt;/p&gt; 
&lt;h2&gt;9. 讲一讲MySQL的最左前缀原则?&lt;/h2&gt; 
&lt;p&gt;最左前缀原则就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。&lt;br/&gt;mysql会一直向右匹配直到遇到范围查询(&amp;gt;、&amp;lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &amp;gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。&lt;/p&gt; 
&lt;p&gt;=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。&lt;/p&gt; 
&lt;h2&gt;10. 讲一讲前缀索引？&lt;/h2&gt; 
&lt;p&gt;因为可能我们索引的字段非常长，这既占内存空间，也不利于维护。所以我们就想，如果只把很长字段的前面的公共部分作为一个索引，就会产生超级加倍的效果。但是，我们需要注意，order by不支持前缀索引 。&lt;/p&gt; 
&lt;p&gt; 流程是： &lt;/p&gt; 
&lt;p&gt; 先计算完整列的选择性 :&lt;code&gt;select count(distinct col_1)/count(1) from table_1&lt;/code&gt;&lt;/p&gt; 
&lt;p&gt; 再计算不同前缀长度的选择性 :&lt;code&gt;select count(distinct left(col_1,4))/count(1) from table_1&lt;/code&gt;&lt;/p&gt; 
&lt;p&gt; 找到最优长度之后，创建前缀索引 :&lt;code&gt;create index idx_front on table_1 (col_1(4))&lt;/code&gt;&lt;/p&gt; 
&lt;h2&gt;11. 了解索引下推吗？&lt;/h2&gt; 
&lt;p&gt;MySQL 5.6引入了索引下推优化。默认开启，使用SET optimizer_switch = ‘index_condition_pushdown=off’;可以将其关闭。 &lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;有了索引下推优化，可以在&lt;strong&gt;减少回表次数&lt;/strong&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;在InnoDB中只针对二级索引有效&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;官方文档中给的例子和解释如下：&lt;/p&gt; 
&lt;p&gt;在 people_table中有一个二级索引(zipcode，lastname，address)，查询是SELECT * FROM people WHERE zipcode=’95054′ AND lastname LIKE ‘%etrunia%’ AND address LIKE ‘%Main Street%’; &lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;如果没有使用索引下推技术，则MySQL会通过zipcode=’95054’从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’来判断数据是否符合条件 &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;如果使用了索引下推技术，则MYSQL首先会返回符合zipcode=’95054’的索引，然后根据lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;12. 怎么查看MySQL语句有没有用到索引？&lt;/h2&gt; 
&lt;p&gt;通过explain，如以下例子：&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&#x27;10001&#x27; AND title=&#x27;Senior Engineer&#x27; AND from_date=&#x27;1986-06-26&#x27;;&lt;/code&gt;&lt;/p&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th&gt;id&lt;/th&gt; 
   &lt;th&gt;select_type&lt;/th&gt; 
   &lt;th&gt;table&lt;/th&gt; 
   &lt;th&gt;partitions&lt;/th&gt; 
   &lt;th&gt;type&lt;/th&gt; 
   &lt;th&gt;possible_keys&lt;/th&gt; 
   &lt;th&gt;key&lt;/th&gt; 
   &lt;th&gt;key_len&lt;/th&gt; 
   &lt;th&gt;ref&lt;/th&gt; 
   &lt;th&gt;filtered&lt;/th&gt; 
   &lt;th&gt;rows&lt;/th&gt; 
   &lt;th&gt;Extra&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt;
  &lt;tr&gt; 
   &lt;td&gt;1&lt;/td&gt; 
   &lt;td&gt;SIMPLE&lt;/td&gt; 
   &lt;td&gt;titles&lt;/td&gt; 
   &lt;td&gt;null&lt;/td&gt; 
   &lt;td&gt;const&lt;/td&gt; 
   &lt;td&gt;PRIMARY&lt;/td&gt; 
   &lt;td&gt;PRIMARY&lt;/td&gt; 
   &lt;td&gt;59&lt;/td&gt; 
   &lt;td&gt;const,const,const&lt;/td&gt; 
   &lt;td&gt;10&lt;/td&gt; 
   &lt;td&gt;1&lt;/td&gt; 
   &lt;td/&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt;
&lt;/table&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;id：在⼀个⼤的查询语句中每个&lt;strong&gt;SELECT&lt;/strong&gt;关键字都对应⼀个唯⼀的id ，如explain select * from s1 where id = (select id from s1 where name = &#x27;egon1&#x27;);第一个select的id是1，第二个select的id是2。有时候会出现两个select，但是id却都是1，这是因为优化器把子查询变成了连接查询 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;select_type：select关键字对应的那个查询的类型，如SIMPLE,PRIMARY,SUBQUERY,DEPENDENT,SNION 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;table：每个查询对应的表名 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;type：&lt;code&gt;type&lt;/code&gt; 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 &lt;code&gt;type&lt;/code&gt; 字段, 我们判断此次查询是 &lt;code&gt;全表扫描&lt;/code&gt; 还是 &lt;code&gt;索引扫描&lt;/code&gt; 等。如const(主键索引或者唯一二级索引进行等值匹配的情况下),ref(普通的⼆级索引列与常量进⾏等值匹配),index(扫描全表索引的覆盖索引) 。&lt;/p&gt; &lt;p&gt;通常来说, 不同的 type 类型的性能关系如下:&lt;br/&gt;&lt;code&gt;ALL &amp;lt; index &amp;lt; range ~ index_merge &amp;lt; ref &amp;lt; eq_ref &amp;lt; const &amp;lt; system&lt;/code&gt;&lt;br/&gt;&lt;code&gt;ALL&lt;/code&gt; 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.&lt;br/&gt;而 &lt;code&gt;index&lt;/code&gt; 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;possible_key：查询中可能用到的索引&lt;em&gt;(可以把用不到的删掉，降低优化器的优化时间)&lt;/em&gt; 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;key：此字段是 MySQL 在当前查询时所真正使用到的索引。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;filtered：查询器预测满足下一次查询条件的百分比 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.&lt;br/&gt;这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;extra：表示额外信息，如Using where,Start temporary,End temporary,Using temporary等。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;13. 为什么官方建议使用自增长主键作为索引？&lt;/h2&gt; 
&lt;p&gt;结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。&lt;/p&gt; 
&lt;p&gt;插入连续的数据：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;图片来自：&lt;a href=&quot;https://www.javazhiyin.com/40232.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://www.javazhiyin.com/40232.html&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752160/java10-1562726251.gif&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;插入非连续的数据：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752674/java8-1562726251.gif&quot;/&gt;&lt;/p&gt; 
&lt;h2&gt;14. 如何创建索引？&lt;/h2&gt; 
&lt;p&gt;创建索引有三种方式。&lt;/p&gt; 
&lt;p&gt;1、 在执行CREATE TABLE时创建索引&lt;/p&gt; 
&lt;pre class=&quot;prettyprint lang-sql&quot; from-niu=&quot;default&quot;&gt;CREATE TABLE user_index2 (
    id INT auto_increment PRIMARY KEY,
    first_name VARCHAR (16),
    last_name VARCHAR (16),
    id_card VARCHAR (18),
    information text,
    KEY name (first_name, last_name),
    FULLTEXT KEY (information),
    UNIQUE KEY (id_card)
);
&lt;/pre&gt; 
&lt;p&gt;2、 使用ALTER TABLE命令去增加索引。&lt;/p&gt; 
&lt;pre class=&quot;prettyprint lang-sql&quot; from-niu=&quot;default&quot;&gt;ALTER TABLE table_name ADD INDEX index_name (column_list);&lt;/pre&gt; 
&lt;p&gt;ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。&lt;/p&gt; 
&lt;p&gt;其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。&lt;/p&gt; 
&lt;p&gt;索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。&lt;br/&gt;3、 使用CREATE INDEX命令创建。&lt;/p&gt; 
&lt;pre class=&quot;prettyprint lang-sql&quot; from-niu=&quot;default&quot;&gt;CREATE INDEX index_name ON table_name (column_list);&lt;/pre&gt; 
&lt;h2&gt;15. 创建索引时需要注意什么？&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值； &lt;/li&gt;
 &lt;li&gt;取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高； &lt;/li&gt;
 &lt;li&gt;索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;16. 建索引的原则有哪些？&lt;/h2&gt; 
&lt;p&gt;1、最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&amp;gt;、&amp;lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &amp;gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。&lt;/p&gt; 
&lt;p&gt;2、=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。&lt;/p&gt; 
&lt;p&gt;3、尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。&lt;/p&gt; 
&lt;p&gt;4、索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。&lt;/p&gt; 
&lt;p&gt;5、尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。&lt;/p&gt; 
&lt;h2&gt;17. 使用索引查询一定能提高查询的性能吗？&lt;/h2&gt; 
&lt;p&gt;通常通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。&lt;/p&gt; 
&lt;p&gt;索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的I* NSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;基于一个范围的检索，一般查询返回结果集小于表中记录数的30%。 &lt;/li&gt;
 &lt;li&gt;基于非唯一性索引的检索。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;18. 什么情况下不走索引（索引失效）？&lt;/h2&gt; 
&lt;h5&gt;1、使用!= 或者 &amp;lt;&amp;gt; 导致索引失效&lt;/h5&gt; 
&lt;h5&gt;2、类型不一致导致的索引失效&lt;/h5&gt; 
&lt;h5&gt;3、函数导致的索引失效&lt;/h5&gt; 
&lt;p&gt;如：&lt;/p&gt; 
&lt;pre class=&quot;prettyprint&quot; from-niu=&quot;default&quot;&gt;SELECT * FROM `user` WHERE DATE(create_time) = &#x27;2020-09-03&#x27;;&lt;/pre&gt;
&lt;p&gt;如果你的索引字段使用了函数，对不起，他是真的不走索引的。&lt;/p&gt; 
&lt;h5&gt;4、运算符导致的索引失效&lt;/h5&gt; 
&lt;pre class=&quot;prettyprint&quot; from-niu=&quot;default&quot;&gt;SELECT * FROM `user` WHERE age - 1 = 20;&lt;/pre&gt;
&lt;p&gt;如果你对列进行了（+，-，*，/，!）, 那么都将不会走索引。&lt;/p&gt; 
&lt;h5&gt;5、OR引起的索引失效&lt;/h5&gt; 
&lt;pre class=&quot;prettyprint&quot; from-niu=&quot;default&quot;&gt;SELECT * FROM `user` WHERE `name` = &#x27;张三&#x27; OR height = &#x27;175&#x27;;&lt;/pre&gt;
&lt;p&gt;OR导致索引是在特定情况下的，并不是所有的OR都是使索引失效，如果OR连接的是同一个字段，那么索引不会失效，反之索引失效。&lt;/p&gt; 
&lt;h5&gt;6、模糊搜索导致的索引失效&lt;/h5&gt; 
&lt;pre class=&quot;prettyprint&quot; from-niu=&quot;default&quot;&gt;SELECT * FROM `user` WHERE `name` LIKE &#x27;%冰&#x27;;&lt;/pre&gt;
&lt;p&gt;当&lt;code&gt;%&lt;/code&gt;放在匹配字段前是不走索引的，放在后面才会走索引。&lt;/p&gt; 
&lt;h5&gt;7、NOT IN、NOT EXISTS导致索引失效&lt;/h5&gt; 
&lt;h2 id=&quot;end&quot;&gt;End&lt;/h2&gt; 
&lt;p&gt;整理不易，点个赞呗！&lt;/p&gt; 
&lt;h2&gt;巨人的肩膀&lt;/h2&gt; 
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ThinkWon/article/details/104778621&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://blog.csdn.net/ThinkWon/article/details/104778621&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.javazhiyin.com/40232.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://www.javazhiyin.com/40232.html&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844904039860142088&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://juejin.cn/post/6844904039860142088&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ThinkWon/article/details/104778621&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://blog.csdn.net/ThinkWon/article/details/104778621&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000008131735&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://segmentfault.com/a/1190000008131735&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b16f6de03361c8fc84754f1a633cb48d</guid>
<title>Golang 官方限流器的用法详解</title>
<link>https://toutiao.io/k/xvjaiyz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限流器是提升服务稳定性的非常重要的组件，可以用来限制请求速率，保护服务，以免服务过载。限流器的实现方法有很多种，常见的限流算法有&lt;strong&gt;固定窗口、滑动窗口、漏桶、令牌桶&lt;/strong&gt;，我在前面的文章 &lt;strong&gt;「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247486937&amp;amp;idx=1&amp;amp;sn=d4ea6ebb38c52e8004e73f235bde9848&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;常用限流算法的应用场景和实现原理&lt;/a&gt;」&lt;/strong&gt; 中给大家讲解了这几种限流方法自身的特点和应用场景，其中令牌桶在限流的同时还可以应对一定的突发流量，与互联网应用容易因为热点事件出现突发流量高峰的特点更契合。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;简单来说，令牌桶就是想象有一个固定大小的桶，系统会以恒定速率向桶中放 Token，桶满则暂时不放。在请求比较的少的时候桶可以先&quot;攒&quot;一些Token，应对突发的流量，如果桶中有剩余 Token 就可以一直取。如果没有剩余 Token，则需要等到桶中被放置了 Token 才行。&lt;/p&gt;&lt;p&gt;关于令牌桶限流更详细的解释请参考文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247486937&amp;amp;idx=1&amp;amp;sn=d4ea6ebb38c52e8004e73f235bde9848&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;常用限流算法的应用场景和实现原理&lt;/a&gt;&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的同学在看明白令牌桶的原理后就非常想去自己实现一个限流器应用到自己的项目里，em... 怎么说呢，造个轮子确实有利于自己水平提高，不过要是应用到商用项目里的话其实大可不必自己去造轮子，Golang官方已经替我们造好轮子啦 ......~！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Golang 官方提供的扩展库里就自带了限流算法的实现，即 &lt;code&gt;golang.org/x/time/rate&lt;/code&gt;。该限流器也是基于 Token Bucket(令牌桶) 实现的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;限流器的内部结构&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;time/rate&lt;/code&gt;包的&lt;code&gt;Limiter&lt;/code&gt;类型对限流器进行了定义，所有限流功能都是通过基于&lt;code&gt;Limiter&lt;/code&gt;类型实现的，其内部结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Limiter &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; mu     sync.Mutex&lt;br/&gt; limit  Limit&lt;br/&gt; burst  &lt;span&gt;int&lt;/span&gt; &lt;span&gt;// 令牌桶的大小&lt;/span&gt;&lt;br/&gt; tokens &lt;span&gt;float64&lt;/span&gt;&lt;br/&gt; last time.Time &lt;span&gt;// 上次更新tokens的时间&lt;/span&gt;&lt;br/&gt; lastEvent time.Time &lt;span&gt;// 上次发生限速器事件的时间（通过或者限制都是限速器事件）&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其主要字段的作用是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;limit：&lt;code&gt;limit&lt;/code&gt;字段表示往桶里放Token的速率，它的类型是Limit，是int64的类型别名。&lt;strong&gt;设置&lt;code&gt;limit&lt;/code&gt;时既可以用数字指定每秒向桶中放多少个Token，也可以指定向桶中放Token的时间间隔&lt;/strong&gt;，其实指定了每秒放Token的个数后就能计算出放每个Token的时间间隔了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;burst: 令牌桶的大小。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tokens: 桶中的令牌。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;last: 上次往桶中放 Token 的时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;lastEvent：上次发生限速器事件的时间（通过或者限制都是限速器事件）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;可以看到在 &lt;code&gt;timer/rate&lt;/code&gt; 的限流器实现中，并没有单独维护一个 Timer 和队列去真的每隔一段时间向桶中放令牌，而是仅仅通过计数的方式表示桶中剩余的令牌。每次消费取 Token 之前会先根据上次更新令牌数的时间差更新桶中Token数&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大概了解了&lt;code&gt;time/rate&lt;/code&gt;限流器的内部实现后，下面的内容我们会集中介绍下该组件的具体使用方法：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;构造限流器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用以下方法构造一个限流器对象：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;limiter := rate.NewLimiter(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有两个参数：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一个参数是 &lt;code&gt;r Limit&lt;/code&gt;，设置的是限流器Limiter的&lt;code&gt;limit&lt;/code&gt;字段，代表每秒可以向 Token 桶中产生多少 token。Limit 实际上是 float64 的别名。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二个参数是 &lt;code&gt;b int&lt;/code&gt;，b 代表 Token 桶的容量大小，也就是设置的限流器 Limiter 的&lt;code&gt;burst&lt;/code&gt;字段。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，对于以上例子来说，其构造出的限流器的令牌桶大小为 100, 以每秒 10 个 Token 的速率向桶中放置 Token。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了给&lt;code&gt;r Limit&lt;/code&gt;参数直接指定每秒产生的 Token 个数外，还可以用 Every 方法来指定向桶中放置 Token 的间隔，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;limit := rate.Every(&lt;span&gt;100&lt;/span&gt; * time.Millisecond);&lt;br/&gt;limiter := rate.NewLimiter(limit, &lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就表示每 100ms 往桶中放一个 Token。本质上也是一秒钟往桶里放 10 个。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用限流器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Limiter 提供了三类方法供程序消费 Token，可以每次消费一个 Token，也可以一次性消费多个 Token。每种方法代表了当 Token 不足时，各自不同的对应手段，可以阻塞等待桶中Token补充，也可以直接返回取Token失败。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Wait/WaitN&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(lim *Limiter)&lt;/span&gt; &lt;span&gt;Wait&lt;/span&gt;&lt;span&gt;(ctx context.Context)&lt;/span&gt; &lt;span&gt;(err error)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(lim *Limiter)&lt;/span&gt; &lt;span&gt;WaitN&lt;/span&gt;&lt;span&gt;(ctx context.Context, n &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(err error)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Wait 实际上就是 &lt;code&gt;WaitN(ctx,1)&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用 Wait 方法消费 Token 时，如果此时桶内 Token 数组不足 (小于 N)，那么 Wait 方法将会阻塞一段时间，直至 Token 满足条件。如果充足则直接返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里可以看到，Wait 方法有一个 context 参数。我们可以设置 context 的 Deadline 或者 Timeout，来决定此次 Wait 的最长时间。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 一直等到获取到桶中的令牌&lt;/span&gt;&lt;br/&gt;err := limiter.Wait(context.Background())&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;Error: &quot;&lt;/span&gt;, err)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 设置一秒的等待超时时间&lt;/span&gt;&lt;br/&gt;ctx, _ := context.WithTimeout(context.Background(), time.Second * &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;err := limiter.Wait(ctx)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;Error: &quot;&lt;/span&gt;, err)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Allow/AllowN&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(lim *Limiter)&lt;/span&gt; &lt;span&gt;Allow&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(lim *Limiter)&lt;/span&gt; &lt;span&gt;AllowN&lt;/span&gt;&lt;span&gt;(now time.Time, n &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Allow 实际上就是对 &lt;code&gt;AllowN(time.Now(),1)&lt;/code&gt; 进行简化的函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AllowN 方法表示，截止到某一时刻，目前桶中数目是否至少为 n 个，满足则返回 true，同时从桶中消费 n 个 token。反之不消费桶中的Token，返回false。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应线上的使用场景是，如果请求速率超过限制，就直接丢弃超频后的请求。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; limiter.AllowN(time.Now(), &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;event allowed&quot;&lt;/span&gt;)&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;event not allowed&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Reserve/ReserveN&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(lim *Limiter)&lt;/span&gt; &lt;span&gt;Reserve&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;Reservation&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(lim *Limiter)&lt;/span&gt; &lt;span&gt;ReserveN&lt;/span&gt;&lt;span&gt;(now time.Time, n &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; *&lt;span&gt;Reservation&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Reserve 相当于 &lt;code&gt;ReserveN(time.Now(), 1)&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReserveN 的用法就相对来说复杂一些，当调用完成后，无论 Token 是否充足，都会返回一个 &lt;code&gt;*Reservation&lt;/code&gt; 对象。你可以调用该对象的&lt;code&gt;Delay()&lt;/code&gt;方法，该方法返回的参数类型为&lt;code&gt;time.Duration&lt;/code&gt;，反映了需要等待的时间，必须等到等待时间之后，才能进行接下来的工作。如果不想等待，可以调用&lt;code&gt;Cancel()&lt;/code&gt;方法，该方法会将 Token 归还。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举一个简单的例子，我们可以这么使用 Reserve 方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;r := limiter.Reserve()&lt;br/&gt;f !r.OK() {&lt;br/&gt;    &lt;span&gt;// Not allowed to act! Did you remember to set lim.burst to be &amp;gt; 0 ?&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;time.Sleep(r.Delay())&lt;br/&gt;Act() &lt;span&gt;// 执行相关逻辑&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;动态调整速率和桶大小&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Limiter 支持创建后动态调整速率和桶大小：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;SetLimit(Limit) 改变放入 Token 的速率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SetBurst(int) 改变 Token 桶大小&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这两个方法，可以根据现有环境和条件以及我们的需求，动态地改变 Token 桶大小和速率。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们总结了 Golang 官方限流器的使用方法，它是一种令牌桶算实现的限流器。其中 &lt;strong&gt;Wait/WaitN&lt;/strong&gt;，&lt;strong&gt;Allow/AllowN&lt;/strong&gt; 这两组方法在平时用的比较多，前者是消费Token时如果桶中Token不足可以让程序等待桶中新Token的放入（最好设置上等待时长）后者则是在桶中的Token不足时选择直接丢弃请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了Golang官方提供的限流器实现，Uber公司开源的限流器&lt;code&gt;uber-go/ratelimit&lt;/code&gt;也是一个很好的选择，与Golang官方限流器不同的是Uber的限流器是通过漏桶算法实现的，不过对传统的漏桶算法进行了改良，有兴趣的同学可以自行去体验一下。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUzNTY5MzU2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4pGhLz2xEbRFHnAQon2QLYgbBibCJo1ibJHesLWshPJeRibateRtAqkaf6BgjlbhYiaxHLq6Zu07CRPw/0?wx_fmt=png&quot; data-nickname=&quot;网管叨bi叨&quot; data-alias=&quot;kevin_tech&quot; data-signature=&quot;分享软件开发和系统架构设计基础、Go 语言和Kubernetes。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0b4771a8f217a32164940cb97ec062b0</guid>
<title>一步步拆解 Elasticsearch BM25 模型评分细节</title>
<link>https://toutiao.io/k/hctpzno</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Elasticsearch 5 之前的版本，评分机制或者打分模型基于 TF-IDF 实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 Elasticsearch 5 开始，Elasticsearch 的默认&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDY1MTA3OQ==&amp;amp;mid=2247484713&amp;amp;idx=1&amp;amp;sn=5961d78af4fa65c8ea0d3649aa1baec9&amp;amp;chksm=eaa82d01dddfa4178c2dbb1fd1fdf5a00ad8e9d5395aedf831f29a0cfe53b63bc56e47315b52&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;相似度算法是 Okapi BM25&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;相似度算法是 Okapi BM25&lt;/a&gt;，Okapi BM25模型于 1994 年提出，BM25 的 BM 是缩写自 Best Match, 25 是经过 25 次迭代调整之后得出的算法，该模型也是基于 TF/IDF 进化来的，Okapi 信息检索系统是第一个实现此功能的系统，之后被广泛应用在不同系统里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相似性（评分/排名模型）定义了匹配文档的评分方式， 对一组文档执行搜索并提供按相关性排序的结果。在这篇文章中，我们将一步步拆解 Okapi BM25 模型的内部工作原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在拆解评分算法之前，必须简单解释一下背后的理论——Elasticsearch 基于 Lucene。要了解 Elasticsearch，我们必须了解 Lucene。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、Okapi BM25 基本概念&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Okapi BM25 模型的计算公式如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1457725947521866&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9YfgMo8XzUMwYiaNwfYxIESHsAyE82Zy4yA4XRjSup1Ev9VN9ic05OHxKdDPlPQ37fovWvA4072mYyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;686&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似的公式，我看到后的第一反应：这是科研人员才能搞懂的事情，我等只能围观。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但，为了进一步深入算分机制，我们一个个参数拆解一下，期望能“拨开云天、豁然开朗”！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述公式中：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;D：代表文档。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Q：代表查询。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;K1：自由参数，默认值：1.2。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;b：自由参数，默认值：0.75。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参见 Lucene 官方文档：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://lucene.apache.org/core/8_0_0/core/org/apache/lucene/search/similarities/BM25Similarity.html&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、词频 TF&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;词频英文释义：TF(Term Frequency) ，即：分词单元（Term）在文档中出现的频率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于每个文本的长度不同，一个单词在长文档中出现的次数可能比短文档中出现的次数要多得多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个词出现的次数越多，它的得分就越高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.36363636363636365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9YfgMo8XzUMwYiaNwfYxIESHNvME4wclb71GRYibCoPzhVt29UibTrbFQQGRZ0pdlGLDqiaVM29YAZypA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;110&quot;/&gt;可以简记为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;     特定分词单元 Term 出现次数 (Number of &lt;span&gt;times&lt;/span&gt; term t appears &lt;span&gt;in&lt;/span&gt; a document)&lt;br/&gt;TF =  ---------------------------------------------- &lt;br/&gt;         所在文档 Terms 总数 (Total number of terms &lt;span&gt;in&lt;/span&gt; the document)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、逆文档频率 IDF&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;逆文档频率英文释义: IDF(Inverse Document Frequency)，衡量分词单元Term的重要性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，众所周知，诸如“the”、“is”、“of、“that”、“的”、“吗”等之类的特定词可能会出现很多次但重要性不大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，我们需要通过计算以下公式来降低常用分词单元的权重，同时扩大稀有分词单元的权重。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.22857142857142856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9YfgMo8XzUMwYiaNwfYxIESHBGhZEa9RmIfibsfQx8swZ8B09sicDYUfxy7Vz73iaAyTQmyCLtPiaeHVBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;350&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;                文档数(Total number of documents) &lt;br/&gt;IDF = &lt;span&gt;log&lt;/span&gt;  ---------------------------------------&lt;br/&gt;          包含特定分词单元 Term 的文档数 (Number of documents with term t &lt;span&gt;in&lt;/span&gt; it)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、实战探索&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.1 索引准备&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文基于：7.12.0 版本的 Elasticsearch 进行拆解验证。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建索引：got，并制定字段 quote 为 text 类型，同时指定：english 分词器。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;DELETE got&lt;br/&gt;PUT got&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;settings&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;number_of_shards&quot;&lt;/span&gt;: 1,&lt;br/&gt;    &lt;span&gt;&quot;number_of_replicas&quot;&lt;/span&gt;: 0&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;mappings&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;properties&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;quote&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;text&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;analyzer&quot;&lt;/span&gt;: &lt;span&gt;&quot;english&quot;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2 数据准备&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bulk 批量导入数据，数据来自《权利的游戏》电视剧的台词。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;POST _bulk&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;1&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;A mind needs books as a sword needs a whetstone, if it is to keep its edge.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;2&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;Never forget what you are, for surely the world will not. Make it your strength. Then it can never be your weakness. Armor yourself in it, and it will never be used to hurt you.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;3&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;Let them see that their words can cut you, and you’ll never be free of the mockery. If they want to give you a name, take it, make it your own. Then they can’t hurt you with it anymore.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;4&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;When you play the game of thrones, you win or you die. There is no middle ground.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;5&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;The common people pray for rain, healthy children, and a summer that never ends. It is no matter to them if the high lords play their game of thrones, so long as they are left in peace.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;6&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;If you would take a man’s life, you owe it to him to look into his eyes and hear his final words. And if you cannot bear to do that, then perhaps the man does not deserve to die.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;7&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;Sorcery is the sauce fools spoon over failure to hide the flavor of their own incompetence.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;8&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;Power resides where men believe it resides. No more and no less.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;9&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;There’s no shame in fear, my father told me, what matters is how we face it.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;10&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;Love is poison. A sweet poison, yes, but it will kill you all the same.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;11&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;What good is this, I ask you? He who hurries through life hurries to his grave.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;12&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;Old stories are like old friends, she used to say. You have to visit them from time to time.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;13&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;The greatest fools are ofttimes more clever than the men who laugh at them.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;14&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;Everyone wants something, Alayne. And when you know what a man wants you know who he is, and how to move him.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;15&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;Always keep your foes confused. If they are never certain who you are or what you want, they cannot know what you are like to do next. Sometimes the best way to baffle them is to make moves that have no purpose, or even seem to work against you.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;16&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;One voice may speak you false, but in many there is always truth to be found.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;17&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;History is a wheel, for the nature of man is fundamentally unchanging.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;18&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;Knowledge is a weapon, Jon. Arm yourself well before you ride forth to battle.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;19&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;I prefer my history dead. Dead history is writ in ink, the living sort in blood.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;20&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;In the game of thrones, even the humblest pieces can have wills of their own. Sometimes they refuse to make the moves you’ve planned for them. Mark that well, Alayne. It’s a lesson that Cersei Lannister still has yet to learn.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;21&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;Every man should lose a battle in his youth, so he does not lose a war when he is old.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;22&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;A reader lives a thousand lives before he dies. The man who never reads lives only one.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;23&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;The fisherman drowned, but his daughter got Stark to the Sisters before the boat went down. They say he left her with a bag of silver and a bastard in her belly. Jon Snow, she named him, after Arryn.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;24&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;You could make a poultice out of mud to cool a fever. You could plant seeds in mud and grow a crop to feed your children. Mud would nourish you, where fire would only consume you, but fools and children and young girls would choose fire every time.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;25&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;Men live their lives trapped in an eternal present, between the mists of memory and the sea of shadow that is all we know of the days to come.&quot;&lt;/span&gt; }&lt;br/&gt;{ &lt;span&gt;&quot;index&quot;&lt;/span&gt; : { &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;, &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;26&quot;&lt;/span&gt; } }&lt;br/&gt;{ &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;No. Hear me, Daenerys Targaryen. The glass candles are burning. Soon comes the pale mare, and after her the others. Kraken and dark flame, lion and griffin, the sun’s son and the mummer’s dragon. Trust none of them. Remember the Undying. Beware the perfumed seneschal.&quot;&lt;/span&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.3 实施检索&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;GET got/_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;match&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;quote&quot;&lt;/span&gt;: &lt;span&gt;&quot;live&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回结果（仅列举评分、Quote 字段）如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Score&lt;/th&gt;&lt;th&gt;Quote&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;3.3297362&lt;/td&gt;&lt;td&gt;A reader lives a thousand lives before he dies.  The man who never reads lives only one.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2.847715&lt;/td&gt;&lt;td&gt;Men live their lives trapped in an eternal present, between the mists of memory  and the sea of shadow that is all we know of the days to come.&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;2.313831&lt;/th&gt;&lt;th&gt;I prefer my history dead. Dead history is writ in ink, the living sort in blood.&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候会面临我们的终极疑惑——这些评分咋来的？咋计算的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;别急，我们一步步拆解。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5、评分拆解&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加上 &quot;explain&quot;:true 一探究竟。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;GET got/_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;match&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;quote&quot;&lt;/span&gt;: &lt;span&gt;&quot;you&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;explain&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拿第一个返回文档也就是评分为：3.3297362 的结果数据为例，&lt;strong&gt;自顶向下&lt;/strong&gt;的方法有利于理解计算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下拆解结果所示，分数 3.3297362 是分词单元 live 的 boost * IDF * TF 三者的乘积，简记为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;总评分 = 2.2 * 2.043074 * 0.74080354 = 3.3297362。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;explain 执行后的结果，核心部分如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;{&lt;br/&gt;        &lt;span&gt;&quot;_shard&quot;&lt;/span&gt; : &lt;span&gt;&quot;[got][0]&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;_node&quot;&lt;/span&gt; : &lt;span&gt;&quot;m9VCQfPDRqqMuupU_Xz5Eg&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;got&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;_type&quot;&lt;/span&gt; : &lt;span&gt;&quot;_doc&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;22&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;_score&quot;&lt;/span&gt; : 3.3297362,&lt;br/&gt;        &lt;span&gt;&quot;_source&quot;&lt;/span&gt; : {&lt;br/&gt;          &lt;span&gt;&quot;quote&quot;&lt;/span&gt; : &lt;span&gt;&quot;A reader lives a thousand lives before he dies. The man who never reads lives only one.&quot;&lt;/span&gt;&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;&quot;_explanation&quot;&lt;/span&gt; : {&lt;br/&gt;          &lt;span&gt;&quot;value&quot;&lt;/span&gt; : 3.3297362,&lt;br/&gt;          &lt;span&gt;&quot;description&quot;&lt;/span&gt; : &lt;span&gt;&quot;weight(quote:live in 21) [PerFieldSimilarity], result of:&quot;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;&quot;details&quot;&lt;/span&gt; : [&lt;br/&gt;            {&lt;br/&gt;              &lt;span&gt;&quot;value&quot;&lt;/span&gt; : 3.3297362,&lt;br/&gt;              &lt;span&gt;&quot;description&quot;&lt;/span&gt; : &lt;span&gt;&quot;score(freq=3.0), computed as boost * idf * tf from:&quot;&lt;/span&gt;,&lt;br/&gt;              &lt;span&gt;&quot;details&quot;&lt;/span&gt; : [&lt;br/&gt;                {&lt;br/&gt;                  &lt;span&gt;&quot;value&quot;&lt;/span&gt; : 2.2,&lt;br/&gt;                  &lt;span&gt;&quot;description&quot;&lt;/span&gt; : &lt;span&gt;&quot;boost&quot;&lt;/span&gt;,&lt;br/&gt;                  &lt;span&gt;&quot;details&quot;&lt;/span&gt; : [ ]&lt;br/&gt;                },&lt;br/&gt;                {&lt;br/&gt;                  &lt;span&gt;&quot;value&quot;&lt;/span&gt; : 2.043074,&lt;br/&gt;                  &lt;span&gt;&quot;description&quot;&lt;/span&gt; : &lt;span&gt;&quot;idf, computed as log(1 + (N - n + 0.5) / (n + 0.5)) from:&quot;&lt;/span&gt;,&lt;br/&gt;                },&lt;br/&gt;                {&lt;br/&gt;                  &lt;span&gt;&quot;value&quot;&lt;/span&gt; : 0.7408035,&lt;br/&gt;                  &lt;span&gt;&quot;description&quot;&lt;/span&gt; : &lt;span&gt;&quot;tf, computed as freq / (freq + k1 * (1 - b + b * dl / avgdl)) from:&quot;&lt;/span&gt;,&lt;br/&gt;                }&lt;br/&gt;              ]&lt;br/&gt;            }&lt;br/&gt;          ]&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.1 词频 TF 拆解&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行 explain 后，词频 TF 拆解计算如下，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;{&lt;br/&gt;    &lt;span&gt;&quot;value&quot;&lt;/span&gt;:0.7408035,&lt;br/&gt;    &lt;span&gt;&quot;description&quot;&lt;/span&gt;:&lt;span&gt;&quot;tf, computed as freq / (freq + k1 * (1 - b + b * dl / avgdl)) from:&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;details&quot;&lt;/span&gt;:[&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;&quot;value&quot;&lt;/span&gt;:&lt;span&gt;&quot;3.0&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;description&quot;&lt;/span&gt;:&lt;span&gt;&quot;freq, occurrences of term within document&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;details&quot;&lt;/span&gt;:[&lt;br/&gt;&lt;br/&gt;            ]&lt;br/&gt;        },&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;&quot;value&quot;&lt;/span&gt;:1.2,&lt;br/&gt;            &lt;span&gt;&quot;description&quot;&lt;/span&gt;:&lt;span&gt;&quot;k1, term saturation parameter&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;details&quot;&lt;/span&gt;:[&lt;br/&gt;&lt;br/&gt;            ]&lt;br/&gt;        },&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;&quot;value&quot;&lt;/span&gt;:0.75,&lt;br/&gt;            &lt;span&gt;&quot;description&quot;&lt;/span&gt;:&lt;span&gt;&quot;b, length normalization parameter&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;details&quot;&lt;/span&gt;:[&lt;br/&gt;&lt;br/&gt;            ]&lt;br/&gt;        },&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;&quot;value&quot;&lt;/span&gt;:&lt;span&gt;&quot;14.0&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;description&quot;&lt;/span&gt;:&lt;span&gt;&quot;dl, length of field&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;details&quot;&lt;/span&gt;:[&lt;br/&gt;&lt;br/&gt;            ]&lt;br/&gt;        },&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;&quot;value&quot;&lt;/span&gt;:16.807692,&lt;br/&gt;            &lt;span&gt;&quot;description&quot;&lt;/span&gt;:&lt;span&gt;&quot;avgdl, average length of field&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;details&quot;&lt;/span&gt;:[&lt;br/&gt;&lt;br/&gt;            ]&lt;br/&gt;        }&lt;br/&gt;    ]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;词频计算涉及参数如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;freq = 分词单元 live 在文档中出现的次数为 3 次，如下图所示：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.07770961145194274&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9YfgMo8XzUMwYiaNwfYxIESH46HM8bX5jwyazXh9GqyEzy8uaGes0Q4qu3nOfjX5ziatWgFiaibu2EdAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;978&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;k1：1.2，缺省值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;b：0.75 缺省值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;dl：该文档的分词后分词单元的个数（number of tokens），为 14。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以借助——analyze API 验证：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;POST got/_analyze&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;text&quot;&lt;/span&gt;: &lt;span&gt;&quot;A reader lives a thousand lives before he dies. The man who never reads lives only one&quot;&lt;/span&gt;, &lt;br/&gt;  &lt;span&gt;&quot;analyzer&quot;&lt;/span&gt;: &lt;span&gt;&quot;english&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分词后的 token 为：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5789473684210527&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9YfgMo8XzUMwYiaNwfYxIESHwy3FFicsYqGIXotzrzIgeJ6e2R0bCAJHHIJChKwsxyDQ7UoImrRvpCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;418&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;avgdl：等于所有文档的分词单元的总数  / 文档个数） ，计算结果为：16.807692。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何计算的呢？这里有同学会有疑惑，解读如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;avgdl 计算步骤 1&lt;/strong&gt;：所有文档的分词单元的总数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下所示：共 437个。文档数为 26 个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了方面查看，我把 26 个文档的全部 document 内容集合到一个文档里面，求得的分词后的结果值为 437 。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5219925808161102&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9YfgMo8XzUMwYiaNwfYxIESH6eT761sD9XbFFLQHjMK4Y9U3Dae92dwVms5ViaAYnCpsKVm4zpianaCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1887&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;avgdl 计算步骤 2&lt;/strong&gt;：avgdl = 437 / 26 = 16.807692。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终 TF 词频 求解结果为：0.740803524（该手算值精度和最终 Elasticsearch 返回结果精度值不完全一致，属于精度问题，不影响理解全局），其求解步骤如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;TF = freq / (freq + k1 * (1 - b + b * dl / avgdl))  &lt;br/&gt;= 3 / (3 + 1.2 *( 1 - 0.75 + 0.75 * 14 / 16.807692)) &lt;br/&gt;= 3 / (3 + 1.2 *0.87471397)&lt;br/&gt;= 3/（3+1.049656764）&lt;br/&gt;= 3/4.049656764&lt;br/&gt;= 0.740803524&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.2 逆文档频率 IDF 拆解&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行 explain 后，逆文档频率 IDF 拆解如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;{&lt;br/&gt;    &lt;span&gt;&quot;value&quot;&lt;/span&gt;:2.043074,&lt;br/&gt;    &lt;span&gt;&quot;description&quot;&lt;/span&gt;:&lt;span&gt;&quot;idf, computed as log(1 + (N - n + 0.5) / (n + 0.5)) from:&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;details&quot;&lt;/span&gt;:[&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;&quot;value&quot;&lt;/span&gt;:3,&lt;br/&gt;            &lt;span&gt;&quot;description&quot;&lt;/span&gt;:&lt;span&gt;&quot;n, number of documents containing term&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;details&quot;&lt;/span&gt;:[&lt;br/&gt;&lt;br/&gt;            ]&lt;br/&gt;        },&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;&quot;value&quot;&lt;/span&gt;:26,&lt;br/&gt;            &lt;span&gt;&quot;description&quot;&lt;/span&gt;:&lt;span&gt;&quot;N, total number of documents with field&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;details&quot;&lt;/span&gt;:[&lt;br/&gt;&lt;br/&gt;            ]&lt;br/&gt;        }&lt;br/&gt;    ]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;N：待检索文档数，本示例为 26。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;n：包含分词单元 live 的文档数目，本示例为 3。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终 IDF 求解结果为：2.043074，其计算公式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;IDF = &lt;span&gt;log&lt;/span&gt;(1 + (N - n + 0.5) / (n + 0.5)) &lt;br/&gt;= &lt;span&gt;log&lt;/span&gt;( 1 + ( 26 - 3 + 0.5) / ( 3 + 0.5)) &lt;br/&gt;= &lt;span&gt;log&lt;/span&gt;( 1 + 23.5/3.5) &lt;br/&gt;= &lt;span&gt;log&lt;/span&gt;( 1 + 6.714285) &lt;br/&gt;= &lt;span&gt;log&lt;/span&gt;(7.714285) &lt;br/&gt;= 2.043074&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上计算对数， 底数为 e。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.3 总评分拆解&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;总评分 &lt;br/&gt;= boost * TF * IDF &lt;br/&gt;= 2.2 * 0.74080354  * 2.043074 = 3.3297362&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;boost 为什么等于 2.2 ？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们不指定 boost，boost 就是使用&lt;strong&gt;缺省值&lt;/strong&gt;，缺省值是 2.2。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;boost 参见：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-explain.html&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://www.infoq.com/articles/similarity-scoring-elasticsearch/&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6、小结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一步步拆解，才能知道 BM25 模型的评分‘奥秘’所在，原来难懂的数学计算公式，也变得清晰明朗！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了拆解，再来看其他的检索评分问题自然会“毫不费力&quot;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文由英文博客：https://blog.mimacom.com/bm25-got/ 翻译而来，较原来博客内容，增加了计算的细节和个人解读，确保每一个计算细节小学生都能看懂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎就评分问题留言交流细节。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;https://blog.mimacom.com/bm25-got/&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDY1MTA3OQ==&amp;amp;mid=2247484713&amp;amp;idx=1&amp;amp;sn=5961d78af4fa65c8ea0d3649aa1baec9&amp;amp;chksm=eaa82d01dddfa4178c2dbb1fd1fdf5a00ad8e9d5395aedf831f29a0cfe53b63bc56e47315b52&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;实战 | Elasticsearch自定义评分的N种方法&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;实战 | Elasticsearch自定义评分的N种方法&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;https://ruby-china.org/topics/31934&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;https://www.elastic.co/guide/en/elasticsearch/reference/current/similarity.html&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;https://lucene.apache.org/core/4_0_0/core/org/apache/lucene/search/similarities/BM25Similarity.html&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules-similarity.html&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;https://nlp.stanford.edu/IR-book/html/htmledition/okapi-bm25-a-non-binary-model-1.html&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>89e463613a350058a51ed5a1c793624f</guid>
<title>Flink Broadcast State 实战指南</title>
<link>https://toutiao.io/k/j8spuhu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.562962962962963&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6LrrYenhZVnA3upAl8steFSDBVfSooXf3whKUm0WBvibrc4tBiaJWAdvtpU6HhvFQaOYOSmAWuF765B8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Flink 版本 1.13.0&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Flink 从 1.5.0 版本开始引入了一种新的状态，称为广播状态。在这篇文章中，我们会解释什么是广播状态以及展示一个示例来说明如何使用广播状态。&lt;/p&gt;&lt;h3&gt;1. 什么是广播状态？&lt;/h3&gt;&lt;p&gt;广播状态可以以某种方式组合处理两个事件流。第一个流的事件被广播到算子所有并行实例上，并存储在状态中。另一个流的事件不会被广播，但是会被发送到同一算子的各个实例上，并与广播流的事件一起处理。这种新的广播状态非常适合低吞吐量和高吞吐量流 Join 或需要动态更新处理逻辑的应用程序。我们将使用一个具体示例来演示如何使用广播状态，并展示具体的API。&lt;/p&gt;&lt;h3&gt;2. 广播状态的动态模型评估&lt;/h3&gt;&lt;p&gt;想象一下，一个电子商务网站获取用户所有交互行为作为用户行为流。运营该网站的公司分析交互行为以增加收入，改善用户体验，以及检测和防止恶意行为。该网站实现了一个流应用程序，用于检测用户事件流上的行为模式。但是，我们希望每次模式修改时不需要修改以及重新部署应用程序，应用程序能从模式数据流接收新模式并动态更新模式。在下文中，我们将逐步讨论此应用程序，并展示如何利用 Flink 中的广播状态功能。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.66993006993007&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6LrqsHKBwk9M9WicXB2oNTB7TKX60pP4Kgk38Kzqdz6GYfOZqglAd0fYhzy6l2UZCP7eZLEwjztK33aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;715&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们示例应用程序接收两个数据流。第一个数据流提供在网站上的用户行为操作，在上图的左上方显示。用户交互事件由不同类型的操作（用户登录，用户退出，添加到购物车或完成支付）以及由不同颜色编码的用户ID组成。在上图中我们可以看到用户行为数据流最新三个事件分别为：1001用户的登录事件、1003用户的支付完成事件以及1002用户的添加购物车事件。&lt;/p&gt;&lt;p&gt;第二个流提供了动态模型评估的用户操作模式。一个模式由两个连续的行为组成。在上图中的模式流包含以下两个模式：&lt;/p&gt;&lt;p&gt;这些模式有助于企业更好地分析用户行为，检测恶意行为并改善网站的用户体验。例如，如果商品被添加到购物车而没有后续购买，网站团队可以采取适当的措施来更好地了解用户未完成购买的原因并进行一些工作改善网站的转化率（ 如提供折扣，限时免费送货优惠等）。&lt;/p&gt;&lt;p&gt;在右侧，该图显示了算子的三个并发任务，该算子接收模式流和用户行为流，并在用户行为流上进行模式评估，然后向下游发送匹配的模式。为简单起见，我们示例中的算子仅计算满足单个模式的连续两个操作。当从模式流接收到新模式时，新模式会替换当前模式。原则上，还可以实现计算更复杂的模式或多个模式，这些模式可以单独添加或是删除。&lt;/p&gt;&lt;p&gt;我们将描述模式匹配应用程序如何处理用户操作和模式流。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6970128022759602&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6LrqsHKBwk9M9WicXB2oNTB7TKCL8DvUsqBsDcHyp9CxHncsibyldGYGt69U9zic2bVZxt4817bKCQ1btQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;703&quot;/&gt;&lt;/p&gt;&lt;p&gt;首先将模式发送给算子。该模式被广播到算子的所有三个并发任务上。任务将模式存储在其广播状态中。由于广播状态只应使用广播数据进行更新，因此所有任务的状态都是一样的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6629834254143646&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6LrqsHKBwk9M9WicXB2oNTB7TKjJTPrtg2iaUpdmCF6Wz0HRwz0kPx8yKYcYl2Zg5VicibU71JQa6QNomibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;724&quot;/&gt;&lt;/p&gt;&lt;p&gt;接下来，第一个用户行为根据用户ID分区并发送到算子任务上。分区可确保同一用户的所有行为都由同一个任务处理。上图显示了算子任务消费第一个模式和前三个行为事件后应用程序的状态。&lt;/p&gt;&lt;p&gt;当任务收到新的用户行为时，通过查看用户最新行为和前一个行为来评估当前的活跃模式。对于每个用户，算子都将前一个行为存储在 Keyed State 中。由于上图中的任务到目前为止每个用户仅收到了一个行为（因为我们刚刚才启动应用程序），因此不需要进行模式评估。最后， 最新行为会更新 Keyed State 中存储的前一个行为，以便能够在同一用户的下一个行为到达时进行查找。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.633423180592992&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6LrqsHKBwk9M9WicXB2oNTB7TKnUOnYYTBS7Ag4KhUicSL8clCSYWYLfFjsiavvNPkegcDrIjmupagicW9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;742&quot;/&gt;&lt;/p&gt;&lt;p&gt;在处理完前三个行为之后，下一个行为（用户1001的退出行为）被发送到处理用户 1001 的任务上。当任务接收到新行为时，从广播状态中查找当前模式以及用户1001的前一个行为。由于两个行为匹配模式（用户登录后并立即退出），因此任务发出一个模式匹配事件。最后，任务使用最新行为来覆盖 Keyed State 上的前一个行为。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6398362892223738&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6LrqsHKBwk9M9WicXB2oNTB7TK9mZCTjcYCNCaHibib50yvj90QmTuPLswEUfLughjia6wIiagibDz9XrHZtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;733&quot;/&gt;&lt;/p&gt;&lt;p&gt;当一个新模式进入了模式流，它会被广播给所有任务，并且每个并发任务通过使用新模式替换当前模式来更新其广播状态。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6896551724137931&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6LrqsHKBwk9M9WicXB2oNTB7TKuSpK17rYwdGiaYANa6I1WvWibzWKcWiaicYhlQtUgKtfRicerhqrekgMu0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;696&quot;/&gt;&lt;/p&gt;&lt;p&gt;一旦用新模式更新了广播状态，匹配逻辑就像之前一样继续执行，即用户行为事件按 key 分区并由负责的任务进行评估。&lt;/p&gt;&lt;h3&gt;3. 如何使用广播状态实现应用程序？&lt;/h3&gt;&lt;p&gt;到目前为止，我们在理论上讨论了应用程序并解释了如何使用广播状态来计算事件流上的动态模式。接下来，我们将展示如何使用 Flink 的 DataStream API 和广播状态功能实现示例应用程序。&lt;/p&gt;&lt;p&gt;让我们从应用程序的输入数据开始。我们有两个数据流，行为数据流和模式数据流。在这，我们并不关心流来自何处。可以从 Kafka 或 Kinesis 或任何其他系统获取流:&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;DataStream&amp;lt;String&amp;gt; actionsSource =&lt;/span&gt;&lt;br/&gt;&lt;span&gt;DataStream&amp;lt;String&amp;gt; patternsSource =&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;行为和模式都有两个字段：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Action的字段：String uid, String action&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Pattern的字段：String firstAction, String secondAction&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;// 行为流 (uid, action)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;DataStream&amp;lt;Action&amp;gt; actionsStream = actionsSource&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    .map(&lt;span&gt;new&lt;/span&gt; MapFunction&amp;lt;String, Action&amp;gt;() {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Action &lt;span&gt;map&lt;/span&gt;&lt;span&gt;(String str)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            String[] params = str.split(&lt;span&gt;&quot;,&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            String uid = params[&lt;span&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            String action = params[&lt;span&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            LOG.info(&lt;span&gt;&quot;[行为流] uid: &quot;&lt;/span&gt; + uid + &lt;span&gt;&quot;, action: &quot;&lt;/span&gt; + action);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Action(uid, action);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    });&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;// 模式流 (firstAction, secondAction)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;DataStream&amp;lt;Pattern&amp;gt; patternsStream = patternsSource&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    .map(&lt;span&gt;new&lt;/span&gt; MapFunction&amp;lt;String, Pattern&amp;gt;() {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Pattern &lt;span&gt;map&lt;/span&gt;&lt;span&gt;(String str)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            String[] params = str.split(&lt;span&gt;&quot;,&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            String firstAction = params[&lt;span&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            String secondAction = params[&lt;span&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            LOG.info(&lt;span&gt;&quot;[模式流] firstAction: &quot;&lt;/span&gt; + firstAction + &lt;span&gt;&quot;, secondAction: &quot;&lt;/span&gt; + secondAction);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Pattern(firstAction, secondAction);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    });&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;作为第一步，我们根据 uid 对行为流分区:&lt;/p&gt;&lt;pre&gt;&lt;span&gt;KeyedStream&amp;lt;Action, String&amp;gt; actionsByUser = actionsStream.keyBy(&lt;span&gt;new&lt;/span&gt; KeySelector&amp;lt;Action, String&amp;gt;() {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      &lt;span&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getKey&lt;/span&gt;&lt;span&gt;(Action action)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;          &lt;span&gt;return&lt;/span&gt; action.uid;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  });&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面，我们准备广播状态。广播状态始终用 MapState 表示，这是 Flink 提供的最通用的状态原语:&lt;/p&gt;&lt;pre&gt;&lt;span&gt;MapStateDescriptor&amp;lt;Void, Pattern&amp;gt; stateDescriptor = &lt;span&gt;new&lt;/span&gt; MapStateDescriptor&amp;lt;&amp;gt;(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &lt;span&gt;&quot;patternsState&quot;&lt;/span&gt;, Types.VOID, Types.POJO(Pattern.class)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;);&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于我们的应用程序一次只评估和存储一个 Pattern，因此我们将广播状态配置键为 Void 类型和值为 Pattern 类型的 MapState。Pattern 始终存储在 MapState 中，并将 null 作为键:&lt;/p&gt;&lt;pre&gt;&lt;span&gt;BroadcastStream broadcastStream = patternsStream.broadcast(stateDescriptor);&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以 MapStateDescriptor 为参数，调用模式流上的 Broadcast 转换操作，得到一个 BroadcastStream 对象 broadcastStream。&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;DataStream&amp;lt;Tuple2&amp;lt;Long, Pattern&amp;gt;&amp;gt; matches = actionsByUser&lt;/span&gt;&lt;br/&gt;&lt;span&gt; .connect(broadcastStream)&lt;/span&gt;&lt;br/&gt;&lt;span&gt; .process(&lt;span&gt;new&lt;/span&gt; PatternEvaluatorProcessFunction());&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;在我们获得 actionsByUser 行为流和 broadcastStream 广播流之后，使用 connect() 函数连接两个流并在连接的流上应用 PatternEvaluatorProcessFunction。PatternEvaluatorProcessFunction 是一个实现 KeyedBroadcastProcessFunction 接口的自定义函数。它调用了我们之前讨论过的模式匹配逻辑，并发出模式匹配的记录，其中包含用户 ID 和匹配的模式：&lt;/p&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;PatternEvaluatorProcessFunction&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;KeyedBroadcastProcessFunction&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Action&lt;/span&gt;, &lt;span&gt;Pattern&lt;/span&gt;, &lt;span&gt;Tuple2&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Pattern&lt;/span&gt;&amp;gt;&amp;gt; {&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;// 前一个行为&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;private&lt;/span&gt; ValueState&amp;lt;String&amp;gt; prevActionState;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;// 模式&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;private&lt;/span&gt; MapStateDescriptor&amp;lt;Void, Pattern&amp;gt; patternDesc;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(Configuration parameters)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;// 初始化 KeyedState&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        prevActionState = getRuntimeContext().getState(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                &lt;span&gt;new&lt;/span&gt; ValueStateDescriptor&amp;lt;&amp;gt;(&lt;span&gt;&quot;lastAction&quot;&lt;/span&gt;, Types.STRING)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        );&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        patternDesc = &lt;span&gt;new&lt;/span&gt; MapStateDescriptor&amp;lt;&amp;gt;(&lt;span&gt;&quot;patternsState&quot;&lt;/span&gt;, Types.VOID, Types.POJO(Pattern.class));&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;processElement&lt;/span&gt;&lt;span&gt;(Action action, ReadOnlyContext ctx, Collector&amp;lt;Tuple2&amp;lt;String, Pattern&amp;gt;&amp;gt; out)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        String uid = action.uid;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        String lastAction = action.action;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;// 从广播状态中获取模式&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        Pattern pattern = ctx.getBroadcastState(&lt;span&gt;this&lt;/span&gt;.patternDesc)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                &lt;span&gt;// access MapState with null as VOID default value&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                .get(&lt;span&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;// 获取当前用户的前一个行为&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        String prevAction = prevActionState.value();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;if&lt;/span&gt; (pattern != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; prevAction != &lt;span&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            String firstAction = pattern.firstAction;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            String secondAction = pattern.secondAction;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            &lt;span&gt;// 模式是否匹配&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            &lt;span&gt;boolean&lt;/span&gt; isMatch = &lt;span&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            &lt;span&gt;if&lt;/span&gt; (firstAction.equals(prevAction) &amp;amp;&amp;amp; secondAction.equals(lastAction)) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                isMatch = &lt;span&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                out.collect(&lt;span&gt;new&lt;/span&gt; Tuple2&amp;lt;&amp;gt;(ctx.getCurrentKey(), pattern));&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            LOG.info(&lt;span&gt;&quot;[Evaluation] uid: {}, Action: [{}-&amp;gt;{}], Pattern: [{}-&amp;gt;{}], IsMatch: {}&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                    uid, prevAction, lastAction, firstAction, secondAction, isMatch&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            );&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;// 用最新行为更新状态&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        prevActionState.update(lastAction);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;processBroadcastElement&lt;/span&gt;&lt;span&gt;(Pattern pattern, Context ctx, Collector&amp;lt;Tuple2&amp;lt;String, Pattern&amp;gt;&amp;gt; out)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;// 如果有新模式则更新广播状态&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        BroadcastState&amp;lt;Void, Pattern&amp;gt; broadcastState = ctx.getBroadcastState(patternDesc);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        broadcastState.put(&lt;span&gt;null&lt;/span&gt;, pattern);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;完整代码请查阅原文链接&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;KeyedBroadcastProcessFunction 接口提供了三种处理记录和发送结果的方法：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;processBroadcastElement：每次收到广播流的记录时会调用。在自定义实现中，我们只需使用 null 键将接收到的 Pattern 记录放入广播状态中（记住，我们只在 MapState 中存储一个模式）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;processElement：每次收到行为流的记录时会调用。它提供对广播状态的只读访问权限，以防止对广播状态修改导致函数的并行实例之间有不同的广播状态。自定义函数实现中我们从广播状态查看当前的模式，并从 KeyedState 查看用户的前一个行为。如果两者都存在，就会检查上一个行为和当前行为是否与模式匹配，如果是匹配，则发送模式匹配记录。最后，用当前最新行为更新 KeyedState。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;onTimer：当之前注册过的计时器触发时被调用。计时器可以在 processElement 方法中定义，用于执行计算或是清除状态。为了保持代码的简洁性，我们没有在例子中实现这个方法，但当用户在某段时间内没有操作时，它可以用来删除最后一个操作，以避免由于非活动用户而导致状态增长；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;你可能注意到了 KeyedBroadcastProcessFunction 类方法的上下文对象，提供了对其它功能的访问方法，例如：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;广播状态（读写或只读，取决于方法），&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;TimerService，可以访问记录的时间戳，当前的 Watermark，可以注册定时器，&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当前键（仅在 processElement() 中可用）以及&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一种将函数应用于每个已注册键的 keyed state 的方法（仅在 processBroadcastElement() 方法中可用）。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;KeyedBroadcastProcessFunction 可以像任何其他 ProcessFunction 一样访问 Flink 状态和时间功能，因此可用于实现复杂的应用程序逻辑。广播状态被设计为一种适用于不同场景和用例的通用功能。虽然我们只讨论了一个相当简单且受限制的应用程序，但你可以通过多种方式使用广播状态来实现应用程序的要求。&lt;/p&gt;&lt;p&gt;现在我们以下面的具体行为和模式为例，具体演示一下执行过程：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;// 模式流输入&lt;/span&gt;&lt;br/&gt;&lt;span&gt;login,logout&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;// 行为流输入&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1001,login&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1003,pay&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1002,cart&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1001,logout&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1002,pay&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;// 模式流切换模式&lt;/span&gt;&lt;br/&gt;&lt;span&gt;cart,logout&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;// 行为流输入&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1003,cart&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1002,logout&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1003,logout&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6LrqsHKBwk9M9WicXB2oNTB7TKKs2SrkYEVLO3zzbhS37iaE0rz9lLXxmnT4pABfW3345v5NEzJHXGLqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h3&gt;4. 结论&lt;/h3&gt;&lt;p&gt;在这篇博文中，我们向你介绍了一个示例应用程序，以解释 Flink 的广播状态以及它如何用于计算事件流上的动态模式。我们还讨论了API并展示了我们的示例应用程序的源代码。&lt;/p&gt;&lt;p&gt;欢迎关注我的公众号和博客：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.595&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nKovjAe6LrqPP36RWGmwXAHAUPcg48ibQzRb82UubkaEj0K8CANwdefia4cJZK3B0jiavicU35I08Z8lbgeFzibJofw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p&gt;原文:A Practical Guide to Broadcast State in Apache Flink&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ed5bca5377fb1207fdd4c178b8850551</guid>
<title>Linux 下简单几步安装 AI 开发环境：ROS</title>
<link>https://toutiao.io/k/3n8q2m9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一口君机缘巧合，接触到了一个开源的项目ROS，只需要根据本文操作，就可以很容易搭建一个具有3d效果的开发环境，非常有意思，和大家分享下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;0、什么是ROS&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6385714285714286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9RKPFKMpeMRSEv8f0Y9AWWYdq6uRAr9fIDJTPYrAByhAkfibLfNsFWbJGQXBMzPu4xC4rNh86hm0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ROS（Robot Operating System，下文简称“ROS”）是用于编写机器人软件程序的一种具有高度灵活性的软件架构，是一个开源的元操作系统。ROS的原型源自斯坦福大学的STanford Artificial Intelligence Robot (STAIR) 和 Personal Robotics (PR)项目。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它提供了操作系统应有的服务，包括硬件抽象，底层设备控制，常用函数的实现，进程间消息传递，以及包管理。它也提供用于获取、编译、编写、和跨计算机运行代码所需的工具和库函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ROS设计者将ROS表述为“ROS = Plumbing + Tools + Capabilities + Ecosystem”，即ROS是通讯机制、工具软件包、机器人高层技能以及机器人生态系统的集合体   。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. ROS安装&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ROS Kinetic 只 支持Wily (Ubuntu 15.10), Xenial (Ubuntu 16.04) 和Jessie (Debian 8) 的debian包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ubuntu 16.04安装，请参考文章《linux环境搭建-ubuntu16.04安装》&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 配置Ubuntu软件仓库&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置你的Ubuntu软件仓库（repositories）以允许使用“restricted”“universe”和“multiverse”存储库。你可以根据Ubuntu软件仓库指南来完成这项工作。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 设置sources.list&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置电脑以安装来自packages.ros.org的软件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打开终端，输入以下命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sudo sh -c &lt;span&gt;&#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &amp;gt; /etc/apt/sources.list.d/ros-latest.list&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若下载速度缓慢，推荐就近选择一个镜像源替换上面的命令。例如，Tsinghua University为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sudo sh -c &lt;span&gt;&#x27;. /etc/lsb-release &amp;amp;&amp;amp; echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &amp;gt; /etc/apt/sources.list.d/ros-latest.list&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果依旧遇到连接问题，请尝试为Ubuntu apt换源（非ROS网站）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3 设置密钥&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sudo apt-key adv --keyserver &lt;span&gt;&#x27;hkp://keyserver.ubuntu.com:80&#x27;&lt;/span&gt; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若无法连接到密钥服务器，可以尝试替换上面命令中的 hkp://keyserver.ubuntu.com:80 为 hkp://pgp.mit.edu:80 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你也可以使用curl命令替换apt-key命令，这在使用代理服务器的情况下比较有用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;curl -sSL &lt;span&gt;&#x27;http://keyserver.ubuntu.com/pks/lookup?op=get&amp;amp;search=0xC1CF6E31E6BADE8868B172B4F42ED6FBAB17C654&#x27;&lt;/span&gt; | sudo apt-key add -&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.4 安装&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，确保你的Debian软件包索引是最新的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sudo apt-get update&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在ROS中，有很多不同的库和工具。我们提供了默认的配置来开始。你也可以单独安装ROS包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果以下步骤出现问题，可以使用以下存储库，而不是上面提到的那些ros-shadow-fixed&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;桌面完整版: (推荐) : 包含ROS、rqt、rviz、机器人通用库、2D/3D 模拟器、导航以及2D/3D感知&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sudo apt-get install ros-kinetic-desktop-full&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.10414201183431952&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9RKPFKMpeMRSEv8f0Y9AWWniaEabFYSiaJznhNOj2kNepQRwSvMPZQXzNrRl3W3nr7HnSwRnb1icQAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;845&quot;/&gt;&lt;img data-ratio=&quot;0.3799237611181703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9RKPFKMpeMRSEv8f0Y9AWWicQWCDwztGvG4QoSExZsv1X6wTXFAFvQnUcRlLmlPonE0DVmgBr7Ahg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;787&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际操作可能会出错，多试几次即可。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.5 初始化 rosdep&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开始使用ROS之前你还需要初始化rosdep。rosdep可以方便在你需要编译某些源码的时候为其安装一些系统依赖，同时也是某些ROS核心功能组件所必需用到的工具。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sudo rosdep init&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.08962264150943396&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9RKPFKMpeMRSEv8f0Y9AWWvN9qG65EWMo9JTPGaV9ToPACYXCdNhNFRxTQGyGHctmQaJ3UKvH3KA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;848&quot;/&gt;但是初始化经常会失败，
解决方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sudo su&lt;br/&gt;sudo gedit /etc/hosts&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在hosts中添加以下内容并保存，在执行完后继续rosdep update&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;199.232.28.133 raw.githubusercontent.com&lt;br/&gt;151.101.228.133 raw.github.com&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在此执行 &lt;strong&gt;sudo rosdep init&lt;/strong&gt;&lt;img data-ratio=&quot;0.1924812030075188&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9RKPFKMpeMRSEv8f0Y9AWWst8bghdzh2s88Zvia39Jxocg2mTibP1kbVzUdVuH5hhibB59YsWxYeb3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;665&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.6 更新 rosdep&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该步骤可以不执行，如果需要更新rosdep ，可以执行以下命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;rosdep update&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3747276688453159&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9RKPFKMpeMRSEv8f0Y9AWWfG7LDCTKyYEznAxWUqWCVxz1ibNB28GwLnxfMeb5AJG0hThs3gJMwkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;918&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是由于服务器不稳定，通常需要多试几次，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者直接直接下载对应的更新文件UAV_ROS.tar，拷贝到ubuntu中，&lt;img data-ratio=&quot;0.32234432234432236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9RKPFKMpeMRSEv8f0Y9AWW8hb5Z0Mn7nuOyQ1C2sBGo5RHuMvdevcN1uy2Q8qdIRNpiaenEfcOSFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;819&quot;/&gt;然后拷贝到/etc/ros/rosdep/下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;cd&lt;/span&gt; ~/ros&lt;br/&gt;sudo cp * /etc/ros/rosdep/&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 编译&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 下载demo的解压包hw_1,并解压&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;tar zxvf hw_1.tar&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 创建工作空间&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Ctrl+alt+t，打开终端，复制并逐条运行以下命令&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mkdir -p ~/catkin_ws/src&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; ~/catkin_ws/src&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后将 hw_1/src 中的三个文件夹复制到/catkin_ws/src 路径下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cp ~/hw_1/src/*  ~/catkin_ws/src -r&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; ~/catkin_ws/src&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续在终端执行命令:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;catkin_init_workspace&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; ~/catkin_ws/&lt;br/&gt;catkin_make&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6907103825136612&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9RKPFKMpeMRSEv8f0Y9AWWz03Bmq9MbJrSsO4NiauSialicQNicPib4uCwsuHbbYIZVlnsXFv1XXTDsOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;915&quot;/&gt;&lt;img data-ratio=&quot;0.32860262008733626&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9RKPFKMpeMRSEv8f0Y9AWWjYYmFFW42Jbo39t8kyJF60D0ees2oKNzSmDgUkmQmzEWDW7V41ibP3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;916&quot;/&gt;成功！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;声明环境变量：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;source&lt;/span&gt; devel/setup.bash&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 打开 rviz&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在终端执行命令&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;roscore&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6255458515283843&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9RKPFKMpeMRSEv8f0Y9AWWBauVTw23xFsG6sKRbBAVQAq15puibMGQyKm3LSjMERFpCGbPwWXTJrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;916&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ctrl+shift+t，打开新一页终端，执行以下命令&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;rviz&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显示出 rviz 初始页面&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5255681818181818&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9RKPFKMpeMRSEv8f0Y9AWWQ8XwETVJQjpzRMeSiboycbS0MG5OMelNDUAVUNjaEKPt0fibM5Q4NI6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot;/&gt;最终界面如下：&lt;img data-ratio=&quot;0.6059602649006622&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9RKPFKMpeMRSEv8f0Y9AWWD5a2d79KXucaBxz6HymS4gdncLk3oBHO4bC613iapH9TfneaUNia3JaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1208&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 打开 rviz 配置文件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;鼠标放在左上方，点击添加配置文件(open Config)，&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5861526357199056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9RKPFKMpeMRSEv8f0Y9AWWbiaJo3knZBFRmCqTypYwTX8fy7wpicTgHwRf5ym096N94h5MJ71usXew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1271&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置文件路径为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;~/catkin_ws/src/grid_path_searcher/launch/rviz_config/demo.rviz&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6972477064220184&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9RKPFKMpeMRSEv8f0Y9AWWXPcElwSCRRAYWDE23Q4cPjhnuACc1icOJPgwMBgrv5yKqaEDOGIOPJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;654&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击open，进入下面对话框：&lt;img data-ratio=&quot;0.42168674698795183&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9RKPFKMpeMRSEv8f0Y9AWWqWOPZx4ECCriaYS7RNS00Y7rbT5U9sOZPNbxW81rAotSN8fY23iaZ5Jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;415&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击save后，显示如下画面，此时因为还未运行程序，所以地图没有初始化，看不到点云三维地
图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5483293556085919&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9RKPFKMpeMRSEv8f0Y9AWW0TBibiaod5VeGbA72E6vNxwvxib22xnM6pbQnutlZJGKicl1EHcViaiasVzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1676&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 运行程序，载入地图&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ctrl+shift+t，打开新一页终端，执行以下命令&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;cd&lt;/span&gt; ~/catkin_ws&lt;br/&gt;&lt;span&gt;source&lt;/span&gt; devel/setup.bash&lt;br/&gt;roslaunch grid_path_searcher demo.launch&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;画面切到 rivz，可以看到，程序自动载入了点云地图&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5483293556085919&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9RKPFKMpeMRSEv8f0Y9AWWtp9WEEUXxFnfjdJ37xsE9eu3gpvwgNspyGxLxibKVcfSulPAsH5QDDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1676&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;成功！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文中提到的安装包UAV_ROS.tar 、hw_1.tar，关注公众号：一口Linux，后台回复&lt;span&gt;&lt;strong&gt;ros&lt;/strong&gt;&lt;/span&gt;，即可获得。&lt;img data-ratio=&quot;0.1069182389937107&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9RKPFKMpeMRSEv8f0Y9AWWp8fuCawW875hkLwichfiaXuFThGp0ENEKqVibetH7DkViapqdjvLDRJ34A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;477&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>