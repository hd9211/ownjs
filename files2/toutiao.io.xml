<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b15079191076f98c975bb961389177ce</guid>
<title>[译] 2021 Go 趋势报告</title>
<link>https://toutiao.io/k/runaz5c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;markdown-body entry-content container-lg&quot; itemprop=&quot;text&quot;&gt;&lt;h1&gt;&lt;a id=&quot;user-content-2021-go-趋势报告&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#2021-go-趋势报告&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;2021 Go 趋势报告&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.jetbrains.com/author/ekaterina-zharovajetbrains-com&quot; rel=&quot;nofollow&quot;&gt;Ekaterina Zharova&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2021.2.3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在当今最流行的编程语言列表里，Go语言一直是名列前茅。众所周知 Go 语言现在很火，写 Go 代码也很有意思，Go 在社区也很受用户欢迎，主要是 Go 语言的速度块，效率高。除了这些众所周知的优点之外，我们期待发现 Go 更多不为人知的信息。为了发现更多的事实，我们在目前Go现有信息的基础上，进行了深入研究。我们邀请了Go语言专家、&lt;code&gt;Goland&lt;/code&gt;开发倡导者 &lt;code&gt;Florin Pățan&lt;/code&gt;  来发表他对Go语言发展趋势的看法。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/gocn/translator/blob/master/static/images/w6_the_state_of_Go/Go_8001611039611515.gif&quot;&gt;&lt;img src=&quot;/gocn/translator/raw/master/static/images/w6_the_state_of_Go/Go_8001611039611515.gif&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-在哪儿&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#在哪儿&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;在哪儿&lt;/h2&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-约110万go开发者&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#约110万go开发者&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;约110万Go开发者&lt;/h3&gt;
&lt;p&gt;总的来说，大约有 &lt;strong&gt;110万专业的 Go 开发者&lt;/strong&gt; 使用 Go 作为&lt;strong&gt;主要开发语言&lt;/strong&gt;。 如果我们把那些使用其他语言作为主力开发语言，但是把Go当作业余爱好的开发人员算在内的话，这一数字可能接近&lt;strong&gt;270万&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;就全球分布而言，居住在 &lt;strong&gt;亚洲&lt;/strong&gt; 的 Go 开发者最多，大约有57万开发者使用 Go 作为主要开发语言。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;专家分析&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这也正是我最期待的使用Go开发的地方。就Go用户数量而言，亚洲高居榜首，我认为主要原因是有大量的来自像腾讯、阿里巴巴、华为这些大公司的开发者。这些公司一般都有很多开发人员。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/gocn/translator/blob/master/static/images/w6_the_state_of_Go/1-2x.png&quot;&gt;&lt;img src=&quot;/gocn/translator/raw/master/static/images/w6_the_state_of_Go/1-2x.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-具体在哪里&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#具体在哪里&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;具体在哪里&lt;/h2&gt;
&lt;p&gt;下图显示了我们在 &lt;a href=&quot;https://www.jetbrains.com/lp/devecosystem-2020/go/&quot; rel=&quot;nofollow&quot;&gt;2020开发者生态调查&lt;/a&gt; 中调查的每个国家使用Go作为主要语言的开发者的分布情况（受访者最多可以选择3种主要语言）。&lt;strong&gt;中国&lt;/strong&gt; 的开发者集中度最高，有16%的中国开发者在使用Go。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;专家分析&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;看到中国排在榜首，我一点也不惊讶。我本以为俄罗斯会排在第二，美国会高一点，大概在前五位。&lt;/p&gt;
&lt;p&gt;中国之所以排在榜首，可能正是因为他们拥有的开发者数量最多。而且我认识的很多公司，比如 &lt;code&gt;PingCAP&lt;/code&gt;、腾讯和华为，都有很多开发者来支撑和构建他们的内部工具、基础设施和后端服务，这些服务都和微服务相结合。这似乎是中国排在榜首关键原因。&lt;/p&gt;
&lt;p&gt;我知道俄罗斯的 Go 社区非常棒，所以也难怪 Go 在那里很受欢迎。我对日本和乌克兰很好奇，因为我没想到他们会这么高，我以为德国和印度会更高些。记得四五年前我在柏林的时候，我认识的每一家创业公司都在使用 Go 。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/gocn/translator/blob/master/static/images/w6_the_state_of_Go/2-2x.png&quot;&gt;&lt;img src=&quot;/gocn/translator/raw/master/static/images/w6_the_state_of_Go/2-2x.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-行业洞察&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#行业洞察&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;行业洞察&lt;/h2&gt;
&lt;p&gt;Go 依然保持着开发者主要使用语言的 &lt;strong&gt;前10名&lt;/strong&gt;，根据&lt;a href=&quot;https://www.jetbrains.com/lp/devecosystem-2020/go/&quot; rel=&quot;nofollow&quot;&gt;2020开发者生态调查&lt;/a&gt;显示 Go 的份额约为9%。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;专家分析&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我认为 Go 会一直增长。人们通常不会把 Go 作为他们开始编程的入门语言，但是会从其他语言迁移过来，例如 &lt;code&gt;PHP&lt;/code&gt; &lt;code&gt;Ruby&lt;/code&gt;，但据我所知，主要从 &lt;code&gt;C++&lt;/code&gt; &lt;code&gt;C#&lt;/code&gt; 迁移过来。&lt;/p&gt;
&lt;p&gt;Go 相比 PHP 的优势是类型安全，因为 Go 是一门静态类型语言，而 PHP 是门动态类型语言。这就意味着编译器在运行时做了大量的工作来确保你写的代码能够编译并且正常运行。相比于 C++ ，Go 的优势是简单。在 Go 里面，一切都是那么简单。&lt;/p&gt;
&lt;p&gt;总的来说，Go 的特点就是与生俱来的速度快，无论是写代码还是运行时。一般来说，在不做任何特殊优化的情况下，采用 Go 语言你就能提高5-10倍的性能，这对公司来说是一个很重要的生产优势。同时 Go 也是一门简单的语言，很容易上手，很容易替换现有项目中的微服务。&lt;/p&gt;
&lt;p&gt;许多 IT 基础设施工具，如 &lt;code&gt;Kubernetes&lt;/code&gt;、&lt;code&gt;Docker&lt;/code&gt;和&lt;code&gt;Vault&lt;/code&gt;（举几个大型的例子）都是用 Go 构建的。因此虽然很多公司是使用 Java ，但是还是会有一个团队会用 Go，特别是为了来维护这些项目和给这些项目打补丁。这可能是 Go  采用率保持增长的另外一个原因。 这种技术在公共技术设施和部署中使用的越多，Go 就增长的越快。我认为接下来几年会有越来越多的人采用Go，我们将会看到大约有15%-20%的开发者会使用 Go 。特别是考虑到开发者生态调查中问的一个问题，“您打算在今后12个月内采用或迁移到其他语言吗？”，13%的受访者回答是Go。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/gocn/translator/blob/master/static/images/w6_the_state_of_Go/3-2x.png&quot;&gt;&lt;img src=&quot;/gocn/translator/raw/master/static/images/w6_the_state_of_Go/3-2x.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-go开发的软件类型&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#go开发的软件类型&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;Go开发的软件类型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Web 服务&lt;/strong&gt; 是使用 Go  最受欢迎的领域，根据 &lt;a href=&quot;https://www.jetbrains.com/lp/devecosystem-2020/go/&quot; rel=&quot;nofollow&quot;&gt;2020开发者生态调查&lt;/a&gt; 结果显示，其占有36%份额。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;专家分析&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;为什么是 web 服务，我认为主要原因是构建一个 API 服务非常快。他们不需要框架，就可以用 Go 快速启动和运行一个。&lt;/p&gt;
&lt;p&gt;我不认为这张图在未来会有很大变化，我真心希望看到 web 服务得到更多的分享，因为用 Go 开始一个web 服务确实很简单。&lt;/p&gt;
&lt;p&gt;对于实用小程序，我见过很多类似的，因为 Go 很容易快速写一个小应用来帮你处理大量的数据，写一个小的实用程序或需要消耗大量资源的一次性任务。越来越多的人采用&lt;code&gt;Docker&lt;/code&gt; 和&lt;code&gt;Kubernetes&lt;/code&gt;，就会有越来越多的人使用 Go,仅仅是因为他们都是用 Go 写的。任何类型的 DevOps 的工作都可以从 Go 中获益，因为它提供了类型安全和速度。与基础设施的云端交互很容易（Google、Amazon、Azure等），因为他们都有很好的 SDK 。我认为未来几年，当泛型到来时，我们还可以期待下 “Libraries / Frameworks” 的一些提升。&lt;/p&gt;
&lt;p&gt;系统软件——我认为随着越来越多的人开始使用像 Rust 这样的语言编写系统软件，这一数字将会下降。数据库也是如此。所以这大约6%市场，在未来这可能会变成一个商机。编程工具——我很惊讶它在列表中份额这么高，我非常感兴趣去了解一下 Go 有哪些编程工具。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/gocn/translator/blob/master/static/images/w6_the_state_of_Go/5-2x.png&quot;&gt;&lt;img src=&quot;/gocn/translator/raw/master/static/images/w6_the_state_of_Go/5-2x.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-使用go的顶级行业&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#使用go的顶级行业&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;使用Go的顶级行业&lt;/h2&gt;
&lt;p&gt;根据 &lt;a href=&quot;https://www.jetbrains.com/lp/devecosystem-2020/go/&quot; rel=&quot;nofollow&quot;&gt;2020开发者生态调查&lt;/a&gt; ，Go 程序员主要从事 &lt;strong&gt;IT 服务&lt;/strong&gt;，其次是 &lt;strong&gt;金融和金融科技&lt;/strong&gt;、&lt;strong&gt;云技术/云平台&lt;/strong&gt; 和其他行业。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;专家分析&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;金融和金融科技。这是我希望看到的，因为据我所知有相当多的银行已经开始采用 Go 或者正在广泛使用 Go 作为他们的基础设施。例如，&lt;a href=&quot;https://monzo.com/blog/2016/09/19/building-a-modern-bank-backend&quot; rel=&quot;nofollow&quot;&gt;来自英国的Monzo使用 Go 构建了他们整个银行系统&lt;/a&gt;。云计算和云平台也很有意义，因为它们对于使用 Go 编写的应用来说是很自然的。&lt;/p&gt;
&lt;p&gt;移动开发，这是意料之外的。Go 并没有好的移动开发历史。如果有什么不同的话，我希望大家使用 Go 来为移动程序提供网络服务或者后端服务，但仅此而已。&lt;/p&gt;
&lt;p&gt;有几个行业，我不认为 Go 的使用率会很快增加。比如，任何基于机器学习的东西，因为这仍然是 Python 的地盘。人们正在努力让机器学习在 Go 中变得受欢迎和变得更好，但是我认为至少要几年之后才会有一些结果。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/gocn/translator/blob/master/static/images/w6_the_state_of_Go/4-2x.png&quot;&gt;&lt;img src=&quot;/gocn/translator/raw/master/static/images/w6_the_state_of_Go/4-2x.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-go-工具&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#go-工具&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;Go 工具&lt;/h2&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-包管理&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#包管理&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;包管理&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Go Modules&lt;/strong&gt; 是 Go 开发者中最受欢迎的包管理工具。根据 &lt;em&gt;2020 开发者生态调查&lt;/em&gt; 其使用率从 &lt;a href=&quot;https://www.jetbrains.com/lp/devecosystem-2019/go/&quot; rel=&quot;nofollow&quot;&gt;2019&lt;/a&gt; 到41%上升到到 &lt;a href=&quot;https://www.jetbrains.com/lp/devecosystem-2020/go/&quot; rel=&quot;nofollow&quot;&gt;2020&lt;/a&gt; 的82%。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;专家分析&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我认为在某种程度上我们可能不得不停止问这个问题，因为 Go Modules已经被设置为标准默认模型，而且Go团队也想要弃用 &lt;code&gt;GOPATH&lt;/code&gt;。到那时，其他的所有的包管理工具都将会被淘汰。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/gocn/translator/blob/master/static/images/w6_the_state_of_Go/6-2x.png&quot;&gt;&lt;img src=&quot;/gocn/translator/raw/master/static/images/w6_the_state_of_Go/6-2x.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-go-路由&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#go-路由&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;Go 路由&lt;/h3&gt;
&lt;p&gt;根据 &lt;a href=&quot;https://www.jetbrains.com/lp/devecosystem-2020/go/&quot; rel=&quot;nofollow&quot;&gt;2020&lt;/a&gt; 和 &lt;a href=&quot;https://www.jetbrains.com/research/devecosystem-2018/go/&quot; rel=&quot;nofollow&quot;&gt;2018&lt;/a&gt; 的开发者生态调查显示，&lt;strong&gt;Gorilla / Mux&lt;/strong&gt; 和 &lt;strong&gt;标准库&lt;/strong&gt; 自2018年以来一直是使用最多的 Go 路由。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;专家分析&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;标准库之所以如此受欢迎，可能是因为每当你去Reddit、Slack或其他地方，人们通常都会建议你坚持使用标准库，只有在你真正需要的时候才使用其他东西。我使用&lt;code&gt;gorilla/mux&lt;/code&gt;，是因为它在标准库的基础上有更多的抽象，又不会牺牲太多的性能。也可能是因为它是最接近标准库的，而且它使得编写服务端更容易。总的来说，这种分布可能是我希望看到的。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/gocn/translator/blob/master/static/images/w6_the_state_of_Go/7-2x.png&quot;&gt;&lt;img src=&quot;/gocn/translator/raw/master/static/images/w6_the_state_of_Go/7-2x.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-5大web框架&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#5大web框架&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;5大web框架&lt;/h3&gt;
&lt;p&gt;根据 &lt;a href=&quot;https://www.jetbrains.com/lp/devecosystem-2020/go/&quot; rel=&quot;nofollow&quot;&gt;2020&lt;/a&gt; 和 &lt;a href=&quot;https://www.jetbrains.com/research/devecosystem-2018/go/&quot; rel=&quot;nofollow&quot;&gt;2018&lt;/a&gt; 的开发者生态调查显示，&lt;strong&gt;Gin&lt;/strong&gt; 的使用量自2018年以来几乎翻了一倍，而其他 web 框架基本保持稳定。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;专家分析&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Gin 在 web 上如此受欢迎，因为它是一个速度快的框架，而且也得到了很好的推荐。它也是最古老的框架之一。因为会有很多文档摆在那儿，很多用户已经在使用它和推荐它。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/gocn/translator/blob/master/static/images/w6_the_state_of_Go/8-2x.png&quot;&gt;&lt;img src=&quot;/gocn/translator/raw/master/static/images/w6_the_state_of_Go/8-2x.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-测试框架&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#测试框架&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;测试框架&lt;/h3&gt;
&lt;p&gt;使用 &lt;strong&gt;内置测试框架&lt;/strong&gt; 的比例从 &lt;a href=&quot;https://www.jetbrains.com/research/devecosystem-2018/go/&quot; rel=&quot;nofollow&quot;&gt;2018&lt;/a&gt; 64%下降到 &lt;a href=&quot;https://www.jetbrains.com/lp/devecosystem-2020/go/&quot; rel=&quot;nofollow&quot;&gt;2020&lt;/a&gt; 的44%，而使用其他测试框架的比例略有增长。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;专家分析&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;内置的测试框架比例很高是因为 Go 标准库有一个非常好的开箱即用的测试库。&lt;/p&gt;
&lt;p&gt;内置测试可能会下降主要是因为越来越多的人从其他语言(比如 PHP )转向这门语言，他们试图复制自己已有的测试习惯。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/gocn/translator/blob/master/static/images/w6_the_state_of_Go/9-2x.png&quot;&gt;&lt;img src=&quot;/gocn/translator/raw/master/static/images/w6_the_state_of_Go/9-2x.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-讨论最多的go工具和其他语言&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#讨论最多的go工具和其他语言&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;讨论最多的Go工具和其他语言&lt;/h2&gt;
&lt;p&gt;Go 经常在 IT 社区中被讨论，Stack Overflow 就是其中之一。我们从其 Q&amp;amp;A 单元获取数据来找出哪些标签与“Go”同时出现次数最多。其中有23种工具和两种语言（&lt;code&gt;MySQL&lt;/code&gt; 和 &lt;code&gt;PostgreSQL&lt;/code&gt;）。除了这些工具，还有与其他顶级语言的共存。纵轴表示标签出现的总次数，而横轴表示带有“Go”的标签的提及次数。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;专家分析&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我早料到&lt;code&gt; JSON&lt;/code&gt; 会是个问题，把 Go 的数据结构序列化和反序列化成&lt;code&gt; JSON&lt;/code&gt;确实是很不容易的，这可能就是 &lt;code&gt;JSON&lt;/code&gt;会如此醒目的原因。来自其他语言的人通常很难理解&lt;code&gt;struct&lt;/code&gt;，除非它们来自C++或C。&lt;/p&gt;
&lt;p&gt;基于&lt;code&gt;AWS&lt;/code&gt;本身的受欢迎程度，我认为&lt;code&gt;Amazon Web Services&lt;/code&gt;会有很多问题。现在现在为&lt;code&gt;Google App Engine&lt;/code&gt;开发 Go 应用程序更简单了，但以前并不是这样，所以才会有这么多问题。&lt;/p&gt;
&lt;p&gt;总而言之，Go社区是一个非常有趣且具有包容性的社区，你可以成为其中的一员。从不排斥新人，鼓励他们提出问题，探索语言。在一般的主题方面，泛型以及某些语言改进、编译器改进等都是经常讨论的话题。&lt;/p&gt;
&lt;p&gt;尤其是泛型，因为它是该语言最需要的特性之一，并且有大量的工作负载将受益于该特性。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/gocn/translator/blob/master/static/images/w6_the_state_of_Go/11-2x.png&quot;&gt;&lt;img src=&quot;/gocn/translator/raw/master/static/images/w6_the_state_of_Go/11-2x.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;/article&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f1ab739fd37e62813103eaa50b813d5f</guid>
<title>公司内U盘不能写入的解决方案</title>
<link>https://toutiao.io/k/55xb950</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;markdown-body mt-4&quot;&gt;
        &lt;h3 id=&quot;一背景&quot;&gt;一、背景&lt;/h3&gt;
&lt;p&gt;因为安全原因，公司的电脑安装了安全软件，开启启动后就把U盘写权限关闭了，博主长期挂载移动硬盘使用，对日常使用造成很大困扰。本文提供两种思路，可实现公司内电脑U盘的读写。&lt;/p&gt;
&lt;p&gt;注：本文只针对windows。&lt;/p&gt;
&lt;h3 id=&quot;二方法1手动修改本地组策略&quot;&gt;二、方法1：手动修改本地组策略&lt;/h3&gt;
&lt;p&gt;点击windows键，输入gpedit.msc，打开本地组策略编辑器，依次找到：计算机配置--&amp;gt; 管理模板 --&amp;gt; 系统 --&amp;gt; 可移动存储访问。找到：可移动磁盘:拒绝写入权限，如果是已开启状态，则编辑改为未配置或已禁用即可实现U盘写入。如果还是不行，把U盘拔掉重新插入即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/image-20210208161208393.png&quot; alt=&quot;image-20210208161208393&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;三方法2虚拟器映射smb远程访问&quot;&gt;三、方法2：虚拟器映射smb远程访问&lt;/h3&gt;
&lt;p&gt;上面方法1对于临时写入够用了， 如果想挂载U盘或移动硬盘长期使用，每次开机启动都要重新配置一遍，很是麻烦。由于公司内安全软件是管理员权限开启启动，不能阻止它将本地组策略中的可移动磁盘:拒绝写入权限给开启。那有什么办法可以绕过这个权限呢？&lt;/p&gt;
&lt;p&gt;答案就是虚拟机，开机启动时把U盘挂载到虚拟中，然后共享samba给宿主机，开启读写权限，宿主机就可以正常读写U盘中的内容了。&lt;/p&gt;
&lt;p&gt;博主安装的是VirtualBox虚拟机。第一步当然是安装软件及系统，推荐安装debian最小镜像，因为这个镜像包小而且安全性高。操作习惯和Ubuntu一样，详细安装过程及网络配置请参考其他文档。&lt;/p&gt;
&lt;h5 id=&quot;1安装virtualbox扩展启用usb30支持&quot;&gt;1、安装VirtualBox扩展，启用USB3.0支持。&lt;/h5&gt;
&lt;p&gt;默认VirtualBox是不支持USB3.0的，需要安装扩展才能支持。&lt;/p&gt;
&lt;p&gt;下载官网链接: &lt;a href=&quot;https://www.virtualbox.org/wiki/Downloads&quot;&gt;https://www.virtualbox.org/wiki/Downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;详细下载教程请参考：&lt;a href=&quot;https://blog.csdn.net/qzhn_/article/details/86365917&quot;&gt;https://blog.csdn.net/qzhn_/article/details/86365917&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装扩展包教程参考：&lt;a href=&quot;https://jingyan.baidu.com/article/3052f5a1b2dd39d6f21f862d.html&quot;&gt;https://jingyan.baidu.com/article/3052f5a1b2dd39d6f21f862d.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装完成，打开虚拟机USB设备配置，出现USB3.0即表示安装成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/image-20210208163042492.png&quot; alt=&quot;image-20210208163042492&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;2挂载u盘到虚拟机&quot;&gt;2、挂载U盘到虚拟机&lt;/h5&gt;
&lt;p&gt;虚拟机关机，打开配置，按以下步骤添加USB设备，USB控制器选择USB3.0。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/image-20210208163408809.png&quot; alt=&quot;image-20210208163408809&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动虚拟机，输入命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo fdisk -l
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;出现硬盘即为映射成功，记住红框中的Device名称&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/image-20210208163231638.png&quot; alt=&quot;image-20210208163231638&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;3配置虚拟机启动挂载&quot;&gt;3、配置虚拟机启动挂载&lt;/h5&gt;
&lt;p&gt;默认硬盘是不会自动挂载的，通过以下步骤配置开机自动挂载。&lt;/p&gt;
&lt;p&gt;（1）安装驱动：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install ntfs-3g
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(2) 编辑/etc/fstab, 再末尾加入如下内容就可以了，以下是我的配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/dev/sdb1       /mnt/move       ntfs-3g defaults,locale=zh_CN.UTF-8     0       0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启虚拟机，查看/mnt/move目录，看是不是正确列出U盘中的文件。&lt;/p&gt;
&lt;h5 id=&quot;3配置samba&quot;&gt;3、配置samba&lt;/h5&gt;
&lt;p&gt;Linux中安装samba配置项很多，一不小心就配置不对，这里推荐使用docker安装samba，我使用是的这个image：&lt;a href=&quot;https://github.com/dperson/samba&quot;&gt;https://github.com/dperson/samba&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（1）安装docker，推荐使用国内daocloud一键安装命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -sSL https://get.daocloud.io/docker | sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（2）docker启动samba，并支持开机启动：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo docker run -d \
    --name samba \
    --restart unless-stopped \
    -p 139:139 \
    -p 445:445 \
    -v /mnt/move:/mount \
    -d dperson/samba \
    -u &quot;youusername;yourpassword&quot; \
    -s &quot;移动硬盘;/mount/;yes;no;no;all;yourusername&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将命令中的用户名密码改成你自己的，执行启动，在宿主机的文件资源管理器中输入，192.168.56.101是我的虚拟机ip，查看自己的虚拟机ip使用命令：sudo ifconfig&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\\192.168.56.101
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提示出入用户名、密码。输入正确后进入弹出我们移动硬盘表示配置成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/image-20210208164925982.png&quot; alt=&quot;image-20210208164925982&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后可以右键“移动硬盘”，映射网络驱动器，即可当成本地磁盘使用。&lt;/p&gt;
&lt;h5 id=&quot;4配置虚拟机开机启动&quot;&gt;4、配置虚拟机开机启动&lt;/h5&gt;
&lt;p&gt;右击VirtualBox中的虚拟机，点击创建桌面快捷方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/image-20210208165241154.png&quot; alt=&quot;image-20210208165241154&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开桌面，右击快捷方式，点最下面的属性，编辑“目标”栏，配置成headless模式。即不打开VirtualBox，直接无界面启动虚拟机。将下面中VirtualBox路径和虚拟机ID改成你自己的，并保存。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;D:\Program Files\Oracle\VirtualBox\VBoxManage.exe&quot; startvm &quot;{7a1f224f-af3f-4850-bc39-20f76d83db83}&quot; --type headless
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后一步，将此快捷方式移动到，即可开启启动虚拟机。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Users\&amp;lt;your name&amp;gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;四总结&quot;&gt;四、总结&lt;/h3&gt;
&lt;p&gt;本文提供了两种解决公司内U盘不能写入的方法，第一种适合临时使用，第二种适合长期挂载U盘使用。你还有什么更好的方法吗，欢迎讨论。&lt;/p&gt;
&lt;p&gt;本文作者：&lt;strong&gt;木小丰&lt;/strong&gt;，美团Java高级工程师，不定期分享软件研发过程中的实践、思考。&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;https://lesofn.com/jie-jue-gong-si-nei-u-pan-bu-neng-xie-ru-de-wen-ti&quot;&gt;https://lesofn.com/jie-jue-gong-si-nei-u-pan-bu-neng-xie-ru-de-wen-ti&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公共号：Java研发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%B0%8F_1607785087313.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

    &lt;/article&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>baf9d7288663f2179bd7a28c6b6cc940</guid>
<title>Go 工程化（二）：项目目录结构</title>
<link>https://toutiao.io/k/9p2dvmm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;markdown-body&quot;&gt;&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;/&gt;序&lt;/h2&gt;&lt;p&gt;本系列为 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;amp;utm_medium=lailin.xyz&quot;&gt;Go 进阶训练营&lt;/a&gt; 笔记，预计 2021Q1 完成更新，访问 &lt;a href=&quot;https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/&quot;&gt;博客: Go 进阶训练营&lt;/a&gt; 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳&lt;/p&gt;&lt;p&gt;工程化这一节说简单看似简单，无非就是目录结构，代码分层，依赖注入等等。但是其中很多坑如果没踩过是不知道这里面的痛点的。除此之外这里面也会有很多架构的思想在里面，这也就是为什么我会把架构整洁之道的阅读笔记放在第一小节的原因。&lt;/p&gt;&lt;p&gt;接来下包含这一篇文章在内，我会先用几篇文章结合参考材料以及个人的理解整理一下毛老师课上讲的内容。然后恰好在这个课程前，我也在对我们之前的一些项目做重构，所以会再用一到两篇文章大概说一些我最后选择的方式，已经在实践过程中的一些取舍，就工程化这个事情来说大概原理上基本都是相通的，但是每个团队甚至每个人所面临的一些问题都各不相同，所以最后出来的东西肯定不是完全一致的。&lt;/p&gt;&lt;p&gt;注意，你如果是只是需要写一个脚本，或者是做一些简单的 demo 大可不必像文章接下来介绍的这样搞的这么麻烦，直接一个 main.go 简单快捷方便即可，但是如果你这是一个长期维护的项目，甚至涉及到的多个人之间的合作，那么接下来的几篇文章就不能错过了，可以仔细阅读，希望可以对你有所帮助。&lt;/p&gt;&lt;h2 id=&quot;Standard-Go-Project-Layout&quot;&gt;&lt;a href=&quot;#Standard-Go-Project-Layout&quot; class=&quot;headerlink&quot; title=&quot;Standard Go Project Layout&quot;/&gt;Standard Go Project Layout&lt;/h2&gt;&lt;p&gt;这一部分的内容主要来自于 github 的高星项目：&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/golang-standards/project-layout/blob/master/README_zh.md&quot;&gt;golang-standards/project-layout&lt;/a&gt; 通过这个我们可以大概的了解到在 Go 中一些约定俗成的目录含义，虽然这些不是强制性的，但是如果有去看官方的源码或者是一些知名的项目可以发现大多都是这么命名的，所以我们最好和社区保持一致，大家保持同样的语言。&lt;/p&gt;&lt;h3 id=&quot;cmd&quot;&gt;&lt;a href=&quot;#cmd&quot; class=&quot;headerlink&quot; title=&quot;/cmd&quot;/&gt;/cmd&lt;/h3&gt;&lt;p&gt;我们一般采用 &lt;code&gt;/cmd/[appname]/main.go&lt;/code&gt; 的形式进行组织&lt;/p&gt;&lt;ul&gt;&lt;li&gt;首先 cmd 目录下一般是项目的主干目录&lt;/li&gt;&lt;li&gt;这个目录下的文件&lt;strong&gt;不应该有太多的代码，不应该包含业务逻辑&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;main.go 当中主要做的事情就是负责程序的生命周期，服务所需资源的依赖注入等，其中依赖注入一般而言我们会使用一个依赖注入框架，这个主要看复杂程度，后续会有一篇文章单独介绍这个&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;internal&quot;&gt;&lt;a href=&quot;#internal&quot; class=&quot;headerlink&quot; title=&quot;/internal&quot;/&gt;/internal&lt;/h3&gt;&lt;p&gt;internal 目录下的包，不允许被其他项目中进行导入，这是在 Go 1.4 当中引入的 feature，会在编译时执行&lt;/p&gt;&lt;ul&gt;&lt;li&gt;所以我们一般会把项目文件夹放置到 internal 当中，例如 &lt;code&gt;/internal/app&lt;/code&gt;&lt;/li&gt;&lt;li&gt;如果是可以被其他项目导入的包我们一般会放到 pkg 目录下&lt;/li&gt;&lt;li&gt;如果是我们项目内部进行共享的包，而不期望外部共享，我们可以放到 &lt;code&gt;/internal/pkg&lt;/code&gt; 当中&lt;/li&gt;&lt;li&gt;注意 internal 目录的限制并不局限于顶级目录，在任何目录当中都是生效的&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;举个 🌰 下面的是我们当前的目录结构，其中的代码很简单，在 &lt;code&gt;t.go&lt;/code&gt; 当中导出了一个变量 &lt;code&gt;I&lt;/code&gt; 然后在 &lt;code&gt;a/cmd/a/main.go&lt;/code&gt; 和 &lt;code&gt;b/cmd/b/main.go&lt;/code&gt; 当中分别导入输出这个变量的值&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;❯ tree&lt;br/&gt;.&lt;br/&gt;├── a&lt;br/&gt;│   ├── cmd&lt;br/&gt;│   │   └── a&lt;br/&gt;│   │       └── main.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;&lt;br/&gt;│   └── internal&lt;br/&gt;│       └── pkg&lt;br/&gt;│           └── t&lt;br/&gt;│               └── t.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;&lt;br/&gt;└── b&lt;br/&gt;    └── cmd&lt;br/&gt;        └── b&lt;br/&gt;            └── main.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;我们可以发现， &lt;code&gt;a&lt;/code&gt; 目录下可以直接输出 &lt;code&gt;I&lt;/code&gt; 的值&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;❯ &lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt; run ./a/cmd/a/main.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;但是在 &lt;code&gt;b&lt;/code&gt; 目录下，编译器会直接报错说导入了 &lt;code&gt;a&lt;/code&gt; 的私有包&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;❯ &lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt; run ./b/cmd/b/main.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; command-line-arguments&lt;br/&gt;        b/cmd/b/main.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;: use of internal &lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; github.com/mohuishou/&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;-training/Week04/blog/&lt;span class=&quot;hljs-number&quot;&gt;02&lt;/span&gt;_project_layout/&lt;span class=&quot;hljs-number&quot;&gt;01&lt;/span&gt;_internal_example/a/internal/pkg/t not allowed&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;pkg&quot;&gt;&lt;a href=&quot;#pkg&quot; class=&quot;headerlink&quot; title=&quot;/pkg&quot;/&gt;/pkg&lt;/h3&gt;&lt;p&gt;一般而言，我们在 pkg 目录下放置可以被外部程序安全导入的包，对于不应该被外部程序依赖的包我们应该放置到 &lt;code&gt;internal&lt;/code&gt; 目录下， &lt;code&gt;internal&lt;/code&gt; 目录会有编译器进行强制验证&lt;/p&gt;&lt;ul&gt;&lt;li&gt;pkg 目录下的包一般会按照功能进行区分，例如 &lt;code&gt;/pkg/cache&lt;/code&gt; 、 &lt;code&gt;/pkg/conf&lt;/code&gt; 等&lt;/li&gt;&lt;li&gt;如果你的目录结构比较简单，内容也比较少，其实也可以不使用 &lt;code&gt;pkg&lt;/code&gt; 目录，直接把上面的这些包放在最上层即可&lt;/li&gt;&lt;li&gt;一般而言我们应用程序 app 在最外层会包含很多文件，例如 &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; &lt;code&gt;makefile&lt;/code&gt; &lt;code&gt;.gitignore&lt;/code&gt; 等等，这种时候顶层目录会很多并且会有点杂乱，建议还是放到 &lt;code&gt;/pkg&lt;/code&gt; 目录比较好&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;Kit-Project-Layout&quot;&gt;&lt;a href=&quot;#Kit-Project-Layout&quot; class=&quot;headerlink&quot; title=&quot;Kit Project Layout&quot;/&gt;Kit Project Layout&lt;/h2&gt;&lt;p&gt;kit 库其实也就是一些基础库&lt;/p&gt;&lt;ul&gt;&lt;li&gt;每一个公司正常来说应该&lt;strong&gt;有且仅有一个基础库项目&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;kit 库一般会包含一些常用的公共的方法，例如缓存，配置等等，比较典型的例子就是 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/go-kit/kit&quot;&gt;go-kit&lt;/a&gt;&lt;/li&gt;&lt;li&gt;kit 库必须具有的特点：&lt;ul&gt;&lt;li&gt;统一&lt;/li&gt;&lt;li&gt;标准库方式布局&lt;/li&gt;&lt;li&gt;高度抽象&lt;/li&gt;&lt;li&gt;支持插件&lt;/li&gt;&lt;li&gt;尽量减少依赖&lt;/li&gt;&lt;li&gt;持续维护&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;减少依赖和持续维护是我后面补充的，这一点其实很遗憾，我们部门刚进来的时候方向是对的也建立了一套基础库，然后大家都使用这同一套库，但是很遗憾，我们这一套库一是没人维护，二是没有一套机制来进行迭代，到现在很多团队和项目已经各搞各的了。&lt;br/&gt;这样其实会导致做很多重复工作以及后续的一些改动很难推进，前车之鉴，如果有类似的情况一定要在小火苗出来的时候先摁住，从大的角度来讲统一有时候比好用重要，不好用应该参与贡献而不是另起炉灶。&lt;/p&gt;&lt;h2 id=&quot;Service-Application-Project-Layout&quot;&gt;&lt;a href=&quot;#Service-Application-Project-Layout&quot; class=&quot;headerlink&quot; title=&quot;Service Application Project Layout&quot;/&gt;Service Application Project Layout&lt;/h2&gt;&lt;p&gt;在这一小节我们会先看到毛老师在课上讲解的他们的应用程序目录的迭代变化，然后说一些我最后的采用的目录结构以及里面的取舍，关于具体怎么演进来的当中遇到了什么问题，我们会在 Go 工程化这个系列的最后一篇文章详细说明。&lt;/p&gt;&lt;h3 id=&quot;api&quot;&gt;&lt;a href=&quot;#api&quot; class=&quot;headerlink&quot; title=&quot;/api&quot;/&gt;/api&lt;/h3&gt;&lt;p&gt;API 定义的目录，如果我们采用的是 grpc 那这里面一般放的就是 proto 文件，除此之外也有可能是 openapi/swagger 定义文件，以及他们生成的文件。&lt;/p&gt;&lt;p&gt;下面给出一个我现在使用的 api 目录的定义，其实和毛老师课上讲的类似，后面还有一篇文章会专门讲 api 的设计会讲到这里就不详细讲了&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;.&lt;br/&gt;└── api&lt;br/&gt;    └── product_name &lt;span class=&quot;hljs-comment&quot;&gt;// 产品名称&lt;/span&gt;&lt;br/&gt;        └── app_name &lt;span class=&quot;hljs-comment&quot;&gt;// 应用名称&lt;/span&gt;&lt;br/&gt;            └── v1   &lt;span class=&quot;hljs-comment&quot;&gt;// 版本号&lt;/span&gt;&lt;br/&gt;                └── v1.proto&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;config-s&quot;&gt;&lt;a href=&quot;#config-s&quot; class=&quot;headerlink&quot; title=&quot;/config(s)&quot;/&gt;/config(s)&lt;/h3&gt;&lt;p&gt;为什么加个(s) 是课上讲的还有参考材料中很多都叫 configs 但是我们习惯使用 config 但是含义上都是一样的&lt;br/&gt;这里面一般放置配置文件文件和默认模板&lt;/p&gt;&lt;h3 id=&quot;test&quot;&gt;&lt;a href=&quot;#test&quot; class=&quot;headerlink&quot; title=&quot;/test&quot;/&gt;/test&lt;/h3&gt;&lt;p&gt;额外的外部测试应用程序和测试数据。一般会放测试一些辅助方法和测试数据&lt;/p&gt;&lt;h3 id=&quot;服务类型&quot;&gt;&lt;a href=&quot;#服务类型&quot; class=&quot;headerlink&quot; title=&quot;服务类型&quot;/&gt;服务类型&lt;/h3&gt;&lt;p&gt;微服务中的 app 服务类型分为 4 类：interface、service、job、admin。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;interface: 对外的 BFF 服务，接受来自用户的请求，比如暴露了 HTTP/gRPC 接口。&lt;/li&gt;&lt;li&gt;service: 对内的微服务，仅接受来自内部其他服务或者网关的请求，比如暴露了 gRPC 接口只对内服务。&lt;/li&gt;&lt;li&gt;admin：区别于 service，更多是面向运营测的服务，通常数据权限更高，隔离带来更好的代码级别安全。&lt;/li&gt;&lt;li&gt;job: 流式任务处理的服务，上游一般依赖 message broker。&lt;/li&gt;&lt;li&gt;task: 定时任务，类似 cronjob，部署到 task 托管平台中。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://lailin.xyz/images/1612614638378-d00b94ac-f743-414e-bca2-b9d941da7902.png&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;这上面是毛老师课上讲解的类型，和我们常用的做法类似，但是有点区别，同样假设我们有一个应用叫 &lt;code&gt;myapp&lt;/code&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;myapp-api: 这个是对外暴露的 api 的服务，可以是 http, 也可以是 grpc&lt;/li&gt;&lt;li&gt;myapp-cron: 这个是定时任务&lt;/li&gt;&lt;li&gt;myapp-job: 这个用于处理来自 message 的流式任务&lt;/li&gt;&lt;li&gt;myapp-migration: 数据库迁移任务，用于初始化数据库&lt;/li&gt;&lt;li&gt;scripts/xxx: 一次性执行的脚本，有时候会有一些脚本任务&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;大多大同小异，主要是 BFF 层我们一般是一个独立的应用，不会放在同一个仓库里面，&lt;/p&gt;&lt;h3 id=&quot;项目布局-v1&quot;&gt;&lt;a href=&quot;#项目布局-v1&quot; class=&quot;headerlink&quot; title=&quot;项目布局 v1&quot;/&gt;项目布局 v1&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://lailin.xyz/images/1612615089844-dfc6a101-710e-42e4-983f-ea340676b5f4.png&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;项目的依赖路径为: model -&amp;gt; dao -&amp;gt; service -&amp;gt; api，model struct 串联各个层，直到 api 需要做 DTO 对象转换。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;model: 放对应“存储层”的结构体，是对存储的一一隐射。&lt;/li&gt;&lt;li&gt;dao: 数据读写层，数据库和缓存全部在这层统一处理，包括 cache miss 处理。&lt;/li&gt;&lt;li&gt;service: 组合各种数据访问来构建业务逻辑。&lt;/li&gt;&lt;li&gt;server: 依赖 proto 定义的服务作为入参，提供快捷的启动服务全局方法。&lt;/li&gt;&lt;li&gt;api: 定义了 API proto 文件，和生成的 stub 代码，它生成的 interface，其实现者在 service 中。&lt;/li&gt;&lt;li&gt;service 的方法签名因为实现了 API 的 接口定义，DTO 直接在业务逻辑层直接使用了，更有 dao 直接使用，最简化代码。&lt;/li&gt;&lt;li&gt;DO(Domain Object): 领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。缺乏 DTO -&amp;gt; DO 的对象转换。&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;v1-存在的问题&quot;&gt;&lt;a href=&quot;#v1-存在的问题&quot; class=&quot;headerlink&quot; title=&quot;v1 存在的问题&quot;/&gt;v1 存在的问题&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;没有 DTO 对象，model 中的对象贯穿全局，所有层都有&lt;ul&gt;&lt;li&gt;model 层的数据不是每个接口都需要的，这个时候会有一些问题&lt;/li&gt;&lt;li&gt;在上一篇文章中其实也反复提到了 “如果两段看似重复的代码，如果有不同的变更速率和原因，那么这两段代码就不算是真正的重复”&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;server 层的代码可以通过基础库干掉，提供统一服务暴露方式&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;项目布局-v2&quot;&gt;&lt;a href=&quot;#项目布局-v2&quot; class=&quot;headerlink&quot; title=&quot;项目布局 v2&quot;/&gt;项目布局 v2&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://lailin.xyz/images/1612615164024-9156a848-53f7-4324-963a-e7e4ae110424.png&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;app 目录下有 api、cmd、configs、internal 目录，目录里一般还会放置 README、CHANGELOG、OWNERS。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;internal:&lt;/strong&gt; 是为了避免有同业务下有人跨目录引用了内部的 biz、data、service 等内部 struct。&lt;ul&gt;&lt;li&gt;如果存在一个仓库多个应用，那么可以在 internal 里面进行分层，例如 &lt;code&gt;/internal/app&lt;/code&gt; , &lt;code&gt;/internal/job&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;biz&lt;/strong&gt;: 业务逻辑的组装层，类似 DDD 的 domain 层，data 类似 DDD 的 repo，repo 接口在这里定义，使用依赖倒置的原则。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;data&lt;/strong&gt;: 业务数据访问，包含 cache、db 等封装，实现了 biz 的 repo 接口。我们可能会把 data 与 dao 混淆在一起，data 偏重业务的含义，它所要做的是将领域对象重新拿出来，我们去掉了 DDD 的 infra 层。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;service&lt;/strong&gt;: 实现了 api 定义的服务层，类似 DDD 的 application 层，处理 DTO 到 biz 领域实体的转换(DTO -&amp;gt; DO)，同时协同各类 biz 交互，但是不应处理复杂逻辑。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;PO(Persistent Object): 持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么数据表中的每个字段（或若干个）就对应 PO 的一个（或若干个）属性。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;示例可以参考 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/go-kratos/examples/tree/main/blog&quot;&gt;kratos v2 的 example&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;我的项目布局&quot;&gt;&lt;a href=&quot;#我的项目布局&quot; class=&quot;headerlink&quot; title=&quot;我的项目布局&quot;/&gt;我的项目布局&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;.&lt;br/&gt;├── api&lt;br/&gt;├── cmd&lt;br/&gt;│   └── app&lt;br/&gt;├── config&lt;br/&gt;├── internal&lt;br/&gt;│   ├── domain&lt;br/&gt;│   ├── repo&lt;br/&gt;│   ├── service&lt;br/&gt;│   └── usecase&lt;br/&gt;└── pkg&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;internal:&lt;/strong&gt; 是为了避免有同业务下有人跨目录引用了内部的对象&lt;/p&gt;&lt;h2 id=&quot;应该避免的坏习惯&quot;&gt;&lt;a href=&quot;#应该避免的坏习惯&quot; class=&quot;headerlink&quot; title=&quot;应该避免的坏习惯&quot;/&gt;应该避免的坏习惯&lt;/h2&gt;&lt;h3 id=&quot;src&quot;&gt;&lt;a href=&quot;#src&quot; class=&quot;headerlink&quot; title=&quot;/src&quot;/&gt;/src&lt;/h3&gt;&lt;p&gt;一般而言，在 Go 项目当中不应该出现 src 目录，Go 和 Java 不同，在 Go 中每一个目录都是一个包，每一个包都是一等公民，我们不需要将项目代码放到 src 当中，不要用写其他语言的方式来写 Go&lt;/p&gt;&lt;h3 id=&quot;utils，common&quot;&gt;&lt;a href=&quot;#utils，common&quot; class=&quot;headerlink&quot; title=&quot;utils，common&quot;/&gt;utils，common&lt;/h3&gt;&lt;p&gt;不要在项目中出现 utils 和 common 这种包，如果出现这种包，因为我们并不能从包中知道你这个包的作用，长久之后这个包就会变成一个大杂烩，所有东西都往这里面扔。&lt;br/&gt;有的同学这个时候会问说，那我们的工具函数应该放到哪里？怎么放？&lt;br/&gt;举个例子，我们当前使用 &lt;code&gt;gin&lt;/code&gt; 作为路由框架，但是 &lt;code&gt;gin&lt;/code&gt; 的 handler 注册其实不是很方便，所以我们做了一层封装，这个时候这个工具方法我们一般放在 &lt;code&gt;/pkg/ginx&lt;/code&gt; 目录下，表示这个是对 &lt;code&gt;gin&lt;/code&gt; 增强的包，不直接使用 &lt;code&gt;gin&lt;/code&gt; 作为包名的原因是因为我们在项目中也会引用 &lt;code&gt;gin&lt;/code&gt; 相同的命名一个是会导致误解，另一个是在同时导入的时候也会需要去进行重命名会比较麻烦&lt;/p&gt;&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;/&gt;总结&lt;/h2&gt;&lt;p&gt;关于项目目录结构这种真的算是见仁见智，不同的理论有不同的方法，但是我觉得有两件事比较重要，就服务应用而言需要灵活应用，就基础库而言一定要统一，做的好不好和要不要做是两件事情，如果因为当前做的不够好而不做，那么越到后面就越做不了。&lt;br/&gt;下一篇文章会讲一讲依赖注入框架 wire 的使用与最佳(?)实践&lt;/p&gt;&lt;h2 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;/&gt;参考文献&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;amp;utm_medium=lailin.xyz&quot;&gt;Go 进阶训练营-极客时间&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/golang-standards/project-layout/blob/master/README_zh.md&quot;&gt;golang-standards/project-layout · GitHub&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html&quot;&gt;Package Oriented Design&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://golang.org/doc/go1.4#internalpackages&quot;&gt;Go 1.4 Release Notes - The Go Programming Language&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/&quot;&gt;I’ll take pkg over internal&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1&quot;&gt;https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;关注我获取更新&quot;&gt;&lt;a href=&quot;#关注我获取更新&quot; class=&quot;headerlink&quot; title=&quot;关注我获取更新&quot;/&gt;关注我获取更新&lt;/h2&gt;&lt;p&gt;看到这里了还不关注点赞走一波&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://lailin.xyz&quot;&gt;博客&lt;/a&gt; 可以订阅 RSS，也可以点击首页通过 webpush 订阅浏览器消息&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/mohuishou&quot;&gt;Github&lt;/a&gt; Follow me&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://www.zhihu.com/people/mo-hui-shou-76&quot;&gt;知乎&lt;/a&gt; 关注账号，顺便点个 👍&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://toutiao.io/subjects/387401?f=new&quot;&gt;开发者头条&lt;/a&gt; 订阅订阅号，顺便点个 👍&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b3b8e20cca6b893e339f25e7c46d07f1</guid>
<title>闲鱼如何一招保证推荐流稳如泰山</title>
<link>https://toutiao.io/k/mmzvygh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;闲鱼是阿里巴巴旗下品牌，是中国最大的闲置交易平台，于2014年成立至今，是继淘宝、天猫之后，阿里巴巴正在催生的第三个万亿级平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;闲鱼技术部不断在驱动业务变革，通过创新追寻更多价值。从出版书籍、峰会发声，到开源专利、海外传播。闲不住，上闲鱼——技术团队对极致的探索与深耕是我们的底气。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 立即加入 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1、招&lt;/span&gt;&lt;span&gt;&lt;strong&gt;项目经理PMO&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;/客户端/服务端/前端/数据+算法/质量工程师&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、发简历给guicai.gxy@alibaba-inc.com&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、您还可以在头条、知乎、掘金、facebook、twitter找到我们&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9e1a78c83b0eeb5c13fb48149fe34c44</guid>
<title>实践持续交付一年后的反思</title>
<link>https://toutiao.io/k/rv1k3vs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img data-ratio=&quot;0.6671875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FBPFm28kpSzOvQboiaKFCO7icxatGrMuh2iaLseFI4n7pXHuVug9JWP8rqjAIfTicfhGjvMUyZsoaDibIfAl4HAl1Qg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;感谢领导们，让我有机会在团队里实践持续交付。因为在3年前我就已经希望有这样的机会。了解我的人都知道这是肺腑之言，我个人是不会拍马屁的人。&lt;/p&gt;&lt;p&gt;我先申明，我不是那种为了持续交付而持续交付的人，我深刻地知道我实践持续交付的目的。持续交付只是手段。&lt;/p&gt;&lt;p&gt;之前分享过一些持续交付的实践经验。没读过的读者可以在翻下之前的博客。这篇博客主要是反思。&lt;/p&gt;&lt;p&gt;为什么要反思？是因为从上周六到这周四，生产环境出现了三次事故。触目惊心的数字。这还是在我们自动化程度、版本化很高的情况下发生的。&lt;/p&gt;&lt;p&gt;朋友问我：咋最近这么多事故？&lt;/p&gt;&lt;p&gt;这是一个好问题。&lt;/p&gt;&lt;p&gt;我问自己，为什么是最近才发生？想想最近发生的事故，似乎都是必然的。最近不发生，将来也会以某种形式发生。&lt;/p&gt;&lt;p&gt;接着是为什么这么多？这个问题的答案并不重要。我们应该问为什么会发生，为什么离我们高可用的目标那么远？&lt;/p&gt;&lt;p&gt;原因很多。我总结有以下几点：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;主干开发后，没有code review，或者code review做得不够好。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;采用feature toggle后，只测试了feature toggle开的时候，没有测试feature toggle关的时候。&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;当实现自动化构建和自动化部署后，要想交付得更快，测试资源将会成为瓶颈。但是我们不能简单的通过加人来解决这个问题。&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;当采用主干开发的方式，又没有code review时，开发人员变更代码会变得很“随意”。实现feature时，一堆堆的代码的push到主干，等待自动化打包完成，然后部署到开发环境进行联调。到月底，所有的feature再统一的提测。&lt;/span&gt;&lt;span&gt;&lt;span&gt;5.&lt;/span&gt;工程化程度高的同时，人员的能力也要跟上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;以上是这些问题，并不是一个个独立的问题。它们是相互关联相互影响的。不可能采用先解决问题一，再解决问题二，逐步接近法来解决。因为它们也只是表象。需要找到根本问题。&lt;/p&gt;&lt;p&gt;如果硬是要我说根本问题是什么，我觉得是反馈周期太慢了。目前的反馈周期是按月来算的。程序员在月初写的代码，只能在月底才能得到反馈。&lt;/p&gt;&lt;p&gt;反馈包括：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;代码质量层面的反馈&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;测试层面的反馈&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;业务价值层面的反馈&lt;/span&gt;&lt;/p&gt;&lt;p&gt;接下来的问题是，如何验证我的结论是否正确呢？这时，我想起了大野耐一的《现场管理》。只有深入现场，才有可能找到问题的本质。软件工程的现场是什么呢？是一个好问题。将来再写。&lt;/p&gt;&lt;h3&gt;小结&lt;/h3&gt;&lt;p&gt;虽然，基于一切版本化，一切自动化的原则，技术上实现了自动化构建和自动化部署，但是离真正的业务上的持续交付还很远。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.939297124600639&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSxXYiaE2vFz3pUQyI7ia4TQ7MbvWRAgJPAdsXSKNyezq2hs4hkpuUYiafycXNcdmTxCXEhMSAcAeXe5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;313&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>