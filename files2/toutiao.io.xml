<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3943f00f34fad794ad60b273b92948cb</guid>
<title>如何使用Go调用Kubernetes API？</title>
<link>https://toutiao.io/k/ctnjr3u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;官方的Kubernetes Go客户端装载了高级抽象——Clientset、Informers、Cache、Scheme、Discovery，哦，天哪！当我尝试在没有学习移动部分的情况下使用它时，我遇到了大量的新概念。这是一次不愉快的经历，但更重要的是，它削弱了我在代码中做出明智决定的能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;因此，我决定通过对客户端组件的彻底研究来解开这个谜。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;但是从哪里开始呢？在剖析client-go本身之前，了解它的两个主要依赖项可能是一个好主意，k8s.io/api和k8s.io/apimachinery模块。这将简化主要任务，但这不是唯一的好处。&lt;/span&gt;&lt;span&gt;这两个模块被分离出来是有原因的——它们不仅可以被客户端使用，也可以被服务器端使用，或者被处理Kubernetes对象的任何其他软件使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzC9vlNS5jTmI3X1lJiaicP0I5xhIIhlIRZE5OVDzdJofMOvicUKCKEbt43r6XFK4wDl8H7sCBvzFgFuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4722222222222222&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;1&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;API资源、类和对象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;首先，快速&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg5Mjc3MjIyMA==&amp;amp;mid=2247544647&amp;amp;idx=2&amp;amp;sn=721d6dcfc8f9eb6e5f4c95b528757375&amp;amp;chksm=c03b6554f74cec42de34bfdba9f0c2424726fbaf02b7cf8fcc98312c11a72e78072be01d4db6&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;回顾一下&lt;/a&gt;。熟悉以下概念对进一步讨论的成功至关重要：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;资源类型——一个由Kubernetes API端点服务的实体：Pod、Deployment、ConfigMap等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;API组——资源类型被组织成版本化的逻辑组：apps/v1、batch/v1、storage.k8s.io/v1beta1等等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对象——一个资源实例——每个API端点都处理特定资源类型的对象。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;类——API返回或接受的每个对象都必须符合一个对象模式——由其类型定义的属性的特定组合Pod、Deployment、ConfigMap等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;同样重要的是要区分广义对象和Kubernetes的“一级”对象——像Pod、Service或Secret这样的持久实体，它们作为集群的意图的记录。虽然为了序列化和反序列化，每个API对象都必须有一个API版本和类型属性，但并不是每个API对象都是“一级”Kubernetes对象。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzC9vlNS5jTmI3X1lJiaicP0I58BchNCCxpgYbJZg4tAeXLK57fdIo5zBibLOOZiaibw6aDmhvBmrADIibxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5287037037037037&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;2&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;k8s.io/api模块&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Go是一种静态类型的编程语言。那么，与Pod、ConfigMap、Secret和其他一级Kubernetes对象对应的所有结构在哪里呢？对，在k8s.io/api。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;尽管命名松散，k8.io/api模块似乎只用于API类型定义。它充满了固定结构，与我们都知道和喜爱的YAML体现的那些内容非常相似：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;  &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  appsv1 &lt;span&gt;&quot;k8s.io/api/apps/v1&quot;&lt;/span&gt;&lt;br/&gt;  corev1 &lt;span&gt;&quot;k8s.io/api/core/v1&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  deployment := appsv1.Deployment{&lt;br/&gt;    Spec: appsv1.DeploymentSpec{&lt;br/&gt;      Template: corev1.PodTemplateSpec{&lt;br/&gt;        Spec: corev1.PodSpec{&lt;br/&gt;          Containers: []corev1.Container{&lt;br/&gt;            { Name:  &lt;span&gt;&quot;web&quot;&lt;/span&gt;, Image: &lt;span&gt;&quot;nginx:1.21&quot;&lt;/span&gt; },&lt;br/&gt;          },&lt;br/&gt;        },&lt;br/&gt;      },&lt;br/&gt;    },&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  fmt.Printf(&lt;span&gt;&quot;%#v&quot;&lt;/span&gt;, &amp;amp;deployment)&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这个模块不仅定义了顶层的Kubernetes对象，就像上面的部署一样，还为它们的内部属性定义了许多辅助类型：&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;// PodSpec is a description of a pod.&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; PodSpec struct {&lt;br/&gt;  Volumes []Volume `json:&lt;span&gt;&quot;volumes,omitempty&quot;&lt;/span&gt; patchStrategy:&lt;span&gt;&quot;merge,retainKeys&quot;&lt;/span&gt; patchMergeKey:&lt;span&gt;&quot;name&quot;&lt;/span&gt; protobuf:&lt;span&gt;&quot;bytes,1,rep,name=volumes&quot;&lt;/span&gt;`&lt;br/&gt;  &lt;br/&gt;  InitContainers []Container `json:&lt;span&gt;&quot;initContainers,omitempty&quot;&lt;/span&gt; patchStrategy:&lt;span&gt;&quot;merge&quot;&lt;/span&gt; patchMergeKey:&lt;span&gt;&quot;name&quot;&lt;/span&gt; protobuf:&lt;span&gt;&quot;bytes,20,rep,name=initContainers&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;br/&gt;  Containers []Container `json:&lt;span&gt;&quot;containers&quot;&lt;/span&gt; patchStrategy:&lt;span&gt;&quot;merge&quot;&lt;/span&gt; patchMergeKey:&lt;span&gt;&quot;name&quot;&lt;/span&gt; protobuf:&lt;span&gt;&quot;bytes,2,rep,name=containers&quot;&lt;/span&gt;`&lt;br/&gt;&lt;br/&gt;  EphemeralContainers []EphemeralContainer `json:&lt;span&gt;&quot;ephemeralContainers,omitempty&quot;&lt;/span&gt; patchStrategy:&lt;span&gt;&quot;merge&quot;&lt;/span&gt; patchMergeKey:&lt;span&gt;&quot;name&quot;&lt;/span&gt; protobuf:&lt;span&gt;&quot;bytes,34,rep,name=ephemeralContainers&quot;&lt;/span&gt;`&lt;br/&gt;&lt;br/&gt;  RestartPolicy RestartPolicy `json:&lt;span&gt;&quot;restartPolicy,omitempty&quot;&lt;/span&gt; protobuf:&lt;span&gt;&quot;bytes,3,opt,name=restartPolicy,casttype=RestartPolicy&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;br/&gt;  ...&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Kubernetes中定义的所有结构k8s.io/api模块自带JSON和Protobuf注解。但要注意：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;专业提示&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：如果你去阅读源码，你会看到k8s.io/apimachery通过对提供的对象调用标准的json.marshal()来实现JSON的序列化。因此，不要害怕，只要需要转储API对象，就使用json.Marshal()。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;总结一下，k8s.io/api模块：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;3&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;k8s.io/apimachinery模块&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;不像简单的k8s.io/api模块，k8s.io/apimachery模块是相当复杂的。README[2]将其目的描述为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这个库是服务器和客户端使用Kubernetes API基础设施的共享依赖项，不需要直接的类型依赖项。它的第一批消费者是k8s.io/kubernetes、k8s.io/client-go、k8s.io/apiserver。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;要在一篇文章中涵盖apimachinery模块的所有职责是很困难的。因此，我将讨论这个模块中最常见的包、类型和功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;有用的结构和接口&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;k8s.io/api模块专注于具体的高级类型，如Deployment、Secret、Pod，k8s.io/apimachery是低层但更通用的数据结构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;例如，Kubernetes对象的所有这些公共属性：apiVersion、kind、name、uid、ownerReferences、creationTimestamp等。如果我要构建自己的Kubernetes自定义资源，我就不需要自己为这些属性定义数据类型——这要感谢apimachery模块。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;k8s.io/apimachery/pkg/apis/meta包定义了两个方便的结构体：TypeMeta和ObjectMeta，它们可以嵌入到用户定义的结构体中，使其看起来像任何其他Kubernetes对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;此外，TypeMeta和ObjectMeta结构实现了meta.Type和meta.Object接口，可用于以通用方式指向任何兼容对象。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49537037037037035&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzC9vlNS5jTmI3X1lJiaicP0I5MHlxKlAA7VCpT4spaFGHVias6wI0zlxGGiaiaStOzKGYuJJ1fsk8kJD7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在apimachery模块中定义的另一个方便的类型是接口runtime.Object。由于其简单的定义，它可能看起来毫无用处：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;// pkg/runtime&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Object interface {&lt;br/&gt;  GetObjectKind() schema.ObjectKind&lt;br/&gt;  DeepCopyObject() Object&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;但实际上，它被用得很多！Kubernetes的代码是在Go获得真正泛型支持之前很久编写的。因此，runtime.Object很像传统的接口——它是一个泛型接口，在代码库中广泛地进行类型断言和类型切换。而实际的类型可以通过检查底层对象的类型来获得。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;runtime.Object实例可以指向任何具有kind属性的对象——成熟的Kubernetes对象、不携带元数据的更简单的API资源，或者具有定义良好的对象方案的任何其他类型的对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意，虽然看起来相似，但meta.Object不能安全地向下转换到相应的Kubernetes对象，因为它的结构偏移量不为零。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;更有用的apimachery类型：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;PartialObjectMetadata结构——meta.TypeMeta和meta.ObjectMeta作为一种通用的方法来表示任何具有元数据的对象。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;APIVersions、APIGroupList、APIGroup结构体——还记得kubectl get的&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg5Mjc3MjIyMA==&amp;amp;mid=2247544676&amp;amp;idx=2&amp;amp;sn=a5584d8a3101e59a8ef2bd5878f20708&amp;amp;chksm=c03b6577f74cec61efe3303d911894c6e886e9f840ce45dd2ecc1a16f0cbbdcd5698a63fcd41&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;API探索练习吗&lt;/a&gt;？原始API这些和类似的结构用于Kubernetes，API资源的类型，但不是Kubernetes对象（例如，它们有kind和apiVersion属性，但没有真正的Object元数据）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;GetOptions、ListOptions、UpdateOptions等等——这些结构体代表了客户端对资源的相应动作的参数。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;GroupKind、GroupVersionKind、GroupResource、GroupVersionResource等——简单的数据传输对象，包含组、版本、类型或资源字符串的元组。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在讨论Scheme和RESTMapper之前，请记住GroupVersionKind和GroupVersionResource——他们的知识将派上用场。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;非结构化的结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;是的，你没听错。撇开玩笑不谈，它是另一种重要且广泛使用的数据类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;使用固定k8s.io/api类型处理Kubernetes对象很方便，但如果：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;你需要以通用的方式使用Kubernetes对象？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;你不想或不能依赖于API模块？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;你需要使用API模块中没有定义的自定义资源？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;非结构化，用于救援的非结构化结构！这个结构体允许没有注册Go结构体的对象被操作为通用的JSON类对象：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;type&lt;/span&gt; Unstructured struct {&lt;br/&gt;  // Object is a JSON compatible map with&lt;br/&gt;  // string, &lt;span&gt;float&lt;/span&gt;, int, bool, []interface{}, or&lt;br/&gt;  // map[string]interface{} children.&lt;br/&gt;  Object map[string]interface{}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// And &lt;span&gt;for&lt;/span&gt; the list of objects you can &lt;br/&gt;// use the UnstructuredList struct.&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; UnstructuredList struct {&lt;br/&gt;  Object map[string]interface{}&lt;br/&gt;&lt;br/&gt;  Items []Unstructured&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;实际上，这两个结构只是map[string]interface{}。不过，它们附带了一堆方便的方法，简化了嵌套属性访问和JSON序列化/反序列化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;示例：https://github.com/iximiuz/client-go-examples/blob/5b220c4572d65ea8bf0ad68e369e015902e7521c/crud-dynamic-simple/main.go#L36&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;类型转换——非结构化到类型化，反之亦然&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;自然的，需要将非结构化对象转换为具体k8s.io/api类型（反之亦然）。runtime.UnstructuredConverter接口及其默认实现DefaultUnstructuredConverter可以帮助你：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;type&lt;/span&gt; UnstructuredConverter interface {&lt;br/&gt;  ToUnstructured(obj interface{}) (map[string]interface{}, error)&lt;br/&gt;  FromUnstructured(u map[string]interface{}, obj interface{}) error&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;示例：https://github.com/iximiuz/client-go-examples/tree/main/convert-unstructured-typed&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对象序列化为JSON、YAML或Protobuf&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在处理来自静态类型语言的API时，另一项乏味的任务是将数据结构编组和解组到它们的连线表示中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;大量的apimachery代码都用于此任务‍‍：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;// pkg/runtime&lt;br/&gt;&lt;br/&gt;// Encoder writes objects to a serialized form&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Encoder interface {&lt;br/&gt;  Encode(obj Object, w io.Writer) error&lt;br/&gt;  Identifier() Identifier&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// Decoder attempts to load an object from data.&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Decoder interface {&lt;br/&gt;  Decode(&lt;br/&gt;    data []byte,&lt;br/&gt;    defaults *schema.GroupVersionKind,&lt;br/&gt;    into Object&lt;br/&gt;  ) (Object, *schema.GroupVersionKind, error)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Serializer interface {&lt;br/&gt;  Encoder&lt;br/&gt;  Decoder&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;注意到上面的代码片段中的这些对象了吗？是的，这些是runtime.Object，也就是Kind-able接口实例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;例子:&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;https://github.com/iximiuz/client-go-examples/tree/main/serialize-typed-json&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;https://github.com/iximiuz/client-go-examples/tree/main/serialize-typed-yaml&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;https://github.com/iximiuz/client-go-examples/tree/main/serialize-unstructured-json&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;https://github.com/iximiuz/client-go-examples/tree/main/serialize-unstructured-yaml&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;模式和RESTMapper&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;runtime.Schema在使用client-go时，模式概念随处出现，特别是在编写处理自定义资源的控制器（或操作符）时。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;我花了一段时间才明白它的目的。但是，按照正确的顺序处理事情会有所帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;考虑一下非结构化到类型化转换的潜在实现：有一个类似json的对象，以及一些具体k8s.io/api类型需要从它创建。也许，第一步就是要弄清楚如何使用kind字符串创建一个空的类型化对象实例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;一个简单的方法可能看起来像一个巨大的switch语句，覆盖所有可能的类型（实际上是API组）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;import (&lt;br/&gt;  appsv1 &lt;span&gt;&quot;k8s.io/api/apps/v1&quot;&lt;/span&gt;&lt;br/&gt;  corev1 &lt;span&gt;&quot;k8s.io/api/core/v1&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func New(apiVersion, kind string) runtime.Object {&lt;br/&gt;  switch (apiVersion + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + kind) {  &lt;br/&gt;  &lt;span&gt;case&lt;/span&gt;: &lt;span&gt;&quot;v1/Pod&quot;&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;corev1.Pod{}&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt;: &lt;span&gt;&quot;apps/v1/Deployment&quot;&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;appsv1.Deployment{}&lt;br/&gt;  }&lt;br/&gt;  ...&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;更聪明的方法是使用反射。不是开关，而是映射[字符串]反射。类型可以为所有注册类型维护：&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;type&lt;/span&gt; Registry struct {&lt;br/&gt;  map[string]reflect.Type types&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (r *Registry) Register(apiVersion, kind string, typ reflect.Type) {&lt;br/&gt;  r.types[apiVersion + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + kind] = typ&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (r *Registry) New(apiVersion, kind string) runtime.Object {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; r.types[apiVersion + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + kind].New().(runtime.Object)&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这种方法的优点是不需要生成代码，并且可以在运行时添加新的类型映射。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;现在，考虑一个反序列化问题：需要将一段YAML或JSON转换为一个类型化对象。第一步——对象创建——将非常类似。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;事实证明，通过API组和类型创建空对象是一项非常频繁的任务，以至于它在apimachery模块——运行时中获得了自己的模块——runtime.Schema：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;// Scheme defines methods &lt;span&gt;for&lt;/span&gt; serializing and deserializing API objects, a &lt;span&gt;type&lt;/span&gt;&lt;br/&gt;// registry &lt;span&gt;for&lt;/span&gt; converting group, version, and kind information to and from Go&lt;br/&gt;// schemas, and mappings between Go schemas of different versions. &lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Scheme struct {&lt;br/&gt;  gvkToType map[schema.GroupVersionKind]reflect.Type&lt;br/&gt;  &lt;br/&gt;  typeToGVK map[reflect.Type][]schema.GroupVersionKind&lt;br/&gt;  &lt;br/&gt;  unversionedTypes map[reflect.Type]schema.GroupVersionKind&lt;br/&gt;  &lt;br/&gt;  unversionedKinds map[string]reflect.Type&lt;br/&gt;&lt;br/&gt;  ...&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;runtime.Scheme结构就是这样一个注册表，它包含了所有Kubernetes对象的kind到type和type到kind的映射。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;记住，GroupVersionKind只是一个元组，即DTO结构，对吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;runtime.Scheme结构实际上是非常强大的，它有一大堆方法和实现一些基本的接口，如：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;// ObjectTyper contains methods &lt;span&gt;for&lt;/span&gt; extracting &lt;br/&gt;// the APIVersion and Kind of objects.&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; ObjectTyper interface {&lt;br/&gt;  ObjectKinds(runtime.Object) ([]schema.GroupVersionKind, bool, error)&lt;br/&gt;  Recognizes(gvk schema.GroupVersionKind) bool&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// ObjectCreater contains methods &lt;span&gt;for&lt;/span&gt; instantiating&lt;br/&gt;// an object by kind and version.&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; ObjectCreater interface {&lt;br/&gt;  New(kind schema.GroupVersionKind) (out Object, err error)&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;然而，runtime.Schema不是万能的。它有从kind到type的映射，但是如果不是只有资源名已知而不是类型呢?&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这就是RESTMapper的作用所在：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;type&lt;/span&gt; RESTMapper interface {&lt;br/&gt;  // KindFor takes a partial resource and returns the single match.  Returns an error &lt;span&gt;if&lt;/span&gt; there are multiple matches&lt;br/&gt;  KindFor(resource schema.GroupVersionResource) (schema.GroupVersionKind, error)&lt;br/&gt;&lt;br/&gt;  // KindsFor takes a partial resource and returns the list of potential kinds &lt;span&gt;in&lt;/span&gt; priority order&lt;br/&gt;  KindsFor(resource schema.GroupVersionResource) ([]schema.GroupVersionKind, error)&lt;br/&gt;&lt;br/&gt;  ...&lt;br/&gt;  &lt;br/&gt;  ResourceSingularizer(resource string) (singular string, err error)&lt;br/&gt;}&lt;/section&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;RESTMapper也是某种注册表。但是，它维护资源到种类的映射。因此，向映射器提供一个像apps/v1/Deployment这样的字符串，就会得到API Group apps/v1和部署类型。RESTMapper还可以处理资源快捷方式和奇点化: po、pod和pods可以注册为相同资源的别名。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.487962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzC9vlNS5jTmI3X1lJiaicP0I55JWfn1RIIDmulBO0000F26E6z8hppQOiaWgB2sev5ib6mHW5T4RQHLkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;通常情况下，会有一个全局的单例运行时。然而，似乎apimachery模块本身试图避免状态——它定义了RESTMapper和Scheme结构，但没有实例化它们。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;不像运行时。该方案被apimachery模块本身广泛使用，RESTMapper在内部没有使用，至少目前没有。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;字段和标签选择器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;字段和标签的类型、创建和匹配逻辑也存在于apimachery模块中。例如，这里是k8s.io/apimachinery/pkg/labels包：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;lbl := labels.Set{&lt;span&gt;&quot;foo&quot;&lt;/span&gt;: &lt;span&gt;&quot;bar&quot;&lt;/span&gt;}&lt;br/&gt;sel, _ = labels.Parse(&lt;span&gt;&quot;foo==bar&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; sel.Matches(lbl) {&lt;br/&gt;  fmt.Printf(&lt;span&gt;&quot;Selector %v matched label set %v\n&quot;&lt;/span&gt;, sel, lbl)&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;例子:&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;https://github.com/iximiuz/client-go-examples/tree/main/label-selectors&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;https://github.com/iximiuz/client-go-examples/tree/main/field-selectors&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;API错误处理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在代码中使用Kubernetes API是不可能的，除非正确处理它的错误。API服务器可能完全消失，请求可能未经授权，对象可能丢失，并发更新可能发生冲突。幸运的是，k8s.io/apimachery /pkg/api/errors包定义了一些方便的实用函数来处理API错误。下面是一个例子：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;_, err = client.&lt;br/&gt;  CoreV1().&lt;br/&gt;  ConfigMaps(&lt;span&gt;&quot;default&quot;&lt;/span&gt;).&lt;br/&gt;  Get(&lt;br/&gt;    context.Background(),&lt;br/&gt;    &lt;span&gt;&quot;this_name_definitely_does_not_exist&quot;&lt;/span&gt;,&lt;br/&gt;    metav1.GetOptions{},&lt;br/&gt;  )&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; !errors.IsNotFound(err) {&lt;br/&gt;  panic(err.Error())&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;示例：https://github.com/iximiuz/client-go-examples/tree/main/error-handling&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;其他&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;最后但并非最不重要的是，apimachery/pkg/util包充满了有用的东西。下面是一些例子:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;4&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;k8s.io/api和k8s.io/apimachery包是学习如何在Go中使用Kubernetes对象的一个很好的起点。如果你需要编写你的第一个控制器，直接跳到client-go，甚至跳到controller-runtime或kubebuilder可能会让你的学习经历变得太复杂——可能会有太多的知识缺口。不过，先看看API和apimachery包，然后再尝试一下，这将帮助你在接下来的旅程中保持平和的心态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;相关链接：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://github.com/kubernetes/api/tree/35d41aaac2bf55a353ccade31b852d466b2495c2#recommended-use&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://github.com/kubernetes/apimachinery/tree/3d7c63b4de4fdee1917284129969901d4777facc#purpose&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;推荐阅读：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;点击下方卡片关注&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分布式实验室&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;，和&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;我们&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一起&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关注分布式最佳实践&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UibM134tIsO1j5yqHyNhh9arj090oAL7zGhRJRq6cFqFOlDZMleLl4pw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg5Mjc3MjIyMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzCwsauR1olj2b0tyPJXRBicSkuNEiaBuN8AQ61xkz4dH9DBr1PypYtFlEnczVkAeQvLz7rjsjttotCg/0?wx_fmt=png&quot; data-nickname=&quot;分布式实验室&quot; data-alias=&quot;DistributedLab&quot; data-signature=&quot;关注分布式相关的开源项目和基础架构，致力于分析并报道这些新技术是如何以及将会怎样影响企业的软件构建方式。&quot; data-from=&quot;2&quot; has-insert-preloading=&quot;1&quot; wah-hotarea=&quot;click&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;▲&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;点击上方卡片关注分布式实验室，掌握前沿分布式技术&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有想一起学习K8s、考CKA证书吗？来，这里有最好的学习方案，&lt;/span&gt;&lt;span&gt;线下3天封闭式培训，15人小班课，考不过免费复训&lt;/span&gt;&lt;span&gt;。Kubernetes实战班，7月22日在深圳开课，扫描下方二维码咨询详情。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzDGnTiaw7Teu5bSfO5NUAibEHyvmB2iaJArRBNbhOCawDQg6x23yR12zmh5B4sFCMv8eyq5LpuNTFU2Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6ad8eb69fa201af24eae03771c91af6f</guid>
<title>2022年最受欢迎的5大开源自动化和编排技术</title>
<link>https://toutiao.io/k/fj7m6x8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;span&gt;出品 | OSC开源社区（ID：oschina2013）&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/span&gt;DevOps 一直是开发者的重点关注领域，外媒 openlogic 联合 OSI 统计了各行各业 2600 多名开源用户的数据，得出了一份 2022 年开源状态报告，根据统计的数据总结了 2022 年最受欢迎的 5 大开源自动化和编排技术，以及开发团队选择这些技术的标准和常见问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基于&lt;strong&gt;自动化和编排技术&lt;/strong&gt;的调查范围，本次参与调查的工具主要有 Puppet、Ansible、Chef、Salt、Kubespray、Terraform、Rancher 和 Zabbix ，而 GitHub Actions、GitLab、Jenkins X、Jenkins、Spinnaker、Travis CI、Tekton、 Zuul 被视作 CI/CD 工具，不作统计。 &lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2022 年最受欢迎的 5 大开源自动化和编排技术&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;1、Puppet&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2022 年的调查发现，Puppet 是自动化和编配技术中被采用最多的技术，26.6% 的受访者使用该软件。上一次调查 Puppet 仅有 16%  的占比，可谓是迅猛增加。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;2、Ansible&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Ansible 的采用率第二，24.8% 的受访者表示使用了该软件，上次调查是 24 % 占比，较为稳定。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;3、Chef&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; 23.4% 的人使用 Chef 作为自动化和编排工具。自上次调查以来，Chef 使用量增加了 10%，也是被市场认可的工具。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;4、Salt&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Salt 的增长率位居第二，占比从 7% 提高到 21.9%，&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;5、Kubespray&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;排名第五的 Kubespray 增长百分比最高，在之前的调查中，Kubespray 占比仅 5%，2022 年增长到 21.4%。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;选择开源自动化和编排工具的原因&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45661157024793386&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRKibMkIxZD11PiaYXJBZqJiaSRcUoYeP8wph5fF55thQfUD1ZIicJWL8e5B8FZMLa6RYzicvDTFv2l4yabg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;968&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;调查结果显示，大型组织选择自动化和编排工具的主要原因是新特性和功能、安全访问和控制，而小型组织选择自动化和编排工具的关键原因是客户群的不断扩展，需要自动化工具来维持产品的安全和稳定。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;开源自动化和编排技术面临的主要问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4483837330552659&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRKibMkIxZD11PiaYXJBZqJiaSRc6h8eyRrYIdyXqSNs98v5uJ8NW4T9YAMWERJYw4XAYibs5YQ0vDZ6pwQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;959&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;安装、升级和配置问题是开源自动化和编排技术的最大挑战：并非每个组织都拥有熟悉自动化和编排工具的 DevOps 团队。对很多开发者来说 DevOps 其实是一项从未接触过的新工具，很容易在复杂的安装和配置过程中陷入困境，然后花费大量的时间查资料解决问题，这对小型组织来说是非常昂贵的人力资源和学习成本。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;从统计结果来看， DevOps 领域内采用开源技术变得更加普遍。openlogic 之前的调查发现 50% 的开发者从未使用过任何开源自动化和编排技术。而 2022 年的调查中这一数据仅剩 16% 。但采用并不意味着能掌握，大部分采用这些开源技术的组织在安装、配置、升级以及熟练部署方面都遇到了困难，这意味着开源自动化和编排技术的资料和教程仍需进一步完善。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;感兴趣的朋友可以查看 openlogic 的开源调查报告和开源自动化和编排技术排行博客。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;相关链接：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;开源调查报告：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;https://www.openlogic.com/resources/2022-open-source-report&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;编排技术排行博客：&lt;span&gt;https://www.openlogic.com/blog/top-open-source-automation-and-orchestration-trends-2022&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;https://www.openlogic.com/resources/2022-open-source-report&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;---END---&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;推荐↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI3NDA4OTk1OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/UDxcwVqYKV9IOTr5rggNKcaXwzBdaq9EG6A3Jib6YGFIWjCh0rpwGlapib9GGcr9TeSRcEqasuom6dLibqswdq1Mw/0?wx_fmt=png&quot; data-nickname=&quot;数据库开发&quot; data-alias=&quot;DataBase1024&quot; data-signature=&quot;分享数据库开发、原理和应用，涵盖MySQL、PostgreSQL、MS SQL Sever、Oracle等主流关系数据库的应用和原理，以及MongoDB、Redis、Memcached等NoSQL数据库和缓存技术。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>788f5af52a2d9dc44a67a7814e9f0b71</guid>
<title>正确复制、重写别人的代码，为什么是件很酷的事情</title>
<link>https://toutiao.io/k/li8d566</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0Mckx2q9iciaNlK44cAQ5icVeTJeTCU7HqkpFu4oRQOHSzDP7lCH4gvaOPqvbg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;
作者 | Erik Hermansen&lt;/section&gt;&lt;section&gt;
译者 | Sambodhi&lt;/section&gt;&lt;section&gt;
策划 | 闫园园&lt;/section&gt;&lt;p&gt;我最近在一篇文章提到，工程师应该怎样避免使用大量的库、包以及其他依赖关系。我建议的另一种方案是，如果你没有达到重用第三方代码的阈值时，那么你就可以自己编写代码。&lt;/p&gt;&lt;p&gt;在本文中，我将讨论一个在重用和从头开始编写之间的抉择。这些技术能为你提供良好的综合优势。你将会听到我提到的一些在不同编程语言 / 环境下的例子。但是，这篇文章的层次足够高，而且说实话，你在什么环境下工作，并不重要。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5578571428571428&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxGzexT7cibibA3W7ibQv0C8F8m9SKJhTfqNC2ibPKv3QsYXLqPuOUFKSiaEg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们一再要求她把字写得小一点。她浪费了那么多纸张。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;1&lt;/span&gt; 四种编码技术&lt;/section&gt;&lt;p&gt;设想你所处的情况是这样的，你希望你的软件能够完成当前无法完成的任务。比如，你也许想要一份 PDF 格式的报告，方便打印。但是你的软件并不会输出 PDF。作为一名工程师，你要做的工作就是解决这个问题。&lt;/p&gt;&lt;p&gt;下图展示了四种不同的技术来添加这个功能。我并没有提到“这四种技术”。当然，我肯定还有更多的技术，包括镖靶和猴子。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31285714285714283&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0Mckx7j3anMPVL2dZ1I8yYJMXCicEtTwyuoMPu9JlcmtibU7RgCZYkG81Azew/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;为什么这么多决定都要权衡利弊呢？这真的很让人恼火。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;重用&lt;/strong&gt;：根据你的环境，你可能会在 lib 中建立链接，或者在 &lt;code&gt;pom.xml&lt;/code&gt; 或 &lt;code&gt;package.json&lt;/code&gt; 中添加一个条目。不管你怎么做，“重用”就是抓取别人的代码，通过它的接口来使用，而不去关心它的内部结构。这段代码还可能会“偷渡”到一群横向的依赖关系中去，这会给你带来麻烦。最少的努力，带来的是最少的控制。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;复制&lt;/strong&gt;：从 Github repo、代码片段集或者其他地方，选择你所需要的代码。然后把它直接粘贴到你的项目中。这段代码已经存在于你的代码库中，而不再是一个依赖关系。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;重写&lt;/strong&gt;：采用一些适合你的第三方代码，通过重写，使其成为你自己的代码。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;编写&lt;/strong&gt;：你自己编写所有的代码，用自己的脑子，不借用任何人的东西。Ayn Rand 和 Casey Muratori 将尊重你的决定。最大的努力，将得到最大限度的控制。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;为了确保我上面的图表给人留下正确的印象，我给了它两把斧子——一把是努力，一把是控制。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5064285714285715&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0Mckx9nuiacfib4BUyuNnobZqVlOU9YO8Wzic3UAwXlTicYC3IYhfdYEPS3JuSg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;另一方面，这家伙的两把斧子也让人印象深刻。&lt;/p&gt;&lt;p&gt;所有这四种技术都是在努力和控制之间的权衡。&lt;/p&gt;&lt;p&gt;你可以通过重用快速地获取大量的功能，然后以软件膨胀、黑盒调试、安全修补和耦合升级的形式遭受缺乏控制的痛苦。在重用的情况下，你不一定会面临这些问题，但是这样做的风险会增大。在你的项目中添加的每一行代码就好像是一张彩票，会“赢得”一个非常糟糕的问题。&lt;/p&gt;&lt;p&gt;或者在这张图的另一端，你从头开始编写所有的代码，你将会对进入项目的新代码进行完全的控制。不过，你可以花些无聊的时间去把所有的东西都按你的想法去编写，而你却成了编程的天后。&lt;/p&gt;&lt;p&gt;在我以前的一篇文章《多编写，少重用》（Write More, Reuse Less）中，我已经详细地阐述了重用和编写之间的权衡。&lt;/p&gt;&lt;p&gt;我将会深入探讨两种中间技术（复制和重写）。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;2&lt;/span&gt; 复制&lt;/section&gt;&lt;p&gt;有许多可以复制代码的好地方。如果你要完成的任务可以用一句话来完成，而且代码不超过 100 行即可实现，那么，你只需把问题输入到搜索引擎，就能轻松地找到。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6350245499181669&quot; data-type=&quot;jpeg&quot; data-w=&quot;1222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxZrnXsJ52PCBVpJ0OibB4cabOJp7dTuSOibvh8Sw3msibRud5mtsafPRGw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;与 DuckDuckGo 相比，谷歌最大的优势在于：“DuckDuckGo”作为动词，在会话中会让人感到难堪。&lt;/p&gt;&lt;p&gt;用这种方式来搜索一些简单的代码任务的问题，你将很快就能找到代码的天堂。&lt;/p&gt;&lt;p&gt;我从 StackOverflow、W3Schools、MDN、Unity Answers 和各种我懒得记住的地方复制了很多代码。我总是先从搜索引擎开始，在那里提出问题。通常情况下，我会先从我工作的语言 / 平台开始，然后再提问。在我敲代码的时候，看一下自动完成的内容往往很有帮助。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;3&lt;/span&gt; GitHub Copilot&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4635714285714286&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxLNrh62keCMgaLupcVOsqy2oWHJorPExeCADLZu8atXDZeIthIH2Q4Q/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;从复制人类答案的机器人那里复制你的答案。&lt;/p&gt;&lt;p&gt;如果你更愿意相信由复杂的人工智能为你编写的代码片段，可以试试 GitHub Copilot。这是一个集成到 IDE 中的插件。基本上，你并不需要在搜索引擎中输入你想要的东西，而是将该文本输入一个略微详细的源码注释即可。然后，实现的源代码就会自动填充在下面。&lt;/p&gt;&lt;p&gt;是真的！我不是在开玩笑。请看一些关于它的视频。&lt;/p&gt;&lt;p&gt;&lt;span&gt;视频地址：https://youtu.be/FHwnrYm0mNc&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这使我既害怕又激动。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;4&lt;/span&gt; 超越代码片段&lt;/section&gt;&lt;p&gt;如果你想要为更大的功能部分复制代码，那么只要：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;寻找包含这些功能的开源项目；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将所需的文件复制过来。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我刚才提出的一种做法，不是很傻就是很疯狂。我真心希望你能想到下面那个问题。别让我跟你扯淡。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;5&lt;/span&gt; “什么时候从第三方项目中复制会比直接导入更好？”&lt;/section&gt;&lt;p&gt;如果你仅仅想将一个依赖关系的所有未改变的文件复制到你的项目中，那么我将会发现这种复制方法的缺陷。你复制的源码不会轻易地被更新到依赖关系的新版本。这就意味着你会错过 Bug 修复、新功能和安全补丁。&lt;/p&gt;&lt;p&gt;尽管在一些情况下，对某个特定版本的代码进行快照非常有价值，但是你可以通过构建清单（例如 Java 中的 &lt;code&gt;pom.xml&lt;/code&gt;，Node 中的 &lt;code&gt;package.json&lt;/code&gt;）使用固定版本来完成同样的事情。而且如果你决定要升级的话，那么你可以轻易地更新一个固定版本。&lt;/p&gt;&lt;p&gt;另外一个潜在的复制理由是，你可能需要对项目的源码进行修改。如果你要进行增量更改，你可以最好这样做：1. 从原项目中创建一个复刻项目；或者 2. 把你的更改贡献给原项目。这样可以让你在以后更容易从原项目中收到修改。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4928571428571429&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxgPSpmezstQJYYulht2kzx3ViapSg4AWuEYypwroDFeAg7T1GQqPZCDg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;有三种不同的方式可以让你在你的项目中修改他人的代码。最上面的一种做法是不好的。&lt;/p&gt;&lt;p&gt;这也许是你大规模、全面地修改你的代码库。你准备在以后的合并项目中，把一切后路都堵死。那真是太好了。这往往是有正当理由的。但是我在本文中所提供的定义是，对源码的大规模结构性的修改属于“重写”技术，下面我会详细讨论。&lt;/p&gt;&lt;p&gt;我唯一能想到的一个很好的理由就是，将第三方项目的代码复制（而非重写）到你的项目中：你只需在这个项目中得到一些源码即可。&lt;/p&gt;&lt;p&gt;而这种理由出现的频率超出了你的想象。大型 Node 包，如 Lodash 和 TurfJS，都是非常聪明的，它们会提供子集包，这些子集包只是为了你需要的特定功能在函数级颗粒度来导入。不过，在野外中也有很多臃肿的怪物。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.56&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxLkruib1ocAO5wFVmnXib8WF746PG252qhbPgP46XARTic6sbK6KUJPoWA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;Nodelerfish 需要你的爱。但不要让它进入你的项目中。&lt;/p&gt;&lt;p&gt;你也许只需要使用 50 行代码就可以完成的库 API。但是单体导入的库，可能会拉来数十万行代码，特别是那些具有横向依赖关系。在这种情况下，将一个子集复制下来，而非将其导入到整个该死的烂摊子中，这完全是很合理的。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;6&lt;/span&gt; 开源许可证&lt;/section&gt;&lt;p&gt;我不是一个律师。既然我不是律师，我就会把我在开源许可方面的实践告诉你。你可以咨询顶级律师团队，以达成你自己的决策。&lt;/p&gt;&lt;p&gt;笔者作为非律师，是如何做的：&lt;/p&gt;&lt;p&gt;如果我把源码复制到我的项目中，我把它和导入代码一样对待，并遵循所有的许可条款。在开源软件许可的条款中，一般都是指分发源码或者从许可源码中构建的行为。如果复制的代码是我发布版本的一部分，那么它也算作分发。对于我使用的确切的开源许可证，我也非常谨慎，例如，GPL 可能会要求我使用 GPL 许可证来许可我自己的代码库，而 MIT 许可证几乎不要求我做任何事情。&lt;/p&gt;&lt;p&gt;我还喜欢将复制的代码归入“第三方”目录（例如 Github 上的例子），然后在文档的顶部添加注释，这样就可以保证所有的内容都是一致的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2757142857142857&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxianDy2PEqT2920FqJq5eNHsHbia8bbTepiagvaianYCQhrJjMcHeDHHdJA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;他们不认识我，但 Matt Daly 和 Chris Anderson 是我的代码兄弟。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;7&lt;/span&gt; 重写的优点&lt;/section&gt;&lt;p&gt;你知道你正在复制的代码里有什么吗？它是适合你的代码吗？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4542857142857143&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxxeO9NF537Yzn5NYqZ2GqdkeOeanpic8FMfM4L3952UuM697PSJxuaMA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;对于某些测试，复制别人的答案效果并不好。&lt;/p&gt;&lt;p&gt;你能够而且应当对其他人的代码进行判断。或许不要对这段代码做出无情的评论。但是，请务必为自己的利益，私下评估第三方代码。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;8&lt;/span&gt; 重写代码片段&lt;/section&gt;&lt;p&gt;如果是 200 行以内的代码片段，或者是复制的代码，我一定会逐行重写代码，这样可以了解到这些代码是如何工作的，并且做一些改动，使之更适合我的项目。这是为数不多的几次在其他方面进行毫无意义的、风格化的编辑，是有价值的。&lt;/p&gt;&lt;p&gt;我要举一个具体的例子来说明。现在，我要从互联网上某个地方随机找出一个代码片段，然后进行重写。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24928571428571428&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxG4Rv2DCC90uI7bTLX5n1ekQgZKdTjwdgs14QbJjDFoUJMKNbfiaj82w/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;左边的代码是原来的。右边的代码是我重写的。&lt;/p&gt;&lt;p&gt;我重写的 代码片段 是由 StackOverflow 上一位名叫“Mark”的人发布的。他的代码通过对每一个点与它的左右邻居进行平均，使折线图中参差不齐的高峰和低谷变得平滑。&lt;/p&gt;&lt;p&gt;概括地说，在重写代码中，我做了以下的改动：&lt;/p&gt;&lt;p&gt;我编写代码的风格并不比 Mark 的好。它只不过是碰巧以正确的方式触动了我的大脑。这并不足以让 Mark 的代码发生改变。下面是重写他的代码片段的真实益处：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;我学会了这个算法。我现在完全明白这个折线图平滑的工作原理了。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我创建的代码对我而言更易于维护，即使对 Mark 来说并不是这样。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我可以把那些和我需求无关的部分代码删除掉。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我确认了代码没有任何错误，比如，无限循环。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我已经确认了没有引入安全漏洞，比如在 DOM 中注入一个 &lt;code&gt;querystring&lt;/code&gt; 变量。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我已经确认了，这些代码没有添加任何额外的依赖关系，比如某些统计库。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我了解到另外一位工程师很享受编写代码的乐趣，并且有机会把他的实践为我自己所用。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;所以，这种浅重写是一种很好的方式，可以把别人的代码导入到你的项目中。有些问题是可以避免的。你可以根据你的用例和其他需求对代码进行调整。另外，你还可以在学习新的算法和实践中，成长为一名工程师。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;9&lt;/span&gt; 重写的许可考虑因素&lt;/section&gt;&lt;p&gt;笔者作为非律师，是如何做的：&lt;/p&gt;&lt;p&gt;我想，完全的逐行重写应该可以免除几乎所有开源软件许可的法律义务。但是我始终坚持着开源的理念，例如，在源码的注释中引用原作，或者为原项目提供帮助。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;10&lt;/span&gt; 更深入的重写和修剪&lt;/section&gt;&lt;p&gt;有时候，你希望导入多个文档或数千行的源码，并做大量的改动，以让新代码适合你的项目。尤其是，修剪掉你实际上不需要的东西，是很好的做法。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6142857142857143&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0Mckx94wMVAGv5wBG72mX6rRIfsLZGstkLBjmIceqjPBCLbyUz7EQQXEqwQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;当攀爬到一棵树上修剪时，我建议你在面向树干的那一侧坐下来进行修剪。&lt;/p&gt;&lt;p&gt;下面是一个简单的复制和修剪的方法：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;将所有的依赖源文件复制到你的项目中。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;确保你所需的功能能够在实践中起作用。单元测试一般都是非常有用的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;把你不需要的部分删除。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;重复第 2 和第 3 步，直至剩余的代码能够符合你的需求。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;至少对剩余的代码进行一次浅重写，这样才能保证你能够了解并从中得到其他的益处。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;你的 IDE 的选择和配置应该能够很好地支持你完成这项任务，包括提示、语法高亮和通知功能，这些功能可以向你显示：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;哪些代码在调用函数。（修剪它们？)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;哪些函数从未被调用。（修剪它们！)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;哪些变化会破坏你的构建。（取消修剪！)&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果你的 IDE 没有为你对这些进行适配，可以花点时间去做更好的设置。&lt;/p&gt;&lt;p&gt;&lt;code&gt;git commit&lt;/code&gt; 和 &lt;code&gt;git checkout&lt;/code&gt; 可以让你设定一个很好的状态，在你因过度修剪而破坏一些东西的时候，能够恢复到之前的状态。这是一张很好的安全网，可以使你的工作速度更快。&lt;/p&gt;&lt;p&gt;我都能听见你想说什么了……&lt;/p&gt;&lt;section&gt;
&lt;span&gt;11&lt;/span&gt; “可是，要重写代码的话，实在是太费事了！”&lt;/section&gt;&lt;p&gt;我不是说你一定要重写。只有在一些情况下，如果你这么做，就能得到很好的回报。我来告诉你一个真实的案例，我重写了一个第三方项目，并且从中获益良多。&lt;/p&gt;&lt;p&gt;我先从依赖树开始，如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21428571428571427&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxeibYm6yY76mUPWM7ObEDo19mocgy0yNjOEuibadDaVnyPNm3wefzfMUw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;在花了半天时间完成重写之后，我去掉了 5 个依赖关系的需求，最后得到了如下结果：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21642857142857144&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxZQ6uI6HvzicOrDbzm7k6o5sy60IYrpWIPvticdcwnvhfdcwCljf4mLlQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;有一个名为“microphone-stream”的 NPM 包，我在 Web 应用中使用它来发送从麦克风捕获的样本缓冲区到语音识别包（Cieran O&#x27;Reilly 的 vosk-browser，如果你有兴趣的话）中的一个接口。&lt;/p&gt;&lt;p&gt;我最初是在“让它工作”的开发阶段使用 &lt;code&gt;microphone-stream&lt;/code&gt;。它包含在一个示例 Web 应用项目中，我已经将其复制到我的项目中。&lt;code&gt;microphone-stream&lt;/code&gt; 运行得很好，直到我升级了一个构建工具（Webpack），这破坏了 &lt;code&gt;readable-stream&lt;/code&gt; 的构建，这是一个更高级别的依赖包。我研究了对这两个第三方库中任何一个可能的 PR 修复。不过，向仓库提交一个好的修改需要花费好几天时间。我由于种种理由而拒绝了其他的变通方案。&lt;/p&gt;&lt;p&gt;通过查看 &lt;code&gt;microphone-stream&lt;/code&gt; 的代码，我意识到我并不需要该库的核心功能：一个 Node.js 风格的流接口。因此，我认真地重写了那些我真正需要的那部分代码，把那些我不想要的东西删除掉。&lt;/p&gt;&lt;p&gt;一路走来，我在源码中发现了这样的宝藏：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18571428571428572&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxszrsEOXJpuLTVTuz04tnWKjrtquRObCVBGEndBOG8C1ibgJnhicJdOqQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;还有这个：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxD582Afia9UqibhGnrPMlr0egKCXBOVxIVicbDtMiapibAibpibnTrfDylqSVg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;我很感激地将这些想法合并到我重写的代码中。&lt;/p&gt;&lt;p&gt;作者 Nathan Friedly 在这样的源码注释中阐述了他的思考过程。也许他拯救了我，可能让我以后不用再找漏洞来修复了。从这个角度来看，重写比从头开始编写要好。你可以“捕捉”到别人来之不易的知识。&lt;/p&gt;&lt;p&gt;因此，对我来说，这是一个明显的案例，重写，而非重用，可以节约我的时间，并且让我得到更好的结果。重写也比从头开始编写要好，因为这样可以让我了解其他工程师的真实经验，否则我可能会错过这些经验。&lt;/p&gt;&lt;p&gt;复制和重写——试试吧！&lt;/p&gt;&lt;p&gt;这是好东西。这算不上作弊。&lt;/p&gt;&lt;p&gt;只要遵循开源许可的条款，和你的工程师伙伴成为好邻居吧。&lt;/p&gt;&lt;p&gt;你不希望复制或重写所有的东西。但是要学习辨别哪些情况值得你这么做。&lt;/p&gt;&lt;p&gt;并享受与其他人工作中的联系。那些数以百万计的项目，都是由伟大的头脑构建的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6414285714285715&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0Mckx59cPsDu8kjWCaNSrM48vA463B0EwDRsVFHcTwY1r1c7pjUwwIwVbLw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;好吧，这个特别的孩子可能复制得太多了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;作者介绍：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Erik Hermansen，博主，撰写关于工程、技术，以及人机共同构成的系统的文章。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原文链接：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://levelup.gitconnected.com/copying-other-peoples-code-is-very-cool-717e8a72aa3b&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;span/&gt; 今日文章推荐&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;amp;mid=2247526287&amp;amp;idx=1&amp;amp;sn=40ccfa506d54ac807f42ccec549f9426&amp;amp;chksm=e8d4984ddfa3115bbf70989c1bcab4f8ed1bd0e969eba46629b2157e2a94734676c317e290f5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;谷歌工作十年，我总结了这些工程师必备软技能&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;谷歌工作十年，我总结了这些工程师必备软技能&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;amp;mid=2247526174&amp;amp;idx=1&amp;amp;sn=523a1c69928eaf3d5228d124450f49cf&amp;amp;chksm=e8d498dcdfa311ca4692a85d1be0b3def9d826cbb6c8aadfcd24a435f765404dfe126703311c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;InfoQ 2022 年趋势报告：DevOps 与云计算篇&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;InfoQ 2022 年趋势报告：DevOps 与云计算篇&lt;/a&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;span/&gt; 活动推荐&lt;/section&gt;&lt;/section&gt;&lt;p&gt;云原生环境下，混沌的微服务架构、多语言的应用、多种网络调用协议并存给可观测性带来埋点成本上升、观测数据割裂、问题定位麻烦等挑战。&lt;/p&gt;&lt;p&gt;7 月 15-16 日 ArchSummit 全球架构师峰会将落地深圳，大会设置了「可观测性技术落地探索」专题，邀请到了阿里、PingCAP、微众银行、TT 语音等公司的嘉宾向大家分享可观测性技术落地的相关实践经验，点击阅读原文查看大会更多精彩内容。&lt;/p&gt;&lt;p&gt;大会已进入倒计时，现场席位有限，了解大会详情或预订门票请咨询小助手：18514549229（微信同电话)&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.9907407407407407&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfM309BBOzAe3aB7ERfdIqkRGPkc2pJIHicvQG0vsgRMatSKlbqnS1DcVouWsQYCJ8eHhribcxwahZuQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e9d058f7372c776535b4701d2cde2b14</guid>
<title>探索Glide原理</title>
<link>https://toutiao.io/k/tx553c1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4725050916496945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkbeR6DFPgAAEaIEm7EJk2Oz8cb5XwibJLcOwpdJnHJyGSUXwYdKwUOWA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1964&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. Glide 基本用法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来的讲解将基于 Glide 目前的最新版本 4.11。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Glide 的使用特别简单，首先添加依赖。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46464646464646464&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkJMpu2kWqnCaribT7xVWfic3Q084nufP1LKcicF6S9RqY8AvRsljmDPFQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;990&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后调用下面这三个方法。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4485294117647059&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkOGpjW8jK6RS3L2mZyraAdMNJWjYJPh6CYN6xES8eiaibHs0B3td0XzUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;544&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;with()&lt;/p&gt;&lt;p&gt;可以传 Applicaiton、Activity 、Fragment 与 view 等类型的参数，加载图片的请求会与该参数的生命周期绑定在一起。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;load()&lt;/p&gt;&lt;p&gt;可以传图片的网络地址、Drawable 等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;into()&lt;/p&gt;&lt;p&gt;一般传 ImageView 。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 内容概览&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8199203187250996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkuB8ZajH5H8q0pm0FK9XNnnibJFXPEn4G8rppdK6WsnfFQT0EgrMEp3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1255&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Glide 加载图片大致可分为三个步骤。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;发起加载图片请求&lt;/p&gt;&lt;p&gt;当我们用 into() 方法加载图片时，就是发起了一次图片加载请求；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;执行解码任务&lt;/p&gt;&lt;p&gt;我们在 load() 方法中设置的图片来源会传到 DecodeJob 中，DecodeJob 就会被 Engine 提交到线程池中开始执行；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;加载图片&lt;/p&gt;&lt;p&gt;当 DecodeJob 对图片解码完成后，就会把图片加载到 ImageView 中；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来会以这三个步骤为基础来展开 Glide 的图片加载流程，下面是每个大节讲解的内容。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 四步启动解码任务&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一大节将会讲解从我们调用 into() 方法到启动 DecodeJob 的 run() 方法的过程中，Glide 做了哪些事情，包含了 Request、Target 、 Engine 和 DecodeJob 等内容。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 六步加载图片&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二大节会讲解当 DecodeJob 获取到图片数据后，会怎么处理图片数据，也就是解码、加载图片和编码的过程，包括 ModelLoader、ResourceDecoder、Transformation、ResourceTranscoder 以及 ResourceEncoder 的实现。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. Glide 缓存原理&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里会讲 Glide 的图片缓存相关的实现，包括内存缓存、磁盘缓存、BitmapPool 以及 ArrayPool 等内容。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. Glide 初始化流程与配置&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一节会讲解 Glide 的初始化流程，包括 Glide 调用配置的方式、AppGlideModule 的两个方法中用到的 Registry 和 GlideBuilder 在 Glide 中的作用。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. Glide 图片加载选项&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Glide 开放了非常多的图片加载选项，我们不一定全都用得上，但是了解这些选项，可以让我们在需要的时候能调用对应的选项，不用再自己实现一遍。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 四步启动解码任务&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一节我们先来看下从 into() 到启动 DecodeJob 的过程中涉及哪些对象。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6857344632768362&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkicVggYMMXZkyvJuMictXHuQOYZeSsv3BtIFoj8pbL5nOiahQDIBzmpa9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1416&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从我们调用 into() 方法加载图片到启动解码任务 DecodeJob，大致分为 4 个步骤，涉及下面 4 个对象。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;加载请求 Request&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加载目标 Target&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加载引擎 Engine&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解码任务 DecodeJob&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们围绕这 4 个对象看看 Glide 的解码任务的启动流程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 Request&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1.1 请求构建器 RequestBuilder&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. into()&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于我们发起的图片加载请求，Glide 会把这个请求封装为 Request，而 RequestBuilder 就是 Request 的构建器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们用 into() 方法加载图片时，调用的其实是 RequestBuilder 的 into() 方法，这个方法会创建一个 Request ，并把 Request 传给请求管理器。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. Model&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Glide 会把我们在 load() 中传入的图片来源数据封装为 Model ，而这个 Model 具体就是 RequestBuilder 中的 model 字段，类型为 Object 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 加载选项&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RequestBuilder 继承了 BaseRequestOptions 抽象类，我们平时用的 centerCrop() 等方法大部分都是 BaseRequestOptions 的方法，关于图片加载选项在后面会讲到。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1.2 请求管理器 RequestManager&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RequestManager 有下面几个特点。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 绑定生命周期&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Glide 中，一个 Context 对应一个 RequestManager，当我们调用 with() 方法时，RequestManager 会用对应的 Context 创建一个 RequestManagerFragment 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RequestManagerFragment 是一个无布局的 Fragment，主要是用来做生命周期关联的，当这个 Fragment 感知到 Activity 的生命周期发生变化时，就会告诉请求管理器，让它去做暂停请求、继续请求和取消请求等操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们用的是 ApplicationContext 加载某张图片，那就意味着这次图片加载操作的生命周期是与应用的生命周期绑定的。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 监听网络状态&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RequestManager 中有一个网络连接监听器 RequestManagerConnectivityListener ，它实现了ConnectivityListener 接口，每次网络状态切换时，RequestManager 就会重启所有的图片加载请求。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 创建请求构建器&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在加载图片时调用的 load() 方法是 RequestManager 的方法，调用这个方法其实是创建了一个请求构建器 RequestBuilder，RequestManager 中有很多创建 RequestBuilder 的方法，比如 asDrawable()、asBitmap() 、asFile() 等，这些方法对应着不同泛型参数的 RequestBuilder 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;load() 方法支持下面这些类型的参数。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Bitmap&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Drawable&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;String&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Uri&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;URL&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;File&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Integer（resourceId）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;byte[]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Object&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 启动请求&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RequestManager 的 track() 方法调用了目标跟踪器 TargetTracker 的 track() 方法，还调用了请求跟踪器 RequestTracker 的 runRequest() 方法 。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;TargetTracker&lt;/p&gt;&lt;p&gt;TargetTracker 实现了 LifecycleListener ，它会根据页面生命周期播放和暂停动画，比如暂停 Gif 动画。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;RequestTracker&lt;/p&gt;&lt;p&gt;RequestTracker 的 runRequest() 方法调用了 Request.begin() 方法。&lt;/p&gt;&lt;p&gt;在 Request 的 begin() 方法中会获取 View 的尺寸，获取到了尺寸后就会调用 Engine 的 load() 方法启动图片加载请求。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1.3 Request 的 6 种状态&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.7687991021324354&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxku2Xdwda43U2e9FQL3mAN4GeoWtghWzd3n76mbWakcnR6axAthFwlibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;891&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面讲到的 Request 具体就是 SingleRequest ，SingleRequest 中有一个 Status 枚举类，包含了请求的 6 种状态。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 待运行 PENDING&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们通过 into() 创建了一个 SingleRequest 后，该 Request 就进入了待运行状态。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 已清除 CLEARED&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次我们用 into() 方法加载图片时，RequestManager 都会先看下我们传入的 Target 是否有对应的 Request ，如果有的话就会调用该 Request 的 clear() 方法释放资源，这时 Request 就进入了已清除状态。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 待测量 WAITING_FOR_SIZE&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 RequestManager 调用 RequestTracker 的 runRequest() 方法后，RequestTracker 就会调用 Request 的 begin() 方法，这时请求就进入了待测量状态。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 运行中 RUNNING&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 SingleRequest 的 begin() 方法中，调用了 Target 的 getSize() 方法获取 ImageView 的尺寸，获取到尺寸后，SingleRequst 会调用 Engine 的 load() 方法启动图片加载请求，这时 Request 就进入了运行中状态。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 已完成 COMPLETE&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 Engine 从内存中加载到资源，或者通过解码任务加载到资源后，就会调用 SingleRequest 的 onResourceReady() 方法，这时 Request 就进入了已完成状态。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. 失败 FAILED&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当解码任务 DecodeJob 在处理图片的过程中遇到异常时，就会调用 EngineJob 的 onLoadFailed() 方法，然后 EngineJob 会调用 SingleRequest 的 onLoadFailed() 方法，这时 SingleRequest 就进入了失败状态。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1.4 三种占位图&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4926650366748166&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxk71dXuBTvP4ic9WdG0Ycx6SmIWm0xLQbqEZ0gVWCcDNRscmLTPsRjSibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;818&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在加载图片时，可以设置 placeholder、error 和 fallback 三种占位图。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;placeholder&lt;/p&gt;&lt;p&gt;图片加载完成前显示的占位图；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;error&lt;/p&gt;&lt;p&gt;图片加载失败时显示的占位图；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;fallback&lt;/p&gt;&lt;p&gt;图片来源为空时显示的占位图；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用占位图时，要注意占位图是不会使用 Transformation 进行变换的，如果你想弄个圆角或圆形的占位图，可以用 submit().get() 获取对应变换后的占位图的 Drawable 对象，然后传到对应的占位图设置方法中。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1.5 Request 相关问题&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是几个跟 Request 相关的问题，看看你能不能答得上来。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我们平时用 Glide 加载图片调用的 into() 方法是哪个类的方法？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当设备的网络状态发生变化时，是谁负责重启图片加载请求？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Request 有哪几种状态？这些状态是如何流转的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Glide 有几种占位图？分别在什么时候显示？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 Target&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7807670291929021&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkibRcvbFwpmlm4jrlzrloRmltm4VaQOIrvxLSNTojia7ic5xX8S7YMaWYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1747&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们调用 into() 方法，传入 ImageView 后，Glide 会把 ImageView 转化为 Target ，下面我们来看下不同 Target 的作用。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2.1 ImageViewTarget&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. SizeDeterminer&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ImageViewTarget 继承了 ViewTarget ，在 ViewTarget 中有一个用来获取尺寸的 SizeDeterminer ，SizeDeterminer 的 getSize() 方法拿到的尺寸，是把 ImageView 的内边距 padding() 去掉后的尺寸。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Glide 中，宽高分为请求宽高和原始宽高 ，而 SizeDeterminer 拿到的尺寸就是请求宽高，Glide 会根据请求宽高对图片进行缩放操作，以减少不必要的内存消耗。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. OnPreDrawListener&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 Request 获取 View 的尺寸失败时，ViewTarget 会通过 ViewTreeObserver 的 OnPreDrawListener 的回调来获取 View 的尺寸，然后再传给 Request。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. setResource()&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ImageViewTarget 主要有 BitmapImageViewTarget 和 DrawableImageViewTarget 两个子类，它们两个的区别就在于它们的 setResource() 方法。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;BitmapImageViewTarget&lt;/p&gt;&lt;p&gt;setResource() 用的是 ImageView 的 setImageBitmap() 方法；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DrawableImageViewTarget&lt;/p&gt;&lt;p&gt;setResource() 用的是 ImageView 的 setImageDrawable() 方法；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2.2 RequestFutureTarget&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. submit()&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FutureTarget 是一个实现了 Future 和 Target 接口的接口，它只有一个 RequestFutureTarget 子类 ，当我们用 submit() 方法获取 Glide 加载好的图片资源时，就是创建了一个 RequestFutureTarget 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. Waiter&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RequestFutureTarget 是用 wait/notify 的方式来实现等待和通知的，这两个是 Object 的方法，Request 中有一个 Waiter ，当 DecodeJob 加载到图片后，RequestFutureTarget 就会让 Waiter 发出通知，这时我们的 get() 方法就能获取到返回值了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是为什么我们用 RequestFutureTarget 的 get() 方法获取图片时，要把这个操作放在子线程运行。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2.3  CustomTarget&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给不是 View 的 Target 加载图片时，Glide 都把它作为 CustomTarget 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. PreloadTarget&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;预加载 Target 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们调用 preload() 选项预加载图片时，Glide 会把图片交给 PreloadTarget 处理，当 PreloadTarget 接收到图片资源后，就会让 RequestManager 把该请求的资源释放掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为不需要等待资源加载完成，所以我们在用 preload() 预加载图片时，不用像 submit() 一样在子线程中执行。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. AppWidgetTarget&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;桌面组件 Target 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 AppWidgetTarget 接收到处理好的图片资源后，会把它设置给 RemoteView ，然后通过桌面组件管理器 AppWidgetManager 更新桌面组件。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. DelayTarget&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GifTarget。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是加载 Gif 图片时要用到的 Target ，关于 Glide 加载 Gif 图片的流程在后面会讲到。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. NotificationTarget&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通知栏 Target 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 Target 有一个 setBitmap 方法，会把图片设置给通知栏的 RemoteView ，然后通过 NotificationManager 更新通知栏中的通知。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2.4 Target 相关问题&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ImageViewTarget 是用什么来获取请求宽高的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么在用 submit() 获取图片时，要放在子线程中执行？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 preload() 预加载图片时，用的是哪个 Target ？该 Target 获取到资源会后做什么？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3 Engine&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一些与 Engine 相关的实现。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Engine 的作用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Key 的作用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Resource 的作用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;BitmapPool&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3.1 Engine 的作用&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Engine 是 Glide 的图片加载引擎，是 Glide 中非常重要的一个类，下面我们来看下 Engine 的作用。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. load()&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.6235093696763203&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkvIeRKPAFSq6UZfONcpb9NIGM9TphM3yN7tVvEI3sVCro7jClGWveOA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;587&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面讲到了当我们调用 into() 方法时，就是间接调用了 Request.begin() 方法，而 Request 的 begin() 方法又调用了 Engine 的 load() 方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 load() 方法中，Engine 会先用 EngineKeyFactory 创建资源标识符 Key，然后用这个 Key 去内存缓存中加载资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果从内存中找到了资源，Engine 就会直接把资源回传给 Resource，如果没有加载到资源，Engine 就会创建并启动新的 EngineJob 和解码任务 DecodeJob。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. EngineKeyFactory&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;EngineKeyFactory 是 Engine 中一个负责生产 EngineKey 的工厂，EngineKey 是引擎任务资源标识符，关于什么是 Key 后面进一步讲。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Engine 启动新的任务加载图片前，会先通过 EngineKeyFactory 创建一个 EngineKey，然后让 DecodeJob 把资源与 EngineKey 进行绑定，这里说的绑定，其实就是把 model 放到 EngineKey 中。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 回收资源&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Engine 中有一个资源回收器 ResourceRecycler ，Resource 接口中有一个 recycle() 方法，关于 Resource 我们后面再讲。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里只要知道，当 SingleRequest 被清除，比如在 into() 方法中发现 Target 已经有对应的 Request 时，Request 就会让 Engine 释放资源，具体做释放资源操作的就是 ResourceRecycler。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 磁盘缓存提供器&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LazyDiskCacheProvider 是 Engine 中的一个静态内部类，是磁盘缓存 DiskCache 的提供器，DiskCache 是一个接口，关于 DiskCache 的实现我们后面再讲。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 启动新的解码任务&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 Engine 从内存中找不到对应的 Key 的资源时，就会启动新的解码任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Engine 会用加载任务工厂 EngineJobFactory 构建一个加载任务 EngineJob，然后再构建一个解码任务 DecodeJob。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;EngineJob 这个名字看起来很霸气，但是实际上它并没有做什么事情，它只是 Engine 与 DecodeJob 之间沟通的桥梁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当构建了 EngineJob 和 DecodeJob 后，Engine 就会把 DecodeJob 提交到线程池 GlideExecutor 中。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3.2 Key&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面讲到了 Engine 会通过 EngineKeyFactory 创建资源标识符 Key ，那什么是 Key ？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Key 是 Glide 中的一个接口，是图片资源的标识符。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 避免比较有误&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Glide 的内存缓存和磁盘缓存用的都是 Glide 自己实现的 LruCache，LruCache 也就是最近最少使用缓存算法（Least Recently Used），LruCache 中有一个 LinkedHashMap ，这个 HashMap 的 Key 就是 Key 接口，而 Value 则是 Resource 接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在用对象作为 HashMap 的 Key 时，要重写 equals() 和 hashCode() 方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不重写这两个方法，那么当两个 Key 的内存地址不同，但是实际代表的资源相同时，使用父类 Object的 hasCode() 直接用内存地址做比较，那么结果会是不相等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外 Object 的 equals() 方法也是拿内存地址作比较，所以也要重写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如下面就是 ResourceCacheKey 的 equals() 判断逻辑。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;2.380875202593193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkFbjpYRtVyO8XicZnsNmxCAmkDAFEflkZjLZu0roibLyRx6QiahGfgZcDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;617&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. Key 实现类&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5315315315315315&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkFo3uCRvR3LaUicmJLsdrZ185z4ibgiavWJP8UVbQrzcT6ibZIaJdqOaXKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1332&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是几个实现了 Key 接口的类。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DataCacheKey&lt;/p&gt;&lt;p&gt;原始图片数据标识符。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ResourceCacheKey&lt;/p&gt;&lt;p&gt;处理后的图片资源标识符。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AndroidResourceSignature&lt;/p&gt;&lt;p&gt;Android 资源标识符。当我们传入 into() 方法的图片是 R.drawable.xxx 时，Glide 就会把它封装为 AndroidResourceSignature 。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ObjectKey&lt;/p&gt;&lt;p&gt;通用资源标识符。&lt;/p&gt;&lt;p&gt;可以说除了 App 自带的 Android 资源以外的图片资源都会用 ObjectKey 作为标识符，比如本地图片文件。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;EngineKey&lt;/p&gt;&lt;p&gt;引擎资源标识符。&lt;/p&gt;&lt;p&gt;这个 Key 是 Engine 对其他 Key 的封装，这时传进来的 Key 是以签名（Signature）的身份存在 EngineKey 中的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3.3 Resource&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面讲到了 Engine 会通过 ResourceRecycler 来回收资源，而 ResourceRecycler 调用了 Resource 的 recycle() 方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能你想起来 Bitmap 就有一个可以回收图片内存的 recycle() 方法，没错，Glide 回收 Bitmap 的方式就是用的 Bitmap 自带的 recycle() 方法，但是这个过程又比这复杂一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Resource 是一个接口，其中一个实现类是 BitmapResource ，也就是位图资源，比如网络图片就会转化为 BitmapResource。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 BitmapResource 中有一个位图池 BitmapPool，这是 Glide 用来复用 Bitmap 的一个接口，具体的实现类是 LruBitmapPool 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 BitmapResource 的 recycle() 方法中，会把对应的 Bitmap 通过 put() 方法放到 BitmapPool 中，关于 BitmapPool 在讲 Glide 缓存原理时会进一步讲。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3.4 Engine 相关问题&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Engine 的 load() 方法首先会做什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么 Key 要重写 hashCode() 和 equals() 方法？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;负责回收 Resource 的是哪个类？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加载 Drawable 资源时，会转化为哪种 Key？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.4 DecodeJob&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面讲到了 Engine 在缓存中找不到资源时，就会创建新的加载任务 EngineJob 和新的解码任务 DecodeJob ，然后让 EngineJob 启动 DecodeJob。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DecodeJob 实现了 Runnable 接口，EngineJob 启动 DecodeJob 的方式就是把它提交给 GlideExecutor，如果我们没有调整磁盘缓存策略的话，那默认用的就是 diskCacheExecutor ，关于 GlideExecutor 在第 4 大节会讲，下面我们先看下 DecodeJob 的实现。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.4.1 runWrapped()&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DecodeJob 的 run() 方法只是对 runWrapped() 可能遇到的异常进行了捕获，而 runWrapped() 方法会根据不同的运行理由 RunReason 运行不同的数据生成器。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8477188655980271&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkkBhysaQiaGv4xbXDuqTqCp2wNX3bZ7jUTOGlCjFZHibGKPnZYE6CumTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1622&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 三种运行理由&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;runWrapped() 会根据下面三种运行理由来执行解码任务。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;INITAILIZE&lt;/p&gt;&lt;p&gt;从缓存中获取数据并解码；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;SWITCH_TO_SOURCE_SERVICE&lt;/p&gt;&lt;p&gt;从来源获取数据后再进行解码；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DECODE_DATA&lt;/p&gt;&lt;p&gt;当获取数据的线程与 DecodeJob 的线程不同时，比如使用了 OkHttp-Integration 时，DecodeJob 会直接对数据进行解码；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 初始化&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当运行理由为默认状态 INITIALIZE 时，DecodeJob 会从磁盘中获取图片数据并进行解码。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 从来源获取数据&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 DecodeJob 从缓存中获取不到数据时，就会把运行理由改为 SWITCH_TO_SOURCE_SERVICE ，也就是从来源获取数据，然后运行来源数据生成器 SourceGenerator 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 对检索到的数据进行解码&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DecodeJob 通过数据生成器获取到数据后，就会调用 decodeFromRetrievedData() 方法来对检索到的数据进行解码。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.4.2 DecodeJob 数据获取流程&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0074034902168165&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkyBJau5tGkIXuzfkbHBZoWc3bolHNACiagq0BoiabY7cr13pR802APY4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1891&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 DecodeJob 的 getNextStage() 方法中，会根据当前的解码步骤 stage 来判断进行什么操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DecodeJob 把提取数据分为了 6 个阶段，这 6 个阶段是 Stage 枚举类中的值。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. INITIALIZE&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当解码处于这个阶段时，DecodeJob 会根据磁盘缓存策略，判断是否要从磁盘缓存中获取处理过的图片资源，是的话就用 ResourceCacheGenerator 获取图片资源，当用 ResourceCacheGenerator 获取到 Resource 后，就会开始对资源进行解码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果磁盘缓存策略设定了不从缓存中获取 Resource，那就会切换到 RESOURCE_CACHE 阶段。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. RESOURCE_CACHE&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从缓存中获取处理过的图片资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当解码处于这个阶段时，DecodeJob 会根据磁盘缓存策略，判断是否要从磁盘缓存中获取未处理过的图片原始数据，是的话就用 DataCacheGenerator 获取图片数据。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. DATA_CACHE&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从缓存中获取原始数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果磁盘缓存策略设定了不获取缓存中的图片资源和原始数据 ，又或者是获取不到数据，DecodeJob 那就会切换到 DATA_CACHE 阶段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们在加载图片时调用了 onlyRetrieveFromCache(true) ，那么 DecodeJob 就会不会切换到 SOURCE 阶段从来源获取数据，而是会切换到 FINISH 阶段结束数据获取流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;否则就会切换到 SOURCE 阶段。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. SOURCE&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图片来源获取原始数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 DecodeJob 在 RESOURCE_CACHE 和 DATA_CACHE 阶段都没有拿到图片数据，那就会用 SourceGenerator 从图片来源获取图片数据。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. ENCODE&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当磁盘缓存策略设定了要对图片资源进行缓存时，那么在获取到数据后，DecodeJob 就会用 ResourceDecoder 对资源进行编码，也就是把图片放到磁盘缓存中。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. FINISH&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结束。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.4.3 三种数据生成器&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 DecodeJob 切换阶段后，会调用 getNextGenerator() 切换不同阶段对应的生成器，这里说的生成器，指的是 DataFetcherGenerator 接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DataFetcherGenerator 不是像名字说的那样用来创建 DataFetcher 的，DataFetcherGenerator 与 DataFetcher 是通过 ModelLoader 来关联的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DataFetcherGenerator 会通过 ModelLoader 构建数据封装对象 LoadData ，然后通过 LoadData 中的 DataFetcher 来加载数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LoadData 是 ModelLoader 的内部类，它有来源标识符 Key 和 DataFetcher 两个字段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 ModelLoader 中最重要的就是 buildLoadData() 方法，不同类型的 Model 对应的 ModelLoader 所创建出来的 LoadData() 也不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看下 DataFetcherGenerator ，这个接口中最重要的方法是 startNext() ，具体实现了这个接口有下面三个类。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;SourceGenerator&lt;/p&gt;&lt;p&gt;来源数据生成器。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DataCacheGenerator&lt;/p&gt;&lt;p&gt;原始缓存数据生成器。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ResourceCacheGenerator&lt;/p&gt;&lt;p&gt;缓存资源生成器。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以 SourceGenerator 为例，我们来看下 startNext() 方法的处理流程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1287208366854384&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkNav9Ga7nP5ACwqd4CVNGPaZeAZNld8oLicibLOfMhMO7IoXbgqGDKs2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1243&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 是否获取到了需要缓存的数据&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 SourceGenerator 加载完数据后，会再次进入 startNext() 方法，这时就获取到了需要缓存的数据。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 是否保存原始数据&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果磁盘缓存策略设定了要保存图片的原始数据，就用数据提取器加载数据，否则就直接把图片加载给 Target 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 加载数据&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当需要保存原始数据或数据有加载路径时，SourceGenerator 就会根据 Model 的类型，使用对应的 DataFetcher 来提取数据，比如从网络上下载图片。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 是否保存原始数据&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 SourceGenerator 获取到数据后，会再次判断是否要保存原始数据，否则就直接把图片加载给 Target 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 编码&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 SourceGenerator 从 DataFetcher 中拿到数据后，会再走一遍 startNext() 方法，然后用编码器 Encoder 对数据进行编码，也就是把图片放到磁盘缓存中。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. 从磁盘中获取数据&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 SourceGenerator 把数据保存到磁盘后，不会直接加载图片，而是从磁盘中拿这张图片，然后再进行加载。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.4.4 onResourceDecoded()&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1610006414368186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxksicicGCClZJ3SJpyxmibA8zHn8mBHBPTrSJsicIWBK6zte5cmmHKt3ibohg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1559&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 DecodeJob 调用 ResourceDecoder 的 decode() 方法，并且获取到编码结果后，会调用 onResourceDecoded() 方法应用变换选项以及初始化编码管理器。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 应用变换选项&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于处理过的 Resource，onResourceDecoded() 不会再次进行变换，否则就会对图片进行变换操作。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 回收图片资源&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当对资源应用了变换选项后，DecodeJob 会把原来的资源回收掉，因为这个资源接下来也用不上了。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 缓存变换后图片资源&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;onResourceDecoded() 方法中，会根据磁盘缓存策略判断是否要对资源进行编码，如果要进行编码的话，会根据不同的编码策略创建不同的 Key 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Glide 有 SOURCE 和 TRANSFORMED 两种编码策略，分别代表对原始数据进行编码和对变换后资源进行编码。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;SOURCE&lt;/p&gt;&lt;p&gt;GIF 编码器 GifDrawableEncoder 中用的编码策略；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;TRANSFORMED&lt;/p&gt;&lt;p&gt;位图编码器 BitmapEncoder 中用的编码策略；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 初始化编码管理器&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建好 Key 后不会直接对图片进行编码，而是会修改编码管理器的 Key ，等到转码完成后再用 ResourceEncoder 进行编码。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.4.5 DecodeJob 相关问题&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;DecodeJob 会根据哪些理由来执行任务？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DecodeJob 提取数据的过程分为哪几个阶段？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DataFetcherGenerator 有哪些实现类？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Glide 有几种编码策略？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 六步加载图片&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5105842506350551&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkiaBcVeia7zCEpXl6GPjnKL4Rzm6iauO2Tjyf8PA7liaBSDUoyaSHrqcmKA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;2362&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完了解码任务启动流程，下面我们来看下当 DecodeJob 获取到图片数据后是怎么处理这些数据的，在文章的开头已经讲过 Glide 解码大致的 5 步，这里再补充一个，就是在把图片加载到 Target 后，DecodeJob 会通过 ResourceEncoder 把图片保存到本地。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中关于 Target 在 1.2 小节已经讲过，下面就不再多讲了，我们来看下其他的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Glide 对图片解码的过程涉及下面 6 个概念。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;数据来源（Model）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;原始数据（Data）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;资源（Resource）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;变换后资源（TransformedResource）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;转码后资源（TranscodedResource）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;目标（Target）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 数据来源（Model）&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Glide 会以 Model 的形式封装图片来源 ，Model 可以是 URL、本地文件和网络图片等类型。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 原始数据（Data）&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Glide 把数据源转换为Model 后，会把它加工成原始数据 Data ，一般就是输入流 InputStream ，Glide 会把这些输入流封装为 Data ，而 ModelLoader 则负责从 Data 获取原始数据。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 资源（Resource）&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取到原始数据后，Glide 会用资源解码器 ResourceDecoder 对原始数据进行解码，比如把输入流 InputStream 解码为 Bitmap，解码后的资源就是 Resource 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 变换后资源（TransformedResource）&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Glide 会根据我们的变换选项处理 Resource ，比如用 centerCrop() 裁剪就是一种变换，变换后的 Resource 就叫 TransformedResource ，负责转换的就是 Transformation 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 转码后资源（TranscodedResource）&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Glide 除了能加载静态图片，还能加载 Gif 动态图，解码后的 Bitmap 和 Gif 的类型不是统一的，为了统一处理静态和动态图片，Glide 会把 Bitmap 转换为 GlideBitmapDrawable ，而负责转码的角色则是 ResourceTranscoder 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. 目标（Target）&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Glide 最终会把图片显示到目标 Target 上，比如 ImageView 对应的就是 ImageViewTarget 。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 ModelLoader&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ModelLoader 是一个接口，负责创建 LoadData ，它有两个泛型参数 Model 和 Data。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Model&lt;/p&gt;&lt;p&gt;代表图片来源的类型，比如图片的网络地址的 Model 类型为 String ；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Data&lt;/p&gt;&lt;p&gt;代表图片的原始数据的类型，比如网络图片对应的类型为 InputStream ；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. Factory&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 DataFetcherGenerator 获取图片数据时，会调用 ModelLoaderRegistry 的 getModelLoaders() 方法，这个方法中会根据 model 的类型用 MultiModelLoaderFactory 生成对应的 ModelLoader，比如能够解析字符串的 ModelLoader 就有 7 个，关于 ModelLoaderRegistry 在后面讲 Glide 配置的时候会讲到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外每一个 ModelLoader 的实现类中都定义了一个实现了 ModelLoaderFactory 接口的静态内部类 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. handles()&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个 Model 对应这么多 ModelLoader，每个 ModelLoader 加载数据的方式都不同，这时候就要用 handles() 方法了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ModelLoader 接口有 handles() 和 buildLoadData() 两个方法，handles() 用于判断某个 Model 是否能被自己处理，比如 HttpUriLoader 的 handles() 会判断传进来的字符串是否以 http 或 https 开头，是的话则可以处理。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. buildLoadData()&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ModelLoader 之间是存在嵌套关系的，比如 HttpUriLoader 的 buildLoadData() 方法就是调用的 HttpGlideUrlLoader 的 buildLoadData() 方法，HttpGlideUrlLoader 会创建一个 HttpUrlFetcher ，然后把它放到 LoadData() 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LoadData 是 ModelLoader 中定义的一个类，它只是放置了图片来源的 Key 和要用来提取数据的 DataFetcher ，没有其他方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 ResourceDecoder&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DataFetcherGenerator 使用 ModelLoader 构建完数据后，就会用 DataRewinder 对数据进行重绕，也就是重置数据，比如 InputStreamRewinder 就会调用 RecyclableBufferedInputStream 的 reset() 方法重置输入流对应的字节数组的位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ResourceDecoder 是一个接口，有非常多的实现类，比如网络图片对应的解码器为 StreamBitmapDecoder ，StreamBitmapDecoder 的 decode() 方法调用了降采样器 Downsampler 的 decode() 方法，下图是 Downsampler 的解码逻辑。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.644278606965174&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkxbicbAmgKLThM6t7YbVMPKmqyGRBhic0qDLk2EdquFJVlwQANGe6ruaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;804&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 设置目标宽高&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除非我们通过 override() 方法把尺寸改为 Target.SIZE_ROGINAL ，否则 Glide 默认会把 ImageView 的大小作为加载图片的目标宽高。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 计算缩放后宽高&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据不同的变换选项计算缩放后宽高。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 创建空 Bitmap&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据计算后的目标宽高创建一个空的 Bitmap 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 使用 BitmapFactory 解码&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6548042704626335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkka2ncgu8VvkDsZNOFG1kw2H5Djn7HDiazcETAhf8qPln8icDO4fucV8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1967&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Downsampler 的解码方式用的是 ImageReader 的 decodeBitmap() 方法，而 ImageReader 又调用了 BitmapFactory 的 decodeStream() 方法，BitmapFactory 最终调用的是 SkImageDecoder 的 decode() 方法。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 把 Bitmap 放入 BitmapPool 中&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面讲 Resource 的时候讲到了 BitmapResource 中有一个 BitmapPool，这个 BitmapPool 是由 Downsampler 传过去的，而 Downsampler 的 BitmapPool 是由 Glide 创建并传进来的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 Transformation&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Transformation 是一个接口，它有一个 transform() 方法，这个方法是在 DecodeJob 中调用的，当 DecodeJob 发现数据源不是缓存中的 Resource 时，就会调用变换选项的 transform() 方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Transformation 的其中一个实现类是 BitmapTransformation，我们平时调用的 centerCrop() 就是 BitmapTransformation 的子类，centerCrop() 选项对应的是 CenterCrop 类，它实现了 Transformation 接口，具体的变换实现在 TransformationUtils 中。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. Matrix&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以 centerCrop() 为例，TransformationUtils 的 centerCrop() 方法会先创建一个 Matrix 矩阵，然后根据传进来的 Bitmap 计算 Matrix 的缩放比例和平移坐标。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. drawBitmap()&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置好 Matrix 后，就会根据目标宽高创建一个空的目标 Bitmap ，然后把原始 Bitmap、目标 Bitmap 和 Matrix 传给 Canvas 的 drawBitmap() 方法，然后返回 Canvas 处理好的图片。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 ResouceTranscoder&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ResourceTranscoder 是一个接口，是 Glide 中的资源转码器，它有两个泛型参数 Z 和 R ，分别代表需要进行原始类型和转码目标类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 BitmapDrawableTranscoder 的原始类型是 Bitmap，转码目标类型是 BitmapDrawable，在BitmapDrawableTranscoder 的 transcode() 方法中，会把 Bitmap 转换为 BitmapDrawable ，以便 Target 进行处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 ResourceEncoder&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ResourceEncoder 是一个接口，是 Glide 中的资源编码器，ResourceEncoder 有好几个实现类，比如网络图片对应的编码器为 StreamEncoder。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在转码完成后，DecodeJob 会先把图片加载到 Target 中，然后用 ResourceEncoder 对图片进行编码，比如 StreamEncoder 的编码操作就是把输入流 InputStream 转化为图片文件，然后保存到本地。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.6 图片加载相关问题&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;图片加载分为哪几步？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ModelLoader 有哪些泛型参数？分别代表什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ResourceDecoder 会用哪个类进行解码？最终进行解码的哪个类？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;真正进行变换操作的是哪个类？变换操作使用了哪些类？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Glide 怎么对图片数据进行编码？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. Glide 缓存原理&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Glide 使用了三级缓存机制，图片的缓存分为内存、磁盘和来源，也就是从内存获取不到图片时，再去磁盘获取图片，从磁盘获取不到图片时，再从图片来源获取图片。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;三级缓存的优势在于节省流量和内存&lt;/strong&gt;，如果不用三级缓存，每次都从服务端获取图片的话，图片消耗的流量就会非常多，如果把所有图片都放在内存的话，那就有可能发生 OOM 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看下 Glide 的内存缓存原理、磁盘缓存原理和磁盘缓存策略。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 Glide 内存缓存原理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面提到 Engine 的 load() 方法会先在内存缓存中查找 Key 对应的资源，没有的话再启动新的解码任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里说的内存缓存就是 MemoryCache，MemoryCache 是一个接口，它的实现类是 LruResourceCache。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LruResourceCache 不仅实现了 MemoryCache 接口，而且还是 LruCache 的子类，具体的内存缓存实现是在 LruCache 中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;2.2437357630979498&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkpeTXaqqibC0Bfumw34HHw99Vz875cZPhMibeMictmJBZW3rzQOZib2RIdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;878&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 LruCache 的 put() 方法中，首先会判断要保存的元素大小是否大于缓存最大值，如果是的话，则不进行保存，如果不是的话，则把当前容量加上元素的大小，并把该元素放入缓存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LruCache 比较特别的就是它的 trimToSize() 方法和 LinkedHashMap 的 accessOrder 属性。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. trimToSize()&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LruCache 在用 put() 方法保存新的元素时，它会通过 trimToSize() 方法移除最近最少使用的元素。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. accessOrder&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LruCache 中是用 LinkedHashMap 保存数据的，并且这个 LinkedHashMap 的 accessOrder 的值为 true，也就是每一次获取 LinkedHashMap 中的元素时，这个元素都会被移到链表的尾端。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 Glide 磁盘缓存原理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Glide 是用 DiskCache 保存图片文件的，DiskCache 是一个接口，这个接口中还定义了 Factory 和 Writer 两个接口，Writer 只是对 ResourceEncoder 的封装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们就来看看 DiskCache 和 DiskCache.Factory 的具体实现。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.1  DiskLruCache&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DiskCache 有两个实现类， DiskCacheAdapter 和 DiskLruCacheWrapper，DiskCacheAdapter 只是一个空实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从名字可以看得出来 DiskLruCacheWrapper 是对 DiskLruCache 的封装，具体的实现是在 DiskLruCache 中，DataCacheGenerator 和 ResourceCacheGenerator 都是用的 DiskLruCache 来获取磁盘缓存数据的。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. Entry&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和 LruCache 一样，DiskLruCache 中也有一个 LinkedHashMap ，这个 HashMap 的 Key 的类型为 String，Value 的类型为 Entry，从缓存中获取到的图片文件会放在 Entry的 cleanFiles 字段中。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. Editor&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当图片加载进入编码阶段时，DecodeJob 会通过编码管理器调用 DiskLruCacheWrapper 的 put() 方法保存图片文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 DiskLruCacheWrapper 的 put() 方法中，会通过 DiskCache 的缓存编辑器 Editor 获取图片文件，获取到图片文件后，就会用 Writer 把文件写入本地，写完后再调用 Editor 的 commit() 方法，把清理缓存的回调提交到清理线程池中。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 清理资源&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DiskLruCache 中有一个执行清理资源任务的线程池，线程池的线程数最多为 1，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个线程池要执行的任务为 cleanupCallback 回调，这个回调会执行 trimToSize() 方法，为的就是把最近最少使用的文件清除掉。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.2  DiskCache.Factory&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 DiskCache 中有一个 Factory 工厂接口，这个接口用在了 Engine 的 LazyDiskCacheProvider 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Factory 接口中，定义了默认的磁盘缓存大小为 250M，默认的缓存目录名称为 &quot;image_manager_disk_cache&quot; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Factory 主要有下面 2 个实现类。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ExternalPreferredCacheDiskCacheFactory&lt;/p&gt;&lt;p&gt;用的是 getExternalCacheDir() 。&lt;/p&gt;&lt;p&gt;对应的目录是 /data/user/0/包名/cache/image_manager_disk_cache。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;InternalCacheDiskCacheFactory&lt;/p&gt;&lt;p&gt;用的是 context.getCacheDir() 。&lt;/p&gt;&lt;p&gt;对应的目录是 /data/user/0/包名/cache 。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下 Glide 用的是 InternalCacheDiskCacheFactory ，如果想把图片放在外部缓存目录的话，可以在自定义的 GlideModule 设置 DiskCache 。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.36774193548387096&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkdic3TqLFapib3iboXqom32bzdwtuYfOM9hScO3ELE604icosqkV369HSlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3  Glide 磁盘缓存策略&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在加载图片时，我们可以用 diskCacheStratgy() 方法设置图片在磁盘的缓存策略，这个选项传入的参数类型为抽象类 DiskCacheStrategy。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;磁盘缓存策略涉及到 Glide 的数据源类型 DataSource 和编码策略 EncodeStratefy，编码策略前面讲过了，下面我们先来看看数据源 DataSource。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3.1 五种数据源&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Glide 中定义了下面 5 种数据源 DataSource。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LOCAL&lt;/p&gt;&lt;p&gt;设备上有的数据，比如 App 内置的 Drawable 也属于 LOCAL ；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;REMOTE&lt;/p&gt;&lt;p&gt;从服务端拿到的数据；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DATA_DISK_CACHE&lt;/p&gt;&lt;p&gt;从缓存中取出来的原始数据；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;RESOURCE_DISK_CACHE&lt;/p&gt;&lt;p&gt;从缓存中取出来的图片资源；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;MEMORY_CACHE&lt;/p&gt;&lt;p&gt;从内存缓存中取出来的数据；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3.2 四个抽象方法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DiskCacheStrategy 有下面 4 个抽象方法，这个 4 个方法的返回值都是布尔值。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;isDataCacheable()&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;isResourceCacheable()&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;decodeCachedResource()&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;decodeCacheData()&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. isDataCacheable()&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是否保存图片的原始数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DecodeJob 中用到的 SourceGenerator 在从图片来源获取到数据后，会根据这个方法判断是否保存图片的原始数据。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. isResourceCacheable()&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是否保存解码后的图片数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当资源解码器对图片数据进行解码后，DecodeJob 就会根据这个方法的返回值决定是否保存该 Resource 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. decodeCachedResource()&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是否对缓存的解码后的图片数据进行解码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 DecodeJob 的 getNextStage() 中，会根据这个方法的返回值判断，如果返回值为 false，意味着跳过 RESOURCE_CACHE 步骤，也就是不对缓存中处理过的图片资源进行处理。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. decodeCachedData()&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是否对缓存的原始数据进行解码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 DecodeJob 的 getNextStage() 方法中，会根据这个方法的返回值判断，如果该值为 false，意味着跳过 DATA_CACHE 步骤，也就是不对缓存中的原始图片数据进行处理。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3.2 五种缓存策略&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Glide 定义好的磁盘缓存策略有下面 5 种，默认为 AUTOMATIC。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;AUTOMATIC&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ALL&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NONE&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RESOURCE&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DATA&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. AUTOMATIC&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;isDataCacheable()&lt;/p&gt;&lt;p&gt;只保存网络图片的原始数据；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;isResourceCacheable()&lt;/p&gt;&lt;p&gt;只保存数据源为 DATA_DISK_CACHE 或 LOCAL ，并且编码策略为 TRANSFORMED 的图片资源；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;decodeCachedResource()&lt;/p&gt;&lt;p&gt;true；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;decodeCachedData()&lt;/p&gt;&lt;p&gt;true；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. ALL&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;isDataCacheable()&lt;/p&gt;&lt;p&gt;只保存网络图片的原始数据；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;isResourceCacheable()&lt;/p&gt;&lt;p&gt;不保存数据源为 RESOURCE_DISK_CACHE 和 MEMORY_CACHE 的图片资源；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;decodeCachedResource()&lt;/p&gt;&lt;p&gt;true；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;decodeCachedData()&lt;/p&gt;&lt;p&gt;true；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. DATA&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;isDataCacheable()&lt;/p&gt;&lt;p&gt;不保存数据源为 DATA_DISK_CACHE 或 MEMORY_CACHE 的图片资源；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;isResourceCacheable()&lt;/p&gt;&lt;p&gt;false；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;decodeCachedResource()&lt;/p&gt;&lt;p&gt;false；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;decodeCachedData()&lt;/p&gt;&lt;p&gt;true；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. RESOURCE&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;isDataCacheable()&lt;/p&gt;&lt;p&gt;false；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;isResourceCacheable()&lt;/p&gt;&lt;p&gt;不保存数据源为 RESOURCE_DISK_CACHE 和 MEMORY_CACHE 的图片资源；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;decodeCachedResource()&lt;/p&gt;&lt;p&gt;true；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;decodeCachedData()&lt;/p&gt;&lt;p&gt;false；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. NONE&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有方法的返回值都为 false。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4 BitmapPool&lt;span/&gt;&lt;/h3&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 减少 Bitmap 占用的内存&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BitmapResource 的 BitmapPool 用的就是 GlideBuilder 中的 BitmapPool，Downsampler 在解码后，会把图片放入 BitmapPool 中，当 BitmapResource 被回收时，也会把 Bitmap 放到 BitmapPool 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体需要用到 BitmapPool 中的 Bitmap 的地方在 TransformationUtils 中，TransformationUtils 在进行变换前会从 BitmapPool 中获取之前保存的 Bitmap。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以要这么做，是因为每一次变换都需要创建一个 Bitmap ，BitmapPool 就是为了复用这个 Bitmap 占用的内存，这样下次要做变换操作时，可以用同一个 Bitmap 就进行复用，以减少内存使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如对于 RecyclerView 中的图片，它们的大小是一样的，没必要在变换时为每张图片都创建一个新的 Bitmap。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. LruPoolStrategy&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BitmapPool 是一个接口，实现类为 LruBitmapPool ，具体的逻辑在 LruPoolStrategy 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LruPoolStrategy 也是一个接口，它的实现类为 SizeConfigStrategy，从 LruPoolStrategy 的名字可以看得出来，BitmapPool 用的是 LruCache 来保存 Bitmap 的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 LruPoolStrategy 中，会根据 Bitmap 的大小和编码选项，把 Bitmap 放到 GroupedLinkedHamp 中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.5 ArrayPool&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和 BitmapPool 一样，ArrayPool 用的也是 LruCache，也是为了减少不必要的内存浪费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如在输入流编码器 StreamEncoder 中，当把输入流转化为文件时，需要创建一个新的字节数组，如果不用 ArrayPool，而图片是在列表中加载的，那就会创建很多不必要的的字节数组。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.6 Glide 缓存相关问题&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LruCache 的缓存实现比较特别的是哪两点？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DiskLruCache 有哪 3 个特点？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DiskCacheStrategy 定义了几种磁盘缓存策略？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. Glide 初始化流程与配置&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 Glide 初始化流程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在看 Glide 的配置前，我们先来看下 Glide 的初始化流程，因为读取配置就是在初始化的过程中读取的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1.1 with()&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.5629139072847682&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkHoFBE3y0ob5PXV0ia80t9x4Kc7S9o36TZ8ej5p3cBUlEHJZz3luaVGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;453&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们调用 Glide.with() 方法时，Glide 会先用 getRetriever() 方法获取请求管理器检索器，在这个方法中还会用 get() 方法获取 Glide 实例，获取不到的话就会初始化 Glide 。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1.2 initializeGlide()&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;2.035769828926905&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxk3EVgic5tfyPqvKXR2lGWqQ9Zr2P1PDZhzlu89ebusIfFnq77UbicFhLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;643&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以在 AndroidManifest 中声明 GlideModule，也可以用 @GlideModule 注解声明 GlideModule，走的都是上面这个流程。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 应用选项&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Glide 有一个 ApppModuleGenerator，它会把读取我们设定的 AppGlideModule 中的配置，然后生成一个 GeneratedAppGlideModuleImpl 配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后用反射读取这个配置，读取到配置后，就会应用我们在 applyOptions() 中给 GlideBuilder 设置的选项。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不用生成加反射的话读取配置的话，Glide 并不知道我们会把配置叫什么，放哪里。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 创建实例&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用选项后，就会创建一个 Glide 实例。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 注册组件&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建完实例后，就会把实例的 registry 传到 registerComponents() 中，也就是我们修改编解码逻辑的地方。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 注册回调&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Glide 实现了 ComponentCallback 用于监听内存状态，这里的注册回调就是调用 ApplicationContext 的 registerComponentCallbacks() 方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 Registry&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Glide 有一个登记处 Registry ，它包含了下面这些 Registry 。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据加载器登记处 ModelLoaderRegistry&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;编码器登记处 EncoderRegistry&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;资源解码器登记处 ResourceDecoderRegistry&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;资源编码器登记处 ResourceEncoderRegistry&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据重绕器登记处 DataRewinderRegistry&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;转码器登记处 DataRewinderRegistry&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;图片头部信息解析器登记处 ImageHeaderRegistry&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Glide 的构造方法中，会把所有的编码、解码和数据加载等逻辑通过 Registry 的 append() 方法登记到 Registry 中，我们可以在 AppGlideModule 的 registerComponents() 方法中获取到 registry 实例，通过这个实例就可以替换掉对应的实现。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. registerComponents()&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如获取网络图片默认用的是 HttpUrlFetcher ，HttpUrlFetcher 是用的 HttpURLConnection 来获取图片数据的，我们可以在 registerComponents() 方法中，把 HttpUrlFetcher 替换为 OkHttp 。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9360730593607306&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxklFQnxv2QX7Pe8G5jniahgwTqAVPVN9NdwF4nehchhmEWy95lSM4Q9Eg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;876&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. Entry&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.842391304347826&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxk0QpysXztqtjO3YoXWlZmn2FFn4NfLUSQ5YLDfmQLHvicx7azR6tpia5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;552&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以要用 Class 来替换 ModelLoader ，是因为 ModelLoaderRegistry 的 append() 方法会用来源类型（Model）、原始数据类型（Data）和 ModelLoaderFactory 来创建不同类型的 Entry ，这些 Entry 会保存在 MultiModelLoaderFactory 工厂中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 DataFetcherGenerator 通过 ModelLoader 获取数据时，则会通过 model 的 Class 信息来获取 ModelLoader，除了 ModelLoaderRegistry，其他的 Registry 中也有 Entry。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3 GlideBuilder&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GlideBuilder 就是 Glide 的构建器，它包含了下面这些数据。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程池&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;图片来源线程池 sourceExecutor&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;磁盘缓存线程池 diskCacheExecutor&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;动画线程池 animationExecutor&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;内存大小计算器 memorySizeCalculator&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网络状态监听器工厂 connectivityMonitorFactory&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请求选项工厂 defaultRequestOptionsFactory&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请求管理器工厂 requestManagerFactory&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请求监听器列表 defaultRequestListeners&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;位图池 bitmapPool&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数组池 arrayPool&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存缓存 MemoryCache&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;磁盘缓存工厂 diskCacheFactory&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引擎 Engine&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这些字段大多数都是可以在 AppGlideModule 的 applyOptions() 方法中，调用 GlideBuilder 的 setXXX() 方法来替换实现的，下面我们主要看下 Glide 线程池和内存大小计算器。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3.1 Glide 线程池&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GlideExecutor 是 Glide 的线程池实现，Glide 中有下面 4 种线程池。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. SourceExecutor&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对图片来源解码的任务的线程池，线程数为最多为 4 ，最小为设备的 CPU 核数。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. unlimitedSourceExecutor&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们在加载图片时调用了 useUnlimitedSourceGeneratorsPool() 选项，那 Glide 就会用这个无线程数限制的线程池来获取图片。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. DiskCacheExecutor&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对磁盘缓存数据解码的任务的线程池，线程数为 1 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. AnimationExecutor&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是用来从图片来源获取数据的线程池，而不是用来播放 GIF 动画的线程池，当我们加载图片时调用了 useAnimationPool(true) ，那在获取图片数据时 EngineJob 就会把 DecodeJob 放到 AnimationExecutor 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果设备 CPU 核数大于等于 4 ，那 AnimationPool 线程数就是 2 ，否则就是 1 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 自定义线程池&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Glide 对于线程池只允许用 GlideBuilder 中的 Builder 来设置参数，GlideExecutor.Builder 支持下面几个参数。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;setThreadTimeoutMillis()&lt;/p&gt;&lt;p&gt;设置线程存活时间；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;setThreadCount()&lt;/p&gt;&lt;p&gt;设置线程数；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;setUncaughtThrowableStrategy()&lt;/p&gt;&lt;p&gt;设置异常处理策略，有三种可以选，也可以自己自定义，默认为 LOG。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;IGNORE&lt;/p&gt;&lt;p&gt;忽略异常；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LOG&lt;/p&gt;&lt;p&gt;打印异常日志；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;THROW&lt;/p&gt;&lt;p&gt;抛出异常；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;setName()&lt;/p&gt;&lt;p&gt;设置线程名称；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4879725085910653&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkxj0YnwOH8fhKDD09BicuwI4EPiboJOiaeD8HXLdwlelXcuek0N15ibibEUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1164&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3.2 内存大小计算器&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MemorySizeCalculator 负责计算 BitmapPool 、ArrayPool 和 MemoryCache 的大小。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. BitmapPool 大小&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BitmapPool 大小为一屏可容纳的最高图片质量的大小，比如 1080 * 1920 * 4 ≈ 7.9M 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. ArrayPool 大小&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认为 4M，如果系统版本低于 19 则为 2M。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 内存缓存大小&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存缓存大小为两屏可容纳的最高图片质量的大小，比如 1080 * 1920 * 2 * 4 ≈ 15.8M 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. maxSizeMultiplier&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MemorySizeCalculator 在计算 BitmapPool 和 MemoryCache 大小时，会通过 getMaxSize() 方法，用 ActivityManager 获取 memoryClasss，然后用 memoryClass 的值乘以 maxSizeMultiplier，maxSizeMultiplier 默认为 0.4。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;memoryClass 就是获取应用可用内存大小，比如我的 VIVO 手机给应用分配的可用内存为 256M，以我的手机为例，256 * 0.4 = 102.4 ，也就是默认情况下， BitmapPool 、ArrayPool 和 MemoryCache 的大小最多不会超过 102.4M。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 BitmapPool 、ArrayPool 和 MemoryCache 的大小加起来大于最大值时，会按这个最大值重新计算 BitmapPool 和 MemoryCache 的大小。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 自定义内存大小计算方式&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和 GlideExecutor 一样，MemorySizeCalculator 也有一个 Builder，支持下面这些参数的设置。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;setMemoryCacheSizeScreens(screens)&lt;/p&gt;&lt;p&gt;设置内存缓存大小为几屏的大小；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;setBitmapPoolScreens(screens)&lt;/p&gt;&lt;p&gt;设置 BitmapPool 大小为几屏的大小；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;setArrayPoolSize(sizeBytes)&lt;/p&gt;&lt;p&gt;设置 ArrayPool 大小；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;setMaxSizeMultiplier()&lt;/p&gt;&lt;p&gt;设置最大值乘数大小；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.4 初始化流程与配置相关问题&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;什么是 Registry ？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在哪里可以替换 Glide 的数据加载逻辑？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在哪里可以修改 Glide 的内存使用计算方式？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Glide 有几种线程池？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;BitmapPool 和 MemoryCache 的大小是怎么计算的？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. Glide 图片加载选项&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. placeholder(drawable)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用户打开 App 的时候，本来应该显示图片的控件，由于网络原因等了好几秒都没加载出来，这样用户体验就不好，所以我们可以加上一张占位图，这样用户就知道图片等下就出来了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里要注意的是，占位图只能是 App 内置图片，不能是网络图片，否则无网络的时候它就没作用了。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. error(drawable)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当用户的网络出现错误，图片加载失败时，一直显示占位图，用户就会一直等待，如果等了半天都没加载出来，用户就会觉得我们的 App 有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候我们可以用一张错误占位图，这样用户就知道有可能是网络出问题了，切换一下网络，又或者是主动联系开发者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有设置这个参数的话，出错时会显示 placeholder 中传的占位图。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. fallback()&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置当数据模型为空，也就是我们传入 load() 中的值为空时要显示的图片，没有设置 fallback 会显示错误占位图，连错误占位图也没设置就会显示 placeholder 占位图。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. override(width, height)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们不想让 Glide 把图片按 ImageView 的大小进行缩放，我们可以用这个方法来设置加载的目标宽高。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. fitCenter()&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7272727272727273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkjPvemEibnOfEwl1pH7l03HTiaFP7JfwLG2bglCyzXbAiaq3ae1jBdRPSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;484&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;fitCenter 是一个图片裁剪选项，用于把图片尺寸限定在 ImageView 内并居中，这样图片就能完全显示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择这个选项后，当图片的宽高比和 ImageView 的宽高比不同时，ImageView 就不会被填满。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. centerCrop()&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们使用了 centerCrop ()，并且图片宽高比与 ImageView 不同时，Glide 会裁剪中间的部分，以填满 ImageView ，这时图像就不是完全显示的了。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7. centerInside()&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与 fitCenter 类似，不同的是，当 ImageView 的尺寸为 wrap_content 时，fitCenter() 会把图片放大，而 centerInside() 则会保持原图大小。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2307692307692308&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkwsfauM4U4hPLcH16nr6gicDs905d3xBjZhbGBDH2nyX5IPBokXibNJ0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;481&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8. transform(Transformation)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置变换选项，比如旋转选项 Rotate 和圆角选项 RoundedCorners 没有对应的方法可以直接设置，就可以用这个方法传进去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想要同时多种变换选项，也要从这个参数传进去，比如 transform(CenterCrop(), RoundedCorners()) ，这样创建的就是多重变换 MultiTransformation ，否则只有后面设置的变换选项会起效。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9. dontTransform()&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;禁止变换，调用这个方法后会删除之前设定的变换选项。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10. skipMemoryCache(boolean)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跳过内存缓存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下 Glide 会把图片放在内存缓存中，如果我们不想要让某张图片保留在内存缓存中，比如加载高清原图时，可以把这个值改为 true 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;11. diskCacheStrategy(strategy)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;磁盘缓存策略，Glide 自带了 5 种磁盘缓存策略，默认为 AUTOMATIC。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ALL&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NONE&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DATA&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RESOURCE&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AUTOMATIC&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;12. onlyRetrieveFromCache(boolean)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果传 true ，表示不从图片来源获取数据，只从缓存中读取数据。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;13.priority&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置加载图片的优先级，比如运营图的优先级就比其他图片高，Glide 的加载优先级有下面四种。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;IMMEDIATE&lt;/p&gt;&lt;p&gt;立即加载；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;HIGH&lt;/p&gt;&lt;p&gt;高优先级；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;NORMAL&lt;/p&gt;&lt;p&gt;正常优先级；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LOW&lt;/p&gt;&lt;p&gt;低优先级；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;14. sizeMultiplier(float)&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.096311475409836&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkysyIIa3aeATfPfoGCo6wq8n8ziahz99lIHm08bGfm23zLIdrUWYQD2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;488&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按比例缩放图片。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;15. encodeFormat(CompressFormat)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置下载或缓存的图片的编码类型，比如 JPEG、PNG、WEBP。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有设置 encodeFormat，并且图像有透明通道，那 Glide 默认会把以 PNG 的方式保存图片，否则就是 JPEG。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;16. encodeQuality(int)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置下载或缓存的图片的编码质量，这个参数会传到 Bitmap.compress() 方法中。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;17. frame(long)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;取视频中某一帧的作为图片。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;18. format(DecodeFormat)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置解码格式，比如 ARGB_8888、RGB_565 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;19. timeout(milliseconds)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置网络图片的请求超时，默认为 2500 毫秒。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;20. transition(options)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置过渡动画，这里的 options 传的是 TransitionOptions ，这是一个抽象类，它有三个子类。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;GenericTransitionOptions.with()&lt;/p&gt;&lt;p&gt;自定义动画。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DrawableTransitionOptions.withCrossFade()&lt;/p&gt;&lt;p&gt;设置图片淡入动画。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;BitmapTransitionOptions.withCrossFade()&lt;/p&gt;&lt;p&gt;如果调用了 asBitmap() 方法，就要用这个过渡动画。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;21. dontAnimate()&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不播放 GIF 动画 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;22. apply(options)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用选项。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6298701298701299&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkEcsBl5EdiaewoSWsBicZUL29gFW6icrvVuGfpmCmenwlTgzKVqjXfMYtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;616&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;23. listener(RequestListener)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置请求监听器 ，这个接口有下面两个回调。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;onResourceReady()&lt;/p&gt;&lt;p&gt;图片加载完成回调。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;onLoadFailed()&lt;/p&gt;&lt;p&gt;图片加载失败回调。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;24. asBitmap()&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把解码类型改为 Bitmap 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法并不是 BaseRequestOptions 提供的，而是 RequestManager 中的，但是对于外部使用者来说，这就是一个加载选项，不同的是，这个选项需要在 load() 方法前调用。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;25.asFile()&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把解码类型改为 File，也就是用 submit().get() 获取到的类型为 File 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;26. submit()&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以用 submit() 方法来获取我们想要的图片类型，比如文件、Bitmap 和 Drawable 等，但是要注意的是这个方法要在子线程中执行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6883116883116883&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkYbO8R5b8WKnh8TpQrTV03bgU9sXRia4jugOV3miadxsjZjxNT1eZJf2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;616&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;27. downloadOnly()&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设定只下载图片，不加载图片。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个选项就是 asFile() + diskCacheStrategy(DATA) + priority(LOW) + skiptMmoeryCache(true) 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;28. download()&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法相当于是用 download(image) 替换 downloadOnly().load(image) 。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;29. preload(width, height)&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5893719806763285&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1ePy61xrlXCEEe1jAF3kcxkTia764xKia6sial4OY50oK4Ox6jIWjpEaK60htEiaicssVoSBNljwLnzMKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;414&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;预加载图片，可以用来提前下载一些下一次启动应用的时候会用到的图片，比如闪屏页广告。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和 downloadOnly() 的区别在于不需要在子线程调用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;10大开源框架源码解析&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Glide最新版V4使用指南&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Android图片加载框架最全解析（八），带你全面了解Glide 4的用法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HashMap的key是对象&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>224b4527764afcd323af8177d3c1377e</guid>
<title>基于 qiankun 的微前端实践</title>
<link>https://toutiao.io/k/gg5peyr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;前言&lt;/h1&gt;&lt;p&gt;微前端（Micro-Frontends）是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。&lt;/p&gt;&lt;p&gt;微前端并不是前端领域的新概念。早期希望前端工程能够像后台的微服务一样，项目分开自治，核心的诉求是：&lt;/p&gt;&lt;p&gt;1、兼容不同技术栈&lt;/p&gt;&lt;p&gt;2、将项目看作页面、组件，能够复用到不同的系统中&lt;/p&gt;&lt;p&gt;早期比较成熟的 single-spa，从早期 React 的现代框架组件生命周期中获得灵感，将生命周期应用于这个应用程序，即将整个页面作为组件。&lt;/p&gt;&lt;p&gt;后来蚂蚁金融团队孵化了基于 single-spa 的 qiankun 架构，将微前端进一步的深耕，目标直指巨石应用业务难题，旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用 (&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DpU1gXA0rfwc&amp;amp;title=Frontend%20Monolith&quot; href=&quot;&quot;&gt;Frontend Monolith&lt;/a&gt;) 后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。&lt;/p&gt;&lt;p&gt;本人在深入实践微前端之后，深感 qiankun 受制于前端架构的定位，无法使用 Nodejs 等能力快速解决快速发布，构建，管理的困境，因此在此基础上做了一定程度的 APAAS 探索，将本文的项目作为 APAAS 应用快速集成到其他业务系统。&lt;/p&gt;&lt;h1&gt;qiankun 介绍&lt;/h1&gt;&lt;p&gt;首先基于作者自己的思考，给大家梳理下 qiankun 微前端的渲染流程，方便不了解微前端的同学有个大体的认识。&lt;/p&gt;&lt;p&gt;假如你不了解微前端的话，对于这个新事物的学习和探索，一般是按照 5Ws 的学习规律来学习：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Who is it about?&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;What happened?&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;When did it take place?&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Where did it take place?&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Why did it happen?&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;本文也按照类似的方式一个具体的案例去梳理 qiankun 的核心概念。&lt;/p&gt;&lt;p&gt;本文有一个业务系统 A，希望集成业务系统 B 的&lt;em&gt;&lt;strong&gt;欢迎卡片配置&lt;/strong&gt;&lt;/em&gt;功能页面。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2416666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCt8pDve5VGBXX2z9X1nYX5qJETRZczMuooVWUGiaWfMLQ8KicXK0ibBZKG9JkXRicDJFKG8G1aTNice6lw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;480&quot;/&gt;&lt;/p&gt;&lt;p&gt;那么 who 包含 qiankun 客户端、主应用 A、微应用 B 三部分，三者协作完成了微前端的设计。从产品使用的角度来看，第一步则是注册路由，确定微前端启动的时机和启动渲染的内容（when 和 where）。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { registerMicroApps, start } &lt;span&gt;from&lt;/span&gt;&lt;span&gt;&#x27;qiankun&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;registerMicroApps([&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;smart-contact-cms-index&#x27;&lt;/span&gt;, &lt;span&gt;// app name registered&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;entry&lt;/span&gt;: &lt;span&gt;&#x27;//localhost:7100&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;container&lt;/span&gt;: &lt;span&gt;&#x27;#yourContainer&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;activeRule&lt;/span&gt;: &lt;span&gt;&#x27;/yourActiveRule&#x27;&lt;/span&gt;,&lt;br/&gt;  },&lt;br/&gt;]);&lt;br/&gt;&lt;br/&gt;start();&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的实例十分简单，通过 name 来作为微应用 B 的唯一标识， entry 作为微应用 B 的资源加载地址。当路由映射到 &#x27;/yourActiveRule&#x27; 时，则请求微应用 B 的页面资源地址，解析其中的 JS 和 CSS 资源，将微应用 B 的页面渲染到 id 为 #yourContainer 的 DOM 节点。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; packageName = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;./package.json&#x27;&lt;/span&gt;).name;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;  &lt;span&gt;output&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;library&lt;/span&gt;: &lt;span&gt;`&lt;span&gt;${packageName}&lt;/span&gt;-[name]`&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;libraryTarget&lt;/span&gt;: &lt;span&gt;&#x27;umd&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;jsonpFunction&lt;/span&gt;: &lt;span&gt;`webpackJsonp_&lt;span&gt;${packageName}&lt;/span&gt;`&lt;/span&gt;,&lt;br/&gt;  },&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面是一段微应用 webpack 的配置，library 就是注册路由时的唯一标识 name 了。这里也十分好理解为啥 qiankun 要在构建资源时给 js 增加标识。&lt;/p&gt;&lt;p&gt;qiankun 客户端 entry 配置的 HTML 页面资源的地址，拉取到页面资源之后劫持 HTML 解析，自行构建 Http 请求去加载 JS 文件。很明显页面中肯定不止一段 JS 代码，就需要标识来标识那一段的入口 JS 代码了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3446054750402576&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCt8pDve5VGBXX2z9X1nYX5qFCdvVT3AQiaicfCkc5ShmXymcWwo6w7P7qJwqRjPDWYfxmAOEjfaCicEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3726&quot;/&gt;&lt;/p&gt;&lt;p&gt;下面截取了 index.js 头部代码&lt;/p&gt;&lt;pre&gt;&lt;code&gt;!&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;e,t&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;&quot;object&quot;&lt;/span&gt;==&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;exports&lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt;&quot;object&quot;&lt;/span&gt;==&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;module&lt;/span&gt;?&lt;span&gt;module&lt;/span&gt;.exports=t():&lt;span&gt;&quot;function&quot;&lt;/span&gt;==&lt;span&gt;typeof&lt;/span&gt; define&amp;amp;&amp;amp;define.amd?define([],t):&lt;span&gt;&quot;object&quot;&lt;/span&gt;==&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;exports&lt;/span&gt;?&lt;span&gt;exports&lt;/span&gt;[&lt;span&gt;&quot;smart-contact-cms-index&quot;&lt;/span&gt;]=t():e[&lt;span&gt;&quot;smart-contact-cms-index&quot;&lt;/span&gt;]=t()&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;仅仅修改微应用 B 的 webpack 是远远不够的，常规前端页面工程会在 index.js 文件中直接调用类似 ReactDOM.render API，直接去渲染到特定节点。那 qiankun 根本无法干预渲染过程，因此需要将渲染的实际交给 qiankun 客户端来控制，qiankun 受前端组件化的影响，也希望将页面做成一个暴露生命周期的组件，导出相关的生命周期钩子。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 单独 App 运行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (!isMicroApp) {&lt;br/&gt;  &lt;span&gt;// 非微前端渲染&lt;/span&gt;&lt;br/&gt;  renderApp({});&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 导出 qiankun 生命周期&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; bootstrap = &lt;span&gt;async&lt;/span&gt; () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;[smart-contact-cms] bootstrap&#x27;&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; mount = &lt;span&gt;async&lt;/span&gt; (props: any) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;[smart-contact-cms] mount&#x27;&lt;/span&gt;, props);&lt;br/&gt;  normalizeObject(props.mainAppState);&lt;br/&gt;  &lt;span&gt;// 作为微应用运行&lt;/span&gt;&lt;br/&gt;  renderApp(props);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; unmount = &lt;span&gt;async&lt;/span&gt; (props: any) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { container } = props;&lt;br/&gt;  ReactDOM.unmountComponentAtNode(container ? container.querySelector(&lt;span&gt;&#x27;#root&#x27;&lt;/span&gt;) : &lt;span&gt;document&lt;/span&gt;.querySelector(&lt;span&gt;&#x27;#root&#x27;&lt;/span&gt;));&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;细心的同学会发现有个 isMicroApp 的变量可以控制启动微前端渲染还是独立 APP 渲染，这个实际是 qiankun 客户端启动后，会在 window 上挂在 &lt;em&gt;&lt;strong&gt;__POWERED_BY_QIANKUN__&lt;/strong&gt;&lt;/em&gt; 变量标识运行时环境。&lt;/p&gt;&lt;p&gt;这里还有个小细节就是微应用的 JS CSS 文件请求是属于 &lt;strong&gt;Ftech/XHR&lt;/strong&gt; 类型，说明 js 文件的请求是 qiankun 客户端自行构造的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3445378151260504&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCt8pDve5VGBXX2z9X1nYX5q9VGFJR3ZJpy4EmVMKxhWU2wDje2VVhSJH1ib2vg1th5bOwD3Km124bQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3332&quot;/&gt;&lt;/p&gt;&lt;p&gt;至于为何要这么做？我的理解是为了实现微前端的沙箱功能。&lt;/p&gt;&lt;p&gt;qiankun 客户端干预 script 标签和 link 标签的加载过程的难度，和上面的方式相比明显是更简单的，但是这种方式很明显是缺乏安全性，特别是在面临第三方 SDK 加载的时候，例如微信 web SDK 的引入，就无法通过其安全校验，具体可以详细看下 &lt;strong&gt;FAQ 1&lt;/strong&gt; 的案例介绍。&lt;/p&gt;&lt;p&gt;一句话总结上述过程：&lt;/p&gt;&lt;p&gt;在 qiankun 的框架下，一个页面集成到另外一个页面系统中，最关键的核心点就是将微应用封装成具有生命周期的页面组件，使得 qiankun 可以调用 React 或者 Vue 的 render 能力，将页面渲染到对应的 DOM 节点。&lt;/p&gt;&lt;h1&gt;APAAS 架构介绍&lt;/h1&gt;&lt;p&gt;本文由于篇幅限制，只介绍 Client 端、Server 端的接口协议代理、微应用改造，其他部分更多是偏向于自动工程化和项目管理的方面，之后有时间给大家详细介绍下。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5331230283911672&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCt8pDve5VGBXX2z9X1nYX5qSHz0kBAWNZichLLvokBKLVTQZySZ2JVq1whoqeonetQN2bnnHHGlojA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2853&quot;/&gt;&lt;/p&gt;&lt;h2&gt;Client 端&lt;/h2&gt;&lt;p&gt;Client 端是经过业务封装后的 qiankun SDK，内部集成了经过 qiankun 改造的各自子应用系统，对外暴露以下接口：&lt;/p&gt;&lt;h3&gt;1、initial(appInfo)&lt;/h3&gt;&lt;p&gt;appInfo 参数&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;    &lt;span&gt;&quot;app_id&quot;&lt;/span&gt;: &lt;span&gt;&quot;xxx&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;prefetch&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;signUrl&quot;&lt;/span&gt;: &lt;span&gt;&quot;remote-url&quot;&lt;/span&gt;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个接口主要是为了初始化部分信息，包括微应用的鉴权配置、是否启动预加载、微应用的标识。其中鉴权配置可能会让大家感到疑惑。&lt;/p&gt;&lt;p&gt;在介绍 qiankun 的渲染过程中提到&lt;/p&gt;&lt;p&gt;这里还有个小细节就是微应用的 JS CSS 文件请求是属于 &lt;strong&gt;Ftech/XHR&lt;/strong&gt; 类型，说明 js 文件的请求是 qiankun 客户端自行构造的。&lt;/p&gt;&lt;p&gt;这里必然要涉及前端的跨域问题，尤其是当主应用和微应用的域名不一致时，qiankun 客户端如何能够在跨域的限制之下获取到微应用的页面资源？本文的解决方案是主应用提供一个鉴权秘钥下发的接口 signUrl，这个接口由微应用提供也可以，将秘钥信息下发到 cookie 中，通过配置 qiankin 自定义 fetch 方法，带上这些鉴权信息。&lt;/p&gt;&lt;p&gt;本文只是其中一个解决方案，官方也提供了一些通用方案以供参考《&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fqiankun.umijs.org%2Fzh%2Ffaq%23%25E5%25BE%25AE%25E5%25BA%2594%25E7%2594%25A8%25E9%259D%2599%25E6%2580%2581%25E8%25B5%2584%25E6%25BA%2590%25E4%25B8%2580%25E5%25AE%259A%25E8%25A6%2581%25E6%2594%25AF%25E6%258C%2581%25E8%25B7%25A8%25E5%259F%259F%25E5%2590%2597&amp;amp;title=%E5%BE%AE%E5%BA%94%E7%94%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%B8%80%E5%AE%9A%E8%A6%81%E6%94%AF%E6%8C%81%E8%B7%A8%E5%9F%9F%E5%90%97&quot; href=&quot;&quot;&gt;微应用静态资源一定要支持跨域吗&lt;/a&gt;》。&lt;/p&gt;&lt;h3&gt;2、load (FloadConfig) 接口&lt;/h3&gt;&lt;p&gt;动态加载微应用，其 FloadConfig 参数如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;interface FLoadConfig {&lt;br/&gt;  &lt;span&gt;container&lt;/span&gt;: string;&lt;br/&gt;  pageId: string;&lt;br/&gt;  props?: FMicroProps; &lt;span&gt;// 传入对应微应用所需要的参数&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;interface FMicroProps {&lt;br/&gt;  loginUrl?: string, &lt;span&gt;// 登录的重定向地址&lt;/span&gt;&lt;br/&gt;  baseApiUrl?: string,&lt;br/&gt;  dispatch?: &lt;span&gt;(&lt;span&gt;value: { type: string; data: any }&lt;/span&gt;) =&amp;gt;&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;,&lt;br/&gt;  pageInfo?: FPageConfig,&lt;br/&gt;  useNativeRoute?: number;&lt;br/&gt;  extra?: any,&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;loginUrl 是鉴权失败跳转的登录地址；baseApiUrl 是后台请求的地址；useNativeRoute 决定微前端采用何种路由方式加载。&lt;/p&gt;&lt;p&gt;本文在这个阶段主要做两方面的突破：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;解决了后台请求的跨域和鉴权&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;解决了主应用和子应用的 path 冲突问题&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;baseApiUrl 这里默认提供了基于腾讯云的鉴权下发能力，各个业务系统只需要按照规范去对接腾讯云 API 即可，比较远离前端，在这里不做过多解读。&lt;/p&gt;&lt;p&gt;在实际的业务场景中，主应用和微应用互相无法感知到对方，因此其路由有可能会互相冲突，这里通过 useNativeRoute 参数来控制微应用的路由模式。&lt;/p&gt;&lt;p&gt;1、useNativeRoute = 0 采用配置端数据返回的路由路径&lt;br/&gt;2、useNativeRoute = 1 采用当前页面 hash 前缀 + 配置端数据返回的路由路径作为新路由&lt;br/&gt;3、useNativeRoute = 3 采用当前的页面路由不做任何改动， 默认 0&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;底层的实现逻辑则是在 &lt;strong&gt;renderApp&lt;/strong&gt; 传入主应用的路由前缀，改造相对比较简单，但是很实用。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; mount = &lt;span&gt;async&lt;/span&gt; (props: any) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;[smart-contact-cms] mount&#x27;&lt;/span&gt;, props);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 删除不能序列化的内容&lt;/span&gt;&lt;br/&gt;  normalizeObject(props.mainAppState);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 作为微应用运行&lt;/span&gt;&lt;br/&gt;  renderApp(props);&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;返回 MicroApp 实例：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;mount(): Promise;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;unmount(): Promise;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;update(customProps: object): Promise;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;getStatus(): | &quot;NOT_LOADED&quot; | &quot;LOADING_SOURCE_CODE&quot; | &quot;NOT_BOOTSTRAPPED&quot; | &quot;BOOTSTRAPPING&quot; | &quot;NOT_MOUNTED&quot; | &quot;MOUNTING&quot; | &quot;MOUNTED&quot; | &quot;UPDATING&quot; | &quot;UNMOUNTING&quot; | &quot;UNLOADING&quot; | &quot;SKIP_BECAUSE_BROKEN&quot; | &quot;LOAD_ERROR&quot;;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;loadPromise: Promise;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;bootstrapPromise: Promise;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;mountPromise: Promise;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;unmountPromise: Promise;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;详情参考参考 &lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fqiankun.umijs.org%2Fzh%2Fapi&amp;amp;title=qiankun%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3&quot; href=&quot;&quot;&gt;qiankun 官方文档&lt;/a&gt;。&lt;/p&gt;&lt;h3&gt;3、subscribe(callback: (value: FMicroEvent) =&amp;gt; void): Unsubscribe&lt;/h3&gt;&lt;p&gt;监听主子应用的事件和数据，callback 函数 ({type: string; data: any}) =&amp;gt; { &lt;em&gt;处理程序&lt;/em&gt; }，目前通用返回加载完成事件 type: load，其他自定义事件由主子应用自行定义。&lt;/p&gt;&lt;p&gt;返回值：返回取消订阅的句柄。&lt;/p&gt;&lt;p&gt;其他接口在这里不做赘述了。&lt;/p&gt;&lt;h2&gt;Server 端的接口协议代理&lt;/h2&gt;&lt;p&gt;实现页面低成本接入是微前端的重要愿景之一，也是吸引大家持续探索的核心原因。&lt;br/&gt;理想业务场景下，一个被微应用改造之后的微应用集成到其他业务系统，应该无需关心后台接口，开箱即用。但是后台业务系统具有各自独立的鉴权、账户、业务逻辑，相互之间差异性极大，完全无法做到开箱即用。&lt;/p&gt;&lt;p&gt;传统的方式是主应用去主动接入微应用的后台系统，缺点很明显，主应用要了解微应用系统的后台逻辑，且每接入一个系统就要重复上述的工作，成本高且低效。&lt;/p&gt;&lt;p&gt;微前端脱胎于微应用，我们也希望微应用自己也实现微服务级别的逻辑自治，依托于腾讯云 API 托管，对外提供微应用自身的服务。这样的好处是主应用只需要要对接腾讯云生态，即可实现鉴权、账号转化、监控等能力。主应用和子应用只需要做一次，无需重复，缺点就是必须要依托于腾讯云生态。假如你的业务本身就是依托于微信、企业微信、腾讯云发展起来的，上述方式值得引入。&lt;/p&gt;&lt;h2&gt;微应用改造&lt;/h2&gt;&lt;p&gt;一个业务系统并不是一开始就有被集成的价值的，往往是在业务发展到一定程度，经过市场验证其价值之后，大家才会明确这个业务系统具有微应用改造的价值，这就导致一个窘迫的境地：你需要改造已经成型的项目，使其成为可快速接入的微应用。&lt;/p&gt;&lt;p&gt;qiankun 的微应用改造相对比较简单，一般在开启严格沙箱模式之后，微应用和主应用之间建立比较好的环境隔离，你并不需要太多的工作。&lt;/p&gt;&lt;p&gt;首先样式隔离，参考下面 &lt;strong&gt;FAQ 2、css 隔离&lt;/strong&gt; 章节的介绍。其核心的麻烦在于 qiankun 启动严格沙箱木事之后，会导致 dialog、Modal 等组件无法找到 body 节点，进而无法挂在到 DOM 中。&lt;/p&gt;&lt;p&gt;其次 JS 作用域隔离，这里主要是一些第三方库会在 window 上挂在单例实例，导致主应用和微应用之间单例配置相互覆盖，常见于日志上报、微信 SDK、QQ SDK 等第三方应用。解决方案分为两个方向:&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;假如主应用存在则沿用主应用的配置&lt;br/&gt;这种方式对主应用比较有利。以日志上报的配置为例，微应用的日志会上报到主应用空间下，那么主应用的日志监控会很完整。缺点则是微应用本身失去了这些监控信息。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;微应用对自身使用的单例进行隔离&lt;br/&gt;这种方式对微应用比较有利。以 Axios 的配置为例，子应用可以实现类似中台应用的效果，可以探知到微应用在不同的主应用中的实际使用场景和数据统计。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;本文采用的是第二种方式，假如主应用需要进行数据共享或者配置共享，可以通过主应用和微应用之间的参数和数据传递的方式来实现共享，微应用提供丰富的监听 hooks。&lt;/p&gt;&lt;h1&gt;FAQ&lt;/h1&gt;&lt;h2&gt;1、如何解决 第三方 SDK JS 文件加载失败问题&lt;/h2&gt;&lt;p&gt;微信和企业微信的 SDK 是不可以自行构建 Http 请求加载的，这是由于其安全策略导致的，且每次返回的内容有安全限制的改动，无法复用。&lt;br/&gt;因此必须要在 html 的 header 中引入，但 qiankun 会对 html header 所有 script link 资源构造请求链接，进而导致获取第三方 SD K 的请求报错，整个 qiankun 客户端加载微应用进程报错，无法加载出对应页面。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3358108108108108&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCt8pDve5VGBXX2z9X1nYX5qHdOpAOV1icMaAt8hGt7A5g1SlViafRBQZ7T3xrQFWdLZ1RGnQDZw7Y6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2960&quot;/&gt;&lt;/p&gt;&lt;p&gt;官网在常见问题给了三个解决方案：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;使用 getTemolate 过滤异常脚本；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用自定义 fetch 阻断 script 脚本；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;终极方案 - 修改 html 的 content-type&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;前两种方案需要在乾坤渲染函数中增加一个对应的参数，这里面有个坑点，则是 &lt;strong&gt;prefetchApps&lt;/strong&gt; 不支持这些参数，因此一旦启用预加载函数，则会导致渲染函数的传入配置失效，因此需要关闭使用预加载函数。&lt;/p&gt;&lt;h2&gt;2、css 隔离&lt;/h2&gt;&lt;p&gt;微前端核心理念：解耦 / 技术栈无关，简单来说就是希望微应用之间，基站应用和微应用之间的技术栈可以互相隔离，从而各种定制自己的技术体系来实现开发效率和产品质量的最优化配置，这也是微前端的核心价值体现。&lt;/p&gt;&lt;p&gt;然而理想是丰满的，现实是骨感的。主流的沙箱模式是通过创建一个独立的作用域隔离作用域链，同时克隆全局变量来实现的，但是这种隔离 + 克隆方案并不完美，在复杂运行场景中，无论性能还是安全性都是难以保证的，特别是 CSS 的隔离。&lt;/p&gt;&lt;p&gt;本文基于乾坤的微前端架构，在此基础上做了一些查漏补缺的补充。&lt;/p&gt;&lt;p&gt;首先是基础页面的 CSS，采用的是成熟的 CSS module 方案，简单来说就是将 CSS 变成局部生效，每个 class 生成一个独一无二的名字。从最早的 Less、SASS，到后来的 PostCSS，再到最近的 CSS in JS，都是为了解决 CSS 全局生效带来的副作用。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;css: {&lt;br/&gt;  &lt;span&gt;loaderOptions&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;less&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;javascriptEnabled&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;modifyVars&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&#x27;@ant-prefix&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;industryAnt&#x27;&lt;/span&gt;, &lt;span&gt;// 前缀&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&#x27;primary-color&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;#0052d9&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&#x27;link-color&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;#0052d9&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&#x27;btn-primary-color&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;#ffffff&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&#x27;btn-danger-bg&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;#e34d59&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&#x27;disabled-color&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;rgba(15, 24, 41, .3);&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&#x27;btn-disable-bg&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;#eaedf2&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&#x27;text-color&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;#0F1829&#x27;&lt;/span&gt;,&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;module&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;postcss&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;plugins&lt;/span&gt;: [&lt;br/&gt;        AddAntClass({ &lt;span&gt;prefix&lt;/span&gt;: &lt;span&gt;&#x27;industryAnt&#x27;&lt;/span&gt; })&lt;br/&gt;      ],&lt;br/&gt;    }&lt;br/&gt;  },&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考上面的配置，直接开启即可。&lt;/p&gt;&lt;p&gt;在前端开发过程中，我不可避免的会使用到各种前端的组件库，例如 antd、echarts，且都支持自定义主题配置，假如基站应用和微应用之间主题配置冲突了，就需要我们采用类似 CSS module 的方案，将各自应用的 CSS 应用范围控制在各自的组件控件内。&lt;/p&gt;&lt;p&gt;细心的同学已经发现，我上面的代码就包含了 antd 的类名定制的配置 - &lt;strong&gt;&#x27;@ant-prefix&#x27;: &#x27;xxxAnt&#x27;&lt;/strong&gt; ，给所有 antd 组件增加类名前缀。&lt;/p&gt;&lt;p&gt;你以为到这里就完美解决了吗？不，这才刚开始。回到我们的业务场景中去，很多页面的复用并不是一开始就设计好的，往往是产品中后期发现业务体系之间存在高度的复用性，你需要对老的项目进行改造使它支持微应用架构模式。经验丰富的你发现已有项目中，存在很多全局 class 样式，甚至全局地方类库的组件 class 样式，如果手动去调整，那绝对 boom 。&lt;/p&gt;&lt;p&gt;这里给大家提供一些工程化的方法。第三方类库的样式类名往往都是有通用类名前缀，这是我们能够解决这个问题的基本前提条件，我们在在 CSS 构建阶段对 css class 进行替换和调整。有兴趣的同学可以看下 less、 postcss 提供的插件机制，以下代码仅供参考。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; postcss = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;postcss&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = postcss.plugin(&lt;span&gt;&#x27;postcss-add-css-prefix&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;opts = {}&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; {&lt;br/&gt;    prefix = &lt;span&gt;&#x27;xxxAnt&#x27;&lt;/span&gt;&lt;br/&gt;  } = opts&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 接收两个参数，第一个是每个css文件的ast，第二个参数中可获取转换结果相关信息(包括当前css文件相关信息)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;plugin&lt;/span&gt;(&lt;span&gt;css, result&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!prefix) &lt;span&gt;return&lt;/span&gt;; &lt;span&gt;// 没传入prefix，不执行下面的逻辑&lt;/span&gt;&lt;br/&gt;    css.walkRules(&lt;span&gt;&lt;span&gt;rule&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;span&gt;// 遍历当前ast所有rule节点&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; {&lt;br/&gt;        selector&lt;br/&gt;      } = rule;&lt;br/&gt;      &lt;span&gt;// 只有当节点是ast根节点直属子节点时才添加前缀&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// 简单做了容错处理，只要带有根选择器的都不添加前缀，本身带有前缀了也不添加&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// 加了个flag，防止节点更新后重复执行该逻辑进入死循环&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (rule.parent.type === &lt;span&gt;&#x27;root&#x27;&lt;/span&gt; &amp;amp;&amp;amp; selector.indexOf(&lt;span&gt;&#x27;.ant-&#x27;&lt;/span&gt;) &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; selector.indexOf(&lt;span&gt;`&lt;span&gt;${prefix}&lt;/span&gt;-`&lt;/span&gt;) &amp;lt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; !rule.flag) {&lt;br/&gt;        rule.flag = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; clone = rule.clone();&lt;br/&gt;        clone.selector = selector.split(&lt;span&gt;&#x27; &#x27;&lt;/span&gt;).map(&lt;span&gt;&lt;span&gt;item&lt;/span&gt; =&amp;gt;&lt;/span&gt; item.replace(&lt;span&gt;&#x27;.ant-&#x27;&lt;/span&gt;, &lt;span&gt;`.&lt;span&gt;${prefix}&lt;/span&gt;-`&lt;/span&gt;)).join(&lt;span&gt;&#x27; &#x27;&lt;/span&gt;);&lt;br/&gt;        rule.replaceWith(clone)&lt;br/&gt;      }&lt;br/&gt;    })&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; plugin&lt;br/&gt;})&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;经过以上调整，样式终于隔离成功，微前端接入后展示完美，此时测试的反馈打破了你的幻想：confirm 的弹窗提示不显示了。经过排查发现 ant-prefix + css 插件的方案，无法对动态生成的组件样式进行调整，因此它的样式会丢失。&lt;br/&gt;最终在 Ant Design of React 官方的 FAQ 中找到了线索，&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2107168718320058&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCt8pDve5VGBXX2z9X1nYX5qJb8Z05zrt4VDWdEv01Smrh4Oc2l2B7h34pjF1HibdAXOrxylVhKyq2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2762&quot;/&gt;&lt;/p&gt;&lt;p&gt;但是这个方案并不适用于本文使用 antdv 1.x 版本的微应用项目，不支持这些 API。在 3.x 版本 FAQ 中给了一个推荐方案。&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32096635030198445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCt8pDve5VGBXX2z9X1nYX5qgxelBjBbGibNXICLQsnXwVuBH2ofgaCIJdG7fGKmNXiaFzS3UiapeckpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2318&quot;/&gt;&lt;br/&gt;这种方案是适用于 vue 3.x，对于 vue 2.x 的项目则需要使用 &quot;@vue/composition-api&quot; 来兼容 getCurrentInstance 等 API。经过实践发现本文的项目的 antv 的版本是 1.x 的，无法支持 appContext 参数，最终探索了最终的解决方案。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;this&lt;/span&gt;.$confirm({&lt;br/&gt;  &lt;span&gt;prefixCls&lt;/span&gt;: &lt;span&gt;`&lt;span&gt;${ANT_PREFIX}&lt;/span&gt;-modal`&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;title&lt;/span&gt;: &lt;span&gt;&#x27;正在上传，确定要停止吗？&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;cancelText&lt;/span&gt;: &lt;span&gt;&#x27;取消&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;cancelButtonProps&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;props&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;prefixCls&lt;/span&gt;: &lt;span&gt;`&lt;span&gt;${ANT_PREFIX}&lt;/span&gt;-btn`&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;okText&lt;/span&gt;: &lt;span&gt;&#x27;停止&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;centered&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;okButtonProps&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;props&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;danger&#x27;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;prefixCls&lt;/span&gt;: &lt;span&gt;`&lt;span&gt;${ANT_PREFIX}&lt;/span&gt;-btn`&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;  } &lt;span&gt;as&lt;/span&gt;&lt;span&gt;any&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;onOk&lt;/span&gt;: &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  },&lt;br/&gt;} &lt;span&gt;as&lt;/span&gt;&lt;span&gt;any&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;confirm 类型定义中并不包含 prefixCls，因此需要使用 as any 忽略其类型校验，实际会透传到底层 rc-dialog 组件中。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6385681293302541&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCt8pDve5VGBXX2z9X1nYX5qic0P08x1JHRRpMutDh8tIVVibhNXPmeWzS7aoxT839jEbmib3G5cOx5fA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1732&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODIwMDY2OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/3GPT1CHiaSVssAs3fYdfweBskcYpVTrKpyGRwvSia0MOULHpGU8497uAkHic3CSPvqbr1BGQY45zoj0rvLexzLVVA/0?wx_fmt=png&quot; data-nickname=&quot;前端巅峰&quot; data-alias=&quot;Java-Script-&quot; data-signature=&quot;不止前端&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97587&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.006666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/7QRTvkK2qC6D2OhibHUMz1XiaC7v0RcUA1thKEXck4AzcEnKnOXEHJibw1OEpzrL0n2O4FNrfgNaAZRcDyzDkKqiaw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>