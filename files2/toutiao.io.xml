<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>86b11757c52ad7b81d1010cff93c9d8e</guid>
<title>从前，有一个简单的通道系统叫尤娜……</title>
<link>https://toutiao.io/k/6kbx2kv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;从前，有个女生宿舍，住着小A、小B、尤娜和我4个人。有天，小A不小心把小B的床板坐塌了。小B非常生气，当场和小A翻脸。不论人缘最好的尤娜怎么中间调解都不管用。一直到毕业，小A和小B再没有说过一句话。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;后来，小A、小B和尤娜都成了公司老板，只有我一事无成。小A公司需要使用小B公司的系统，小A还记着当年的事情，没敢直接找小B，就找尤娜商量。尤娜就找到小B诉说原委。有生意小B自然是愿意做的，但是想到关系这么僵了，还是放不下身段。尤娜叹了口气：“这样吧，我们公司做一个系统，你俩都来接我吧。”&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是，尤娜成立了一个以自己名字命名的项目，看着我实在找不到工作，就让我自学编程，给她做开发。于是尤娜初版就这样上线了。架构是这样的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.9917355371900827&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRl8PicnOiboOzX9wmHLtjoBu8O4UllEHOxhgBUtB9ftia0m7RUtzrsdAJ7vb8XOObAt5UEpxHmaTvVPUw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;121&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我还只是个菜鸟，所以我的做法只是把B的http接口包装了一下，其他什么也没有做。上线之后，我发现A的调用请求一天有几个时间调用量特别大，小B公司的老师说：“扛不住了，不要把流量直接透传过来呀！”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我通过自己的学习调查，发现可以使用消息中间件做个缓冲。当A请求过来，我先把请求放到消息队列里，然后再自己消费后转发请求给B。因为消费是匀速的，就起到了削峰填谷的作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是这样，我怎么把返回结果再返回给A呢？聪明如我怎么会想不到办法，我把B返回的结果记录到数据库中。当A的请求发送到消息中间件后就循环去数据库里取结果，取到就返回这个结果给A。完美！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是我跟尤娜商量了这个想法，尤娜是我的好姐妹，我的想法她马上表示支持，让我放手去做，资源呀什么都不是问题。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我按照网上找到的&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485934&amp;amp;idx=1&amp;amp;sn=71bc51653cef4a1b3c86e663fb2a3c62&amp;amp;chksm=fafde340cd8a6a5646411696514f350cc1cb00dbac89d6989115f3eeaf1b05d9bb4167b6011e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《项目中怎样做技术选型》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《项目中怎样做技术选型》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;的文章，结合目前的特点，优缺点比较之后，消息中间件使用kafka，数据库使用mysql。经过自己的努力，尤娜第二版上线啦。架构是这样的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.667590027700831&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8PicnOiboOzX9wmHLtjoBu8O78brobwPdG89sTsMSjTxLEfBGWUCs8qOe7aAWFowADTJvBeibql3Yxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;361&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;kafka集群的内部架构，我是参考&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485702&amp;amp;idx=1&amp;amp;sn=79563d2f2d6a3e38d19459286ac26a6f&amp;amp;chksm=fafde3a8cd8a6abeec857f877d8c1353f2d959871c1634bf138103a7117abd9d5598d4b7ab84&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《Kafka生产端实际项目中的使用分析》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《Kafka生产端实际项目中的使用分析》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;这篇文章，使用zookeeper做分布式协调。上线不久后，意想不到的事情发生了：kafka broker集群挂了。不管三七二十一先重启再说。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;重启之后，尤娜消费端没有恢复，每隔3ms报一个warn日志：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Auto offset commit failed for group XXX:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; Commit cannot be completed since the group has already rebalanced and assigned the partitions to another member.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; This means that the time between subsequent calls to poll() was longer than the configured max.poll.interval.ms,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; which typically implies that the poll loop is spending too much time message processing.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我根据auto offset commit failed（自动提交offset失败了）这个信息在网上搜索了一下。通过之前的学习我知道：kafka的数据更新消费都是通过在zookeeper中标记一个偏移量（offset）来记录每个分区的消费位置，所以一旦offset更新失败，会出现重复消费数据的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终我分总结出：kafka消费者在处理消息时，在指定时间内（session.time.out）没有处理完。kafka消费要在消息处理完之后，自己提交当前的offset给kafka集群。而这时候已经超时断开连接了，导致自动提交offset失败。因此就会像日志中所说的发生rebalanced（重平衡即重新分配partition给客户端），而之前提交的offset已经失败了，所以重新分配的客户端又会消费之前的数据，接着consumer重新消费，又出现了消费超时，无限循环下去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;出现这个原因是因为我客户端使用时就是使用了spring-kafka，只用了一个@KafkaListener，没有修改任何默认配置。而默认enable.auto.commit设置成true，可以改为false，不采用自动提交方式。所谓不自动提交实际上是消费端收到消息不先处理而是先提交offset再处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种解决方案，万一提交了offset之后消费失败了不会再次处理。这样次数多了向A不好交代呀。还是先不改了。我决定先修改session.time.out时间设置长一些，重启解决问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前服务已经恢复了正常，作为菜鸟新人解决了问题觉得好激动。但是实际上细想还有好多问题没有弄明白，比如：kafka broker集群为什么挂了？太晚了，先睡觉再说。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;突然想起那时候在宿舍我们四个一起读《飘》的情景，特别喜欢里面那句名言：无论如何，明天又是新的一天！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e3a295836f129cb17a1a145f44a79893</guid>
<title>Go 高性能编程技法</title>
<link>https://toutiao.io/k/405ts7m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：dablelv，腾讯 IEGggG 后台开发工程师&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;代码的稳健、可读和高效是我们每一个 coder 的共同追求。本文将结合 Go 语言特性，为书写效率更高的代码，从常用数据结构、内存管理和并发，三个方面给出相关建议。话不多说，让我们一起学习 Go 高性能编程的技法吧。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;常用数据结构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.反射虽好，切莫贪杯&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标准库 reflect 为 Go 语言提供了运行时动态获取对象的类型和值以及动态创建对象的能力。反射可以帮助抽象和简化代码，提高开发效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言标准库以及很多开源软件中都使用了 Go 语言的反射能力，例如用于序列化和反序列化的 json、ORM 框架 gorm、xorm 等。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 优先使用 strconv 而不是 fmt&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本数据类型与字符串之间的转换，优先使用 strconv 而不是 fmt，因为前者性能更佳。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Bad&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt; s := fmt.Sprint(rand.Int())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;BenchmarkFmtSprint&lt;span&gt;-4&lt;/span&gt;    &lt;span&gt;143&lt;/span&gt; ns/op    &lt;span&gt;2&lt;/span&gt; allocs/op&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Good&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt; s := strconv.Itoa(rand.Int())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;BenchmarkStrconv&lt;span&gt;-4&lt;/span&gt;    &lt;span&gt;64.2&lt;/span&gt; ns/op    &lt;span&gt;1&lt;/span&gt; allocs/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么性能上会有两倍多的差距，因为 fmt 实现上利用反射来达到范型的效果，在运行时进行类型的动态判断，所以带来了一定的性能损耗。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 少量的重复不比反射差&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时，我们需要一些工具函数。比如从 uint64 切片过滤掉指定的元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用反射，我们可以实现一个类型泛化支持扩展的切片过滤函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// DeleteSliceElms 从切片中过滤指定元素。注意：不修改原切片。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;DeleteSliceElms&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;interface&lt;/span&gt;{}, elms ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} {&lt;br/&gt; &lt;span&gt;// 构建 map set。&lt;/span&gt;&lt;br/&gt; m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;interface&lt;/span&gt;{}]&lt;span&gt;struct&lt;/span&gt;{}, &lt;span&gt;len&lt;/span&gt;(elms))&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, v := &lt;span&gt;range&lt;/span&gt; elms {&lt;br/&gt;  m[v] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 创建新切片，过滤掉指定元素。&lt;/span&gt;&lt;br/&gt; v := reflect.ValueOf(i)&lt;br/&gt; t := reflect.MakeSlice(reflect.TypeOf(i), &lt;span&gt;0&lt;/span&gt;, v.Len())&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; v.Len(); i++ {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; _, ok := m[v.Index(i).Interface()]; !ok {&lt;br/&gt;   t = reflect.Append(t, v.Index(i))&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; t.Interface()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们可能只需要操作一个类型的切片，利用反射实现的类型泛化扩展的能力压根没用上。退一步说，如果我们真地需要对 uint64 以外类型的切片进行过滤，拷贝一次代码又何妨呢？可以肯定的是，绝大部份场景，根本不会对所有类型的切片进行过滤，那么反射带来好处我们并没有充分享受，但却要为其带来的性能成本买单。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// DeleteU64liceElms 从 []uint64 过滤指定元素。注意：不修改原切片。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;DeleteU64liceElms&lt;/span&gt;&lt;span&gt;(i []&lt;span&gt;uint64&lt;/span&gt;, elms ...&lt;span&gt;uint64&lt;/span&gt;)&lt;/span&gt; []&lt;span&gt;uint64&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 构建 map set。&lt;/span&gt;&lt;br/&gt; m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;uint64&lt;/span&gt;]&lt;span&gt;struct&lt;/span&gt;{}, &lt;span&gt;len&lt;/span&gt;(elms))&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, v := &lt;span&gt;range&lt;/span&gt; elms {&lt;br/&gt;  m[v] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 创建新切片，过滤掉指定元素。&lt;/span&gt;&lt;br/&gt; t := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;uint64&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;len&lt;/span&gt;(i))&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, v := &lt;span&gt;range&lt;/span&gt; i {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; _, ok := m[v]; !ok {&lt;br/&gt;   t = &lt;span&gt;append&lt;/span&gt;(t, v)&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; t&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看一下二者的性能对比。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkDeleteSliceElms&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; slice := []&lt;span&gt;uint64&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;}&lt;br/&gt; elms := []&lt;span&gt;interface&lt;/span&gt;{}{&lt;span&gt;uint64&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;), &lt;span&gt;uint64&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;), &lt;span&gt;uint64&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;), &lt;span&gt;uint64&lt;/span&gt;(&lt;span&gt;7&lt;/span&gt;), &lt;span&gt;uint64&lt;/span&gt;(&lt;span&gt;9&lt;/span&gt;)}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = DeleteSliceElms(slice, elms...)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkDeleteU64liceElms&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; slice := []&lt;span&gt;uint64&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;}&lt;br/&gt; elms := []&lt;span&gt;uint64&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = DeleteU64liceElms(slice, elms...)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面的基准测试。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; test -bench=. -benchmem main/reflect &lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/reflect&lt;br/&gt;cpu: Intel(R) Core(TM) i7&lt;span&gt;-9750&lt;/span&gt;H CPU @ &lt;span&gt;2.60&lt;/span&gt;GHz&lt;br/&gt;BenchmarkDeleteSliceElms&lt;span&gt;-12&lt;/span&gt;              &lt;span&gt;1226868&lt;/span&gt;               &lt;span&gt;978.2&lt;/span&gt; ns/op           &lt;span&gt;296&lt;/span&gt; B/op         &lt;span&gt;16&lt;/span&gt; allocs/op&lt;br/&gt;BenchmarkDeleteU64liceElms&lt;span&gt;-12&lt;/span&gt;            &lt;span&gt;8249469&lt;/span&gt;               &lt;span&gt;145.3&lt;/span&gt; ns/op            &lt;span&gt;80&lt;/span&gt; B/op          &lt;span&gt;1&lt;/span&gt; allocs/op&lt;br/&gt;PASS&lt;br/&gt;ok      main/reflect    &lt;span&gt;3.809&lt;/span&gt;s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，反射涉及了额外的类型判断和大量的内存分配，导致其对性能的影响非常明显。随着切片元素的递增，每一次判断元素是否在 map 中，因为 map 的 key 是不确定的类型，会发生变量逃逸，触发堆内存的分配。所以，可预见的是当元素数量增加时，性能差异会越来大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用反射时，请问一下自己，我真地需要它吗？&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3 慎用 binary.Read 和 binary.Write&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;binary.Read 和 binary.Write 使用反射并且很慢。如果有需要用到这两个函数的地方，我们应该手动实现这两个函数的相关功能，而不是直接去使用它们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;encoding/binary 包实现了数字和字节序列之间的简单转换以及 varints 的编码和解码。varints 是一种使用可变字节表示整数的方法。其中数值本身越小，其所占用的字节数越少。Protocol Buffers 对整数采用的便是这种编码方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中数字与字节序列的转换可以用如下三个函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Read 从结构化二进制数据 r 读取到 data。data 必须是指向固定大小值的指针或固定大小值的切片。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Read&lt;/span&gt;&lt;span&gt;(r io.Reader, order ByteOrder, data &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Write 将 data 的二进制表示形式写入 w。data 必须是固定大小的值或固定大小值的切片，或指向此类数据的指针。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Write&lt;/span&gt;&lt;span&gt;(w io.Writer, order ByteOrder, data &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Size 返回 Wirte 函数将 v 写入到 w 中的字节数。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Size&lt;/span&gt;&lt;span&gt;(v &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面以我们熟知的 C 标准库函数 ntohl() 函数为例，看看 Go 利用 binary 包如何实现。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Ntohl 将网络字节序的 uint32 转为主机字节序。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Ntohl&lt;/span&gt;&lt;span&gt;(bys []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;uint32&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; r := bytes.NewReader(bys)&lt;br/&gt; err = binary.Read(buf, binary.BigEndian, &amp;amp;num)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 如将 IP 127.0.0.1 网络字节序解析到 uint32&lt;/span&gt;&lt;br/&gt;fmt.Println(Ntohl([]&lt;span&gt;byte&lt;/span&gt;{&lt;span&gt;0x7f&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0x1&lt;/span&gt;})) &lt;span&gt;// 2130706433 &amp;lt;nil&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们针对 uint32 类型手动实现一个 ntohl() 呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NtohlNotUseBinary&lt;/span&gt;&lt;span&gt;(bys []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;uint32&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;uint32&lt;/span&gt;(bys[&lt;span&gt;3&lt;/span&gt;]) | &lt;span&gt;uint32&lt;/span&gt;(bys[&lt;span&gt;2&lt;/span&gt;])&amp;lt;&amp;lt;&lt;span&gt;8&lt;/span&gt; | &lt;span&gt;uint32&lt;/span&gt;(bys[&lt;span&gt;1&lt;/span&gt;])&amp;lt;&amp;lt;&lt;span&gt;16&lt;/span&gt; | &lt;span&gt;uint32&lt;/span&gt;(bys[&lt;span&gt;0&lt;/span&gt;])&amp;lt;&amp;lt;&lt;span&gt;24&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 如将 IP 127.0.0.1 网络字节序解析到 uint32&lt;/span&gt;&lt;br/&gt;fmt.Println(NtohlNotUseBinary([]&lt;span&gt;byte&lt;/span&gt;{&lt;span&gt;0x7f&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0x1&lt;/span&gt;})) &lt;span&gt;// 2130706433&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该函数也是参考了 encoding/binary 包针对大端字节序将字节序列转为 uint32 类型时的实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看下剥去反射前后二者的性能差异。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkNtohl&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _, _ = Ntohl([]&lt;span&gt;byte&lt;/span&gt;{&lt;span&gt;0x7f&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0x1&lt;/span&gt;})&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkNtohlNotUseBinary&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = NtohlNotUseBinary([]&lt;span&gt;byte&lt;/span&gt;{&lt;span&gt;0x7f&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0x1&lt;/span&gt;})&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面的基准测试，结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go &lt;span&gt;test&lt;/span&gt; -bench=BenchmarkNtohl.* -benchmem main/reflect&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/reflect&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz&lt;br/&gt;BenchmarkNtohl-12                       13026195                81.96 ns/op           60 B/op          4 allocs/op&lt;br/&gt;BenchmarkNtohlNotUseBinary-12           1000000000               0.2511 ns/op          0 B/op          0 allocs/op&lt;br/&gt;PASS&lt;br/&gt;ok      main/reflect    1.841s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见使用反射实现的 encoding/binary 包的性能相较于针对具体类型实现的版本，性能差异非常大。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.避免重复的字符串到字节切片的转换&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要反复从固定字符串创建字节 slice，因为重复的切片初始化会带来性能损耗。相反，请执行一次转换并捕获结果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Bad&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt; w.Write([]&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;Hello world&quot;&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;BenchmarkBad&lt;span&gt;-4&lt;/span&gt;   &lt;span&gt;50000000&lt;/span&gt;   &lt;span&gt;22.2&lt;/span&gt; ns/op&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Good&lt;/span&gt;&lt;br/&gt;data := []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;Hello world&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt; w.Write(data)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;BenchmarkGood&lt;span&gt;-4&lt;/span&gt;  &lt;span&gt;500000000&lt;/span&gt;   &lt;span&gt;3.25&lt;/span&gt; ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.指定容器容量&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽可能指定容器容量，以便为容器预先分配内存。这将在后续添加元素时减少通过复制来调整容器大小。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 指定 map 容量提示&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在尽可能的情况下，在使用 make() 初始化的时候提供容量信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[T1]T2, hint)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;向 make() 提供容量提示会在初始化时尝试调整 map 的大小，这将减少在将元素添加到 map 时为 map 重新分配内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，与 slice 不同。map capacity 提示并不保证完全的抢占式分配，而是用于估计所需的 hashmap bucket 的数量。因此，在将元素添加到 map 时，甚至在指定 map 容量时，仍可能发生分配。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Bad&lt;/span&gt;&lt;br/&gt;m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]os.FileInfo)&lt;br/&gt;&lt;br/&gt;files, _ := ioutil.ReadDir(&lt;span&gt;&quot;./files&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; _, f := &lt;span&gt;range&lt;/span&gt; files {&lt;br/&gt;    m[f.Name()] = f&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// m 是在没有大小提示的情况下创建的； 在运行时可能会有更多分配。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Good&lt;/span&gt;&lt;br/&gt;files, _ := ioutil.ReadDir(&lt;span&gt;&quot;./files&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]os.FileInfo, &lt;span&gt;len&lt;/span&gt;(files))&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; _, f := &lt;span&gt;range&lt;/span&gt; files {&lt;br/&gt;    m[f.Name()] = f&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// m 是有大小提示创建的；在运行时可能会有更少的分配。&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 指定切片容量&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在尽可能的情况下，在使用 make() 初始化切片时提供容量信息，特别是在追加切片时。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;make&lt;/span&gt;([]T, length, capacity)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与 map 不同，slice capacity 不是一个提示：编译器将为提供给 make() 的 slice 的容量分配足够的内存，这意味着后续的 append() 操作将导致零分配（直到 slice 的长度与容量匹配，在此之后，任何 append 都可能调整大小以容纳其他元素）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; size = &lt;span&gt;1000000&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Bad&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt; data := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; k := &lt;span&gt;0&lt;/span&gt;; k &amp;lt; size; k++ {&lt;br/&gt;     data = &lt;span&gt;append&lt;/span&gt;(data, k)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;BenchmarkBad&lt;span&gt;-4&lt;/span&gt;    &lt;span&gt;219&lt;/span&gt;    &lt;span&gt;5202179&lt;/span&gt; ns/op&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Good&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt; data := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, size)&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; k := &lt;span&gt;0&lt;/span&gt;; k &amp;lt; size; k++ {&lt;br/&gt;     data = &lt;span&gt;append&lt;/span&gt;(data, k)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;BenchmarkGood&lt;span&gt;-4&lt;/span&gt;   &lt;span&gt;706&lt;/span&gt;    &lt;span&gt;1528934&lt;/span&gt; ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行基准测试：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=^BenchmarkJoinStr -benchmem &lt;br/&gt;BenchmarkJoinStrWithOperator-8    66930670    17.81 ns/op    0 B/op    0 allocs/op&lt;br/&gt;BenchmarkJoinStrWithSprintf-8      7032921    166.0 ns/op    64 B/op   4 allocs/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.字符串拼接方式的选择&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 行内拼接字符串推荐使用运算符+&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;行内拼接字符串为了书写方便快捷，最常用的两个方法是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;行内字符串的拼接，主要追求的是代码的简洁可读。&lt;code&gt;fmt.Sprintf()&lt;/code&gt; 能够接收不同类型的入参，通过格式化输出完成字符串的拼接，使用非常方便。但因其底层实现使用了反射，性能上会有所损耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运算符 + 只能简单地完成字符串之间的拼接，非字符串类型的变量需要单独做类型转换。行内拼接字符串不会产生内存分配，也不涉及类型地动态转换，所以性能上优于&lt;code&gt;fmt.Sprintf()&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;从性能出发，兼顾易用可读，如果待拼接的变量不涉及类型转换且数量较少（&amp;lt;=5），行内拼接字符串推荐使用运算符 +，反之使用 &lt;code&gt;fmt.Sprintf()&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看下二者的性能对比。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Good&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithOperator&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = s1 + s2 + s3&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Bad&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithSprintf&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = fmt.Sprintf(&lt;span&gt;&quot;%s%s%s&quot;&lt;/span&gt;, s1, s2, s3)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行基准测试结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=^BenchmarkJoinStr -benchmem .&lt;br/&gt;BenchmarkJoinStrWithOperator-8    70638928    17.53 ns/op     0 B/op    0 allocs/op&lt;br/&gt;BenchmarkJoinStrWithSprintf-8      7520017    157.2 ns/op    64 B/op    4 allocs/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 非行内拼接字符串推荐使用 strings.Builder&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字符串拼接还有其他的方式，比如&lt;code&gt;strings.Join()&lt;/code&gt;、&lt;code&gt;strings.Builder&lt;/code&gt;、&lt;code&gt;bytes.Buffer&lt;/code&gt;和&lt;code&gt;byte[]&lt;/code&gt;，这几种不适合行内使用。当待拼接字符串数量较多时可考虑使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看下其性能测试的对比。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithStringsJoin&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = strings.Join([]&lt;span&gt;string&lt;/span&gt;{s1, s2, s3}, &lt;span&gt;&quot;&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithStringsBuilder&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; builder strings.Builder&lt;br/&gt;  _, _ = builder.WriteString(s1)&lt;br/&gt;  _, _ = builder.WriteString(s2)&lt;br/&gt;  _, _ = builder.WriteString(s3)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithBytesBuffer&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; buffer bytes.Buffer&lt;br/&gt;  _, _ = buffer.WriteString(s1)&lt;br/&gt;  _, _ = buffer.WriteString(s2)&lt;br/&gt;  _, _ = buffer.WriteString(s3)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithByteSlice&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; bys []&lt;span&gt;byte&lt;/span&gt;&lt;br/&gt;  bys= &lt;span&gt;append&lt;/span&gt;(bys, s1...)&lt;br/&gt;  bys= &lt;span&gt;append&lt;/span&gt;(bys, s2...)&lt;br/&gt;  _ = &lt;span&gt;append&lt;/span&gt;(bys, s3...)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithByteSlicePreAlloc&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  bys:= &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;)&lt;br/&gt;  bys= &lt;span&gt;append&lt;/span&gt;(bys, s1...)&lt;br/&gt;  bys= &lt;span&gt;append&lt;/span&gt;(bys, s2...)&lt;br/&gt;  _ = &lt;span&gt;append&lt;/span&gt;(bys, s3...)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基准测试结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=^BenchmarkJoinStr .&lt;br/&gt;goos: windows&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/perf&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9700 CPU @ 3.00GHz&lt;br/&gt;BenchmarkJoinStrWithStringsJoin-8               31543916                36.39 ns/op&lt;br/&gt;BenchmarkJoinStrWithStringsBuilder-8            30079785                40.60 ns/op&lt;br/&gt;BenchmarkJoinStrWithBytesBuffer-8               31663521                39.58 ns/op&lt;br/&gt;BenchmarkJoinStrWithByteSlice-8                 30748495                37.34 ns/op&lt;br/&gt;BenchmarkJoinStrWithByteSlicePreAlloc-8         665341896               1.813 ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从结果可以看出，&lt;code&gt;strings.Join()&lt;/code&gt;、&lt;code&gt;strings.Builder&lt;/code&gt;、&lt;code&gt;bytes.Buffer&lt;/code&gt;和&lt;code&gt;byte[]&lt;/code&gt; 的性能相近。如果结果字符串的长度是可预知的，使用 &lt;code&gt;byte[]&lt;/code&gt; 且预先分配容量的拼接方式性能最佳。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果对性能要求非常严格，或待拼接的字符串数量足够多时，建议使用  &lt;code&gt;byte[]&lt;/code&gt; 预先分配容量这种方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;综合易用性和性能，一般推荐使用&lt;code&gt;strings.Builder&lt;/code&gt;来拼接字符串。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;string.Builder&lt;/code&gt;也提供了预分配内存的方式 Grow：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithStringsBuilderPreAlloc&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; builder strings.Builder&lt;br/&gt;  builder.Grow(&lt;span&gt;9&lt;/span&gt;)&lt;br/&gt;  _, _ = builder.WriteString(s1)&lt;br/&gt;  _, _ = builder.WriteString(s2)&lt;br/&gt;  _, _ = builder.WriteString(s3)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用了 Grow 优化后的版本的性能测试结果如下。可以看出相较于不预先分配空间的方式，性能提升了很多。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BenchmarkJoinStrWithStringsBuilderPreAlloc-8    60079003                20.95 ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.遍历 []struct{} 使用下标而不是 range&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 中遍历切片或数组有两种方式，一种是通过下标，一种是 range。二者在功能上没有区别，但是在性能上会有区别吗？&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.1 []int&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先看一下遍历基本类型切片时二者的性能差别，以 []int 为例。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// genRandomIntSlice 生成指定长度的随机 []int 切片&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;genRandomIntSlice&lt;/span&gt;&lt;span&gt;(n &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; []&lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; rand.Seed(time.Now().UnixNano())&lt;br/&gt; nums := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, n)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++ {&lt;br/&gt;  nums = &lt;span&gt;append&lt;/span&gt;(nums, rand.Int())&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; nums&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkIndexIntSlice&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; nums := genRandomIntSlice(&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; tmp &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; k := &lt;span&gt;0&lt;/span&gt;; k &amp;lt; &lt;span&gt;len&lt;/span&gt;(nums); k++ {&lt;br/&gt;   tmp = nums[k]&lt;br/&gt;  }&lt;br/&gt;  _ = tmp&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkRangeIntSlice&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; nums := genRandomIntSlice(&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; tmp &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; _, num := &lt;span&gt;range&lt;/span&gt; nums {&lt;br/&gt;   tmp = num&lt;br/&gt;  }&lt;br/&gt;  _ = tmp&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行测试结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=IntSlice$ .&lt;br/&gt;goos: windows&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/perf&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9700 CPU @ 3.00GHz&lt;br/&gt;BenchmarkIndexIntSlice-8         5043324               236.2 ns/op&lt;br/&gt;BenchmarkRangeIntSlice-8         5076255               239.1 ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;genRandomIntSlice()&lt;/code&gt; 函数用于生成指定长度元素类型为 int 的切片。从最终的结果可以看到，遍历 []int 类型的切片，下标与 range 遍历性能几乎没有区别。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.2 []struct{}&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么对于稍微复杂一点的 []struct 类型呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Item &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; id  &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; val [&lt;span&gt;1024&lt;/span&gt;]&lt;span&gt;byte&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkIndexStructSlice&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; items [&lt;span&gt;1024&lt;/span&gt;]Item&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; tmp &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; j := &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;len&lt;/span&gt;(items); j++ {&lt;br/&gt;   tmp = items[j].id&lt;br/&gt;  }&lt;br/&gt;  _ = tmp&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkRangeIndexStructSlice&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; items [&lt;span&gt;1024&lt;/span&gt;]Item&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; tmp &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; k := &lt;span&gt;range&lt;/span&gt; items {&lt;br/&gt;   tmp = items[k].id&lt;br/&gt;  }&lt;br/&gt;  _ = tmp&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkRangeStructSlice&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; items [&lt;span&gt;1024&lt;/span&gt;]Item&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; tmp &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; _, item := &lt;span&gt;range&lt;/span&gt; items {&lt;br/&gt;   tmp = item.id&lt;br/&gt;  }&lt;br/&gt;  _ = tmp&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行测试结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=StructSlice$ .&lt;br/&gt;goos: windows&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/perf&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9700 CPU @ 3.00GHz&lt;br/&gt;BenchmarkIndexStructSlice-8              5079468               234.9 ns/op&lt;br/&gt;BenchmarkRangeIndexStructSlice-8         5087448               236.2 ns/op&lt;br/&gt;BenchmarkRangeStructSlice-8                38716               32265 ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出，两种通过 index 遍历 []struct 性能没有差别，但是 range 遍历 []struct 中元素时，性能非常差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;range 只遍历 []struct 下标时，性能比 range 遍历  []struct 值好很多。从这里我们应该能够知道二者性能差别之大的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Item 是一个结构体类型 ，Item 由两个字段构成，一个类型是 int，一个是类型是 [1024]byte，如果每次遍历 []Item，都会进行一次值拷贝，所以带来了性能损耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，因为 range 时获取的是值拷贝的副本，所以对副本的修改，是不会影响到原切片。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.3 []*struct&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那如果切片中是指向结构体的指针，而不是结构体呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// genItems 生成指定长度 []*Item 切片&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;genItems&lt;/span&gt;&lt;span&gt;(n &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; []*&lt;span&gt;Item&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; items := &lt;span&gt;make&lt;/span&gt;([]*Item, &lt;span&gt;0&lt;/span&gt;, n)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++ {&lt;br/&gt;  items = &lt;span&gt;append&lt;/span&gt;(items, &amp;amp;Item{id: i})&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; items&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkIndexPointer&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; items := genItems(&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; tmp &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; k := &lt;span&gt;0&lt;/span&gt;; k &amp;lt; &lt;span&gt;len&lt;/span&gt;(items); k++ {&lt;br/&gt;   tmp = items[k].id&lt;br/&gt;  }&lt;br/&gt;  _ = tmp&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkRangePointer&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; items := genItems(&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; tmp &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; _, item := &lt;span&gt;range&lt;/span&gt; items {&lt;br/&gt;   tmp = item.id&lt;br/&gt;  }&lt;br/&gt;  _ = tmp&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行性能测试结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=Pointer$ main/perf&lt;br/&gt;goos: windows&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/perf&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9700 CPU @ 3.00GHz&lt;br/&gt;BenchmarkIndexPointer-8           773634              1521 ns/op&lt;br/&gt;BenchmarkRangePointer-8           752077              1514 ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;切片元素从结构体 Item 替换为指针 *Item 后，for 和 range 的性能几乎是一样的。而且使用指针还有另一个好处，可以直接修改指针对应的结构体的值。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.4 小结&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;range 在迭代过程中返回的是元素的拷贝，index 则不存在拷贝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 range 迭代的元素较小，那么 index 和 range 的性能几乎一样，如基本类型的切片 []int。但如果迭代的元素较大，如一个包含很多属性的 struct 结构体，那么 index 的性能将显著地高于 range，有时候甚至会有上千倍的性能差异。对于这种场景，建议使用 index。如果使用 range，建议只迭代下标，通过下标访问元素，这种使用方式和 index 就没有区别了。如果想使用 range 同时迭代下标和值，则需要将切片/数组的元素改为指针，才能不影响性能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;内存管理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.使用空结构体节省内存&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 不占内存空间&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 中，我们可以使用 unsafe.Sizeof 计算出一个数据类型实例需要占用的字节数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;unsafe&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(unsafe.Sizeof(&lt;span&gt;struct&lt;/span&gt;{}{}))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面的例子将会输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; run main.&lt;span&gt;go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，Go 中空结构体 struct{} 是不占用内存空间，不像 C/C++ 中空结构体仍占用 1 字节。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 用法&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为空结构体不占据内存空间，因此被广泛作为各种场景下的占位符使用。一是节省资源，二是空结构体本身就具备很强的语义，即这里不需要任何值，仅作为占位符，达到的代码即注释的效果。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2.1 实现集合（Set）&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言标准库没有提供 Set 的实现，通常使用 map 来代替。事实上，对于集合来说，只需要 map 的键，而不需要值。即使是将值设置为 bool 类型，也会多占据 1 个字节，那假设 map 中有一百万条数据，就会浪费 1MB 的空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此呢，将 map 作为集合（Set）使用时，可以将值类型定义为空结构体，仅作为占位符使用即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Set &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s Set)&lt;/span&gt; &lt;span&gt;Has&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; _, ok := s[key]&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; ok&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s Set)&lt;/span&gt; &lt;span&gt;Add&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s[key] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s Set)&lt;/span&gt; &lt;span&gt;Delete&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;delete&lt;/span&gt;(s, key)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s := &lt;span&gt;make&lt;/span&gt;(Set)&lt;br/&gt; s.Add(&lt;span&gt;&quot;foo&quot;&lt;/span&gt;)&lt;br/&gt; s.Add(&lt;span&gt;&quot;bar&quot;&lt;/span&gt;)&lt;br/&gt; fmt.Println(s.Has(&lt;span&gt;&quot;foo&quot;&lt;/span&gt;))&lt;br/&gt; fmt.Println(s.Has(&lt;span&gt;&quot;bar&quot;&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想使用 Set 的完整功能，如初始化（通过切片构建一个 Set）、Add、Del、Clear、Contains 等操作，可以使用开源库 &lt;a href=&quot;https://github.com/deckarep/golang-set&quot; data-linktype=&quot;2&quot;&gt;golang-set&lt;/a&gt;。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2.2 不发送数据的信道&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;worker&lt;/span&gt;&lt;span&gt;(ch &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &amp;lt;-ch&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;do something&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; worker(ch)&lt;br/&gt; ch &amp;lt;- &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt; &lt;span&gt;close&lt;/span&gt;(ch)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候使用 channel 不需要发送任何的数据，只用来通知子协程（goroutine）执行任务，或只用来控制协程的并发。这种情况下，使用空结构体作为占位符就非常合适了。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2.3 仅包含方法的结构体&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Door &lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(d Door)&lt;/span&gt; &lt;span&gt;Open&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;Open the door&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(d Door)&lt;/span&gt; &lt;span&gt;Close&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;Close the door&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在部分场景下，结构体只包含方法，不包含任何的字段。例如上面例子中的 Door，在这种情况下，Door 事实上可以用任何的数据结构替代。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Door &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Door &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是 int 还是 bool 都会浪费额外的内存，因此呢，这种情况下，声明为空结构体最合适。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. struct 布局要考虑内存对齐&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 为什么需要内存对齐&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。比如 32 位的 CPU ，字长为 4 字节，那么 CPU 访问内存的单位也是 4 字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么设计的目的，是减少 CPU 访问内存的次数，加大 CPU 访问内存的吞吐量。比如同样读取 8 个字节的数据，一次读取 4 个字节那么只需要读取 2 次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU 始终以字长访问内存，如果不进行内存对齐，很可能增加 CPU 访问内存的次数，例如：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6060606060606061&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasXic8UMQ0Bbvu6iaXLy4Q8sF3gkkRyxjMxonRLkWx29jDvibWPibibkoglDhHxPorbalQiaTJNDYRfFKGw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;990&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;变量 a、b 各占据 3 字节的空间，内存对齐后，a、b 占据 4 字节空间，CPU 读取 b 变量的值只需要进行一次内存访问。如果不进行内存对齐，CPU 读取 b 变量的值需要进行 2 次内存访问。第一次访问得到 b 变量的第 1 个字节，第二次访问得到 b 变量的后两个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这个例子中也可以看到，内存对齐对实现变量的原子性操作也是有好处的，每次内存访问是原子的，如果变量的大小不超过字长，那么内存对齐后，对该变量的访问就是原子的，这个特性在并发场景下至关重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简言之：合理的内存对齐可以提高内存读写的性能，并且便于实现变量操作的原子性。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 Go 内存对齐规则&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译器一般为了减少 CPU 访存指令周期，提高内存的访问效率，会对变量进行内存对齐。Go 作为一门追求高性能的后台编程语言，当然也不例外。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go Language Specification 中 &lt;a href=&quot;https://go.dev/ref/spec#Size_and_alignment_guarantees&quot; data-linktype=&quot;2&quot;&gt;Size and alignment guarantees&lt;/a&gt; 描述了内存对齐的规则。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1.For a variable x of any type: unsafe.Alignof(x) is at least 1.
2.For a variable x of struct type: unsafe.Alignof(x) is the largest of all the values unsafe.Alignof(x.f) for each field f of x, but at least 1.
3.For a variable x of array type: unsafe.Alignof(x) is the same as the alignment of a variable of the array&#x27;s element type.&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;对于任意类型的变量 x ，unsafe.Alignof(x) 至少为 1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于结构体类型的变量 x，计算 x 每一个字段 f 的 unsafe.Alignof(x.f)，unsafe.Alignof(x) 等于其中的最大值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于数组类型的变量 x，unsafe.Alignof(x) 等于构成数组的元素类型的对齐系数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中函数 &lt;code&gt;unsafe.Alignof&lt;/code&gt; 用于获取变量的对齐系数。对齐系数决定了字段的偏移和变量的大小，两者必须是对齐系数的整数倍。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 合理的 struct 布局&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为内存对齐的存在，合理的 struct 布局可以减少内存占用，提高程序性能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; demo1 &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; a &lt;span&gt;int8&lt;/span&gt;&lt;br/&gt; b &lt;span&gt;int16&lt;/span&gt;&lt;br/&gt; c &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; demo2 &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; a &lt;span&gt;int8&lt;/span&gt;&lt;br/&gt; c &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt; b &lt;span&gt;int16&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(unsafe.Sizeof(demo1{})) &lt;span&gt;// 8&lt;/span&gt;&lt;br/&gt; fmt.Println(unsafe.Sizeof(demo2{})) &lt;span&gt;// 12&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，同样的字段，因字段排列顺序不同，最终会导致不一样的结构体大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个字段按照自身的对齐系数来确定在内存中的偏移量，一个字段因偏移而浪费的大小也不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来逐个分析，首先是 demo1：a 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节。b 是第二个字段，对齐系数为 2，因此，必须空出 1 个字节，偏移量才是 2 的倍数，从第 2 个位置开始占据 2 字节。c 是第三个字段，对齐倍数为 4，此时，内存已经是对齐的，从第 4 个位置开始占据 4 字节即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此 demo1 的内存占用为 8 字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 demo2：a 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节。c 是第二个字段，对齐倍数为 4，因此，必须空出 3 个字节，偏移量才是 4 的倍数，从第 4 个位置开始占据 4 字节。b 是第三个字段，对齐倍数为 2，从第 8 个位置开始占据 2 字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;demo2 的对齐系数由 c 的对齐系数决定，也是 4，因此，demo2 的内存占用为 12 字节。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36891385767790263&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasXic8UMQ0Bbvu6iaXLy4Q8sFf2TJrMgXLEuDYFxgsuQ7cIph3SKr8DCwljibicSS85OZiaItevkL7rxnQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1068&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;因此，在对内存特别敏感的结构体的设计上，我们可以通过调整字段的顺序，将字段宽度从小到大由上到下排列，来减少内存的占用。&lt;/strong&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4 空结构与空数组对内存对齐的影响&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;空结构与空数组在 Go 中比较特殊。没有任何字段的空 struct{} 和没有任何元素的 array 占据的内存空间大小为 0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为这一点，空 struct{} 或空 array 作为其他 struct 的字段时，一般不需要内存对齐。但是有一种情况除外：即当 struct{} 或空 array 作为结构体最后一个字段时，需要内存对齐。因为如果有指针指向该字段，返回的地址将在结构体之外，如果此指针一直存活不释放对应的内存，就会有内存泄露的问题（该内存不因结构体释放而释放）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; demo3 &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; a &lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt; b &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; demo4 &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; b &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt; a &lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(unsafe.Sizeof(demo3{})) &lt;span&gt;// 4&lt;/span&gt;&lt;br/&gt; fmt.Println(unsafe.Sizeof(demo4{})) &lt;span&gt;// 8&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，demo3{} 的大小为 4 字节，与字段 b 占据空间一致，而 demo4{} 的大小为 8 字节，即额外填充了 4 字节的空间。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.减少逃逸，将变量限制在栈上&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;变量逃逸一般发生在如下几种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;变量较大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;变量大小不确定&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;变量类型不确定&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回指针&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回引用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;闭包&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道变量逃逸的原因后，我们可以有意识的控制变量不发生逃逸，将其控制在栈上，减少堆变量的分配，降低 GC 成本，提高程序性能。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 小的拷贝好过引用&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小的拷贝好过引用，什么意思呢，就是尽量使用栈变量而不是堆变量。下面举一个反常识的例子，来证明小的拷贝比在堆上创建引用变量要好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道 Go 里面的 Array 以 pass-by-value 方式传递后，再加上其长度不可扩展，考虑到性能我们一般很少使用它。实际上，凡事无绝对。有时使用数组进行拷贝传递，比使用切片要好。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// copy/copy.go&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; capacity = &lt;span&gt;1024&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;arrayFibonacci&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; [&lt;span&gt;capacity&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; d [capacity]&lt;span&gt;int&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(d); i++ {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; i &amp;lt;= &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;   d[i] = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  d[i] = d[i&lt;span&gt;-1&lt;/span&gt;] + d[i&lt;span&gt;-2&lt;/span&gt;]&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; d&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;sliceFibonacci&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; []&lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; d := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, capacity)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(d); i++ {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; i &amp;lt;= &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;   d[i] = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  d[i] = d[i&lt;span&gt;-1&lt;/span&gt;] + d[i&lt;span&gt;-2&lt;/span&gt;]&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; d&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看一下性能对比。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkArray&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = arrayFibonacci()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkSlice&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = sliceFibonacci()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面的基准测试，将得到如下结果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=. -benchmem -gcflags=&quot;-l&quot; main/copy&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/copy&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz&lt;br/&gt;BenchmarkArray-12         692400              1708 ns/op               0 B/op          0 allocs/op&lt;br/&gt;BenchmarkSlice-12         464974              2242 ns/op            8192 B/op          1 allocs/op&lt;br/&gt;PASS&lt;br/&gt;ok      main/copy       3.908s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从测试结果可以看出，对数组的拷贝性能却比使用切片要好。为什么会这样呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sliceFibonacci() 函数中分配的局部变量切片因为要返回到函数外部，所以发生了逃逸，需要在堆上申请内存空间。从测试也过也可以看出，arrayFibonacci() 函数没有内存分配，完全在栈上完成数组的创建。这里说明了对于一些短小的对象，栈上复制的成本远小于在堆上分配和回收操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意，运行上面基准测试时，传递了禁止内联的编译选项 &quot;-l&quot;，如果发生内联，那么将不会出现变量的逃逸，就不存在堆上分配内存与回收的操作了，二者将看不出性能差异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译时可以借助选项 -gcflags=-m 查看编译器对上面两个函数的优化决策。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go build  -gcflags=-m copy/copy.go&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; &lt;span&gt;command&lt;/span&gt;-line-arguments&lt;/span&gt;&lt;br/&gt;copy/copy.go:5:6: can inline arrayFibonacci&lt;br/&gt;copy/copy.go:17:6: can inline sliceFibonacci&lt;br/&gt;copy/copy.go:18:11: make([]int, capacity) escapes to heap&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，arrayFibonacci() 和 sliceFibonacci() 函数均可内联。sliceFibonacci() 函数中定义的局部变量切片逃逸到了堆。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么多大的变量才算是小变量呢？对 Go 编译器而言，超过一定大小的局部变量将逃逸到堆上，不同的 Go 版本的大小限制可能不一样。一般是 &amp;lt;64KB，局部变量将不会逃逸到堆上。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 返回值 VS 返回指针&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值传递会拷贝整个对象，而指针传递只会拷贝地址，指向的对象是同一个。返回指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择返回指针。对于只读的占用内存较小的结构体，直接返回值能够获得更好的性能。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3 返回值使用确定的类型&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果变量类型不确定，那么将会逃逸到堆上。所以，函数返回值如果能确定的类型，就不要使用 interface{}。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是以上面斐波那契数列函数为例，看下返回值为确定类型和 interface{} 的性能差别。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; capacity = &lt;span&gt;1024&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;arrayFibonacci&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; [&lt;span&gt;capacity&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; d [capacity]&lt;span&gt;int&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(d); i++ {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; i &amp;lt;= &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;   d[i] = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  d[i] = d[i&lt;span&gt;-1&lt;/span&gt;] + d[i&lt;span&gt;-2&lt;/span&gt;]&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; d&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;arrayFibonacciIfc&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; d [capacity]&lt;span&gt;int&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(d); i++ {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; i &amp;lt;= &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;   d[i] = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  d[i] = d[i&lt;span&gt;-1&lt;/span&gt;] + d[i&lt;span&gt;-2&lt;/span&gt;]&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; d&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkArray&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = arrayFibonacci()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkIfc&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = arrayFibonacciIfc()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面的基准测试结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=. -benchmem main/copy&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/copy&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz&lt;br/&gt;BenchmarkArray-12         832418              1427 ns/op               0 B/op          0 allocs/op&lt;br/&gt;BenchmarkIfc-12           380626              2861 ns/op            8192 B/op          1 allocs/op&lt;br/&gt;PASS&lt;br/&gt;ok      main/copy       3.742s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见，函数返回值使用 interface{} 返回时，编译器无法确定返回值的具体类型，导致返回值逃逸到堆上。当发生了堆上内存的申请与回收时，性能会差一点。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.sync.Pool 复用对象&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 简介&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 是 sync 包下的一个组件，可以作为保存临时取还对象的一个“池子”。个人觉得它的名字有一定的误导性，因为 Pool 里装的对象可以被无通知地被回收，可能 sync.Cache 是一个更合适的名字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 是可伸缩的，同时也是并发安全的，其容量仅受限于内存的大小。存放在池中的对象如果不活跃了会被自动清理。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 作用&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于很多需要重复分配、回收内存的地方，sync.Pool 是一个很好的选择。频繁地分配、回收内存会给 GC 带来一定的负担，严重的时候会引起 CPU 的毛刺，而 sync.Pool 可以将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力，提升系统的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一句话总结：用来保存和复用临时对象，减少内存分配，降低 GC 压力。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3 如何使用&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 的使用方式非常简单，只需要实现 New 函数即可。对象池中没有对象时，将会调用 New 函数创建。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们有一个“学生”结构体，并复用改结构体对象。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Student &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Name   &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; Age    &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt; Remark [&lt;span&gt;1024&lt;/span&gt;]&lt;span&gt;byte&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; studentPool = sync.Pool{&lt;br/&gt;    New: &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} { &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;(Student) &lt;br/&gt;    },&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后调用 Pool 的 Get() 和 Put() 方法来获取和放回池子中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;stu := studentPool.Get().(*Student)&lt;br/&gt;json.Unmarshal(buf, stu)&lt;br/&gt;studentPool.Put(stu)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Get() 用于从对象池中获取对象，因为返回值是 interface{}，因此需要类型转换。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Put() 则是在对象使用完毕后，放回到对象池。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4 性能差异&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以 bytes.Buffer 字节缓冲器为例，利用 sync.Pool 复用 bytes.Buffer 对象，避免重复创建与回收内存，来看看对性能的提升效果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; bufferPool = sync.Pool{&lt;br/&gt; New: &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &amp;amp;bytes.Buffer{}&lt;br/&gt; },&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkBufferWithPool&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt;  buf := bufferPool.Get().(*bytes.Buffer)&lt;br/&gt;  buf.Write(data)&lt;br/&gt;  buf.Reset()&lt;br/&gt;  bufferPool.Put(buf)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkBuffer&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; buf bytes.Buffer&lt;br/&gt;  buf.Write(data)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=. -benchmem main/pool&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/pool&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz&lt;br/&gt;BenchmarkBufferWithPool-12      11987966                97.12 ns/op            0 B/op          0 allocs/op&lt;br/&gt;BenchmarkBuffer-12               1246887              1020 ns/op           10240 B/op          1 allocs/op&lt;br/&gt;PASS&lt;br/&gt;ok      main/pool       3.510s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子创建了一个 bytes.Buffer 对象池，每次只执行 Write 操作，及做一次数据拷贝，耗时几乎可以忽略。而内存分配和回收的耗时占比较多，因此对程序整体的性能影响更大。从测试结果也可以看出，使用了 Pool 复用对象，每次操作不再有内存分配。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.5 在标准库中的应用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 标准库也大量使用了 sync.Pool，例如 fmt 和 encoding/json。以 fmt 包为例，我们看下其是如何使用 sync.Pool 的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看一下最常用的标准格式化输出函数 Printf() 函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Printf formats according to a format specifier and writes to standard output.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// It returns the number of bytes written and any write error encountered.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Printf&lt;/span&gt;&lt;span&gt;(format &lt;span&gt;string&lt;/span&gt;, a ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;(n &lt;span&gt;int&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; Fprintf(os.Stdout, format, a...)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续看 Fprintf() 的定义。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Fprintf formats according to a format specifier and writes to w.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// It returns the number of bytes written and any write error encountered.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Fprintf&lt;/span&gt;&lt;span&gt;(w io.Writer, format &lt;span&gt;string&lt;/span&gt;, a ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;(n &lt;span&gt;int&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; p := newPrinter()&lt;br/&gt; p.doPrintf(format, a)&lt;br/&gt; n, err = w.Write(p.buf)&lt;br/&gt; p.free()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Fprintf() 函数的参数是一个 io.Writer，Printf() 传的是 os.Stdout，相当于直接输出到标准输出。这里的 newPrinter 用的就是 sync.Pool。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// go version go1.17 darwin/amd64&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// pp is used to store a printer&#x27;s state and is reused with sync.Pool to avoid allocations.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; pp &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    buf buffer&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; ppFree = sync.Pool{&lt;br/&gt; New: &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;(pp) },&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// newPrinter allocates a new pp struct or grabs a cached one.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;newPrinter&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;pp&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; p := ppFree.Get().(*pp)&lt;br/&gt; p.panicking = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; p.erroring = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; p.wrapErrs = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; p.fmt.init(&amp;amp;p.buf)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; p&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// free saves used pp structs in ppFree; avoids an allocation per invocation.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(p *pp)&lt;/span&gt; &lt;span&gt;free&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Proper usage of a sync.Pool requires each entry to have approximately&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// the same memory cost. To obtain this property when the stored type&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// contains a variably-sized buffer, we add a hard limit on the maximum buffer&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// to place back in the pool.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// See https://golang.org/issue/23199&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;cap&lt;/span&gt;(p.buf) &amp;gt; &lt;span&gt;64&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;10&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; p.buf = p.buf[:&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt; p.arg = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; p.value = reflect.Value{}&lt;br/&gt; p.wrappedErr = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; ppFree.Put(p)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;fmt.Printf() 的调用是非常频繁的，利用 sync.Pool 复用 pp 对象能够极大地提升性能，减少内存占用，同时降低 GC 压力。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;并发编程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.关于锁&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 无锁化&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加锁是为了避免在并发环境下，同时访问共享资源产生的安全问题。那么，在并发环境下，是否必须加锁？答案是否定的。并非所有的并发都需要加锁。适当地降低锁的粒度，甚至采用无锁化的设计，更能提升并发能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无锁化主要有两种实现，无锁数据结构和串行无锁。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1.1 无锁数据结构&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用硬件支持的原子操作可以实现无锁的数据结构，原子操作可以在 lock-free 的情况下保证并发安全，并且它的性能也能做到随 CPU 个数的增多而线性扩展。很多语言都提供 CAS 原子操作（如 Go 中的 atomic 包和 C++11 中的 atomic 库），可以用于实现无锁数据结构，如无锁链表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以一个简单的线程安全单向链表的插入操作来看下无锁编程和普通加锁的区别。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; list&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync/atomic&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&quot;golang.org/x/sync/errgroup&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Node 链表节点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Node &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Value &lt;span&gt;interface&lt;/span&gt;{}&lt;br/&gt; Next  *Node&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 有锁单向链表的简单实现&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// WithLockList 有锁单向链表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; WithLockList &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Head *Node&lt;br/&gt; mu   sync.Mutex&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Push 将元素插入到链表的首部&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(l *WithLockList)&lt;/span&gt; &lt;span&gt;Push&lt;/span&gt;&lt;span&gt;(v &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; l.mu.Lock()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; l.mu.Unlock()&lt;br/&gt; n := &amp;amp;Node{&lt;br/&gt;  Value: v,&lt;br/&gt;  Next:  l.Head,&lt;br/&gt; }&lt;br/&gt; l.Head = n&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// String 有锁链表的字符串形式输出&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(l WithLockList)&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s := &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt; cur := l.Head&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; cur == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; s != &lt;span&gt;&quot;&quot;&lt;/span&gt; {&lt;br/&gt;   s += &lt;span&gt;&quot;,&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  s += fmt.Sprintf(&lt;span&gt;&quot;%v&quot;&lt;/span&gt;, cur.Value)&lt;br/&gt;  cur = cur.Next&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; s&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 无锁单向链表的简单实现&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// LockFreeList 无锁单向链表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; LockFreeList &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Head atomic.Value&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Push 有锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(l *LockFreeList)&lt;/span&gt; &lt;span&gt;Push&lt;/span&gt;&lt;span&gt;(v &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  head := l.Head.Load()&lt;br/&gt;  headNode, _ := head.(*Node)&lt;br/&gt;  n := &amp;amp;Node{&lt;br/&gt;   Value: v,&lt;br/&gt;   Next:  headNode,&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; l.Head.CompareAndSwap(head, n) {&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// String 有锁链表的字符串形式输出&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(l LockFreeList)&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s := &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt; cur := l.Head.Load().(*Node)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; cur == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; s != &lt;span&gt;&quot;&quot;&lt;/span&gt; {&lt;br/&gt;   s += &lt;span&gt;&quot;,&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  s += fmt.Sprintf(&lt;span&gt;&quot;%v&quot;&lt;/span&gt;, cur.Value)&lt;br/&gt;  cur = cur.Next&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; s&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的实现有几点需要注意一下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）无锁单向链表实现时在插入时需要进行 CAS 操作，即调用&lt;code&gt;CompareAndSwap()&lt;/code&gt;方法进行插入，如果插入失败则进行 for 循环多次尝试，直至成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）为了方便打印链表内容，实现一个&lt;code&gt;String()&lt;/code&gt;方法遍历链表，且使用值作为接收者，避免打印对象指针时无法生效。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol start=&quot;5&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;If an operand implements method String() string, that method will be invoked to convert the object to a string, which will then be formatted as required by the verb (if any).&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们分别对两种链表做一个并发写入的操作验证一下其功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;br/&gt; &lt;span&gt;&quot;main/list&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ConcurWriteWithLockList 并发写入有锁链表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConcurWriteWithLockList&lt;/span&gt;&lt;span&gt;(l *WithLockList)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; g errgroup.Group&lt;br/&gt; &lt;span&gt;// 10 个协程并发写入链表&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;  i := i&lt;br/&gt;  g.Go(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   l.Push(i)&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; _ = g.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ConcurWriteLockFreeList 并发写入无锁链表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConcurWriteLockFreeList&lt;/span&gt;&lt;span&gt;(l *LockFreeList)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; g errgroup.Group&lt;br/&gt; &lt;span&gt;// 10 个协程并发写入链表&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;  i := i&lt;br/&gt;  g.Go(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   l.Push(i)&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; _ = g.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 并发写入与遍历打印有锁链表&lt;/span&gt;&lt;br/&gt; l1 := &amp;amp;list.WithLockList{}&lt;br/&gt; list.ConcurWriteWithLockList(l1)&lt;br/&gt; fmt.Println(l1)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 并发写入与遍历打印无锁链表&lt;/span&gt;&lt;br/&gt; l2 := &amp;amp;list.LockFreeList{}&lt;br/&gt; list.ConcurWriteLockFreeList(l2)&lt;br/&gt; fmt.Println(l2)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，多次运行上面的&lt;code&gt;main()&lt;/code&gt;函数的结果可能会不相同，因为并发是无序的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;8,7,6,9,5,4,3,1,2,0&lt;br/&gt;9,8,7,6,5,4,3,2,0,1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面再看一下链表 Push 操作的基准测试，对比一下有锁与无锁的性能差异。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkWriteWithLockList&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; l := &amp;amp;WithLockList{}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt;  l.Push(n)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;BenchmarkWriteWithLockList&lt;span&gt;-8&lt;/span&gt;    &lt;span&gt;14234166&lt;/span&gt;                &lt;span&gt;83.58&lt;/span&gt; ns/op&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkWriteLockFreeList&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; l := &amp;amp;LockFreeList{}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt;  l.Push(n)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;BenchmarkWriteLockFreeList&lt;span&gt;-8&lt;/span&gt;    &lt;span&gt;15219405&lt;/span&gt;                &lt;span&gt;73.15&lt;/span&gt; ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出无锁版本比有锁版本性能高一些。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1.2 串行无锁&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;串行无锁是一种思想，就是避免对共享资源的并发访问，改为每个并发操作访问自己独占的资源，达到串行访问资源的效果，来避免使用锁。不同的场景有不同的实现方式。比如网络 I/O 场景下将&lt;strong&gt;单 Reactor 多线程模型&lt;/strong&gt;改为&lt;strong&gt;主从 Reactor 多线程模型&lt;/strong&gt;，避免对同一个消息队列锁读取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我介绍的是后台微服务开发经常遇到的一种情况。我们经常需要并发拉取多方面的信息，汇聚到一个变量上。那么此时就存在对同一个变量互斥写入的情况。比如批量并发拉取用户信息写入到一个 map。此时我们可以将每个协程拉取的结果写入到一个临时对象，这样便将并发地协程与同一个变量解绑，然后再将其汇聚到一起，这样便可以不用使用锁。即独立处理，然后合并。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.19331742243436753&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasXic8UMQ0Bbvu6iaXLy4Q8sFJCE3nO5BibRwkgEf3biaawPGIsxcJ6qQib7aSFQdIlmaRrYHz1Zs5D9WA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1676&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了模拟上面的情况，简单地写个示例程序，对比下性能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&quot;golang.org/x/sync/errgroup&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ConcurWriteMapWithLock 有锁并发写入 map&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConcurWriteMapWithLock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; mu sync.Mutex&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; g errgroup.Group&lt;br/&gt; &lt;span&gt;// 10 个协程并发写入 map&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;  i := i&lt;br/&gt;  g.Go(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   mu.Lock()&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; mu.Unlock()&lt;br/&gt;   m[i] = i * i&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; _ = g.Wait()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; m&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ConcurWriteMapLockFree 无锁并发写入 map&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConcurWriteMapLockFree&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;// 每个协程独占一 value&lt;/span&gt;&lt;br/&gt; values := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;// 10 个协程并发写入 map&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; g errgroup.Group&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;  i := i&lt;br/&gt;  g.Go(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   values[i] = i * i&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; _ = g.Wait()&lt;br/&gt; &lt;span&gt;// 汇聚结果到 map&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i, v := &lt;span&gt;range&lt;/span&gt; values {&lt;br/&gt;  m[i] = v&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; m&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下二者的性能差异：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkConcurWriteMapWithLock&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt;  _ = ConcurWriteMapWithLock()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;BenchmarkConcurWriteMapWithLock&lt;span&gt;-8&lt;/span&gt;         &lt;span&gt;218673&lt;/span&gt;              &lt;span&gt;5089&lt;/span&gt; ns/op&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkConcurWriteMapLockFree&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt;  _ = ConcurWriteMapLockFree()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;BenchmarkConcurWriteMapLockFree&lt;span&gt;-8&lt;/span&gt;         &lt;span&gt;316635&lt;/span&gt;              &lt;span&gt;4048&lt;/span&gt; ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 减少锁竞争&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果加锁无法避免，则可以采用分片的形式，减少对资源加锁的次数，这样也可以提高整体的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 Golang 优秀的本地缓存组件  &lt;a href=&quot;https://github.com/allegro/bigcache&quot; data-linktype=&quot;2&quot;&gt;bigcache&lt;/a&gt; 、&lt;a href=&quot;https://github.com/patrickmn/go-cache&quot; data-linktype=&quot;2&quot;&gt;go-cache&lt;/a&gt;、&lt;a href=&quot;https://github.com/coocood/freecache&quot; data-linktype=&quot;2&quot;&gt;freecache&lt;/a&gt; 都实现了分片功能，每个分片一把锁，采用分片存储的方式减少加锁的次数从而提高整体性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以一个简单的示例，通过对&lt;code&gt;map[uint64]struct{}&lt;/code&gt;分片前后并发写入的对比，来看下减少锁竞争带来的性能提升。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; (&lt;br/&gt; num = &lt;span&gt;1000000&lt;/span&gt;&lt;br/&gt; m0  = &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;struct&lt;/span&gt;{}, num)&lt;br/&gt; mu0 = sync.RWMutex{}&lt;br/&gt; m1  = &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;struct&lt;/span&gt;{}, num)&lt;br/&gt; mu1 = sync.RWMutex{}&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ConWriteMapNoShard 不分片写入一个 map。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConWriteMapNoShard&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; g := errgroup.Group{}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; i++ {&lt;br/&gt;  g.Go(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   mu0.Lock()&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; mu0.Unlock()&lt;br/&gt;   m0[i] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; _ = g.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ConWriteMapTwoShard 分片写入两个 map。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConWriteMapTwoShard&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; g := errgroup.Group{}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; i++ {&lt;br/&gt;  g.Go(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; i&amp;amp;&lt;span&gt;1&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;    mu0.Lock()&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; mu0.Unlock()&lt;br/&gt;    m0[i] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   mu1.Lock()&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; mu1.Unlock()&lt;br/&gt;   m1[i] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; _ = g.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下二者的性能差异：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkConWriteMapNoShard&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  ConWriteMapNoShard()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;BenchmarkConWriteMapNoShard&lt;span&gt;-12&lt;/span&gt;                 &lt;span&gt;3&lt;/span&gt;         &lt;span&gt;472063245&lt;/span&gt; ns/op&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkConWriteMapTwoShard&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  ConWriteMapTwoShard()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;BenchmarkConWriteMapTwoShard&lt;span&gt;-12&lt;/span&gt;                &lt;span&gt;4&lt;/span&gt;         &lt;span&gt;310588155&lt;/span&gt; ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，通过对分共享资源的分片处理，减少了锁竞争，能明显地提高程序的并发性能。可以预见的是，随着分片粒度地变小，性能差距会越来越大。当然，分片粒度不是越小越好。因为每一个分片都要配一把锁，那么会带来很多额外的不必要的开销。可以选择一个不太大的值，在性能和花销上寻找一个平衡。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3 优先使用共享锁而非互斥锁&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果并发无法做到无锁化，优先使用共享锁而非互斥锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓互斥锁，指锁只能被一个 Goroutine 获得。共享锁指可以同时被多个 Goroutine 获得的锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 标准库 sync 提供了两种锁，互斥锁（sync.Mutex）和读写锁（sync.RWMutex），读写锁便是共享锁的一种具体实现。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3.1 sync.Mutex&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;互斥锁的作用是保证共享资源同一时刻只能被一个 Goroutine 占用，一个 Goroutine 占用了，其他的 Goroutine 则阻塞等待。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3859223300970874&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasXic8UMQ0Bbvu6iaXLy4Q8sFuDDfnQxBm08cRBpsiacfibcOFSnm1wWmtkBp9zFNeaq0WMdl55LehQCQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;824&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Mutex 提供了两个导出方法用来使用锁。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Lock()   &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;Unlock()   &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过在访问共享资源前前用 Lock 方法对资源进行上锁，在访问共享资源后调用 Unlock 方法来释放锁，也可以用 defer 语句来保证互斥锁一定会被解锁。在一个 Go 协程调用 Lock 方法获得锁后，其他请求锁的协程都会阻塞在 Lock 方法，直到锁被释放。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3.2 sync.RWMutex&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写锁是一种共享锁，也称之为多读单写锁 (multiple readers, single writer lock)。在使用锁时，对获取锁的目的操作做了区分，一种是读操作，一种是写操作。因为同一时刻允许多个 Gorouine 获取读锁，所以是一种共享锁。但写锁是互斥的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，有如下几种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;读锁之间不互斥，没有写锁的情况下，读锁是无阻塞的，多个协程可以同时获得读锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写锁之间是互斥的，存在写锁，其他写锁阻塞。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写锁与读锁是互斥的，如果存在读锁，写锁阻塞，如果存在写锁，读锁阻塞。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.20430107526881722&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasXic8UMQ0Bbvu6iaXLy4Q8sFVsSVEskUxvXv93ibFYdsQUHpHLE2zY5zsMZE93VeYn3eK15R9sSpZWA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1674&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.RWMutex 提供了五个导出方法用来使用锁。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Lock()    &lt;span&gt;// 加写锁&lt;/span&gt;&lt;br/&gt;Unlock()   &lt;span&gt;// 释放写锁&lt;/span&gt;&lt;br/&gt;RLock()    &lt;span&gt;// 加读锁&lt;/span&gt;&lt;br/&gt;RUnlock()   &lt;span&gt;// 释放读锁&lt;/span&gt;&lt;br/&gt;RLocker() Locker &lt;span&gt;// 返回读锁，使用 Lock() 和 Unlock() 进行 RLock() 和 RUnlock()&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写锁的存在是为了解决读多写少时的性能问题，读场景较多时，读写锁可有效地减少锁阻塞的时间。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3.3 性能对比&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大部分业务场景是读多写少，所以使用读写锁可有效提高对共享数据的访问效率。最坏的情况，只有写请求，那么读写锁顶多退化成互斥锁。所以优先使用读写锁而非互斥锁，可以提高程序的并发性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们测试三种情景下，互斥锁和读写锁的性能差异。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;读多写少(读占 80%)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;读写一致(各占 50%)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;读少写多(读占 20%)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先根据互斥锁和读写锁分别实现对共享 map 的并发读写。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// OpMapWithMutex 使用互斥锁读写 map。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// rpct 为读操作占比。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;OpMapWithMutex&lt;/span&gt;&lt;span&gt;(rpct &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;struct&lt;/span&gt;{})&lt;br/&gt; mu := sync.Mutex{}&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++ {&lt;br/&gt;  i := i&lt;br/&gt;  wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;   mu.Lock()&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; mu.Unlock()&lt;br/&gt;   &lt;span&gt;// 写操作。&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; i &amp;gt;= rpct {&lt;br/&gt;    m[i] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;    time.Sleep(time.Microsecond)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;// 读操作。&lt;/span&gt;&lt;br/&gt;   _ = m[i]&lt;br/&gt;   time.Sleep(time.Microsecond)&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt; wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// OpMapWithRWMutex 使用读写锁读写 map。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// rpct 为读操作占比。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;OpMapWithRWMutex&lt;/span&gt;&lt;span&gt;(rpct &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;struct&lt;/span&gt;{})&lt;br/&gt; mu := sync.RWMutex{}&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++ {&lt;br/&gt;  i := i&lt;br/&gt;  wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;   &lt;span&gt;// 写操作。&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; i &amp;gt;= rpct {&lt;br/&gt;    mu.Lock()&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; mu.Unlock()&lt;br/&gt;    m[i] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;    time.Sleep(time.Microsecond)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;// 读操作。&lt;/span&gt;&lt;br/&gt;   mu.RLock()&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; mu.RUnlock()&lt;br/&gt;   _ = m[i]&lt;br/&gt;   time.Sleep(time.Microsecond)&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt; wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;入参 rpct 用来调节读操作的占比，来模拟读写占比不同的场景。rpct 设为 80 表示读多写少(读占 80%)，rpct 设为 50 表示读写一致(各占 50%)，rpct 设为 20 表示读少写多(读占 20%)。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkMutexReadMore&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  OpMapWithMutex(&lt;span&gt;80&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkRWMutexReadMore&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  OpMapWithRWMutex(&lt;span&gt;80&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkMutexRWEqual&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  OpMapWithMutex(&lt;span&gt;50&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkRWMutexRWEqual&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  OpMapWithRWMutex(&lt;span&gt;50&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkMutexWriteMore&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  OpMapWithMutex(&lt;span&gt;20&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkRWMutexWriteMore&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  OpMapWithRWMutex(&lt;span&gt;20&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行当前包下的所有基准测试，结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dablelv@DABLELV-MB0 mutex % go test -bench=.&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/mutex&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz&lt;br/&gt;BenchmarkMutexReadMore-12                   2462            485917 ns/op&lt;br/&gt;BenchmarkRWMutexReadMore-12                 8074            145690 ns/op&lt;br/&gt;BenchmarkMutexRWEqual-12                    2406            498673 ns/op&lt;br/&gt;BenchmarkRWMutexRWEqual-12                  4124            303693 ns/op&lt;br/&gt;BenchmarkMutexWriteMore-12                  1906            532350 ns/op&lt;br/&gt;BenchmarkRWMutexWriteMore-12                2462            432386 ns/op&lt;br/&gt;PASS&lt;br/&gt;ok      main/mutex      9.532s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见读多写少的场景，使用读写锁并发性能会更优。可以预见的是如果写占比更低，那么读写锁带的并发效果会更优。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要注意的是，因为每次读写 map 的操作耗时很短，所以每次睡眠一微秒（百万分之一秒）来增加耗时，不然对共享资源的访问耗时，小于锁处理的本身耗时，那么使用读写锁带来的性能优化效果将变得不那么明显，甚至会降低性能。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.限制协程数量&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 协程数过多的问题&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.1 程序崩溃&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 程（goroutine）是由 Go 运行时管理的轻量级线程。通过它我们可以轻松实现并发编程。但是当我们无限开辟协程时，将会遇到致命的问题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; math.MaxInt32; i++ {&lt;br/&gt;  wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;   fmt.Println(i)&lt;br/&gt;   time.Sleep(time.Second)&lt;br/&gt;  }(i)&lt;br/&gt; }&lt;br/&gt; wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子实现了 math.MaxInt32 个协程的并发，&lt;code&gt;2^31 - 1&lt;/code&gt; 约为 20 亿个，每个协程内部几乎没有做什么事情。正常的情况下呢，这个程序会乱序输出 0 ~ 2^31-1 个数字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序会像预期的那样顺利的运行吗？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go run main.go&lt;br/&gt;...&lt;br/&gt;108668&lt;br/&gt;1142025&lt;br/&gt;panic: too many concurrent operations on a single file or socket (max 1048575)&lt;br/&gt;&lt;br/&gt;goroutine 1158408 [running]:&lt;br/&gt;internal/poll.(*fdMutex).rwlock(0xc0000ae060, 0x0)&lt;br/&gt;        /usr/local/go/src/internal/poll/fd_mutex.go:147 +0x11b&lt;br/&gt;internal/poll.(*FD).writeLock(...)&lt;br/&gt;        /usr/local/go/src/internal/poll/fd_mutex.go:239&lt;br/&gt;internal/poll.(*FD).Write(0xc0000ae060, {0xc12cadf690, 0x8, 0x8})&lt;br/&gt;        /usr/local/go/src/internal/poll/fd_unix.go:262 +0x72&lt;br/&gt;os.(*File).write(...)&lt;br/&gt;        /usr/local/go/src/os/file_posix.go:49&lt;br/&gt;os.(*File).Write(0xc0000ac008, {0xc12cadf690, 0x1, 0xc12ea62f50})&lt;br/&gt;        /usr/local/go/src/os/file.go:176 +0x65&lt;br/&gt;fmt.Fprintln({0x10c00e0, 0xc0000ac008}, {0xc12ea62f90, 0x1, 0x1})&lt;br/&gt;        /usr/local/go/src/fmt/print.go:265 +0x75&lt;br/&gt;fmt.Println(...)&lt;br/&gt;        /usr/local/go/src/fmt/print.go:274&lt;br/&gt;main.main.func1(0x0)&lt;br/&gt;        /Users/dablelv/work/code/test/main.go:16 +0x8f&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行的结果是程序直接崩溃了，关键的报错信息是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;panic: too many concurrent operations on a single file or socket (max 1048575)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对单个 file/socket 的并发操作个数超过了系统上限，这个报错是 fmt.Printf 函数引起的，fmt.Printf 将格式化后的字符串打印到屏幕，即标准输出。在 Linux 系统中，标准输出也可以视为文件，内核（Kernel）利用文件描述符（File Descriptor）来访问文件，标准输出的文件描述符为 1，错误输出文件描述符为 2，标准输入的文件描述符为 0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简而言之，系统的资源被耗尽了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那如果我们将 fmt.Printf 这行代码去掉呢？那程序很可能会因为内存不足而崩溃。这一点更好理解，每个协程至少需要消耗 2KB 的空间，那么假设计算机的内存是 4GB，那么至多允许 4GB/2KB = 1M 个协程同时存在。那如果协程中还存在着其他需要分配内存的操作，那么允许并发执行的协程将会数量级地减少。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.2 协程的代价&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面的例子过于极端，一般情况下程序也不会无限开辟协程，旨在说明协程数量是有限制的，不能无限开辟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们开辟很多协程，但不会导致程序崩溃，可以吗？如果真要这么做的话，我们应该清楚地知道，协程虽然轻量，但仍有开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 的开销主要是三个方面：创建（占用内存）、调度（增加调度器负担）和删除（增加 GC 压力）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;空间上，一个 Go 程占用约 2K 的内存，在源码 src/runtime/runtime2.go里面，我们可以找到 Go 程的结构定义type g struct。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时间上，协程调度也会有 CPU 开销。我们可以利用runntime.Gosched()让当前协程主动让出 CPU 去执行另外一个协程，下面看一下协程之间切换的耗时。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; NUM = &lt;span&gt;10000&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;cal&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; NUM; i++ {&lt;br/&gt;  runtime.Gosched()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 只设置一个 Processor&lt;/span&gt;&lt;br/&gt; runtime.GOMAXPROCS(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt; start := time.Now().UnixNano()&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; cal()&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; NUM; i++ {&lt;br/&gt;  runtime.Gosched()&lt;br/&gt; }&lt;br/&gt; end := time.Now().UnixNano()&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;total %vns per %vns&quot;&lt;/span&gt;, end-start, (end-start)/NUM)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;total 997200ns per 99ns&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见一次协程的切换，耗时大概在 100ns，相对于线程的微秒级耗时切换，性能表现非常优秀，但是仍有开销。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;GC 开销
创建 Go 程到运行结束，占用的内存资源是需要由 GC 来回收，如果无休止地创建大量 Go 程后，势必会造成对 GC 的压力。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;runtime&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;runtime/debug&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;createLargeNumGoroutine&lt;/span&gt;&lt;span&gt;(num &lt;span&gt;int&lt;/span&gt;, wg *sync.WaitGroup)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; wg.Add(num)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; i++ {&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 只设置一个 Processor 保证 Go 程串行执行&lt;/span&gt;&lt;br/&gt; runtime.GOMAXPROCS(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;// 关闭GC改为手动执行&lt;/span&gt;&lt;br/&gt; debug.SetGCPercent(&lt;span&gt;-1&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt; createLargeNumGoroutine(&lt;span&gt;1000&lt;/span&gt;, &amp;amp;wg)&lt;br/&gt; wg.Wait()&lt;br/&gt; t := time.Now()&lt;br/&gt; runtime.GC() &lt;span&gt;// 手动GC&lt;/span&gt;&lt;br/&gt; cost := time.Since(t)&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;GC cost %v when goroutine num is %v\n&quot;&lt;/span&gt;, cost, &lt;span&gt;1000&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; createLargeNumGoroutine(&lt;span&gt;10000&lt;/span&gt;, &amp;amp;wg)&lt;br/&gt; wg.Wait()&lt;br/&gt; t = time.Now()&lt;br/&gt; runtime.GC() &lt;span&gt;// 手动GC&lt;/span&gt;&lt;br/&gt; cost = time.Since(t)&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;GC cost %v when goroutine num is %v\n&quot;&lt;/span&gt;, cost, &lt;span&gt;10000&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; createLargeNumGoroutine(&lt;span&gt;100000&lt;/span&gt;, &amp;amp;wg)&lt;br/&gt; wg.Wait()&lt;br/&gt; t = time.Now()&lt;br/&gt; runtime.GC() &lt;span&gt;// 手动GC&lt;/span&gt;&lt;br/&gt; cost = time.Since(t)&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;GC cost %v when goroutine num is %v\n&quot;&lt;/span&gt;, cost, &lt;span&gt;100000&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GC cost 0s when goroutine num is 1000&lt;br/&gt;GC cost 2.0027ms when goroutine num is 10000&lt;br/&gt;GC cost 30.9523ms when goroutine num is 100000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当创建的 Go 程数量越多，GC 耗时越大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的分析目的是为了尽可能地量化 Goroutine 的开销。虽然官方宣称用 Golang 写并发程序的时候随便起个成千上万的 Goroutine 毫无压力，但当我们起十万、百万甚至千万个 Goroutine 呢？Goroutine 轻量的开销将被放大。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 限制协程数量&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统地资源是有限，协程是有代价的，为了保护程序，提高性能，我们应主动限制并发的协程数量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以利用信道 channel 的缓冲区大小来实现。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt; ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{}, &lt;span&gt;3&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;  ch &amp;lt;- &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;  wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;   log.Println(i)&lt;br/&gt;   time.Sleep(time.Second)&lt;br/&gt;   &amp;lt;-ch&lt;br/&gt;  }(i)&lt;br/&gt; }&lt;br/&gt; wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上例中创建了缓冲区大小为 3 的 channel，在没有被接收的情况下，至多发送 3 个消息则被阻塞。开启协程前，调用&lt;code&gt;ch &amp;lt;- struct{}{}&lt;/code&gt;，若缓存区满，则阻塞。协程任务结束，调用 &amp;lt;-ch 释放缓冲区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.WaitGroup 并不是必须的，例如 Http 服务，每个请求天然是并发的，此时使用 channel 控制并发处理的任务数量，就不需要 sync.WaitGroup。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;2022/03/06 20:37:02 0&lt;br/&gt;2022/03/06 20:37:02 2&lt;br/&gt;2022/03/06 20:37:02 1&lt;br/&gt;2022/03/06 20:37:03 3&lt;br/&gt;2022/03/06 20:37:03 4&lt;br/&gt;2022/03/06 20:37:03 5&lt;br/&gt;2022/03/06 20:37:04 6&lt;br/&gt;2022/03/06 20:37:04 7&lt;br/&gt;2022/03/06 20:37:04 8&lt;br/&gt;2022/03/06 20:37:05 9&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从日志中可以很容易看到，每秒钟只并发执行了 3 个任务，达到了协程并发控制的目的。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 协程池化&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的例子只是简单地限制了协程开辟的数量。在此基础之上，基于对象复用的思想，我们可以重复利用已开辟的协程，避免协程的重复创建销毁，达到池化的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;协程池化，我们可以自己写一个协程池，但不推荐这么做。因为已经有成熟的开源库可供使用，无需再重复造轮子。目前有很多第三方库实现了协程池，可以很方便地用来控制协程的并发数量，比较受欢迎的有：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面以 panjf2000/ants 为例，简单介绍其使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ants 是一个简单易用的高性能 Goroutine 池，实现了对大规模 Goroutine 的调度管理和复用，允许使用者在开发并发程序的时候限制 Goroutine 数量，复用协程，达到更高效执行任务的效果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/panjf2000/ants&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Use the common pool&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;  i := i&lt;br/&gt;  ants.Submit(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   fmt.Println(i)&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; time.Sleep(time.Second)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 ants，我们简单地使用其默认的协程池，直接将任务提交并发执行。默认协程池的缺省容量 math.MaxInt32。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果自定义协程池容量大小，可以调用 NewPool 方法来实例化具有给定容量的池，如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Set 10000 the size of goroutine pool&lt;/span&gt;&lt;br/&gt;p, _ := ants.NewPool(&lt;span&gt;10000&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4 小结&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Golang 为并发而生。Goroutine 是由 Go 运行时管理的轻量级线程，通过它我们可以轻松实现并发编程。Go 虽然轻量，但天下没有免费的午餐，无休止地开辟大量 Go 程势必会带来性能影响，甚至程序崩溃。所以，我们应尽可能的控制协程数量，如果有需要，请复用它。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.使用 sync.Once 避免重复执行&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 简介&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Once 是 Go 标准库提供的使函数只执行一次的实现，常应用于单例模式，例如初始化配置、保持数据库连接等。作用与 init 函数类似，但有区别。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;init 函数是当所在的 package 首次被加载时执行，若迟迟未被使用，则既浪费了内存，又延长了程序加载时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sync.Once 可以在代码的任意位置初始化和调用，因此可以延迟到使用时再执行，并发场景下是线程安全的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在多数情况下，sync.Once 被用于控制变量的初始化，这个变量的读写满足如下三个条件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当且仅当第一次访问某个变量时，进行初始化（写）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;变量初始化过程中，所有读都被阻塞，直到初始化完成；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;变量仅初始化一次，初始化完成后驻留在内存里。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 原理&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Once 用来保证函数只执行一次。要达到这个效果，需要做到两点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;计数器，统计函数执行次数；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程安全，保障在多 Go 程的情况下，函数仍然只执行一次，比如锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2.1 源码&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看一下 sync.Once 结构，其有两个变量。使用 done 统计函数执行次数，使用锁 m 实现线程安全。果不其然，和上面的猜想一致。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Once is an object that will perform exactly one action.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// A Once must not be copied after first use.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Once &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// done indicates whether the action has been performed.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// It is first in the struct because it is used in the hot path.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// The hot path is inlined at every call site.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// Placing done first allows more compact instructions on some architectures (amd64/386),&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// and fewer instructions (to calculate offset) on other architectures.&lt;/span&gt;&lt;br/&gt; done &lt;span&gt;uint32&lt;/span&gt;&lt;br/&gt; m    Mutex&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Once 仅提供了一个导出方法 Do()，参数 f 是只会被执行一次的函数，一般为对象初始化函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// go version go1.17 darwin/amd64&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Do calls the function f if and only if Do is being called for the&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// first time for this instance of Once. In other words, given&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//  var once Once&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// if once.Do(f) is called multiple times, only the first call will invoke f,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// even if f has a different value in each invocation. A new instance of&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Once is required for each function to execute.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Do is intended for initialization that must be run exactly once. Since f&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// is niladic, it may be necessary to use a function literal to capture the&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// arguments to a function to be invoked by Do:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//  config.once.Do(func() { config.init(filename) })&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Because no call to Do returns until the one call to f returns, if f causes&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Do to be called, it will deadlock.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// If f panics, Do considers it to have returned; future calls of Do return&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// without calling f.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(o *Once)&lt;/span&gt; &lt;span&gt;Do&lt;/span&gt;&lt;span&gt;(f &lt;span&gt;func&lt;/span&gt;()&lt;/span&gt;)&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Note: Here is an incorrect implementation of Do:&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// if atomic.CompareAndSwapUint32(&amp;amp;o.done, 0, 1) {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//  f()&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// }&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// Do guarantees that when it returns, f has finished.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// This implementation would not implement that guarantee:&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// given two simultaneous calls, the winner of the cas would&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// call f, and the second would return immediately, without&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// waiting for the first&#x27;s call to f to complete.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// This is why the slow path falls back to a mutex, and why&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// the atomic.StoreUint32 must be delayed until after f returns.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; atomic.LoadUint32(&amp;amp;o.done) == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// Outlined slow-path to allow inlining of the fast-path.&lt;/span&gt;&lt;br/&gt;  o.doSlow(f)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(o *Once)&lt;/span&gt; &lt;span&gt;doSlow&lt;/span&gt;&lt;span&gt;(f &lt;span&gt;func&lt;/span&gt;()&lt;/span&gt;)&lt;/span&gt; {&lt;br/&gt; o.m.Lock()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; o.m.Unlock()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; o.done == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;defer&lt;/span&gt; atomic.StoreUint32(&amp;amp;o.done, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  f()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;抛去大段的注释，可以看到 sync.Once 实现非常简洁。Do() 函数中，通过对成员变量 done 的判断，来决定是否执行传入的任务函数。执行任务函数前，通过锁保证任务函数的执行和 done 的修改是一个互斥操作。在执行任务函数前，对 done 做一个二次判断，来保证任务函数只会被执行一次，done 只会被修改一次。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2.2  done 为什么是第一个字段&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从字段 done 前有一段注释，说明了done 为什么是第一个字段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;done 在热路径中，done 放在第一个字段，能够减少 CPU 指令，也就是说，这样做能够提升性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;热路径（hot path）是程序非常频繁执行的一系列指令，sync.Once 绝大部分场景都会访问 o.done，在热路径上是比较好理解的。如果 hot path 编译后的机器码指令更少，更直接，必然是能够提升性能的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么放在第一个字段就能够减少指令呢？因为结构体第一个字段的地址和结构体的指针是相同的，如果是第一个字段，直接对结构体的指针解引用即可。如果是其他的字段，除了结构体指针外，还需要计算与第一个值的偏移（calculate offset）。在机器码中，偏移量是随指令传递的附加值，CPU 需要做一次偏移值与指针的加法运算，才能获取要访问的值的地址。因为，访问第一个字段的机器代码更紧凑，速度更快。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;参考 &lt;a href=&quot;https://stackoverflow.com/questions/59174176/what-does-hot-path-mean-in-the-context-of-sync-once&quot; data-linktype=&quot;2&quot;&gt;What does “hot path” mean in the context of sync.Once? - StackOverflow&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3 性能差异&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以一个简单示例，来说明使用 sync.Once 保证函数只会被执行一次和多次执行，二者的性能差异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考虑一个简单的场景，函数 ReadConfig 需要读取环境变量，并转换为对应的配置。环境变量在程序执行前已经确定，执行过程中不会发生改变。ReadConfig 可能会被多个协程并发调用，为了提升性能（减少执行时间和内存占用），使用 sync.Once 是一个比较好的方式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Config &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; GoRoot &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; GoPath &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; (&lt;br/&gt; once   sync.Once&lt;br/&gt; config *Config&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ReadConfigWithOnce&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;Config&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; once.Do(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  config = &amp;amp;Config{&lt;br/&gt;   GoRoot: os.Getenv(&lt;span&gt;&quot;GOROOT&quot;&lt;/span&gt;),&lt;br/&gt;   GoPath: os.Getenv(&lt;span&gt;&quot;GOPATH&quot;&lt;/span&gt;),&lt;br/&gt;  }&lt;br/&gt; })&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; config&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ReadConfig&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;Config&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;Config{&lt;br/&gt;  GoRoot: os.Getenv(&lt;span&gt;&quot;GOROOT&quot;&lt;/span&gt;),&lt;br/&gt;  GoPath: os.Getenv(&lt;span&gt;&quot;GOPATH&quot;&lt;/span&gt;),&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看下二者的性能差异。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkReadConfigWithOnce&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = ReadConfigWithOnce()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkReadConfig&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = ReadConfig()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行测试结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=. main/once&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/once&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz&lt;br/&gt;BenchmarkReadConfigWithOnce-12          670438965                1.732 ns/op&lt;br/&gt;BenchmarkReadConfig-12                  13339154                87.46 ns/op&lt;br/&gt;PASS&lt;br/&gt;ok      main/once       3.006s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Once 中保证了 Config 初始化函数仅执行了一次，避免了多次重复初始化，在并发环境下很有用。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.使用 sync.Cond 通知协程&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 简介&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Cond 是基于互斥锁/读写锁实现的条件变量，用来协调想要访问共享资源的那些 Goroutine，当共享资源的状态发生变化的时候，sync.Cond 可以用来通知等待条件发生而阻塞的 Goroutine。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Cond 基于互斥锁/读写锁，它和互斥锁的区别是什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;互斥锁 sync.Mutex 通常用来保护共享的临界资源，条件变量 sync.Cond 用来协调想要访问共享资源的 Goroutine。当共享资源的状态发生变化时，sync.Cond 可以用来通知被阻塞的 Goroutine。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 使用场景&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Cond 经常用在多个 Goroutine 等待，一个 Goroutine 通知（事件发生）的场景。如果是一个通知，一个等待，使用互斥锁或 channel 就能搞定了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们想象一个非常简单的场景：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一个协程在异步地接收数据，剩下的多个协程必须等待这个协程接收完数据，才能读取到正确的数据。在这种情况下，如果单纯使用 chan 或互斥锁，那么只能有一个协程可以等待，并读取到数据，没办法通知其他的协程也读取数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候，就需要有个全局的变量来标志第一个协程数据是否接受完毕，剩下的协程，反复检查该变量的值，直到满足要求。或者创建多个 channel，每个协程阻塞在一个 channel 上，由接收数据的协程在数据接收完毕后，逐个通知。总之，需要额外的复杂度来完成这件事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言在标准库 sync 中内置一个 sync.Cond 用来解决这类问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3 原理&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Cond 内部维护了一个等待队列，队列中存放的是所有在等待这个 sync.Cond 的 Go 程，即保存了一个通知列表。sync.Cond 可以用来唤醒一个或所有因等待条件变量而阻塞的 Go 程，以此来实现多个 Go 程间的同步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Cond 的定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Cond implements a condition variable, a rendezvous point&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// for goroutines waiting for or announcing the occurrence&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// of an event.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Each Cond has an associated Locker L (often a *Mutex or *RWMutex),&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// which must be held when changing the condition and&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// when calling the Wait method.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// A Cond must not be copied after first use.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Cond &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; noCopy noCopy&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// L is held while observing or changing the condition&lt;/span&gt;&lt;br/&gt; L Locker&lt;br/&gt;&lt;br/&gt; notify  notifyList&lt;br/&gt; checker copyChecker&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个 Cond 实例都会关联一个锁 L（互斥锁 *Mutex，或读写锁 *RWMutex），当修改条件或者调用 Wait 方法时，必须加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Cond 的四个成员函数定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// NewCond returns a new Cond with Locker l.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewCond&lt;/span&gt;&lt;span&gt;(l Locker)&lt;/span&gt; *&lt;span&gt;Cond&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;Cond{L: l}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NewCond 创建 Cond 实例时，需要关联一个锁。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Wait atomically unlocks c.L and suspends execution&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// of the calling goroutine. After later resuming execution,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Wait locks c.L before returning. Unlike in other systems,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Wait cannot return unless awoken by Broadcast or Signal.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Because c.L is not locked when Wait first resumes, the caller&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// typically cannot assume that the condition is true when&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Wait returns. Instead, the caller should Wait in a loop:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//    c.L.Lock()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//    for !condition() {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//        c.Wait()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//    ... make use of condition ...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//    c.L.Unlock()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Cond)&lt;/span&gt; &lt;span&gt;Wait&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; c.checker.check()&lt;br/&gt; t := runtime_notifyListAdd(&amp;amp;c.notify)&lt;br/&gt; c.L.Unlock()&lt;br/&gt; runtime_notifyListWait(&amp;amp;c.notify, t)&lt;br/&gt; c.L.Lock()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Wait 用于阻塞调用者，等待通知。调用 Wait 会自动释放锁 c.L，并挂起调用者所在的 goroutine。如果其他协程调用了 Signal 或 Broadcast 唤醒了该协程，那么 Wait 方法在结束阻塞时，会重新给 c.L 加锁，并且继续执行 Wait 后面的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对条件的检查，使用了 for !condition() 而非 if，是因为当前协程被唤醒时，条件不一定符合要求，需要再次 Wait 等待下次被唤醒。为了保险起，使用 for 能够确保条件符合要求后，再执行后续的代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Signal wakes one goroutine waiting on c, if there is any.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// It is allowed but not required for the caller to hold c.L&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// during the call.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Cond)&lt;/span&gt; &lt;span&gt;Signal&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; c.checker.check()&lt;br/&gt; runtime_notifyListNotifyOne(&amp;amp;c.notify)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Broadcast wakes all goroutines waiting on c.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// It is allowed but not required for the caller to hold c.L&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// during the call.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Cond)&lt;/span&gt; &lt;span&gt;Broadcast&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; c.checker.check()&lt;br/&gt; runtime_notifyListNotifyAll(&amp;amp;c.notify)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Signal 只唤醒任意 1 个等待条件变量 c 的 goroutine，无需锁保护。Broadcast 唤醒所有等待条件变量 c 的 goroutine，无需锁保护。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4 使用示例&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们实现一个简单的例子，三个协程调用 Wait() 等待，另一个协程调用 Broadcast() 唤醒所有等待的协程。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; done = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;(name &lt;span&gt;string&lt;/span&gt;, c *sync.Cond)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; c.L.Lock()&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; !done {&lt;br/&gt;  c.Wait()&lt;br/&gt; }&lt;br/&gt; log.Println(name, &lt;span&gt;&quot;starts reading&quot;&lt;/span&gt;)&lt;br/&gt; c.L.Unlock()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;(name &lt;span&gt;string&lt;/span&gt;, c *sync.Cond)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; log.Println(name, &lt;span&gt;&quot;starts writing&quot;&lt;/span&gt;)&lt;br/&gt; time.Sleep(time.Second)&lt;br/&gt; done = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; log.Println(name, &lt;span&gt;&quot;wakes all&quot;&lt;/span&gt;)&lt;br/&gt; c.Broadcast()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; cond := sync.NewCond(&amp;amp;sync.Mutex{})&lt;br/&gt;&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; read(&lt;span&gt;&quot;reader1&quot;&lt;/span&gt;, cond)&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; read(&lt;span&gt;&quot;reader2&quot;&lt;/span&gt;, cond)&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; read(&lt;span&gt;&quot;reader3&quot;&lt;/span&gt;, cond)&lt;br/&gt; write(&lt;span&gt;&quot;writer&quot;&lt;/span&gt;, cond)&lt;br/&gt;&lt;br/&gt; time.Sleep(time.Second * &lt;span&gt;3&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;done 即多个 Goroutine 阻塞等待的条件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;read() 调用 Wait() 等待通知，直到 done 为 true。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;write() 接收数据，接收完成后，将 done 置为 true，调用 Broadcast() 通知所有等待的协程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;write() 中的暂停了 1s，一方面是模拟耗时，另一方面是确保前面的 3 个 read 协程都执行到 Wait()，处于等待状态。main 函数最后暂停了 3s，确保所有操作执行完毕。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go run main.go&lt;br/&gt;2022/03/07 17:20:09 writer starts writing&lt;br/&gt;2022/03/07 17:20:10 writer wakes all&lt;br/&gt;2022/03/07 17:20:10 reader3 starts reading&lt;br/&gt;2022/03/07 17:20:10 reader1 starts reading&lt;br/&gt;2022/03/07 17:20:10 reader2 starts reading&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多关于 sync.Cond 的讨论可参考 &lt;a href=&quot;https://stackoverflow.com/questions/36857167/how-to-correctly-use-sync-cond&quot; data-linktype=&quot;2&quot;&gt;How to correctly use sync.Cond? - StackOverflow&lt;/a&gt;。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.5 注意事项&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Cond 不能被复制的原因，并不是因为其内部嵌套了 Locker。因为 NewCond 时传入的 Mutex/RWMutex 指针，对于 Mutex 指针复制是没有问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要原因是 sync.Cond 内部是维护着一个 Goroutine 通知队列 notifyList。如果这个队列被复制的话，那么就在并发场景下导致不同 Goroutine 之间操作的 notifyList.wait、notifyList.notify 并不是同一个，这会导致出现有些 Goroutine 会一直阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从等待队列中按照顺序唤醒，先进入等待队列，先被唤醒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用 Wait() 函数前，需要先获得条件变量的成员锁，原因是需要互斥地变更条件变量的等待队列。在 Wait() 返回前，会重新上锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考文献&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;最近好文：&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649768568&amp;amp;idx=1&amp;amp;sn=68dc084a79407a41762f8705b28e1257&amp;amp;chksm=beccd10389bb5815ae094ed7423a32f421fd143d724cbf0330efaeaf0382e683e575e6350f30&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;在鹅厂工作1到11年的程序媛&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;在鹅厂工作1到11年的程序媛&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649769049&amp;amp;idx=1&amp;amp;sn=b8ac0e6409b073758fa0bbcde1acd952&amp;amp;chksm=beccd72289bb5e34bacb76669650d8ebb70563fb35b381f452f20c62b86968f2efbeb98d8337&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;技术她力量，鹅厂女博士的寻“豹”之旅&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;技术她力量，鹅厂女博士的寻“豹”之旅&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649769274&amp;amp;idx=1&amp;amp;sn=a46fc1574ecbf5cfddd1f40af9cb1b4f&amp;amp;chksm=beccd64189bb5f57f80799fd2ea51c7669942254a2223dea55fe7d2bfa5762410a784dec8e2f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;微信全文搜索技术优化&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;微信全文搜索技术优化&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAgDAS3gDsiAAAAAstQy6ubaLX4KHWvLEZgBPE8KIMcXtxZL38zNPgMIvt27oRctxLQngBmm2RSmIU&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7YmwgiahniaXswqz4S6B63dgPBSkQM1Pibkk08bsnRVMG0MKAZ26U5ESqSNFtReXFxmYaalxffR57exzXKicibmO91qDTVFBh9zBPSEAA&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdWOPjH6MHTJcta8qxWU2YJYIzYZjHP3n6pJIp2mTCHqh9rqZQPUvWCEgUCyBuJ4114&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;我的程序媛同事们，节日快乐~&amp;#10;&amp;#10;#不被定义的她 #程序媛 #女性 &amp;#10;&quot; data-nonceid=&quot;6143725764114518706&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5ODYwMjI2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasvpPfMrktl2xvC9A325p8Qa9dFeEzxZmZ2O1XuFGsVXyQhG9Dia8J8nTXVtzNcHozr0umH3R4iboXg/0?wx_fmt=png&quot; data-nickname=&quot;腾讯技术工程&quot; data-alias=&quot;Tencent_TEG&quot; data-signature=&quot;腾讯技术官方号。腾讯技术创新、前沿领域发布解读平台。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f67b6bf165519c9cf8001cb9e60cf7ea</guid>
<title>深入解读腾讯云微搭低代码的技术架构</title>
<link>https://toutiao.io/k/up95s1h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&amp;amp;mid=2247492987&amp;amp;idx=1&amp;amp;sn=2d0413417136df462a96638dbff156e0&amp;amp;chksm=fc50fc80cb2775965ac02736391d98c9ace7402c54c8cf56666577370bfb78e4c6ece718f829&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;5&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5344603381014305&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibNVrke3zbdetTT6KMnfuVic6KUQEk7OibN6KPMme1CTChQYASyuqFgdv5coalmW9BpADns9tIHw8KQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1538&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;腾讯云微搭低代码是高效、高性能的企业级低代码平台。帮助开发者快速搭建支持多种业务场景的小程序、H5、PC WEB应用，通过简单的拖拉拽操作，而不用编写复杂的代码，实现少写代码或者不写代码，就能快速高效完成业务目标。&lt;/span&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;strong mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;本文将带大家深入聊聊微搭的技术架构，来了解下微搭是如何安全、稳定、可靠地支撑商业级应用从搭建到发布上线的。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;h2 mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;28&quot;&gt;&lt;span mp-original-font-size=&quot;24&quot; mp-original-line-height=&quot;28&quot;&gt;01&lt;/span&gt;&lt;/h2&gt;&lt;h2 mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;28&quot;&gt;&lt;span mp-original-font-size=&quot;24&quot; mp-original-line-height=&quot;28&quot;&gt;低代码平台演进&lt;/span&gt;&lt;/h2&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;1. 低代码概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;低代码是无需编码（0代码）或通过少量代码就可以快速生成应用程序的开发平台。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;通过可视化进行应用程序开发的方法，具有不同经验水平的开发人员可以通过&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;strong mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;图形化的用户界面&lt;/strong&gt;&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;，使用&lt;/span&gt;&lt;strong mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;拖拽组件和模型驱动的逻辑&lt;/span&gt;&lt;/strong&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;来创建网页和移动应用程序。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/section&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;2. 低代码衍生历程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;li&gt;&lt;section mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;25.666667938232422&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;25.666667938232422&quot;&gt;20世纪80年代，第四代编程语言出现。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;25.666667938232422&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;25.666667938232422&quot;&gt;2000年 VPL 可视化编程语言的诞生，是低代码产品的前驱，都可以通过一些可视化的界面来进行操作。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;25.666667938232422&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;25.666667938232422&quot;&gt;2014年 业界咨询机构 Forrester 低代码/零代码概念。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;25.666667938232422&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;25.666667938232422&quot;&gt;2016年 国内低代码平台相继发布。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;25.666667938232422&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;25.666667938232422&quot;&gt;2018年  业界咨询机构 Gartner 提出 aPaaS 和 iPaas 的概念。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;25.666667938232422&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;25.666667938232422&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;25.666667938232422&quot;&gt;2021年 中国市场低代码生态体系逐步建立。&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;25.666667938232422&quot;&gt;         &lt;/span&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;25.666667938232422&quot;&gt;        &lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;25.666667938232422&quot;&gt;&lt;br mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;25.666667938232422&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;3. 为什么要用低代码 ？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;1）降本增效，便捷开发&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;低代码开发能够为企业降低成本，提升效率。&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;在过去，低代码平台出现之前，传统的原生代码开发平台需要进行代码开发，开发完成之后需要进行测试以及bug修复的一系列繁琐工作。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;此外，传统的原生代码开发平台涉及到一些上下游合作方是紧耦合的串行开发模型，依赖方不提供接口，上游服务也没有办法进行该接口的开发工作。这增加了开发过程中大量的沟通成本和时间成本。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;低代码开发平台出现后，研发人员可以通过前端图形化的拖拉拽实现需求，实现了研发效率的提高，使用低代码平台降低了研发人员的工作量和对编码人员开发技能的要求。低代码平台套用封装代码，基本消除测试修复bug的环节。&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;同时，低代码开发平台是松耦合的并发开发模型，大大降低开发中对合作方的依赖性，从而降低沟通和时间成本。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;/p&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/section&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7757936507936508&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Oicycervb7zyfGsxQsFVOyiaOGVNlQm9ZicBK0zXwBFicaLicUr8onSiccWeicWGABNBxrVxS216RA7gYU16tjCqnEzgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1008&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;                  &lt;/span&gt;        &lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;        &lt;/span&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;strong mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;2）打破业务竖井，增强跨职能沟通&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;传统开发模式下：业务、产品、设计、开发、测试与运维人员各司其职，且各有一套领域内的工具和语言，长久以来很容易形成一个个 “竖井” ，让跨职能的沟通变得困难而低效。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.802784222737819&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Oicycervb7zyfGsxQsFVOyiaOGVNlQm9ZicWcMUDRx897IoTHDCy1v5eteztk3pJ807B89o0qxvnhfK497OPAbbjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;862&quot;/&gt;&lt;/p&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/section&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;有了低代码后，我们能够基于低代码快速的进行开发，这一状况将得到改善。由于低代码上手容易，无需经过太多专业的训练，业务人员也可以快速上手，通过“拖拉拽”，基于模板或者可视化界面快速生成应用，从而打破业务壁垒。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;                  &lt;/span&gt;      &lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6017505470459519&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Oicycervb7zyuAHq0dcKmXmaQ7oE5KAcAyDwcPGpcF55RpicMfFze5EpFpC9FTOI8ic1rhQbW4gp5vMWtDW27diauA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;457&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;  &lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;3）提高产品的灵活性&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;企业可以利用低代码平台发可以轻松地更改应用和业务流程，而无需花费大量时间编写代码。应用和系统的灵活性、可操作性和可更改性大大提高。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;4）加快数字化转型&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;在经济新常态下，为了提高经营效率和经营表现，数字化转型是大多数传统企业的目标，而低代码技术可以帮助企业更快更好地完成数字化转型。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;相比于纯代码开发，使用低代码开发企业应用能将项目的交付周期大幅缩短，从而更敏捷地完成项目交付，大幅提升企业数字化的速度。敏捷交付的背后是更多次数的迭代，以及软件系统与企业贴合度的大幅提升，而这点是企业数字化转型成败的关键。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;h3 mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;28&quot;&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28&quot;&gt;4.全代码&amp;amp;低代码&amp;amp;无代码对比&lt;/span&gt;&lt;/h3&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;        &lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5769516728624535&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Oicycervb7zyfGsxQsFVOyiaOGVNlQm9Zicmv6yFaIE4ACbw9mNwk9tRBLHXfabGbATQiccEtWLsOrpXQDITmtjEgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2690&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;此处用一个象限图来说明业界低代码的演进方向，首先从看到图中的箭头，左下到右上，我们从传统的编程模式是逐渐向无码化来演进的。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;左下的代码编程，就是我们传统的编程阶段。前提是需要有一些比较强的编程能力。从早期的低级语言、到高级语言、进而到类库的提供、以及组件的使用。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;右上的无码操作，指的是无代码、通用SaaS类的产品是可以让我们进行简单快捷的进行操作生成应用，但他们的灵活性是不够的，如果要支持灵活性和扩展性往往需要我们改变他们。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;有没有一种更好的方式，能够支持这种情况？&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;我认为最理想的情况是，在开发者不懂前端语言（JavaScript等）或者不懂后端语言（Php、Java等）的情况下，依然能开发一个足够灵活、足够通用的应用。&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;我认为，&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;低代码平台&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;就是最接近这一个领域的手段，因其可以同时兼顾灵活性和业务逻辑，从而达到最适合开发小白的需求的理想状态。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;                  &lt;/span&gt;&lt;/p&gt;&lt;h3 mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;28&quot;&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28&quot;&gt;5.低代码市场分析&lt;/span&gt;&lt;/h3&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;低代码行业最近几年一直被知名咨询机构 Gartner 所关注。目前，国内外都有很多企业在加入低代码平台搭建，足以说明这个行业的市场认可程度。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;从咨询机构Gartner的市场分析来看，2023年全球超过 &lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;50%&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt; 的大中型企业将把低代码应用平台作为主要的占领应用平台之一。预计到2024年，低代码应用程序开发将占总应用开发的 &lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;65%&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;以上。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;h3 mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;28&quot;&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28&quot;&gt;6.低码平台核心能力&lt;/span&gt;&lt;/h3&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;低代码的平台具备的核心能力要素，我认为有四点：&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;                  &lt;/span&gt;        &lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3203761755485893&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Oicycervb7zyfGsxQsFVOyiaOGVNlQm9ZichhVqic2W1Yofb3mRafTsI1bicKUic837SbYIH8Bxkcd0jznj97do4cLJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3190&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;下面针对以上四点逐一分析：&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;(1) 可视化开发&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;业务人员基于可视化的页面或工具能够进行简单拖拉拽、可以形成一个页面信息。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;他们也能够基于可视化界面来配置定义数据源和数据模型、简单定义一个流程，可以执行工作流。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;总而言之，就是前端拖拉拽可以形成前端的交互语言，进而生成后端可以执行的计算机语言。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;(2) 数据模型驱动&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;低代码平台，能够可以通过页面上的操作进行定义一个模型定义，可以灵活的定义模型中的字段、也可以进行相关数据表的关联操作，以及设置数据模型的规则和索引。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;a. 模型定义&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;进行数据库模型的设计、添加字段，设置字段的类型以及索引&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;b. 模型关联&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;建立数据库表与表之间的关系，具体表现为1对n，n对n，n对1、1对1等关联关系&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;c. 数据操作&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;基于数据库表对外提供一个CRUD 的操作，让应用能够操作该数据模型&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;(3) 扩展性&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;是指低代码平台是否可以提供一些机制来进行扩展。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;具体的扩展方式有以下三点：&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;a. 扩展语言&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;低代码平台是否能够我熟悉的语言来扩展，假如我是前端开发者，能否提供前端熟悉的语言来扩展，假如我是后端开发者，能否基于写一些后端代码（Java 、Go等）来扩展。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;b. 逻辑扩展&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;低代码平台能否通过定义一些流程图也进行业务逻辑的扩展，来执行业务if、else的流程来做业务上的一些调用。   &lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;c. API 集成     &lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;低代码平台是否可以通过低码平台搭建的应用与第三方公司已有的系统或者服务做集成，能否在低码中通过API做集成过来，供我的应用来调用集成。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;(4) 工程化&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;低代码平台是否可以进行本地开发调试、版本控制、自动构建发布上线、免运费以及监控的一些能力。简单来说是否在该平台上一站式配套的能力。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;a. 扩展语言&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;低代码平台要能够进行本地的开发调试。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;b. 版本管理&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;低代码平台可以进行版本回退操作，以及有能力可以预留体验，回退体验的时候不会影响到发布态的产物。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;c. 自动化&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;低代码平台可以自动构建发布上线、免运费以及配套监控的一站式能力&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;/&gt;&lt;/p&gt;&lt;h2 mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;28&quot;&gt;&lt;span mp-original-font-size=&quot;24&quot; mp-original-line-height=&quot;28&quot;&gt;02&lt;/span&gt;&lt;/h2&gt;&lt;h2 mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;28&quot;&gt;&lt;span mp-original-font-size=&quot;24&quot; mp-original-line-height=&quot;28&quot;&gt;微搭低代码架构和开发简介&lt;/span&gt;&lt;/h2&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;1. &lt;/span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;微搭低代码介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;微搭低代码平台&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;是高效、高性能的拖拽式低代码开发平台，向上连接前端的行业业务，向下连接云计算的海量能力，助力企业垂直上云。微搭以云开发作为底层支撑，云原生能力将应用搭建的全链路打通，提供高度开放的开发环境。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;微搭低代码是低代码应用程序平台（LCAPS）+ 多维体验开发平台（MXDP）的结合体。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;我们有以下能力：&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;1）多端支持&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;一套代码，可以同时支持多端、小程序、web、pc 都可用。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;2）生态集成&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;我们内部集成了腾讯文档，腾讯会议、微信支付、企微等能力，可以一站式用用户提供能力。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;3）高阶组件&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;内部提供了模型组件、企业工作台等高阶组件。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;li&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;29.75&quot;&gt;开箱即用&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;29.75&quot;&gt;提供了开箱即用的能力，可以通过我们的应用市场、模板中心可以快速的进行业务开发和发布。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;29.75&quot;&gt;云端一体&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;29.75&quot;&gt;底层是serverless云原生技术&lt;/span&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;29.75&quot;&gt;，&lt;/span&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;29.75&quot;&gt;业务开发完成之后，业务上的是免运维免部署。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;29.75&quot;&gt;统一管理&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;29.75&quot;&gt;提供了框架开发的规范，便于统一的管理。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;29.75&quot;&gt;高扩展性&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;29.75&quot;&gt;支持高扩展性，高扩展性能够自定义组件、第三方数据源完成自定义逻辑的扩展。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;29.75&quot;&gt;混合开发&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;29.75&quot;&gt;业务模式上支持 可视化开发、低代码开发的能力。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;29.75&quot;&gt;                  &lt;/span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4640804597701149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Oicycervb7zyfGsxQsFVOyiaOGVNlQm9Zicw42u0UTta60LJznLNByIPZiarQuTRXic8tyZ30qnDt1vmLM3VY8ou3EQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2784&quot;/&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;       &lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;2. 微搭低代码产品架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;微搭低代码提供了应用开发的一站式低代码开发服务，从底层能力迭代至行业级方案，云原生全链路支撑为您的应用保驾护航，让您能够完全专注于业务场景，小白也可以极速搭建出成熟、专业的应用。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.471875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Oicycervb7zyuAHq0dcKmXmaQ7oE5KAcAhXiav6oXricq8TVLe42H70zMQzcoLqvlicSfqLdmLsLkMPUnjkXHjqvug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;3. 微搭低代码后端实践&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;我们看下微搭低代码的后端实践，那么我们思考下后端低代码需要解决什么问题？我认为应该有四点，以及具体在微搭低代码平台是如何实践的：&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;strong mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;1、业务数据如何存？如何实现自定义数据存储？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;微搭低代码抽象出了&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;数据模型。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;strong mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;2、如何实现业务流程流转？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;微搭低代码基于&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;工作流&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;来进行业务流程流转。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;strong mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;3、业务数据和流程流转，那些人可以访问和控制？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;微搭低代码建立了&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;用户权限平台，来进行人员角色的控制。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;strong mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;4、如何进行服务端逻辑的自定义扩展？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;微搭低代码通过&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;云函数来实现后端服务的自定义扩展能力。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;所以我们微搭低代码后端开发实践分为以下四种：&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;数据模型、工作流、角色权限、服务端扩展。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;                  &lt;/span&gt;        &lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4569653948535936&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Oicycervb7zyfGsxQsFVOyiaOGVNlQm9ZiciaBNnNJC2WdCxR4BKE0iakmmqOaNGbic1BFIEYqibqY9ydkEL8kE4NmQaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2254&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;              &lt;br mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;我们逐一看下具体每个是如何设计的：&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;1、数据模型&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;数据模型基于业界标准的能力JSONSchema来进行扩展，数据模型分为内部数据源和外部数据源两种。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;数据模型 - 内部数据源&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;为我们提供数据模型定义，索引、以及各种数据模型的关系。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;我们可以灵活的来自定义数据字段，以及字段的索引功能。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;也能过提供标准通用的能力，比如新增、删除、查询、更新等。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;/p&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/section&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5745614035087719&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Oicycervb7zyuAHq0dcKmXmaQ7oE5KAcAR8vz6sXoMVe5wUqh4sLTcYZKPRAibc0pZoo8co97zX6icbosI1WOqAaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2736&quot;/&gt;           &lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;数据模型 - 外部数据源&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;连接器&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;连接器可以打通外部应用数据或调用外部应用开放的服务，开发者只需要对连接器完成授权或少量填写一些配置信息，即可使用对应产品的服务接口&lt;/span&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;29.75&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;我们内部集成一些企业级的应用，比如腾讯会议、腾讯文档、腾讯地图、微信支付等应用，方便快速提供一些企业级的能力给到开发者。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48093023255813955&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Oicycervb7zyuAHq0dcKmXmaQ7oE5KAcAMQiavy43thzy54N9XeVWHQULyTgVSrIXx1sjXWJ6s7WIVMBvmg15hFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2150&quot;/&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;自定义连接器&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;自定义连接器支持调用第三方服务接口或使用代码来实现业务逻辑。开发者可以在应用、工作流、自定义数据模型中使用。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;分为http和云函数模式：&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;http：&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;开放式API，用户来链接外部的服务，与外部API来做集成。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;                                           &lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5026178010471204&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Oicycervb7zyuAHq0dcKmXmaQ7oE5KAcA6yFltlh5WLicGYTTwD0BrdoNs7fibr5dTcIR62pUIHicEJOT62j3zfh6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2292&quot;/&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;云函数模式：&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;完全自定义&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;，&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;当用户以上所有的场景均不能满足的时候，可以通过云函数的来手动写一些代码来自定义一些逻辑，实现业务上的逻辑扩展。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;                  &lt;/span&gt;         &lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8434982738780207&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Oicycervb7zyuAHq0dcKmXmaQ7oE5KAcA29JW8kicJoQQrS5rVP843qBXGXsv9dq5sT3E1LEGNcEOoh4fR9GzgLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1738&quot;/&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;         &lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;2、工作流&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;工作流基于业界标准bpmn协议来扩展，数据展示和存储基于标准JSON来处理可读性更高。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;微搭工作流的触发时间：&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;即时时机、也支持定时触发。可以通过配置一些节点，来执行业务逻辑的操作。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;我们支持审批节点、自动化节点、数据源变更通知、加签、转签等操作。通知节点与消息模板集成，可以发送系统站内信、与企微打通，可以发送企微系统消息。我们也支持本地调试，支持版本回溯能力&lt;/span&gt;&lt;span mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;29.75&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/section&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7275922671353251&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Oicycervb7zyuAHq0dcKmXmaQ7oE5KAcAMTTon9eCX1pgiczlK59n3ib3qjicpOyQm9ibjLm1RK5ibNYH5HibCMpLBHqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1138&quot;/&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;         &lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;3、角色权限&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;角色权限整体遵循RBAC模型来进行设计的，业务上可灵活的支持扩展。具体用户能够访问哪些页面、数据源、以及流程权限等，我们也支持设置一些权限集，以便于灵活地进行业务上权限的扩展。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;                  &lt;/span&gt;    &lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0798319327731092&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Oicycervb7zyfGsxQsFVOyiaOGVNlQm9ZicOXSl40q7n8zfUp7TfJQEuz5KmDAtMm93vBvlDF099XjEGuLia1ZbULQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;952&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;从下边的图可以看到，我们可以控制普通应用的访问权限，页面权限以及页面下的按钮权限，也可以控制模型应用的权限；&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;可以控制数据源的行记录，数据源方法权限，数据源列权限，也能够对流程的访问权限做控制，还可以控制企业工作的访问和登录权限等操作。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;                          &lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3125469571750564&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Oicycervb7zyuAHq0dcKmXmaQ7oE5KAcA8nlNvAynkYuiaRibdtZc9p36qXIkeX1fYB6dOsTiaiab5xSXmmj0EaE4dA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2662&quot;/&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;4、服务端扩展&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;服务端的扩展基于云函数的能力，通过页面可视化编写代码来进行服务端逻辑的扩展。可以做一些数据表的聚合，以及CRUD等操作方法。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5616438356164384&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Oicycervb7zyuAHq0dcKmXmaQ7oE5KAcAWwEqcENJZXM5kZ6tLPYJQJQ70LQN6PwV7hdbprwGWazAkke4o8w4XQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;657&quot;/&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;*云函数（Serverless Cloud Function，SCF）&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;是腾讯云为企业和开发者们提供的无服务器执行环境，帮助您在无需购买和管理服务器的情况下运行代码。您只需使用平台支持的语言编写核心代码并设置代码运行的条件，即可在腾讯云基础设施上弹性、安全地运行代码。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;4. 微搭应用开发流程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;此处将介绍基于微搭拖拉拽来快速构建一个应用的生命周期，整个低码应用开发和运行的生命周期，以及低码在设计态和运行态做了什么。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;在微搭的应用开发流程中，微搭应用的生命周期分为设计态和开发态。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;strong mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;1）设计态&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;我们通过前端可视化的界面和组件，进行表单定义模型及定义模型关联关系。我们还可以针对表单配置用户和权限、也可以通过页面来操作配置一些工作流。我们可以拖拉拽配置一些页面，生成页面的DSL。配置数据模型，生成数据的JSONSchema DSL。配置流程生成流程的BPMN扩展，基于角色绑定用户权限，生成RBAC 模型的DSL。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;在发布的时候，我们前端H5会生成Reat代码、小程序会生成小程序代码。发布之后，前端代码会发布在静态托管中，服务端自定义扩展服务逻辑是部署在云函数中。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;2）运行态&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;客户会从web或者小程序发起调用，会经过访问经过我们的静态托管以及云函数和云数据库，进而将请求分为到微搭侧后端中心化服务，和企业第三方服务。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;                  &lt;/span&gt;        &lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.565025716385011&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Oicycervb7zyfGsxQsFVOyiaOGVNlQm9ZicmAibHOklzhDDjC63KJLjL6MMEOdy8CnTco3tQicicwAM1zXr6OCxLUdQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2722&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;29.75&quot;&gt;5. 微搭高可用服务能力&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;一个高可用的服务需要从部署、变更、预案、监控、安全等多方面考虑。达到 99.99%服务高可用的目标，需要各角色的工程师共同努力。本文简单介绍下微搭在消除单点和弹性伸缩这块的实践。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;29.75&quot;&gt;消除单点&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;单点有两种场&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;景：一种是&lt;/span&gt;&lt;strong mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;某个模块仅部署了一个实例&lt;/span&gt;&lt;/strong&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;；第二种是某个模块虽然部署了多个实例，但任&lt;/span&gt;&lt;strong mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;意实例故障都会导致服务整体或者大面积不可用&lt;/span&gt;&lt;/strong&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;。如何识别系统单点？通过排查模块的实例数量和进行破坏性测试来发现系统中是否存在单点。对于已知的单点，则应该尽量做好预案，减少故障时长。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;针对这种情况，&lt;/span&gt;&lt;strong mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;微搭一是在每个集群部署了多个POD 来消除集群内单点，另外一块针对集群1整体挂掉的情况下，也可快速切换集群来消除单点，保障服务的稳定性。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5685534591194968&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Oicycervb7zyuAHq0dcKmXmaQ7oE5KAcAoLlEUulgnaVsHv7T5ZnD7m4aduQ4nn92WPJSa93EK5B7qJPVnDrPpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1590&quot;/&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;29.75&quot;&gt;弹性伸缩&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;弹性伸缩是根据业务需求和策略，针对无状态的服务，通过定时、阈值设定等方式，自动调整集群规模，举例来说，对于&lt;/span&gt;&lt;strong mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;大促，机房故障等灾难场景&lt;/span&gt;&lt;/strong&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;，能够很好的提升可用性。伸缩顾名思义，有伸也有缩，缩的特性，可能让集群维持在一个合理的规模上，从而避免造成不必要的成本浪费。因此，弹性伸缩也是常态下系统保持可用性的重要手段。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;微搭是基于serverless自动弹性伸缩云原生的能力，来保证我们后端服务整体的高可用。当流量高的时候自动来扩容机器，当流量低的来实时缩容服务器。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;                          &lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Oicycervb7zyuAHq0dcKmXmaQ7oE5KAcAgtW7fHw8aeAUUnHazjDJsE0DWXy704WpyjemvN2NmDaeib2Q7kzAprQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;930&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/p&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;/&gt;&lt;/section&gt;&lt;h2 mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;28&quot;&gt;&lt;span mp-original-font-size=&quot;24&quot; mp-original-line-height=&quot;28&quot;&gt;03&lt;/span&gt;&lt;/h2&gt;&lt;h2 mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;28&quot;&gt;&lt;span mp-original-font-size=&quot;24&quot; mp-original-line-height=&quot;28&quot;&gt;微低代码的未来趋势&lt;/span&gt;&lt;/h2&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;从2020年开始，低代码成为了业界热点，无论是资本市场还是企业用户都纷纷追捧。那么在未来，低代码平台会如何发展呢？&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;在我个人理解中，低代码平台开发将会沿两个纬度演进：&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;1、通用性&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;，也就是语言属性维度；随着低代码开发平台的不断成熟和发展，低代码开发平台逐渐具备通用场景的开发能力，例如可以开发网站、游戏、3D场景、电商、企业应用、个人应用；支持的系统也会更加全面，例如支持WebApp、iOS/Android、Windows/Mac/Linux、小程序等各种应用。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;2、便捷性&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;，也就是指代码量不断降低的过程，最终将实现0代码编程。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;但是通用性和便捷性要想同时实现，是非常困难的，这也是低代码开发平台急需解决的问题和下一个挑战。最终使“去掉程序语法，保留程序逻辑”成为可能。&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;最后也回答下大家比较关心的一个问题：&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt; 低代码会取代程序员吗？&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;我认为低代码解决的是可抽象的，通用的且可复用的产品能力，程序员作为高端技术人才，市场缺口巨大，低代码工具是将程序员从现有的重复的枯燥的接口开发中解放出来。程序员应该更关注业务创造方面的技术研究和开发。&lt;/span&gt;&lt;span mp-original-font-size=&quot;14.666666984558105&quot; mp-original-line-height=&quot;29.75&quot;&gt;低代码是工具，低代码与程序员之间的关系就像翻译软件与译者，数据统计系统与数据分析师，工具的目的是减少重复的劳作而将人力投入更有意义、有价值的研究之中。&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;strong mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;29.75&quot;&gt;本文作者：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;29.75&quot;&gt;谢艳祥&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;29.75&quot;&gt;腾讯云微搭高级工程师，专注于后端研发效能提升，工程化体系建设。&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;29.75&quot;&gt;在性能优化、研发效能、架构高可用设计等方向有一定的落地实践经验。&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;/&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;29.75&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;29.75&quot;&gt;文章来源：腾讯云微搭低代码&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span data-raw-text=&quot;❤️&quot; data-textnode-index=&quot;336&quot; data-index=&quot;7580&quot;&gt;❤️&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;336&quot; data-index=&quot;7581&quot;&gt; H5-Dooring，让H5制作更简单&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAyNs2Jog-SwAAAAstQy6ubaLX4KHWvLEZgBPE16AICXFOGIr9zNPgMIu0W21oRBBJVKsQ45ey88-P&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7Ym3K77SEULgkiadGkru52yhQYyxSWtTeQdbh6Jz4VVGrJZocpzDrwJS4yy8KZBiaA8LGl6CaOX6QPmYnWOf5iaXiaTAeQssyUsuBic0g&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SZ&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=x5Y29zUxcibDlfxWROiaaU28lG7O0MQtjZ9ONXO7KzuQiaic2wkLmmrfTT4OzhspB81YQA3KfqZTCM4&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/UbElsfFAugjRuQPHZiaFgaR20aiag3NnqLbrTB4JESOXY/0&quot; data-username=&quot;v2_060000231003b20faec8c7e7881dc1d3cb00e43cb07780a8fcc6d58d85f4f2d027a069baf143@finder&quot; data-nickname=&quot;趣谈前端&quot; data-desc=&quot;分享一款简单好用的H5页面制作工具&quot; data-nonceid=&quot;12015738868130292137&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>46e1bd698e74f476449e3d11f0d61220</guid>
<title>CGO 项目实战</title>
<link>https://toutiao.io/k/a2304fr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某项目要集成 PDF 文件的 OCR 功能，不过由于此功能技术难度太大，网络上找不到靠谱的开源实现，最终不得不选择 &lt;span&gt;ABBYY FineReader Engine&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; 的付费服务。可惜 ABBYY 只提供了 C++ 和 Java 两种编程语言的 SDK，而我们的项目采用的编程语言是 Golang，此时通常的集成方法是使用 C++ 或 Java 实现一个服务，然后在 Golang 项目里通过 RPC 调用服务，不过如此一来明显增加了系统的复杂度，好在 Golang 支持 CGO，让我们可以很方便的在 Golang 中使用 C 模块，本文总结了我在学习 CGO 过程中的心得体会。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们看看一个 CGO 版本的 Hello, world 大概长什么样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/*&lt;br/&gt;#include &amp;lt;stdio.h&amp;gt;&lt;br/&gt;&lt;br/&gt;void say(const char *s) {&lt;br/&gt;    puts(s);&lt;br/&gt;}&lt;br/&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;C&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    hello()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;hello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    s := C.CString(&lt;span&gt;&quot;Hello, World\n&quot;&lt;/span&gt;)&lt;br/&gt;    C.say(s)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上所示，通过「import “C”」来激活 CGO，并且所有 C 语言相关的代码都以注释的形式放在此行之上，中间不允许有空行，这样我们就可以在 Golang 代码里使用 C 模块了，看上去很简单，不过代码里存在内存泄漏，让我们修改一下代码，使问题更明显一点：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/*&lt;br/&gt;#include &amp;lt;stdio.h&amp;gt;&lt;br/&gt;&lt;br/&gt;void say(const char *s) {&lt;br/&gt;    puts(s);&lt;br/&gt;}&lt;br/&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;C&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;        hello()&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;hello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    s := C.CString(&lt;span&gt;&quot;Hello, World\n&quot;&lt;/span&gt;)&lt;br/&gt;    C.say(s)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行程序后，我们可以单独开一个命令行窗口，通过运行 top 命令来监控进程的内存变化，会发现在循环调用 C 模块之后，进程的内存占用不断增加，究其原因，是因为通过 C.CString 创建的变量，会在 C 语言层面上分配内存，而在 Golang 语言层面上是不会负责管理相关内存的，所以我们需要通过 C.free 手动释放相关内存：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/*&lt;br/&gt;#include &amp;lt;stdio.h&amp;gt;&lt;br/&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;br/&gt;&lt;br/&gt;void say(const char *s) {&lt;br/&gt;    puts(s);&lt;br/&gt;}&lt;br/&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;C&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;unsafe&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;        hello()&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;hello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    s := C.CString(&lt;span&gt;&quot;Hello, World\n&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; C.free(unsafe.Pointer(s))&lt;br/&gt;    C.say(s)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说明：代码中的 unsafe.Pointer 相当于 C 语言中的 void *。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;In Action&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些读者看到这里可能会有疑问：虽然 CGO 让我们可以在 Golang 里使用 C，但是文章开头提到的 ABBYY 并没有 C 的 SDK，只有 C++ 的 SDK，那么 CGO 支持 C++ 么？答案是否定的，不过我们可以通过 C 来适配 C++。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以 ABBYY 为例，假设它的安装目录是 /opt/ABBYY/FREngine12，并且通过 &lt;span&gt;ldconfig&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt; 把 /opt/ABBYY/FREngine12/Bin 目录加入到动态链接库的查找目录：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;shell&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;/opt/ABBYY/FREngine12/Bin&quot;&lt;/span&gt; &amp;gt; /etc/ld.so.conf.d/abbyy.conf&lt;/span&gt;&lt;br/&gt;&lt;span&gt;shell&amp;gt;&lt;/span&gt;&lt;span&gt; ldconfig&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;准备工作做好后使用 /opt/ABBYY/FREngine12/Samples/Hello 例子做代码范本：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先编写 OCR.cpp 文件的内容，不用在意技术细节，我放这些代码只是为了备份：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&quot;AbbyyException.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&quot;BstrWrap.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&quot;FREngineLoader.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&quot;./OCR.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;load&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    LoadFREngine();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;unload&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    UnloadFREngine();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;process&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *inPath, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *outPath)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;string&lt;/span&gt; file = outPath;&lt;br/&gt;    &lt;span&gt;string&lt;/span&gt; extension = file.substr(file.find_last_of(&lt;span&gt;&quot;.&quot;&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    FileExportFormatEnum format;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (extension == &lt;span&gt;&quot;pdf&quot;&lt;/span&gt;) {&lt;br/&gt;        format = FEF_PDF;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (extension == &lt;span&gt;&quot;doc&quot;&lt;/span&gt; || extension == &lt;span&gt;&quot;docx&quot;&lt;/span&gt;) {&lt;br/&gt;        format = FEF_DOCX;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (extension == &lt;span&gt;&quot;ppt&quot;&lt;/span&gt; || extension == &lt;span&gt;&quot;pptx&quot;&lt;/span&gt;) {&lt;br/&gt;        format = FEF_PPTX;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (extension == &lt;span&gt;&quot;xls&quot;&lt;/span&gt; || extension == &lt;span&gt;&quot;xlsx&quot;&lt;/span&gt;) {&lt;br/&gt;        format = FEF_XLSX;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;wchar_t&lt;/span&gt; *language = &lt;span&gt;L&quot;ChinesePRC,ChineseTaiwan,English&quot;&lt;/span&gt;;&lt;br/&gt;    CSafePtr frDocument = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    CSafePtr documentProcessingParams;&lt;br/&gt;    CSafePtr pageProcessingParams;&lt;br/&gt;    CSafePtr recognizerParams;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        CheckResult(FREngine-&amp;gt;CreateFRDocumentFromImage(CBstr(inPath), &lt;span&gt;0&lt;/span&gt;, &amp;amp;frDocument));&lt;br/&gt;        CheckResult(FREngine-&amp;gt;CreateDocumentProcessingParams(&amp;amp;documentProcessingParams));&lt;br/&gt;        CheckResult(documentProcessingParams-&amp;gt;get_PageProcessingParams(&amp;amp;pageProcessingParams));&lt;br/&gt;        CheckResult(pageProcessingParams-&amp;gt;get_RecognizerParams(&amp;amp;recognizerParams));&lt;br/&gt;        CheckResult(recognizerParams-&amp;gt;SetPredefinedTextLanguage(CBstr(language)));&lt;br/&gt;        CheckResult(frDocument-&amp;gt;Process(documentProcessingParams));&lt;br/&gt;        CheckResult(frDocument-&amp;gt;Export(CBstr(outPath), format, &lt;span&gt;0&lt;/span&gt;));&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (...) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再编写 OCR.h 文件的内容，要特别注意其中的「&lt;span&gt;extern “C”&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;」，有了它，当编译的时候，就会把 C++ 中的方法名链接成 C 的风格，如此一来，CGO 才能识别它：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;ifdef&lt;/span&gt; __cplusplus&lt;/span&gt;&lt;br/&gt;&lt;span&gt;extern&lt;/span&gt; &lt;span&gt;&quot;C&quot;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;#&lt;span&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;load&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;unload&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;process&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *inPath, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *outPath)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;ifdef&lt;/span&gt; __cplusplus&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;#&lt;span&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后编写 OCR.go 文件的内容，因为 C/C++ 代码量比较大，所以在使用 CGO 的时候直接把 C/C++ 代码写在注释中就显得不合适了，此时更合适的方法是链接库：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// #cgo CFLAGS: -I .&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// #cgo LDFLAGS: -L . -L /opt/ABBYY/FREngine12/Bin/ -lFREngine -lOCR -lstdc++&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// #include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// #include &quot;OCR.h&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;C&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;flag&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;unsafe&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; flag.Parse()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; flag.NArg() != &lt;span&gt;2&lt;/span&gt; {&lt;br/&gt;  os.Exit(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; C.load()&lt;br/&gt; inPath := C.CString(flag.Arg(&lt;span&gt;0&lt;/span&gt;))&lt;br/&gt; outPath := C.CString(flag.Arg(&lt;span&gt;1&lt;/span&gt;))&lt;br/&gt;&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  C.unload()&lt;br/&gt;  C.free(unsafe.Pointer(inPath))&lt;br/&gt;  C.free(unsafe.Pointer(outPath))&lt;br/&gt; }()&lt;br/&gt;&lt;br/&gt; C.process(inPath, outPath)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设目标文件都已经就绪，那么让我们分别看看如何构建静态链接库和动态链接库：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看静态链接库，只要通过如下 ar 命令即可，在最终编译程序的时候，静态链接库会被编译到程序里，所以运行时不存在依赖问题，当然代价就是文件尺寸相对较大：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;shell&amp;gt;&lt;/span&gt;&lt;span&gt; ar -r libOCR.a *.o&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再看动态链接库，只要通过如下 gcc 命令即可，和静态链接库相比，虽然它运行时存在依赖问题，但是它生成的文件尺寸相对较小，不过需要提醒的是，在之前编译目标文件的时候，需要在 CFLAGS 或 CXXFLAGS 参数中需要加入 -fpic 或者 -fPIC 选项，以便实现地址无关，至于 -fpic 和 -fPIC 的区别，可以参考 &lt;span&gt;Shared Libraries&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;shell&amp;gt;&lt;/span&gt;&lt;span&gt; gcc -shared -o libOCR.so *.o&lt;/span&gt;&lt;br/&gt;&lt;span&gt;shell&amp;gt;&lt;/span&gt;&lt;span&gt; cp libOCR.so /opt/ABBYY/FREngine12/Bin/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;动态链接库还有一个有点是更新方便，如果多个程序依赖同一个动态链接库的时候，那么当动态链接库有问题的时候，直接更新它即可，相反如果多个程序依赖同一个静态链接库，那么当静态链接库有问题的时候，你不得不重新编译每一个程序。不过动态链接库的依赖关系本身很容易出问题，下图是我的 OCR 程序依赖关系，有点复杂啊：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-ratio=&quot;0.6375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rJDC5vuwJCMiaiaNuCwca3SNCicMwcZtrCa90aDxz5hj8JY1iasVoeZJvCShnQsaBibvWh0LoBIT5htvFRjmQNDkIfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;动态链接&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文仅是 CGO 的入门笔记，想进一步了解的话，推荐阅读「&lt;span&gt;CGO 编程&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;」，收摊儿。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;ABBYY FineReader Engine: &lt;em&gt;https://www.abbyy.com/ocr-sdk/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;ldconfig: &lt;em&gt;https://linux.die.net/man/8/ldconfig&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;extern “C”: &lt;em&gt;https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;Shared Libraries: &lt;em&gt;https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;CGO 编程: &lt;em&gt;https://chai2010.cn/advanced-go-programming-book/ch2-cgo/readme.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fb6a81854a10cb772f88b60613b12819</guid>
<title>如何从容应对复杂性</title>
<link>https://toutiao.io/k/ay455oc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article data-clipboard-cangjie=&quot;[&amp;quot;root&amp;quot;,{},[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;软件的复杂性，是一个很泛的概念&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;但是一直都是开发过程中的一个难题，本文旨在在探讨如何去从容应对复杂性&amp;quot;]]],[&amp;quot;h2&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:18,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;软件的熵增、构造定律&amp;quot;]]],[&amp;quot;h3&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:15,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;熵增定律&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;熵的概念最早起源于物理学，热力学第二定律（又称“熵增定律”），表明了在自然过程中，一个孤立的系统总是从最初的集中、有序的排列状态，趋向于分散、混乱和无序；当熵达到最大时，系统就会处于一种静寂状态。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;软件系统亦是如此， 在软件系统的维护过程中。软件的生命力会从最初的集中、有序的排列状态，逐步趋向复杂、无序状态，直到软件不可维护而被迫下线或重构。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]],[&amp;quot;img&amp;quot;,{&amp;quot;id&amp;quot;:&amp;quot;2zm7fr&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;image.png&amp;quot;,&amp;quot;size&amp;quot;:228805,&amp;quot;width&amp;quot;:804,&amp;quot;height&amp;quot;:596,&amp;quot;rotation&amp;quot;:0,&amp;quot;src&amp;quot;:&amp;quot;/oss/getResourceRedirectUrl?fileId=neweditor%2F821aa376-2772-4bd8-af00-109c8a74b517.png&amp;amp;expire=3600000&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;  &amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;h3&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:15,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;构造定律&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;自然界是如何应对这复杂性？&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;这在物理中被称为构造定律 （Constructal Law), &amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;是由Adrian Bejan于1995提出的：&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;For a finite-size system to persist in time (to live), it must evolve in such a way that it provides easier access to the imposed currents that flow through it.&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;对于一个有限大小的持续活动的系统，它必须以这种方式发展演进：它提供了一种在自身元素之间更容易访问的流动方式。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;这个定理在自然界中比比皆是，最典型的比如水循环系统，海水蒸发到大气，下雨时降落在地面，一部分渗入地面流入江河，一部分继续蒸发，不断循环。这种自发性质的设计反映了这一趋势：他们允许实体或事物更容易地流动 - 以最少的能量消耗到达最远的地方，就连街道和道路这些人为地构建物体，往往也是有排序的模式，以提供最大的灵活性。&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;h2&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:18,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;如何应对软件系统的复杂性？&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;软件系统的复杂性往往是被低估的。复杂越高，开发人员会感到不安。对其的理解认知负荷代价就越高，我们就更不快乐。真正的挑战是在构建我们的系统时要保持其有序以及工程师的生产方式。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(18, 18, 18)&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;Ousterhout教授在《软件设计的哲学》书中提到&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;color&amp;quot;:&amp;quot;#F5222D&amp;quot;,&amp;quot;sz&amp;quot;:14,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;软件设计的最大目标，就是降低复杂度（complexity）&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;就是设计符合业务的构造定律的演进方式，一种可以以最小的开发维护成本， 使业务更快更好的流动发展的方式&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]],[&amp;quot;img&amp;quot;,{&amp;quot;src&amp;quot;:&amp;quot;/oss/getResourceRedirectUrl?fileId=neweditor%2F8a3a48cc-d47c-4a43-a9c8-1d6d858a2321.png&amp;amp;expire=3600000&amp;quot;,&amp;quot;width&amp;quot;:763,&amp;quot;height&amp;quot;:377,&amp;quot;rotation&amp;quot;:0},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;h2&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:18,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;软件复杂性来自哪里， 如何解决？&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]],[&amp;quot;img&amp;quot;,{&amp;quot;id&amp;quot;:&amp;quot;4p78uk&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;软件复杂性.jpeg&amp;quot;,&amp;quot;size&amp;quot;:14064,&amp;quot;width&amp;quot;:845,&amp;quot;height&amp;quot;:220,&amp;quot;rotation&amp;quot;:0,&amp;quot;src&amp;quot;:&amp;quot;/oss/getResourceRedirectUrl?fileId=neweditor%2F8a0a654f-81e5-4c9b-89a2-9308971f8a0e.jpeg&amp;amp;expire=3600000&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot; &amp;quot;]]],[&amp;quot;h3&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:15,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;不确定性的来源&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;1、业务的不确定性&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;2、技术的不确定性&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;3、人员流动的不确定性&amp;quot;]]],[&amp;quot;h3&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:15,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;如何面对不确定性&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;面对外部的确定性，转化为&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;#FE0300&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;内核的确定性&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;面对外部的不确定性，找到&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;#FE0300&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;稳定的内核基础&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;1、专注问题域&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;当下互联网发展速度是迅猛的， 软件的形态也在不断的变化演进&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;面对未来的业务及变化，横向业务与纵向业务的发展都是不确定性的&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;Robert C. Martin提到的&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(64, 64, 64)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;BDUF&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(64, 64, 64)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;永远不要想着在开始就设计好了全部的事情(big design up front)&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;一定要&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;#F5222D&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;避免过度设计&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;除非能够十分确认的可预见变化， 业务边界&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;否则专注解决当前1-2年内业务变化设计, 讲好当下的用户故事&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;专注解决眼前的问题域， 面向不确定设计，增量敏捷开发&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;2、确认稳定的系统内核&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;随着业务的变化、系统设计也要持续演进升级。没有一开始就完美的架构， 好的架构设计一定演化来的，不是一开始就设计出来的。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;一个健康公司的成长，业务横向、纵向会发展的会越来越复杂，支持业务的系统也一定会越来越复杂。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;系统演进过程中的成本，会受到最开始的设计、系统最初的内核影响的。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;面对外部业务的不确定性， 技术的不确定性，&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;外部依赖的不确定性&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;一个稳定的内核应该尽量把外部的不确定性隔离&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;1、业务与技术的隔离&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;color&amp;quot;:&amp;quot;#FE0300&amp;quot;,&amp;quot;sz&amp;quot;:16,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;以业务为核心&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;，分离业务复杂度和技术复杂度。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;2、内部系统与外部依赖的隔离&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;3、系统中常变部分与不常变部分的隔离&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;4、隔离复杂性（&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(18, 18, 18)&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;把复杂性的部分隔离在一个模块，尽量不与其他模块互动）&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;h3&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:15,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;无序性&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;系统和代码像多个线团一样散落一地一样,&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;混乱不堪，毫无头绪。&amp;quot;]]],[&amp;quot;h3&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:15,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;如何面对无序性&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;1、统一认知（秩序化）&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;2、系统清晰明了的结构（结构化）&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;3、业务开发流程化（标准化）&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;注：这里说的流程化并非指必须使用类似&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;BPM的流程编排系统，&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;而是指对于一个需求，业务开发有一定的顺序， 有规划的先做一部分事情，开发哪一个模块再去做剩下的工作，是可以流程化的&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;h3&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:15,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;规模&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;业务规模的膨胀以及开发团队规模的膨胀&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;都会带来系统的复杂性提升&amp;quot;]]],[&amp;quot;h3&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:15,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;如何面对规模膨胀带来的复杂性&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;1、业务隔离， 分而治之&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;2、专注产品核心竞争力的发展&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;3、场景分层&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;color&amp;quot;:&amp;quot;#FE0300&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;关键场景&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;投入更多的开发、测试资源、业务资源(比如单元测试覆盖率在90%以上)在关键场景， &amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;普通场景&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;更快，更低成本、更少资源投入地完成普通场景的迭代&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;h3&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:15,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;认知成本&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;是指开发人员需要多少知识才能完成一项任务。&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;在引入新的变化时，要考虑到带来的好处是否大于系统认知成本的提升&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;比如：之前提到的BPM流程编排引擎，如果对系统带来的好处不够多也是增加认知成本的一种&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;不合适的设计模式也&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;是增加认知成本的一种&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;前台同学吐槽的星环&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;比较高的学习成本， 也是认知成本的一种&amp;quot;]]],[&amp;quot;h3&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:15,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;如何降低认知成本&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;1、系统与现实业务更自然真实的映射，对业务抽象建模&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]],[&amp;quot;img&amp;quot;,{&amp;quot;src&amp;quot;:&amp;quot;/oss/getResourceRedirectUrl?fileId=neweditor%2Fb9409356-2c95-4ffa-9ebe-d7e52250d4a1.png&amp;amp;expire=3600000&amp;quot;,&amp;quot;width&amp;quot;:729,&amp;quot;height&amp;quot;:260,&amp;quot;rotation&amp;quot;:0},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(77, 77, 77)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;软件工程师实际上只在做一件事情，即把现实中的问题搬到计算机上，通过信息化提升生产力。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;2、代码的含义清晰，不模糊&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;3、代码的整洁度&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;4、系统的有序性， 架构清晰&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;5、避免过度设计&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;6、减少复杂、重复概念， 降低学习成本&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;7、谨慎引入会带来系统复杂性的变化&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;h1&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:21,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;应对复杂性的利器&amp;quot;]]],[&amp;quot;h2&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:18,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;领域驱动设计——DDD&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;领域驱动设计(DDD) &amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;DDD是把业务模型翻译成系统架构设计的一种方式, 领域模型是对业务模型的抽象。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;不是所有的业务服务都合适做DDD架构，DDD合适产品化，可持续迭代，业务逻辑足够复杂的业务系统，小规模的系统与简单业务不适合使用，毕竟相比较于MVC架构，认知成本和开发成本会大不少&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;但是DDD里面的一些战略思想我认为还是较为通用的&amp;quot;]]],[&amp;quot;h3&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:15,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;1、对通用语言的提炼和推广&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;清晰语言认知， 比如之前在详情装修系统中，&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;ItemTemplate : 表示当前具体的装修页面&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;ItemDescTemplate、Template，两个都能表示模板概概念&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;刚开始接触这块的时候比较难理解这一块逻辑&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;之后在负责设计详情编辑器大融合这个项目时第一件事就是团队内先重新统一认知&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;装修页面统一使用 —— Page概念&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;模板统一使用 —— Template概念&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;不将模板和页面的概念糅杂在一起，含糊不清&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;避免重复和混乱的概念定义&amp;quot;]]],[&amp;quot;h3&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:15,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;2、贫血模型和充血模型&amp;quot;]]],[&amp;quot;h4&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;2.1 贫血模型&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;贫血模型的&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(18, 18, 18)&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;基本特征是：它第一眼看起来还真像这么回事儿。项目中有许多对象，它们的命名都是根据领域模型来的。然而当你真正检视这些对象的行为时，会发现它们基本上没有任何行为，仅仅是一堆getter/setter方法，&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(18, 18, 18)&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;这些贫血对象在设计之初就被定义为只能包含数据，不能加入领域逻辑；&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;所有的业务逻辑是放在所谓的业务层（xxxService, xxxManager对象中)，&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(18, 18, 18)&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;需要使用这些模型来传递数据。&amp;quot;]]],[&amp;quot;code&amp;quot;,{&amp;quot;syntax&amp;quot;:&amp;quot;java&amp;quot;,&amp;quot;theme&amp;quot;:&amp;quot;default&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;@Data\npublic class Person {\n    /**\n     * 姓名\n     */\n    private String name;\n\n    /**\n     * 年龄\n     */\n    private Integer age;\n\n    /**\n     * 生日\n     */\n    private Date birthday;\n\n    /**\n     * 当前状态\n     */\n    private Stauts stauts;\n}&amp;quot;]]],[&amp;quot;code&amp;quot;,{&amp;quot;syntax&amp;quot;:&amp;quot;java&amp;quot;,&amp;quot;theme&amp;quot;:&amp;quot;default&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;public class PersonServiceImpl implements PersonService {\n    \n    public void sleep(Person person) {\n        person.setStauts(SleepStatus.get());\n    }\n\n    public void setAgeByBirth(Person person) {\n        Date birthday = person.getBirthday();\n        if (currentDate.before(birthday)) {\n            throw new IllegalArgumentException(\&amp;quot;The birthday is before Now,It&#x27;s unbelievable\&amp;quot;);\n        }\n        int yearNow = cal.get(Calendar.YEAR);\n        int dayBirth = bir.get(Calendar.DAY_OF_MONTH);\n        /*大概计算， 忽略月份等，年龄是当前年减去出生年*/\n        int age = yearNow - yearBirth;\n        person.setAge(age);\n    }\n}\n}&amp;quot;]]],[&amp;quot;code&amp;quot;,{&amp;quot;syntax&amp;quot;:&amp;quot;java&amp;quot;,&amp;quot;theme&amp;quot;:&amp;quot;default&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;public class WorkServiceImpl implements WorkService{\n\n    public void code(Person person) {\n        person.setStauts(CodeStatus.get());\n    }\n\n}&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(18, 18, 18)&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;这一段代码就是贫血对象的处理过程&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(18, 18, 18)&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;Person类， 通过PersonService、WorkingService去控制Person的行为&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(18, 18, 18)&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;第一眼看起来像是没什么问题&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(18, 18, 18)&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;但是真正去思考整个流程&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(18, 18, 18)&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;WorkingService， PersonService到底是什么样的存在&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(18, 18, 18)&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;与真实世界逻辑相比， 过于抽象&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(18, 18, 18)&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;基于贫血模型的传统开发模式，将数据与业务逻辑分离，违反了 OOP 的封装特性，实际上是一种面向过程的编程风格。但是，现在几乎所有的 Web 项目，都是基于这种贫血模型的开发模式，甚至连 Java Spring 框架的官方 demo，都是按照这种开发模式来编写的。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(18, 18, 18)&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;面向过程编程风格有种种弊端，比如，数据和操作分离之后，数据本身的操作就不受限制了。任何代码都可以随意修改数据。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;h4&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;2.2 充血模型&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;充血模型是一种有行为的模型，模型中状态的改变只能通过模型上的行为来触发，同时所有的约束及业务逻辑都收敛在模型上。&amp;quot;]]],[&amp;quot;code&amp;quot;,{&amp;quot;syntax&amp;quot;:&amp;quot;java&amp;quot;,&amp;quot;theme&amp;quot;:&amp;quot;default&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;@Data\npublic class Person extends Entity {\n    /**\n     * 姓名\n     */\n    private String name;\n\n    /**\n     * 年龄\n     */\n    private Integer age;\n\n    /**\n     * 生日\n     */\n    private Date birthday;\n\n    /**\n     * 当前状态\n     */\n    private Stauts stauts;\n\n    public void code() {\n        this.setStauts(CodeStatus.get());\n    }\n    \n    public void sleep() {\n        this.setStauts(SleepStatus.get());\n    }\n    \n    public void setAgeByBirth() {\n        Date birthday = this.getBirthday();\n        Calendar currentDate = Calendar.getInstance();\n        if (currentDate.before(birthday)) {\n            throw new IllegalArgumentException(\&amp;quot;The birthday is before Now,It&#x27;s unbelievable\&amp;quot;);\n        }\n        int yearNow = currentDate.get(Calendar.YEAR);\n        int yearBirth = birthday.getYear();\n        /*粗略计算， 忽略月份等，年龄是当前年减去出生年*/\n        int age = yearNow - yearBirth;\n        this.setAge(age);\n    }\n        \n}&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;h4&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;before&amp;quot;:10.666666666666666,&amp;quot;after&amp;quot;:10.666666666666666,&amp;quot;line&amp;quot;:0.8529411764705882}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;2.3 贫血模型和充血模型的区别&amp;quot;]]],[&amp;quot;code&amp;quot;,{&amp;quot;syntax&amp;quot;:&amp;quot;java&amp;quot;,&amp;quot;theme&amp;quot;:&amp;quot;default&amp;quot;,&amp;quot;wrap&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;/**\n * 贫血模型\n */\npublic class Client {\n\n    @Resource\n    private PersonService personService;\n\n    @Resource\n    private WorkService workService;\n\n    public void test() {\n        Person person = new Person();\n        personService.setAgeByBirth(person);\n        workService.code(person);\n        personService.sleep(person);\n    }\n}\n\n\n/**\n * 充血模型\n */\npublic class Client {\n\n    public void test() {\n        Person person = new Person();\n        person.setAgeByBirth();\n        person.code();\n        person.sleep();\n    }\n}&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;上面两段代码，&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;很明显第二段的认知成本更低，  这在满是Service，Manage 的系统下更为明显&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;Person的行为交由自己去管理， 而不是交给各种Service去管理&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;贫血模型是&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(18, 18, 18)&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;事务脚本模式&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;贫血模型相对简单，模型上只有数据没有行为，业务逻辑由xxxService、xxxManger等类来承载，相对来说比较直接，针对简单的业务，贫血模型可以快速的完成交付，但后期的维护成本比较高，很容易变成我们所说的面条代码。\n&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(18, 18, 18)&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;充血模型是领域模型模式&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;充血模型的实现相对比较复杂，但所有逻辑都由各自的类来负责，职责比较清晰，方便后期的迭代与维护。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(18, 18, 18)&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;面向对象设计主张将数据和行为绑定在一起也就是充血模型，而贫血领域模型则更像是一种面向过程设计，很多人认为这些贫血领域对象是真正的对象，从而彻底误解了面向对象设计的涵义。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(18, 18, 18)&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;Martin Fowler 曾经和 Eric Evans 聊天谈到它时，都觉得这个模型似乎越来越流行了。作为领域模型的推广者，他们觉得这不是一件好事，极力反对这种做法。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(18, 18, 18)&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;贫血领域模型的根本问题是，它引入了领域模型设计的所有成本，却没有带来任何好处。最主要的成本是将对象映射到数据库中，从而产生了一个O/R（对象关系）映射层。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(18, 18, 18)&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;只有当你充分使用了面向对象设计来组织复杂的业务逻辑后，这一成本才能够被抵消。如果将所有行为都写入到Service对象，那最终你会得到一组事务处理脚本，从而错过了领域模型带来的好处。而且当业务足够复杂时， 你将会得到一堆爆炸的事务处理脚本。&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;h3&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:15,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;3、对业务的理解和抽象&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(18, 18, 18)&amp;quot;,&amp;quot;sz&amp;quot;:11.5,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;限定业务边界，&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;对业务进行与现实更自然的理解和抽象&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;数据模型与业务模型隔离&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;把业务映射成为领域模型沉淀在系统中&amp;quot;]]],[&amp;quot;h3&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:15,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;4、结构与防腐层&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]],[&amp;quot;img&amp;quot;,{&amp;quot;src&amp;quot;:&amp;quot;/oss/getResourceRedirectUrl?fileId=neweditor%2F53ca5d18-3bc3-4fc1-8670-d5da79c1267c.png&amp;amp;expire=3600000&amp;quot;,&amp;quot;width&amp;quot;:580,&amp;quot;height&amp;quot;:559,&amp;quot;rotation&amp;quot;:0},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;User &amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;Interfaces&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;负责对外交互, &amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;提供对外远程接口&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;application&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;应用程序执行其任务所需的代码。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;它协调域层对象以执行实际任务。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;该层适用于跨事务、安全检查和高级日志记录。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;domain&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(18, 18, 18)&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;负责表达业务概念&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;对业务的分解，抽象，建模 &amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;业务逻辑、程序的核心。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;#F5222D&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;防腐层接口&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;放在这里&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;infrastucture&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(18, 18, 18)&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;为其他层提供通用的技术能力&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;。如repository的implementation（ibatis，hibernate, nosql），中间件服务等&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;anti-corruption layer的implementation &amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;#F5222D&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;防腐层实现&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;放在这里。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;防腐层的作用：&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgba(0, 0, 0, 0.8)&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;封装三方服务&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;隔离内部系统对外部的依赖&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;h3&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:15,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;5、让隐性概念显性化&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;文档与注释可能会失去实时性（文档、注释没有人持续维护）&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;但是线上生产代码是业务逻辑最真实的展现&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;减少代码中模糊的地方&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;让业务逻辑显性化体现出来&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;提升代码清晰度&amp;quot;]]],[&amp;quot;code&amp;quot;,{&amp;quot;syntax&amp;quot;:&amp;quot;java&amp;quot;,&amp;quot;theme&amp;quot;:&amp;quot;default&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;if (itemDO != null &amp;amp;&amp;amp; MapUtils.isNotEmpty(itemDO.getFeatures()) &amp;amp;&amp;amp; itemDO.getFeatures().containsKey(ITEM_PC_DESCRIPTION_PUSH)) {\n   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_PC_TEMPLATEID, \&amp;quot;\&amp;quot; + templateId);\n   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_SELL_PC_PUSH, \&amp;quot;\&amp;quot; + pcContent.hashCode());\n} else {\n   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_PC_TEMPLATEID, \&amp;quot;\&amp;quot; + templateId);\n   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_WL_TEMPLATEID, \&amp;quot;\&amp;quot; + templateId);\n   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_SELL_PC_PUSH, \&amp;quot;\&amp;quot; + pcContent.hashCode());\n   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_SELL_WL_PUSH, \&amp;quot;\&amp;quot; + content.hashCode());\n}&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;比如这一段代码就把判断里的业务逻辑隐藏了起来&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;这段代码其实的业务逻辑是这样， 判断商品是否有PC装修内容&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;如果有做一些操作， 如果没有做一些操作&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;将hasPCContent 这个逻辑表现出来， 一眼就能看出来大概的业务逻辑&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;让业务逻辑显现化，能让代码更清晰&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;可以改写成这样&amp;quot;]]],[&amp;quot;code&amp;quot;,{&amp;quot;syntax&amp;quot;:&amp;quot;java&amp;quot;,&amp;quot;theme&amp;quot;:&amp;quot;default&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;boolean hasPCContent = itemDO != null &amp;amp;&amp;amp; MapUtils.isNotEmpty(itemDO.getFeatures()) &amp;amp;&amp;amp; itemDO.getFeatures().containsKey(ITEM_PC_DESCRIPTION_PUSH);\nif (hasPCContent) {\n   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_PC_TEMPLATEID, \&amp;quot;\&amp;quot; + templateId);\n   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_SELL_PC_PUSH, \&amp;quot;\&amp;quot; + pcContent.hashCode());\n} else {\n   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_PC_TEMPLATEID, \&amp;quot;\&amp;quot; + templateId);\n   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_WL_TEMPLATEID, \&amp;quot;\&amp;quot; + templateId);\n   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_SELL_PC_PUSH, \&amp;quot;\&amp;quot; + pcContent.hashCode());\n   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_SELL_WL_PUSH, \&amp;quot;\&amp;quot; + content.hashCode());\n}&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;h2&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:18,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;简单设计原则——《Clean Code》&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;1、保持系统最大可测试&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;只要系统可测试并且越丰富的单元测试越会导向保持类短小且目的单一的设计方案，遵循单一职责的类，测试起来比较简单&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;遵循有关编写测试并持续运行测试的简单、明确规则，系统就会更贴近OO低偶尔度，高内聚度的目标。编写测试越多，就越会遵循DIP之类的规则，编写最大可测试可改进并走向更好的系统设计&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;2、避免重复&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(55, 55, 55)&amp;quot;,&amp;quot;sz&amp;quot;:11.5,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;重复是拥有良好设计系统的大敌。它代表着额外的工作、额外的风险和额外且不必要的复杂度。&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;除了雷同的代码，功能类似的方法也可以进行包装减少重复，&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(55, 55, 55)&amp;quot;,&amp;quot;sz&amp;quot;:11.5,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;“小规模复用”可大量降低系统复杂性。要想实现大规模复用，必须理解如何实现小规模复用。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;共性的抽取也会使代码更好的符合单一职责原则&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;3、更清晰的表达开发者的意图&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;软件项目的主要成本在于长期维护，当系统变得越来越复杂，开发者就需要越来越多的时间来理解他，而且也极有可能误解。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;所以作者需要将代码写的更清晰：选用好名称、保持函数和类的短小、采用标准命名法、标准的设计模式名，编写良好的单元测试。用心是最珍贵的资源。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;4、尽可能减少类和方法&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;如果过度使用以上原则，为了保持类的函数短小，我们可能会造出太多细小的类和方法。所以这条规则也主张函数和类的数量要少。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;如应当为每个类创建接口、字段和行为必须切分到数据类和行为类中。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;应该抵制这类教条，采用更实用的手段。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;目标是在保持函数和类短小的同时，保持系统的短小精悍。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;不过这是优先级最低的一条。更重要的是测试，消除重复和清晰表达。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;h1&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;line&amp;quot;:1}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:21,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;最后&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;总而言之，做业务开发其实一点也不简单，面对不确定性的问题域，复杂的业务变化，&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;如何更好的理解和抽象业务，如何更优雅的应对复杂性，一直都是软件开发的一个难题。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;在对抗软件熵增，寻找对抗软件复杂性，符合业务的构造定律的演进方式，我们一直都在路上。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;jc&amp;quot;:&amp;quot;left&amp;quot;,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;h1&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;before&amp;quot;:14.666666666666668,&amp;quot;after&amp;quot;:14.666666666666668,&amp;quot;line&amp;quot;:0.8529411764705882}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;sz&amp;quot;:20,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;参考&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;[1]  《&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(17, 17, 17)&amp;quot;,&amp;quot;fonts&amp;quot;:{&amp;quot;ascii&amp;quot;:&amp;quot;Helvetica&amp;quot;,&amp;quot;hAnsi&amp;quot;:&amp;quot;Helvetica&amp;quot;,&amp;quot;cs&amp;quot;:&amp;quot;Helvetica&amp;quot;,&amp;quot;eastAsia&amp;quot;:&amp;quot;Helvetica&amp;quot;},&amp;quot;sz&amp;quot;:10,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;Domain-Driven Design&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;》 ：&amp;quot;]],[&amp;quot;a&amp;quot;,{&amp;quot;href&amp;quot;:&amp;quot;https://book.douban.com/subject/1629512/&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;https://book.douban.com/subject/1629512/&amp;quot;]]],[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;[2] 《&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(17, 17, 17)&amp;quot;,&amp;quot;fonts&amp;quot;:{&amp;quot;ascii&amp;quot;:&amp;quot;Helvetica&amp;quot;,&amp;quot;hAnsi&amp;quot;:&amp;quot;Helvetica&amp;quot;,&amp;quot;cs&amp;quot;:&amp;quot;Helvetica&amp;quot;,&amp;quot;eastAsia&amp;quot;:&amp;quot;Helvetica&amp;quot;},&amp;quot;sz&amp;quot;:10,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;Implementing Domain-Driven Design&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;》 ：&amp;quot;]],[&amp;quot;a&amp;quot;,{&amp;quot;href&amp;quot;:&amp;quot;https://book.douban.com/subject/25844633/&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;https://book.douban.com/subject/25844633/&amp;quot;]]],[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;[3] 《&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(17, 17, 17)&amp;quot;,&amp;quot;fonts&amp;quot;:{&amp;quot;ascii&amp;quot;:&amp;quot;Helvetica&amp;quot;,&amp;quot;hAnsi&amp;quot;:&amp;quot;Helvetica&amp;quot;,&amp;quot;cs&amp;quot;:&amp;quot;Helvetica&amp;quot;,&amp;quot;eastAsia&amp;quot;:&amp;quot;Helvetica&amp;quot;},&amp;quot;sz&amp;quot;:10,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;Clean Code》：&amp;quot;]],[&amp;quot;a&amp;quot;,{&amp;quot;href&amp;quot;:&amp;quot;https://book.douban.com/subject/4199741/&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;https://book.douban.com/subject/4199741/&amp;quot;]]],[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(17, 17, 17)&amp;quot;,&amp;quot;fonts&amp;quot;:{&amp;quot;ascii&amp;quot;:&amp;quot;Helvetica&amp;quot;,&amp;quot;hAnsi&amp;quot;:&amp;quot;Helvetica&amp;quot;,&amp;quot;cs&amp;quot;:&amp;quot;Helvetica&amp;quot;,&amp;quot;eastAsia&amp;quot;:&amp;quot;Helvetica&amp;quot;},&amp;quot;sz&amp;quot;:10,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;[4]  《&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(73, 73, 73)&amp;quot;,&amp;quot;fonts&amp;quot;:{&amp;quot;ascii&amp;quot;:&amp;quot;Helvetica&amp;quot;,&amp;quot;hAnsi&amp;quot;:&amp;quot;Helvetica&amp;quot;,&amp;quot;cs&amp;quot;:&amp;quot;Helvetica&amp;quot;,&amp;quot;eastAsia&amp;quot;:&amp;quot;Helvetica&amp;quot;},&amp;quot;sz&amp;quot;:10,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;A Philosophy of Software Design》 ：&amp;quot;]],[&amp;quot;a&amp;quot;,{&amp;quot;href&amp;quot;:&amp;quot;https://book.douban.com/subject/30218046/&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;https://book.douban.com/subject/30218046/&amp;quot;]]],[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(73, 73, 73)&amp;quot;,&amp;quot;fonts&amp;quot;:{&amp;quot;ascii&amp;quot;:&amp;quot;Helvetica&amp;quot;,&amp;quot;hAnsi&amp;quot;:&amp;quot;Helvetica&amp;quot;,&amp;quot;cs&amp;quot;:&amp;quot;Helvetica&amp;quot;,&amp;quot;eastAsia&amp;quot;:&amp;quot;Helvetica&amp;quot;},&amp;quot;sz&amp;quot;:10,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]]]&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;‍&lt;/span&gt;软件的复杂性，是一个很泛的概念。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是一直都是开发过程中的一个难题，本文旨在探讨如何去从容应对复杂性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;一  软件的熵增、构造定律&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;1  熵增定律&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;熵的概念最早起源于物理学，热力学第二定律（又称“熵增定律”），表明了在自然过程中，一个孤立的系统总是从最初的集中、有序的排列状态，趋向于分散、混乱和无序；当熵达到最大时，系统就会处于一种静寂状态。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;软件系统亦是如此， 在软件系统的维护过程中。软件的生命力会从最初的集中、有序的排列状态，逐步趋向复杂、无序状态，直到软件不可维护而被迫下线或重构。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7415565345080763&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;681&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLr4HM643NC0QVdy2veiclpKFvYa05uEPvHxCQ5Jo2Bn4WobQfQM8R2nnUI9bz27pSnyOURyJwcQcw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;2  构造定律&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自然界是如何应对这复杂性？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这在物理中被称为构造定律 （Constructal Law), &lt;/span&gt;&lt;span&gt;是由Adrian Bejan于1995提出的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;For a finite-size system to persist in time (to live), it must evolve in such a way that it provides easier access to the imposed currents that flow through it.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于一个有限大小的持续活动的系统，它必须以这种方式发展演进：它提供了一种在自身元素之间更容易访问的流动方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个定理在自然界中比比皆是，最典型的比如水循环系统，海水蒸发到大气，下雨时降落在地面，一部分渗入地面流入江河，一部分继续蒸发，不断循环。这种自发性质的设计反映了这一趋势：他们允许实体或事物更容易地流动 - 以最少的能量消耗到达最远的地方，就连街道和道路这些人为地构建物体，往往也是有排序的模式，以提供最大的灵活性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;二  如何应对软件系统的复杂性？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;软件系统的复杂性往往是被低估的。复杂越高，开发人员会感到不安。对其的理解认知负荷代价就越高，我们就更不快乐。真正的挑战是在构建我们的系统时要保持其有序以及工程师的生产方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Ousterhout教授在《软件设计的哲学》书中提到：&lt;/span&gt;&lt;span&gt;软件设计的最大目标，就是降低复杂度（complexity）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;就是设计符合业务的构造定律的演进方式，一种可以以最小的开发维护成本， 使业务更快更好的流动发展的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.49226006191950467&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;646&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLr4HM643NC0QVdy2veiclpKC6D45xbj7MrIQjOgolsN7SC7dfwqCAGn9Yunb561AyDDO2icT5PwV1A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;三  软件复杂性来自哪里， 如何解决？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.29253731343283584&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;670&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLr4HM643NC0QVdy2veiclpKAEmdoucWPuHkicMn9r9kB7qTjvib7wbtPSOXCqh99D6JDwmB4ic8Wm3hA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;1  不确定性的来源&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、业务的不确定性&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、技术的不确定性&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、人员流动的不确定性&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;2  如何面对不确定性&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;面对外部的确定性，转化为内核的确定性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;面对外部的不确定性，找到稳定的内核基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;专注问题域&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当下互联网发展速度是迅猛的， 软件的形态也在不断的变化演进。&lt;/span&gt;&lt;span&gt;面对未来的业务及变化，横向业务与纵向业务的发展都是不确定性的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Robert C. Martin提到的BDUF，&lt;/span&gt;&lt;span&gt;永远不要想着在开始就设计好了全部的事情(big design up front)，&lt;/span&gt;&lt;span&gt;一定要避免过度设计。&lt;/span&gt;&lt;span&gt;除非能够十分确认的可预见变化， 业务边界，&lt;/span&gt;&lt;span&gt;否则专注解决当前1-2年内业务变化设计, 讲好当下的用户故事，&lt;/span&gt;&lt;span&gt;专注解决眼前的问题域。 面向不确定设计，增量敏捷开发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;确认稳定的系统内核&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着业务的变化、系统设计也要持续演进升级。没有一开始就完美的架构， 好的架构设计一定演化来的，不是一开始就设计出来的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个健康公司的成长，业务横向、纵向会发展的会越来越复杂，支持业务的系统也一定会越来越复杂。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;系统演进过程中的成本，会受到最开始的设计、系统最初的内核影响的。&lt;/span&gt;&lt;span&gt;面对外部业务的不确定性， 技术的不确定性，外部依赖的不确定性。&lt;/span&gt;&lt;span&gt;一个稳定的内核应该尽量把外部的不确定性隔离。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;以业务为核心，分离业务复杂度和技术复杂度。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;3  无序性&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;系统和代码像多个线团一样散落一地一样，&lt;/span&gt;&lt;span&gt;混乱不堪，毫无头绪。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;4  如何面对无序性&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、统一认知（秩序化）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、系统清晰明了的结构（结构化）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、业务开发流程化（标准化）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注：这里说的流程化并非指必须使用类似BPM的流程编排系统，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而是指对于一个需求，业务开发有一定的顺序， 有规划的先做一部分事情，开发哪一个模块再去做剩下的工作，是可以流程化的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;5  规模&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务规模的膨胀以及开发团队规模的膨胀，&lt;/span&gt;&lt;span&gt;都会带来系统的复杂性提升。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;6  如何面对规模膨胀带来的复杂性&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、业务隔离， 分而治之&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、专注产品核心竞争力的发展&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、场景分层&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关键场景&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;投入更多的开发、测试资源、业务资源(比如单元测试覆盖率在90%以上)在关键场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;普通场景&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更快，更低成本、更少资源投入地完成普通场景的迭代&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7  认知成本&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;是指开发人员需要多少知识才能完成一项任务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在引入新的变化时，要考虑到带来的好处是否大于系统认知成本的提升，&lt;/span&gt;&lt;span&gt;比如：&lt;/span&gt;&lt;span&gt;之前提到的BPM流程编排引擎，如果对系统带来的好处不够多也是增加认知成本的一种。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不合适的设计模式也是增加认知成本的一种，前台同学吐槽的中台架构比较高的学习成本， 也是认知成本的一种。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;8  如何降低认知成本&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、系统与现实业务更自然真实的映射，对业务抽象建模&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3605769230769231&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;624&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLr4HM643NC0QVdy2veiclpKYKO1o2iaCXNMx29C1sDUw7SpMhqQ4AsAZQGyGV2BMJ1YmwNXaNPJuFA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;软件工程师实际上只在做一件事情，即把现实中的问题搬到计算机上，通过信息化提升生产力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、代码的含义清晰，不模糊&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、代码的整洁度&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、系统的有序性， 架构清晰&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5、避免过度设计&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6、减少复杂、重复概念， 降低学习成本&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;7、谨慎引入会带来系统复杂性的变化&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;四  应对复杂性的利器&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1  领域驱动设计——DDD&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DDD是把业务模型翻译成系统架构设计的一种方式, 领域模型是对业务模型的抽象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不是所有的业务服务都合适做DDD架构，DDD合适产品化，可持续迭代，业务逻辑足够复杂的业务系统，小规模的系统与简单业务不适合使用，毕竟相比较于MVC架构，认知成本和开发成本会大不少。&lt;/span&gt;&lt;span&gt;但是DDD里面的一些战略思想我认为还是较为通用的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;对通用语言的提炼和推广&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;清晰语言认知， 比如之前在详情装修系统中：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ItemTemplate : 表示当前具体的装修页面&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ItemDescTemplate、Template，两个都能表示模板概概念&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;刚开始接触这块的时候比较难理解这一块逻辑，&lt;/span&gt;&lt;span&gt;之后在负责设计详情编辑器大融合这个项目时第一件事就是团队内先重新统一认知。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;装修页面统一使用 —— Page概念&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;模板统一使用 —— Template概念&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不将模板和页面的概念糅杂在一起，含糊不清，&lt;/span&gt;&lt;span&gt;避免重复和混乱的概念定义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;贫血模型和充血模型&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;1）贫血模型&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;贫血模型的基本特征是：它第一眼看起来还真像这么回事儿。项目中有许多对象，它们的命名都是根据领域模型来的。然而当你真正检视这些对象的行为时，会发现它们基本上没有任何行为，仅仅是一堆getter/setter方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些贫血对象在设计之初就被定义为只能包含数据，不能加入领域逻辑；所有的业务逻辑是放在所谓的业务层（xxxService, xxxManager对象中)，需要使用这些模型来传递数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Data&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; Person {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; name;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; Integer age;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Date&lt;/span&gt; birthday;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; Stauts stauts;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;PersonServiceImpl&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;PersonService&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Person person&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        person.setStauts(SleepStatus.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;setAgeByBirth&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Person person&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Date birthday = person.getBirthday();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (currentDate.before(birthday)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;The birthday is before Now,It&#x27;s unbelievable&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; yearNow = cal.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(Calendar.YEAR);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; dayBirth = bir.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(Calendar.DAY_OF_MONTH);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; age = yearNow - yearBirth;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        person.setAge(age);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;WorkServiceImpl&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;WorkService&lt;/span&gt;&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Person person)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        person.setStauts(CodeStatus.get());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一段代码就是贫血对象的处理过程，&lt;/span&gt;&lt;span&gt;Person类， 通过PersonService、WorkingService去控制Person的行为，&lt;/span&gt;&lt;span&gt;第一眼看起来像是没什么问题，&lt;/span&gt;&lt;span&gt;但是真正去思考整个流程。&lt;/span&gt;&lt;span&gt;WorkingService， PersonService到底是什么样的存在？&lt;/span&gt;&lt;span&gt;与真实世界逻辑相比， 过于抽象。&lt;/span&gt;&lt;span&gt;基于贫血模型的传统开发模式，将数据与业务逻辑分离，违反了 OOP 的封装特性，实际上是一种面向过程的编程风格。&lt;/span&gt;&lt;span&gt;但是，现在几乎所有的 Web 项目，都是基于这种贫血模型的开发模式，甚至连 Java Spring 框架的官方 demo，都是按照这种开发模式来编写的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;面向过程编程风格有种种弊端，比如，数据和操作分离之后，数据本身的操作就不受限制了。任何代码都可以随意修改数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;2）充血模型&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;充血模型是一种有行为的模型，模型中状态的改变只能通过模型上的行为来触发，同时所有的约束及业务逻辑都收敛在模型上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@Data&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Entity&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; String name;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; Integer age;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; Date birthday;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; Stauts stauts;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;code&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.setStauts(CodeStatus.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.setStauts(SleepStatus.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;setAgeByBirth&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Date birthday = &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.getBirthday();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Calendar currentDate = Calendar.getInstance();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (currentDate.before(birthday)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;The birthday is before Now,It&#x27;s unbelievable&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; yearNow = currentDate.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(Calendar.YEAR);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; yearBirth = birthday.getYear();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; age = yearNow - yearBirth;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.setAge(age);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;3）贫血模型和充血模型的区别&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Client&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Resource&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; PersonService personService;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Resource&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; WorkService workService;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Person person = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Person();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        personService.setAgeByBirth(person);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        workService.code(person);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        personService.sleep(person);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Client&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Person person = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Person();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        person.setAgeByBirth();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        person.code();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        person.sleep();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;br/&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;上面两段代码&lt;/span&gt;&lt;span&gt;很明显第二段的认知成本更低，  这在满是Service，Manage 的系统下更为明显，&lt;/span&gt;&lt;span&gt;Person的行为交由自己去管理， 而不是交给各种Service去管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;贫血模型是事务脚本模式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;贫血模型相对简单，模型上只有数据没有行为，业务逻辑由xxxService、xxxManger等类来承载，相对来说比较直接，针对简单的业务，贫血模型可以快速的完成交付，但后期的维护成本比较高，很容易变成我们所说的面条代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;充血模型是领域模型模式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;充血模型的实现相对比较复杂，但所有逻辑都由各自的类来负责，职责比较清晰，方便后期的迭代与维护。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;面向对象设计主张将数据和行为绑定在一起也就是充血模型，而贫血领域模型则更像是一种面向过程设计，很多人认为这些贫血领域对象是真正的对象，从而彻底误解了面向对象设计的涵义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Martin Fowler 曾经和 Eric Evans 聊天谈到它时，都觉得这个模型似乎越来越流行了。作为领域模型的推广者，他们觉得这不是一件好事，极力反对这种做法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;贫血领域模型的根本问题是，它引入了领域模型设计的所有成本，却没有带来任何好处。最主要的成本是将对象映射到数据库中，从而产生了一个O/R（对象关系）映射层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只有当你充分使用了面向对象设计来组织复杂的业务逻辑后，这一成本才能够被抵消。如果将所有行为都写入到Service对象，那最终你会得到一组事务处理脚本，从而错过了领域模型带来的好处。而且当业务足够复杂时， 你将会得到一堆爆炸的事务处理脚本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;对业务的理解和抽象&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;限定业务边界，&lt;/span&gt;&lt;span&gt;对业务进行与现实更自然的理解和抽象，&lt;/span&gt;&lt;span&gt;数据模型与业务模型隔离，&lt;/span&gt;&lt;span&gt;把业务映射成为领域模型沉淀在系统中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;结构与防腐层&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9576107899807321&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;519&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLr4HM643NC0QVdy2veiclpK0k4zOLKibzFNBY9XRvEyzYzibO8qmj4ibodX9Wm3AYoBoSaBr5tico4Ujw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;User Interfaces&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;负责对外交互, 提供对外远程接口&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;application&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;应用程序执行其任务所需的代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它协调域层对象以执行实际任务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该层适用于跨事务、安全检查和高级日志记录。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;domain&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;负责表达业务概念。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对业务的分解，抽象，建模 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务逻辑、程序的核心。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;防腐层接口放在这里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;infrastucture&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为其他层提供通用的技术能力。如repository的implementation（ibatis，hibernate, nosql），中间件服务等&lt;/span&gt;&lt;span&gt;anti-corruption layer的implementation &lt;/span&gt;&lt;span&gt;防腐层实现放在这里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;防腐层的作用：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;封装三方服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;隔离内部系统对外部的依赖。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;让隐性概念显性化&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;文档与注释可能会失去实时性（文档、注释没有人持续维护），&lt;/span&gt;&lt;span&gt;但是线上生产代码是业务逻辑最真实的展现，&lt;/span&gt;&lt;span&gt;减少代码中模糊的地方，&lt;/span&gt;&lt;span&gt;让业务逻辑显性化体现出来，&lt;/span&gt;&lt;span&gt;提升代码清晰度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (itemDO != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; MapUtils.isNotEmpty(itemDO.getFeatures()) &amp;amp;&amp;amp; itemDO.getFeatures().containsKey(ITEM_PC_DESCRIPTION_PUSH)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_PC_TEMPLATEID, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt; + templateId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_SELL_PC_PUSH, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt; + pcContent.hashCode());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_PC_TEMPLATEID, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt; + templateId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_WL_TEMPLATEID, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt; + templateId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_SELL_PC_PUSH, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt; + pcContent.hashCode());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_SELL_WL_PUSH, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt; + content.hashCode());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;span/&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;比如这一段代码就把判断里的业务逻辑隐藏了起来，&lt;/span&gt;&lt;span&gt;这段代码其实的业务逻辑是这样， 判断商品是否有PC装修内容。&lt;/span&gt;&lt;span&gt;如果有做一些操作， 如果没有做一些操作，&lt;/span&gt;&lt;span&gt;将hasPCContent 这个逻辑表现出来， 一眼就能看出来大概的业务逻辑，&lt;/span&gt;&lt;span&gt;让业务逻辑显现化，能让代码更清晰。&lt;/span&gt;&lt;span&gt;可以改写成这样：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;boolean&lt;/span&gt; hasPCContent = itemDO != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; MapUtils.isNotEmpty(itemDO.getFeatures()) &amp;amp;&amp;amp; itemDO.getFeatures().containsKey(ITEM_PC_DESCRIPTION_PUSH);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (hasPCContent) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_PC_TEMPLATEID, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt; + templateId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_SELL_PC_PUSH, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt; + pcContent.hashCode());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_PC_TEMPLATEID, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt; + templateId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_WL_TEMPLATEID, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt; + templateId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_SELL_PC_PUSH, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt; + pcContent.hashCode());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   itemUpdateBO.getFeatures().put(ItemTemplateConstant.FEATURE_TSP_SELL_WL_PUSH, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt; + content.hashCode());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;br/&gt;&lt;span/&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;2  简单设计原则——《Clean Code》&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、保持系统最大可测试&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只要系统可测试并且越丰富的单元测试越会导向保持类短小且目的单一的设计方案，遵循单一职责的类，测试起来比较简单。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;遵循有关编写测试并持续运行测试的简单、明确规则，系统就会更贴近OO低偶尔度，高内聚度的目标。编写测试越多，就越会遵循DIP之类的规则，编写最大可测试可改进并走向更好的系统设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、避免重复&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;重复是拥有良好设计系统的大敌。它代表着额外的工作、额外的风险和额外且不必要的复杂度。除了雷同的代码，功能类似的方法也可以进行包装减少重复，&lt;/span&gt;&lt;span&gt;“小规模复用”可大量降低系统复杂性。&lt;/span&gt;&lt;span&gt;要想实现大规模复用，必须理解如何实现小规模复用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;共性的抽取也会使代码更好的符合单一职责原则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、更清晰的表达开发者的意图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;软件项目的主要成本在于长期维护，当系统变得越来越复杂，开发者就需要越来越多的时间来理解他，而且也极有可能误解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以作者需要将代码写的更清晰：选用好名称、保持函数和类的短小、采用标准命名法、标准的设计模式名，编写良好的单元测试。用心是最珍贵的资源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、尽可能减少类和方法&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果过度使用以上原则，为了保持类的函数短小，我们可能会造出太多细小的类和方法。所以这条规则也主张函数和类的数量要少。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如应当为每个类创建接口、字段和行为必须切分到数据类和行为类中。&lt;/span&gt;&lt;span&gt;应该抵制这类教条，采用更实用的手段。&lt;/span&gt;&lt;span&gt;目标是在保持函数和类短小的同时，保持系统的短小精悍。&lt;/span&gt;&lt;span&gt;不过这是优先级最低的一条。&lt;/span&gt;&lt;span&gt;更重要的是测试，消除重复和清晰表达。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;五  最后&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总而言之，做业务开发其实一点也不简单，面对不确定性的问题域，复杂的业务变化，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何更好的理解和抽象业务，如何更优雅的应对复杂性，一直都是软件开发的一个难题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在对抗软件熵增，寻找对抗软件复杂性，符合业务的构造定律的演进方式，我们一直都在路上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[1]  《Domain-Driven Design》 ：https://book.douban.com/subject/1629512/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[2] 《Implementing Domain-Driven Design》 ：https://book.douban.com/subject/25844633/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[3] 《Clean Code》：https://book.douban.com/subject/4199741/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[4]  《A Philosophy of Software Design》 ：https://book.douban.com/subject/30218046/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/article&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>