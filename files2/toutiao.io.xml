<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>783c4b2149d63d5ce65d18b91eacd36d</guid>
<title>你对天天挂在嘴边的高并发，怕是有什么误解吧？</title>
<link>https://toutiao.io/k/xpyufe6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;高并发，几乎是每个程序员都想拥有的经验。原因很简单：随着流量变大，会遇到各种各样的技术问题，比如接口响应超时、CPU load升高、GC频繁、死锁、大数据量存储等等，这些问题能推动我们在技术深度上不断精进。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;在过往的面试中，如果候选人做过高并发的项目，我通常会让对方谈谈对于高并发的理解，但是能系统性地回答好此问题的人并不多，大概分成这样几类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、对数据化的指标没有概念：&lt;/strong&gt;不清楚选择什么样的指标来衡量高并发系统？分不清并发量和QPS，甚至不知道自己系统的总用户量、活跃用户量，平峰和高峰时的QPS和TPS等关键数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、设计了一些方案，但是细节掌握不透彻：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;讲不出该方案要关注的技术点和可能带来的副作用。比如读性能有瓶颈会引入缓存，但是忽视了缓存命中率、热点key、数据一致性等问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、理解片面，把高并发设计等同于性能优化：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;大谈并发编程、多级缓存、异步化、水平扩容，却忽视高可用设计、服务治理和运维保障。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、掌握大方案，却忽视最基本的东西：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;能讲清楚垂直分层、水平分区、缓存等大思路，却没意识去分析数据结构是否合理，算法是否高效，没想过从最根本的IO和计算两个维度去做细节优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这篇文章，我想结合自己的高并发项目经验，系统性地总结下高并发需要掌握的知识和实践思路，希望对你有所帮助。内容分成以下3个部分：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;90899&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9814814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpR9scLygIskn6ZaT2zRoCmIWtvhia2hrsg2ACwcFY1YTv4LJZtdcRjjHA1pBFtib6lia1MmFPIic88MMntnVEL6HQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;54&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;如何理解高并发？&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9814814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpR9scLygIskn6ZaT2zRoCmIWtvhia2hrUAUsXuNq4BWNjBoomo2r19aicZpIrEgH482K6CVSWVonqy54sY2ta0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;54&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;高并发意味着大流量，需要运用技术手段抵抗流量的冲击，这些手段好比操作流量，能让流量更平稳地被系统所处理，带给用户更好的体验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我&lt;/span&gt;&lt;span&gt;们常见的高并发场景有：淘宝的双11、春运时的抢票、微博大V的热点新闻等。除了这些典型事情，每秒几十万请求的秒杀系统、每天千万级的订单系统、每天亿级日活的信息流系统等，都可以归为高并发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很显然，上面谈到的高并发场景，并发量各不相同，&lt;strong&gt;那到底多大并发才算高并发呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、不能只看数字，要看具体的业务场景。不能说10W QPS的秒杀是高并发，而1W QPS的信息流就不是高并发。信息流场景涉及复杂的推荐模型和各种人工策略，它的业务逻辑可能比秒杀场景复杂10倍不止。因此，不在同一个维度，没有任何比较意义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、业务都是从0到1做起来的，并发量和QPS只是参考指标，最重要的是：在业务量逐渐变成原来的10倍、100倍的过程中，你是否用到了高并发的处理方法去演进你的系统，从架构设计、编码实现、甚至产品方案等维度去预防和解决高并发引起的问题？而不是一味的升级硬件、加机器做水平扩展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，各个高并发场景的业务特点完全不同：有读多写少的&lt;/span&gt;&lt;span&gt;信息流场景、有读多写多的交易场景，&lt;strong&gt;那是否有通用的技术方案解决不同场景的高并发问题呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我觉得大的思路可以借鉴，别人的方案也可以参考，但是真正落地过程中，细节上还会有无数的坑。另外，由于软硬件环境、技术栈、以及产品逻辑都没法做到完全一致，这些都会导致同样的业务场景，就算用相同的技术方案也会面临不同的问题，这些坑还得一个个趟。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，这篇文章我会将重点放在基础知识、通用思路、和我曾经实践过的有效经验上，希望让你对高并发有更深的理解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;90899&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9814814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpR9scLygIskn6ZaT2zRoCmIWtvhia2hrsg2ACwcFY1YTv4LJZtdcRjjHA1pBFtib6lia1MmFPIic88MMntnVEL6HQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;54&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;高并发系统设计的目标是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9814814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpR9scLygIskn6ZaT2zRoCmIWtvhia2hrUAUsXuNq4BWNjBoomo2r19aicZpIrEgH482K6CVSWVonqy54sY2ta0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;54&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;先搞清楚高并发系统设计的目标，在此基础上再讨论设计方案和实践经验才有意义和针对性&lt;/span&gt;。&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;2.1 宏观目标&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;高并发绝不意味着只追求高性能，这是很多人片面的理解。从宏观角度看，高并发系统设计的目标有三个：高性能、高可用，以及高可扩展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;360&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.6342592592592593&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GpR9scLygIskn6ZaT2zRoCmIWtvhia2hrrq9KteB1zBlDFzdPduib2wRZgiaWogcEEkLP2TL7M0bGVYlY7B1OR3IA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这3个目标是需要通盘考虑的，因为它们互相关联、甚至也会相互影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如说：考虑系统的扩展能力，你会将服务设计成无状态的，这种集群设计保证了高扩展性，其实也间接提升了系统的性能和可用性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再比如说：为了保证可用性，通常会对服务接口进行超时设置，以防大量线程阻塞在慢请求上造成系统雪崩，那超时时间设置成多少合理呢？一般，我们会参考依赖服务的性能表现进行设置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;2.2 微观目标&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;再从微观角度来看，高性能、高可用和高扩展又有哪些具体的指标来衡量？为什么会选择这些指标呢？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1）性能指标&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;通过性能指标可以度量目前存在的性能问题，同时作为性能优化的评估依据。一般来说，会采用一段时间内的接口响应时间作为指标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;平均响应时间：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;最常用，但是缺陷很明显，对于慢请求不敏感。比如1万次请求，其中9900次是1ms，100次是100ms，则平均响应时间为1.99ms，虽然平均耗时仅增加了0.99ms，但是1%请求的响应时间已经增加了100倍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;TP90、TP99等分位值：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;将响应时间按照从小到大排序，TP90表示排在第90分位的响应时间， 分位值越大，对慢请求越敏感。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;156&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.2743055555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GpR9scLygIskn6ZaT2zRoCmIWtvhia2hrmpSTExUOX0IOiaf8e2iaOQJS5t7e9mKk8THuia2ZMlVV0Bos8ewX8plgw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;864&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;吞吐量：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;和响应时间呈反比，比如响应时间是1ms，则吞吐量为每秒1000次。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常，设定性能目标时会兼顾吞吐量和响应时间，比如这样表述：在每秒1万次请求下，AVG控制在50ms以下，TP99控制在100ms以下。对于高并发系统，AVG和TP分位值必须同时要考虑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，从用户体验角度来看，200毫秒被认为是第一个分界点，用户感觉不到延迟，1秒是第二个分界点，用户能感受到延迟，但是可以接受。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，对于一个健康的高并发系统，TP99应该控制在200毫秒以内，TP999或者TP9999应该控制在1秒以内。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2）可用性指标&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;高可用性是指系统具有较高的无故障运行能力，可用性 = 正常运行时间 / 系统总运行时间，一般使用几个9来描述系统的可用性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;228&quot; data-backw=&quot;568&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;568&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;156&quot; data-ratio=&quot;0.40083945435466944&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpR9scLygIskn6ZaT2zRoCmIWtvhia2hr64hfhnLsqQEHMM0ibOrpWmwWR7YOvrTuqQgd5K9OLFVvaF1DrXJ6L9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;953&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于高并发系统来说，最基本的要求是：保证3个9或者4个9。原因很简单，如果你只能做到2个9，意味着有1%的故障时间，像一些大公司每年动辄千亿以上的GMV或者收入，1%就是10亿级别的业务影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3）可扩展性指标&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;面对突发流量，不可能临时改造架构，最快的方式就是增加机器来线性提高系统的处理能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于业务集群或者基础组件来说，扩展性 = 性能提升比例 / 机器增加比例，理想的扩展能力是：资源增加几倍，性能提升几倍。通常来说，扩展能力要维持在70%以上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是从高并发系统的整体架构角度来看，扩展的目标不仅仅是把服务设计成无状态就行了，因为当流量增加10倍，业务服务可以快速扩容10倍，但是数据库可能就成为了新的瓶颈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;像MySQL这种有状态的存储服务通常是扩展的技术难点，如果架构上没提前做好规划（垂直和水平拆分），就会涉及到大量数据的迁移。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，高扩展性需要考虑：服务集群、数据库、缓存和消息队列等中间件、负载均衡、带宽、依赖的第三方等，当并发达到某一个量级后，上述每个因素都可能成为扩展的瓶颈点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;90899&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9814814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpR9scLygIskn6ZaT2zRoCmIWtvhia2hrsg2ACwcFY1YTv4LJZtdcRjjHA1pBFtib6lia1MmFPIic88MMntnVEL6HQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;54&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;高并发的实践方案有哪些？&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9814814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpR9scLygIskn6ZaT2zRoCmIWtvhia2hrUAUsXuNq4BWNjBoomo2r19aicZpIrEgH482K6CVSWVonqy54sY2ta0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;54&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;了解了高并发设计的3大目标后，再系统性总结下高并发的设计方案，会从以下两部分展开：先总结下通用的设计方法，然后再围绕高性能、高可用、高扩展分别给出具体的实践方案。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;3.1 通用的设计方法二级标&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;通用的设计方法主要是从「纵向」和「横向」两个维度出发，俗称高并发处理的两板斧：纵向扩展和横向扩展。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1）纵向扩展（scale-up）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;它的目标是提升单机的处理能力，方案又包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2）横向扩展（scale-out）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;因为单机性能总会存在极限，所以最终还需要引入横向扩展，通过集群部署以进一步提高并发处理能力，又包括以下2个方向：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;455&quot; data-backw=&quot;568&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;568&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;228&quot; data-ratio=&quot;0.8009259259259259&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpR9scLygIskn6ZaT2zRoCmIWtvhia2hr2KFcC2ImKwmp7rPNIhIhDiafqpaEEicicmExvgqylia2shjubCz9StNjIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面这种图是互联网最常见的分层架构，当然真实的高并发系统架构会在此基础上进一步完善。比如会做动静分离并引入CDN，反向代理层可以是LVS+Nginx，Web层可以是统一的API网关，业务服务层可进一步按垂直业务做微服务化，存储层可以是各种异构数据库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;3.2 具体的实践方案&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面再结合我的个人经验，针对高性能、高可用、高扩展3个方面，总结下可落地的实践方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1）高性能的实践方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;集群部署&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，通过负载均衡减轻单机压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;多级缓存&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，包括静态数据使用CDN、本地缓存、分布式缓存等，以及对缓存场景中的热点key、缓存穿透、缓存并发、数据一致性等问题的处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分库分表和索引优化&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，以及借助搜索引擎解决复杂查询问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;考虑NoSQL数据库的使用&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，比如HBase、TiDB等，但是团队必须熟悉这些组件，且有较强的运维能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;异步化&lt;/strong&gt;，将次要流程通过多线程、MQ、甚至延时任务进行异步处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;限流&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，需要先考虑业务是否允许限流（比如秒杀场景是允许的），包括前端限流、Nginx接入层的限流、服务端的限流。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;对流量进行削峰填谷&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，通过MQ承接流量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;并发处理&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，通过多线程将串行逻辑并行化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;预计算&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，比如抢红包场景，可以提前计算好红包金额缓存起来，发红包时直接使用即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;存预热&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，通过异步任务提前预热数据到本地缓存或者分布式缓存中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;减少IO次数&lt;/strong&gt;，比如数据库和缓存的批量读写、RPC的批量接口支持、或者通过冗余数据的方式干掉RPC调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;减少IO时的数据包大小&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，包括采用轻量级的通信协议、合适的数据结构、去掉接口中的多余字段、减少缓存key的大小、压缩缓存value等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;程序逻辑优化&lt;/strong&gt;，比如将大概率阻断执行流程的判断逻辑前置、For循环的计算逻辑优化，或者采用更高效的算法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;各种池化技术的使用和池大小的设置&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;包括HTTP请求池、线程池（考虑CPU密集型还是IO密集型设置核心参数）、数据库和Redis连接池等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;JVM优化&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，包括新生代和老年代的大小、GC算法的选择等，尽可能减少GC频率和耗时。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;锁选择&lt;/strong&gt;，读多写少的场景用乐观锁，或者考虑通过分段锁的方式减少锁冲突。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上述方案无外乎从计算和 IO 两个维度考虑所有可能的优化点，需要有配套的监控系统实时了解当前的性能表现，并支撑你进行性能瓶颈分析，然后再遵循二八原则，抓主要矛盾进行优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2）高可用的实践方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;对等节点的故障转移，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Nginx和服务治理框架均支持一个节点失败后访问另一个节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;非对等节点的故障转移，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;通过心跳检测并实施主备切换（比如redis的哨兵模式或者集群模式、MySQL的主从切换等）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;接口层面的超时设置、重试策略和幂等设计。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;降级处理：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;保证核心服务，牺牲非核心服务，必要时进行熔断；或者核心链路出问题时，有备选链路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;限流处理：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;对超过系统处理能力的请求直接拒绝或者返回错误码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;MQ场景的消息可靠性保证，&lt;/strong&gt;包括producer端的重试机制、broker侧的持久化、consumer端的ack机制等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;灰度发布，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;能支持按机器维度进行小流量部署，观察系统日志和业务指标，等运行平稳后再推全量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;监控报警：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;全方位的监控体系，包括最基础的CPU、内存、磁盘、网络的监控，以及Web服务器、JVM、数据库、各类中间件的监控和业务指标的监控。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;灾备演练：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;类似当前的“混沌工程”，对系统进行一些破坏性手段，观察局部故障是否会引起可用性问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;高可用的方案主要从&lt;strong&gt;冗余、取舍、系统运维&lt;/strong&gt;3个方向考虑，同时需要有配套的值班机制和故障处理流程，当出现线上问题时，可及时跟进处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3）高扩展的实践方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;合理的分层架构：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;比如上面谈到的互联网最常见的分层架构，另外还能进一步按照数据访问层、业务逻辑层对微服务做更细粒度的分层（但是需要评估性能，会存在网络多一跳的情况）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;存储层的拆分：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;按照业务维度做垂直拆分、按照数据特征维度进一步做水平拆分（分库分表）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;业务层的拆分：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;最常见的是按照业务维度拆（比如电商场景的商品服务、订单服务等），也可以按照核心接口和非核心接口拆，还可以按照请求源拆（比如To C和To B，APP和H5）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;90899&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9814814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpR9scLygIskn6ZaT2zRoCmIWtvhia2hrsg2ACwcFY1YTv4LJZtdcRjjHA1pBFtib6lia1MmFPIic88MMntnVEL6HQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;54&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;最后的话&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9814814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpR9scLygIskn6ZaT2zRoCmIWtvhia2hrUAUsXuNq4BWNjBoomo2r19aicZpIrEgH482K6CVSWVonqy54sY2ta0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;54&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;高并发确实是一个复杂且系统性的问题，由于篇幅有限，诸如分布式Trace、全链路压测、柔性事务都是要考虑的技术点。另外，如果业务场景不同，高并发的落地方案也会存在差异，但是总体的设计思路和可借鉴的方案基本类似。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;高并发设计同样要秉承架构设计的3个原则：简单、合适和演进。“过早的优化是万恶之源”，不能脱离业务的实际情况，更不要过度设计，合适的方案就是最完美的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;希望这篇文章能带给你关于高并发更全面的认识，如果你也有可借鉴的经验和深入的思考，欢迎评论区留言讨论。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;  作者丨骆俊武&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;来源丨公众号：武哥漫谈IT（ID：BestITer）&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;dbaplus社群欢迎广大技术人员投稿，投稿邮箱：&lt;/span&gt;&lt;span&gt;editor@dbaplus.cn&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;205&quot; data-backw=&quot;568&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;568&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;205&quot; data-ratio=&quot;0.36086956521739133&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8YY6J547ZhgwY87vBia8l2ic7vAeqPaIJicV0RiacMHFOs2HBwzojCN94ROMWN3hCF1Z5DAwEaibibQSLxQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1150&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5cd8619e5363d8fdbf992c09adc158f2</guid>
<title>Go 工程化（八）：单元测试</title>
<link>https://toutiao.io/k/svx31y3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;markdown-body&quot;&gt;&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;/&gt;序&lt;/h2&gt;&lt;p&gt;本系列为 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;amp;utm_medium=lailin.xyz&quot;&gt;Go 进阶训练营&lt;/a&gt; 笔记，预计 2021Q2 完成更新，访问 &lt;a href=&quot;https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/&quot;&gt;博客: Go 进阶训练营&lt;/a&gt; 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。&lt;strong&gt;3 月进度: 05/15&lt;/strong&gt; 3 月开始会尝试爆更模式，争取做到两天更新一篇文章，如果感兴趣可以拉到文章最下方获取关注方式。&lt;/p&gt;&lt;p&gt;从我们开始开发以来，应该很多人都提到过测试的重要性，而在所有的测试类型当中，以单元测试为代表的单元测试无疑是成本最小，性价比最高的一种，而且有的公司为了保证质量会要求单元测试覆盖率的指标（包括我们）&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1614514088908-363f1894-098c-47e5-8289-0e223adda8a6.png&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;所以希望看完这篇文章，希望大家可以很快的在我们之前提出的项目结构上进行单元测试的编写，可以做到又快又好。&lt;br/&gt;本文分为两部分，前半段会简单介绍一下 go 的单元测试怎么写，不会有很复杂的技巧，如果已经比较了解可以跳过，后半段会介绍一下我们在项目当中该如何写 “单元测试”&lt;/p&gt;&lt;h2 id=&quot;单元测试简明教程&quot;&gt;&lt;a href=&quot;#单元测试简明教程&quot; class=&quot;headerlink&quot; title=&quot;单元测试简明教程&quot;/&gt;单元测试简明教程&lt;/h2&gt;&lt;h3 id=&quot;go-test&quot;&gt;&lt;a href=&quot;#go-test&quot; class=&quot;headerlink&quot; title=&quot;go test&quot;/&gt;go test&lt;/h3&gt;&lt;h4 id=&quot;一个简单的-🌰&quot;&gt;&lt;a href=&quot;#一个简单的-🌰&quot; class=&quot;headerlink&quot; title=&quot;一个简单的 🌰&quot;/&gt;一个简单的 🌰&lt;/h4&gt;&lt;p&gt;项目结构&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;.&lt;br/&gt;├── max.go&lt;br/&gt;└── max_test.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;max.go&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; max&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Int get the max&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(a, b &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; a &amp;gt; b {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; b&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;max_test.go&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; max&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;testing&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TestInt&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; got := Int(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;); got != &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; {&lt;br/&gt;t.Errorf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;exp: %d, got: %d&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, got)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;执行结果&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;▶ go &lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;&lt;br/&gt;PASS&lt;br/&gt;ok      code/max        0.006s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;单元测试文件说明&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;文件名必须是&lt;code&gt;_test.go&lt;/code&gt;结尾的，这样在执行&lt;code&gt;go test&lt;/code&gt;的时候才会执行到相应的代码。&lt;/li&gt;&lt;li&gt;你必须&lt;code&gt;import testing&lt;/code&gt;这个包。&lt;/li&gt;&lt;li&gt;所有的测试用例函数必须是&lt;code&gt;Test&lt;/code&gt;开头。&lt;/li&gt;&lt;li&gt;测试用例会按照源代码中写的顺序依次执行。&lt;/li&gt;&lt;li&gt;测试函数&lt;code&gt;TestX()&lt;/code&gt;的参数是&lt;code&gt;testing.T&lt;/code&gt;，我们可以使用该类型来记录错误或者是测试状态。&lt;/li&gt;&lt;li&gt;测试格式：&lt;code&gt;func TestXxx (t *testing.T)&lt;/code&gt;,&lt;code&gt;Xxx&lt;/code&gt;部分可以为任意的字母数字的组合，但是首字母不能是小写字母[a-z]，例如&lt;code&gt;Testintdiv&lt;/code&gt;是错误的函数名。&lt;/li&gt;&lt;li&gt;函数中通过调用&lt;code&gt;testing.T&lt;/code&gt;的&lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;Errorf&lt;/code&gt;, &lt;code&gt;FailNow&lt;/code&gt;, &lt;code&gt;Fatal&lt;/code&gt;, &lt;code&gt;FatalIf&lt;/code&gt;方法，说明测试不通过，调用&lt;code&gt;Log&lt;/code&gt;方法用来记录测试的信息。&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;表驱动测试&quot;&gt;&lt;a href=&quot;#表驱动测试&quot; class=&quot;headerlink&quot; title=&quot;表驱动测试&quot;/&gt;表驱动测试&lt;/h4&gt;&lt;p&gt;在实际编写单元测试的时候，我们往往需要执行多个测试用例，期望达到更全面的覆盖效果，这时候就需要使用表驱动测试了。&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TestInt_Table&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;tests := []&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;br/&gt;name &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;&lt;br/&gt;a    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&lt;br/&gt;b    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&lt;br/&gt;want &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&lt;br/&gt;}{&lt;br/&gt;{name: &lt;span class=&quot;hljs-string&quot;&gt;&quot;a&amp;gt;b&quot;&lt;/span&gt;, a: &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, b: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, want: &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;},&lt;br/&gt;{name: &lt;span class=&quot;hljs-string&quot;&gt;&quot;a&amp;lt;b&quot;&lt;/span&gt;, a: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, b: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, want: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;},&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; _, tt := &lt;span class=&quot;hljs-keyword&quot;&gt;range&lt;/span&gt; tests {&lt;br/&gt;t.Run(tt.name, &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; got := Int(tt.a, tt.b); got != tt.want {&lt;br/&gt;t.Errorf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;exp: %d, got: %d&quot;&lt;/span&gt;, tt.want, got)&lt;br/&gt;}&lt;br/&gt;})&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;执行结果&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;▶ &lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt; test -v&lt;br/&gt;=== RUN   TestInt&lt;br/&gt;--- PASS: TestInt (&lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;s)&lt;br/&gt;=== RUN   TestInt_Table&lt;br/&gt;=== RUN   TestInt_Table/a&amp;gt;b&lt;br/&gt;=== RUN   TestInt_Table/a&amp;lt;b&lt;br/&gt;--- PASS: TestInt_Table (&lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;s)&lt;br/&gt;    --- PASS: TestInt_Table/a&amp;gt;b (&lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;s)&lt;br/&gt;    --- PASS: TestInt_Table/a&amp;lt;b (&lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt;s)&lt;br/&gt;PASS&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;随机执行&lt;/strong&gt;&lt;br/&gt;上面的例子是按照顺序执行的，单元测试大多随机执行更能够发现一些没有注意到的错误, 如下面的这个例子，利用 &lt;code&gt;map&lt;/code&gt; 的特性我们很容易将上面这个例子改造为随机执行的单元测试&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TestInt_RandTable&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;tests := &lt;span class=&quot;hljs-keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;]&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;br/&gt;a    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&lt;br/&gt;b    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&lt;br/&gt;want &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&lt;br/&gt;}{&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;a&amp;gt;b&quot;&lt;/span&gt;: {a: &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, b: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, want: &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;},&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;a&amp;lt;b&quot;&lt;/span&gt;: {a: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, b: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, want: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;},&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; name, tt := &lt;span class=&quot;hljs-keyword&quot;&gt;range&lt;/span&gt; tests {&lt;br/&gt;t.Run(name, &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; got := Int(tt.a, tt.b); got != tt.want {&lt;br/&gt;t.Errorf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;exp: %d, got: %d&quot;&lt;/span&gt;, tt.want, got)&lt;br/&gt;}&lt;br/&gt;})&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;testfiy&quot;&gt;&lt;a href=&quot;#testfiy&quot; class=&quot;headerlink&quot; title=&quot;testfiy&quot;/&gt;testfiy&lt;/h3&gt;&lt;p&gt;标准库为我们提供了一个还不错的测试框架，但是没有提供断言的功能，&lt;code&gt;testify&lt;/code&gt; 包含了 断言、mock、suite 三个功能，mock 推荐使用官方的 &lt;code&gt;gomock&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;testify/assert&lt;/code&gt; 提供了非常多的方法，这里为大家介绍最为常用的一些，所有的方法可以访问 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://godoc.org/github.com/stretchr/testify/assert&quot;&gt;https://godoc.org/github.com/stretchr/testify/assert&lt;/a&gt; 查看&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 判断两个值是否相等&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Equal&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(t TestingT, expected, actual &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt;{}, msgAndArgs ...&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 判断两个值不相等&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NotEqual&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(t TestingT, expected, actual &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt;{}, msgAndArgs ...&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 测试失败，测试中断&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;FailNow&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(t TestingT, failureMessage &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;, msgAndArgs ...&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 判断值是否为nil，常用于 error 的判断&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Nil&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(t TestingT, object &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt;{}, msgAndArgs ...&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 判断值是否不为nil，常用于 error 的判断&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NotNil&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(t TestingT, object &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt;{}, msgAndArgs ...&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;我们可以发现，断言方法都会返回一个 &lt;code&gt;bool&lt;/code&gt; 值，我们可以通过这个返回值判断断言成功/失败，从而做一些处理&lt;/p&gt;&lt;p&gt;一个例子&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TestInt_assert_fail&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;got := Int(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)&lt;br/&gt;assert.Equal(t, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, got)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;执行结果, 可以看到输出十分的清晰&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;=== RUN   TestInt_assert_fail&lt;br/&gt;--- FAIL: TestInt_assert_fail (0.00s)&lt;br/&gt;    max_test.go:62:&lt;br/&gt;                Error Trace:    max_test.go:62&lt;br/&gt;                Error:          Not equal:&lt;br/&gt;                                expected: 1&lt;br/&gt;                                actual  : 2&lt;br/&gt;                Test:           TestInt_assert_fail&lt;br/&gt;FAIL&lt;br/&gt;FAIL    code/max        0.017s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;gomock&quot;&gt;&lt;a href=&quot;#gomock&quot; class=&quot;headerlink&quot; title=&quot;gomock&quot;/&gt;gomock&lt;/h3&gt;&lt;h4 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;/&gt;安装&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;注意: 请在非项目文件夹执行下面这条命令&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;GO111MODULE=on GOPROXY=https://goproxy.cn go get github.com/golang/mock/mockgen&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;code&gt;mockgen&lt;/code&gt; 是一个代码生成工具，可以对包或者源代码文件生成指定&lt;strong&gt;接口&lt;/strong&gt;的 Mock 代码&lt;/p&gt;&lt;h4 id=&quot;生成-Mock-代码&quot;&gt;&lt;a href=&quot;#生成-Mock-代码&quot; class=&quot;headerlink&quot; title=&quot;生成 Mock 代码&quot;/&gt;生成 Mock 代码&lt;/h4&gt;&lt;p&gt;指定源文件&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;mockgen -&lt;span class=&quot;hljs-built_in&quot;&gt;source&lt;/span&gt;=./.go  -destination=./a_mock.go  INeedMockInterface&lt;br/&gt;&lt;br/&gt;mockgen -&lt;span class=&quot;hljs-built_in&quot;&gt;source&lt;/span&gt;=源文件路径  -destination=写入文件的路径(没有这个参数输出到终端) 需要mock的接口名(多个接口逗号间隔)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;指定包路径&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;mockgen  -destination=写入文件的路径(没有这个参数输出到终端) 包路径 需要mock的接口名(多个接口逗号间隔)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h4 id=&quot;一个简单的-gomock-🌰&quot;&gt;&lt;a href=&quot;#一个简单的-gomock-🌰&quot; class=&quot;headerlink&quot; title=&quot;一个简单的 gomock 🌰&quot;/&gt;一个简单的 gomock 🌰&lt;/h4&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// UserAge 获取用户年龄&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; UserAge &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; {&lt;br/&gt;GetAge(user &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Simple 一个简单的例子&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Simple&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(user &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;, age UserAge)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; fmt.Sprintf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%s age is: %d&quot;&lt;/span&gt;, user, age.GetAge(user))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TestSimple&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 新建一个mock对象&lt;/span&gt;&lt;br/&gt;ctrl := gomock.NewController(t)&lt;br/&gt;age := mock_mock.NewMockUserAge(ctrl)&lt;br/&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;// mock 返回值&lt;/span&gt;&lt;br/&gt;age.EXPECT().GetAge(gomock.Any()).Return(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;).AnyTimes()&lt;br/&gt;&lt;br/&gt;assert.Equal(t, &lt;span class=&quot;hljs-string&quot;&gt;&quot;a age is: 1&quot;&lt;/span&gt;, Simple(&lt;span class=&quot;hljs-string&quot;&gt;&quot;a&quot;&lt;/span&gt;, age))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;项目-“单元测试”&quot;&gt;&lt;a href=&quot;#项目-“单元测试”&quot; class=&quot;headerlink&quot; title=&quot;项目 “单元测试”&quot;/&gt;项目 “单元测试”&lt;/h2&gt;&lt;p&gt;接下来就是本文的重点，在我们之前提到的 &lt;a href=&quot;https://lailin.xyz/post/go-training-week4-project-layout.html&quot;&gt;Go 工程化(二) 项目目录结构&lt;/a&gt; 当中，如何编写单元测试。虽然这里说的是单元测试，其实后面讲的其实很多不是单元测试，像 repo 层，如果涉及到数据库后面就会讲到我们一般会启动一个真实的数据库来测试，这其实已经算是集成测试了，但是它仍然是轻量级的。&lt;/p&gt;&lt;h3 id=&quot;service&quot;&gt;&lt;a href=&quot;#service&quot; class=&quot;headerlink&quot; title=&quot;service&quot;/&gt;service&lt;/h3&gt;&lt;p&gt;这一层主要处理的 dto 和 do 数据之间的相互转换，本身是不含什么业务逻辑的，目前我们使用的是 http，所以在这一层的测试一般会使用 httptest 来模拟实际请求的测试。然后在对 usecase 层的调用上，我们使用 gomock mock 掉相关的接口，简化我们的测试。如果你不想写的那么麻烦，也可以不用启用 httptest 来测试，直接测试 service 层的代码也是可以的，不过这样的话，service 层的代码测试的内容就没有多少了，也就是看转换数据的时候符不符合预期。&lt;/p&gt;&lt;p&gt;这一层主要完成的测试是&lt;/p&gt;&lt;ul&gt;&lt;li&gt;参数的校验是否符合预期&lt;/li&gt;&lt;li&gt;数据的转换是否符合预期，如果你像我一样偷懒使用了类似 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://pkg.go.dev/github.com/jinzhu/copier&quot;&gt;copier&lt;/a&gt; 的工具的话一定要写这部分的单元测试，不然还是很容易出错，容易字段名不一致导致 copier 的工作不正常&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;当然如果时间有限的话，这一层的测试也不是必须的，因为接入层相对来说变化也比较快一点，这是说写了单元测试，基本上在测试阶段很少会出现由于参数的问题提交过来的 bug&lt;/p&gt;&lt;p&gt;同样我们直接看一个例子, 首先是 service 层的代码，可以看到逻辑很简单，就是调用了一下，usecase 层的接口&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; _ v1.BlogServiceHTTPServer = &amp;amp;PostService{}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// PostService PostService&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; PostService &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;br/&gt;Usecase domain.IPostUsecase&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// CreateArticle 创建文章&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(p *PostService)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CreateArticle&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ctx context.Context, req *v1.Article)&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(*v1.Article, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;article, err := p.Usecase.CreateArticle(ctx, domain.Article{&lt;br/&gt;Title:    req.Title,&lt;br/&gt;Content:  req.Content,&lt;br/&gt;AuthorID: req.AuthorId,&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;, err&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; resp v1.Article&lt;br/&gt;err = copier.Copy(&amp;amp;resp, &amp;amp;article)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;amp;resp, err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;再看看单元测试&lt;br/&gt;首先是初始化，之前我们讲到初始化的时候我们一般在 cmd 当中使用 wire 自动生成，但是在单元测试中 wire 并不好用，并且由于单元测试的时候我们的依赖项其实没有真实的依赖项那么复杂我们只需要关心当前这一层的依赖即可，所以一般在单元测试的时候我都是手写初始化&lt;br/&gt;一般会向下面这样，使用一个 struct 包装起来，因为在后面像是 mock 的 usecase 还需要调用&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; testPostService &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;br/&gt;post    *PostService&lt;br/&gt;usecase *mock_domain.MockIPostUsecase&lt;br/&gt;handler *gin.Engine&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;initPostService&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(t *testing.T)&lt;/span&gt; *&lt;span class=&quot;hljs-title&quot;&gt;testPostService&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;ctrl := gomock.NewController(t)&lt;br/&gt;usecase := mock_domain.NewMockIPostUsecase(ctrl)&lt;br/&gt;service := &amp;amp;PostService{Usecase: usecase}&lt;br/&gt;&lt;br/&gt;handler := gin.New()&lt;br/&gt;v1.RegisterBlogServiceHTTPServer(handler, service)&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;amp;testPostService{&lt;br/&gt;post:    service,&lt;br/&gt;usecase: usecase,&lt;br/&gt;handler: handler,&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;实际的测试，这一块主要是为了展示一个完整的单元测试所以贴的代码稍微长了一些，后面的两层具体的单元测试代码都大同小异，我就不再贴了，主要的思路就是把依赖的接口都用 gomock mock 掉，这样实际写单元测试代码的时候就会比较简单。&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TestPostService_CreateArticle&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;s := initPostService(t)&lt;br/&gt;s.usecase.EXPECT().&lt;br/&gt;CreateArticle(gomock.Any(), gomock.Eq(domain.Article{Title: &lt;span class=&quot;hljs-string&quot;&gt;&quot;err&quot;&lt;/span&gt;, AuthorID: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;})).&lt;br/&gt;Return(domain.Article{}, fmt.Errorf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;err&quot;&lt;/span&gt;))&lt;br/&gt;s.usecase.EXPECT().&lt;br/&gt;CreateArticle(gomock.Any(), gomock.Eq(domain.Article{Title: &lt;span class=&quot;hljs-string&quot;&gt;&quot;success&quot;&lt;/span&gt;, AuthorID: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;})).&lt;br/&gt;Return(domain.Article{Title: &lt;span class=&quot;hljs-string&quot;&gt;&quot;success&quot;&lt;/span&gt;}, &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;tests := []&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;br/&gt;name       &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;&lt;br/&gt;params     *v1.Article&lt;br/&gt;want       *v1.Article&lt;br/&gt;wantStatus &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&lt;br/&gt;wantCode   &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&lt;br/&gt;wantErr    &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;&lt;br/&gt;}{&lt;br/&gt;{&lt;br/&gt;name: &lt;span class=&quot;hljs-string&quot;&gt;&quot;参数错误 author_id 必须&quot;&lt;/span&gt;,&lt;br/&gt;params: &amp;amp;v1.Article{&lt;br/&gt;Title:    &lt;span class=&quot;hljs-string&quot;&gt;&quot;1&quot;&lt;/span&gt;,&lt;br/&gt;Content:  &lt;span class=&quot;hljs-string&quot;&gt;&quot;2&quot;&lt;/span&gt;,&lt;br/&gt;AuthorId: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;br/&gt;},&lt;br/&gt;want:       &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;,&lt;br/&gt;wantStatus: &lt;span class=&quot;hljs-number&quot;&gt;400&lt;/span&gt;,&lt;br/&gt;wantCode:   &lt;span class=&quot;hljs-number&quot;&gt;400&lt;/span&gt;,&lt;br/&gt;},&lt;br/&gt;{&lt;br/&gt;name: &lt;span class=&quot;hljs-string&quot;&gt;&quot;失败&quot;&lt;/span&gt;,&lt;br/&gt;params: &amp;amp;v1.Article{&lt;br/&gt;Title:    &lt;span class=&quot;hljs-string&quot;&gt;&quot;err&quot;&lt;/span&gt;,&lt;br/&gt;AuthorId: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;br/&gt;},&lt;br/&gt;want:       &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;,&lt;br/&gt;wantStatus: &lt;span class=&quot;hljs-number&quot;&gt;500&lt;/span&gt;,&lt;br/&gt;wantCode:   &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;,&lt;br/&gt;},&lt;br/&gt;{&lt;br/&gt;name: &lt;span class=&quot;hljs-string&quot;&gt;&quot;成功&quot;&lt;/span&gt;,&lt;br/&gt;params: &amp;amp;v1.Article{&lt;br/&gt;Title:    &lt;span class=&quot;hljs-string&quot;&gt;&quot;success&quot;&lt;/span&gt;,&lt;br/&gt;AuthorId: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;br/&gt;},&lt;br/&gt;want: &amp;amp;v1.Article{&lt;br/&gt;Title: &lt;span class=&quot;hljs-string&quot;&gt;&quot;success&quot;&lt;/span&gt;,&lt;br/&gt;},&lt;br/&gt;wantStatus: &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt;,&lt;br/&gt;wantCode:   &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;br/&gt;},&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; _, tt := &lt;span class=&quot;hljs-keyword&quot;&gt;range&lt;/span&gt; tests {&lt;br/&gt;t.Run(tt.name, &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 下面这些一般都会封装在一起，这里是为了演示&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 初始化请求&lt;/span&gt;&lt;br/&gt;b, err := json.Marshal(tt.params)&lt;br/&gt;require.NoError(t, err)&lt;br/&gt;uri := fmt.Sprintf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/v1/author/%d/articles&quot;&lt;/span&gt;, tt.params.AuthorId)&lt;br/&gt;req := httptest.NewRequest(http.MethodPost, uri, bytes.NewReader(b))&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 初始化响应&lt;/span&gt;&lt;br/&gt;w := httptest.NewRecorder()&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 调用相应的handler接口&lt;/span&gt;&lt;br/&gt;s.handler.ServeHTTP(w, req)&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 提取响应&lt;/span&gt;&lt;br/&gt;resp := w.Result()&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;defer&lt;/span&gt; resp.Body.Close()&lt;br/&gt;require.Equal(t, tt.wantStatus, resp.StatusCode)&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 读取响应body&lt;/span&gt;&lt;br/&gt;respBody, _ := ioutil.ReadAll(resp.Body)&lt;br/&gt;r := &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;br/&gt;Code &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;         &lt;span class=&quot;hljs-string&quot;&gt;`json:&quot;code&quot;`&lt;/span&gt;&lt;br/&gt;Msg  &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;      &lt;span class=&quot;hljs-string&quot;&gt;`json:&quot;msg&quot;`&lt;/span&gt;&lt;br/&gt;Data *v1.Article &lt;span class=&quot;hljs-string&quot;&gt;`json:&quot;data&quot;`&lt;/span&gt;&lt;br/&gt;}{}&lt;br/&gt;require.NoError(t, json.Unmarshal(respBody, &amp;amp;r))&lt;br/&gt;&lt;br/&gt;assert.Equal(t, tt.wantCode, r.Code)&lt;br/&gt;assert.Equal(t, tt.want, r.Data)&lt;br/&gt;})&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;usecase&quot;&gt;&lt;a href=&quot;#usecase&quot; class=&quot;headerlink&quot; title=&quot;usecase&quot;/&gt;usecase&lt;/h3&gt;&lt;p&gt;usecase 是主要的业务逻辑，所以一般写单元测试的时候都应该先写这一层的单远测试，而且这一层我们没有任何依赖，只需要把 repo 层的接口直接 mock 掉就可以了，是非常纯净的一层，其实也就这一层的单元测试才是真正的单元测试&lt;/p&gt;&lt;h3 id=&quot;repo&quot;&gt;&lt;a href=&quot;#repo&quot; class=&quot;headerlink&quot; title=&quot;repo&quot;/&gt;repo&lt;/h3&gt;&lt;p&gt;repo 层我们一般依赖 mysql 或者是 redis 等数据库，在测试的时候我们可以直接启动一个全新的数据库用于测试即可。&lt;/p&gt;&lt;h4 id=&quot;本地&quot;&gt;&lt;a href=&quot;#本地&quot; class=&quot;headerlink&quot; title=&quot;本地&quot;/&gt;本地&lt;/h4&gt;&lt;p&gt;直接使用 docker run 对应的数据库就可以了&lt;/p&gt;&lt;h4 id=&quot;ci-cd&quot;&gt;&lt;a href=&quot;#ci-cd&quot; class=&quot;headerlink&quot; title=&quot;ci/cd&quot;/&gt;ci/cd&lt;/h4&gt;&lt;p&gt;我们的 ci cd 是使用的 gitlab，gitlab 有一个比较好用的功能是指定 service，只需要指定对应的数据库镜像我们就可以在测试容器启动的时候自动启动对应的测试数据库容器，并且每一次都是全新的空数据库。我们只需要每次跑单元测试的时候先跑一下数据库的 migration 就可以了。&lt;/p&gt;&lt;p&gt;下面给出一个配置示例&lt;/p&gt;&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs yaml&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;test:&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;stage:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;test&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;image:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;golang:1.15-alpine-test&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;services:&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;redis:v4.0.11&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;postgres:10-alpine&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;docker:19-dind&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;variables:&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-attr&quot;&gt;POSTGRES_DB:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;test_db&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-attr&quot;&gt;POSTGRES_USER:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;root&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-attr&quot;&gt;POSTGRES_PASSWORD:&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1234567&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-attr&quot;&gt;GOPROXY:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;这里设置 proxy 地址&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-attr&quot;&gt;CGO_ENABLED:&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;script:&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;download&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;db/*.go&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;artifacts&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;gotestsum&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;-coverprofile=./artifacts/coverage.out&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;-coverpkg=./...&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;./...&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;# 单元测试统计去除一些不需要测试的代码&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;|&lt;/span&gt;&lt;br/&gt;      &lt;span class=&quot;hljs-string&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;./artifacts/coverage.out&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;\&lt;/span&gt;&lt;br/&gt;      &lt;span class=&quot;hljs-string&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;/mock/&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;/db/&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;|&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;pb.go&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;./artifacts/coverage.out2&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;tool&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;cover&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;-func=./artifacts/coverage.out2&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;# 捕获单元测试覆盖率在 gitlab job 上显示&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;coverage:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#x27;/total:\s+.*\s+\d+\.\d+%/&#x27;&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;artifacts:&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-attr&quot;&gt;paths:&lt;/span&gt;&lt;br/&gt;      &lt;span class=&quot;hljs-bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;artifacts/coverage.out&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;/&gt;总结&lt;/h2&gt;&lt;p&gt;单元测试的介绍就到这里了，这篇文章从单元测试的基本写法，再到我们在项目当中如何写单元测试都简单介绍了一下，希望你看了这篇文章能有所收获。&lt;/p&gt;&lt;p&gt;同时我们 Go 工程化 这一章节的内容也接近尾声了，整理的材料也挺多的，下一篇就是这一节的最后一篇文章，讲一讲我在真实改造一个项目的时候遇到的一些问题和解决方案。&lt;/p&gt;&lt;h2 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;/&gt;参考文献&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;amp;utm_medium=lailin.xyz&quot;&gt;Go 进阶训练营-极客时间&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/stretchr/testify&quot;&gt;https://github.com/stretchr/testify&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/golang/mock&quot;&gt;https://github.com/golang/mock&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://pkg.go.dev/github.com/jinzhu/copier&quot;&gt;https://pkg.go.dev/github.com/jinzhu/copier&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ac9c534b493b6468dfaaf21385aecdea</guid>
<title>详解低延时高音质：回声消除与降噪篇</title>
<link>https://toutiao.io/k/axnb7n6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-id=&quot;97593&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.2173913043478262&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBGvmIzgMnias1Gia2184vGeCQib3Z6zUfLX24YsAJCaD2Q7X6iagDDUpPTicc2iczkXEpoxumkGbVvuVjLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;23&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p hm_fix=&quot;328:399&quot;&gt;在实时音频互动场景中，除了我们上一篇讲到的编解码会影响音质与体验，在端上，降噪、回声消除、自动增益模块同样起着重要作用。在本篇内容中我们将主要围绕回声消除和降噪模块，讲讲实时互动场景下的技术挑战，以及我们的解决思路与实践。&lt;span&gt;「文末有个小彩蛋:) 」&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101598&quot;&gt;&lt;section hm_fix=&quot;410:202&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9774436090225563&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YO07vjlZVBGvmIzgMnias1Gia2184vGeCQT7jYhsFQCN5QPLBBFCFE8A1L2w3apkfxYYBuyvhawVPTGHKAVZpv0Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;266&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;回声消除的三大算法模块优化&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在语音通信系统中，回声消除（Echo Cancellation）一直扮演着核心算法的角色。一般来说，回声消除的效果受诸多因素的影响，包括：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;声网回声消除算法在设计之初，就将算法性能、鲁棒性和普适性作为最终的优化目标，这一点对于一个优秀的音视频 SDK 来说至关重要。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先，回声是怎么产生的？简单来讲，就是你的声音从对方的扬声器发出，这个声音又被他的麦克风给收录了进去，这个被麦克风收录的声音又传回到你这一端，你就听到了回声。为了消除回声，我们就要设计一个算法将这个声音信号从麦克风信号中去除掉。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;p line=&quot;jpdn&quot;&gt;&lt;img data-ratio=&quot;0.5214477211796247&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBGvmIzgMnias1Gia2184vGeCQRk2Vz0sRon1LC20FhCUIVuUdm8Bzm5V1CWia9dXHd8WLAyias7G7wrBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1492&quot;/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么声学回声消除模块（AEC, Acoustic Echo Cancellation）是如何消除回声的呢？具体的步骤见如下简图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.8365122615803815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBGvmIzgMnias1Gia2184vGeCQ1L0nTepRR1BhmgoBbKUfibCb0licr5WQudaRKdxO0fXOfVKpYfD0Pmcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;367&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第一步需要找到参考信号/扬声器信号（蓝色折线）跟麦克风信号（红色折线）之间的延迟，也就是图中的 delay=T。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第二步根据参考信号估计出麦克风信号中的线性回声成分，并将其从麦克风信号中减去，得到残差信号（黑色折线）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第三步通过非线性的处理将残差信号中的残余回声给彻底抑制掉。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;与以上的三个步骤相对应，回声消除也由三个大的算法模块组成：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中「延迟估计」决定了AEC的下限，「线性自适应滤波器」决定了 AEC 的上限，「非线性处理」决定了最终的通话体验，特别是回声抑制跟双讲之间的平衡。&lt;/span&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;82&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;注：双讲是指在交互场景中，互动双方或多方同时讲话，其中一方的声音会受到抑制，从而出现断断续续的情况。这是由于回声消除算法“矫枉过正”，消除了部分不该去除的音频信号。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;接下来，我们先围绕这三个算法模块，分别讲讲其中的技术挑战与优化思路。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、延迟估计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;受具体系统实现的影响，当把参考信号与麦克风信号分别送入 AEC 模块进行处理之时，它们所存入的数据 buffer 之间存在一个时间上的延迟，即我们在上图中看到的“delay=T”。假设这个产生回声的设备是一部手机，那么声音从它的扬声器发出后，一部分会经过设备内部传导到麦克风，也可能会经过外部环境传回到麦克风中。所以这个延迟就包含了设备采集播放 buffer 的长度，声音在空气中传输的时间，也包含了播放线程与采集线程开始工作的时间差。&lt;strong&gt;正是由于影响延迟的因素很多，因此这个延迟的值在不同系统，不同设备，不同 SDK 底层实现上都各不相同。&lt;/strong&gt;它在通话过程中也许是一个定值，也有可能会中途变化（所谓的 overrun 和 underrun）。这也是为什么一个 AEC 算法在设备 A 上可能起作用，但换到另一个设备上可能效果会变差。延迟估计的精确性是 AEC 能够工作的先决条件，过大的估计偏差会导致 AEC 的性能急剧下降，甚至无法工作，而无法快速跟踪时延变化是出现偶现回声的重要因素。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;增强延迟估计算法鲁棒性&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;传统算法通常通过计算参考信号跟麦克风信号之间的相关性来决定延迟。相关性的计算可以放在频域上，典型的就是 Binary Spectrum 的方法，通过计算单频点上的信号能量是否超过一定门限值，实际将参考信号跟麦克风信号映射成了两维的0/1数组，然后通过不断移动数组偏移来找到延迟。最新的 WebRTC AEC3 算法通过并行的多个NLMS线性滤波器来寻找延迟，这个方法在检测速度及鲁棒性方面都取得了不错的效果，但是计算量非常大。当在时域上计算两个信号的互相关时，一个明显的问题是语音信号包含大量的谐波成分并且具有时变特性，它的相关信号常常呈现出多峰值的特征，有的峰值并不代表真正的延迟，并且算法容易受到噪声干扰。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;声网延迟估计算法通过降低信号之间的相关性（de-correlate），能够有效抑制 local maxima 的值以大大增强算法的鲁棒性。如下图所示，左边是原始信号之间的互相关，右边是声网SDK处理后的互相关，可见信号的预处理大大增强了延迟估计的鲁棒性：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;p line=&quot;hzQn&quot;&gt;&lt;img data-ratio=&quot;0.27256317689530685&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBGvmIzgMnias1Gia2184vGeCQNugB0awicbicAvFnn4OkcYCadEc2SgvUpiatb1OibIDOQRBIlj0ehASPnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;算法自适应，降低计算量&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通常延迟估计算法为了降低计算量的需要，会预先假设回声信号出现在某个较低的频段内，这样就可以将信号做完下采样之后再送入延迟估计模块，降低算法的计算复杂度。然而面对市面上数以万计的设备及各种路由，以上的假设往往并不成立。下图是 VivoX20 在耳机模式下麦克风信号的频谱图，可见回声都集中在 4kHz 以上的频段内，传统的算法针对这些 case 都会导致回声消除模块的失效。声网延迟估计算法会在全频段内搜索回声出现的区域，并自适应地选择该区域计算延迟，确保算法在任何设备，路由下都有精确的延迟估计输出。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;p line=&quot;4Or3&quot;&gt;&lt;img data-ratio=&quot;0.44765342960288806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBGvmIzgMnias1Gia2184vGeCQtmyY8pVkl3qo4DRt6wJItxSia7SrTDicmwPlwXoEVMQcWArM3vvf013w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p line=&quot;4Or3&quot;&gt;&lt;/p&gt;&lt;p line=&quot;c5J4&quot;&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;图：VivoX20 接入耳机后的麦克风信号&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;动态更新音频算法库，提升设备覆盖率&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了确保算法的持续迭代改进，声网维护了一个音频算法的数据库。我们使用大量不同测试设备，在不同声学环境下采集到了各种参考信号和麦克风信号的组合，而它们之间的延迟全部通过离线处理的方式进行标定。除了真实采集的数据，数据库中也包含了大量仿真的数据，包括不同的说话人，不同的混响强度，不同的底噪水平，以及不同的非线性失真类型。为了衡量延迟估计算法的性能，参考信号与麦克风信号之间的延迟可以随机的变化，用以观察算法对突发延迟变化的响应。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以判断一个延迟估计算法的优劣，还需要考察：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;1. 适应尽量多的设备、声学环境，且在尽量短的时间内根据设备、声学环境的因素匹配合适的算法；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 在突发随机的延迟变化后，能及时动态调整算法策略。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;以下是声网 SDK 与友商之间的延迟估计性能对比，总共使用了数据库中 8640 组测试数据。从图中数据可以看出，声网 SDK 可以在更短的时间内找到大多数测试数据的初始时延。在 96% 的测试数据中，声网 SDK 能在 1s 之内找到它们正确的延迟，而友商这一比例为 89%。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6021220159151194&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBGvmIzgMnias1Gia2184vGeCQ1PdsbwrwbweNPiaZuF0cAG76KpeLEHcmHzr9Z1NqZpjCcXYPMRYlA7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;754&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;p line=&quot;Mm5Z&quot;&gt;&lt;span data-comment-guid=&quot;comment-FilKQRswXFnBKHde&quot;&gt;第二个测试的是在通话过程中出现随机的延迟抖动，测试延迟估计算法要在尽量短的时间内找到精确的延迟值。如图中所示，声网 SDK 在 71% 的测试数据中能在 3s 之内重新找到变化后的精确延迟值，而友商这个比例为 44%。&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;p line=&quot;VY3Z&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBGvmIzgMnias1Gia2184vGeCQCCygehVOD67pOVCqScIiaP6icscle64LwicR29YrRCGzTREJqjt7xpic1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5866336633663366&quot; data-w=&quot;808&quot;/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、线性自适应滤波器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于线性滤波器，已有大量的文献介绍其原理及实践。当应用于回声消除的应用场景，主要考虑的指标包含收敛速度（convergence rate），稳态失调（steady-state misalignment）及跟踪性能（tracking capability）。这些指标之间往往也有冲突，譬如较大的步长可以改善收敛速度，但是会导致较大的失调。这个就是自适应滤波器中的没有免费的午餐定理(No Free Lunch Theorem)。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于自适应滤波器的类型，除了最为常用的 NLMS 滤波器（Model Independent），还可以使用 RLS 滤波器（Least Squares Model）或 Kalman 滤波器（State-Space Model）。除了各自理论推导中的各种假设，近似，优化，这些滤波器的性能最终都归结到如何计算最佳的步长因子（在卡尔曼滤波器里面步长因子合并到 Kalman Gain 的计算里面）。在滤波器尚未收敛或是环境传输函数突变的情形下，步长因子需要足够大以跟踪环境变化，当滤波器收敛及环境传递函数变化缓慢的时间段，步长因子应尽量减小以达到尽可能小的稳态失调。对于步长因子的计算，需要考虑自适应滤波器后残余回声跟残差信号间的能量比值，建模为系统的 leakage coefficients。这个变量常常等价于求滤波器系数跟真实传递函数之间的差（Kalman 滤波器里面称为状态空间状态向量误差），这也是整个估计算法中的难点。除此之外，双讲阶段的滤波器发散问题也是一个需要考虑的点，一般来说这个问题可以通过调整滤波器结构，使用 two echo path models 来解决。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;声网自适应滤波器算法并不使用单一的滤波器类型，而是兼顾了不同滤波器之间的优点，同时搭配自适应算法计算最优的步长因子。此外，算法通过线性滤波器系数实时估计环境的传递函数，自动修正滤波器长度，以覆盖通信设备连接 HDMI 外设等高混响，强回声的场景。如下是一个例子，在声网办公室的一个中型会议室中（面积约 20m2，三面玻璃墙），使用 Macbook Pro 通过 HDMI 连接小米电视，图中是线性滤波器时域信号的变化趋势，算法能自动计算并匹配实际环境传递函数的长度（在第 1400 帧左右自动检测出了强混响环境），以优化线性滤波器的性能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;p&gt;&lt;span line-inline=&quot;V378&quot;&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YO07vjlZVBGvmIzgMnias1Gia2184vGeCQOZib8t9rdbHLJUP94ov64mY9acpdKfAOg1w6CRkrj3AiahpxVpnqBXbA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;560&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;同样的，我们也使用数据库中大量测试数据进行声网 SDK 与友商之间的性能对比，对比的指标包括稳态失调（滤波器收敛之后对回声的抑制程度）以及收敛速度（滤波器达到收敛状态需要的时长）。第一张图代表自适应滤波器的稳态失调，声网SDK在 47%的测试数据中能达到超过 20dB 的回声抑制，而友商的比例为 39%。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;span line-inline=&quot;wSkF&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBGvmIzgMnias1Gia2184vGeCQAUtJ6HVMhfobjofQKiaZFsSTl8Cgg54OCSibUmqibSciarLlOm9fryeVcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6021220159151194&quot; data-w=&quot;754&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;下图显示的是自适应滤波器的收敛速度，声网 SDK 在 51% 的测试样本中能在通话前 3s 之内收敛到稳态，而友商的比例为13%。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p line=&quot;nVBX&quot;&gt;&lt;img data-ratio=&quot;0.5994694960212201&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBGvmIzgMnias1Gia2184vGeCQB2l9Av0DXZPhqNN8ODayiarM7mhbvMNb6lBGib4CP3gnyvqebAfeBk4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;754&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;三、非线性处理&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;非线性处理旨在抑制线性滤波器所没有预测出的回声成分，通常通过计算参考信号，麦克风信号，线性回声以及残差信号间的相关性，或是将相关性直接映射到抑制增益上，或是通过相关性估计出残留回声的功率谱，进一步通过维纳滤波器等传统降噪的算法抑制残留回声。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作为回声消除算法的最后一个模块，除了抑制残留回声之外，非线性处理单元也肩负着监控整个系统是否正常工作的重任，譬如线性滤波器是否因为延迟抖动而无法正常工作？在声网 SDK 回声消除之前是否存在硬件回声消除未能处理的残余回声？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下面是一个简单的例子，通过自适应滤波器估计出的回声能量等内部参数，能够更快的发现延迟变化的现象，并且提示 NLP 采取相应的动作：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;p line=&quot;m80l&quot;&gt;&lt;span line-inline=&quot;5qxP&quot;&gt;&lt;img data-ratio=&quot;0.6642599277978339&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBGvmIzgMnias1Gia2184vGeCQiauWm2HaoAjtAWiavdia3ia0hkVG9Gj0d1UxIayW41NVNADjnFlluwkWtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;随着声网 SDK 覆盖的场景越来越广，针对音乐信号的传输成为了一个重要的场景。声网 SDK 针对音乐信号的回声消除体验做了大量的优化，一个典型场景是舒适噪声的估计算法改进。传统算法使用基于 Minimum Statistics 的算法原理对信号中的底噪进行估计，当把这个算法应用于音乐信号时，因为音乐信号比之语音信号更为平稳，因此会过高的估计噪声功率，反映到回声消除中会导致处理后有回声时段与无回声时段间的底噪（背景噪声）不平稳，体验极差。声网 SDK通过信号分类以及模块融合的方式，彻底解决了 CNG 估计导致的底噪起伏现象。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;除此之外，声网 SDK 还针对所有可能碰到的极端情况，包括非因果系统，设备频率偏移，采集信号溢出，声卡包含系统信号处理等等，都进行了大量的优化，确保算法能够工作在所有的通信场景中。&lt;/span&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101598&quot;&gt;&lt;section hm_fix=&quot;410:202&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9774436090225563&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YO07vjlZVBGvmIzgMnias1Gia2184vGeCQT7jYhsFQCN5QPLBBFCFE8A1L2w3apkfxYYBuyvhawVPTGHKAVZpv0Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;266&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;音质优先的降噪策略&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;降噪对信号音质的影响大于回声消除模块，这一点源自于在降噪算法的设计之初，我们先验的假设底噪都是平稳信号（至少是短时平稳的），而根据这个假设，音乐跟底噪的区分度明显弱于语音跟底噪的区分度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;声网 SDK 在降噪模块的前端预置了信号分类模块，能够精确的检测出信号的类型，并根据信号的类型调整降噪算法的类型及参数，常见的信号类型包括一般语音、清唱、音乐信号等。下图所示是两个降噪算法处理的信号片段，其中第一个是语音与音乐的混合信号，前15秒为含噪的语音信号，之后是40s是音乐信号，再之后是10s的含噪语音，语谱图从上到下分别是原始信号、友商处理结果、声网SDK处理结果。结果显示在语音段信号降噪性能差不多的前提下，竞品处理过信号中的音乐部分受到了严重的损伤，而声网SDK的处理并没有降低音乐的音质。&lt;/span&gt;&lt;/section&gt;&lt;p line=&quot;j21a&quot;&gt;&lt;img data-ratio=&quot;0.5327102803738317&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBGvmIzgMnias1Gia2184vGeCQ4qeibYDpySqEgx3eWaElWns4B1jcGmvwiaSiaEC1z3SK7iasngRk7y0kpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;642&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在第二个例子中，使用的音频是歌手的清唱，清唱中歌手反复发出“啊”的声音。在下图的语谱图中，从上到下分别是原始信号、友商的处理结果、声网 SDK 处理结果。结果显示，友商的降噪处理严重的损伤了原语音的频谱成分，而声网 SDK 完整的保留了原语音的谐波成分，保证了歌手清唱时候的音质体验。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p line=&quot;sgTg&quot;&gt;&lt;img data-ratio=&quot;0.5073313782991202&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBGvmIzgMnias1Gia2184vGeCQD3mI8ibMCA9t80cl3ZFDaicXxgdOTveicgwsP2qPoaJRdrjbiaJuCC9NpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;682&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;结语&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;自1967年贝尔实验室的M. M. Sondhi开创性的提出以自适应滤波器的方法来消除回声为开端，无数的研究和实践都投入到了这个语音通信的最基本问题上。要完美的解决回声问题，除了要有强大的算法作为基础，也需要在工程优化领域做很多优化。声网会持续不断的改进回声消除在各个不同应用场景下的体验。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在本系列的下一篇内容中，我们将随着音频信号，从设备端进入现实的网络环境，一边实地环行上海，一边聊聊音频互动场景下的延时、抖动，以及丢包对抗背后的优化策略。（以一张图来简单剧透，敬请期待）&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;p line=&quot;MAVh&quot;&gt;&lt;span line-inline=&quot;5x5v&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p line=&quot;nVBX&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.61171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBGvmIzgMnias1Gia2184vGeCQb9m0A2VaibQxJQVYoZlWRQc07pj3I5bNdr3W1nWHdaFicYJh3icaJL1Fg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101592&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;361:373&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9774436090225563&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YO07vjlZVBGvmIzgMnias1Gia2184vGeCQT7jYhsFQCN5QPLBBFCFE8A1L2w3apkfxYYBuyvhawVPTGHKAVZpv0Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;266&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;END&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3037037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YO07vjlZVBEHqOZjJmEPvV8JHfEDRRkq4aQIgGKpLLGE7KUcBVJVMhkRibEKbYLzKkOYzMbia7B90GEslXrkCYUg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ad534605cb0170e5d9c78384c0ee0b08</guid>
<title>大话 Python：python 基础巩固 -- Python 3 * 和 ** 运算符使用场景</title>
<link>https://toutiao.io/k/wp1dj1g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、算数运算&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt; * &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;2   6&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt; ** &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;4   9&lt;/span&gt;&lt;span/&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;2、函数形参&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;*args 和 **kwargs 主要用于函数定义，&lt;/span&gt;&lt;span&gt;你可以将不定数量的参数传递给一个函数。&lt;/span&gt;&lt;span&gt;不定的意思是：&lt;/span&gt;&lt;span&gt;预先并不知道, 函数使用者会传递多少个参数给你，所以在这个场景下使用这两个关键字，&lt;/span&gt;&lt;span&gt;其实并不是必须写成 *args 和 **kwargs。&lt;/span&gt;&lt;span&gt;* 是必须要有的。 也可以写成 *r  和 **g ,&lt;/span&gt;&lt;span&gt;写成 *args 和**kwargs 是通常的一种约定。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;python函数传递参数的方式：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;*args 与 **kwargs 的区别：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果同时使用 *args 和 **kwargs 时，必须 *args 参数列要在 **kwargs 的前面。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;fun&lt;/span&gt;&lt;span&gt;(*args, **kwargs)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;...     print(&lt;span&gt;&#x27;args=&#x27;&lt;/span&gt;, args)&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;...     print(&lt;span&gt;&#x27;kwargs=&#x27;&lt;/span&gt;, kwargs)&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;... &lt;br/&gt;&lt;span&gt;5&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; fun(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, A=&lt;span&gt;&#x27;a&#x27;&lt;/span&gt;, B=&lt;span&gt;&#x27;b&#x27;&lt;/span&gt;, C=&lt;span&gt;&#x27;c&#x27;&lt;/span&gt;, D=&lt;span&gt;&#x27;d&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;args= (&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;kwargs= {&lt;span&gt;&#x27;A&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;a&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;B&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;b&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;C&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;c&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;D&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;d&#x27;&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;*args 的使用&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;fun&lt;/span&gt;&lt;span&gt;(name, *args)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;...     print(&lt;span&gt;&#x27;你好:&#x27;&lt;/span&gt;, name)&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;...     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; args:&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;...         print(&lt;span&gt;&quot;你的宠物有:&quot;&lt;/span&gt;, i)&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;... &lt;br/&gt;&lt;span&gt;6&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; fun(&lt;span&gt;&quot;Geek&quot;&lt;/span&gt;, &lt;span&gt;&quot;dog&quot;&lt;/span&gt;, &lt;span&gt;&quot;cat&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;你好: Geek&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;你的宠物有: dog&lt;br/&gt;&lt;span&gt;9&lt;/span&gt;你的宠物有: cat&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;**kwargs 的使用&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;fun&lt;/span&gt;&lt;span&gt;(**kwargs)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;...     &lt;span&gt;for&lt;/span&gt; key, value &lt;span&gt;in&lt;/span&gt; kwargs.items():&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;...         print(&lt;span&gt;&quot;{0} 喜欢 {1}&quot;&lt;/span&gt;.format(key, value))&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;... &lt;br/&gt;&lt;span&gt;5&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; fun(Geek=&lt;span&gt;&quot;cat&quot;&lt;/span&gt;, cat=&lt;span&gt;&quot;box&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;Geek 喜欢 cat&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;cat 喜欢 box&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、函数实参&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如果函数的形参是定长参数，也可以使用 *args 和 **kwargs 调用函数，类似对元组和字典进行解引用：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;fun&lt;/span&gt;&lt;span&gt;(data1, data2, data3)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;...     print(&lt;span&gt;&quot;data1: &quot;&lt;/span&gt;, data1)&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;...     print(&lt;span&gt;&quot;data2: &quot;&lt;/span&gt;, data2)&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;...     print(&lt;span&gt;&quot;data3: &quot;&lt;/span&gt;, data3)&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;... &lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; args = (&lt;span&gt;&quot;one&quot;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;)&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; fun(*args)&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;data1:  one&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;data2:  &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;data3:  &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; kwargs = {&lt;span&gt;&quot;data3&quot;&lt;/span&gt;: &lt;span&gt;&quot;one&quot;&lt;/span&gt;, &lt;span&gt;&quot;data2&quot;&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;data1&quot;&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;}&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; fun(**kwargs)&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;data1:  &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;data2:  &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;data3:  one&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;4、序列解包&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;序列解包 往期博客有写过，这里只列出一个例子，序列解包没有 **。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; a, b, *c = &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; a  &lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; b  &lt;br/&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;6&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; c  &lt;br/&gt;&lt;span&gt;7&lt;/span&gt;[&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;文章引用来源：CSDN 博客平台  &lt;/span&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;93761&quot;&gt;&lt;section hm_fix=&quot;350:260&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.5689655172413792&quot; data-type=&quot;gif&quot; data-w=&quot;116&quot; data-width=&quot;100%&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/wzyc1ToJM6gmdOtlOP6aVquJL3WXvZzVibasgniamwNg8oibW1XNbxzprdiaEMOhxK7zpyFbbF2FRG8J9X1xcTxasQ/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;89197&quot;&gt;&lt;section hm_fix=&quot;395:444&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;老王说编程&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;分享编程技术、还原编程思想&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-role=&quot;width&quot;&gt;&lt;img border=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;109&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;109&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;394&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wzyc1ToJM6gmdOtlOP6aVquJL3WXvZzVmMjhUibbjhVM8lkv19nnYHC9UibfFMfzfx7HfiaG9m7Q3tQDYHw7c5FdA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Java|Python|Linux|编程趣事&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;加个鸡腿🍗&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f7431819315c8e54c3b8239adce13826</guid>
<title>总在不轻易间就留了个频繁 GC 的坑</title>
<link>https://toutiao.io/k/pkg9mj6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近有写一些关于 prometheus 监控的文章，也是在实践这块的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天分享一个在实践过程中遇到的问题，也许你也遇到过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对 RPC 服务做埋点的时候，想知道下面这些指标：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会有下面的代码进行指标的暴露：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Counter.builder(&quot;dubbo.request.total&quot;).description(&quot;请求数量&quot;)&lt;br/&gt;        .tags(Tags.of(apiTag, typeTag, originApplicationTag, originApiTag))&lt;br/&gt;        .register(meterRegistry).increment();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;apiTag：比说 OrderService.createOrder&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;typeTag：success, error, timeout 等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;originApplicationTag: 来源的服务名称，比如 goods-service&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;originApiTag：来源的 API 信息，比如 GET:goods/1001&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在程序中会通过/actuator/prometheus 进行数据的暴露，格式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dubbo_request_total{api=&quot;GoodsRemoteService.get(int)&quot;,originApplication=&quot;order-service&quot;,originApi=&quot;order/1001&quot;,type=&quot;success&quot;,} 59.0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dubbo_request_total 这个指标会产生 N 条，N 的决定因素就是 dubbo_request_total 中这些 tag 值的重复度，也就是完全一样的数据只有一条，如果有一个 tag 不一样，就会新产生一条数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上线后没多久，就收到了频繁 GC 的告警。然后排查下来发现指标数据已经堆积了很多。根本原因在 originApi，因为接口是 Restful 风格的资源形式，所以一个接口会产生 N 条数据，比如 order/1001, order/1002 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时间越来越长，被访问的数据范围也就越大，内存中堆积的数据也就越多，然后就出问题了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Restful 风格的资源形式在其他的场景中也经常会遇到，比如用 Sentinel 限流的时候也是一样，在后台也是会显示很多资源，也得做格式化才行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;关于作者&lt;/strong&gt;：尹吉欢，简单的技术爱好者，《Spring Cloud 微服务-全栈技术与案例解析》, 《Spring Cloud 微服务 入门 实战与进阶》作者, 公众号&lt;strong&gt;猿天地&lt;/strong&gt;发起人。&lt;/p&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;pre data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(167, 167, 167)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(63, 63, 63)&quot; data-style=&quot;letter-spacing: 0.544px; font-size: 16px; color: rgb(63, 63, 63); word-spacing: 1px; line-height: inherit;&quot; class=&quot;js_darkmode__91&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;后台回复 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;学习资料&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;span&gt;领取学习视频&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-mpa-template-id=&quot;112&quot; data-mpa-category=&quot;quote&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.511002444987775&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39zWmaics1nAAwT4NCD77uDcf6vcXE1DAHybibTY0V3XDmf4YX1q9qYibIwz9xmRVTkEvTjP87gaKEZrQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;818&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如有收获，点个在看，诚挚感谢&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;我不差钱啊&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>