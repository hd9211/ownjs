<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>55fd8c50bb32a0bcb471ff3c048ce0e4</guid>
<title>解读 Go 语言的 2020：变革前夜</title>
<link>https://toutiao.io/k/ifhix9t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;作者 | 郝林&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;策划 | 张晓楠&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;本文是 InfoQ“解读 2020”年终技术盘点系列文章之一。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在作者去年年底撰写《解读 Go 语言的 2019》的时候，绝没有想到 2020 年将会如此的不平凡。全球范围内的疫情在大大地限制了人们和企业的对外活动之余，还带来了一个副作用，即：线下活动向线上的迅速迁移。&lt;/p&gt;&lt;p&gt;实际上，对于这种迁移，我们国内的民营企业和事业单位早就在做了，只不过在 2020 年之前还没有这么急迫。不知道你发现了没有，在 2020 这一年，那些已经存在的远程办公、视频会议、在线医疗、在线教育等方面的基础设施和应用程序给予了我们莫大的支撑。即便说它们辅助保障了社会的正常运转，也不为过。&lt;/p&gt;&lt;p&gt;目前来看，全球的疫情还会存在一段时间。虽然这个事件本身绝对不值得高兴，但是反过来想，这会倒逼国内数字经济的大踏步前进，甚至飞跃。&lt;/p&gt;&lt;p&gt;从基础层面讲，数字经济的发展必须要有半导体等高精尖领域的强力支持。而从应用层面说，数字经济将会依托于云计算、大数据和人工智能。更具体地说，云计算是高级的基础设施，大数据和人工智能是建立在云计算之上的高级应用。Go 语言，早已霸占了云计算的大半个江山，今后它也将在大数据和人工智能方面发挥重要作用。&lt;/p&gt;&lt;section&gt;&lt;span&gt;趋势纵览&lt;/span&gt;&lt;/section&gt;&lt;p&gt;下面，我们依旧先从整体趋势上看看 Go 语言在今年的发展。&lt;/p&gt;&lt;p&gt;在全球范围内，从 2010 年的集体追新，到之后几年内的理性对待，再到 2016 年、2017 年的“第二春”，直至 2018 年的升降大反差和 2020 年的新反弹。Go 语言可谓是经历了诸多风风雨雨，持续地在各种好评和诟病之间砥砺前行，既得意过也失意过。&lt;/p&gt;&lt;p&gt;下图展现了 TIOBE Index（著名编程语言排行榜）对 Go 语言使用情况的最新统计。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7939814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VOUYicyDDGqfGoPMcprNYFsOgRibInPBSgF0kSFLzTCQx3oC0nRadBxdviau0GsYLR8VndibebZm5FCjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1728&quot;/&gt;&lt;span&gt;图 1 - TIOBE Index 之 Go 语言（2020 年 12 月）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9030470914127424&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VOUYicyDDGqfGoPMcprNYFsO1zEsfwrIJZHRecAsq6AgrC3zyOJZZiaIc3q5BX1tJokOpZtA5f1ALxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1444&quot;/&gt;&lt;span&gt;图 2 - TIOBE Index（2020 年 12 月）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我们从上面这两幅图中可以看出， Go 语言在今年的排名又有了大幅的提升。作者个人认为，这与 go mod 工具的转正和推广，以及“泛型”实现的排期确定是分不开的。&lt;/p&gt;&lt;p&gt;同时，据 StackOverflow（全球最大的编程社区和问答网站）在前不久发布的一份开发者生存报告显示，Go 语言在 2020 年是继 Python、Java、C++ 和 C 之后、排名第五的通用型、全平台编程语言。如果把脚本语言和标记语言都算在内的话，它的总排名是第 12 名。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7207977207977208&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VOUYicyDDGqfGoPMcprNYFsOGR4xZqhibrhm7WEBeZHXvh4ibvlUDRX8ZC4nIaTvaehQEicibF36kLa62A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2106&quot;/&gt;&lt;span&gt;图 3 - Stack Overflow Servey 2020 - The Most Popular Languages&lt;/span&gt;&lt;/p&gt;&lt;p&gt;不但如此，Go 语言在“最喜爱”和“最需要”的编程语言排行中也名列前茅。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5470249520153551&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VOUYicyDDGqfGoPMcprNYFsOyUPQtUM8MVLVsGklEdvnotbQsoGoX8NnXxlcSuNArGw961Zv1DUrTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2084&quot;/&gt;&lt;span&gt;图 4 - Stack Overflow Servey 2020 - The Most Loved Languages&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6045142296368989&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VOUYicyDDGqfGoPMcprNYFsOx6LqibAtb4LlDCZ7B6OichSJdbRDqAIg3F4ezMbVeq7I7XqiaUHBFAibNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2038&quot;/&gt;&lt;span&gt;图 5 - Stack Overflow Servey 2020 - The Most Wanted Languages&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我们可以看到，Go 语言不但是开发者们非常喜爱的编程语言之一（“最喜爱”排行榜第五名），而且从实际应用的角度看，大家也是非常需要它的（“最需要”排行榜第三名）。作者认为，正因为 Go 语言有着崇尚简约和实用主义的编程哲学，广大软件工程师才会如此地爱用它。&lt;/p&gt;&lt;p&gt;更重要的是，Go 软件工程师的薪资待遇也是相当不错的。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.671455938697318&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VOUYicyDDGqfGoPMcprNYFsO9fvTYC2WbP5uSefoKMElvkX4HDibbSiaYGHKcDpWoyiaXSX1Q6w2wYlnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2088&quot;/&gt;&lt;span&gt;图 6 - Stack Overflow Servey 2020 - The Highest Salaries&lt;/span&gt;&lt;/p&gt;&lt;p&gt;你可能会奇怪，为什么 Perl 程序员的薪资排在了第一位？这可能是因为物以稀为贵，Perl 程序员在当代已经非常少见了。而在当今很热门的通用型编程语言中，从薪资角度来看，Scala 语言、Go 语言和 Rust 语言都有着相当大的优势。&lt;/p&gt;&lt;p&gt;当然了，这是在全球范围内的情况，并且参与这份调查的中国开发者并不多。很可惜，作者没能找出一份公认且权威的国内开发者调查报告。&lt;/p&gt;&lt;p&gt;不过，从作者的亲身经历来看，Go 语言在国内恐怕并不亚于国际上的热度，甚至还要更火热一些。&lt;/p&gt;&lt;p&gt;作者这两年一直在断断续续地帮助一些互联网企业招聘 Go 软件工程师。除了作为老一代霸主的 BAT（百度、阿里巴巴、腾讯）以及作为新一代翘楚的 TMD（今日头条、美团、滴滴）之外，还有很多知名的互联网公司都在招聘掌握 Go 语言的开发工程师和系统运维人员。像 PingCAP、七牛、哔哩哔哩、探探、Grab 这些公司，在很早以前就混迹于 Go 语言圈子了。而在最近几年才进入 Go 语言圈子的知名公司还有华为、小米、映客、云智联、轻松筹、贝壳网、美菜网、游族网络等等。就连刚开始大红大紫的工业互联网领域，也有不少公司选择 Go 语言作为其主力开发语言之一。比如，积梦智能、必可测等。&lt;/p&gt;&lt;p&gt;这么多的优秀企业，以及活跃在技术社区中的大佬和新秀共同营造出了 Go 语言工程师的供需网络。作者认为，在国内的服务端编程市场，除了 Java 和 PHP，就当属 Go 语言了。&lt;/p&gt;&lt;section&gt;&lt;span&gt;2020 年回顾&lt;/span&gt;&lt;/section&gt;&lt;p&gt;在了解了 Go 语言的发展趋势之后，我们再一起来看看它在 2020 年都有哪些重要的更新。&lt;/p&gt;&lt;section&gt;&lt;span&gt;模块：终于稳定&lt;/span&gt;&lt;/section&gt;&lt;p&gt;自 2020 年 2 月份发布的 1.14 版本起，Go 语言官方就开始正式地推广 go modules 了。这说明它已经完全可以在生成环境中使用了。&lt;/p&gt;&lt;p&gt;如果你是老牌的 Go 工程师的话，那么肯定使用过像 glide、dep、govendor 这类第三方的依赖管理工具。这些工具都非常的优秀，并且在很大程度上解决了我们在项目开发过程中遇到的痛点。&lt;/p&gt;&lt;p&gt;不过，现在是时候迁移到 go modules 了。Go modules 综合了这些第三方工具的优点，并经历了数年的设计和磨合，最终成为了 Go 程序依赖管理的官方工具。&lt;/p&gt;&lt;p&gt;即使现存的项目已经使用了前面提及的某一个依赖管理工具，那么也无需担心。我们只需要在 Go 项目的根目录中运行命令“go mod init &amp;lt;项目主模块的导入路径&amp;gt;”就可以实现自动地迁移。go mod 命令会读取那些已经存在的依赖配置文件，然后在其创建的 go.mod 文件中添加相应的内容。不过在这之后，我们最好再次使用 go build 命令构建一下项目并运行相应的单元测试，以确保一切正常。&lt;/p&gt;&lt;p&gt;还记得系统环境变量 GOPATH 吗？现在的 go 命令会自动地把项目所需的依赖包下载到它指向的第一个工作区目录中的 pkg/mod 子目录里。这里有一点需要注意，如果我们的项目中存在处于顶层的 vendor 目录，那么 go 命令将会优先在该目录中查找对应的依赖包。&lt;/p&gt;&lt;p&gt;如果我们使用的是 Go 语言的 1.15 版本，那么也可以通过设置系统环境变量 GOMODCACHE 来自定义上述存储依赖包的目录。这实际上是为以后彻底废弃 GOPATH 埋下的一个伏笔。&lt;/p&gt;&lt;p&gt;另外，执行一下 go mod tidy 命令也是一个很好的主意。这个命令会对 go modules 的依赖配置文件进行整理，添加那些实际在用的依赖项，并去除那些未用的依赖项。换句话说，它会确保项目的依赖配置文件与项目源码的实际依赖相对应。&lt;/p&gt;&lt;p&gt;Go 语言的大多数标准命令都得到了不同程度的改进以更加适配 go modules，包括一些标记（flag）的调整和一些行为上的优化。比如，go get 命令在默认情况下不再会去更新非兼容版本的依赖库。不兼容的依赖库更新常常会让我们很恼火，但现在不会再出现这种情况了。&lt;/p&gt;&lt;section&gt;&lt;span&gt;环境变量：跟进的调整&lt;/span&gt;&lt;/section&gt;&lt;p&gt;Go 语言可识别的系统环境变量 GO111MODULE 在 1.14 和 1.15 版本中的默认值都是 auto。这意味着，go 命令仅在当前目录或上层目录中存在 go.mod 文件的情况下才会以 go modules 的方式运行，否则它就会退回到之前以 GOPATH 为中心的运行方式。不过，预计在明年发布的 1.16 版本中，Go 语言将会把这个环境变量的默认值设置为 on。也就是说，到了那时，GOPATH 这一古老但能勾起我们满满回忆的东西终于要默默地退出了。&lt;/p&gt;&lt;p&gt;另外，我们现在可以在系统环境变量 GOPROXY 的值中使用管道符“｜”了。在这之前，GOPROXY 的值中只能出现分隔符“，”。如果一个代理 URL 跟在了分隔符后面，那么只有在前一个代理 URL 指向的服务器返回 404 或 401 错误时，go 命令才会尝试使用当前的代理 URL。现在，如果一个代理 URL 跟在了管道符后面，那么只要在访问前一个服务器时发生了（任何的）错误，go 命令就会马上使用当前的代理 URL。换句话说，新的管道符让我们多了一种容错的选择，即范围更广的容错。合理使用它，可以让我们更快地从可用的代理那里下载到所需的代码包。&lt;/p&gt;&lt;p&gt;顺便说一下，我们现在有了一个新的系统环境变量 GOINSECURE。这个环境变量的存在单纯是为了让我们能够从非 HTTPS 的代码包服务器上下载依赖包（或者模块）。&lt;/p&gt;&lt;p&gt;有关环境变量的更多细节，我就不在这里说了。大家如果想了解的话，可以去参看 Go 语言的相关文档。&lt;/p&gt;&lt;section&gt;&lt;span&gt;语言语法：可重叠的接口方法&lt;/span&gt;&lt;/section&gt;&lt;p&gt;我们都知道，Go 语言这些年在语法方面一向很稳定，少有改动，更没有不兼容的变化出现。在 2020 年，Go 语言只做了一项语法改进。这是关于接口声明的，并且完全保证了向后兼容性。我们下面来看一组代码示例。假设，我们有如下两个接口声明：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; MyReader &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    io.ReadCloser&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; MyWriter &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    io.WriteCloser&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;在 Go 1.14 之前，这两个接口是无法内嵌到同一个接口声明中去的。就像这样：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; MyIO &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    MyReader&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    MyWriter&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    io.Closer&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;这会让 Go 语言的编译器报错。报错的原因是：在同一个接口声明中发现了重复的方法声明。更具体地说，Go 语言标准库中的 io.ReadCloser 接口和 io.WriteCloser 接口都包含了一个名为 Close 的方法，而分别内嵌了这两个接口的 MyReader 和 MyWriter 又已经嵌入到了接口 MyIO 之中。这导致 MyIO 接口里现在存在两个 Close 方法的声明。所以，MyIO 的声明是无效的，并且无法通过编译。&lt;/p&gt;&lt;p&gt;这看上去是合规的，但却不一定合理。因为在很多情况下，我们想做的只是把多个接口合并在一起，而不在乎方法声明是否有重叠。我们一般认为，如果有重叠的方法，那么就当作一个就好了。很可惜，之前的 Go 语言并不这么认为。更重要的是，对于像上面那样深层次的接口内嵌问题，我们排查和解决起来都会很麻烦。有时候，这还会涉及到第三方库。&lt;/p&gt;&lt;p&gt;值得庆幸的是，自 Go 1.14 开始，我们的这个合理诉求终于得到了满足。Go 语言的语法已经认可了上述情况。这将给我们的接口整合工作带来极大的便利。&lt;/p&gt;&lt;p&gt;不过请注意，Go 语言只接受在同一个接口声明中完全重叠的多个方法声明。换句话说，只有这些方法声明在名称和签名上完全一致，它们才能够合而为一。别忘了，接口中方法的签名包括了参数列表和结果列表。如果仅名称相同但签名不同，那么 Go 语言编译器照样会报错。例如：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; MyIO &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    MyReader&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    MyWriter&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Close()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;由于这里最后面的方法声明 Close() 与接口 io.ReadCloser 和 io.WriteCloser 中的方法声明 Close() error 不完全一致（请注意结果声明上的差异），所以 Go 语言仍然会报出错误“duplicate method Close”，并使得程序编译不通过。&lt;/p&gt;&lt;section&gt;&lt;span&gt;运行时内部：性能提升&lt;/span&gt;&lt;/section&gt;&lt;p&gt;Go 语言每次的版本更新都会包含针对其运行时系统的性能提升。在 2020 年的优化中，有几点值得我们注意：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;goroutine 真正实现了异步的抢占。也就是说，现在即使是不包含任何函数调用的 for 循环也绝不会引起程序的死锁和垃圾回收的延误了。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;defer 语句的执行效率又得到了进一步的提升，额外的开销已几乎为零。所以，我们已经完全可以将 defer 语句用在对性能有严苛要求的应用场景中了。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;运行时系统内部的内存分配器获得了改进。这使得在系统环境变量 GOMAXPROCS 有较高数值的情况下，内存的申请效率会得到大幅的提升。这间接地让运行时系统的整体性能明显提高。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;除了以上这些，Go 语言运行时系统还有一些比较小的改进，比如：panic 函数已经可以正确地打印出我们传入的参数值当中的各种数值了、在将较小的整数值转换为接口值的过程中不再会引起内存分配、针对通道的非阻塞接收操作得到了进一步的优化，等等。&lt;/p&gt;&lt;section&gt;&lt;span&gt;并发编程：一些微调&lt;/span&gt;&lt;/section&gt;&lt;p&gt;我们都知道，runtime.Goexit 函数在被调用之后会中止当前的 goroutine 的运行。然而，在嵌套的 panic/recover 处理流程中，程序对它的调用会被忽略掉。虽然这种应用场景非常少见，但终归是一个问题。幸好自 Go 1.14 开始，这个问题被彻底地解决了。&lt;/p&gt;&lt;p&gt;还要注意，如果 runtime.Goexit 函数被主 goroutine 中的代码调用了，那么它并不会终止整个 Go 程序的运行，而只会中止主 goroutine 而已。在这种情况下，其他的 goroutine 会继续运行。如果，在这之后，这些其他的 goroutine 都运行完毕了，那么程序就会崩溃。所以说，我们千万不要在主 goroutine 中调用 runtime.Goexit 函数。&lt;/p&gt;&lt;p&gt;在同步工具方面，现在的 Go 运行时系统会更加关注那些竞争非常激烈的互斥锁。一旦这样的锁被解锁，系统会立即安排 CPU 去运行正在等待该锁的下一个 goroutine（也就是说，它会跳过调度的过程）。这显然可以大大提高此类场景下的互斥锁性能。&lt;/p&gt;&lt;p&gt;并发安全字典 sync.Map 有了一个新方法 LoadAndDelete。从方法名上我们也可以看得出来，这个方法能够在获取某个元素值的同时把它从字典中删除掉。更重要的是，Go 语言会保证这个“获取 + 删除”的操作的原子性。另外，该方法返回的第二个结果值会告知我们，字典先前是否包含与我们传入的健值（key）对应的元素值（element）。如果不包含，那么它返回的第一个结果值就会是 nil。&lt;/p&gt;&lt;p&gt;再来说 context.Context。虽然它并不在 sync 代码包中，但是我们常常用它来做上下文的同步。因此，它也算是一个很重要的同步工具。关于它的调整很简单也很明确，那就是：不再允许使用 nil 作为父级的上下文来创建衍生的 Context 实例了。这一要求显然是合理的，因为所谓的衍生 Context 就应该有实实在在的父级。然而，在 Go 1.15 之前，并没有专门的防卫语句来对此进行前置检查。此项改进涉及到了 context 包中的几个重要函数，如 WithCancel、WithDeadline、WithTimeout 和 WithValue。现在，如果我们传给这些方法的第一个参数值是 nil，那么它们都将会立即抛出包含了对应错误信息的 panic。&lt;/p&gt;&lt;section&gt;&lt;span&gt;标准库：新的散列算法包&lt;/span&gt;&lt;/section&gt;&lt;p&gt;标准库中多了一个新的代码包：hash/maphash。这是一个通用的散列算法包，可以将任意的字节序列或者字符串散列成 64 位的整数。从名字上我们也可以看出，它能够帮助我们实现那些基于散列表的数据结构。该包中的 Hash 类型的基本行为如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;此 Hash 类型是开箱即用的。也就是说，我们在实例化它的时候无需额外的初始化工作，仅创建一个它的零值即可使用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不同的 Hash 实例在默认的情况下会有不同的默认种子。因此，这些默认实例为同一个对象计算出的散列值将会不同。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Hash 实例允许手动设置种子（必须由 MakeSeed 函数产生）。在单一进程中，只要种子相同，Hash 实例为同一个对象计算出的散列值就会相同。不论进行计算的 Hash 实例是一个还是多个，都会如此。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;被计算的对象的表现形式可以是字节序列，也可以是字符串。只要内容一致，不论它们是以怎样的方式写入 Hash 实例的，计算出的散列值都会相同（大前提是进程和种子都相同）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Hash 实例可以被重置。此操作会清空已写入当前 Hash 实例的内容，但并不会改变当前的种子。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;总之，hash/maphash.Hash 类型代表着一种基于种子的、可重用、可重置、稳定、通用的散列算法。这种算法的优势是可以有效地避免散列冲突，但它并不是加密安全的。如果你的关注点是加密安全，那么可以考虑使用标准库 crypto 包中的算法包，如 md5、sha256、sha512 等。&lt;/p&gt;&lt;section&gt;&lt;span&gt;单元测试：资源清理&lt;/span&gt;&lt;/section&gt;&lt;p&gt;今年，Go 语言还在单元测试方面做了一些改进。&lt;/p&gt;&lt;p&gt;作者认为最实用的一项改进当属 Cleanup 方法的增加。更具体地说，现在 testing.T 类型和 testing.B 类型都有了这个方法。该方法接受一个函数作为其参数值。我们的测试代码可以多次调用 Cleanup 方法，以传入多个函数。这些函数都会被记录在测试程序的内部。当测试即将结束的时候，这些函数就会被一一调用，且越晚传入的函数会越先被调用。&lt;/p&gt;&lt;p&gt;虽然 Cleanup 方法的文档中并没有规定这些被传入的函数应该做什么。但正如其名，它们最应该做的是清理在测试运行的过程中用到的各种资源。&lt;/p&gt;&lt;p&gt;另外，testing.T 类型和 testing.B 类型还各自多了一个名为 TempDir 的方法。这个方法会返回一个临时目录的路径。这样的临时目录是专门为当前的测试实例创建的。并且，这些目录会在测试即将结束的时候被自动地删除掉。因此，我们可以在测试的过程中根据实际需要在这样的目录下创建一些临时的文件，以帮助测试更好的进行。&lt;/p&gt;&lt;section&gt;&lt;span&gt;时区信息：独立性增强&lt;/span&gt;&lt;/section&gt;&lt;p&gt;Go 1.15 包含了一个新的代码包 time/tzdata。该包允许将时区数据库嵌入到 Go 程序当中。当我们在程序中添加导入语句（即 import _ &quot;time/tzdata&quot;）之后，即使本地系统里不存在时区数据库，当前程序也完全可以正确地查询到时区信息。另外，我们还可以通过在构建程序时追加 -tags timetzdata 来嵌入时区数据库。当然了，天下没有免费的午餐。这两种方法都会使 Go 程序的大小增加大约 800 KB（预计在 Go 1.16 中会降低到 350 KB）。&lt;/p&gt;&lt;section&gt;&lt;span&gt;明年的展望&lt;/span&gt;&lt;/section&gt;&lt;p&gt;目前，可以明确的是，Go 语言明年肯定不会有泛型和新的错误处理机制。如果不出意外的话，范型应该会在 2022 年发布的 1.18 版本中出现。而有些可惜的是，错误处理方面的变革可能要等到 Go 2 发布的时候才能够真正的实现。&lt;/p&gt;&lt;p&gt;关于 Go 语言的泛型，大家可以参看 Ian Lance Taylor 和 Robert Griesemer 在 2020 年 11 月 25 日发布的最新设计草案。而对于新的错误处理机制，大家可以去看 Go 2 设计草案中“Error handling”部分。作者就不在这里多说了。&lt;/p&gt;&lt;p&gt;我们下面来看看，将要在 2021 年 2 月发布的 Go 1.16 预计会包括哪些重要的更新。由于 1.16 版本目前还在开发当中，因此以下所讲的内容不一定就是最终的实现。&lt;/p&gt;&lt;section&gt;&lt;span&gt;端口：支持新的组合&lt;/span&gt;&lt;/section&gt;&lt;p&gt;大家都知道，苹果公司已经发布了他们自己研发的 CPU，并且已经应用在了自家的入门级电脑当中。然而，很多在 macOS 操作系统上运行的软件却还没有准备好。Go 语言也在其列。&lt;/p&gt;&lt;p&gt;不过，Go 语言打算从 1.16 版本开始支持这种新的“计算架构 + 操作系统”组合，代号为“darwin/arm64”。请注意，在当下的 Go 语言之中其实已经存在了“darwin/arm64”，只不过现在这个代号实际上对应的是“ARM 处理器 +iOS 操作系统”。为了避免混淆，之前的“darwin/arm64”将更名为“ios/arm64”，而 “darwin/arm64”之后将对应于“ARM 处理器 +macOS 操作系统”。&lt;/p&gt;&lt;section&gt;&lt;span&gt;模块与工具：GOPATH 即将下岗&lt;/span&gt;&lt;/section&gt;&lt;p&gt;我们在前文说过，Go 语言预计在 1.16 版本将系统环境变量 GO111MODULE 的默认值改为 on。这就意味着，GOPATH 以及以它为中心的程序存储和构建方式终于要向我们挥手告别了。不过，若我们还想让 go 命令以之前的方式运行，那么还可以把该环境变量的值改成 auto。按照惯例，本文作者估计这个环境变量还会再在 Go 语言中留存 1 或 2 个版本。&lt;/p&gt;&lt;p&gt;与之相应的，Go 语言自带的各种标准工具会彻底地站在 go modules 一方。&lt;/p&gt;&lt;p&gt;命令 go install 将会支持安装指定版本号的代码包。更具体地说，我们在输入命令的时候可以这样：“go install golibhub.com/mylib@v1.2.1 ”。在这种情况下，go 命令将会忽略掉相关 go.mod 文件中的 mylib 包条目，即使那里配置的版本号与命令参数中的不同也会如此。顺便说一下，Go 语言官方将会在之后的某个版本中改变 go get 命令的行为，使它只负责下载代码包，而不再自动地进行代码包的构建和安装。也就是说，这个“构建 + 安装”的动作将只由 go install 命令负责。&lt;/p&gt;&lt;p&gt;另外，go build 命令和 go test 命令将不会再对 go.mod 文件进行任何的修改。对它们来说，go.mod 文件将会是只读的。一个相应的行为是，如果这两个命令在执行的过程中发现需要对依赖配置文件进行修改（或者说有必要调整依赖包的配置信息），那么它们将会立即报错。这与之前在输入命令时追加标记 -mod=readonly 的行为是一致的。这时，我们可以使用命令 go mod tidy 或 go get 来做相应的调整。&lt;/p&gt;&lt;section&gt;&lt;span&gt;运行时 API：监测的增强&lt;/span&gt;&lt;/section&gt;&lt;p&gt;在 Go 1.16 中，将会出现一个新的用于运行时度量的代码包 runtime/metrics。该代码包旨在引入一种稳定的度量接口，用于从 Go 运行时系统中读取相应的指标数据。它在功能上会取代现有的诸如 runtime.ReadMemStats、debug.GCStats 等 API，并且会更加的通用和高效。&lt;/p&gt;&lt;p&gt;另外，系统环境变量 GODEBUG 将可以接受一个新的选项“inittrace”。当该环境变量的值中包含“inittrace=1”的时候，Go 运行时系统会输出有关于 init 函数的监测信息。其中会包含对应函数的执行时间和内存分配情况。这将非常有利于我们观察各个代码包在初始化方面的性能。&lt;/p&gt;&lt;section&gt;&lt;span&gt;标准库：新的嵌入包&lt;/span&gt;&lt;/section&gt;&lt;p&gt;Go 1.16 的标准库中将会出现一个新的代码包 embed。这个包的主要作用是让 go 命令在编译程序的时候向其嵌入指定的外部文件。至于嵌入什么文件，需要我们通过注释指令 //go:embed 来指定，如：//go:embed hello.txt 。请注意，在包含了这个注释指令的源码文件中必须要有针对 embed 包的导入语句，如：import &quot;embed&quot; 。&lt;/p&gt;&lt;p&gt;同时，这样的注释指令必须紧挨在单一变量声明语句的上方，且该变量的类型必须是 string、[]byte 或 embed.FS。这样的话，Go 语言就会自动地把我们指定的文件的内容转化为相应的值，并赋给这个变量。&lt;/p&gt;&lt;p&gt;在 //go:embed 的右边，我们可以用空格来分割多个文件路径，或者通过添加多个这样的注释指令来分别指定多个文件。文件的路径可以是相对的，也可以是绝对的。&lt;/p&gt;&lt;p&gt;另外，这里的文件路径还可以包含通配符，如：//go:embed image/&lt;span&gt;template/&lt;/span&gt;。具体有哪些通配符可用，大家可以去参看 path.Match 函数的文档。&lt;/p&gt;&lt;p&gt;一定要注意，如果需要嵌入多个文件，那么我们就必须把变量的类型声明为 embed.FS。这主要是因为，只有这个类型才能把多个嵌入文件的内容区分开来。通过该类型的方法（Open、ReadDir 和 ReadFile），我们还可以分别拿到代表了某个文件或目录的实体，或者读取其中任何文件的内容。&lt;/p&gt;&lt;p&gt;究其原因，结构体类型 embed.FS 的实例可以代表一个树形的文件系统。也就是说，它可以用来表示一个拥有多个层级的文件目录。另外，embed.FS 类型是 io/fs.FS 接口的一个实现，因此它的实例可以被应用在很多理解统一文件系统的 API 之上。这些 API 散落在 net/http、text/template、html/template 等代码包之中。&lt;/p&gt;&lt;p&gt;请想象一下，如果我们在开发一个带有 Web 页面和静态资源的软件系统，那么这将会给我们带来多么大的便利。让单个的可执行文件包含所有的程序和资源将变为可能。&lt;/p&gt;&lt;section&gt;&lt;span&gt;标准库：新的文件系统包&lt;/span&gt;&lt;/section&gt;&lt;p&gt;代码包 io/fs 代表了一种全新的文件系统模型。它可以对应于任意（已支持的）操作系统中的文件系统，但并不局限于此。该包中的核心就是我们已经在前面提及的 FS 接口，以及还未讲到的 File 接口。&lt;/p&gt;&lt;p&gt;简单来说，FS 接口代表了一个文件系统抽象的最小实现要求。其中只有一个方法声明：Open(name string) (File, error) 。而 File 接口则代表了可以在单个文件上进行的一系列操作。请看下面这幅图。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5633732534930139&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VOUYicyDDGqfGoPMcprNYFsOMOgicy3Zvmtic9ibICmMEic4OaKYcugKRoUVJzE2UHKvhYzrxBBVUcEDcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2004&quot;/&gt;&lt;span&gt;图 7 - io/fs 包中的接口&lt;/span&gt;&lt;/p&gt;&lt;p&gt;到目前为止，这个代码包中的接口共有 10 个。其他的大部分接口都会内嵌 FS 接口或 File 接口。也就是说，它们都属于核心接口的扩展。虽然从声明上看 DirEntry 接口和 FileInfo 接口是独立的，但它们都被多个其他的接口所引用。&lt;/p&gt;&lt;p&gt;在仔细阅读上图或者该包的源码之后，你一定会发现，这个模型所代表的文件系统是只读的。也就是说，其中并没有表示“写操作”的方法。&lt;/p&gt;&lt;p&gt;正因为这个模型可以用来表示任何树形结构的资源系统，所以作为统一的模型，它只提供了最基础的抽象。要知道，有的资源系统就是只能读、不能写的。比如，我们前面说过的嵌入 Go 程序的外部文件和目录就必须是只读的。也就是说，它们在嵌入程序之后就不应该再被改变了。&lt;/p&gt;&lt;p&gt;为了适配这个模型，Go 语言标准库中的不少代码包都做了相应的调整，比如：os 包、net/http 包、archive/zip 包，以及 html/template 包和 text/template 包。&lt;/p&gt;&lt;p&gt;这里有一些更具体的例子：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;embed.FS 类型用于表示嵌入的文件或目录。它实现了 io/fs 包中的 FS 接口、ReadDirFS 接口和 ReadFileFS 接口；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;新的 os.DirFS 函数可以提供由当前的操作系统支持的 io/fs.FS 接口实现；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;新的 http.FS 函数和 http.FileServer 函数可以把 io/fs.FS 接口的实例包装成 http.Handler；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;新的 testing/fstest 包专门用于测试相应的文件系统模型，其中还包含了一个基于内存的文件系统抽象 MapFS。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;总之，代码包 io/fs 代表了一个全新的、统一的文件系统（或者说资源系统）的模型。这个模型将会作为很多具体应用的底层框架。另外，io/fs 包在以后可能会得到进一步的拓展，说不定还会发展出一些描述“写操作”的扩展接口。作者也希望如此。&lt;/p&gt;&lt;section&gt;&lt;span&gt;总     结&lt;/span&gt;&lt;/section&gt;&lt;p&gt;好了，我们现在来稍微总结一下。在 2020 年，Go 语言同样做出了很多改变。这包括已经完全稳定的 go modules、环境变量和标准工具的跟进和增强、语法上的一项重要调整——可重叠的接口方法、运行时系统的性能提升、异步编程和同步工具方面的进一步优化，以及新的散列算法包、新的单元测试辅助方法和独立的时区代码包。这些更新表面上看起来可能并不算大，但 Go 语言内部其实已经做了很多的改变。有的改变是完全的，而有的改变是在为以后的目标做铺垫。&lt;/p&gt;&lt;p&gt;我们对 Go 语言有着很多的期望。但是，大饼还是要一口一口的吃。在 2021 年，Go 语言中的 GOPATH 将会正式宣布下岗。同时，Go 语言也会把一些重要的东西统一起来，比如用于运行时度量的代码包 runtime/metrics，以及代表了新的文件系统模型的代码包 io/fs。随着 io/fs 包而来的，还有便于我们将程序和资源整合成一个单独文件的代码包 embed 和注释指令 //go:embed 。另外，作者也非常期待 Go 语言对“ARM+macOS”组合的支持。&lt;/p&gt;&lt;p&gt;目前可以预计，Go 语言的泛型支持将会比新的错误处理机制更早到来。不过，Go 语言官方在保证向后兼容性的情况下已经对现有的错误处理 API 进行了尽可能的改进。更何况，我们还有几个不错的错误处理包可用，如官方的扩展包 golang.org/x/xerrors，以及已经过时间验证的第三方包 github.com/pkg/errors 和 gopkg.in/errgo.v2。所以当前看来，这个问题早已不那么尖锐了。&lt;/p&gt;&lt;p&gt;作者对 Go 语言的发展仍然是非常乐观的，尤其是在“云原生”大行其道的当下。在数据科学方面，七牛云的 CEO 许式伟正在带头创造对标“Python 语言 +Numpy+Pandas”和（MIT 出品的）Julia 语言的新玩意儿——基于 Go 语言的编程语言 Go+。作者对此还是很看好的。不过，据说（Apple 出品的）Swift 语言也将在这一领域继续发力，可能会出现“Swift Number”之类的东西，同样对标基于 Python 语言的数据科学包。作者相信，到了 2021 年下半年或者 2022 年，这里很可能会出现四足鼎立的态势。总之，有竞争才会有突破，基于 Go 语言的生态环境依然不可限量。&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;示例代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;github.com/hyper0x/go2020&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://github.com/hyper0x/go2020&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3086fb0341f3a4167d25f1954cf0ee2a</guid>
<title>挑战 Redis 单实例内存最大极限，“遭遇” NUMA 陷阱</title>
<link>https://toutiao.io/k/4mnda7r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6583333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/BBjAFF4hcwo5CJu7ibqMFwxicMyj0Lgl4MUsyW6Ov1If9qicvya5oQbG9u4J3WpVTKK5hMpno9eV9trpaJ0llHGcA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们公司的基础架构部有个云Redis平台，其中Redis实例在申请的时候可以自由选择需要的内存的大小。然后就引发了我的一个思考，Redis单实例内存最大申请到多大比较合适？假设母机是64GB内存的物理机，如果不考虑CPU资源的的浪费，我是否可以开一个50G的Redis实例？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是我在Google上各种搜索，讨论这个问题的人似乎不多。找到唯一感觉靠谱点的答案，那就是单进程分配的内存最好不要超过一个node里的内存总量，否则linux当该node里的内存分配光了的时候，会在自己node里动用硬盘swap，而不是其它node里申请。这即使所谓的numa陷阱，当Redis进入这种状态后会导致性能急剧下降（不只是redis，所有的内存密集型应用如mysql，mongo等都会有类似问题）。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;看起来这个解释非常有说服力。于是乎，我就想亲手捕捉一次NUMA陷阱，看看这个家伙究竟什么样。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-original-title=&quot;&quot; placeholder=&quot;1&quot; title=&quot;&quot;&gt;1&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;先聊聊QPI与NUMA&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最早在CPU都是单核的时候，用的总线都是FSB总线。经典结构如下图：&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;span&gt;&lt;img data-cropselx1=&quot;1&quot; data-cropselx2=&quot;477&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;208&quot; data-ratio=&quot;0.43487394957983194&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwo5CJu7ibqMFwxicMyj0Lgl4MZuibkPrKMfEwictV0Dv79UiapdoQQ2nKFHhJmuUPMkbDhGZI4t8QHZjlw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/span&gt;&lt;figcaption&gt;&lt;span&gt;图1 单核时代的FSB总线&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;到来后来CPU的开发者们发现CPU的频率已经接近物理极限了，没法再有更大程度的提高了。在2003年的时候，CPU的频率就已经达到2个多GB，甚至3个G了。现在你再来看今天的CPU，基本也还是这个频率，没进步多少。摩尔定律失效了，或者说是向另外一个方向发展了。那就是多核化、多CPU化。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;574&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;225&quot; data-ratio=&quot;0.39316239316239315&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwo5CJu7ibqMFwxicMyj0Lgl4MbZQJOxDfaes5byOiaE2v2FRChLUl7Cn49SqhBiaeMIEloriaxupibLBVLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;585&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2 多核时代的FSB总线&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;刚开始核不多的时候，FSB总线勉强还可以支撑。但是随着CPU越来越多，所有的数据IO都通过这一条总线和内存交换数据，这条FSB就成为了整个计算机系统的瓶颈。举个北京的例子，这就好比进回龙观的京藏高速，刚开始回龙观人口不多的时候，这条高速承载没问题。但是现在回龙观聚集了几十万人了，“总线”还仅有这一条，未免效率太低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CPU的设计者们很快改变了自己的设计，引入了QPI总线，相应的CPU的结构就叫NMUA架构。下图直观理解&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;574&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;108&quot; data-ratio=&quot;0.18722139673105498&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwo5CJu7ibqMFwxicMyj0Lgl4M1gkcicVEhZ5T2IwyVvKuM39dObRgJknjrmxvpG7TQWb6calZbyvnSpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;673&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图3 QPI总线&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2/&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-original-title=&quot;&quot; placeholder=&quot;1&quot; title=&quot;&quot;&gt;2&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;话说NUMA陷阱&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;NUMA陷阱指的是引入QPI总线后，在计算机系统里可能会存在的一个坑。大致的意思就是如果你的机器打开了numa，那么你的内存即使在充足的情况下，也会使用磁盘上的swap，导致性能低下。原因就是NUMA为了高效，会仅仅只从你的当前node里分配内存，只要当前node里用光了（即使其它node还有），也仍然会启用硬盘swap。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;当我第一次听说到这个概念的时候，不禁感叹我运气好，我的Redis实例貌似从来没有掉进这个陷阱里过。那为了以后也别栽坑，赶紧去了解了下我的机器的numa状态：&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# numactl --hardware&lt;/span&gt;&lt;br/&gt;&lt;span&gt;available: 2 nodes (0-1)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;node 0 cpus: 0 1 2 3 4 5 12 13 14 15 16 17&lt;/span&gt;&lt;br/&gt;&lt;span&gt;node 0 size: 32756 MB&lt;/span&gt;&lt;br/&gt;&lt;span&gt;node 0 free: 19642 MB&lt;/span&gt;&lt;br/&gt;&lt;span&gt;node 1 cpus: 6 7 8 9 10 11 18 19 20 21 22 23&lt;/span&gt;&lt;br/&gt;&lt;span&gt;node 1 size: 32768 MB&lt;/span&gt;&lt;br/&gt;&lt;span&gt;node 1 free: 18652 MB&lt;/span&gt;&lt;br/&gt;&lt;span&gt;node distances:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;node   0   1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  0:  10  21&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  1:  21  10&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;上面结果说明我们有两个node，node0和node1，分别有12个核心，各有32GB的内存。 再看zone_reclaim_mode，它用来管理当一个内存区域(zone)内部的内存耗尽时，是从其内部进行内存回收还是可以从其他zone进行回收的选项：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;0 关闭zone_reclaim模式，可以从其他zone或NUMA节点回收内存&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1 打开zone_reclaim模式，这样内存回收只会发生在本地节点内&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2 在本地回收内存时，可以将cache中的脏数据写回硬盘，以回收内存&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4 在本地回收内存时，表示可以用Swap 方式回收内存&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# cat /proc/sys/vm/zone_reclaim_mode&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;额，好吧。我的这台机器上的zone_reclaim_mode还真是1，只会在本地节点回收内存。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-original-title=&quot;&quot; placeholder=&quot;1&quot; title=&quot;&quot;&gt;3&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;实践捕捉numa陷阱未遂&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;那我的好奇心就来了，既然我的单个node节点只有32G，那我部署一个50G的Redis，给它填满数据试试到底会不会发生swap。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;实验开始，我先查看了本地总内存，以及各个node的内存剩余状况。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# top&lt;/span&gt;&lt;br/&gt;&lt;span&gt;......&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Mem:  65961428k total, 26748124k used, 39213304k free,   632832k buffers&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Swap:  8388600k total,        0k used,  8388600k free,  1408376k cached&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# cat /proc/zoneinfo&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  ......&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Node 0, zone   Normal&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  pages free     4651908&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Node 1, zone   Normal&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  pages free     4773314&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;总内存不用解释，&lt;/span&gt;&lt;code&gt;&lt;span&gt;/proc/zoneinfo&lt;/span&gt;&lt;/code&gt;&lt;span&gt;里包含了node可供应用程序申请的free pages。node1有4651908个页面，4651908*4K=18G的可用内存。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;接下来让我们启动redis实例，把其内存上限设置到超过单个node里的内存大小。我这里单node内存大小是32G，我把redis设置成了50G。开始灌入数据。最终数据全部灌完之后，&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# top&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Mem:  65961428k total, 53140400k used, 12821028k free,   637112k buffers&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Swap:  8388600k total,        0k used,  8388600k free,  1072524k cached&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 8356 root      20   0 62.8g  46g 1292 S  0.0 74.5   3:45.34 redis-server&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# cat /proc/zoneinfo | grep &quot;pages free&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  pages free     3935&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  pages free     347180&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  pages free     1402744&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  pages free     1501670&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;实验证明，在zone_reclaim_mode为1的情况下，Redis是平均在两个node里申请节点的，并没有固定在某一个cpu里。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;莫非是大佬们的忠告错了吗？其实不是，如果不绑定亲和性的话，&lt;span&gt;分配内存是当进程在哪个node上的CPU发起内存申请，就优先在哪个node里分配内存&lt;/span&gt;。之所以是平均分配在两个node里，是因为redis-server进程实验中经常会进入主动睡眠状态，醒来后可能CPU就换了。所以基本上，最后看起来内存是平均分配的。如下图，CPU进行了500万次的上下文切换，用top命令看到cpu也是在node0和node1跳来跳去。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# grep ctxt /proc/8356/status&lt;/span&gt;&lt;br/&gt;&lt;span&gt;voluntary_ctxt_switches:        5259503&lt;/span&gt;&lt;br/&gt;&lt;span&gt;nonvoluntary_ctxt_switches:     1449&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2/&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-original-title=&quot;&quot; placeholder=&quot;1&quot; title=&quot;&quot;&gt;4&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;绑定亲和性，成功捕获NUMA陷阱&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;杀死进程，内存归位&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# cat /proc/zoneinfo&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Node 0, zone   Normal&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  pages free     7597369&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Node 1, zone   Normal&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  pages free     7686732&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;绑定CPU和内存的亲和性，然后再启动。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;numactl --cpunodebind=0 --membind=0 /search/odin/daemon/redis/bin/redis-server /search/odin/daemon/redis/conf/redis.conf&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;top命令观察到CPU确实一直在node0的节点里。node里的内存也在快速消耗。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# cat /proc/zoneinfo&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Node 0, zone   Normal&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  pages free     10697&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Node 1, zone   Normal&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  pages free     7686732&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;看，内存很快就消耗光了。我们再看top命令观察到的swap，很激动地发现，我终于陷入到传说中的numa陷阱了。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;Tasks: 603 total,   2 running, 601 sleeping,   0 stopped,   0 zombie&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Cpu(s):  0.7%us,  5.4%sy,  0.0%ni, 85.6%id,  8.2%wa,  0.0%hi,  0.1%si,  0.0%st&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Mem:  65961428k total, 34530000k used, 31431428k free,   319156k buffers&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Swap:  8388600k total,  6000792k used,  2387808k free,   777584k cached&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  258 root      20   0     0    0    0 R 72.3  0.0   0:17.18 kswapd0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;25934 root      20   0 37.5g  30g 1224 D 71.6 48.7   1:06.09 redis-server&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这时候，Redis实际使用的物理内存RES定格到了30g不再上涨，而是开始消耗Swap。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;又过了一会儿，Redis被oom给kill了。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-original-title=&quot;&quot; placeholder=&quot;1&quot; title=&quot;&quot;&gt;5&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;结论&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;通过今天的实验，我们可以发现确实有NUMA陷阱这种东西存在。不过那是我手工通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;numactl&lt;/span&gt;&lt;/code&gt;&lt;span&gt;指令绑定cpu和mem的亲和性后才遭遇的。相信国内绝大部分的线上Redis没有进行这个绑定，所以理论上来单Redis单实例可以使用到整个机器的物理内存。（实践中最好不要这么干，你的大部分内存都绑定到一个redis进程里的话，那其它CPU核就没啥事干了，浪费了CPU的多核计算能力）&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-original-title=&quot;&quot; placeholder=&quot;1&quot; title=&quot;&quot;&gt;6&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;扩展&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;numactl&lt;/span&gt;&lt;/code&gt;&lt;span&gt;绑定CPU和mem都在一个node里的时候，内存IO不需要经过总线，性能会比较高，你Redis的QPS能力也会上涨。和跨node的内存IO性能对比，可以下面的实例，就是10:21的区别。&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# numactl --hardware&lt;/span&gt;&lt;br/&gt;&lt;span&gt;......&lt;/span&gt;&lt;br/&gt;&lt;span&gt;node distances:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;node   0   1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  0:  10  21&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  1:  21  10&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;你要是对性能有极致的追求，可以试着绑定numa的亲和性玩玩。不过，no作no die，掉到numa陷阱里可别赖我，嘎嘎！&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;往期文章：&lt;br/&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MjEwMDMzNQ==&amp;amp;mid=2652517899&amp;amp;idx=1&amp;amp;sn=71ed82f0375e86a31fa0bf826ec21465&amp;amp;chksm=f2efe70bc5986e1de11e3b40ce60079768f9dddce7d009ca5c7438a8c1e5459a7ff202c726c9&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;漫画 | 理解了TCP连接的实现以后，客户端的并发也爆发了！&lt;/a&gt;&lt;br/&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MjEwMDMzNQ==&amp;amp;mid=2652517902&amp;amp;idx=1&amp;amp;sn=5726b81353083f11d03eeb8ede21213f&amp;amp;chksm=f2efe70ec5986e183de00c1d8a41889cbf25e59e21e6f9353a7f4a331f7a30a448cd44a75a4f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;从内核角度分析 listen() 系统调用的 backlog 参数作用&lt;/a&gt;&lt;br/&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MjEwMDMzNQ==&amp;amp;mid=2652517906&amp;amp;idx=1&amp;amp;sn=949567b867becd946747648a80842909&amp;amp;chksm=f2efe712c5986e044fdc1207ed8e7d9b0b273aa95bce285d4d0a8081b51c44fda1b63cc572bf&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;带宽、延时、吞吐率、PPS 这些都是啥？&lt;/a&gt;&lt;br/&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MjEwMDMzNQ==&amp;amp;mid=2652517890&amp;amp;idx=1&amp;amp;sn=9cafd69e198174f653387f769a1a7821&amp;amp;chksm=f2efe702c5986e144c5feb8482cd4a1f933f891062b49e391815db7b42b3cadc018e13e7658a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;漫画 | 一台Linux服务器最多能支撑多少个TCP连接？&lt;/a&gt;&lt;br/&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MjEwMDMzNQ==&amp;amp;mid=2652517873&amp;amp;idx=1&amp;amp;sn=ec63573ce71973fd7e0f1ddd1ffd8664&amp;amp;chksm=f2efe4f1c5986de752ed2f89a72a5ffcb84a5e7e373a536956a455d29c5bf3055fb486c78f7a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;10张图让你彻底理解回调函数&lt;/a&gt;&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__0&quot;&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2934&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2935&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2936&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2937&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2938&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2939&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2940&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2941&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2942&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2943&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;伟&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2944&quot;&gt;伟&lt;/span&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2945&quot;&gt;大&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2946&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;分&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2947&quot;&gt;分&lt;/span&gt;&lt;span data-raw-text=&quot;割&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2948&quot;&gt;割&lt;/span&gt;&lt;span data-raw-text=&quot;线&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2949&quot;&gt;线&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2950&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2951&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2952&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2953&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2954&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2955&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2956&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2957&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2958&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2959&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2960&quot;&gt;-&lt;/span&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__1&quot;&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__2&quot;&gt;&lt;span data-raw-text=&quot;P&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2961&quot;&gt;P&lt;/span&gt;&lt;span data-raw-text=&quot;H&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2962&quot;&gt;H&lt;/span&gt;&lt;span data-raw-text=&quot;P&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2963&quot;&gt;P&lt;/span&gt;&lt;span data-raw-text=&quot;饭&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2964&quot;&gt;饭&lt;/span&gt;&lt;span data-raw-text=&quot;米&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2965&quot;&gt;米&lt;/span&gt;&lt;span data-raw-text=&quot;粒&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2966&quot;&gt;粒&lt;/span&gt;&lt;span data-raw-text=&quot;(&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2967&quot;&gt;(&lt;/span&gt;&lt;span data-raw-text=&quot;p&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2968&quot;&gt;p&lt;/span&gt;&lt;span data-raw-text=&quot;h&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2969&quot;&gt;h&lt;/span&gt;&lt;span data-raw-text=&quot;p&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2970&quot;&gt;p&lt;/span&gt;&lt;span data-raw-text=&quot;f&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2971&quot;&gt;f&lt;/span&gt;&lt;span data-raw-text=&quot;a&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2972&quot;&gt;a&lt;/span&gt;&lt;span data-raw-text=&quot;m&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2973&quot;&gt;m&lt;/span&gt;&lt;span data-raw-text=&quot;i&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2974&quot;&gt;i&lt;/span&gt;&lt;span data-raw-text=&quot;l&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2975&quot;&gt;l&lt;/span&gt;&lt;span data-raw-text=&quot;y&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2976&quot;&gt;y&lt;/span&gt;&lt;span data-raw-text=&quot;)&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2977&quot;&gt;)&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;98&quot; data-index=&quot;2978&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;由&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2979&quot;&gt;由&lt;/span&gt;&lt;span data-raw-text=&quot;一&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2980&quot;&gt;一&lt;/span&gt;&lt;span data-raw-text=&quot;群&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2981&quot;&gt;群&lt;/span&gt;&lt;span data-raw-text=&quot;靠&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2982&quot;&gt;靠&lt;/span&gt;&lt;span data-raw-text=&quot;谱&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2983&quot;&gt;谱&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2984&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;人&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2985&quot;&gt;人&lt;/span&gt;&lt;span data-raw-text=&quot;建&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2986&quot;&gt;建&lt;/span&gt;&lt;span data-raw-text=&quot;立&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2987&quot;&gt;立&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2988&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;愿&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2989&quot;&gt;愿&lt;/span&gt;&lt;span data-raw-text=&quot;为&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2990&quot;&gt;为&lt;/span&gt;&lt;span data-raw-text=&quot;P&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2991&quot;&gt;P&lt;/span&gt;&lt;span data-raw-text=&quot;H&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2992&quot;&gt;H&lt;/span&gt;&lt;span data-raw-text=&quot;P&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2993&quot;&gt;P&lt;/span&gt;&lt;span data-raw-text=&quot;e&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2994&quot;&gt;e&lt;/span&gt;&lt;span data-raw-text=&quot;r&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2995&quot;&gt;r&lt;/span&gt;&lt;span data-raw-text=&quot;带&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2996&quot;&gt;带&lt;/span&gt;&lt;span data-raw-text=&quot;来&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2997&quot;&gt;来&lt;/span&gt;&lt;span data-raw-text=&quot;一&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2998&quot;&gt;一&lt;/span&gt;&lt;span data-raw-text=&quot;些&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2999&quot;&gt;些&lt;/span&gt;&lt;span data-raw-text=&quot;值&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3000&quot;&gt;值&lt;/span&gt;&lt;span data-raw-text=&quot;得&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3001&quot;&gt;得&lt;/span&gt;&lt;span data-raw-text=&quot;细&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3002&quot;&gt;细&lt;/span&gt;&lt;span data-raw-text=&quot;细&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3003&quot;&gt;细&lt;/span&gt;&lt;span data-raw-text=&quot;品&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3004&quot;&gt;品&lt;/span&gt;&lt;span data-raw-text=&quot;味&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3005&quot;&gt;味&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3006&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;精&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3007&quot;&gt;精&lt;/span&gt;&lt;span data-raw-text=&quot;神&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3008&quot;&gt;神&lt;/span&gt;&lt;span data-raw-text=&quot;食&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3009&quot;&gt;食&lt;/span&gt;&lt;span data-raw-text=&quot;粮&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3010&quot;&gt;粮&lt;/span&gt;&lt;span data-raw-text=&quot;！&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3011&quot;&gt;！&lt;/span&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__3&quot;&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__4&quot;&gt;&lt;span data-raw-text=&quot;饭&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3012&quot;&gt;饭&lt;/span&gt;&lt;span data-raw-text=&quot;米&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3013&quot;&gt;米&lt;/span&gt;&lt;span data-raw-text=&quot;粒&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3014&quot;&gt;粒&lt;/span&gt;&lt;span data-raw-text=&quot;只&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3015&quot;&gt;只&lt;/span&gt;&lt;span data-raw-text=&quot;发&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3016&quot;&gt;发&lt;/span&gt;&lt;span data-raw-text=&quot;原&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3017&quot;&gt;原&lt;/span&gt;&lt;span data-raw-text=&quot;创&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3018&quot;&gt;创&lt;/span&gt;&lt;span data-raw-text=&quot;或&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3019&quot;&gt;或&lt;/span&gt;&lt;span data-raw-text=&quot;授&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3020&quot;&gt;授&lt;/span&gt;&lt;span data-raw-text=&quot;权&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3021&quot;&gt;权&lt;/span&gt;&lt;span data-raw-text=&quot;发&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3022&quot;&gt;发&lt;/span&gt;&lt;span data-raw-text=&quot;表&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3023&quot;&gt;表&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3024&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3025&quot;&gt;文&lt;/span&gt;&lt;span data-raw-text=&quot;章&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3026&quot;&gt;章&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3027&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;不&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3028&quot;&gt;不&lt;/span&gt;&lt;span data-raw-text=&quot;转&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3029&quot;&gt;转&lt;/span&gt;&lt;span data-raw-text=&quot;载&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3030&quot;&gt;载&lt;/span&gt;&lt;span data-raw-text=&quot;网&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3031&quot;&gt;网&lt;/span&gt;&lt;span data-raw-text=&quot;上&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3032&quot;&gt;上&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3033&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3034&quot;&gt;文&lt;/span&gt;&lt;span data-raw-text=&quot;章&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3035&quot;&gt;章&lt;/span&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__5&quot;&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__6&quot;&gt;&lt;span data-raw-text=&quot;所&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3036&quot;&gt;所&lt;/span&gt;&lt;span data-raw-text=&quot;发&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3037&quot;&gt;发&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3038&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3039&quot;&gt;文&lt;/span&gt;&lt;span data-raw-text=&quot;章&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3040&quot;&gt;章&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3041&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;均&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3042&quot;&gt;均&lt;/span&gt;&lt;span data-raw-text=&quot;可&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3043&quot;&gt;可&lt;/span&gt;&lt;span data-raw-text=&quot;找&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3044&quot;&gt;找&lt;/span&gt;&lt;span data-raw-text=&quot;到&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3045&quot;&gt;到&lt;/span&gt;&lt;span data-raw-text=&quot;原&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3046&quot;&gt;原&lt;/span&gt;&lt;span data-raw-text=&quot;作&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3047&quot;&gt;作&lt;/span&gt;&lt;span data-raw-text=&quot;者&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3048&quot;&gt;者&lt;/span&gt;&lt;span data-raw-text=&quot;进&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3049&quot;&gt;进&lt;/span&gt;&lt;span data-raw-text=&quot;行&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3050&quot;&gt;行&lt;/span&gt;&lt;span data-raw-text=&quot;沟&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3051&quot;&gt;沟&lt;/span&gt;&lt;span data-raw-text=&quot;通&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3052&quot;&gt;通&lt;/span&gt;&lt;span data-raw-text=&quot;。&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3053&quot;&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__7&quot;&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__8&quot;&gt;&lt;span&gt;&lt;span data-raw-text=&quot;也&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3054&quot;&gt;也&lt;/span&gt;&lt;span data-raw-text=&quot;希&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3055&quot;&gt;希&lt;/span&gt;&lt;span data-raw-text=&quot;望&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3056&quot;&gt;望&lt;/span&gt;&lt;span data-raw-text=&quot;各&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3057&quot;&gt;各&lt;/span&gt;&lt;span data-raw-text=&quot;位&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3058&quot;&gt;位&lt;/span&gt;&lt;span data-raw-text=&quot;多&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3059&quot;&gt;多&lt;/span&gt;&lt;span data-raw-text=&quot;多&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3060&quot;&gt;多&lt;/span&gt;&lt;span data-raw-text=&quot;打&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3061&quot;&gt;打&lt;/span&gt;&lt;span data-raw-text=&quot;赏&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3062&quot;&gt;赏&lt;/span&gt;&lt;span data-raw-text=&quot;（&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3063&quot;&gt;（&lt;/span&gt;&lt;span data-raw-text=&quot;算&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3064&quot;&gt;算&lt;/span&gt;&lt;span data-raw-text=&quot;作&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3065&quot;&gt;作&lt;/span&gt;&lt;span data-raw-text=&quot;稿&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3066&quot;&gt;稿&lt;/span&gt;&lt;span data-raw-text=&quot;费&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3067&quot;&gt;费&lt;/span&gt;&lt;span data-raw-text=&quot;给&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3068&quot;&gt;给&lt;/span&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3069&quot;&gt;文&lt;/span&gt;&lt;span data-raw-text=&quot;章&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3070&quot;&gt;章&lt;/span&gt;&lt;span data-raw-text=&quot;作&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3071&quot;&gt;作&lt;/span&gt;&lt;span data-raw-text=&quot;者&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3072&quot;&gt;者&lt;/span&gt;&lt;span data-raw-text=&quot;）&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3073&quot;&gt;）&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3074&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;更&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3075&quot;&gt;更&lt;/span&gt;&lt;span data-raw-text=&quot;希&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3076&quot;&gt;希&lt;/span&gt;&lt;span data-raw-text=&quot;望&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3077&quot;&gt;望&lt;/span&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3078&quot;&gt;大&lt;/span&gt;&lt;span data-raw-text=&quot;家&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3079&quot;&gt;家&lt;/span&gt;&lt;span data-raw-text=&quot;多&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3080&quot;&gt;多&lt;/span&gt;&lt;span data-raw-text=&quot;多&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3081&quot;&gt;多&lt;/span&gt;&lt;span data-raw-text=&quot;投&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3082&quot;&gt;投&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;稿&quot; data-textnode-index=&quot;102&quot; data-index=&quot;3083&quot;&gt;稿&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__9&quot;&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__10&quot;&gt;&lt;span data-raw-text=&quot;投&quot; data-textnode-index=&quot;104&quot; data-index=&quot;3085&quot;&gt;投&lt;/span&gt;&lt;span data-raw-text=&quot;稿&quot; data-textnode-index=&quot;104&quot; data-index=&quot;3086&quot;&gt;稿&lt;/span&gt;&lt;span data-raw-text=&quot;请&quot; data-textnode-index=&quot;104&quot; data-index=&quot;3087&quot;&gt;请&lt;/span&gt;&lt;span data-raw-text=&quot;联&quot; data-textnode-index=&quot;104&quot; data-index=&quot;3088&quot;&gt;联&lt;/span&gt;&lt;span data-raw-text=&quot;系&quot; data-textnode-index=&quot;104&quot; data-index=&quot;3089&quot;&gt;系&lt;/span&gt;&lt;span data-raw-text=&quot;：&quot; data-textnode-index=&quot;104&quot; data-index=&quot;3090&quot;&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__11&quot;&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__12&quot;&gt;&lt;span data-raw-text=&quot;s&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3091&quot;&gt;s&lt;/span&gt;&lt;span data-raw-text=&quot;h&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3092&quot;&gt;h&lt;/span&gt;&lt;span data-raw-text=&quot;e&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3093&quot;&gt;e&lt;/span&gt;&lt;span data-raw-text=&quot;n&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3094&quot;&gt;n&lt;/span&gt;&lt;span data-raw-text=&quot;z&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3095&quot;&gt;z&lt;/span&gt;&lt;span data-raw-text=&quot;h&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3096&quot;&gt;h&lt;/span&gt;&lt;span data-raw-text=&quot;e&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3097&quot;&gt;e&lt;/span&gt;&lt;span data-raw-text=&quot;1&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3098&quot;&gt;1&lt;/span&gt;&lt;span data-raw-text=&quot;6&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3099&quot;&gt;6&lt;/span&gt;&lt;span data-raw-text=&quot;3&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3100&quot;&gt;3&lt;/span&gt;&lt;span data-raw-text=&quot;@&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3101&quot;&gt;@&lt;/span&gt;&lt;span data-raw-text=&quot;g&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3102&quot;&gt;g&lt;/span&gt;&lt;span data-raw-text=&quot;m&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3103&quot;&gt;m&lt;/span&gt;&lt;span data-raw-text=&quot;a&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3104&quot;&gt;a&lt;/span&gt;&lt;span data-raw-text=&quot;i&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3105&quot;&gt;i&lt;/span&gt;&lt;span data-raw-text=&quot;l&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3106&quot;&gt;l&lt;/span&gt;&lt;span data-raw-text=&quot;.&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3107&quot;&gt;.&lt;/span&gt;&lt;span data-raw-text=&quot;c&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3108&quot;&gt;c&lt;/span&gt;&lt;span data-raw-text=&quot;o&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3109&quot;&gt;o&lt;/span&gt;&lt;span data-raw-text=&quot;m&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3110&quot;&gt;m&lt;/span&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__13&quot;&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__14&quot;&gt;&lt;span data-raw-text=&quot;本&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3111&quot;&gt;本&lt;/span&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3112&quot;&gt;文&lt;/span&gt;&lt;span data-raw-text=&quot;由&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3113&quot;&gt;由&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;106&quot; data-index=&quot;3114&quot;&gt;  &lt;span&gt;张彦飞allen&lt;/span&gt; &lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;106&quot; data-index=&quot;3118&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;授&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3119&quot;&gt;授&lt;/span&gt;&lt;span data-raw-text=&quot;权&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3120&quot;&gt;权&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;106&quot; data-index=&quot;3121&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;饭&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3122&quot;&gt;饭&lt;/span&gt;&lt;span data-raw-text=&quot;米&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3123&quot;&gt;米&lt;/span&gt;&lt;span data-raw-text=&quot;粒&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3124&quot;&gt;粒&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;106&quot; data-index=&quot;3125&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;发&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3126&quot;&gt;发&lt;/span&gt;&lt;span data-raw-text=&quot;布&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3127&quot;&gt;布&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3128&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;转&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3129&quot;&gt;转&lt;/span&gt;&lt;span data-raw-text=&quot;载&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3130&quot;&gt;载&lt;/span&gt;&lt;span data-raw-text=&quot;请&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3131&quot;&gt;请&lt;/span&gt;&lt;span data-raw-text=&quot;注&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3132&quot;&gt;注&lt;/span&gt;&lt;span data-raw-text=&quot;明&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3133&quot;&gt;明&lt;/span&gt;&lt;span data-raw-text=&quot;本&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3134&quot;&gt;本&lt;/span&gt;&lt;span data-raw-text=&quot;来&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3135&quot;&gt;来&lt;/span&gt;&lt;span data-raw-text=&quot;源&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3136&quot;&gt;源&lt;/span&gt;&lt;span data-raw-text=&quot;信&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3137&quot;&gt;信&lt;/span&gt;&lt;span data-raw-text=&quot;息&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3138&quot;&gt;息&lt;/span&gt;&lt;span data-raw-text=&quot;和&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3139&quot;&gt;和&lt;/span&gt;&lt;span data-raw-text=&quot;以&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3140&quot;&gt;以&lt;/span&gt;&lt;span data-raw-text=&quot;下&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3141&quot;&gt;下&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3142&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;二&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3143&quot;&gt;二&lt;/span&gt;&lt;span data-raw-text=&quot;维&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3144&quot;&gt;维&lt;/span&gt;&lt;span data-raw-text=&quot;码&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3145&quot;&gt;码&lt;/span&gt;&lt;span data-raw-text=&quot;（&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3146&quot;&gt;（&lt;/span&gt;&lt;span data-raw-text=&quot;长&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3147&quot;&gt;长&lt;/span&gt;&lt;span data-raw-text=&quot;按&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3148&quot;&gt;按&lt;/span&gt;&lt;span data-raw-text=&quot;可&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3149&quot;&gt;可&lt;/span&gt;&lt;span data-raw-text=&quot;识&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3150&quot;&gt;识&lt;/span&gt;&lt;span data-raw-text=&quot;别&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3151&quot;&gt;别&lt;/span&gt;&lt;span data-raw-text=&quot;二&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3152&quot;&gt;二&lt;/span&gt;&lt;span data-raw-text=&quot;维&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3153&quot;&gt;维&lt;/span&gt;&lt;span data-raw-text=&quot;码&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3154&quot;&gt;码&lt;/span&gt;&lt;span data-raw-text=&quot;关&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3155&quot;&gt;关&lt;/span&gt;&lt;span data-raw-text=&quot;注&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3156&quot;&gt;注&lt;/span&gt;&lt;span data-raw-text=&quot;）&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3157&quot;&gt;）&lt;/span&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__15&quot;&gt;&lt;span&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/LHDiahSVnXhunbEtuowcI7kF5kmUaeTrszibibQ3st6OU8hy2CoIotHHLxicicibyF1qkNI7HibXYHXGN6hRby4ZyjR6A/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>083ba4851def872a5d5de52dd01cce64</guid>
<title>Golang 调试分析的高阶技巧</title>
<link>https://toutiao.io/k/9egd20y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;大纲&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Golang tools&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;nm&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;compile&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;objdump&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;pprof&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;trace&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;单元测试&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;程序 Debug&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;小技巧&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;总结&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;Golang 高阶调试&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文专注 golang debug 的一些技巧应用，以及相关工具的实用用法，再也不用怕 golang 怎么调试。golang 作为一门现代化语音，出生的时候就自带完整的 debug 手段：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;golang tools 是直接集成在语言工具里，支持内存分析，cpu分析，阻塞锁分析等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;delve，gdb 作为最常用的 debug 工具，让你能够更深入的进入程序调试；&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;delve 当前是最友好的 golang 调试程序，ide 调试其实也是调用 dlv 而已，比如 goland；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;单元测试的设计深入到语言设计级别，可以非常方便执行单元测试并且生成代码覆盖率；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Golang tools&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang 从语言原生层面就集成了大量的实用工具，这些都是 Robert Griesemer, Rob Pike, Ken Thompson 这几位大神经验沉淀下的精华。你安装好 golang 之后，执行 &lt;code&gt;go tool&lt;/code&gt; 就能看到内置支持的所有工具了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;root@ubuntu:~&lt;span&gt;# go tool&lt;/span&gt;&lt;br/&gt;addr2line&lt;br/&gt;asm&lt;br/&gt;buildid&lt;br/&gt;cgo&lt;br/&gt;compile&lt;br/&gt;cover&lt;br/&gt;dist&lt;br/&gt;doc&lt;br/&gt;fix&lt;br/&gt;link&lt;br/&gt;nm&lt;br/&gt;objdump&lt;br/&gt;pack&lt;br/&gt;pprof&lt;br/&gt;test2json&lt;br/&gt;trace&lt;br/&gt;vet&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这里专注挑选几个 debug 常用的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;nm：查看符号表（等同于系统 &lt;code&gt;nm&lt;/code&gt; 命令）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;objdump：反汇编工具，分析二进制文件（等同于系统 &lt;code&gt;objdump&lt;/code&gt; 命令）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;pprof：指标，性能分析工具&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cover：生成代码覆盖率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;trace：采样一段时间，指标跟踪分析工具&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;compile：代码汇编&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;nm&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看符号表的命令，等同于系统的 nm 命令，非常有用。在断点的时候，如果你不知道断点的函数符号，那么用这个命令查一下就知道了（命令处理的是二进制程序文件）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# exmple 为你编译的二进制文件&lt;/span&gt;&lt;br/&gt;go tool nm ./example&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一列是地址，第二列是类型，第三列是符号：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img data-ratio=&quot;0.43540183112919634&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChOjKKUqUH7qJInwJdQGPKmtzErnNyN1xZP029OJnpl4Ira8cQ7tq9YK42ibXEaBszVyLnEibZzSBYibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;983&quot;/&gt;&lt;span/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;compile&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;汇编某个文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go tool compile -N -l -S example.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你就能看到你 golang 语言对应的汇编代码了（注意了，命令处理的是 golang 代码文本），酷。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;objdump&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反汇编二进制的工具，等同于系统 &lt;code&gt;objdump&lt;/code&gt;（注意了，命令解析的是二进制格式的程序文件）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go tool objdump example.o&lt;br/&gt;go tool objdump -s DoFunc example.o  // 反汇编具体函数&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;汇编代码这个东西在 90% 的场景可能都用不上，但是如果你处理过 c 的程序，在某些特殊场景，通过反汇编一段逻辑来推断应用程序行为将是你唯一的出路。因为线上的代码一般都是会开启编译优化，所以这里会导致你的代码对不上。再者，线上不可能让你随意 attach 进程，很多时候都是出 core 了，你就只有一个 core 文件去排查。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;pprof&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pprof 支持四种类型的分析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CPU ：CPU 分析，采样消耗 cpu 的调用，这个一般用来定位排查程序里耗费计算资源的地方；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Memroy ：内存分析，一般用来排查内存占用，内存泄露等问题；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Block ：阻塞分析，会采样程序里阻塞的调用情况；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Mutex ：互斥锁分析，采样互斥锁的竞争情况；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们这里详细以内存占用分析举例（其他的类似），pprof 这个是内存分析神器。基本上，golang 有了这个东西，99% 的内存问题（比如内存泄露，内存占用过大等等）都是可以非常快的定位出来的。首先，对于 golang 的内存分析（或者其他的锁消耗，cpu 消耗）我们明确几个重要的点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;golang 内存 pprof 是采样的，每 512KB 采样一次；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;golang 的内存采样的是堆栈路径，而不是类型信息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;golang 的内存采样入口一定是通过&lt;code&gt;mProf_Malloc&lt;/code&gt;，&lt;code&gt;mProf_Free&lt;/code&gt; 这两个函数。所以，如果是 cgo 分配的内存，那么是没有机会调用到这两个函数的，所以如果是 cgo 导致的内存问题，go tool pprof 是分析不出来的；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细原理，可以复习另一篇文章：内存分析；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析的形式有两种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果是 &lt;code&gt;net/http/pporf&lt;/code&gt; 方式开启的，那么可以直接在控制台上输入，浏览器就能看；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另一种方式是先把信息 dump 到本地文件，然后用 &lt;code&gt;go tool&lt;/code&gt; 去分析（我们以这个举例，因为这种方式才是生产环境通用的方式）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 查看累计分配占用&lt;/span&gt;&lt;br/&gt;go tool pprof -alloc_space ./29075_20190523_154406_heap&lt;br/&gt;&lt;span&gt;# 查看当前的分配占用&lt;/span&gt;&lt;br/&gt;go tool pprof -inuse_space ./29075_20190523_154406_allocs&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你也可以不指定类型，直接 &lt;code&gt;go tool pprof ./xxx&lt;/code&gt; ，进入分析之后，调用 &lt;code&gt;o&lt;/code&gt; 选项，指定类型：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我写了一个 demo 程序，然后 dump 出了一份 heap 的 pprof 采样文件，我们先通过这个 pprof 得出一些结论，最后我再贴出源代码，再品一品。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go tool pprof ./29075_20190523_154406_heap&lt;br/&gt;(pprof) o              &lt;br/&gt;...          &lt;br/&gt;  sample_index              = inuse_space          //: [alloc_objects | alloc_space | inuse_objects | inuse_space]&lt;br/&gt;...       &lt;br/&gt;(pprof) alloc_space&lt;br/&gt;(pprof) top&lt;br/&gt;Showing nodes accounting &lt;span&gt;for&lt;/span&gt; 290MB, 100% of 290MB total&lt;br/&gt;      flat  flat%   sum%        cum   cum%&lt;br/&gt;     140MB 48.28% 48.28%      140MB 48.28%  main.funcA (inline)&lt;br/&gt;     100MB 34.48% 82.76%      190MB 65.52%  main.funcB (inline)&lt;br/&gt;      50MB 17.24%   100%      140MB 48.28%  main.funcC (inline)&lt;br/&gt;         0     0%   100%      290MB   100%  main.main&lt;br/&gt;         0     0%   100%      290MB   100%  runtime.main&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 top 信息表明了这么几点信息：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;main.funcA&lt;/code&gt;  这个函数现场分配了 140M 的内存，&lt;code&gt;main.funcB&lt;/code&gt; 这个函数现场分配了 100M 内存，&lt;code&gt;main.funcC&lt;/code&gt; 现场分配了 50M 内存；&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;现场的意思：纯粹自己函数直接分配的，而不是调用别的函数分配的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这些信息通过 flat 得知；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;main.funcA&lt;/code&gt;  分配的 140M 内存纯粹是自己分配的，没有调用别的函数分配过内存；&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个信息通过 &lt;code&gt;main.funcA&lt;/code&gt; flat 和 cum 都为 140 M 得出；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;main.funcB&lt;/code&gt;  自己分配了 100MB，并且还调用了别的函数，别的函数里面涉及了 90M 的内存分配；&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个信息通过 &lt;code&gt;main.funcB&lt;/code&gt; flat 和 cum 分别为 100 M，190M 得出；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;main.funcC&lt;/code&gt;  自己分配了 50MB，并且还调用了别的函数，别的函数里面涉及了 90M 的内存分配；&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个信息通过 &lt;code&gt;main.funcC&lt;/code&gt; flat 和 cum 分别为 50 M，140 M 得出；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;main.main&lt;/code&gt; ：所有分配内存的函数调用都是走这个函数出去的。main 函数本身没有函数分配，但是他调用的函数分配了 290M；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;demo 的源代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;net/http&quot;&lt;/span&gt;&lt;br/&gt; _ &lt;span&gt;&quot;net/http/pprof&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;funcA&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; []&lt;span&gt;byte&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; a := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; a&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;funcB&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;([]&lt;span&gt;byte&lt;/span&gt;, []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; a := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt; b := funcA()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; a, b&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;funcC&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;([]&lt;span&gt;byte&lt;/span&gt;, []&lt;span&gt;byte&lt;/span&gt;, []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; a := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt; b, c := funcB()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; a, b, c&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i++ {&lt;br/&gt;  funcA()&lt;br/&gt;  funcB()&lt;br/&gt;  funcC()&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; http.ListenAndServe(&lt;span&gt;&quot;0.0.0.0:9999&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;dump 命令&lt;/strong&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;curl -sS &lt;span&gt;&#x27;http://127.0.0.1:9999/debug/pprof/heap?seconds=5&#x27;&lt;/span&gt; -o heap.pporf&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对照着代码，再品一品。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;trace&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序 trace 调试&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go tool trace -http=&lt;span&gt;&quot;:6060&quot;&lt;/span&gt; ./ssd_336959_20190704_105540_trace&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;trace 这个命令允许你跟踪采集一段时间的信息，然后 dump 成文件，最后调用 &lt;code&gt;go tool trace&lt;/code&gt; 分析 dump 文件，并且以 web 的形式打开。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;单元测试&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单元测试的重要性就不再论述。golang 里面 &lt;code&gt;_test.go&lt;/code&gt; 结尾的文件认为是测试文件，golang 作为现代化的语言，语言工具层面支持单元测试。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;执行单元测试&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行单元测试有两种方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;go test 直接运行，这个是最简单的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;先编译测试文件，再运行。这种方式更灵活；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;go test 运行&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 直接在你项目目录里运行 go &lt;span&gt;test&lt;/span&gt; .&lt;br/&gt;go &lt;span&gt;test&lt;/span&gt; .&lt;br/&gt;// 指定运行函数&lt;br/&gt;go &lt;span&gt;test&lt;/span&gt; -run=TestPutAndGetKeyValue&lt;br/&gt;// 打印详细信息&lt;br/&gt;go &lt;span&gt;test&lt;/span&gt; -v&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;编译，运行&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本质上，golang 跑单测是先编译 &lt;code&gt;*_test.go&lt;/code&gt; 文件，编译成二进制后，再运行这个二进制文件。你执行 &lt;code&gt;go test&lt;/code&gt; 的时候，工具帮你做好了，这些动作其实也是可以拆开来自己做的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译生成单元测试可执行文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 先编译出 .&lt;span&gt;test&lt;/span&gt; 文件&lt;br/&gt;$ go &lt;span&gt;test&lt;/span&gt; -c &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 指定跑某一个文件&lt;br/&gt;$ ./raftexample.test -test.timeout=10m0s -test.v=&lt;span&gt;true&lt;/span&gt; -test.run=TestPutAndGetKeyValue&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式通常会出现在以下几种场景：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这台机器上编译，另一个地方跑单测；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;debug 单测程序；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;统计代码覆盖率&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang 的代码覆盖率是基于单测的，由单测作为出发点，来看你的业务代码覆盖率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作很简单：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;加一个 &lt;code&gt;-coverprofile&lt;/code&gt; 的参数，声明在跑单测的时候，记录代码覆盖率；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;go tool cover&lt;/code&gt; 命令分析，得出覆盖率报告；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go &lt;span&gt;test&lt;/span&gt; -coverprofile=coverage.out&lt;br/&gt;go tool cover -func=coverage.out&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;root@ubuntu:~/opensource/readcode-etcd-master/src/go.etcd.io/etcd/contrib/raftexample&lt;span&gt;# go tool cover -func=coverage.out&lt;/span&gt;&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/httpapi.go:33: ServeHTTP  25.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/httpapi.go:108: serveHttpKVAPI  0.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/kvstore.go:41: newKVStore  100.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/kvstore.go:50: Lookup   100.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/kvstore.go:57: Propose   75.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/kvstore.go:71: readCommits  55.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/kvstore.go:107: getSnapshot  100.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/kvstore.go:113: recoverFromSnapshot 85.7%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/listener.go:30: newStoppableListener 75.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/listener.go:38: Accept   92.9%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/main.go:24: main   0.0%&lt;br/&gt;total:       (statements)  57.1%&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的话，你就知道每个函数的代码覆盖率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;程序 Debug&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序的调试主要由两个工具：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;dlv&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gdb&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里推荐 dlv，因为 gdb 功能实在是有限，gdb 不理解 golang 的业务类型和协程。但是 gdb 有一个功能是无法替代的，就是 gcore 的功能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;dlv 调试用法&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调试二进制&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dlv &lt;span&gt;exec&lt;/span&gt; &amp;lt;path/to/binary&amp;gt; [flags]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dlv &lt;span&gt;exec&lt;/span&gt; ./example&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dlv 调试二进制，并带参数&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dlv &lt;span&gt;exec&lt;/span&gt; ./example -- --audit=./d&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调试进程&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dlv attach &lt;span&gt;${pid}&lt;/span&gt; [executable] [flags]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进程号是必选的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dlv attach 12808 ./example&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调试 core 文件&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dlv 调试core文件；并且标准输出导出到文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dlv core &amp;lt;executable&amp;gt; &amp;lt;core&amp;gt; [flags]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dlv core ./example core.277282&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调试常用语法&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;系统整理&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;程序运行&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;call ：call 函数（注意了，这个会导致整个程序运行的）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;continue ：往下运行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;next ：单步调试&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;restart ：重启&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;step ：单步调试，某个函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;step-instruction ：单步调试某个汇编指令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;stepout ：从当前函数跳出&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;断点相关&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;break (alias: b) ：设置断点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;breakpoints (alias: bp)  ：打印所有的断点信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;clear ：清理断点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;clearall ：清理所有的断点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;condition (alias: cond)  ：设置条件断点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;on ：设置一段命令，当断点命中的时候&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;trace (alias: t) ：设置一个跟踪点，这个跟踪点也是一个断点，只不过运行道德时候不会断住程序，只是打印一行信息，这个命令在某些场景是很有用的，比如你断住程序就会影响逻辑（业务有超时），而你仅仅是想打印某个变量而已，那么用这种类型的断点就行；；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;信息打印&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;args : 打印程序的传参&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;examinemem (alias: x)  ：这个是神器，解析内存用的，和 gdb 的 x 命令一样；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;locals ：打印本地变量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;print (alias: p) ：打印一个表达式，或者变量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;regs ：打印寄存器的信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;set ：set 赋值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;vars ：打印全局变量（包变量）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;whatis ：打印类型信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;协程相关&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;goroutine (alias: gr) ：打印某个特定协程的信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;goroutines (alias: grs)  ：列举所有的协程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;thread (alias: tr) ：切换到某个线程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;threads ：打印所有的线程信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;栈相关&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;deferred ：在 defer 函数上下文里执行命令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;down ：上堆栈&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;frame ：跳到某个具体的堆栈&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;stack (alias: bt)  ：打印堆栈信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;up ：下堆栈&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;其他命令&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;config ：配置变更&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;disassemble (alias: disass) ：反汇编&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;edit (alias: ed) ：略&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;exit (alias: quit | q) ：略&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;funcs ：打印所有函数符号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;libraries ：打印所有加载的动态库&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;list (alias: ls | l) ：显示源码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;source ：加载命令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sources ：打印源码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;types ：打印所有类型信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是完整的 dlv 的支持的命令，从这个来看，是完全满足我们的调试需求的（有的只适用于开发调试环节，比如线上的程序不可能让你随意单步调试的，有的使用于线上生产环节）。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;应用举例&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;打印全局变量&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(dlv) vars&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个非常有用，帮助你看一些全局变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;条件断点&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 先断点&lt;/span&gt;&lt;br/&gt;(dlv) b &lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 查看断点信息&lt;/span&gt;&lt;br/&gt;(dlv) bp&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 然后定制条件&lt;/span&gt;&lt;br/&gt;(dlv) condition 2 i==2 &amp;amp;&amp;amp; j==7 &amp;amp;&amp;amp; z==32&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;查看堆栈&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 展示所有堆栈&lt;/span&gt;&lt;br/&gt;(dlv) goroutines&lt;br/&gt;&lt;span&gt;# 所有堆栈展开&lt;/span&gt;&lt;br/&gt;(dlv) goroutines -t&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解析内存&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(dlv) x -fmt hex -len 20 0xc00008af38&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;x&lt;/code&gt; 命令和 gdb 的 &lt;code&gt;x&lt;/code&gt; 是一样的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;gdb 调试&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gdb 对 golang 的调试支持是通过一个 python 脚本文件 &lt;code&gt;src/runtime/runtime-gdb.py&lt;/code&gt; 来扩展的，所以功能非常有限。gdb 只能做到最基本的变量打印，却理解不了 golang 的一些特殊类型，比如 channel，map，slice 等，gdb 原生是无法调适 goroutine 协程的，因为这个是用户态的调度单位，gdb 只能理解线程。所以只能通过 python 脚本的扩展，把协程结构按照链表输出出来，支持的命令：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img data-ratio=&quot;0.43457943925233644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChOjKKUqUH7qJInwJdQGPKmtKelWeTNYiaWaDr9BrbjuyC4YORJcKttKnlMyNl6ZGUQs17a9Qksedbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;428&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gdb当前只支持6个命令：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3个 cmd 命令&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;info goroutines；打印所有的goroutines&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;goroutine ${id} bt；打印一个goroutine的堆栈&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;iface；打印静态或者动态的接口类型&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3个函数&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;len；打印string，slices，map，channels 这四种类型的长度&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cap；打印slices，channels 这两种类型的cap&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;dtype；强制转换接口到动态类型。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;打印全局变量&lt;/strong&gt; (注意单引号)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(gdb) p &lt;span&gt;&#x27;runtime.firstmoduledata&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 gdb 不理解 golang 的一些类型系统，所以调试打印的时候经常打印不出来，这个要注意下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;打印数组变量长度&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(gdb) p &lt;span&gt;$len&lt;/span&gt;(xxx)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我一般只用 gdb 来 gcore 而已。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;小技巧&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不知道怎么断点函数？&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候不知道怎么断点函数：可以通过nm查询下，然后再断点，就一定能断到了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img data-ratio=&quot;0.22040816326530613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChOjKKUqUH7qJInwJdQGPKmtJjIAnEVLaCISe9ibaPELKN18v9GprR970Jonh6mSCAjNjxuwlcEFkYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;980&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img data-ratio=&quot;0.07482014388489208&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChOjKKUqUH7qJInwJdQGPKmtvtDBf67HhQantibQ4RscF07VSNic1lMkDXJTlsSPL1pnDFianLT3Wic5Sw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;695&quot;/&gt;&lt;span/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不知道调用上下文？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在你的代码里添加一行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;debug.PrintStack()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就能当前代码位置的堆栈给打印出来，这样你就直到怎么函数的调用路径了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不知道怎么开启 pprof ？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pprof 功能有两种开启方式，对应两种包：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;net/http/pprof ：使用在 web 服务器的场景；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;runtime/pprof  ：使用在非服务器应用程序的场景；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个本质上是一致的，&lt;code&gt;net/http/pporf&lt;/code&gt; 也只是在 &lt;code&gt;runtime/pprof&lt;/code&gt; 上的一层 web 封装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;code&gt;net/http/pprof&lt;/code&gt; 方式&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import _ &lt;span&gt;&quot;net/http/pprof&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;code&gt;runtime/pprof&lt;/code&gt; 方式&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种通常用于程序调优的场景，程序只是一个应用程序，跑一次就结束，你想找到瓶颈点，那么通常会使用到这个方式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;// cpu pprof 文件路径&lt;/span&gt;&lt;br/&gt;    f, err := os.Create(&lt;span&gt;&quot;cpufile.pprof&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Fatal(err)&lt;br/&gt; }&lt;br/&gt;    &lt;span&gt;// 开启 cpu pprof&lt;/span&gt;&lt;br/&gt; pprof.StartCPUProfile(f)&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; pprof.StopCPUProfile()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么有时候单点调试的时候，总是非预期的执行代码？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况一般是被编译器优化了，比如函数内联了，编译出的二进制删减了无效逻辑、无效参数。这种情况就会导致你 dlv 单步调试的时候，总是非预期的执行，或者打印某些变量打印不出来。这种情况解决方法就是：禁止编译优化。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go build -gcflags &lt;span&gt;&quot;-N -l&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;总结&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该篇文章系统的分享了 golang 程序调试的技巧和用法：&lt;/p&gt;&lt;section&gt;语言工具包里内置 tool 工具，支持汇编，反汇编，pprof 分析，符号表查询等实用功能；&lt;/section&gt;&lt;section&gt;语言工具包集成单元测试，代码覆盖率依赖于单元测试的触发；&lt;/section&gt;&lt;section&gt;常用 dlv/gdb 这两个工具作为大杀器，可以分析二进制，进程，core 文件；&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;amp;mid=2247484828&amp;amp;idx=3&amp;amp;sn=51bcc62c62a110c01dae3bdc7facbc4e&amp;amp;chksm=eb310413dc468d055f92e0a84c1398e00024bb1154f730cbf6378855ac0db806283e05783f65&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;Go爬虫+WordPress每月躺赚上千元（合法合规实战）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;amp;mid=2247484845&amp;amp;idx=4&amp;amp;sn=b4a01ecf193fc9cd88280653c008fdc8&amp;amp;chksm=eb310422dc468d344914fe894d74866b61f104e120d60c823485bdd834b8f9e66e0f3c7cfafb&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;Golang Gin 实战（十三）| 中间件详解看这一篇就够了&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;amp;mid=2247484430&amp;amp;idx=2&amp;amp;sn=0ae0d76f6ca1b5314861d6fa911ba121&amp;amp;chksm=eb310581dc468c97d986a7b2b5f21cfdf8ea5d5355061bc6ddce8a5115bcc84988e8f8d15bd3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;《Go语言实战》笔记(二十八) | 后记&lt;/a&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3649122807017544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yGKTjJdYkkvuj8z0lDLzibibzK119ljw0Aq61ZDMUp0U6LG9Fhqo9c3rlrGUDGqfosib1ptkqYBDV4uYlOUEktQAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1710&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>452765dcf2c0deb6632e3f650deeacbd</guid>
<title>可视化搭建平台的地图组件和日历组件方案选型</title>
<link>https://toutiao.io/k/m2mo0nj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img data-ratio=&quot;0.4926522043386984&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114997K9ehUwcDh5cb9c1qZjL8ZhhUkav1It9Lpn5tqVFPfnRaBlvibQibhMdAB0sVAz6kVECXlq6Zxaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2858&quot;/&gt;&lt;/p&gt;&lt;p&gt;可视化搭建平台除了需要为用户提供简单便捷的操作方式之外, 还需要提供丰富的组件支持和组件扩展, 这样才能满足更多用户的业务需求.&lt;/p&gt;&lt;p&gt;在 &lt;strong&gt;H5-dooring&lt;/strong&gt; 创建的初期主要考虑的方向是&lt;strong&gt;用户使用的便捷性&lt;/strong&gt;, 即最大程度的降低用户操作成本, 所以采用了&lt;strong&gt;智能布局&lt;/strong&gt;, 也就是&lt;code&gt;react-grid-layout&lt;/code&gt;这个库, 之前考虑过完全的&lt;strong&gt;自由布局&lt;/strong&gt;, 也实现了一套自由布局的方案(使用&lt;code&gt;react-draggable&lt;/code&gt;和&lt;code&gt;React-Resizable&lt;/code&gt;), 但是崇尚 &lt;strong&gt;less is more&lt;/strong&gt; 的设计哲学, 还是坚定的走了&lt;strong&gt;智能布局&lt;/strong&gt;的道路.&lt;/p&gt;&lt;p&gt;笔者接下来会介绍如何在 &lt;strong&gt;H5页面编辑器&lt;/strong&gt; 中自定义开发自己的组件, 以及如何开发可以使H5展现力更强的组件: &lt;strong&gt;地图&lt;/strong&gt;和&lt;strong&gt;日历组件&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;如果大家对可视化拖拽搭建平台的实现方案感兴趣, 可以参考我之前的文章和 github. 后续会更新更多&lt;code&gt;lowcode&lt;/code&gt;和&lt;code&gt;nocode&lt;/code&gt;的技术实现和国内外方案分析.&lt;/p&gt;&lt;h3&gt;演示效果&lt;/h3&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4898813677599442&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114997K9ehUwcDh5cb9c1qZjLfBDjP6nSfgJf0Iia82zufZSLCznDOfNmibGBoFpYoy1OBOma6gvyIxOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2866&quot;/&gt;&lt;/p&gt;&lt;h3&gt;实现自定义组件开发的流程&lt;/h3&gt;&lt;p&gt;作为前端工程师, 我们对于开发&lt;code&gt;vue&lt;/code&gt;组件或者&lt;code&gt;react&lt;/code&gt;组件想必不会很陌生, 对于一个可扩展复用当然组件来说, 我们只需要做好以下几点就好了:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;语义化&lt;/strong&gt; : 组件命名可读性强, 比如&lt;code&gt;antd&lt;/code&gt;, &lt;code&gt;element&lt;/code&gt;的组件风格&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;重用-发布等价原则（REP&lt;/strong&gt;）: 组件中的类要么都是可重用的，要么都不可重用&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;共同重用原则(CRP)&lt;/strong&gt;: 组件中所有类应该是共同重用的，如果重用了组件中的一个类就应该重用组件中的所有类&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;共同封闭原则（CCP)&lt;/strong&gt;: 组件的所有类对同一性质的变化是共同封闭的, 同时不会影响到外部, 即对修改是封闭的，但对扩展应该是开放的&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;稳定抽象原则(SAP)&lt;/strong&gt;: 组件的抽象程度应该与其稳定程度保持一致&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;基本上任何组件的设计都会或多或少的遵循以上原则, 所以说我们在实现自定义组件时, 往往也需要考虑内外部的抽象.&lt;/p&gt;&lt;section&gt;我们定义&lt;code&gt;Dooring&lt;/code&gt;的自定义组件时, 会分为以下几个步骤:&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4511691884456671&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114997K9ehUwcDh5cb9c1qZjL21ZYHLjKkMXoZx6DUaLQZk7eufCiajZZYR8ScjBLPENRzNhFFIcrmiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1454&quot;/&gt;&lt;/p&gt;&lt;p&gt;组件的&lt;code&gt;shape&lt;/code&gt;主要是组件对外暴露的属性和方法, 可以实现用户层面的配置, 也就是&lt;code&gt;vue/react&lt;/code&gt;组件的&lt;code&gt;props&lt;/code&gt;, 由于项目使用&lt;code&gt;typescript&lt;/code&gt;编写, 所以我们需要定义对应的&lt;code&gt;ts&lt;/code&gt;类型, 来实现组件的健壮性和可溯源. 最后我们会定义组件初始化的样子(&lt;code&gt;init shape&lt;/code&gt;), 然后才是实现组件, 这样的步骤好处是我们可以明确组件的边界, 自然贴合上面笔者说的组件设计原则.&lt;/p&gt;&lt;p&gt;以上流程我们会产生如下三个文件:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;componet&lt;/strong&gt; 组件的实现代码&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;schema&lt;/strong&gt; 组件的&lt;code&gt;shape&lt;/code&gt;和&lt;code&gt;type&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;template&lt;/strong&gt; 组件的类型映射模版&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;开发一个日历组件&lt;/h3&gt;&lt;p&gt;我们接下来就来实现拖拽平台的&lt;strong&gt;日历组件&lt;/strong&gt;. 日历组件我们直接采用&lt;code&gt;zarm&lt;/code&gt;的&lt;code&gt;Calendar&lt;/code&gt;组件, 将其封装成&lt;code&gt;dooring&lt;/code&gt;的受控组件.&lt;/p&gt;&lt;p&gt;日历组件我们可以暴露如下props给到用户自行配置:&lt;/p&gt;&lt;p&gt;对应的&lt;code&gt;view&lt;/code&gt;如下:&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5691854759568205&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114997K9ehUwcDh5cb9c1qZjLBgviah8icQN2JBVbiceicc2QNUicL628l0lvVHGmUZS58EYzGoNibhLvn1Tw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2038&quot;/&gt;&lt;/p&gt;&lt;section&gt;由于组件的实现只需要处理传过来的数据, 这里我们看看简单的代码实现:&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; React, { useState, memo, useEffect, useRef } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { Calendar } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;zarm&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; styles &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./index.less&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { ICalendarConfig } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./schema&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; CalendarCp = memo(&lt;span&gt;(&lt;span&gt;props: ICalendarConfig &amp;amp; { isTpl: boolean }&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { time, range, color, selectedColor, round, isTpl } = props;&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;{styles.calenderWrap}&lt;/span&gt; &lt;span&gt;style&lt;/span&gt;=&lt;span&gt;{{borderRadius:&lt;/span&gt; &lt;span&gt;round&lt;/span&gt; + &#x27;&lt;span&gt;px&lt;/span&gt;&#x27;, &lt;span&gt;pointerEvents:&lt;/span&gt; &lt;span&gt;isEditorPage&lt;/span&gt; ? &#x27;&lt;span&gt;none&lt;/span&gt;&#x27; &lt;span&gt;:&lt;/span&gt; &#x27;&lt;span&gt;initial&lt;/span&gt;&#x27;}} &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;{boxRef}&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;Calendar&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;multiple&lt;/span&gt;=&lt;span&gt;{!!range}&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;value&lt;/span&gt;=&lt;span&gt;{value}&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;min&lt;/span&gt;=&lt;span&gt;{min}&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;max&lt;/span&gt;=&lt;span&gt;{new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;(&lt;span&gt;max&lt;/span&gt;)}&lt;br/&gt;        &lt;span&gt;disabledDate&lt;/span&gt;=&lt;span&gt;{(date:any)&lt;/span&gt; =&amp;gt;&lt;/span&gt; /(0|6)/.test(date.getDay())}&lt;br/&gt;        onChange={(value:Date[] | undefined) =&amp;gt; {&lt;br/&gt;          setValue(value);&lt;br/&gt;        }}&lt;br/&gt;      /&amp;gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; CalendarCp;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;这是一个&lt;code&gt;dooring&lt;/code&gt;组件的基本雏形, 其次我们看看 &lt;code&gt;schema&lt;/code&gt; 部分. 这一部分主要包含了组件的&lt;code&gt;shape&lt;/code&gt;的类型定义和基本的可编辑属性(editable), 如下:&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; TCalendarEditData = &lt;span&gt;Array&lt;/span&gt;&amp;lt;INumberConfigType | ITextConfigType | IColorConfigType&amp;gt;;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; ICalendarConfig {&lt;br/&gt;  time: TTextDefaultType;&lt;br/&gt;  range: TTextDefaultType;&lt;br/&gt;  color: TTextDefaultType;&lt;br/&gt;  selectedColor: TTextDefaultType;&lt;br/&gt;  round: TNumberDefaultType;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; ICalendarSchema {&lt;br/&gt;  editData: TCalendarEditData;&lt;br/&gt;  config: ICalendarConfig;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; Calendar: ICalendarSchema = {&lt;br/&gt;  editData: [&lt;br/&gt;    {&lt;br/&gt;      key: &lt;span&gt;&#x27;time&#x27;&lt;/span&gt;,&lt;br/&gt;      name: &lt;span&gt;&#x27;日历时间&#x27;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Text&#x27;&lt;/span&gt;,&lt;br/&gt;      placeholder: &lt;span&gt;&#x27;格式如2020-01或2020-11&#x27;&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      key: &lt;span&gt;&#x27;range&#x27;&lt;/span&gt;,&lt;br/&gt;      name: &lt;span&gt;&#x27;日历选中范围&#x27;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Text&#x27;&lt;/span&gt;,&lt;br/&gt;      placeholder: &lt;span&gt;&#x27;格式如01-12(几号到几号)&#x27;&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      key: &lt;span&gt;&#x27;color&#x27;&lt;/span&gt;,&lt;br/&gt;      name: &lt;span&gt;&#x27;文本颜色&#x27;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Color&#x27;&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      key: &lt;span&gt;&#x27;selectedColor&#x27;&lt;/span&gt;,&lt;br/&gt;      name: &lt;span&gt;&#x27;选中颜色&#x27;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Color&#x27;&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      key: &lt;span&gt;&#x27;round&#x27;&lt;/span&gt;,&lt;br/&gt;      name: &lt;span&gt;&#x27;圆角&#x27;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Number&#x27;&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;  ],&lt;br/&gt;  config: {&lt;br/&gt;    time: &lt;span&gt;&#x27;2020-12&#x27;&lt;/span&gt;,&lt;br/&gt;    range: &lt;span&gt;&#x27;05-08&#x27;&lt;/span&gt;,&lt;br/&gt;    color: &lt;span&gt;&#x27;rgba(0,0,0,1)&#x27;&lt;/span&gt;,&lt;br/&gt;    selectedColor: &lt;span&gt;&#x27;rgba(22,40,212,1)&#x27;&lt;/span&gt;,&lt;br/&gt;    round: &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; Calendar;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果我们想增加属性, 我们只需要在这个文件里添加对应的属性和类型即可.&lt;/p&gt;&lt;p&gt;&lt;code&gt;template&lt;/code&gt;主要是定义了组件的分区和初始高度, 代码如下:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; template = {&lt;br/&gt;  &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Calendar&#x27;&lt;/span&gt;,&lt;br/&gt;  h: &lt;span&gt;185&lt;/span&gt;,&lt;br/&gt;  displayName: &lt;span&gt;&#x27;日历组件&#x27;&lt;/span&gt;,&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; template;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有了以上三个部分, 我们要可以渲染出一个在画布中可拖拽, 可编辑的组件了. 当然这块还需要&lt;code&gt;FormRender&lt;/code&gt;的帮助, 这块笔者后期会介绍.&lt;/p&gt;&lt;p&gt;以上基本就实现了一个可拖拽可配置的日历组件, 我们接下来继续看看地图组件.&lt;/p&gt;&lt;h3&gt;开发地图组件&lt;/h3&gt;&lt;section&gt;有了以上的组件开发经验之后我们开发地图组件就非常方便了. 地图组件我们这里使用了&lt;code&gt;@uiw/react-baidu-map&lt;/code&gt;, 也就是百度地图的&lt;code&gt;React&lt;/code&gt;版本, 大家也可以使用高德地图.&lt;/section&gt;&lt;section&gt;因为地图组件&lt;code&gt;react-baidu-map&lt;/code&gt; 需要提前阅读对应的文档, 这里笔者就不一一介绍了, 我们直接来看如何实现.&lt;/section&gt;&lt;section&gt;同样我们也需要定义好地图对外暴露的&lt;code&gt;props&lt;/code&gt;, 笔者这里简单定义几个可配置的属性:&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;ak&lt;/strong&gt; 百度地图使用凭证, 建议大家在生产环境替换成自己的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;location&lt;/strong&gt; 地点的经纬度, 方便快速定位&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;position&lt;/strong&gt; 地点的地名, 我们可以自定义设置&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;如下图:&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3662667607621736&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114997K9ehUwcDh5cb9c1qZjLIpfibr3xwK2jDjrdDibC36E8tjBUTsIfSLdPd0qMF6ibjyp0ibTlkEOkiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2834&quot;/&gt;&lt;/p&gt;&lt;p&gt;基本的代码实现如下:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; React, { memo } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { &lt;span&gt;Map&lt;/span&gt;, Marker, Label, APILoader } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@uiw/react-baidu-map&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; styles &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./index.less&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { IMapConfig } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./schema&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; Mapcomponent = memo(&lt;span&gt;(&lt;span&gt;props: IMapConfig&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { ak, location, position } = props;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;{styles.mapWrap}&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&amp;lt;&lt;span&gt;APILoader&lt;/span&gt; &lt;span&gt;akay&lt;/span&gt;=&lt;span&gt;{ak}&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;Map&lt;/span&gt; &lt;span&gt;widget&lt;/span&gt;=&lt;span&gt;{[&lt;/span&gt;&#x27;&lt;span&gt;NavigationControl&lt;/span&gt;&#x27;]} &lt;span&gt;zoom&lt;/span&gt;=&lt;span&gt;{13}&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&amp;lt;&lt;span&gt;Marker&lt;/span&gt; &lt;span&gt;animation&lt;/span&gt;=&lt;span&gt;{2}&lt;/span&gt; &lt;span&gt;position&lt;/span&gt;=&lt;span&gt;{{&lt;/span&gt; &lt;span&gt;lng:&lt;/span&gt; &lt;span&gt;position&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;], &lt;span&gt;lat:&lt;/span&gt; &lt;span&gt;position&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;] }} /&amp;gt;&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&amp;lt;&lt;span&gt;Label&lt;/span&gt; &lt;br/&gt;                &lt;span&gt;content&lt;/span&gt;=&lt;span&gt;{location}&lt;/span&gt; &lt;br/&gt;                &lt;span&gt;position&lt;/span&gt;=&lt;span&gt;{{&lt;/span&gt; &lt;span&gt;lng:&lt;/span&gt; &lt;span&gt;position&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;], &lt;span&gt;lat:&lt;/span&gt; &lt;span&gt;position&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;] }} &lt;br/&gt;                &lt;span&gt;style&lt;/span&gt;=&lt;span&gt;{{color:&lt;/span&gt; &#x27;#&lt;span&gt;000&lt;/span&gt;&#x27;, &lt;span&gt;borderColor:&lt;/span&gt; &#x27;#&lt;span&gt;06c&lt;/span&gt;&#x27;, &lt;span&gt;padding:&lt;/span&gt; &#x27;&lt;span&gt;3px&lt;/span&gt; &lt;span&gt;10px&lt;/span&gt;&#x27;, &lt;span&gt;borderRadius:&lt;/span&gt; &#x27;&lt;span&gt;6px&lt;/span&gt;&#x27;}} &lt;br/&gt;              /&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;Map&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&amp;lt;/&lt;span&gt;APILoader&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;      )&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; Mapcomponent;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;最后&lt;/h3&gt;&lt;p&gt;目前&lt;code&gt;H5-Dooring&lt;/code&gt;可视化搭建平台还在持续更新, 主要更新如下:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;列表组件添加搜索功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;图标组件添加链接交互功能, 自定义文本, 文本颜色, 文本大小配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;图表组件支持自定义第三方api接口, 一键导入第三方数据源&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&amp;amp;mid=2247485574&amp;amp;idx=1&amp;amp;sn=17ae656f6543fccc4c38115cf2646e6b&amp;amp;chksm=fc53117dcb24986bfded01740e39cbbf2d16d3f4c6f233a6329dde037abedb947b300285fb97&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;0.4539969834087481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114997K9ehUwcDh5cb9c1qZjLZHYIcUL1Q4brCJc1ia4kat7ibloEKDk0dS6R8fOa4M1c35srroiaDvvibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1326&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;觉得有用 ？喜欢就收藏，顺便点个赞吧，你的支持是我最大的鼓励！微信搜 “趣谈前端”，发现更多有趣的H5游戏, webpack，node，gulp，css3，javascript，nodeJS，canvas数据可视化等前端知识和实战.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.4857142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CwPySK2r5CE47scZ6DBwGdmJx3mfuSicKfqOTvIu9KmpgAz4x2Z3lBKCE9FFkft4hXuRLpMuQGlIgnTzmEbEJhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;140&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.6333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SgwKw0EHW0pzWDAyiaNdnsOmb46T4zcDugsibNXY4gacGR7LaNf9wy5q6PEnRia81lbbn9iaBJH1T1PPs7whZaFgzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;60&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点个&lt;span data-mid=&quot;&quot;&gt;在看&lt;/span&gt;你最好看&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5844f6dcaaed5f4ed02d5483103d35ec</guid>
<title>数据管理流程，基础入门简介</title>
<link>https://toutiao.io/k/ilpdshj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1&gt;&lt;span&gt;一、基础思维&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;数据在现在互联网的行业中可以说是最核心的话题，数据的价值已经被称为资产了，大部分的互联网应用都会源源不断的产生各种数据，如何管理和使用这些数据，让这些看似平常的数据产生更大的价值，一直是热门的探索领域。比如常见的风控、营销、推广等各种业务，都需要依赖大量的用户行为数据作为依赖，才能精准的对相关流程做出分析判断。&lt;/p&gt;&lt;p&gt;数据管理是一项复杂而且庞大的工程，需要付出的时间和成本非常高，通常的说法就是对用户有效的数据进行采集，存储，分析，组建业务模型，二次业务应用，以此让数据发挥更大的价值。&lt;/p&gt;&lt;p&gt;在企业考虑做数据沉淀管理时候，通常这里有一个基础的考虑，数据量是否庞大，搭建起的数据管理体系能带来的收益是否能覆盖成本；对于企业来说，很多事情做起来都是对的，但是不一定是对自身发展是有益的；如果基于数据管理，能带来更多业务收益，那这个庞大的工程自然值得投入。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、业务与数据&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;这里再从实际流程来看这个问题，通常一个项目在开发初期时候，为节约成本都会采取快速迭代的方式，基于产品设计和用户使用分析，不断快速升级，在这一过程中也是数据不断积累的过程，一个方向清晰的产品发展的基本过程：产品核心功能实现，丰富和优化流程，产品分析的数据报告。这是一个项目开发的基本初期流程，如果产品没有成功，过程到这就基本结束，成本不会过高，当然如果产品成功了，那后续产品的发展方向怎么确定，就是另一个大的话题。&lt;/p&gt;&lt;p&gt;通常会从两个方面考虑稳定产品的后续方向：1.借鉴市面上类似产品，去分析成功的原因；2.基于现有的业务流程产生的数据，判断产品的亮点和糟点；通常根据产品现有数据做分析是最常见的操作，在实际互联网产品中，就有活脱脱的案例：&lt;/p&gt;&lt;p&gt;媒体类APP会根据用户浏览行为推荐信息，你感兴趣的内容会不断推送；电商类APP会根据季节或日期或搜索行为，推荐特定的商品，提高成交量；社交类APP会根据多个纬度的使用数据做相应的广告植入，精准分发；&lt;/p&gt;&lt;p&gt;以上这些实际的案例，都是在互联网产品中很常见的操作，都是基于产品业务流程，不断积累数据，然后针对自身数据的沉淀，做二次数据分析，再次应用到业务层产生非常高的价值。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、自动化流程&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;数据管理的流程需要自动化，这个是最基础的操作，如果基于数据的流程不能自动，那就完全没有必要，例如数据完整的周期从业务数据产生，分析沉淀，可视化分析，二次应用，这里流程只有自动化管理才能源源不断的提供稳定的服务。数据管理中的一个核心因素就是效率，追求效率就要依赖自动的流程，拿一个简单的案例来说：今天天气很冷，用户浏览防寒商品，如果产品不快速响应，做好相关分析和推荐服务，那过了今天很可能用户已经没有购买意愿，或者已经在其他平台下单了，大部分用户的行为都是有时效性存在的，这对于交易类产品尤其重要。而对于社交类或者信息流的产品，用户的行为画像至关重要，基于自动的行为分析，源源不断的丰富用户的行为画像，以此更加精准的判断用户心理，提高产品的粘性。&lt;/p&gt;&lt;p&gt;所以数据管理的最终产品形态，工具智能化分析，流程自动化管理，快速判断用户行为，精准响应，这才能最大发挥业务数据的价值。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、服务升级&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;任何一款产品，如果源源不断的用户注册使用，产生大量的数据，都很容易发展成为一款超级应用，或者生态平台。支撑这些业务的都是依靠用户和用户数据。例如社交产品提供精准的营销服务平台；金融产品提供风控分析；电商产品提供消费能力分析；这些服务都是基于用户海量庞大行为数据，做的分析推测，一旦这些生态关系形成，产品必然会发展成为平台。同样的数据，可以提供多次服务是数据管理的一个特点，例如某平台知道用户精准的购买意向，那这个数据能服务多少商家，则就看这个平台有多少合作的商家，这就是一条用户分析数据产生的多次业务收益。&lt;/p&gt;&lt;p&gt;所以很多现象级的产品，都是先有自己的数据管理体系，起初服务自己业务线，然后顺利发展为平台，开放服务能力，获取更多的客户或者用户，然后不断的优化和服务能力升级，进入良好的发展循环。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3783359497645212&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCjMheLZtcM2iaVMBOpIUKR4CDRCG9FLT5K6NmGXvG7exrW0TSuDjnTKJQ5PDq8j8Y7PHDd17Z3gicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>