<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>bd79ab87ab4028f2092179eda4c172bd</guid>
<title>工具 | 字节跳动开源的，直播中台使用的一个视频动画特效 SDK</title>
<link>https://toutiao.io/k/yf0vasu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;「码农周刊 VIP 会员」推出 30 周啦！感谢亲们的大力支持！第 030 期「码农周刊 VIP 会员专属邮件周报」已发送完毕，请注意查收。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;告诉大家一个好消息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：已有数位上市公司 CTO 低调订阅了我们的「码农周刊 VIP 会员专属邮件周报」，感谢肯定！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;255&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;255&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ7PeUupLzwuuAibicnrRNxKcfCY7fIva78efKsUzANlCCAeuSQEGkGm34rKkzNRpzy6IiaiaHmBNA6DcA/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1238&quot; data-ratio=&quot;2.074666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNav9vLowSXzhicvI2pNda2uuh1EkXbnrbskiag3hkYpeKBbSEXCApcR4nKx56cm8vGsnkxOuL2fBJOibIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;「码农周刊 VIP 会员」是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;简介版&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;码农周刊 VIP 会员 = 全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;详细版&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击「阅读原文」即可查看详细介绍&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;加入「码农周刊 VIP 会员」，与上市公司 CTO 一起成长！&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利，你值得拥有！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;原价 365 元/年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;，现价仅需 108 元！&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;260&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;260&quot; data-ratio=&quot;1.3478260869565217&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavibNJDoLvVWUq6RKn5LwtlzRHSMFBED29234hRwibmOzJF4XxKOv5lzRVCelQJIEIOaXh3vYRHOMRzQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d7c5088e35dc4005008d9237984d98de</guid>
<title>备受争议的 PHP 前景究竟如何？我们该何去何从？</title>
<link>https://toutiao.io/k/rvi2msw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content article-content&quot; id=&quot;post-content&quot;&gt;
                                &lt;p&gt;导语：&lt;/p&gt;
&lt;p&gt;最近以来，小编在网上总是会看到这样或那样的关于php的新闻或者信息。比如，PHP一直是被黑。尤其是一些培训机构不断设置编程语言排名，以促进python和Java等语言的培训，从而误导了编程的初学者，并给初学者以PHP不好的印象。&lt;br/&gt;
&lt;img src=&quot;https://wjcms.oss-cn-beijing.aliyuncs.com/blog//v2-054788b296eea7845fb936e7659d22c4_720w_1605351728440.jpg?x-oss-process=style/watermark&quot; alt=&quot;v2054788b296eea7845fb936e7659d22c4_720w.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PHP真的下坡了吗？ PHP语言占据什么市场份额？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从市场份额来看。您可能需要根据W3Techs提供的数据和报告，查看最新的PHP使用情况统计信息和市场地位。 W3Techs是一个外国网站，专门从事网络技术研究，并提供有关各种网络技术使用的信息。从最新的结果中，我们可以看出其服务器端编程语言的所有网站中，有79％使用PHP，稳居第一！将排在第二位的ASP.NET和第三位的JAVA远远甩在身后。&lt;br/&gt;
&lt;img src=&quot;https://wjcms.oss-cn-beijing.aliyuncs.com/blog//20201114151307_1605351744130.jpg?x-oss-process=style/watermark&quot; alt=&quot;20201114151307.jpg&quot;/&gt;&lt;br/&gt;
而且，从十月以来全球增长的网站来看，php也排在第二位。&lt;br/&gt;
&lt;img src=&quot;https://wjcms.oss-cn-beijing.aliyuncs.com/blog//20201114151037_1605351758310.jpg?x-oss-process=style/watermark&quot; alt=&quot;20201114151037.jpg&quot;/&gt;&lt;br/&gt;
从编程语言排名来看。PHP自2001年该指数开始以来，PHP一直处于TIOBE指数的前10位，地位从未动摇。&lt;br/&gt;
&lt;img src=&quot;https://wjcms.oss-cn-beijing.aliyuncs.com/blog//20201114121130_1605351783248.jpg?x-oss-process=style/watermark&quot; alt=&quot;20201114121130.jpg&quot;/&gt;&lt;br/&gt;
而且，PHP常年平均排名处于前列，第四位和第七位，它甚至是2004年TIOBE的年度编程。&lt;br/&gt;
&lt;img src=&quot;https://wjcms.oss-cn-beijing.aliyuncs.com/blog//20201114121226_1605351789877.jpg?x-oss-process=style/watermark&quot; alt=&quot;20201114121226.jpg&quot;/&gt;&lt;br/&gt;
从语言发展来看。PHP最受争议的“弱类型”特性，但是随着语言版本的发布和完善，功能和特性方面的批评开始变少了。HHVM通过hack直接“删除”“弱类型”功能的事实表明HHVM不喜欢“弱类型”功能。但是，在许多PHP程序员看来，这是PHP的主要优势之一。 PHP变量的设计随意而优雅，可向所有河流开放，并为一切准备就绪。语言不是很简单吗？HHVM对PHP的性能提升，让人眼前一亮，而磨刀霍霍的PHP7则让人万分期待。&lt;/p&gt;
&lt;p&gt;还有另外一个最受争议的性能问题，就在前几天刚发布了8.0.0RC4,11月 26 日就会发布正式版本。从&lt;a href=&quot;https://www.phoronix.com/测试性能基准测试报告结果来看，从&quot;&gt;https://www.phoronix.com/测试性能基准测试报告结果来看，从&lt;/a&gt; PHP 7.4 stable 到 PHP 8 有小幅度改进，大约是 7% 的提升，但如果 PHP 8 启用了 JIT，性能改进可以说是非常明显，比 PHP 7.4 stable 提升了 92%。至于更旧的版本，PHP 8 with JIT 的性能是 PHP 5.4 的 5 倍。&lt;br/&gt;
&lt;img src=&quot;https://wjcms.oss-cn-beijing.aliyuncs.com/blog//060022_kYvL_2720166_1605351856641.png?x-oss-process=style/watermark&quot; alt=&quot;060022_kYvL_2720166.png&quot;/&gt;&lt;br/&gt;
最重要的是，越来越多优秀的扩展开发出来，给初中级开发者铺好了更多道路，发挥好社区化开发的路径，能为快速构建出自己的项目，高级程序员能够轻松利用特性，开发出更多好的扩展，构建更强大的生态系统。&lt;/p&gt;
&lt;p&gt;非常多的优秀框架支撑php的强大，例如Symfony/YII/laravel/thinkphp/CI等，在类似项目中重用代码可以节省开发人员大量时间和精力。框架提供了用于执行繁琐的代码任务的预构建模块。因此，开发人员可以花时间开发实际的应用程序，而不必重建每个项目的基本功能。&lt;/p&gt;
&lt;p&gt;结语：&lt;/p&gt;
&lt;p&gt;PHP是有史以来最好的语言，没有之一。PHP一直作为Web开发中的统治力量而存在，在PHP8.0版本的加持下，PHP必将开创新局面，许多PHP专业人员都留在角落，实际上，每个人都必须接受PHP带来的变化和生态。 Swoole解决了IO繁重方案的问题，而JIT解决了计算繁重方案的问题。未来的PHP开发还不错。最后希望大家都成为一名优秀的CTO和架构师。&lt;/p&gt;

                            &lt;/div&gt;
                            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>50006ed97e7ed5d10c4d313724fb737f</guid>
<title>阿里 Sentinel 框架的一些小扩展</title>
<link>https://toutiao.io/k/z99zluq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 是面向分布式服务架构的流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统自适应保护等多个维度来帮助您保障微服务的稳定性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天给大家介绍一些在使用过程中会遇到的一些问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;SentinelResource 埋点监控&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@SentinelResource 可以作用于方法上的熔断降级保护，跟 Hystrix 的@HystrixCommand 注解作用是一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做监控的目的是为了在业务方法触发了熔断降级规则后，在对应的监控视图中可以看到这个操作触发了对应的规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@SentinelResource 的工作依赖于 SentinelResourceAspect 这个切面，需要监控的话对 SentinelResourceAspect 这个类进行改造就可以了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;流控熔断预警&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在流量突然上升的时候，也就意味着随时都可能迎来请求量的高峰，就会触发限流。我们也需要有一定的监控手段来提前告警，这种场景可以扩展 Slot 来实现提前告警的方案，具体方式可以查询这篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMDY0Nzk2Mw==&amp;amp;mid=2650321134&amp;amp;idx=1&amp;amp;sn=5b18e25bba5d2113f0f0fcbd4b6f261a&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;https://mp.weixin.qq.com/s/qhep2f9HgK7sZFcdKMAMVg&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RestFul API 处理&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Sentinel 中，以资源的概念来进行对应的限流熔断操作。如果你们的 API 是 RestFul 风格，就会出现同一个接口变成 N 个资源的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以用@SentinelResource 为每个接口固定好资源名，这样比较繁琐。所以需要对这类的 API 进行格式化，变成一个资源。相关实现参考：https://blog.csdn.net/luanlouis/article/details/91633042还挺全的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心原理就是重写 UrlCleaner 的实现逻辑，利用正则进行匹配处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这类操作不仅仅是在 Sentinel 中会遇到，在其他的框架中也经常会遇到这种情况。比如在 Cat 中也会有类似场景，对 API 进行监控，如果不处理同样会出现 N 个监控项。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Origin 来源限制&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果需要对某个调用方进行限流，我们可以利用 Origin 方式来实现。建议做成动态配置方式，比如支持 IP, 支持请求头中的参数等方式进行限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内部服务之间调用还可以将本服务的应用名存放在请求头中传递过去，这样就可以在 Sentinel 中基于 Origin 来实现内部服务调用的流量控制。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6689466484268126&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39wJ8jrAVewuO1fz59L1aPjfraFseNguxQCiblnoHlnmc23YcImXONRibjfEpXOGYUiaAbjM1ToeHaQPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1462&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;热点参数动态流控&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于热点参数的流控，也可以做成动态配置的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如当前是商品 ID 为热点参数，后面是订单 ID 为热点参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如当前是商品接口，后面是订单接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以从 url 参数中获取热点参数，可以从 header 中获取热点参数，可以从 path 路径中获取热点参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;增加一个配置信息，然后扩展 Sentinel 的 Filter 进行限流控制，根据配置获取对应的热点参数进行限流。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8812785388127854&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39wJ8jrAVewuO1fz59L1aPjfOa6RyYxLz8mniafIHkOiasI6qXVCKRUKuibboV5o9MjoCmKXJVX7j6Cjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1314&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;限流规则持久化&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限流规则持久化是肯定要做的，默认规则是存储在内存中，这样一起动规则就丢失了，所以必须持久化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;持久化分为两种，首先是客户端，客户端持久化意思是说客户端需要加载对应的规则，这些规则会从一个地方进行获取，比如我们用 Apollo 配置中心来存储的话，客户端在启动时就会从 Apollo 中去拉取对应的规则信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应的操作步骤和详细介绍可以查看下面这篇文章，虽然写了很久了，但是总体思路什么的都没变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sentinel Client: 整合 Apollo 规则持久化：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMDY0Nzk2Mw==&amp;amp;mid=2650320129&amp;amp;idx=1&amp;amp;sn=ed46a21c9b3656fc10395840a2e45f50&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;https://mp.weixin.qq.com/s/K9JtdGoLD1XALq5D67slPQ&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后是服务端也就是控制台的持久化，我们可以在控制台进行规则的添加和编辑，然后会把对应的配置信息推送给所有的客户端，这样规则就生效了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样存储重启即丢失的情况，所以控制台也需要进行持久化规则。如果客户端对接了 Apollo,那么控制也需要对接 Apollo 将规则信息存储到 Apollo 中，这样整个流程就连起来了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以参考这篇文章：阿里 Sentinel 控制台:-整合 Apollo 规则持久化：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMDY0Nzk2Mw==&amp;amp;mid=2650320158&amp;amp;idx=1&amp;amp;sn=5c5522f49fb99504818883a9f12104ac&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;https://mp.weixin.qq.com/s/deigVXhEd9HycuLLm-oJzA&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;监控数据持久化&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.17760416666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39wJ8jrAVewuO1fz59L1aPjfnTd13Bu5hdF4eaJN1ZCXz7LVicZDDUgWn3bicibJmz7ibvlgibyPdc8ibjmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;官方说明&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sentinel 控制台的实时监控数据，默认仅存储 5 分钟以内的数据。如果需要持久化，需要实现框架提供的相关接口进行改造。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5 分钟确实很短，最起码要存储最近 3 天的数据，这样方便查看流量的趋势。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于相关实现大家可以去看文档，比较简单，主要就是实现 MetricsRepository，将监控的数据存储到对应的数据库中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相关改造源码可以参考：https://github.com/yinjihuan/kitty/tree/master/kitty-distributed/kitty-distributed-sentinel&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;关于作者&lt;/strong&gt;：尹吉欢，简单的技术爱好者，《Spring Cloud 微服务-全栈技术与案例解析》, 《Spring Cloud 微服务 入门 实战与进阶》作者, 公众号&lt;strong&gt;猿天地&lt;/strong&gt;发起人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我整理了一份很全的学习资料，感兴趣的可以微信搜索「&lt;strong&gt;猿天地&lt;/strong&gt;」，回复关键字 「&lt;strong&gt;学习资料&lt;/strong&gt;」获取我整理好了的 Spring Cloud，Spring Cloud Alibaba，Sharding-JDBC 分库分表，任务调度框架 XXL-JOB，MongoDB，爬虫等相关资料。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>69a87f2a8a4209969f2b78f3418f2482</guid>
<title>Go 语言今年 11 岁，何去何从，现状到底如何？</title>
<link>https://toutiao.io/k/wj2n55o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不说不知道，一说下一跳。Go 语言已经开源 11 周年了，感觉是一路高歌，Release History （polarisxu 整理）如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;2011 年 3 月 16 日，Go 语言的第一个稳定版本 r56 发布；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2012 年 3 月  28 日，Go 语言的第一个正式版本 Go1 发布，并承诺 1.x 的 兼容性；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2013 年  5 月 13 日，Go1.1 正式版才发布。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2013 年 12 月 1 日，Go1.2 正式发布；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2014 年 6 月 18 日，Go1.3 正式发布；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2014 年 12 月 10 日，Go1.4 正式发布；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2015 年 8 月 19 日，Go1.5 正式发布。该版本实现了自举，即移除了 C 代码，使用 Go 开发 Go 语言；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2016 年 2 月 17 日，Go1.6 正式发布；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2016 年 8 月 15 日，Go1.7 正式发布；引入 context 包；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2017 年 2 月 17 日，Go1.8 正式发布；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2017 年 8 月 24 日，Go1.9 正式发布；引入别名；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2018 年 2 月 16 日，Go1.10 正式发布；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2018 年 8 月 25 日，Go1.11 正式发布。开始强势支持 Go modules；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2019 年 3 月 1 日，Go1.12 正式发布；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2019 年 9 月 3 日，Go1.13 正式发布；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2020 年 2 月 25 日，Go1.14 正式发布；goroutine 支持异步抢占调度；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2020 年 8 月 11 日，Go1.15 正式发布；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2021 年 2 月，预计 Go1.16 正式发布；将包含新的文件系统接口和支持在构建时的静态文件嵌入，链接器的重写，Go modules 默认开启且正式对 Apple Silicon（GOARCH=arm64）Mac 进行支持。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;目视现在&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在的 Go 语言在国内已经掀起了一浪又一浪的热潮，炒的非常火热。各大平台极客时间、拉勾教育、掘金小册、慕课网等纷纷出现了大量 Go 语言相关的付费专栏/视频。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在现实工作层面，字节跳动、腾讯向 Go 语言侧偏，以及其它各大一二线厂均出现了不少 Go 的岗位，也正预示着当前已经到了一个比较好风口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开源项目层面，Kubernetes、Etcd、Prometheus、Docker 等大量的云原生相关组件均以 Go 语言开发，懂一门 Go 语言，排查问题也更方便了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与企业开发层面，出现了大量其他语言的开发者向 Go 语言转型，在企业的软件开发中出现，新项目用 Go 语言，老项目保留，形成同时维护新老系统，再渐迁的绞杀者模式：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3011456628477905&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iaicRJAsprHDX2871dhx9Z0Eb0ePX8s2Qocp6ib05xsGNYkjxEcyBFr1eezAeDQaEUUYJmATp4a9f4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1833&quot;/&gt;&lt;figcaption&gt;绞杀者模式&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在面试中比较常见的是 PHP、C++ 语言，就会在企业中形成了 Go+PHP（新+老系统）的局面，又或是 Go 调 CGO 的运行模式。这也得益于 Go 语言的易用性和一定的胶水特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在培训机构层面，各大机构都多少曾经向 Go 语言发起过进攻，但目前 Go 语言大多以中高级人才为主，也就是有过其他语言经验的软件开发从业者为主。因此培训机构的市场行情相对较差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在社会招聘和岗位层面，狭义上来看，与 2018 年我写的 《带你了解一下Golang的市场行情》基本情况仍保持一致：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5930434782608696&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iaicRJAsprHDX2871dhx9Z0EzRDaJeBKPrECbQILSHHuLIzzqplwqacUGeMoC0jNs6K5bdfGTJ9Yjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1150&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;2018 年市场行情分析&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下为 GoCN 所收集的 “2020 中国Go 开发者调查报告” 的地域分布：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3491879350348028&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iaicRJAsprHDX2871dhx9Z0EBPQpDb8OG1NGxNMbKDD2ZE8kafa25gQkiaCwaLXC0gdoXLwXCEPOZVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1724&quot;/&gt;&lt;figcaption&gt;2020 中国Go 开发者调查报告&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言的大热门地区依然是：北京、上海、深圳，主体集中在一线城市，机会这里最多。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;看看数据：TIOBE&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 TIOBE 的编程语言排行榜来看，整体上 Go 语言的热门程度并不会特别高（与老牌语言相比），但作为一门编程语言在短短 11 年内已有很不错的表现：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6041884816753926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4iaicRJAsprHDX2871dhx9Z0E4654YCiasn0WREdIcAcIJRKtCtEFGfYVPuPKpM6R670vwFordmFfA1g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1910&quot;/&gt;&lt;figcaption&gt;TIOBE 排行榜&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时业内时常说 Go 语言要干掉 PHP、C++、Java 等，目前来看短期内不现实，官方也没有这方面打算，因为合适的场景选择合适的语言就好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TIOBE 提示本月的排名在第 13 名，且最高排名出现在 2020 年 5 月，在第 10 名，近期基本稳定在这个位数附近，至少近年是干不掉老大哥们的。&lt;span/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;展望未来&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go1 目前一如既往的遵守了 Go1 兼容性承诺，这给不少正在使用 Go 语言的企业带来了一注强心针。但给 Go 语言也带来了一些 “麻烦”。那就是存在破坏性变更的变动无法在 Go1 中实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此为了解决一些 ”问题“，也想达到更好的特性目标。2018 年时释出了 Go2 的计划，详细可参见Go 2, here we come!，其中包含了大量的功能特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从目前的基本论调和实际情况来看，可兼容实现的，都会在 Go1 实现，例如大家最期待的功能之一 ”泛型“，预计最早会在 Go1.17 会释出，样例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// Print prints the elements of any slice.&lt;br/&gt;// Print has a &lt;span&gt;type&lt;/span&gt; parameter T and has a single (non-type)&lt;br/&gt;// parameter s &lt;span&gt;which&lt;/span&gt; is a slice of that &lt;span&gt;type&lt;/span&gt; parameter.&lt;br/&gt;func Print[T any](s []T) {&lt;br/&gt; // same as above&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其在 6 月下旬发布了最新的设计草稿，若对泛型有更进一步需求可关注 design/go2draft-type-parameters，而一些不兼容的修改，若确切评估后无法直接实现的，将会到 Go2 的 计划中去：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.07985803016858918&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4iaicRJAsprHDX2871dhx9Z0EtK636JiaeIlnZ5ODoEgJxG7Pq8eIEWfKFUHrZPDP4zh5aA00zS2wnIA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2254&quot;/&gt;&lt;figcaption&gt;Milestones&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信 Go2 发布时，肯定也不是 &lt;code&gt;go run xxx&lt;/code&gt; 了，估计会变更命令集，以示区分。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;11 岁，Go 语言目前在国内已经火起来了，最近接触的一个运营大佬称 Go 语言为 “准备霸占未来语言半壁江山” 的语言。&lt;span&gt;还在观望的读者可以考虑下手，吃一波红利。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但现阶段的 ”成功“ 并不代表后续一定持续强劲，背后离不开所有开发者在社区开源的努力。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5093715545755237&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4iaicRJAsprHDX2871dhx9Z0EhaQGibsdwZI12U6xmBcPv8h92yHd0FdP9Gf13O4SKW7kZ7V4icyWoibVg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1814&quot;/&gt;&lt;figcaption&gt;TIOBE Index&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一起思考两个问题：&lt;span/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;你为什么喜欢 Go 语言？他有什么短板？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果 Go 语言想继续占领更多的市场，需要在什么领域发力？&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你的答案是什么？在评论区告诉大家吧！&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分享 Go 语言、微服务架构和奇怪的系统设计&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jDrh1vIHLPh0nz30kZpJxyf1X5pQ4zXM1IGBN5fkpuMrbqLDPTYYk7g5emAOT7jcicTDodld1Nu3Q/0?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;344&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;344&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jDrh1vIHLPh0nz30kZpJxyz1YLWMsJvSmd3ZmCN67m6QRSz5yV1ZM22JUAW1ga6BK5ztEatjkoOA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;1&quot; data-w=&quot;344&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;👆 长按关注煎鱼，在知识的海洋里遨游&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;来一个反馈！&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e112a9896732930cf3094681373aa384</guid>
<title>设计模式大冒险第三关：工厂模式，封装和解耦你的代码</title>
<link>https://toutiao.io/k/1jjvoah</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章是关于&lt;strong&gt;设计模式系列&lt;/strong&gt;的第三篇文章，这一系列的每一篇文章都会通过生活中的小例子以及一些简单的比喻让大家明白每一个设计模式要&lt;strong&gt;解决的是什么问题，然后通过什么方式解决的&lt;/strong&gt;。希望大家在看过每篇文章之后都能够理解文章中讲解的设计模式，然后有所收获。话不多说，让我们开始今天的冒险吧。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;工厂模式的第一印象&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于初次听说这个设计模式的同学来说，你们的第一印象是什么呢？&lt;strong&gt;既然是工厂模式，那么肯定跟工厂的一些功能或者行为有关系&lt;/strong&gt;。那么工厂都有哪些功能和行为呢？首先工厂收集原始材料，然后将原始的材料进行加工，处理，设计之后就变成了一个完整的产品或者部件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这个过程对于产品的销售店，或者用户来说是不可见的&lt;/strong&gt;。对于商家来说如果你想卖这个产品，你只需要去跟厂家沟通买一批这样的产品就行了。那对于用户来说，你想使用这个产品，只需要到卖这个产品的店里把它买回来就好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以根据上面的推论，类比到代码中我们可以得出一些初步的结论：&lt;strong&gt;工厂模式封装了对象的创建过程，把创建和使用对象的过程进行了分离，解耦代码中对具体对象创建类的依赖。让代码更好维护，更方便扩展&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，如果想要知道这个设计模式是如何封装了对象的创建过程，并且减少了对具体类的依赖的话，我们还是要实践一下，通过一些例子或者开发中的场景学习如何使用好这个设计模式。那就让我们开始吧。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;简单工厂&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据对代码&lt;strong&gt;封装&lt;/strong&gt;和&lt;strong&gt;抽象&lt;/strong&gt;的程度，工厂模式的实现方式有三种，它们分别是：&lt;strong&gt;简单工厂&lt;/strong&gt;，&lt;strong&gt;工厂方法&lt;/strong&gt;，以及&lt;strong&gt;抽象工厂&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们首先来学习和了解一下简单工厂吧，假如你现在接手了一个生产蛋糕的程序，程序的部分代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 泡芙蛋糕&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; PUFF_CAKE = &lt;span&gt;&quot;PUFF_CAKE&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;// 奶酪蛋糕&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; CHEESE_CAKE = &lt;span&gt;&quot;CHEESE_CAKE&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PuffCake&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.name = &lt;span&gt;&quot;(泡芙蛋糕)&quot;&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CheeseCake&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.name = &lt;span&gt;&quot;(奶酪蛋糕)&quot;&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CakeMaker&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(type) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (type === PUFF_CAKE) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.cake = &lt;span&gt;new&lt;/span&gt; PuffCake();&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.cake = &lt;span&gt;new&lt;/span&gt; CheeseCake();&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 搅拌原料&lt;/span&gt;&lt;br/&gt;  stirIngredients() {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`开始搅拌&lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.cake.name}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 倒入模具中&lt;/span&gt;&lt;br/&gt;  pourIntoMold() {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`将&lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.cake.name}&lt;/span&gt;倒入模具`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 烘烤蛋糕&lt;/span&gt;&lt;br/&gt;  bakeCake() {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`开始烘焙&lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.cake.name}&lt;/span&gt;蛋糕`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 制作蛋糕&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; cakeMaker = &lt;span&gt;new&lt;/span&gt; CakeMaker(PUFF_CAKE);&lt;br/&gt;cakeMaker.stirIngredients();&lt;br/&gt;cakeMaker.pourIntoMold();&lt;br/&gt;cakeMaker.bakeCake();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在这个制作蛋糕的程序需要新添加一种海绵蛋糕，你要怎么去修改这个程序，让它能够支持生产海绵蛋糕呢？也许你的第一反应就是将&lt;code&gt;CakeMaker&lt;/code&gt;的&lt;strong&gt;构造函数&lt;/strong&gt;进行修改，新增加一个类型的判断，比如像下面这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;constructor&lt;/span&gt;(type) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (type === PUFF_CAKE) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.cake = &lt;span&gt;new&lt;/span&gt; PuffCake();&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type === CHEESE_CAKE) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.cake = &lt;span&gt;new&lt;/span&gt; CheeseCake();&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.cake = &lt;span&gt;new&lt;/span&gt; SpongeCake();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，我们可以思考一下，虽然上面的方法的确可以帮助我们实现添加海绵蛋糕的功能，但是这样做会有一些问题。会有哪些问题呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3852065321805956&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fj9xyC53hPUmFoJ0hF5GDTibJRWbdLX0fUIsltEvq8UkewBzR7BEiaiatUa9bgiafYsneR6U6Ip9NLibVfP7icicNE38A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;10410&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，如果按照这个方式的话，我们以后只要添加新种类的蛋糕或者移除不受欢迎的蛋糕就必须要&lt;strong&gt;修改&lt;/strong&gt;&lt;code&gt;CakeMaker&lt;/code&gt;的&lt;strong&gt;构造函数&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样做实在不是一个好的方案，而且&lt;strong&gt;每当我们在&lt;code&gt;CakeMaker&lt;/code&gt;中新增加一个具体的蛋糕类的话，就相当于给这个类新增加了一个依赖&lt;/strong&gt;。这样我们&lt;code&gt;CakeMaker&lt;/code&gt;的依赖会越来越多，&lt;strong&gt;任何一个依赖类发生改变都可能导致我们的&lt;code&gt;CakeMaker&lt;/code&gt;类不能够正常工作，出错的几率大大增加&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们应该如何修改呢？我们应该减少&lt;code&gt;CakeMaker&lt;/code&gt;类中对具体类的依赖，然后将生成蛋糕种类的过程从&lt;code&gt;CakeMaker&lt;/code&gt;中移除。我们可以这样做：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 封装蛋糕的创建过程&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;cakeCategoryMaker&lt;/span&gt;(&lt;span&gt;type&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; cake;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (type === PUFF_CAKE) {&lt;br/&gt;    cake = &lt;span&gt;new&lt;/span&gt; PuffCake();&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type === CHEESE_CAKE) {&lt;br/&gt;    cake = &lt;span&gt;new&lt;/span&gt; CheeseCake();&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    cake = &lt;span&gt;new&lt;/span&gt; SpongeCake();&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; cake;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CakeMaker&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(type) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.cake = cakeCategoryMaker(type);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你看完了上面的代码，你可能会说，这不只是把代码从一个地方移到了另一个地方，好像没有发生什么根本的变化呀。的确是这样，但是我们来看一下，一旦我们把生成蛋糕种类的代码移到外面，我们的&lt;code&gt;CakeMaker&lt;/code&gt;是不是减少了对具体蛋糕类的依赖。现在对于&lt;code&gt;CakeMaker&lt;/code&gt;类来说，它的依赖只有&lt;code&gt;cakeCategoryMaker&lt;/code&gt;。&lt;code&gt;CakeMaker&lt;/code&gt;不需要管你给我的蛋糕是什么类型的，我只负责对其进行加工制作，并不关心蛋糕的原料和种类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且，&lt;strong&gt;我们的&lt;code&gt;cakeCategoryMaker&lt;/code&gt;还可以被其它的蛋糕加工程序所共享&lt;/strong&gt;；如果以后还需要增加或者移除蛋糕种类的话，我们只需要在这一个地方修改就可以了。而不需要在每个加工蛋糕的代码中分别进行修改。这就是一个很好的编码习惯。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5692025664527957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fj9xyC53hPUmFoJ0hF5GDTibJRWbdLX0f1LEQq0amic8DE8TzheBK2pkgROzVibCWgMqbHqxRMczhicxVEXumicVFVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;10910&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际的开发中，&lt;strong&gt;我们的程序中可能存在需要根据不同场景创建不同类型对象的功能，但是这些对象具有同样的属性和接口，或者需要根据不同的数据源创建相同的对象&lt;/strong&gt;。那么这个时候，&lt;strong&gt;我们就可以把这一部分的逻辑抽离出来，然后在全局中进行使用&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是我们所说的&lt;strong&gt;简单工厂&lt;/strong&gt;了，当然严格意义上来说，简单工厂不算是一个真正的设计模式。但是它很有用，&lt;strong&gt;它封装了根据不同类型来创建不同对象的过程，将我们的程序进行了解耦，这样便于程序的维护和扩展。是一个不错的编程习惯和技巧，值得我们学习和使用&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;工厂方法&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们来了解并学习&lt;strong&gt;工厂方法&lt;/strong&gt;这种更高一级别的封装和抽象。在实际的开发中我们有时会写一些通用的组件，方便我们后续的业务开发使用。假如下面两个组件是已经开发好的组件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Toast&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(text) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.text = text;&lt;br/&gt;  }&lt;br/&gt;  show() {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`toast show: &lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.text}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  hide() {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;toast hide&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Modal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(text) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.text = text;&lt;br/&gt;  }&lt;br/&gt;  show() {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`modal show: &lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.text}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  hide() {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;modal hide&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; toast = &lt;span&gt;new&lt;/span&gt; Toast(&lt;span&gt;&quot;hello&quot;&lt;/span&gt;);&lt;br/&gt;toast.show();&lt;br/&gt;toast.hide();&lt;br/&gt;&lt;span&gt;// modal&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; modal = &lt;span&gt;new&lt;/span&gt; Modal(&lt;span&gt;&quot;world&quot;&lt;/span&gt;);&lt;br/&gt;modal.show();&lt;br/&gt;modal.hide();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面关于组件的代码是没有什么太大问题的，但是我们再仔细思考一下也许会觉得好像这两个组件都有&lt;code&gt;show&lt;/code&gt;和&lt;code&gt;hide&lt;/code&gt;这两个方法。那么这就相当于是重复代码了，一般情况下如果出现了重复的代码那么说明我们还是有优化的地方的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5534665099882491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fj9xyC53hPUmFoJ0hF5GDTibJRWbdLX0feFKpsQu1LXObGsDzBtXIfIgkehM45CcIvd53KrEAZp4fgBORVvrVxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;8510&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;并且如果在不改变现有的思路的情况下&lt;/strong&gt;，我们要再开发一个新的提示类型的组件的话，还是会在代码中重复这两个方法。那么有没有办法解决这个问题呢？当然有办法了，我们知道这种类型的组件都有&lt;code&gt;show&lt;/code&gt;和&lt;code&gt;hide&lt;/code&gt;这两个方法。&lt;strong&gt;那么我们可以通过继承的方式从父类那里继承这两个方法，关于组件的具体创建过程我们可以在子类中进行实现&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体实现的代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CustomComponent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  createComponent() {&lt;br/&gt;    &lt;span&gt;// TODO 需要被子类实现&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  show() {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.concreteComponent = &lt;span&gt;this&lt;/span&gt;.createComponent();&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;br/&gt;      &lt;span&gt;`this &lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.concreteComponent.name}&lt;/span&gt; show: &lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.concreteComponent.text}&lt;/span&gt;`&lt;/span&gt;&lt;br/&gt;    );&lt;br/&gt;  }&lt;br/&gt;  hide() {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`this component hide`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ToastComponent&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;CustomComponent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  createComponent() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&quot;toast&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;text&lt;/span&gt;: &lt;span&gt;&quot;hello&quot;&lt;/span&gt;,&lt;br/&gt;    };&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ModalComponent&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;CustomComponent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  createComponent() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&quot;modal&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;text&lt;/span&gt;: &lt;span&gt;&quot;world&quot;&lt;/span&gt;,&lt;br/&gt;    };&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; toast = &lt;span&gt;new&lt;/span&gt; ToastComponent();&lt;br/&gt;toast.show();&lt;br/&gt;toast.hide();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; modal = &lt;span&gt;new&lt;/span&gt; ModalComponent();&lt;br/&gt;modal.show();&lt;br/&gt;modal.hide();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个解决方案的思路就是：&lt;strong&gt;我们在父类中把子类的一些通用的操作进行实现。然后具体组件的创建细节交给子类去解决。那么这样做就相当于把组件创建的过程进行了封装，父类不需要知道这个组件是如何创建的，被谁创建的。但是这个子类组件已经继承了父类的那些方法，所以可以直接使用父类的方法进行展示和隐藏。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6226415094339622&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fj9xyC53hPUmFoJ0hF5GDTibJRWbdLX0fqnP8llvR11sxWdZ2TfhrOd23OT9ibnBxcB9c0Ru45vicoCdsURxIatJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;9010&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为在&lt;strong&gt;JavaScript&lt;/strong&gt;中暂时还没有实现&lt;strong&gt;抽象类&lt;/strong&gt;的功能，所以我们上面代码中的&lt;code&gt;CustomComponent&lt;/code&gt;类从严格意义上说还不是一个抽象的父类。不过关系不是很大，思路和功能还是能够实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们来总结一下工厂方法的特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;父类通过一个抽象的方法封装了对象的创建过程，对象的创建过程被延迟到子类中进行创建&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;子类因为是从父类继承而来，所以可以使用父类已经实现好的方法&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;工厂方法将我们的代码进行了解耦，创建组件的时候不需要再给父类传递对象的类型，由子类决定创建的对象的类型&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;抽象工厂&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们来讲解一下抽象程度最高的&lt;strong&gt;抽象工厂&lt;/strong&gt;，看过上一篇文章👉&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwMDIzODY5MA==&amp;amp;mid=2247484015&amp;amp;idx=1&amp;amp;sn=98ce49dc27b52205a386b5e2bc30261c&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;设计模式大冒险第二关：装饰者模式，煎饼果子的主场&lt;/strong&gt;&lt;/a&gt;的同学应该知道，由于上次你给煎饼果子的老板帮了个忙。所以他知道你的编程水平不错，今天又来找你帮忙啦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次的问题是这样的，老板说他那边有一个获取煎饼果子原材料的程序，但是最近附近的一个菜市场提供的蔬菜不是很新鲜。所以想换一个菜市场去买原材料，但是更换菜市场的话，之前程序一些统计的数据就不准确了，所以需要让你帮忙修改一下现有的程序。现在的程序部分代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PanCakeMaterials&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(vegetableMarketName) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.vegetableMarketName = vegetableMarketName;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  getEgg() {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.vegetableMarketName === &lt;span&gt;&quot;VEGETABLE_MARKET_NAME_A&quot;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;a_market_egg&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.vegetableMarketName === &lt;span&gt;&quot;VEGETABLE_MARKET_NAME_B&quot;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;b_market_egg&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ... 其它的原料&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; panCakeMaterials = &lt;span&gt;new&lt;/span&gt; PanCakeMaterials(&lt;span&gt;&quot;VEGETABLE_MARKET_NAME_A&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(panCakeMaterials.getEgg());  &lt;span&gt;// a_market_egg&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到现在这个获取原材料的程序&lt;strong&gt;虽然实现了获取原材料的功能，但是现在的扩展性太差。如果添加了新的菜市场或者移除不使用的菜市场的话，就需要修改程序&lt;/strong&gt;。所以又到了你大展身手的时候了，巧的是你刚刚学习完工厂模式的&lt;strong&gt;抽象工厂&lt;/strong&gt;这个解决方案。所以你知道该如何重构现在的代码了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先原来的代码太依赖我们给的类型值了，如果输入的类型值有问题的话，那么整个获取原材料的程序就没有办法运行起来。&lt;strong&gt;所以我们需要将每种食材获取的过程封装起来，由一个&lt;code&gt;VegetableMarketProvider&lt;/code&gt;类来负责，然后对于&lt;code&gt;PanCakeMaterials&lt;/code&gt;来说，我们只需要将&lt;code&gt;VegetableMarketProvider&lt;/code&gt;子类的实例化对象当做传给&lt;code&gt;PanCakeMaterials&lt;/code&gt;类的参数进行初始化就可以了&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现的代码如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;VegetableMarketProvider&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  provideEgg() {}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FirstVegetableMarketProvider&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;VegetableMarketProvider&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  provideEgg() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;a_market_egg&quot;&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SecondVegetableMarketProvider&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;VegetableMarketProvider&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  provideEgg() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;b_market_egg&quot;&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PanCakeMaterials&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(vegetableMarketProvider) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.vegetableMarketProvider = vegetableMarketProvider;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  getEgg() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.vegetableMarketProvider.provideEgg();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ... 其它的原料&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; firstVegetableMarketProvider = &lt;span&gt;new&lt;/span&gt; FirstVegetableMarketProvider();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; secondVegetableMarketProvider = &lt;span&gt;new&lt;/span&gt; SecondVegetableMarketProvider();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; panCakeMaterials = &lt;span&gt;new&lt;/span&gt; PanCakeMaterials(firstVegetableMarketProvider);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(panCakeMaterials.getEgg());  &lt;span&gt;// a_market_egg&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; secondPanCakeMaterials = &lt;span&gt;new&lt;/span&gt; PanCakeMaterials(&lt;br/&gt;  secondVegetableMarketProvider&lt;br/&gt;);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(secondPanCakeMaterials.getEgg());  &lt;span&gt;// b_market_egg&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来分析一下优化后的代码，首先我们写了一个抽象的&lt;code&gt;VegetableMarketProvider&lt;/code&gt;类，这个类里面的所有方法也都是抽象的，需要由子类去实现具体的方法。&lt;strong&gt;每一个子类对应一个具体的菜市场，这样的话每一个菜市场提供的原材料也就知道是什么了&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48741007194244607&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fj9xyC53hPUmFoJ0hF5GDTibJRWbdLX0fLOO3iayowRicYWib4PHSjR0riaWiasFoR4ic1sx2iaQQKnYFPia3uWD5cyjHlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;11120&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于&lt;code&gt;PanCakeMaterials&lt;/code&gt;类来说，&lt;strong&gt;我们不再传递一个表示菜市场类型的字符串了；取而代之的是，传递一个菜市场的实例。这样的话当我们初始化&lt;code&gt;PanCakeMaterials&lt;/code&gt;的时候，对应的菜市场也就确定了，那对应的原材料也就确定了&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的好处有哪些呢？&lt;strong&gt;首先如果我们要更换菜市场，再也不需要改变&lt;code&gt;PanCakeMaterials&lt;/code&gt;类的代码了，只需要更换传给&lt;code&gt;PanCakeMaterials&lt;/code&gt;类的参数就可以了。然后如果需要添加新的菜市场的话，只需要新加一个&lt;code&gt;VegetableMarketProvider&lt;/code&gt;的子类，在子类里面实现相应原材料的获取。这就体现了我们程序设计中的一个原则，对修改关闭，对扩展开放&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过上面的优化，把获取原材料的过程封装到&lt;code&gt;VegetableMarketProvider&lt;/code&gt;的子类中，&lt;strong&gt;然后通过对象组合的方式实现了对菜市场的更换&lt;/strong&gt;，这样的方式进一步解耦了我们的代码，&lt;strong&gt;每一个类都各司其职，保证了职责的单一&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们再来简单总结一下&lt;strong&gt;抽象工厂&lt;/strong&gt;这个方式吧。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;通过使用一个抽象类，把相关的接口进行了定义，然后继承这个抽象类的子类都具有相同的接口和属性。这样用到这些子类的类可以对这些类进行接口编程，而不是在针对具体的类&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;对象的创建过程被封装在子类中，这样实现了代码的封装以及类依赖的解耦&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;使用不同的子类，通过对象的组合，我们可以实现我们想要的创建不同对象的功能&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章到这里就结束了，如果大家有什么问题和疑问欢迎大家在文章下面留言，或者在这里提出来。也欢迎大家关注我的公众号关山不难越，获取更多关于设计模式讲解的内容。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3648148148148148&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fj9xyC53hPX0GpickyJHPNcgzW6zw3JBXT8cWJQ8epmyAmiagZ1xZOrwfBSVF7WAZw20ba6sHxxdrcQlMFF7YexA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是这一系列的其它的文章，也欢迎大家阅读，希望大家都能够掌握好这些设计模式的使用场景和解决的方法。&lt;strong&gt;如果这篇文章对你有所帮助，那就点个赞，分享一下吧~&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>