<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e1910438d1d7264c40aebff4499987fd</guid>
<title>DDD 实现之路</title>
<link>https://toutiao.io/k/9r5qrcy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot; itemprop=&quot;articleBody&quot;&gt;&amp;#13;
&lt;blockquote&gt;
&lt;p&gt;编者按：这篇文章最早撰写于2014年，作者也是《实现领域驱动设计》的译者。几年过去了，DDD在坊间依然方兴未艾，然而它的复杂性所引发的误解也层出不穷。对于一些基本概念的澄清甚至溯源，会帮助我们回到起点，对它展开新的认识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2004年，当Eric Evans的那本&lt;a href=&quot;https://book.douban.com/subject/1629512/&quot;&gt;《领域驱动设计——软件核心复杂性应对之道》&lt;/a&gt;（后文简称《领域驱动设计》）出版时，我还在念高中，接触到领域驱动设计（DDD）已经是8年后的事情了。那时，我正打算在软件开发之路上更进一步，经同事介绍，我开始接触DDD。&lt;/p&gt;
&lt;p&gt;我想，多数有经验的程序开发者都应该听说过DDD，并且尝试过将其应用在自己的项目中。不知你是否遇到过这样的场景：你创建了一个资源库（Repository），但一段时间之后发现这个资源库和传统的DAO越来越像了，你开始反思自己的实现方式是正确的吗？或者，你创建了一个聚合，然后发现这个聚合是如此的庞大，它为什么引用了如此多的对象，难道又是我做错了吗？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/01/1-path-to-ddd.jpg&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/01/1-path-to-ddd.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实你并不孤单，我相信多数同仁都曾遇到过相似的问题。前不久，我一个同事给我展示了他在2007年买的那本已经被他韦编三绝过的《领域驱动设计》，他告诉我，读过好几遍后，他依然不知道如何将DDD付诸实践。Eric那本书固然是好，无可否认，但是我们程序员总希望看到一些实际的例子能够切实将DDD落地以指导我们的日常开发。&lt;/p&gt;
&lt;p&gt;于是，在Eric的书出版将近10年之后，我们有了&lt;a href=&quot;http://vaughnvernon.co/&quot;&gt;Vaughn Vernon&lt;/a&gt;的&lt;a href=&quot;http://book.douban.com/subject/25844633/&quot;&gt;《实现领域驱动设计》&lt;/a&gt;，作为该书的译者，我有幸通读了本书，受益匪浅，得到的结论是：好的软件就应该是DDD的。 &lt;/p&gt;
&lt;p&gt;就像在微电子领域有知识产权核（Intellectual Property）一样，DDD将一个软件系统的核心业务功能集中在一个核心域里面，其中包含了实体、值对象、领域服务、资源库和聚合等概念。在此基础上，DDD提出了一套完整的支撑这样的核心领域的基础设施。此时，DDD已经不再是“面向对象进阶”那么简单了，而是演变成了一个系统工程。&lt;/p&gt;
&lt;p&gt;所谓领域，即是一个组织的业务开展方式，业务价值便体现在其中。长久以来，我们程序员都是很好的技术型思考者，我们总是擅长从技术的角度来解决项目问题。但是，一个软件系统是否真正可用是通过它所提供的业务价值体现出来的。因此，与其每天钻在那些永远也学不完的技术中，何不将我们的关注点向软件系统所提供的业务价值方向思考思考，这也正是DDD所试图解决的问题。&lt;/p&gt;
&lt;p&gt;在DDD中，代码就是设计本身，你不再需要那些繁文缛节的并且永远也无法得到实时更新的设计文档。编码者与领域专家再也不需要翻译才能理解对方所表达的意思。DDD有战略设计和战术设计之分。战略设计主要从高层“俯视”我们的软件系统，帮助我们精准地划分领域以及处理各个领域之间的关系；而战术设计则从技术实现的层面教会我们如何具体地实施DDD。&lt;/p&gt;
&lt;h3&gt;DDD之战略设计&lt;/h3&gt;
&lt;p&gt;需要指出的是，DDD绝非一套单纯的技术工具集，但是我所看到的很多程序员却的确是这么认为的，并且也是怀揣着这样的想法来使用DDD的。过于拘泥于技术上的实现将导致DDD-Lite。简单来讲，DDD-Lite将导致劣质的领域对象，因为我们忽略了DDD战略建模所带来的好处。DDD的战略设计主要包括领域/子域、通用语言、限界上下文和架构风格等概念。&lt;/p&gt;
&lt;h4&gt;领域和子域（Domain/Subdomain）&lt;/h4&gt;
&lt;p&gt;既然是领域驱动设计，那么我们主要的关注点理所当然应该放在如何设计领域模型上，以及对领域模型的划分。&lt;/p&gt;
&lt;p&gt;领域并不是多么高深的概念，比如，一个保险公司的领域中包含了保险单、理赔和再保险等概念；一个电商网站的领域包含了产品名录、订单、发票、库存和物流的概念。这里，我主要讲讲对领域的划分，即将一个大的领域划分成若干个子域。&lt;/p&gt;
&lt;p&gt;在日常开发中，我们通常会将一个大型的软件系统拆分成若干个子系统。这种划分有可能是基于架构方面的考虑，也有可能是基于基础设施的。但是在DDD中，我们对系统的划分是基于领域的，也即是基于业务的。&lt;/p&gt;
&lt;p&gt;于是，问题也来了：首先，哪些概念应该建模在哪些子系统里面？我们可能会发现一个领域概念建模在子系统A中是可以的，而建模在子系统B中似乎也合乎情理。第二个问题是，各个子系统之间的应该如何集成？有人可能会说，这不简单得就像客户端调用服务端那么简单吗？问题在于，两个系统之间的集成涉及到基础设施和不同领域概念在两个系统之间的翻译，稍不注意，这些概念就会对我们精心创建好的领域模型造成污染。&lt;/p&gt;
&lt;p&gt;如何解决？答案是：限界上下文和上下文映射图。&lt;/p&gt;
&lt;h4&gt;限界上下文（Bounded Context）&lt;/h4&gt;
&lt;p&gt;在一个领域/子域中，我们会创建一个概念上的领域边界，在这个边界中，任何领域对象都只表示特定于该边界内部的确切含义。这样边界便称为限界上下文。限界上下文和领域具有一对一的关系。&lt;/p&gt;
&lt;p&gt;举个例子，同样是一本书，在出版阶段和出售阶段所表达的概念是不同的，出版阶段我们主要关注的是出版日期，字数，出版社和印刷厂等概念，而在出售阶段我们则主要关心价格，物流和发票等概念。我们应该怎么办呢，将所有这些概念放在单个Book对象中吗？这不是DDD的做法，DDD有限界上下文将这两个不同的概念区分开来。&lt;/p&gt;
&lt;p&gt;从物理上讲，一个限界上下文最终可以是一个DLL(.NET)文件或者JAR(Java)文件，甚至可以是一个命名空间（比如Java的package）中的所有对象。但是，技术本身并不应该用来界分限界上下文。将一个限界上下文中的所有概念，包括名词、动词和形容词全部集中在一起，我们便为该限界上下文创建了一套通用语言。通用语言是一个团队所有成员交流时所使用的语言，业务分析人员、编码人员和测试人员都应该直接通过通用语言进行交流。&lt;/p&gt;
&lt;p&gt;对于上文中提到的各个子域之间的集成问题，其实也是限界上下文之间的集成问题。在集成时，我们主要关心的是领域模型和集成手段之间的关系。比如需要与一个REST资源集成，你需要提供基础设施（比如Spring 中的RestTemplate），但是这些设施并不是你核心领域模型的一部分，你应该怎么办呢？答案是防腐层，该层负责与外部服务提供方打交道，还负责将外部概念翻译成自己的核心领域能够理解的概念。当然，防腐层只是限界上下文之间众多集成方式的一种，另外还有共享内核、开放主机服务等，具体细节请参考《实现领域驱动设计》原书。限界上下文之间的集成关系也可以理解为是领域概念在不同上下文之间的映射关系，因此，限界上下文之间的集成也称为上下文映射图。&lt;/p&gt;
&lt;h4&gt;架构风格（Architecture）&lt;/h4&gt;
&lt;p&gt;DDD并不要求采用特定的架构风格，因为它是对架构中立的。你可以采用传统的三层式架构，也可以采用REST架构和事件驱动架构等。但是在《实现领域驱动设计》中，作者比较推崇事件驱动架构和六边形（Hexagonal）架构。&lt;/p&gt;
&lt;p&gt;当下，面向接口编程和依赖注入原则已经在颠覆着传统的分层架构，如果再进一步，我们便得到了六边形架构，也称为端口和适配器（Ports and Adapters）。在六边形架构中，已经不存在分层的概念，所有组件都是平等的。这主要得益于软件抽象的好处，即各个组件的之间的交互完全通过接口完成，而不是具体的实现细节。正如Robert C. Martin所说：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象不应该依赖于细节，细节应该依赖于抽象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;采用六边形架构的系统中存在着很多端口和适配器的组合。端口表示的是一个软件系统的输入和输出，而适配器则是对每一个端口的访问方式。比如，在一个Web应用程序中，HTTP协议可以作为一个端口，它向用户提供HTML页面并且接受用户的表单提交；而Servlet（对于Java而言）或者Spring中的Controller则是相对应于HTTP协议的适配器。再比如，要对数据进行持久化，此时的数据库系统则可看成是一个端口，而访问数据库的Driver则是相应于数据库的适配器。如果要为系统增加新的访问方式，你只需要为该访问方式添加一个相应的端口和适配器即可。&lt;/p&gt;
&lt;p&gt;那么，我们的领域模型又如何与端口和适配器进行交互呢？&lt;/p&gt;
&lt;p&gt;上文已经提到，软件系统的真正价值在于提供业务功能，我们会将所有的业务功能分解为若干个业务用例，每一次业务用例都表示对软件系统的一次原子操作。所以首先，软件系统中应该存在这样的组件，他们的作用即以业务用例为单位向外界暴露该系统的业务功能。在DDD中，这样的组件称为应用层（Application Layer）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/01/2-path-to-ddd-1.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/01/2-path-to-ddd-1-768x661.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在有了应用层之后，软件系统和外界的交互便变成了适配器和应用层之间的交互，如上图所示。&lt;/p&gt;
&lt;p&gt;从图中可以看出，领域模型位于应用程序的核心部分，外界与领域模型的交互都通过应用层完成，应用层是领域模型的直接客户。然而，应用层中不应该包含有业务逻辑，否则就造成了领域逻辑的泄漏，而应该是很薄的一层，主要起到协调的作用，它所做的只是将业务操作代理给我们的领域模型。同时，如果我们的业务操作有事务需求，那么对于事务的管理应该放在应用层上，因为事务也是以业务用例为单位的。&lt;/p&gt;
&lt;p&gt;应用层虽然很薄，但却非常重要，因为软件系统的领域逻辑都是通过它暴露出去的，此时的应用层扮演了系统门面（Facade）的角色。&lt;/p&gt;
&lt;h3&gt;DDD之战术设计&lt;/h3&gt;
&lt;p&gt;战略设计为我们提供一种高层视野来审视我们的软件系统，而战术设计则将战略设计进行具体化和细节化，它主要关注的是技术层面的实施，也是对我们程序员来得最实在的地方。&lt;/p&gt;
&lt;h4&gt;行为饱满的领域对象&lt;/h4&gt;
&lt;p&gt;我们希望领域对象能够准确地表达出业务意图，但是多数时候，我们所看到的却是充满getter和setter的领域对象，此时的领域对象已经不是领域对象了，而是Martin Fowler所称之为的&lt;a href=&quot;http://martinfowler.com/bliki/AnemicDomainModel.html&quot;&gt;贫血对象&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;放到Java世界中，多年以来，Java Bean规范都引诱着程序员们以“自然而然又合乎情理”的方式创建着无数的贫血对象，而一些框架也规定对象必须提供getter和setter方法，比如Hibernate的早期版本。那么，贫血对象到底有什么坏处呢？来看一个例子：要修改一个客户（Customer）的邮箱地址，在使用setter方法时为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Customer {
  private String email;

  public void setEmail(String email) {
    this.email = email;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然以上代码可以完成“修改邮箱地址”的功能，但是当你读到这段代码时，你能否推测出系统中就一定存在着一个“修改邮箱地址”的业务用例呢？&lt;/p&gt;
&lt;p&gt;你可能会说，可以在另一个Service类里面创建一个changeCustomerEmail()方法，再在该方法中调用Customer的setEmailAddress()方法，这样业务意图不就明了了吗？问题在于，修改邮箱地址这样的职责本来就应该放在Customer上，而不应该由Service和Customer共同完成。遵循诸如信息封装这样的基本面向对象原则是在实施DDD时最基本的素养。&lt;/p&gt;
&lt;p&gt;要创建行为饱满的领域对象并不难，我们需要转变一下思维，将领域对象当做是服务的提供方，而不是数据容器，多思考一个领域对象能够提供哪些行为，而不是数据。&lt;/p&gt;
&lt;p&gt;近几年又重新流行起来的函数式编程也能够帮助我们编写更加具有业务表达力的业务代码，比如C#和Java 8都提供了Lambda功能，同时还包括多数动态语言（比如Ruby和Groovy等）。再进一步，我们完全可以通过领域特定语言（DSL）的方式实现领域模型。&lt;/p&gt;
&lt;p&gt;笔者曾经设想过这么一个软件系统：它的核心功能完全由一套DSL暴露给外界，所有业务操作都通过这套DSL进行，这个领域的业务规则可以通过一套规则引擎进行配置，于是这套DSL可以像上文提到的知识产权核一样拿到市面上进行销售。此时，我们的核心域被严严实实地封装在这套DSL之内，不容许外界的任何污染。&lt;/p&gt;
&lt;h4&gt;实体vs值对象（Entity vs Value Object）&lt;/h4&gt;
&lt;p&gt;在一个软件系统中，实体表示那些具有生命周期并且会在其生命周期中发生改变的东西；而值对象则表示起描述性作用的并且可以相互替换的概念。同一个概念，在一个软件系统中被建模成了实体，但是在另一个系统中则有可能是值对象。例如货币，在通常交易中，我们都将它建模成了一个值对象，因为我们花了20元买了一本书，我们只是关心货币的数量而已，而不是关心具体使用了哪一张20元的钞票，也即两张20元的钞票是可以互换的。但是，如果现在中国人民银行需要建立一个系统来管理所有发行的货币，并且希望对每一张货币进行跟踪，那么此时的货币便变成了一个实体，并且具有唯一标识（Identity）。在这个系统中，即便两张钞票都是20元，他们依然表示两个不同的实体。&lt;/p&gt;
&lt;p&gt;具体到实现层面，值对象是没有唯一标识的，他的equals()方法（比如在Java语言中）可以用它所包含的描述性属性字段来实现。但是，对于实体而言，equals()方法便只能通过唯一标识来实现了，因为即便两个实体所拥有的状态是一样的，他们依然是不同的实体，就像两个人的名字都叫张三，但是他们却是两个不同的人的个体。&lt;/p&gt;
&lt;p&gt;我们发现，多数领域概念都可以建模成值对象，而非实体。值对象就像软件系统中的过客一样，具有“创建后不管”的特征，因此，我们不需要像关心实体那样去关心诸如生命周期和持久化等问题。&lt;/p&gt;
&lt;h4&gt;聚合（Aggregate）&lt;/h4&gt;
&lt;p&gt;聚合可能是DDD中最难理解的概念 ，之所以称之为聚合，是因为聚合中所包含的对象之间具有密不可分的联系，他们是内聚在一起的。比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。一个聚合中可以包含多个实体和值对象，因此聚合也被称为根实体。聚合是持久化的基本单位，它和资源库（请参考下文）具有一一对应的关系。&lt;/p&gt;
&lt;p&gt;既然聚合可以容纳其他领域对象，那么聚合应该设计得多大呢？这也是设计聚合的难点之一。比如在一个博客（Blog）系统中，一个用户（User）可以创建多个Blog，而一个Blog又可以包含多篇博文（Post）。在建模时，我们通常的做法是在User对象中包含一个Blog的集合，然后在每个Blog中又包含了一个Post的集合。你真的需要这么做吗？如果你需要修改User的基本信息，在加载User时，所有的Blog和Post也需要加载，这将造成很大的性能损耗。诚然，我们可以通过延迟加载的方式解决问题，但是延迟加载只是技术上的实现方式而已。导致上述问题的深层原因其实在我们的设计上，我们发现，User更多的是和认证授权相关的概念，而与Blog关系并不大，因此完全没有必要在User中维护Blog的集合。在将User和Blog分离之后，Blog也和User一样成为了一个聚合，它拥有自己的资源库。问题又来了：既然User和Blog分离了，那么如果需要在Blog中引用User又该怎么办呢？在一个聚合中直接引用另外一个聚合并不是DDD所鼓励的，但是我们可以通过ID的方式引用另外的聚合，比如在Blog中可以维护一个userId的实例变量。&lt;/p&gt;
&lt;p&gt;User作为Blog的创建者，可以成为Blog的工厂。放到DDD中，创建Blog的功能也只能由User完成。&lt;/p&gt;
&lt;p&gt;综上，对于“创建Blog”的用例，我们可以通过以下方法完成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BlogApplicatioinService {

  @Transactional
  public void createBlog(String blogName, String userId) {
    User user = userRepository.userById(userId);
    Blog blog = user.createBlog(blogName);
    blogRepository.save(blog);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上例中，业务用例通过BlogApplicationService应用服务完成，在用例方法createBlog()中，首先通过User的资源库得到一个User，然后调用User中的工厂方法createBlog()方法创建一个Blog，最后通过BlogRepository对Blog进行持久化。整个过程构成了一次事务，因此createBlog()方法标记有@Transactional作为事务边界。&lt;/p&gt;
&lt;p&gt;使用聚合的首要原则为在一次事务中，最多只能更改一个聚合的状态。如果一次业务操作涉及到了对多个聚合状态的更改，那么应该采用发布领域事件（参考下文）的方式通知相应的聚合。此时的数据一致性便从事务一致性变成了最终一致性（Eventual Consistency）。&lt;/p&gt;
&lt;h4&gt;领域服务（Domain Service）&lt;/h4&gt;
&lt;p&gt;你是否遇到过这样的问题：想建模一个领域概念，把它放在实体上不合适，把它放在值对象上也不合适，然后你冥思苦想着自己的建模方式是不是出了问题。恭喜你，祝贺你，你的建模手法完全没有问题，只是你还没有接触到领域服务（Domain Service）这个概念，因为领域服务本来就是来处理这种场景的。比如，要对密码进行加密，我们便可以创建一个PasswordEncryptService来专门负责此事。&lt;/p&gt;
&lt;p&gt;值得一提的是，领域服务和上文中提到的应用服务是不同的，领域服务是领域模型的一部分，而应用服务不是。应用服务是领域服务的客户，它将领域模型变成对外界可用的软件系统。领域服务不能滥用，因为如果我们将太多的领域逻辑放在领域服务上，实体和值对象上将变成贫血对象。&lt;/p&gt;
&lt;h4&gt;资源库（Repository）&lt;/h4&gt;
&lt;p&gt;资源库用于保存和获取聚合对象，在这一点上，资源库与DAO多少有些相似之处。但是，资源库和DAO是存在显著区别的。DAO只是对数据库的一层很薄的封装，而资源库则更加具有领域特征。另外，所有的实体都可以有相应的DAO，但并不是所有的实体都有资源库，只有聚合才有相应的资源库。&lt;/p&gt;
&lt;p&gt;资源库分为两种，一种是基于集合的，一种是基于持久化的。顾名思义，基于集合的资源库具有编程语言中集合的特征。举个例子，Java中的List，我们从一个List中取出一个元素，在对该元素进行修改之后，我们并不用显式地将该元素重新保存到List里面。因此，面向集合的资源库并不存在save()方法。比如，对于上文中的User，其资源库可以设计为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface CollectionOrientedUserRepository {
  public void add(User user);
  public User userById(String userId);
  public List allUsers();     public void remove(User user); 
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于面向持久化的资源库来说，在对聚合进行修改之后，我们需要显式地调用sava()方法将其更新到资源库中。依然是User，此时的资源库如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface PersistenceOrientedUserRepository {
  public void save(User user); 
  public User userById(String userId); 
  public List&amp;lt;User&amp;gt; allUsers();    
  public void remove(User user); 
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上两种方式所实现的资源库中，虽然只是将add()方法改成了save()方法，但是在使用的时候却是不一样的。在使用面向集合资源库时，add()方法只是用来将新的聚合加入资源库；而在面向持久化的资源库中，save()方法不仅用于添加新的聚合，还用于显式地更新既有聚合。&lt;/p&gt;
&lt;h4&gt;领域事件（Domain Event）&lt;/h4&gt;
&lt;p&gt;在Eric的《领域驱动设计》中并没有提到领域事件，领域事件是最近几年才加入DDD生态系统的。&lt;/p&gt;
&lt;p&gt;在传统的软件系统中，对数据一致性的处理都是通过事务完成的，其中包括本地事务和全局事务。但是，DDD的一个重要原则便是一次事务只能更新一个聚合实例。然而，的确存在需要修改多个聚合的业务用例，那么此时我们应该怎么办呢？&lt;/p&gt;
&lt;p&gt;另外，在最近流行起来的微服务（Micro Service）的架构中，整个系统被分成了很多个轻量的程序模块，他们之间的数据一致性并不容易通过事务一致性完成，此时我们又该怎么办呢？&lt;/p&gt;
&lt;p&gt;在DDD中，领域事件便可以用于处理上述问题，此时最终一致性取代了事务一致性，通过领域事件的方式达到各个组件之间的数据一致性。&lt;/p&gt;
&lt;p&gt;领域事件的命名遵循英语中的“名词+动词过去分词”格式，即表示的是先前发生过的一件事情。比如，购买者提交商品订单之后发布OrderSubmitted事件，用户更改邮箱地址之后发布EmailAddressChanged事件。&lt;/p&gt;
&lt;p&gt;需要注意的是，既然是领域事件，他们便应该从领域模型中发布。领域事件的最终接收者可以是本限界上下文中的组件，也可以是另一个限界上下文。&lt;/p&gt;
&lt;p&gt;领域事件的额外好处在于它可以记录发生在软件系统中所有的重要修改，这样可以很好地支持程序调试和商业智能化。另外，在CQRS架构的软件系统中，领域事件还用于写模型和读模型之间的数据同步。再进一步发展，事件驱动架构可以演变成事件源（Event Sourcing），即对聚合的获取并不是通过加载数据库中的瞬时状态，而是通过重放发生在聚合生命周期中的所有领域事件完成。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;DDD存在战略设计和战术设计之分，过度地强调DDD的技术性将使我们错过由战略设计带来的好处。因此，在实现DDD时，我们应该将战略设计也放在一个重要的位置加以对待。战略设计帮助我们从一个宏观的角度观察和审视软件系统，其中的限界上下文和上下文映射图帮助我们正确地界分各个子域（系统）。DDD的战术设计则更加侧重于技术实现，它向我们提供了一整套技术工具集，包括实体、值对象、领域服务和资源库等。虽然DDD的概念已经提出近10年了，但是在如何实现DDD上，我们依然有很长的路要走。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;更多精彩洞见，请关注微信公众号：ThoughtWorks洞见&lt;/strong&gt;&lt;/p&gt;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ee7c1bf18e8f4b1085077de07c1fa051</guid>
<title>敏捷管理系列：学习实践 Scrum，看这一篇就够了</title>
<link>https://toutiao.io/k/wd0phnm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.42265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Jmj2LkhPUr5q85Ow3h2HuaOJQDI7MjwgAtRPnTnl6xogpv2UicQa4UOQUGtE8EHHoCXYzJQtYc8Lcpr01BRSAGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;1&quot; data-url=&quot;https://mp.weixin.qq.com/s?__biz=MzAwODcyODA2MA==&amp;amp;mid=2647539366&amp;amp;idx=1&amp;amp;sn=40032606b40f30f2c31c38e2d50743e1&amp;amp;chksm=8350e235b4276b23bc5b6d7f48c59a6aa74b428f21cac639926e635907c41d9cc0ebd8bc4adb&amp;amp;token=145500855&amp;amp;lang=zh_CN#rd&quot; data-author-name=&quot;Geekwolf&quot; data-content-utf8-length=&quot;39&quot; data-source-title=&quot;敏捷管理系列-四种常见研发模式&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwODcyODA2MA==&amp;amp;mid=2647539366&amp;amp;idx=1&amp;amp;sn=40032606b40f30f2c31c38e2d50743e1&amp;amp;chksm=8350e235b4276b23bc5b6d7f48c59a6aa74b428f21cac639926e635907c41d9cc0ebd8bc4adb&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;敏捷管理系列-四种常见研发模式&lt;/a&gt; 一文介绍了常见的四种研发模式，适用场景及优缺点。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;      笔者有幸参与由瀑布模型到敏捷管理变革尝试的全过程。传统项目管理采用PMP模式，有严格的评审和产出物流程。但敏捷项目管理打破了传统模式，我们需要同时在管理和开发思维上做出变革。本文将对敏捷与Scrum的关系，Scrum的核心概念价值、落地三三五五及度量标准做下阐述总结。希望能够帮助到学习或计划将敏捷带入团队的朋友。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 01 瀑布与敏捷模型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;瀑布模型&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.43529411764705883&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Jmj2LkhPUr5q85Ow3h2HuaOJQDI7Mjwg2h0s8R7leShIokvVkJ4vh6le9icVFkvLMlsH7aAAgyibpRUPDZJXdoBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;模型&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.425531914893617&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Jmj2LkhPUr5q85Ow3h2HuaOJQDI7MjwggafEWqHTXVB89y4Lbc9T4zfTOxTEOAlic2l2tjJ0Ym9iaS0MR3pjTvNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;846&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 02 敏捷宣言与十二原则&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;281&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4862788144895719&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Jmj2LkhPUr5q85Ow3h2HuaOJQDI7MjwgicYfaOyZ5VDlNSq5bBYHSUjia1S3lH3Cp6Fb4fQ0bWAM2PAtLxwia3FhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1822&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong/&gt;&lt;strong&gt;&lt;span&gt; 03 核心思想、行动指南与管理角色&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;核心思想：&lt;/strong&gt;关注价值、拥抱变化、快速交付、持续改进&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;行动指南：&lt;/strong&gt;&lt;span&gt;产品Backlog梳理、版本规划及发布、迭代规划及执行、每日站会、迭代总结会&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;管理角色&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;              - 敏捷教练：提出问题的总结者，解决问题的合作者；帮助团队转变思维方式和观念，让团队深入理解敏捷、实践敏捷，通过言传身教，让团队学会如何应用敏捷方法、实践和工具&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;使命：&lt;/strong&gt;帮助团队驾驭敏捷，生产优秀产品&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;目标：&lt;/strong&gt;培养高效能、高产出敏捷团队，让团队拥有自我管理能力、自我成长能力，自行独立实践敏捷&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;活动：&lt;/strong&gt;观察、反馈、培养、引导和支持&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong/&gt;&lt;strong&gt;&lt;span&gt; 04 敏捷都有哪些实践与工具&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      采用敏捷开发的方法也有很多，主要包括极限编程（XP）、Scrum、水晶方法（Crystal Methods）、自适应软件开发（ASD）、特性驱动开发（FDD）、动态系统开发（DSDM）、轻量级RUP、测试驱动开发（TDD）等等。而在众多的敏捷开发方法中，尤以实施Scrum比较流行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8685897435897436&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Jmj2LkhPUr5q85Ow3h2HuaOJQDI7MjwgVzbYuhWDiaOpicbpjw6w4GFaBMuAxqz4VUibtKwTCvES8icrrkVm3eChtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;624&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 05 Scrum概述与场景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;概述：&lt;/strong&gt;Scrum是一套轻量级的工程实践框架，是Agile的一种，通过各种流程和技术来有效解决复杂的适应性问题，并创造MVP（Minimum Viable Product）的产品&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;历史：&lt;/strong&gt;来自英式橄榄球运动，本质含义就是一群人你推我搡地去抢球和控球。用球赛来类比确实是一个形象又合适的比喻，在赛场上尽管队员们努力按照既定计划推进，但是场上瞬息万变，不可能实时按照教练或者队长的指令亦步亦趋的去行事，只能靠平时训练中形成的素养见机行事，达成目标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;适用场景：&lt;/strong&gt;依赖固定节奏的交付周期，称为Sprint或迭代，围绕迭代、增量的过程骨架展开的活动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4318181818181818&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Jmj2LkhPUr5q85Ow3h2HuaOJQDI7MjwgEkvvgVV5xVia0ZEROoI2NhezHmNwaGR7bficQSRUwKC5ngkfIMZbstvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;968&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 06 Scrum核心思想与精髓&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;核心思路：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    首先承认我们的客户并不清楚自己的需求，并且需求会不断变化，所以我们默认需求是变化的，并且制定出一套策略能让整个组织按照小功能快速开发，并且后续不断迭代。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;精髓：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;   - 解决客户问题，目标是让客户满意；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;   - 关系：团队成员之间的关系，团队与客户之间的关系要处理好；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;   - 反思：作为Scrum Master应该反问自己和团队，现在是否帮助客户解决了问题，我们和客户的关系怎么样？通过不断反思问题来促进团队成长。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;反模式：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;   - 以流程为中心：团队一起反思如何更快的进行产品交付，而不是如何制定一个完美的流程；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;   - 以绩效为中心：绩效是把双刃剑，不同团队采用不同的绩效。没有正确的绩效也没有不变的绩效。要回到Scrum精髓本质，把团队聚焦在解决客户问题上来；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;   - “推动”敏捷转型：Scrum的转型，需要团队、管理层、老板一致认为，我们Scrum改革的WHY；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;07 Scrum落地与三三五五&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;62&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;Scrum是一套轻量级的工程实践框架，是Agile的一种，通过各种流程和技术来有效解决复杂的适应性问题，并创造MVP的产品。&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;适用场景：&lt;/strong&gt;依赖固定节奏的交付周期，称为Sprint或迭代，围绕迭代、增量的过程骨架展开的活动&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Scrum成功落地的关键：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    - 深入学习Scrum的运行规则&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    - 全面掌握Scrum的基本机制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    - 投入足够的时间来学习和实践Scrum&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    - 引入Scrum一定要在新项目或新迭代开始的时候，&lt;span&gt;而不是中途   &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    - 不断持续改进Scrum过程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    - 持续增强master 敏捷管理能力及敏捷文化&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    - 管理软技能 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Scrum三三五五：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.24583333333333332&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Jmj2LkhPUr5q85Ow3h2HuaOJQDI7MjwgMLpjglnw6ZnrlMiaGFLQR27DeWThrFdyiadf1sHibCstqsR43Giasktcaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1440&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.632&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Jmj2LkhPUr5q85Ow3h2HuaOJQDI7MjwgcTPGxzh0icx4OLiappEYWrNnvtic7RehRbTbdpVniaDAbe8n33ialdZUqgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;08 Scrum角色与职责&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;产品负责人(PO)&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;职责：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    主要负责确定产品的功能和达到要求的标准，指定软件的发布日期和交付的内容，最大化产品及开发团队工作的价值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    产品负责人是管理产品待办事项列表的唯一负责人。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;产品待办列表的管理包括：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;改变需求优先级，必须说服产品负责人。为保证产品负责人的工作取得成功，组织中所有人员必须尊重最终的决定，高优先级待办是唯一待开发的产品路径。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;角色需具备的能力:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;熟悉业务，能够让各方干系人对产品需求的认识达到共识&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;准确鉴别用户要求，洞察其背后的意图并转化成为产品需求&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;具备项目管理和产品设计、规划等方面的专业技能和经验&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;研发团队(DT)&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;职责:&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    主要负责软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右，每个成员可能负责不同的技术方面，但要求每成员必须要有很强的自我管理能力，同时具有一定的表达能力；成员可以采用任何工作方式，只要能达到Sprint的目标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    研发团队为每个Sprint的结尾交付潜在可发布的产品增量负责。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;角色需具备的能力:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;期待通过提升自己和帮助他人，让团队成员变的更好&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;尊重自己和他人，认可并实践敏捷价值观和敏捷原则&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;具备开放共赢的心态、求真务实的作风和良好协作精神&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Scrum Master(SM)&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;职责：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;   主要负责整个Scrum流程在项目中的顺利实施和进行，以及清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    Scrum Master服务于Scrum团队，帮助团队外的成员了解如何与Scrum团队交互是有益的，通过改变交互来最大化Scrum团队创造的价值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;服务于产品负责人：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;服务于研发团队：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;服务于组织：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;领导并组织采用Scrum&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在组织范围内计划Scrum的实施&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;帮助员工及干系人理解并实施Scrum和经验性产品开发&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发起提升Scrum团队生产力的变革&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与其他Scrum Master一起，帮助组织更有效应用Scrum&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;角色需具备的能力:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;积极影响他人、帮助他人取得成功来发挥个领导力&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;能够快速与他人建立信任，有效帮助他人发现和解决问题&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;乐于助人，擅长与他人合作，沟通能力和抗压能力都很强&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;09 三个工件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;产品待办列表(Product Backlog)&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt; 产品待办事项列表是一个排序的列表,包含所有产品需要的东西,也是产品需求变动的唯一来源。列出了特性、功能、需求、改进等未来发布产品的改变，包含描述、次序和估算的特征。优先级越高，需求应该越清晰。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;迭代列表(Sprint Backlog)&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;    一组为当前 Sprint 选出的产品代办事项列表条目,外加交付产品增量和实现 Sprint 目标的具体计划。可以在每日站会上得到呈现。只有研发团队可以对Spring Backlog可以进行修改，此时可以移除部分失去开发意义的需求，增加其他优先级更高的需求。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;产品增量(Product Increment)&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;   &lt;span&gt;增量是一个Sprint完成的所有产品待办列表总和以前Sprint所产生的增量的价值总和。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;10 五个活动&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5321701199563795&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Jmj2LkhPUr5q85Ow3h2HuaOJQDI7MjwgNNPMCWiajSIr6bicUEncKrrGAUVNgCnLrG1I6CialBBVFNNoeX8pOwReA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1834&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;11 Scrum管理与度量&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;定性管理&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;   &lt;span&gt;增量是一个Sprint完成的所有产品待办列表总和以前Sprint所产生的增量的价值总和。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;冲刺计划 - 对冲刺期间工作范围及工作量的详细评估；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每日站会 - 团队成员共享任务进度和面临的问题。提供相关Sprint任务剩余时间的报告。保持目标方向；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Sprint总结会议 - 分享进展顺利，表现优秀的地方。进展不佳及改进思路，可以帮助Scrum团队和流程的持续改进；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;团队满意度 - 定期了解Scrum团队满意度，可以提升敏捷文化，减少团队冲突和流程问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;定量管理&lt;/span&gt;&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;燃尽图(Brundown Chart) - 比较直观显示冲刺过程中完成了多少故事点以及还剩下多少故事点，有助于预测冲刺范围是否会按时完成；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;敏捷速度(Velocity Chart) - 衡量团队在过去几个Sprint中平均完成的故事点数即产能，用于预测团队在新的Sprint中的表现。也可以用于提升团队产能的衡量指标。但Scrum团队之间比较不具备参考意义；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;累积流量图(Cumulative Flow Diagram) - 用于显示任务状态-在sprint，发行版或跨软件团队。它可以可视化流程中的瓶颈–在任何工作流程阶段中，成比例的大量任务表明存在问题。例如，在验证或测试阶段图表中的大“气泡”表示该阶段资源不足；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;控制图（Control Chart）、缺陷数等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;度量的目的是为了使Scrum团队更加聚焦交付增量目标，通过过程指标不断修正和持续改进，而非以考核和监督为目的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;h5&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;今日荐文&lt;span/&gt;&lt;/h5&gt;&lt;p&gt;点击下方图片即可阅读&lt;/p&gt;&lt;/section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwODcyODA2MA==&amp;amp;mid=2647539366&amp;amp;idx=1&amp;amp;sn=40032606b40f30f2c31c38e2d50743e1&amp;amp;chksm=8350e235b4276b23bc5b6d7f48c59a6aa74b428f21cac639926e635907c41d9cc0ebd8bc4adb&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.4214046822742475&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Jmj2LkhPUr6h3CrSreKn5SViatk7B0AL5qAEiaJm3Z8kO2cmuCy8NG5DQLqlaGmG1sujV4FE9FjkG2K0iccO7LOzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;897&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwODcyODA2MA==&amp;amp;mid=2647539366&amp;amp;idx=1&amp;amp;sn=40032606b40f30f2c31c38e2d50743e1&amp;amp;chksm=8350e235b4276b23bc5b6d7f48c59a6aa74b428f21cac639926e635907c41d9cc0ebd8bc4adb&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;敏捷管理系列-场景的四种研发模式&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;敏捷管理系列-场景的四种研发模式&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>43bd973e6fcfd2f185f855757a71e3f2</guid>
<title>跳表：会跳的链表原来这么 diao</title>
<link>https://toutiao.io/k/fobkj0c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dLdju2RRyOVZCt6JROGL4RbVO3K89gEdXfahLmO2nuRDaUicEAM0rhqZia7ZXORlkOc7Tecjm3lpDlGQxau5QUTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;12&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Oey3cha6Ms15xGibibd6BHnAecjeJvVEMibTEGb9cIicYpD3GD7iaUufTYUA2yiamMOSicmCFmykG4hFokYqd1d4CcKlw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;12&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;点击上方&lt;/span&gt;&lt;span&gt;bigsai &lt;/span&gt;关注我&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/piaE9ibQxVlzxFkpqJyp0R6UfTwiapfs5ZJicZkZ30ibwqjvia75rRh8naeFTyJB432lOGwM5ntnp71LQjwBicfz4rjKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;12&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CZoQ0UEvvsmkicFKarHicR5kOG2U0nkYfSCia32HFDbSpazHA4qD0upIhQNSzBsLqLicIjY8Qxiap3icA0owFjhyyLaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;12&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.6363636363636364&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9moLyrehXV1g6FjYcibBUZtrDawoib8EqiauZJlUzOhK5gcUOTWKlXruGXSFJPQiaQRUOZ3XTlA7NtNVBbrcbkZTuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;22&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.380952380952381&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iasegoWPqrgYiaTqYcID2emem1YrOiaC8R2mDcycicICSMEo1WNTnyicicmqicYV9hMHkeXZjTdVPNrH76uHjY5riarKEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;42&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;跳表是面试常问的一种数据结构，它在很多中间件和语言中得到应用，我们最最熟知的就有Redis跳表(zset)。并且在面试的很多场景可能会问到，偶尔还会让你手写试一试(跳表可能会让手写，红黑树是不可能的)，这不，给大伙复原一个场景：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9618320610687023&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThwrZ76BJubOdqp6CKDmCickzNJyBhLGN2zJecHuArMLNf0FlmU6LHiaiaPtrYW3eLuvwNc72xIbiaQIdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1310&quot;/&gt;&lt;/p&gt;&lt;p&gt;但你别慌，遇到蘑菇头这种面试官也别怕，因为你看到这篇文章了(得意😏)，不用像熊猫那样窘迫。&lt;/p&gt;&lt;p&gt;对于一个数据结构或算法，人群数量从听过名称、了解基本原理、清楚执行流程、能够手写 呈抖降的趋势。因为很多数据结构与算法其核心原理可能简单，但清楚其执行流程就需要动脑子去思考想明白，但是如果能够把它写出来，那就要自己一步步去设计和实现。可能要花很久才能真正写出来，并且还可能要查阅大量的资料。&lt;/p&gt;&lt;p&gt;而本文在前面进行介绍跳表，后面部分详细介绍跳表的设计和实现，搞懂跳表，这一篇真的就够了。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;快速了解跳表&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;跳跃表(简称跳表)由美国计算机科学家&lt;strong&gt;&lt;span&gt;William Pugh发明于1989年&lt;/span&gt;&lt;/strong&gt;。他在论文《Skip lists: a probabilistic alternative to balanced trees》中详细介绍了跳表的数据结构和插入删除等操作。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;跳表(SkipList，全称跳跃表)是用于有序元素序列快速搜索查找的一个数据结构，跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。它在性能上和红黑树，AVL树不相上下，但是跳表的原理非常简单，实现也比红黑树简单很多。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在这里你可以看到一些关键词：链表(&lt;strong&gt;有序链表&lt;/strong&gt;)、索引、二分查找。想必你的脑海中已经有了一个初略的印象，不过你可能还是不清楚这个&quot;会跳的链表&quot;有多diao，甚至还可能会产生一点疑虑：跟随机化有什么关系？你在下文中很快就能得到答案！&lt;/p&gt;&lt;p&gt;回顾链表，我们知道链表和顺序表(数组)通常都是相爱相杀，成对出现，各有优劣。而链表的优势就是更高效的插入、删除。&lt;strong&gt;痛点就是查询很慢很慢&lt;/strong&gt;！每次查询都是一种O(n)复杂度的操作，链表估计自己都气的想哭了😢。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.24277456647398843&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThwrZ76BJubOdqp6CKDmCickzD4PIr5zK4Vt6m1o6OIllmE6FkMosBnKtCTkO3cDQJBtfmBZN2EEJIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1730&quot; title=&quot;image-20201224155243423&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这是一个带头结点的链表(头结点相当于一个固定的入口，不存储有意义的值)，每次查找都需要一个个枚举，相当的慢，我们能不能稍微优化一下，让它稍微跳一跳呢？答案是可以的，我们知道很多算法和数据结构&lt;strong&gt;以空间换时间&lt;/strong&gt;，我们在上面加一层索引，让部分节点在上层能够直接定位到，这样链表的查询时间近乎减少一半，链表自己虽然没有开心起来，但收起了它想哭的脸。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.42557651991614254&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThwrZ76BJubOdqp6CKDmCickziciccmUiaqlNuOibxIIU6RZroGa535RMGGYys9bSngRc03mLfaFqOlepnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1908&quot; title=&quot;image-20201224160740034&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这样，在查询某个节点的时候，首先会从上一层快速定位节点所在的一个范围，如果找到具体范围向下然后查找代价很小，当然在表的结构设计上会增加一个向下的索引(指针)用来查找确定底层节点。平均查找速度平均为O(n/2)。但是当节点数量很大的时候，它依旧很慢很慢。我们都知道二分查找是每次都能折半的去压缩查找范围，要是有序链表也能这么跳起来那就太完美了。没错&lt;strong&gt;跳表就能让链表拥有近乎的接近二分查找的效率的一种数据结构&lt;/strong&gt;，其原理依然是给上面加若干层索引，优化查找速度。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5215759849906192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThwrZ76BJubOdqp6CKDmCickz5vtMTEMLmQZGiaRq5v0QCunWRatzPZS3U8NicSoCnkFQ1CYe5qrqQrFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2132&quot; title=&quot;image-20201224175922421&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;通过上图你可以看到，通过这样的一个数据结构对有序链表进行查找都能近乎二分的性能。就是在上面维护那么多层的索引，首先在最高级索引上查找最后一个小于当前查找元素的位置，然后再跳到次高级索引继续查找，直到跳到最底层为止，这时候以及十分接近要查找的元素的位置了(如果查找元素存在的话)。由于根据索引可以一次跳过多个元素，所以跳查找的查找速度也就变快了。&lt;/p&gt;&lt;p&gt;对于理想的跳表，每向上一层索引节点数量都是下一层的1/2.那么如果n个节点增加的节点数量(1/2+1/4+…)&amp;lt;n。并且层数较低，对查找效果影响不大。但是对于这么一个结构，你可能会疑惑，这样完美的结构真的存在吗？大概率不存在的，因为作为一个链表，少不了增删该查的一些操作。而删除和插入可能会改变整个结构，所以上面的这些都是理想的结构，在插入的时候是否添加上层索引是个概率问题(1/2的概率)，在后面会具体讲解。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;跳表的增删改查&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;上面稍微了解了跳表是个啥，那么在这里就给大家谈谈跳表的增删改查过程。在实现本跳表的过程为了便于操作，我们将跳表的头结点(head)的key设为int的最小值(一定满足左小右大方便比较)。&lt;/p&gt;&lt;p&gt;对于每个节点的设置，设置成SkipNode类，为了防止初学者将next向下还是向右搞混，直接设置right，down两个指针。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SkipNode&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; key;&lt;br/&gt;    T value;&lt;br/&gt;    SkipNode right,down;&lt;span&gt;//右下个方向的指针&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;SkipNode&lt;/span&gt; &lt;span&gt;(&lt;span&gt;int&lt;/span&gt; key,T value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.key=key;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.value=value;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;跳表的结构和初始化也很重要，其主要参数和初始化方法为：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SkipList&lt;/span&gt; &amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    SkipNode headNode;&lt;span&gt;//头节点，入口&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; highLevel;&lt;span&gt;//当前跳表索引层数&lt;/span&gt;&lt;br/&gt;    Random random;&lt;span&gt;// 用于投掷硬币&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX_LEVEL = &lt;span&gt;32&lt;/span&gt;;&lt;span&gt;//最大的层&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    SkipList(){&lt;br/&gt;        random=&lt;span&gt;new&lt;/span&gt; Random();&lt;br/&gt;        headNode=&lt;span&gt;new&lt;/span&gt; SkipNode(Integer.MIN_VALUE,&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;        highLevel=&lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//其他方法&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;查询操作&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;很多时候链表也可能这样相连仅仅是某个元素或者key作为有序的标准。所以有可能链表内部存在一些value。不过修改和查询其实都是一个操作，找到关键数字(key)。并且查找的流程也很简单，设置一个临时节点team=head。当&lt;strong&gt;team不为null&lt;/strong&gt;其流程大致如下：&lt;/p&gt;&lt;p&gt;(1) 从team节点出发，&lt;strong&gt;如果当前节点的key与查询的key相等&lt;/strong&gt;，那么返回当前节点(如果是修改操作那么一直向下进行修改值即可)。&lt;/p&gt;&lt;p&gt;(2) 如果key不相等，且&lt;strong&gt;右侧为null&lt;/strong&gt;，那么证明只能向下(结果可能出现在下右方向)，此时team=team.down&lt;/p&gt;&lt;p&gt;(3) 如果key不相等，且右侧不为null，且&lt;strong&gt;右侧节点key小于待查询的key&lt;/strong&gt;。那么说明同级还可向右，此时team=team.right&lt;/p&gt;&lt;p&gt;(4)（否则的情况）如果key不相等，且右侧不为null，且&lt;strong&gt;右侧节点key大于待查询的key&lt;/strong&gt; 。那么说明如果有结果的话就在这个索引和下个索引之间，此时team=team.down。&lt;/p&gt;&lt;p&gt;最终将按照这个步骤返回正确的节点或者null(说明没查到)。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.40848806366047746&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThwrZ76BJubOdqp6CKDmCickz1txHcqhnT4IiaicW49MHibQNyibW4LvDibTPDxdPaP9ZGeubMAE76vCvQXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1508&quot; title=&quot;image-20201224210130178&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;例如上图查询12节点，首先第一步从head出发发现右侧不为空，且7&amp;lt;12,向右；第二步右侧为null向下；第三步节点7的右侧10&amp;lt;12继续向右；第四步10右侧为null向下；第五步右侧12小于等于向右。第六步起始发现相等返回节点结束。&lt;/p&gt;&lt;p&gt;而这块的代码也非常容易：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; SkipNode &lt;span&gt;search&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    SkipNode team=headNode;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (team!=&lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(team.key==key)&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;  team;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(team.right==&lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//右侧没有了，只能下降&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            team=team.down;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(team.right.key&amp;gt;key)&lt;span&gt;//需要下降去寻找&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            team=team.down;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;//右侧比较小向右&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            team=team.right;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;删除操作&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;删除操作比起查询稍微复杂一丢丢，但是比插入简单。删除需要改变链表结构所以需要处理好节点之间的联系。对于删除操作你需要谨记以下几点：&lt;/p&gt;&lt;p&gt;(1)删除当前节点和这个节点的前后节点都有关系&lt;/p&gt;&lt;p&gt;(2)删除当前层节点之后，下一层该key的节点也要删除，一直删除到最底层&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据这两点分析一下：如果找到当前节点了，&lt;strong&gt;它的前面一个节点怎么查找呢&lt;/strong&gt;？这个总不能&lt;/span&gt;再&lt;span&gt;遍历一遍吧！&lt;/span&gt;&lt;span&gt;有的使用四个方向的指针(上下左右)用来找到左侧节点。&lt;/span&gt;&lt;span&gt;是可以的，但是这里可以&lt;/span&gt;&lt;strong&gt;特殊处理一下&lt;/strong&gt;&lt;span&gt; ，不直接判断和操作节点，先找到&lt;/span&gt;&lt;strong&gt;待删除节点的左侧节点&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;通过这个节点即可完成删除，然后这个节点直接向下去找下一层待删除的左侧节点。&lt;/span&gt;&lt;span&gt;设置一个临时节点team=head，&lt;/span&gt;&lt;strong&gt;当team不为null&lt;/strong&gt;&lt;span&gt;具体循环流程为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;(1)如果&lt;strong&gt;team右侧为null&lt;/strong&gt;，那么team=team.down(之所以敢直接这么判断是因为左侧有头结点在左侧，不用担心特殊情况)&lt;/p&gt;&lt;p&gt;(2)如果team右侧不 为null，并且&lt;strong&gt;右侧的key等于待删除的key&lt;/strong&gt;，那么先删除节点，再team向下team=team.down为了删除下层节点。&lt;/p&gt;&lt;p&gt;(3)如果team右侧不 为null，并且&lt;strong&gt;右侧key小于待删除的key&lt;/strong&gt;，那么team向右team=team.right。&lt;/p&gt;&lt;p&gt;(4)如果team右侧不 为null，并且&lt;strong&gt;右侧key大于待删除的key&lt;/strong&gt;，那么team向下team=team.down，在下层继续查找删除节点。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7770491803278688&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThwrZ76BJubOdqp6CKDmCickziaqVGO85FrI2yMHDLFh4vbQAAUbUGzdtCl03mTd5RQefA7VReGkG2Aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1830&quot; title=&quot;image-20201225002518856&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;例如上图删除10节点，首先team=head从team出发，7&amp;lt;10向右(team=team.right后面省略)；第二步右侧为null只能向下；第三部右侧为10在当前层删除10节点然后向下继续查找下一层10节点；第四步8&amp;lt;10向右；第五步右侧为10删除该节点并且team向下。team为null说明删除完毕退出循环。&lt;/p&gt;&lt;p&gt;删除操作实现的代码如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; key)&lt;/span&gt;&lt;span&gt;//删除不需要考虑层数&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    SkipNode team=headNode;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (team!=&lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (team.right == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//右侧没有了，说明这一层找到，没有只能下降&lt;/span&gt;&lt;br/&gt;            team=team.down;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(team.right.key==key)&lt;span&gt;//找到节点，右侧即为待删除节点&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            team.right=team.right.right;&lt;span&gt;//删除右侧节点&lt;/span&gt;&lt;br/&gt;            team=team.down;&lt;span&gt;//向下继续查找删除&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(team.right.key&amp;gt;key)&lt;span&gt;//右侧已经不可能了，向下&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            team=team.down;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//节点还在右侧&lt;/span&gt;&lt;br/&gt;            team=team.right;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;插入操作&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;插入操作在实现起来是最麻烦的，需要的考虑的东西最多。回顾查询，不需要动索引；回顾删除，每层索引如果有删除就是了。但是插入不一样了，&lt;strong&gt;插入需要考虑是否插入索引，插入几层&lt;/strong&gt;等问题。由于需要插入删除所以我们肯定无法维护一个完全理想的索引结构，因为它耗费的代价太高。但我们使用&lt;strong&gt;随机化&lt;/strong&gt;的方法去判断是否向上层插入索引。即产生一个[0-1]的随机数如果小于0.5就向上插入索引，插入完毕后再次使用随机数判断是否向上插入索引。运气好这个值可能是多层索引，运气不好只插入最底层(这是100%插入的)。但是索引也不能不限制高度，我们一般会设置索引最高值如果大于这个值就不往上继续添加索引了。&lt;/p&gt;&lt;p&gt;我们一步步剖析该怎么做，其流程为&lt;/p&gt;&lt;p&gt;(1)首先通过上面查找的方式，找到&lt;strong&gt;待插入的左节点&lt;/strong&gt;。插入的话最底层肯定是需要插入的，所以通过链表插入节点(需要考虑是否为末尾节点)&lt;/p&gt;&lt;p&gt;(2)插入完这一层，需要考虑上一层是否插入，首先判断当前索引层级，如果大于最大值那么就停止(比如已经到最高索引层了)。否则设置一个随机数1/2的概率向上插入一层索引(因为理想状态下的就是每2个向上建一个索引节点)。&lt;/p&gt;&lt;p&gt;(3)继续(2)的操作，直到概率退出或者索引层数大于最大索引层。&lt;/p&gt;&lt;p&gt;在&lt;strong&gt;具体向上插入&lt;/strong&gt;的时候，实质上还有非常重要的细节需要考虑。首先&lt;strong&gt;如何找到上层的待插入节点&lt;/strong&gt; ？&lt;/p&gt;&lt;p&gt;这个各个实现方法可能不同，如果有左、上指向的指针那么可以向左向上找到上层需要插入的节点，但是如果只有右指向和下指向的我们也可以&lt;strong&gt;巧妙的借助查询过程中记录下降的节点&lt;/strong&gt;。因为曾经下降的节点倒序就是需要插入的节点，最底层也不例外(因为没有匹配值会下降为null结束循环)。在这里我使用&lt;strong&gt;栈&lt;/strong&gt;这个数据结构进行存储，当然使用List也可以。下图就是给了一个插入示意图。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6670416197975253&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThwrZ76BJubOdqp6CKDmCickzRzzvqySUsTIWPtZqjdpLOaX9ScHJCEwLar8K7aEhEpRp7RKm3iaUqPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1778&quot; title=&quot;image-20201225100031207&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;其次如果该层是目前的&lt;strong&gt;最高层索引&lt;/strong&gt;，需要&lt;strong&gt;继续向上建立索引&lt;/strong&gt;应该怎么办？&lt;/p&gt;&lt;p&gt;首先跳表最初肯定是没索引的，然后慢慢添加节点才有一层、二层索引，但是如果这个节点添加的索引突破当前最高层，该怎么办呢？&lt;/p&gt;&lt;p&gt;这时候&lt;strong&gt;需要注意&lt;/strong&gt;了，跳表的head需要改变了，新建一个ListNode节点作为新的head，将它的down指向老head，将这个head节点加入栈中(也就是这个节点作为下次后面要插入的节点)，就比如上面的9节点如果运气够好在往上建立一层节点，会是这样的。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7872340425531915&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThwrZ76BJubOdqp6CKDmCickz3Y5vImBzmwTEH2Lsp6UXsLS3gYeeIMT9lnM6wn0wK6eXYXQBbSBvRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1786&quot; title=&quot;image-20201225100432978&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;插入上层的时候注意所有节点要新建(拷贝)，除了right的指向down的指向也不能忘记，down指向上一个节点可以用一个临时节点作为前驱节点。如果层数突破当前最高层，头head节点(入口)需要改变。&lt;/p&gt;&lt;p&gt;这部分更多的细节在代码中注释解释了，详细代码为：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(SkipNode node)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; key=node.key;&lt;br/&gt;    SkipNode findNode=search(key);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(findNode!=&lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//如果存在这个key的节点&lt;/span&gt;&lt;br/&gt;    {&lt;br/&gt;        findNode.value=node.value;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    Stack&amp;lt;SkipNode&amp;gt;stack=&lt;span&gt;new&lt;/span&gt; Stack&amp;lt;SkipNode&amp;gt;();&lt;span&gt;//存储向下的节点，这些节点可能在右侧插入节点&lt;/span&gt;&lt;br/&gt;    SkipNode team=headNode;&lt;span&gt;//查找待插入的节点   找到最底层的哪个节点。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (team!=&lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//进行查找操作 &lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(team.right==&lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//右侧没有了，只能下降&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            stack.add(team);&lt;span&gt;//将曾经向下的节点记录一下&lt;/span&gt;&lt;br/&gt;            team=team.down;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(team.right.key&amp;gt;key)&lt;span&gt;//需要下降去寻找&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            stack.add(team);&lt;span&gt;//将曾经向下的节点记录一下&lt;/span&gt;&lt;br/&gt;            team=team.down;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;//向右&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            team=team.right;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; level=&lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//当前层数，从第一层添加(第一层必须添加，先添加再判断)&lt;/span&gt;&lt;br/&gt;    SkipNode downNode=&lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//保持前驱节点(即down的指向，初始为null)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (!stack.isEmpty()) {&lt;br/&gt;        &lt;span&gt;//在该层插入node&lt;/span&gt;&lt;br/&gt;        team=stack.pop();&lt;span&gt;//抛出待插入的左侧节点&lt;/span&gt;&lt;br/&gt;        SkipNode nodeTeam=&lt;span&gt;new&lt;/span&gt; SkipNode(node.key, node.value);&lt;span&gt;//节点需要重新创建&lt;/span&gt;&lt;br/&gt;        nodeTeam.down=downNode;&lt;span&gt;//处理竖方向&lt;/span&gt;&lt;br/&gt;        downNode=nodeTeam;&lt;span&gt;//标记新的节点下次使用&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(team.right==&lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//右侧为null 说明插入在末尾&lt;/span&gt;&lt;br/&gt;            team.right=nodeTeam;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//水平方向处理&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//右侧还有节点，插入在两者之间&lt;/span&gt;&lt;br/&gt;            nodeTeam.right=team.right;&lt;br/&gt;            team.right=nodeTeam;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//考虑是否需要向上&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(level&amp;gt;MAX_LEVEL)&lt;span&gt;//已经到达最高级的节点啦&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;double&lt;/span&gt; num=random.nextDouble();&lt;span&gt;//[0-1]随机数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(num&amp;gt;&lt;span&gt;0.5&lt;/span&gt;)&lt;span&gt;//运气不好结束&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        level++;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(level&amp;gt;highLevel)&lt;span&gt;//比当前最大高度要高但是依然在允许范围内 需要改变head节点&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            highLevel=level;&lt;br/&gt;            &lt;span&gt;//需要创建一个新的节点&lt;/span&gt;&lt;br/&gt;            SkipNode highHeadNode=&lt;span&gt;new&lt;/span&gt; SkipNode(Integer.MIN_VALUE, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;            highHeadNode.down=headNode;&lt;br/&gt;            headNode=highHeadNode;&lt;span&gt;//改变head&lt;/span&gt;&lt;br/&gt;            stack.add(headNode);&lt;span&gt;//下次抛出head&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;对于上面，跳表完整分析就结束啦，当然，你可能看到不同品种跳表的实现，还有的用数组方式表示上下层的关系这样也可以，但本文只定义right和down两个方向的链表更纯正化的讲解跳表。&lt;/p&gt;&lt;p&gt;对于跳表以及跳表的同类竞争产品：红黑树，为啥Redis的有序集合(zset) 使用跳表呢？因为跳表除了查找插入维护和红黑树有着差不多的效率，它是个链表，能确定范围区间，而区间问题在树上可能就没那么方便查询啦。而JDK中&lt;strong&gt;跳跃表ConcurrentSkipListSet和ConcurrentSkipListMap。&lt;/strong&gt; 有兴趣的也可以查阅一下源码。&lt;/p&gt;&lt;p&gt;对于学习，完整的代码是非常重要的，这里我把完整代码贴出来，需要的自取。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.util.Random;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.Stack;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SkipNode&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; key;&lt;br/&gt;    T value;&lt;br/&gt;    SkipNode right,down;&lt;span&gt;//左右上下四个方向的指针&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;SkipNode&lt;/span&gt; &lt;span&gt;(&lt;span&gt;int&lt;/span&gt; key,T value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.key=key;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.value=value;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SkipList&lt;/span&gt; &amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    SkipNode headNode;&lt;span&gt;//头节点，入口&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; highLevel;&lt;span&gt;//层数&lt;/span&gt;&lt;br/&gt;    Random random;&lt;span&gt;// 用于投掷硬币&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX_LEVEL = &lt;span&gt;32&lt;/span&gt;;&lt;span&gt;//最大的层&lt;/span&gt;&lt;br/&gt;    SkipList(){&lt;br/&gt;        random=&lt;span&gt;new&lt;/span&gt; Random();&lt;br/&gt;        headNode=&lt;span&gt;new&lt;/span&gt; SkipNode(Integer.MIN_VALUE,&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;        highLevel=&lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; SkipNode &lt;span&gt;search&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        SkipNode team=headNode;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (team!=&lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(team.key==key)&lt;br/&gt;            {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;  team;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(team.right==&lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//右侧没有了，只能下降&lt;/span&gt;&lt;br/&gt;            {&lt;br/&gt;                team=team.down;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(team.right.key&amp;gt;key)&lt;span&gt;//需要下降去寻找&lt;/span&gt;&lt;br/&gt;            {&lt;br/&gt;                team=team.down;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;//右侧比较小向右&lt;/span&gt;&lt;br/&gt;            {&lt;br/&gt;                team=team.right;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; key)&lt;/span&gt;&lt;span&gt;//删除不需要考虑层数&lt;/span&gt;&lt;br/&gt;    &lt;/span&gt;{&lt;br/&gt;        SkipNode team=headNode;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (team!=&lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (team.right == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//右侧没有了，说明这一层找到，没有只能下降&lt;/span&gt;&lt;br/&gt;                team=team.down;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(team.right.key==key)&lt;span&gt;//找到节点，右侧即为待删除节点&lt;/span&gt;&lt;br/&gt;            {&lt;br/&gt;                team.right=team.right.right;&lt;span&gt;//删除右侧节点&lt;/span&gt;&lt;br/&gt;                team=team.down;&lt;span&gt;//向下继续查找删除&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(team.right.key&amp;gt;key)&lt;span&gt;//右侧已经不可能了，向下&lt;/span&gt;&lt;br/&gt;            {&lt;br/&gt;                team=team.down;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//节点还在右侧&lt;/span&gt;&lt;br/&gt;                team=team.right;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(SkipNode node)&lt;/span&gt;&lt;br/&gt;    &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; key=node.key;&lt;br/&gt;        SkipNode findNode=search(key);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(findNode!=&lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//如果存在这个key的节点&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            findNode.value=node.value;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        Stack&amp;lt;SkipNode&amp;gt;stack=&lt;span&gt;new&lt;/span&gt; Stack&amp;lt;SkipNode&amp;gt;();&lt;span&gt;//存储向下的节点，这些节点可能在右侧插入节点&lt;/span&gt;&lt;br/&gt;        SkipNode team=headNode;&lt;span&gt;//查找待插入的节点   找到最底层的哪个节点。&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (team!=&lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//进行查找操作&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(team.right==&lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//右侧没有了，只能下降&lt;/span&gt;&lt;br/&gt;            {&lt;br/&gt;                stack.add(team);&lt;span&gt;//将曾经向下的节点记录一下&lt;/span&gt;&lt;br/&gt;                team=team.down;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(team.right.key&amp;gt;key)&lt;span&gt;//需要下降去寻找&lt;/span&gt;&lt;br/&gt;            {&lt;br/&gt;                stack.add(team);&lt;span&gt;//将曾经向下的节点记录一下&lt;/span&gt;&lt;br/&gt;                team=team.down;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;//向右&lt;/span&gt;&lt;br/&gt;            {&lt;br/&gt;                team=team.right;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; level=&lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//当前层数，从第一层添加(第一层必须添加，先添加再判断)&lt;/span&gt;&lt;br/&gt;        SkipNode downNode=&lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//保持前驱节点(即down的指向，初始为null)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (!stack.isEmpty()) {&lt;br/&gt;            &lt;span&gt;//在该层插入node&lt;/span&gt;&lt;br/&gt;            team=stack.pop();&lt;span&gt;//抛出待插入的左侧节点&lt;/span&gt;&lt;br/&gt;            SkipNode nodeTeam=&lt;span&gt;new&lt;/span&gt; SkipNode(node.key, node.value);&lt;span&gt;//节点需要重新创建&lt;/span&gt;&lt;br/&gt;            nodeTeam.down=downNode;&lt;span&gt;//处理竖方向&lt;/span&gt;&lt;br/&gt;            downNode=nodeTeam;&lt;span&gt;//标记新的节点下次使用&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(team.right==&lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//右侧为null 说明插入在末尾&lt;/span&gt;&lt;br/&gt;                team.right=nodeTeam;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//水平方向处理&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//右侧还有节点，插入在两者之间&lt;/span&gt;&lt;br/&gt;                nodeTeam.right=team.right;&lt;br/&gt;                team.right=nodeTeam;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//考虑是否需要向上&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(level&amp;gt;MAX_LEVEL)&lt;span&gt;//已经到达最高级的节点啦&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;double&lt;/span&gt; num=random.nextDouble();&lt;span&gt;//[0-1]随机数&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(num&amp;gt;&lt;span&gt;0.5&lt;/span&gt;)&lt;span&gt;//运气不好结束&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            level++;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(level&amp;gt;highLevel)&lt;span&gt;//比当前最大高度要高但是依然在允许范围内 需要改变head节点&lt;/span&gt;&lt;br/&gt;            {&lt;br/&gt;                highLevel=level;&lt;br/&gt;                &lt;span&gt;//需要创建一个新的节点&lt;/span&gt;&lt;br/&gt;                SkipNode highHeadNode=&lt;span&gt;new&lt;/span&gt; SkipNode(Integer.MIN_VALUE, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;                highHeadNode.down=headNode;&lt;br/&gt;                headNode=highHeadNode;&lt;span&gt;//改变head&lt;/span&gt;&lt;br/&gt;                stack.add(headNode);&lt;span&gt;//下次抛出head&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printList&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        SkipNode teamNode=headNode;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; index=&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        SkipNode last=teamNode;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (last.down!=&lt;span&gt;null&lt;/span&gt;){&lt;br/&gt;            last=last.down;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (teamNode!=&lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            SkipNode enumNode=teamNode.right;&lt;br/&gt;            SkipNode enumLast=last.right;&lt;br/&gt;            System.out.printf(&lt;span&gt;&quot;%-8s&quot;&lt;/span&gt;,&lt;span&gt;&quot;head-&amp;gt;&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (enumLast!=&lt;span&gt;null&lt;/span&gt;&amp;amp;&amp;amp;enumNode!=&lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt;(enumLast.key==enumNode.key)&lt;br/&gt;                {&lt;br/&gt;                    System.out.printf(&lt;span&gt;&quot;%-5s&quot;&lt;/span&gt;,enumLast.key+&lt;span&gt;&quot;-&amp;gt;&quot;&lt;/span&gt;);&lt;br/&gt;                    enumLast=enumLast.right;&lt;br/&gt;                    enumNode=enumNode.right;&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;                    enumLast=enumLast.right;&lt;br/&gt;                    System.out.printf(&lt;span&gt;&quot;%-5s&quot;&lt;/span&gt;,&lt;span&gt;&quot;&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;            }&lt;br/&gt;            teamNode=teamNode.down;&lt;br/&gt;            index++;&lt;br/&gt;            System.out.println();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        SkipList&amp;lt;Integer&amp;gt;list=&lt;span&gt;new&lt;/span&gt; SkipList&amp;lt;Integer&amp;gt;();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;&lt;span&gt;20&lt;/span&gt;;i++)&lt;br/&gt;        {&lt;br/&gt;            list.add(&lt;span&gt;new&lt;/span&gt; SkipNode(i,&lt;span&gt;666&lt;/span&gt;));&lt;br/&gt;        }&lt;br/&gt;        list.printList();&lt;br/&gt;        list.delete(&lt;span&gt;4&lt;/span&gt;);&lt;br/&gt;        list.delete(&lt;span&gt;8&lt;/span&gt;);&lt;br/&gt;        list.printList();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;进行测试一下可以发现跳表还是挺完美的(自夸一下)。你是不是非常想跳一下试试！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6509758897818599&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThwrZ76BJubOdqp6CKDmCickzhtDxdOYMicnibc7dY6g81W7a6NwnZjTDm1BplGvQVhU1BZ3VVMbegdgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1742&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/h2&gt;&lt;section&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MTE1NjA2Mg==&amp;amp;mid=2247485697&amp;amp;idx=1&amp;amp;sn=2de52beeea8b5c1458a44e0086267471&amp;amp;chksm=ce1a2eb0f96da7a64aa86eb00779940f2b054127d4f2ba5eba28be6c2f6f8b966018566d0ddd&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;strong&gt;面试官本想拿一道求素数搞我，但被我优雅的&quot;回击&quot;了&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MTE1NjA2Mg==&amp;amp;mid=2247485341&amp;amp;idx=1&amp;amp;sn=9322f5ea2eca0fb3f6927d87c3b532fb&amp;amp;chksm=ce1a202cf96da93a615868dba376b98d77561b88cdcc776bd58c4dd8e00d52b9b9267ad9f3a1&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MTE1NjA2Mg==&amp;amp;mid=2247485763&amp;amp;idx=1&amp;amp;sn=ee5ccb1f64a21cf9cd095339d1363ff4&amp;amp;chksm=ce1a2ef2f96da7e4d32b12d174f2bf2a851ab3352858a15e71026c228d07eee1441fd65f0888&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;是时候捋一捋Java的深浅拷贝了&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MTE1NjA2Mg==&amp;amp;mid=2247485575&amp;amp;idx=1&amp;amp;sn=5bf1be2af6213ee546c0435b92af149d&amp;amp;chksm=ce1a2f36f96da620957e0bf9ec87edc23087bc49800ed2456f41d3495cb16fcf7f1c2b707074&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;strong&gt;「干货总结」程序员必知必会的十大排序算法&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MTE1NjA2Mg==&amp;amp;mid=2247485682&amp;amp;idx=1&amp;amp;sn=e7959e1367394eb6f3a8fe37aa109cb1&amp;amp;chksm=ce1a2f43f96da6554a60ab9ce7f37ad26992ed2b9791693dd4d7e50fb7efc44e88ac77b3e2c0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;strong&gt;花5分钟看这篇之前,你才发现你不懂RESTful&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MTE1NjA2Mg==&amp;amp;mid=2247485648&amp;amp;idx=1&amp;amp;sn=8ef9e4eb5dab360695a637b37ed488e2&amp;amp;chksm=ce1a2f61f96da6770494c1c2041efeb525ba1743cb00e733d57e62e47021f28e5da188a0d853&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;「五大常用算法」一文图解分治算法和思想&lt;/a&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎关注、转发、在看分享，咱们下次再见！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3579175704989154&quot; data-type=&quot;png&quot; data-w=&quot;2766&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThxnTyOzzdibsIIhOb7FJJ4DqfczTibcsLSg6DHic9tJibhxBnjSVDDFmwpoRyQOiagY32aFxia190zIUiaLQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;figcaption&gt;&lt;span/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9495864e0f2b3f2fed109036eab176d9</guid>
<title>Dubbo 靠它崭露头角</title>
<link>https://toutiao.io/k/3f4emhg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hola，我是 yes。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过了 RPC 核心和 Dubbo 微内核两篇文章后，今天终于要稍稍深入一波 Dubbo 了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为一个通用的 RPC 框架，性能是很重要的一环，而易用性和扩展性也极为重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单地、无侵入式地扩展和定制 RPC 各阶段功能是很多团队的述求，Dubbo 就满足了这些需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它通过&lt;span&gt;微内核设计和 SPI 扩展&lt;/span&gt;，使得一些有特殊需求的业务团队可以在 Dubbo 中实现自己的扩展，而不需要修改源码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Dubbo 的成功离不开这样的设计，今天咱们就来盘一盘 Dubbo 是如何实现无侵入扩展的，其间还会看到 &lt;span&gt;Dubbo 的 IOC 和 AOP。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有先打个预防针，今天的内容代码有点多的，毕竟想要深入剖析，源码必不可少，刚好也顺带提一下&lt;span&gt;看源码的小技巧。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以&lt;span&gt;建议电脑上看，更加清晰和舒适。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有如果有没看过源码的同学，来紧跟 Dubbo 这个系列吧，到时候&lt;span&gt;再也不怕被面试官问看过源码没了。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;SPI&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Dubbo 就是利用 SPI （Service Provider Interface）来实现扩展机制的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 SPI 想必你们都很熟悉，在大学写数据库大作业的时候就碰到了，访问数据库需要用到 &lt;code&gt;java.sql.Driver&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;市面上的数据库五花八门，每个数据库厂商都有自己的实现，所以肯定需要定制一个接口，这样我们&lt;span&gt;面向接口编程即可&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而具体的实现则可以通过配置来加载，JDK SPI 这时候就派上用场了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实一点都不神奇，就是&lt;span&gt;约定一个地方&lt;/span&gt;，加载的时候就去那个地方找实现类。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.22324159021406728&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEQriaIEsJ4OAV8k9QwxCYmHrRmf5zGjmo92uV4bJfk1oyzibEWRoX28aYrHamUnjWsibhDIgCDJjpww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;654&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;约定一个地方直白点说就是代码里面写死了一个目录，这个目录就是 &lt;code&gt;META-INF/services/&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在这个目录下创建一个文件，用接口全限定名来命名，文件内容就是实现类的全限定名。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3678571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEQriaIEsJ4OAV8k9QwxCYmHDsQuoxoQoAyubibfXtZzxfVTIOLxVytOOeg2PcUMcgu66TopF9YzGxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;840&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到时候要实现类就根据接口名来这里找，然后实例化就行了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;挺简单的吧，这就是 JDK SPI，但是它不满足 Dubbo 的需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 Dubbo 把自身的一些实现也剥离出来成为扩展，而这些实现还是有点多的，也不需要全部用上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果&lt;span&gt;用 JDK SPI 会把配置文件里面的类全部加载，这就导致资源的浪费。用的时候还需要遍历过去才能找到对应的实现。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 Dubbo 就在 JDK SPI 的基础上实现了个 Dubbo 的 SPI，可以根据指定的名称按需加载实现类，比如拿 Cluster 来说就有这么多实现类。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.25341745531019977&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEQriaIEsJ4OAV8k9QwxCYmHse611xmHPNpNwCWuciaz3s95taiaQVQmicXvYsmdqwnF9ZeGEtm0mLUrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;951&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;约定的地方改了一下，一共有三个目录。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;META-INF/dubbo/internal/ ：这里是存放 Dubbo 内部使用的 SPI 配置文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;META-INF/dubbo/ ：这里是存放用户自定义 SPI 配置文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;META-INF/services/：兼容 JDK SPI&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后文件里面的内容是&lt;code&gt;key=value&lt;/code&gt;形式，这样就可以根据 key 找到对应的实现类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在注解上可以配置默认的 key 来选择默认的实现类，比如 Cluster 默认的实现是 failover。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以通过 URL 参数来选择实现类。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6209677419354839&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEQriaIEsJ4OAV8k9QwxCYmHmtZlBv2Z2Ds83tuUQao1ia7427GbGliaXF0MORpic5cxLqroWrpibp6N9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;620&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有像 JDK SPI 扩展点加载失败的话，连扩展点名称都拿不到，到时候报错也不知道哪里出问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 Dubbo SPI 则不会吃了错误，并且&lt;span&gt;还提供了扩展点的自动注入和 AOP 功能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大致了解了 Dubbo  SPI 之后，我们再来深入看看实现细节。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Dubbo SPI 实现细节&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Dubbo SPI 的核心实现在 ExtensionLoader 中，它负责扩展点的加载和生命周期的维护，类似 JDK SPI 的 ServiceLoader。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里要先提一点&lt;span&gt;看源码的小技巧了&lt;/span&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开源框架都会有单元测试，而单元测试里面就会有我们看源码时候想要的各种功能实现，我们就可以从单元测试入手得知一些功能的划分，然后断点调试逐渐深入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如今天文章的 ExtensionLoader ，它在 dubbo-common 模块中，咱们就进入 test 来看看它测试用例怎么写的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.6513317191283292&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEQriaIEsJ4OAV8k9QwxCYmHxicadT7OTmZkcMyvDvcwibG2UH9IVP7uJEibRJIPPRfkj4glA4MeYL5xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;413&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然除了通过文件夹来找，直接用文件名搜也行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;找到了就好办了，数据都是造好的，找到你想要调试的方法，断点一设，箭头一点，这不就美滋滋了吗？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2153061224489796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEQriaIEsJ4OAV8k9QwxCYmHabePhVbcoRpLxO9A0n0RO5eibBmXzsUI8aIhy8LH357Abspicl8XqAJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;980&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，小技巧分享完毕，回到 ExtensionLoader，我们简单点就用 Dubbo 单元测试的数据来看看实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有个叫 SimpleExt 的类，有三个实现，默认的实现是 impl1。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7173076923076923&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEQriaIEsJ4OAV8k9QwxCYmHtv34icA12xmQMcsVl5pQNJGnnn7icYRibhWXn8gIJoVf8Lk1qq2XpshtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;520&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来看看 SPI 配置文件的内容，可以看到为了测试还故意写了一些空格在配置文件中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.18951612903225806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEQriaIEsJ4OAV8k9QwxCYmHwUQn7kJLFXh3TwSHmuluFtItcL15Vk4Yhk9jJR82yXmMyBYc28w5mQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后现在如果要找 impl2 这个实现，通过以下代码调用即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SimpleExt ext = ExtensionLoader&lt;br/&gt;    .getExtensionLoader(SimpleExt.class).getExtension(&lt;span&gt;&quot;impl2&quot;&lt;/span&gt;) &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个扩展接口对应有个 ExtensionLoader，找到对应的 ExtensionLoader，然后再加载对应名字的实现类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来会有源码，不过没关系，还是很简单的，想要深入源码这关必须过。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6419161676646706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEQriaIEsJ4OAV8k9QwxCYmHQO71shk64OvGTKibRd1Ac2kZIeAzUJ04yEiaRuakXNaKt9FEWyUJvJFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;835&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到&lt;code&gt;getExtensionLoader&lt;/code&gt; 是静态的，里面逻辑也很简单就是从缓存找接口对应的 ExtensionLoader，找不到就新建一个返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在有了 ExtensionLoader，咱们再来看看 getExtension 的逻辑，来看看是如何通过扩展点 name 找到对应的实现类的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0491803278688525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEQriaIEsJ4OAV8k9QwxCYmHLHyuQvzjNXmJNaBhnj6uLqIIUzU0ehZyN7Mp4a3vd8F9xJib1MovaIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到又是有个缓存操作，逻辑非常简单，先去缓存找实例，如果没有则创建实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要说&lt;span&gt;细节就是用到了双检锁，然后用 holder 来保证可见性和防止指令重排。&lt;/span&gt;应该看到注释上的 holder 构造了吧，volatile 和双检锁的搭配，这里就不深入了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看看 createExtension，这是要创建扩展点了，代码有点长，但是我都做了相应的注释，包括绿色的注释。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.730603448275862&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEQriaIEsJ4OAV8k9QwxCYmHcl3rvt7LX4IW44Mz68srNTEysJVicncZZJCPHv3F6wUBx3OEibuHSib1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;928&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;逻辑还是很简单的，详细的代码没有具体展示，我先口述一下。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过接口类名去三个目录找到对应的文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解析文件内容生成 class 对象，然后缓存到 cachedClasses 中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后通过 name 去 cachedClasses  中找到对应的 class 对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;去缓存 EXTENSION_INSTANCES 看看是否已经实例化过了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有的话就实例化，然后调用 injectExtension 实现自动注入。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再通过 cachedWrapperClasses 实现包装，将最后的包装类返回。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有几点不清晰没关系，咱们接着分析，&lt;span&gt;脑海中先大概知道要做什么，然后再来看看具体是怎么做的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码中的 loadDirectory 就是去目录找文件，然后解析，最终会调用  loadClass，这个方法很关键，我们详细分析一下，为了便于观看，删除了一些代码。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.01036866359447&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEQriaIEsJ4OAV8k9QwxCYmHcl7yWkiboJSwJa2ZfdTYNXuMABHQibUw1WLbMb5LuKlmH344RDFoywIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;868&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自适应咱们先略过，只要知道是在这里记录的即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后上面提到的 AOP 相关的 cachedWrapperClasses 就是在这里记录的，如果判断它是包装类呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.32473444613050073&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEQriaIEsJ4OAV8k9QwxCYmH2F1Nd1T92IjZgL80aZZkUyXy8VNM0ObmCUpJPZ8xfenjwsU6JR2MYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;659&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单粗暴但是有效，只要有当前类作为构造器参数的类就是包装类，有点拗口，多读几遍就理解了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;现在我们再回过头来看看这段代码，Dubbo 的 AOP。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23214285714285715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEQriaIEsJ4OAV8k9QwxCYmHkGoKlm6rkJk5mT38jdgR6lHcLGCKTCu4akib7gRVvh43Kftqyia9XAGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;896&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把扩展类对应的包装类都记录下来放在  cachedWrapperClasses 中，然后在实例化扩展类的时候就一层一层的把扩展类包起来，最终返回的就是包装类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么说这就是 AOP 呢？因为等于把一些逻辑切进了扩展实现类中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实就是&lt;span&gt;把扩展对象的公共逻辑移到包装类中&lt;/span&gt;，我们看下单元测试的例子就很清晰了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7433920704845814&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEQriaIEsJ4OAV8k9QwxCYmHekdUyJa7K8YxGc7Fwnla7eMbL1RXC88ln3ibKNLU8DEPI1NlEMh3Alg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;908&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中可以看到有两个扩展实现类，两个包装类，具体逻辑就不看了，不是重点，配置文件如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.16693548387096774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEQriaIEsJ4OAV8k9QwxCYmHIDeWWYOYgLdIcqgicMObianvedFvKruCeoRBjjHF7fYPcLavyw2KfJjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后再看一下单元测试的运行结果，可以看到最终返回的其实是 Ext5Wrapper1 对象，并且它还包着 wrapper2 对象。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5203862660944206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEQriaIEsJ4OAV8k9QwxCYmHk0l3Umkib5pHqyN3wC5pWUdsQmmWN5o85IU0ff4YUZIVZonicdIKCw5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;932&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 echo 方法的调用链就是:&lt;code&gt;Ext5Wrapper1 -&amp;gt;Ext5Wrapper2-&amp;gt;Ext5impl1&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就起到了 AOP 的效果。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;接下来我们再来看看 injectExtension，是如何实现 Dubbo 的自动注入。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7867494824016563&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEQriaIEsJ4OAV8k9QwxCYmHBThzZ1jADfMWjhia4RjfiafbD1w03b0rkYgyCH3q8gz8BKh3bovTyhHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;966&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看了代码之后是不是有点失望，就这？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是的就是这么朴素地判断有没有 set 方法，然后根据参数找到对象，执行 set 方法注入即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以说&lt;span&gt;源码之下无秘密，看起来好像很高级的东西，就这。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面代码中还有个&lt;code&gt;objectFactory.getExtension()&lt;/code&gt;，这个和扩展自适应有关系，还有个&lt;code&gt;@Activate&lt;/code&gt;也没说。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这两些内容还是有点多的，也很重要&lt;/span&gt;，感觉上可能还有点绕，所以单独写一篇说。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Dubbo 就是靠自己实现的 SPI 机制把通信协议、序列化格式、负载均衡、路由策略等各部分抽出来作为插件，实现扩展和定制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过微内核和SPI 机制来满足用户定制化的需求，也保证了框架本身的稳定性和可持续性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且 Dubbo 自身也提供了很多已有的实现，像各种路由策略等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以说一个好的框架不仅自己功能要全，还得对扩展开放，这样生态才会壮大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的代码还是有点多的，如果看不懂的建议下载源码，跟着源码调试几遍就清晰了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码这一步一定要迈过去，迈过去了之后就轻松了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Dubbo 系列持续更新，敬请期待，有问题可以留言。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>849438d928c2e726b5001e50681e926e</guid>
<title>也谈 996</title>
<link>https://toutiao.io/k/7zv2wac</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content___1pb4c&quot;&gt;&lt;p&gt;最近网络上有很多 996 相关话题的讨论，所谓 996 是从互联网公司兴起的一种说法，指的是工作时间从早上 9 点持续到晚上 9 点，一周工作 6 天。换一个说法，就是制度性的强制加班。&lt;/p&gt;
&lt;p&gt;今年是我工作的第 16 年了，基本一直在互联网行业，经历过按时下班保证双休的美好时代，也经历过 996 甚至更辛苦的加班时代。996 被诟病了很久，但看起来却一直没有消失的迹象，身处这个时代，个人所能做的很少，就写一篇博客，记录一下我对这个问题的经历以及看法吧。&lt;/p&gt;
&lt;h2&gt;曾经的美好时代&lt;/h2&gt;
&lt;p&gt;2005 年我开始了自己的第一份工作，在一个小创业公司，工作时间朝九晚六，中午休息一小时，几乎从不加班，不过有一个大小周制度（终于像创业公司了），大周双休，小周周六来加半天班。&lt;/p&gt;
&lt;p&gt;那个年代，加班的风气并不多，我们所在的办公楼甚至每晚一到 8 点就要锁门，看门大爷会挨个办公室来赶人，因此即使有加班的想法，也最多只能加到晚上 8 点。至于把工作带回家做则是基本不可能的，因为那时笔记本电脑还是高级货，大家的工作电脑都是台式机，很多人家里也还没电脑、没网络，所以下班了就是下班了。&lt;/p&gt;
&lt;p&gt;现在回想起来，那真是一个美好的时代。&lt;/p&gt;
&lt;h2&gt;我所经历的 996&lt;/h2&gt;
&lt;p&gt;2008 年我进了阿里，那时阿里还在华星路创业大厦，也基本不加班，双休，朝九晚六，除了小部分工作狂以及真的有紧急项目的人，大部分人傍晚六点之后就走了。&lt;/p&gt;
&lt;p&gt;几个月后，我被调去支援一个项目，后来才知道，那就是一个拍脑袋上的项目，先定了发布时间，再倒排设计和开发时间，然后设计阶段又反复讨论花掉了太多时间，导致留给开发的时间被压缩得非常厉害。那个项目封闭开发了大概三个月，那是我第一次真正经历 996 甚至 9-12-7，当然，那时还没有这样的叫法。&lt;/p&gt;
&lt;p&gt;现在回想起来，那三个月的经历仍然像噩梦一般，每天精神高度紧张，眼看截止时间越来越近，但还有天量的工作没有完成，不断地有人催你，每天到工位一坐下就几乎没有站起来的时候，人就像机器一样一刻不得停歇。不夸张地说，那段时间比高三还要辛苦。我以前是某份报纸的忠实读者，从大学开始每一期都买，但这样一个坚持了几年的习惯，也在那三个月中被生生中止了，因为我发现我已经连读报的时间都挤不出来了。&lt;/p&gt;
&lt;p&gt;那时我也有一些疑惑，这个状态是不是不太合理？但因为当时在公司还是新人，加上对大厂有着天然的敬畏，觉得领导一定比我厉害，既然这么安排，一定是有道理的，如果我完不成，一定是我的能力有问题。看，多好的打工人啊！于是我咬着牙，把压力硬抗下来了，没有向上级抱怨过一句。&lt;/p&gt;
&lt;p&gt;最后，项目终于按时完成上线了，我也终于恢复了正常上下班。但我的身心极度疲惫，几乎做什么事都提不起精神，直到一两个月后才缓过来。&lt;/p&gt;
&lt;p&gt;然后，我惊讶地发现领导其实自始至终都并没有意识到那段时间我所承受的压力，因为他并不是研发出身，不懂技术，见我顺利完成了，便以为这只是常规操作，甚至没有一句表扬或者安慰。所以，那段痛苦的加班经历其实也有我的问题，我应该及时把这个压力反馈给领导，如果不能多争取一些开发时间，至少应该再争取一位同事来分担一部分工作，这样也许那几个月的加班就可以一定程度地避免。但更让我震惊的是，这个我们如此辛苦做出来的项目，上线后不久就又下线了，因为用户不喜欢，负面反馈非常多。所以，可以说，我们那三个月的辛苦，并没有太多的价值。&lt;/p&gt;
&lt;p&gt;从那时起，我就对这类加班产生了怀疑，也对各类大干快上的项目心存警惕。方向很重要，如果方向错了，再努力也是白搭，拿时髦的话来说，就是“不要用战术上的勤奋来掩盖战略上的懒惰”。同时，人不是机器，体力和精力都是有限的，长时间的加班并不是好主意。后来我也读了很多效率相关的书以及文章，有一张关于&lt;a href=&quot;https://oldj.net/article/2011/12/06/rules-of-productivity/&quot;&gt;生产率法则&lt;/a&gt;的图我觉得非常经典：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://oldj.net/uploads/files/201112/06/20111206194759_nLRPx.png&quot;/&gt;
&lt;figcaption&gt;生产率与工作时间&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;短时间的加班，的确会增加产出，但这就像短跑冲刺，不可长期持续，而且并不是没有代价的，一段时间之后，人就会疲惫，效率急剧下降，甚至会比正常上下班的时候还要低效。&lt;/p&gt;
&lt;p&gt;简单来说，长时间高强度的加班不可持续，就像没有人能用短跑的模式跑完马拉松。&lt;/p&gt;
&lt;p&gt;不过在那时，加班仍然不是常态，大多数时候我们仍然能按时下班，那几个月的加班只是一段插曲。那几年我觉得工作总体是快乐的，也很喜欢自己的工作，空闲时间我会阅读大量的书籍，也会主动研究各类技术上的问题，甚至有时在半夜突然想到工作上有个地方有 bug，于是立刻起床开电脑处理，有时我也会主动加班，并且丝毫不觉得辛苦。&lt;/p&gt;
&lt;p&gt;那仍然是一个美好的时代。&lt;/p&gt;
&lt;p&gt;2013 年下年末，我转岗去了来往，这次转岗后来让我后悔了很久。了解来往的人应该知道，当时来往是阿里加班最严重的部门，那时，公司在来往上倾注了极大的期望，从上到下都非常重视，于是整个部门都如同陀螺一般飞速旋转，一个接一个的需求，一次接一次的迭代，让人忙得几乎没空喘气。&lt;/p&gt;
&lt;p&gt;那段时间有多忙呢？就说一点吧，忙得我几乎没时间看微博了。在那之前，我几乎每天都会在微博上自言自语一下，但那段时间里我经常连着几天都没时间打开微博页面。&lt;/p&gt;
&lt;p&gt;这种高强度的 996 持续了几个月之后，我发现自己快崩溃了，每天晚上回到家，往床上一倒，然后就一动也不想动，几乎没有精力思考，更不用说读书或者学习了，只想着让大脑放空，更糟糕的是尽管这么累，晚上却还时不时地失眠，经常在床上辗转反侧到凌晨两三点才迷迷糊糊地睡着，等第二天早上闹钟一响又得起床，拖着沉重的身躯赶去公司继续一天的忙碌。那种感觉，就像心里不甘心这一天就这么过去，因为一天都太忙了，忙得失去了自我，只有这夜深人静的夜晚，没有任务，没有工作，也没有人找，时间是属于自己的。&lt;/p&gt;
&lt;p&gt;半年之后，我再次转岗，离开了来往。但遗憾地发现，此时 996 的风气已经起来了，加班成了政治正确，公司内几乎不管哪个团队都在加班，好一点的还能保证双休，差的就直接 996 了。当然，有一些团队是真忙，就像我上面提到的那种连轴转，这种或许可以称为“硬核 996”，还有一些则是假忙，明明没那么多事，但领导或 HR 却硬要把人耗在办公室，甚至经常把会议或培训安排在晚上，却不知员工们因为疲惫，效率早就非常低下了，这样的情况我也经历过，这种加班大概可以称为“摸鱼 996”。&lt;/p&gt;
&lt;p&gt;经常在网上看到一些言论，说觉得 996 也没那么辛苦，我想这些人经历的大概是摸鱼 996。如果你上班时还经常能看看微博，或者浏览下工作无关的网站，那的确不是那么辛苦。但如果提高一点效率然后能准时下班，把下班后的时间花在更美好的事物上，难道不是更好的事吗？&lt;/p&gt;
&lt;p&gt;无论是硬核 996 还是摸鱼 996，都是不健康的，是一种透支，也许适合部分人，或者适合部分人的某个人生阶段，但绝对不适合所有人的所有人生阶段，因此，它应该只是可选项，而不应该成为必选。&lt;/p&gt;
&lt;p&gt;996 最大的伤害在于吞噬了大量本该属于你的宝贵时间，让你的人生除了工作之外的部分逐渐沦为荒漠。甚至在某种程度上，996 也是对你家人的剥削，比如你本该多一些时间陪伴你的爱人和孩子，帮爱人分担一些家务，和孩子谈谈心、辅导一下作业，但因为 996，你缺席了。如果你手上的工作正好就是你想做的事，那自然是最好的，但如果你还有别的理想，或者别的爱好呢？996 的情况下，你还有多少时间去探索和追求它们？&lt;/p&gt;
&lt;p&gt;每一个 996 公司的背后，都有一批燃烧着自己、透支着未来的年轻人，但他们中的大部分其实并不能得到相应的回报，这大概就是资本时代的“一将功成万骨枯”吧。&lt;/p&gt;
&lt;h2&gt;996 的未来&lt;/h2&gt;
&lt;p&gt;996 本质上是劳资双方的话语权不对等造成的。资本天然是逐利的，当资本觉得让员工加班能获得更大收益时，它就会有这样做的动机，问题是，员工有没有足够的力量与之抗衡？&lt;/p&gt;
&lt;p&gt;什么情况下 996 会消失呢？应该主要有两种可能：第一，资本发现长时间加班并不能带来额外的收益，甚至会带来损失；第二，绝大部分普通员工都能够拒绝加班。&lt;/p&gt;
&lt;p&gt;不可否认，之前的确有大量的企业靠让员工加班赚到了更多的钱，所以现在会有 996 存在。尽管很多人呼吁在 IT 这样的脑力劳动行业，长时间加班其实会降低效率，不如 8 小时工作制，但遗憾的是这个领域那些最有话语权的管理者们并不相信，因为他们中的大多数并没有真正经历过这样的生活，或者说他们以为自己经历过，但他们脱离一线已经太久远，早已不能真正理解和代表广大一线员工了。&lt;/p&gt;
&lt;p&gt;怎么能让现代的资本们像百年前的福特那样，认识到长时间加班其实也是在损害他们自己的利益呢？大概有两条途径，一是他们自己主动发现，比如某位巨头聘请了专业的研究机构进行研究，并得到了这样的结论，他们照着做了，并且真的取得了成功。另一种就是监管出面，对违反劳动法长时间加班的企业处以高额罚款，并且严格执法。遗憾的是，目前来看，短时间内这两者都很难出现。&lt;/p&gt;
&lt;p&gt;那么，怎么能让劳动者有说不的底气呢？所谓底气，就是有人能给你托底，让你知道最坏的情况也坏不到哪里去，这样当你遇到不喜欢的工作或者被强迫加班时，就可以大胆地拒绝。现在有一些家境还不错的年轻人其实就很有底气，他们无疑是幸运的，当你可以说不的时候，你才是自由的。&lt;/p&gt;
&lt;p&gt;但大部分普通人，尤其是上有老下有小的普通中年人，恐怕就没有那么多的底气，一旦失业，只要几个月没有收入，一家人的生活可能就会陷入窘迫状态。&lt;/p&gt;
&lt;p&gt;这样的情况下，谁能给这些广大的普通人托底呢？大概只有等进一步完善的社会福利吧，在此之前，大部分普通人在职场上只能过着战战兢兢、任劳任怨的生活。&lt;/p&gt;
&lt;p&gt;所以，要让 996 消失，或许只有等这些变化发生：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;大量资本家发现从生产规律上来看，长时间加班会损害他们的利益；&lt;/li&gt;
&lt;li&gt;监管部门严格执法，对违反劳动法加班的企业进行严格处罚；&lt;/li&gt;
&lt;li&gt;整体社会的财富以及福利水平提高，让普通劳动者能承担得起失业的成本。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在此之前，996 大概不会消失。&lt;/p&gt;
&lt;p&gt;当然，大环境虽然是这样，但并不代表所有公司都会走 996 的路线，世界那么大，一定会有一些公司相信 996 并不是好的策略，它们更尊重技术，也更尊重员工，并且它们活得还不错。希望这样的公司数量更多一些，赚得也更多一些，那么我们的未来就也会更好一些。&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>