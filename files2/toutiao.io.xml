<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>24d1c3fb39d88510799d8a661df2223d</guid>
<title>从 RPC 到服务化框架设计</title>
<link>https://toutiao.io/k/rh7pc7w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：allendbwu，腾讯 PCG 后台开发工程师&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前互联网系统都是微服务化，那么就需要 RPC 调用，因此本文梳理了从 RPC 基本框架协议到整个服务化框架体系建设中所包含的知识点，重点在于 RPC 框架 和 服务治理能力的梳理，本文定位于一个科普性质的文章，在于让大家了解一个全貌。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、RPC 基本框架&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1-1、RPC 基本框架&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;理解 RPC&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RPC 的概念就是远程过程调用。我们本地的函数调用，就是 A 方法调 B 方法，然后得到调用的结果，RPC 就是让你像本地函数调用一样进行跨服务之间的函数调用。互联网发展到现在，我们都在讲微服务，服务都拆分为微服务了，那么相关依赖的调用，就会变成跨服务之间的调用，而他们之间的通信方式就是依靠 RPC。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RPC 基础结构（RPC 协议）&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nelson 的论文 &lt;a href=&quot;http://www.cs.cmu.edu/%7Edga/15-712/F07/papers/birrell842.pdf&quot; data-linktype=&quot;2&quot;&gt;Implementing Remote Procedure Calls&lt;/a&gt; 告诉我们， RPC 协议包括 5 个部分：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Client&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Client-stub&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RPCRuntime&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Server-stub&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Server&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3864104323953329&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauxfFP5ianjpzLhycSKm03aNjicGVia4dDLiaias8f8F194kQTyUV0HemJNmlibWoGmQtXzOlZmI0Exhd1g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1457&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 Client 发起一个远程调用时，它实际上是调用本地的 Stub。&lt;strong&gt;本地 stub 负责将调用的接口、方法和参数，通过约定的协议规范进行编码，并通过本地的 RPCRuntime 进行传输，然后将数据包发送到网络上传输出去&lt;/strong&gt;。当 Server 端的 RPCRuntime 收到请求后，交给 Server-Stub 进行解码，然后调用 Server 端的函数或者方法，执行完毕就开始返回结果，Server-Stub 将返回结果编码后，发送给 Client，Client 端的 RPCRuntime 收到结果，发给 Client-Stub 解码得到结果，返回给 Client。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里面分了三个层次:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对于客户端和服务端，都和原来本地调用一样，只需要关注自身的业务逻辑。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于 Stub 层，处理双方约定好的语法、语义、封装、解封装。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于 RPCRuntime，主要处理高性能的传输，以及网络的错误和异常。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1-2、RPC 框架的重点&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 RPC 基础结构中，我们总结出 RPC 框架的重点，包括 4 部分，如下：&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1-2-1、数据序列化&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;序列化就是将数据结构或对象转换成二进制的过程，也就是编码的过程，序列化后数据才方便进行网络传输；反序列化就是在序列化过程中所生成的二进制转换成数据结构或者对象的过程，将二进制转换为对象后业务才好进行后续的逻辑处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的序列化协议如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ProtoBuf（IDL）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JSON&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;XML&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Hessian2 （JAVA 系）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的 RPC 框架如 gRPC、Thrift、Dubbo、RPCX 、Motan 等会支持上述协议中的大部分，尤其是 ProtoBuf 和 JSON 。目前从性能上和使用广泛度上来看，现在一般推荐使用 ProtoBuf，当然很多自研的框架里面他们也会自己实现他们自己的序列化协议。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1-2-2、网络传输（网络通信）&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在数据被序列化为二进制后就可以行网络传输了，网络传输就是我们的数据怎么传输到对方服务器上，目前来说，常见的通信传输方式包括 ：TCP、UDP、HTTP(HTTP2.0)、QUIC 协议，TCP 是大部分框架都会默认支持的，额外这里要说明一下，RPCX 支持 QUIC 而 gRPC 支持 HTTP2.0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;QUIC（Quick UDP Internet Connection）是谷歌制定的一种互联网传输层协议，它基于 UDP 传输层协议，同时兼具 TCP、TLS、HTTP/2 等协议的可靠性与安全性，可以有效减少连接与传输延迟，更好地应对当前传输层与应用层的挑战。QUIC 在应用程序层面就能实现不同的拥塞控制算法，不需要操作系统和内核支持，这相比于传统的 TCP 协议，拥有了更好的改造灵活性，非常适合在 TCP 协议优化遇到瓶颈的业务。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1-2-3、RPC 调用方式&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网络传输只是数据传输非常基础的一方面，从业务上来看，我们发起一次 RPC 调用，那么还需要 RPC 的调用方式，包括如下三大类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;同步 RPC：最常用的服务调用方式，发起调用请求后同步等待结果，符合我们开发的一贯认知和习惯。开发简单、容易维护、容易理解。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;异步 RPC：客户端发起服务调用之后，不同步等待响应，而是注册监听器或者回调函数，待接收到响应之后发起异步回调，驱动业务流程继续执行，实现起来相对复杂，但是高并发场景下性能会更好。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;并行 RPC：并行服务调用，一次 I/O 操作，可以发起批量调用，这个并行的批量请求一般是通过协程来实现，然后同步等待响应；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这里需要注意，这个 并行 RPC 和 stream 流式调用是有区别的，流式是说，批量发送请求后，可以不必等所有的消息全收到后才开始响应，而是接收到第一条消息的时候就可以及时的响应。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1-2-4、服务治理&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RPC 协议只是定义了 Client 与 Server 之间的点对点调用流程，包括 stub、通信协议、RPC 消息解析等部分。但是在实际应用中，远程过程调用的时候还需要考虑服务的路由、负载均衡、高可用等问题，而保障服务之间的调用就需要进行服务治理，服务治理基本就涵盖：服务注册和发现、限流、降级、熔断、重试、失败处理、负载均衡等各种服务治理策略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，RPC 框架的重点的 4 大部分就介绍完毕了，现在再来看看，常见的 RPC 框架：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1-3、常见 RPC 框架&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RPC 框架就是在 RPC 协议的基础上，来完善一些偏向业务实际应用的功能，从而满足不同场景的业务诉求。综合来看，目前业界的 RPC 框架大致有两种不同的侧重方向，一种偏向于服务治理型，一种偏向于跨语言调用型。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1-3-1、服务治理型 RPC 框架&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业界比较出名的服务治理型的 RPC 框架有 Dubbo、DubboX、Motan、RPCX 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务治理型 RPC 框架的特点是功能丰富，提供高性能的远程调用以及服务发现、服务治理等功能；常用于微服务化的业务系统中，对于特定语言的项目可以十分友好的透明化接入，是当前业界的主流。但缺点是语言耦合度较高，跨语言支持难度较大。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1-3-2、跨语言调用型 RPC 框架&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业界比较出名的跨语言调用型的 RPC 框架有 ：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跨语言调用型 RPC 框架的重点是关注于服务的跨语言调用，能够支持我们常见的大部分的语言进行语言无关的调用，非常适合于为不同语言提供通用远程服务的场景，但这类框架没有服务发现、服务治理等机制，使用这些框架的时候需要我们自己来实现服务发现、服务治理等相关策略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，跨语言调用指的是啥意思呢，具体是：客户端和服务端可以在各种环境中运行和相互通信，并且可以用框架支持的任何语言编写（参考 gRPC 官网中的一张图如下，比如 C++ 的服务可以调用 Ruby 的服务：）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.592391304347826&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauxfFP5ianjpzLhycSKm03aNA1v4Rg12JtK4xkuc0zqPQF2a0y97vy3IbrsK94m2a3ib5OVdDn8c5IQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;552&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1-3-3、常见 RPC 框架对比&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.509478672985782&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauxfFP5ianjpzLhycSKm03aNEZZQbUFlickZWPgia9vsNlHq935YO1a2aRVy3kNPH8lFtOl15nf4cbJw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;844&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、通用的服务化框架设计&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一般讲的微服务框架包含了 RPC 框架，微服务体系中最重要的就是 RPC 框架，并且是一般是偏向服务治理的 RPC 框架。&lt;strong&gt;微服务需要提供的核心能力包括：微服务架构中通讯的基础协议 RPC、服务发现与注册、负载均衡、容错、熔断、限流、降级、权限、全链路日志跟踪。&lt;/strong&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2-1、微服务框架的核心能力（服务治理策略）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2-1-1、服务注册与发现&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微服务后，服务大量增加，因此我们一定要能够有一个合适的方案能够发现对方的所有服务，业界比较常见的服务发现的组件如 zookeeper、etcd、consul 等，基本原理就是先将自己的服务列表到注册中心注册，然后再提供服务发现能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务发现机制有服务端发现和客户端发现两种实现方式:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;服务端发现模式(server-side):可以通过 DNS 或者带 VIP 的负载均衡实现。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;优点是对客户端无侵入性，客户端只需要简单的向负载均衡或者服务域名发起请求，无需关系服务发现的具体细节，也不用引入服务发现的逻辑&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺点是不灵活，不方便异化处理；并且同时需要引入一个统一的负载均衡器。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;客户端发现模式(client-side):需要客户端到服务注册中心查询服务地址列表，然后再决定通过哪个地址请求服务。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;灵活性更高，可以根据客户端的诉求进行满足自身业务的负载均衡，但是客户端需要引入服务发现的逻辑，同时依赖服务注册中心&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;常见服务注册组件包括：zookeeper、Etcd、Consul。java 系的一般选择 zookeeper ，而 Golang 的一般选择 consul 或 etcd ，这个也就是各自选择对应的语言。etcd 相比而言，是用的较多的，K8s 系统里面也基于是 etcd。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2-1-2、服务路由 &amp;amp; 负载均衡&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务路由和服务发现紧密相关，服务路由一般不会设计成一个独立运行的系统，通常情况下是和服务发现放在一起实现的。在服务路由中，最关键的能力就是负载均衡。我们一般常见的负载均衡算法有：随机路由、轮询路由、hash、权重、最小压力路由、最小连接数路由、就近路由等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从业界来看，负载均衡的实现方案一般可以分为三类:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;服务端负载均衡:&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;负载均衡器在一台单独的主机上，可以采用软负载，如 Nginx，LVS 等，也可以采用硬负载，如 F5 等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现简单，存在单点问题，所有的流量都需要通过负载均衡器，如果负载均衡器存在问题，则直接导致服务不能正常提供服务；中间经过负载均衡器做代理，性能也有一定损耗。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;客户端负载均衡&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;解决了服务端负载的单点问题，每个客户端都实现了自己的负载功能，负载能力和客户端进程在一起&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;负载均衡要求每个客户端自己实现，如果不同的技术栈，每个客户端则需要使用不同的语言实现自己的负载能力。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;目前业界主流的 微服务框架都是采用 客户端负载均衡方案&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;客户端主机独立负载均衡&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;服务发现和负载的能力从客户端进程移出，客户端进程和负载均衡进程是 2 个独立的进程，在同一个主机上。也就是 &lt;a href=&quot;http://dockerone.com/article/8105&quot; data-linktype=&quot;2&quot;&gt;SideCar 模式&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有单点问题，如果一个主机的负载均衡器出问题，只影响一个节点调用，不影响其他的节点，负载均衡器本身负载也较小，性能损耗较低&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2-1-3、服务容错&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;负载均衡和容错是服务高可用的重要手段&lt;/strong&gt;。服务容错的设计有个基本原则，就是“Design for Failure”。&lt;strong&gt;常见的服务容错策略如请求重试、限流、降级、熔断、隔离&lt;/strong&gt;&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;超时与重试&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;超时机制算是一种最常见的服务容错模式了，我们发起的任何请求调用，都不可能无限等待，对方服务可能因为各种原因导致请求不能及时响应，因此超时机制是最基础并且是必须的。超时可能有网络超时、也可能是对方服务异常等多种情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重试一般和超时模式结合使用，适用于对于下游服务的数据强依赖的场景，通过重试来保证数据的可靠性或一致性，不强依赖的场景不建议使用。在对方服务超时之后，可以根据情况进行重试(对方服务返回异常就不要重试了)。但是一定注意，重试不能盲目重试，在重试的设计中，我们一般都会引入，&lt;strong&gt;Exponential Backoff 的策略，也就是 &quot;指数级退避&quot;，每一次重试所需要的 sleep 时间都会指数增加&lt;/strong&gt;，否则可能会导致拖累到整个系统。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;服务限流&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;限流和降级用来保证核心服务的稳定性；限流是指限制每个服务的最大访问量、降级是指高峰期对非核心的系统进行降级从而保证核心服务的可用性&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限流的实现方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;计数器方式（最简单）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;队列算法&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;漏斗(漏桶)算法 Leaky Bucket&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;令牌桶算法 Token Bucket&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;基于响应时间的动态限流&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;参考 TCP 协议中算法：TCP 使用 RTT 来探测网络的延时和性能，从而设定相应的“滑动窗口”的大小&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式限流和单机限流：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;单机限流：单机限流参考上面的实现方式可以发现有多种限流算法可供选择，但是业界我们最常用的是漏桶算法及令牌桶算法。如果要对线上并发总数进行严格限定的话，漏桶算法可能会更合适一些。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;分布式限流（集群限流）：集群限流的情况要更复杂一些，一般是中心化的设计。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;简单的实现可以基于 Redis 来做，但是方案的缺点显而易见，每取一次令牌都会进行一次网络开销，而网络开销起码是毫秒级，所以这种方案支持的并发量是非常有限的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;另外一个简单的实现思路是先在各个微服务节点上实现一个计数器，对单位时间片内的调用进行计数，单个节点的计数量定期推送汇总，然后由中心化的统计服务来计算这个时间片的总调用量，集群限流分析器会拿到这个总调用量，并和预先定义的限流阈值进行比对，计算出一个限流比例，这个限流比例会通过服务注册中心下发到各个服务节点上，服务节点基于限流比例会各自算出当前节点对应的最终限流阈值，最后利用单机限流进行流控。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;分布式限流业界常用的框架包括 Hystrix、resilience4j&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;容错降级&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;容错降级可以分为三大类，从小到大依次是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接口降级：最小的降级类别。对非核心接口，在需要降级的时候，可以直接返回空或者异常，以减少高峰期这些非核心接口对资源如 CPU、内存、磁盘、网络的占用和消耗&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;功能降级：对非核心功能，在需要降级的时候，可以直接执行本地逻辑，不做跨服务、跨网络访问；也可设置降级开关，一键关闭指定功能，保全整体稳定；还可以通过熔断机制实现。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;服务降级：对非核心服务，可以通过服务治理框架根据错误率或者响应时间自动触发降级策略；还可以通过断路器实现&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;熔断&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熔断设计来源于日常生活中的电路系统，在电路系统中存在一种熔断器（Circuit Breaker），它的作用就是在电流过大时自动切断电路。熔断器一般要实现三个状态：闭合、断开和半开，分别对应于正常、故障和故障后检测故障是否已被修复的场景。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;闭合：正常情况，后台会对调用失败次数进行积累，到达一定阈值或比例时则自动启动熔断机制。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;断开：一旦对服务的调用失败次数达到一定阈值时，熔断器就会打开，这时候对服务的调用将直接返回一个预定的错误，而不执行真正的网络调用。同时，熔断器需要设置一个固定的时间间隔，当处理请求达到这个时间间隔时会进入半熔断状态。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;半开：在半开状态下，熔断器会对通过它的部分请求进行处理，如果对这些请求的成功处理数量达到一定比例则认为服务已恢复正常，就会关闭熔断器，反之就会打开熔断器。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熔断设计的一般思路是，在请求失败 N 次后在 X 时间内不再请求，进行熔断；然后再在 X 时间后恢复 M% 的请求，如果 M% 的请求都成功则恢复正常，关闭熔断，否则再熔断 Y 时间，依此循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在熔断的设计中，根据 Netflix 的开源组件 hystrix 的设计，最重要的是三个模块：熔断请求判断算法、熔断恢复机制、熔断报警：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;熔断请求判断机制算法：根据事先设置的在固定时间内失败的比例来计算。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;熔断恢复：对于被熔断的请求，每隔 X 时间允许部分请求通过，若请求都成功则恢复正常。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;熔断报警：对于熔断的请求打异常日志和监控，异常请求超过某些设定则报警&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;隔离&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;隔离，也就是 Bulkheads 隔板的意思，这个术语是用在造船上的，也就是船舱里防漏水的隔板。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在服务化框架的隔离设计中，我们同样是采用类似的技术来让我们的故障得到隔离。因此这里的重点就是需要我们对系统进行分离。一般来说，有两种方式，一种是以服务的类型来做分离，一种是以用户来做分离。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;以服务的种类来做分离的方式：比如一个社交 APP，服务类型包括账号系统、聊天系统，那么可以通过不同系统来做隔离&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;以用户来做分离的方式：比如通过策略来实现不同的用户访问到不同的实例&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2-1-4、集群容错&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式场景下，我们的服务在集群中的都是有冗余的，一个是为容错，一个是为了高并发，针对大量服务实例的情况下，因此就有了集群容错的设计。集群容错是微服务集群高可用的保障，它有很多策略可供选择，包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;快速失败（Failfast）：快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;失败转移（Failover）：失败自动切换，当出现失败，重试集群其它服务实例 。通常用于读操作，但重试会带来更长延迟。一般都会设置重试次数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;失败重试（Failback）:失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;聚合调用（Forking）:并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。一般会设置最大并行数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;广播调用（Broadcast）:广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2-2、微服务框架的基础能力&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;服务监控和告警&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开源代表作：Prometheus + Grafana，遵循 OpenMetrics 规范，基本数据格式分为 Gauge、Count、Summary、Histogram&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分布式服务 Tracing 跟踪系统&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前有两种协议规范：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;OpenTracing ：链路跟踪领域的标准，目前业界系统支持最多的标准，开源代表作：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;OpenTelemetry：可观测性领域的标准，对 Trace，Metrics，Log 统一支持的唯一标准。OpenTelemetry 由 OpenTracing 和 OpenCensus 合并而成，和 OpenTracing 是一个互补的形态。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置中心&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置中心用来管理大量微服务之间的业务配置，并且是中心化的统一配置中心来进行管理。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;远程日志&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;远程日志组件的代表作是 ELK 系统：Elasticsearch, Logstash, Kibana。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在微服务架构中，一个客户端请求的接入，往往涉及到后端一系列服务的调用，如何将这些请求串联起来？业界常用的方案是采用全局流水号【traceID】串联起来。通过全局流水号【traceID】，从日志里面可以拉出整条调用链路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里关于整体链路又和 分布式服务 Tracing 跟踪系统 关联起来，Tracing 可以知道整体链路的请求质量，远程日志+ traceID 可以知道整体链路的日志详情。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2-3、微服务框架依托的自动化运维能力&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微服务框架建设 ok 之后，那么大量服务怎么运维，这就依托自动化运维能力，包括如下几个方面：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业界目前一般采用容器平台，&lt;strong&gt;微服务框架 + K8s 容器平台 是当今互联网业务的黄金标准&lt;/strong&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2-4、小结：自己搭建一个服务化框架的思路&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自己搭建一个服务化框架的思路:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先，要确定好基本的 RPC 通信协议，一般会选择开源方案，重点关注：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;功能需求的满足度&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多语言的支持&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能和稳定性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;社区活跃度、成熟度&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;其次，基于开源的 RPC 框架来搭建而不是完全从 0 开始。可选的框架包括&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Dubbo&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Motan&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gRPC&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Thrift&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关于方案的对比，这里不再陈述，网上可以搜索得到，想要表达的是，每个公司的情况不一样，开发人员的能力和语言也不一样，因此方案选型需要根据自身情况而定，没有最好，只有最合适！&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;最后，Go 语言方面，gRPC 是业界公认的比较好的 RPC 框架，基于 gRPC + 一些服务治理策略可以实现一个服务化框架。这些服务治理的策略，很多也都可以用一些开源的组件。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;腾讯程序员视频号最新视频&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAh_cW1X0FvwAAAAstQy6ubaLX4KHWvLEZgBPEz6FYRFgpfqf9zNPgMItOFKxaKuC_m_gwM6S311lB&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=XGocBFxVWK5dcyOOqpEU47RpBHQIvlhnc81ePuGBwWgUcfUy3LA19mJRk6BNg8WbOe3kE3kqtFMGuFt6IaVMqjdDSUKJNiaHlDIiaHYAZdC0nWcyUjTzdtMxxkibZ6p4rTRjjWAQkhZ0eeFkXkd6IdxUvuxic7ONubdqKDCVsu3PNt1tEkl4zbByGWcRBWpBAQL4&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=d3d65cb4df9cb008820e2b586cd3437c&amp;amp;token=x5Y29zUxcibAKmIHnM3ooSteUXmiaibxx058A221MASoXVsNibtOhYsiaYQtFPE2eO4rWzaTtgfLrChY&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;用这个朋友圈拼图也太简单了&amp;#10;&amp;#10;#朋友圈&amp;#10;&quot; data-nonceid=&quot;13324595909787032563&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ecea725e4bc460bc718d87ec985c93dd</guid>
<title>Spring Boot 原理：自动配置机制</title>
<link>https://toutiao.io/k/1llx7pa</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;在当下的java生态里，SpringBoot已经成为事实上的开发标准，绝大多数人现在都是面向SpringBoot编程。SpringBoot是对Spring的进一步封装，整合了分布式系统上下游所需的各种类库和组件，并且实现了开箱即用，而这一切的底层基础就是SpringBoot的自动配置机制。&lt;/p&gt;&lt;h2&gt;Spring配置类&lt;/h2&gt;&lt;p&gt;Spring引入配置类是为了：1）替换冗长繁琐的配置文件，2）提供更灵活的bean定义方式。使用@Configuration注解去标记一个配置类，通过其中含有@Bean注解的方法去创建一个bean，如下代码&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;HelloAutoConfiguration&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    HelloService &lt;span&gt;helloService&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;HelloService&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即为一个简单的配置类，并且定义了一个HelloService的bean。在此之上，Spring还提供了一套条件加载机制，可以去动态控制一个配置类是否被加载。通过实现&lt;code&gt;org.springframework.context.annotation.Condition&lt;/code&gt;接口，开发者就可以自己控制配置类的加载条件，满足很多复杂的场景&lt;/p&gt;&lt;h2&gt;SpringBoot自动配置&lt;/h2&gt;&lt;p&gt;介绍完了Spring的配置类，我们来看看SpringBoot是怎么利用这套机制去实现自动配置的。&lt;/p&gt;&lt;h4&gt;自动配置的概念&lt;/h4&gt;&lt;p&gt;首先，什么是自动配置？我们看一下SpringBoot对于自动配置类的定义：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;Auto-configuration classes&lt;/strong&gt; are regular Spring &lt;code&gt;@Configuration&lt;/code&gt; beans. They are located using the &lt;em&gt;SpringFactoriesLoader&lt;/em&gt; mechanism (keyed against this class). Generally auto-configuration beans are &lt;code&gt;@Conditional&lt;/code&gt; beans (most often using &lt;code&gt;@ConditionalOnClass&lt;/code&gt; and &lt;code&gt;@ConditionalOnMissingBean&lt;/code&gt;annotations).&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;自动配置类就是一个普通的&lt;code&gt;@Configuration&lt;/code&gt;配置类，通常会带有一些&lt;code&gt;@Conditional&lt;/code&gt;条件注解，并且使用SpringFactoriesLoader机制去定位加载它们（并非都是如此，还有其他一些Spring固有的加载方式，比如通过&lt;code&gt;@ComponentScan&lt;/code&gt;包扫描或者显式&lt;code&gt;@Import&lt;/code&gt;方式都可以让它们被发现）。&lt;/p&gt;&lt;h4&gt;自动配置的运行机制&lt;/h4&gt;&lt;h5&gt;加载方式&lt;/h5&gt;&lt;p&gt;自动配置机制的启用是通过&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;注解去控制的，因此需要在SpringBoot工程的入口类上启用该注解，但是通常，我们一般使用&lt;code&gt;@SpringBootApplication&lt;/code&gt;来代替，后者是一个注解的合集，包含了一些必要的默认配置，其中就有&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;注解，其类的注释上是这么描述的：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Indicates a Configuration class that declares one or more &lt;code&gt;@Bean&lt;/code&gt; methods and also triggers &lt;em&gt;auto-configuration&lt;/em&gt; and &lt;em&gt;component scanning&lt;/em&gt;. This is a convenience annotation that is equivalent to declaring &lt;code&gt;@Configuration&lt;/code&gt;, &lt;code&gt;@EnableAutoConfiguration&lt;/code&gt; and &lt;code&gt;@ComponentScan&lt;/code&gt;.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;它本身既标识一个配置类，同时也开启了自动配置和组件扫描。&lt;/p&gt;&lt;p&gt;回到&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;注解上，我们看一下该注解的定义&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Target&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;ElementType&lt;span&gt;.&lt;/span&gt;TYPE&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Retention&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;RetentionPolicy&lt;span&gt;.&lt;/span&gt;RUNTIME&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Documented&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Inherited&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@AutoConfigurationPackage&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;AutoConfigurationImportSelector&lt;span&gt;.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;EnableAutoConfiguration&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    String ENABLED_OVERRIDE_PROPERTY &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;spring.boot.enableautoconfiguration&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    Class&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;exclude&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    String&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;excludeName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中&lt;code&gt;@Import(AutoConfigurationImportSelector.class)&lt;/code&gt;是功能生效的关键，该注解导入了&lt;code&gt;AutoConfigurationImportSelector&lt;/code&gt;组件到Spring环境中，开启自动配置类的扫描加载工作，该类实现了接口&lt;code&gt;org.springframework.context.annotation.ImportSelector&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ImportSelector&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Select and return the names of which class(es) should be imported based on&lt;br/&gt;     * the {@link AnnotationMetadata} of the importing @{@link Configuration} class.&lt;br/&gt;     * @return the class names, or an empty array if none&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    String&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;selectImports&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;AnnotationMetadata importingClassMetadata&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;其他省略&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中&lt;code&gt;selectImports&lt;/code&gt;方法会在Spring启动时被调用，用于返回所有的自动配置类，调用入口在&lt;code&gt;org.springframework.context.annotation.ConfigurationClassParser&lt;/code&gt;类中，该类是Spring专门用来加载处理所有&lt;code&gt;@Configuration&lt;/code&gt;配置类的，具体的加载细节，限于篇幅问题，就不在本文中展开说明了，读者们可自行去阅读源码，本人也许会在后续再另开一篇详细说明。接着说&lt;code&gt;selectImports&lt;/code&gt;方法，我们来看一下自动配置类的加载过程，&lt;code&gt;AutoConfigurationImportSelector&lt;/code&gt;对于该方法的具体实现为&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; String&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;selectImports&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;AnnotationMetadata annotationMetadata&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;isEnabled&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;annotationMetadata&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; NO_IMPORTS&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;        AutoConfigurationEntry autoConfigurationEntry &lt;span&gt;=&lt;/span&gt; &lt;span&gt;getAutoConfigurationEntry&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;annotationMetadata&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; StringUtils&lt;span&gt;.&lt;/span&gt;&lt;span&gt;toStringArray&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;autoConfigurationEntry&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getConfigurations&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;isEnabled&lt;/code&gt;方法是一个开关，用于控制是否启用自动配置，逻辑很简单，略过不提，往下看，关键逻辑在&lt;code&gt;getAutoConfigurationEntry&lt;/code&gt;方法中，跟下去&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    &lt;span&gt;protected&lt;/span&gt; AutoConfigurationEntry &lt;span&gt;getAutoConfigurationEntry&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;AnnotationMetadata annotationMetadata&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;isEnabled&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;annotationMetadata&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; EMPTY_ENTRY&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;        AnnotationAttributes attributes &lt;span&gt;=&lt;/span&gt; &lt;span&gt;getAttributes&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;annotationMetadata&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;        List&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;String&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; configurations &lt;span&gt;=&lt;/span&gt; &lt;span&gt;getCandidateConfigurations&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;annotationMetadata&lt;span&gt;,&lt;/span&gt; attributes&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;        configurations &lt;span&gt;=&lt;/span&gt; &lt;span&gt;removeDuplicates&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;configurations&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;        Set&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;String&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; exclusions &lt;span&gt;=&lt;/span&gt; &lt;span&gt;getExclusions&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;annotationMetadata&lt;span&gt;,&lt;/span&gt; attributes&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;checkExcludedClasses&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;configurations&lt;span&gt;,&lt;/span&gt; exclusions&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;        configurations&lt;span&gt;.&lt;/span&gt;&lt;span&gt;removeAll&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;exclusions&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;        configurations &lt;span&gt;=&lt;/span&gt; &lt;span&gt;getConfigurationClassFilter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;configurations&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;fireAutoConfigurationImportEvents&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;configurations&lt;span&gt;,&lt;/span&gt; exclusions&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;AutoConfigurationEntry&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;configurations&lt;span&gt;,&lt;/span&gt; exclusions&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很容易看到加载逻辑在&lt;code&gt;getCandidateConfigurations&lt;/code&gt;方法中，后续代码是去重和过滤的过程，再往下看&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    &lt;span&gt;protected&lt;/span&gt; List&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;String&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;getCandidateConfigurations&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;AnnotationMetadata metadata&lt;span&gt;,&lt;/span&gt; AnnotationAttributes attributes&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        List&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;String&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; configurations &lt;span&gt;=&lt;/span&gt; SpringFactoriesLoader&lt;span&gt;.&lt;/span&gt;&lt;span&gt;loadFactoryNames&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;getSpringFactoriesLoaderFactoryClass&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;getBeanClassLoader&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;        Assert&lt;span&gt;.&lt;/span&gt;&lt;span&gt;notEmpty&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;configurations&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;are using a custom packaging, make sure that file is correct.&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; configurations&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个方法就很简单明显了，直接调用&lt;code&gt;SpringFactoriesLoader&lt;/code&gt;去加载对应的内容，接下来我们再聊聊&lt;code&gt;SpringFactoriesLoader&lt;/code&gt;机制是怎么回事。&lt;/p&gt;&lt;h5&gt;SpringFactoriesLoader机制&lt;/h5&gt;&lt;p&gt;&lt;code&gt;SpringFactoriesLoader&lt;/code&gt;直译过来就是工厂加载机制，是Spring仿照Java的SPI机制实现的一套类加载机制，通过读取模块内的&lt;code&gt;META-INF/spring.factories&lt;/code&gt;文件来加载类，该文件为Properties格式，其中key部分是一个Class全限定名称，可以是一个接口、抽象类或者注解等，而value部分是一个支持逗号分割的实现类列表，比如&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.303125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UZibibiaQhjHtkKlXa8Dias6aWhSZibch65Bd6uIDZX6tD7CohWOd3VXRVibeKDsxmptDqVyhCcs73uvknYx3KIJZ1KA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而&lt;code&gt;SpringFactoriesLoader&lt;/code&gt;就是Spring提供的一个用于读取解析&lt;code&gt;META-INF/spring.factories&lt;/code&gt;文件的工具类，通过传入一个Class类型加载其对应的实现类列表。&lt;/p&gt;&lt;h5&gt;SpringFactoriesLoader如何应用在自动配置中&lt;/h5&gt;&lt;p&gt;介绍完了&lt;code&gt;SpringFactoriesLoader&lt;/code&gt;，我们来研究一下SpringBoot的自动配置机制中是怎么使用它的，回到上面的getCandidateConfigurations方法中，我们看一下这一行&lt;/p&gt;&lt;pre&gt;&lt;code&gt;List&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;String&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; configurations &lt;span&gt;=&lt;/span&gt; SpringFactoriesLoader&lt;span&gt;.&lt;/span&gt;&lt;span&gt;loadFactoryNames&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;getSpringFactoriesLoaderFactoryClass&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;getBeanClassLoader&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中第一个参数是key对应Class类型，第二个参数是用哪个ClassLoader去加载配置文件，我们看一下getSpringFactoriesLoaderFactoryClass这个方法返回的具体Class是什么&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    &lt;span&gt;protected&lt;/span&gt; Class&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;getSpringFactoriesLoaderFactoryClass&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; EnableAutoConfiguration&lt;span&gt;.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很简单，直接返回&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;注解对应的class类型，那么自动配置类在&lt;code&gt;META-INF/spring.factories&lt;/code&gt;文件中的配置方式就显而易见了，上面截图中最前面的部分&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# AutoConfiguration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;\&lt;br/&gt;org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration,\&lt;br/&gt;org.springframework.cloud.autoconfigure.LifecycleMvcEndpointAutoConfiguration,\&lt;br/&gt;org.springframework.cloud.autoconfigure.RefreshAutoConfiguration,\&lt;br/&gt;org.springframework.cloud.autoconfigure.RefreshEndpointAutoConfiguration,\&lt;br/&gt;org.springframework.cloud.autoconfigure.WritableEnvironmentEndpointAutoConfiguration&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就是对应的自动配置类了。这些被配置在此处的类都会被作为自动配置类加载到Spring中，然后进行相应的处理，发挥出每个类的功能作用。&lt;/p&gt;&lt;h2&gt;小结&lt;/h2&gt;&lt;p&gt;SpringBoot的自动配置机制就简单介绍到这里了，相信看官们看完了之后也都有了一些了解，当然这篇文章里还有很多相关内容没有涉及到，包括自动配置类的条件加载方式、多个类之间的加载顺序控制、排除和过滤机制，以及如何自定义自动配置类、重写框架默认行为等等，这些内容笔者会在后续的文章中再进行详细探讨。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6e353f89c1c2d8d38f7f49adc9616eec</guid>
<title>ACID 过时？用 Sagas 搞定数据一致性</title>
<link>https://toutiao.io/k/7uf1nzv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;

&lt;/p&gt;&lt;p&gt;&lt;span&gt;ACID Is So Yesterday:
Maintaining Data Consistency
with Sagas&lt;/span&gt;&lt;/p&gt;&lt;p&gt;
&lt;/p&gt;&lt;p&gt;&lt;span&gt;Chris Richardson&lt;/span&gt;&lt;/p&gt;&lt;p&gt;
&lt;/p&gt;&lt;p&gt;&lt;span&gt;Founder of Eventuate.io&lt;br/&gt;Founder of the original CloudFoundry.com
Author of POJOs in Action&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文素材作者  &lt;strong&gt;Chris Richardson&lt;/strong&gt;，由坐馆老G先生注解&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZt17Bv3FrNwKcKb0NrP9h81LRULMcWuD2icBqI2x3qia0FluEjbTjjtLHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;讲义goal：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式数据管理在微服务架构下的挑战&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Sagas 是一种事务模型&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtX244ianca4eKrCjR4iaP3Ymc5PiagdAAyGRSics6kibWia5K2ia87wFrzCGCw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于作者Chris&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大大有名&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;POJO‘s in action&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Microservice Patterns&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtqVFhtoARuwluCKkwWgnLLW94MtkqTU2y0euHCU3rkG1PlCcdOic6VtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZticwbe0x2T8ZILn0nx3kYndMQwVtGRADmiayYryaeW3vhBibOibQ9BIWJzQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtgGfUGGg1YVMjTiasYiaMZjruukm8oeEWO0rvtlicKWFLWQe3SO1ia3lUnQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtRUN8DMC3vZap9V8KoYuyAZyEBCusUpsSTJ1Wcfeeb9xguR5Od7paSw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtjmX96icImELK1tOxBVw5ibCicymKvP2zOax2MKz2MoGqoIoWwYIAA5xhg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZthoTFvicPExH7Vg0A4zkaztnYypFz30bVZX2IraWCseXT63buSk6d9jQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;微服务enable 持续部署&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;架构、组织和过程三角&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;架构：&lt;/strong&gt;微服务架构&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;组织：&lt;/strong&gt;小、敏捷、自组织功能团队&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;过程：&lt;/strong&gt;持续交付/部署&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;services = testability  and deployability&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtibPZA0nOMI7AnccRqgrtTw80BEaicoZG1NHgX6ibLgIUooMy3wFgIxeiaQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtcA5RQ4RkvHsYqMib0XhXSrEyWwoJcfXMPsULnia9jiaPyibPWWCKQ5kFqw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtMcicicuOs87LfycYYE0ibRKlTQWiaOMBicqt7wlzKWNoPaOlnuciaFmX6iciaw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;松耦合，数据封装&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtZlFxuSx6ibiaxBAANHyGfibWhkM6pGp48KpEbibOrDUVV784oa1WMVRrPQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何维护数据一致性呢？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtDA46mkxnLDjr1hj9VWr1gQZZxPZS8W1sTxhO9ja24oEHPzj1lFU7UQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于不在一个（本地）事务中......&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtwJjd4alnybRq2eNeNKJ5nP2Rp3LjK7Wn7hj7WafYkgBvPdS2JrrNhg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2PC 不是一个好的选择&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、2PC事务协调器单点故障问题&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、通讯：至少有O（4n）条消息，并重试O（n^2）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、锁导致吞吐量降低&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、许多NoSQL数据库（或消息代理）不支持&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5、CAP理论 ⇒ 2PC影响可用性&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtIMHXFkiaoCNfYWqZvhicnvv4zOkYfFpPbe1hLKte7NgVB78GdBp6bEsQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Ebay的Dan Pritchett 提出：&lt;/span&gt;&lt;/h3&gt;&lt;h2&gt;&lt;span&gt;In partitioned databases, trading some consistency for availability can lead to dramatic improvements in scalability.&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;并有一个著名的Base理论。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;Base: An Acid Alternative&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;Basically Available &lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Soft state&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Eventually consistent&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZt9CRN84TibFgduyOhWx2VuianzicT2JBhfBpc5PR11NXDXSdG6PV9zRMbQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtib5w2dXcicPNQozib3xKRZHHCh0rxOricbcIQcgqBzWBoogxROAibiaibiciccA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;sagas 可以追溯到1987年的论文&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1987年普林斯顿大学的Hector Garcia-Molina和Kenneth Salem发表了一篇Paper Sagas，讲述的是如何处理long lived transaction（长活事务）。Saga是一个长活事务可被分解成可以交错运行的子事务集合。其中每个子事务都是一个保持数据库一致性的真实事务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtmf0UzxKQibbsKtWgcF3IqJp7La0oNZLmib56C99X3sgoMuZzJNAkjOicQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtRC0Su9mmEicRcic9Bic8FapWjmOsKheBmJhZhhFyUTAEDh76RBBZzOc6A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtQ04MgBCvXQy1SibRpciaIQHTCgSEq6wlIktSjtt22qPhtcqBgKsEJWLQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtsBxnmD7RxPQBKntsIGLXUKRIasIYM8JiagNwLxWAf6jGhI6ZgYcP4OQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZt2fQ1mGU1UxueYPh6scp54nUhtIFSXrZbo9K3g0w5Yl1xKOqqlSHPbA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Saga的组成&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;可以看到，和TCC相比，Saga没有“预留”动作，它的T&lt;sub&gt;i&lt;/sub&gt;就是直接提交到库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Saga的执行顺序有两种：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;T&lt;sub&gt;1&lt;/sub&gt;, T&lt;sub&gt;2&lt;/sub&gt;, T&lt;sub&gt;3&lt;/sub&gt;, ..., T&lt;sub&gt;n&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;T&lt;sub&gt;1&lt;/sub&gt;, T&lt;sub&gt;2&lt;/sub&gt;, ..., T&lt;sub&gt;j&lt;/sub&gt;, C&lt;sub&gt;j&lt;/sub&gt;,..., C&lt;sub&gt;2&lt;/sub&gt;, C&lt;sub&gt;1&lt;/sub&gt;，其中0 &amp;lt; j &amp;lt; n&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Saga定义了两种恢复策略：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;backward recovery，向后恢复，补偿所有已完成的事务，如果任一子事务失败。即上面提到的第二种执行顺序，其中j是发生错误的sub-transaction，这种做法的效果是撤销掉之前所有成功的sub-transation，使得整个Saga的执行结果撤销。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;forward recovery，向前恢复，重试失败的事务，假设每个子事务最终都会成功。适用于必须要成功的场景，执行顺序是类似于这样的：T&lt;sub&gt;1&lt;/sub&gt;, T&lt;sub&gt;2&lt;/sub&gt;, ..., T&lt;sub&gt;j&lt;/sub&gt;(失败), T&lt;sub&gt;j&lt;/sub&gt;(重试),..., T&lt;sub&gt;n&lt;/sub&gt;，其中j是发生错误的sub-transaction。该情况下不需要C&lt;sub&gt;i&lt;/sub&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtg4WIkpNQ1qicmK806LIrsNr9ruAP8CJic7cHxWFnLd9l5zKia4YBAODCA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtvia2ycWSuIzqGllLk2EcFpOuLmpPqswDLveANKK9zCHbGialBr52VdDw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Sagas complicate API design （&lt;/span&gt;&lt;span&gt;Sagas 使 API 设计 复杂化 &lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Synchronous API vs Asynchronous Saga&lt;br/&gt;Request initiates the saga. When to send back the response? &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Option #1: Send response when saga completes:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;
&lt;/p&gt;&lt;p&gt;&lt;span&gt;+ Response specifies the outcome
- Reduced availability&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;选择一：saga完成的时候发送响应&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Option #2: Send response immediately after creating the saga&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(recommended)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;选择二：创建saga之后马上发送响应（推荐）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;+ Improved availability（&lt;span&gt;提高可用性&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- Response does not specify the outcome. Client must poll or be notified&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（响应没有指定结果。必须轮询或通知Client端）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;
&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZticKQzS8YQJnic5n1fhlTiaQ0FxZ08r2boVrBUnq6nTRAWtdAm2vwEQliag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtFYLIajAtZEW5gVfEicqYvKxibnWSY78jhxYgsZL0OSmIm5LAFrWRfwdQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用Sagas，可能影响用户体验。&lt;/p&gt;&lt;p&gt;UI界面向用户隐藏异步API&lt;/p&gt;&lt;p&gt;如果需要更长的时间， 用户界面显示“处理中”弹出窗口&lt;/p&gt;&lt;p&gt;服务器可以将通知推送到UI&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtd0fNco4T2GUVKqa4qF32ufIpRj2FpR7RqC4J6urOIBJl1VGZeTiaAmw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtgZyYfRXAMpL4v7ystHcSsfJXpP6ibiaVKy4UaEneGvH4SP3iaibUwbpePA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtsllKCeRNaxHwLgTXBQibJwkasWEbYKRBAiafc6K0FtFbXtX1PgMrIt8A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZthtIFjrOhV6ictcaruyewYicV0o7B6tnMyuAibWCth5VcOp8XhoZR9rIJQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;Sagas 拥有 ACD 特性&lt;/p&gt;&lt;p&gt;原子性、一致性、持久性&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtu4TqLSADNSVE2GExiaU0fsbjiaBwXr1kUFibibCYicNh3KBibKwZrbzlXibicA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;缺失隔离性&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtYXCbHHRQ61qTjJCtibfW6SSqLKm4aoibkfAg1WGAQ0jj32QuESZazKXA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Commutative updates&lt;/p&gt;&lt;p&gt;e.g. debit account can compensate for a credit account&lt;/p&gt;&lt;p&gt;Version file （版本文件）&lt;/p&gt;&lt;p&gt;Record history of changes （记录变化历史）&lt;/p&gt;&lt;p&gt;Use them to make updates commutative&lt;/p&gt;&lt;p&gt;e.g. record cancel reservation（记录 取消 预定） so that create/cancel = cancel/ create&lt;/p&gt;&lt;p&gt;Sounds suspiciously like event sourcing&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtwBYsQ3OnjRwLt7yGBW04lJsKzoicib9DJ4gBWC8v6ae14rhJ70rGZ0yQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtnGEpxskyqIadia8byoNF6nn1EibYibCObKUJ7lAsOXZhicM1RycHZpQvQw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtWyF9RGzJVPTlocN3FicwtMNg1DxOwE9nbtj1XhiaqFhOqYSeBic2CHfxg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtwg9se57qZc7iagN4pMI4yxVJP7uQh5dM6b0k7aSKw2locLxyIPmn0uQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZt10l32EfGJEArIJicjl9wnR7RBicS0kA3LJekbLOIOAOArbtCP5VwFkZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;

&lt;/p&gt;&lt;p&gt;&lt;span&gt;Choreography （编排）: &lt;/span&gt;&lt;span&gt;distributed &lt;/span&gt;&lt;span&gt;decision making
vs.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Orchestration（协调）: &lt;/span&gt;&lt;span&gt;centralized &lt;/span&gt;&lt;span&gt;decision making&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtEdBTySgtq00P20acOFRUGsLnRkNwgdl2yPsibGCujOR7cHW586dvRqw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;方案1:使用事件做基于编排模式的协作&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtecfjeJLibJpXmv4aZvcM1LdiaUyWy7DJRKQuNMcXEXJQWicGxB4ehfRlA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;优缺点：&lt;/p&gt;&lt;p&gt;
&lt;/p&gt;&lt;p&gt;&lt;span&gt;Benefits （&lt;/span&gt;&lt;span&gt;好处&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;简单，尤其使用事件溯源时&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参与者松耦合&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Drawbacks （缺点）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;
&lt;/p&gt;&lt;p&gt;&lt;span&gt;循环依赖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;领域对象过载，例如订单和客户相互知道太多&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Events = &lt;/span&gt;&lt;span&gt;ndirect way to
make something happen to
make something happen&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtKQSia2jiaAMGvDMHQtXY2SaMEL6maUsj3a2nKNhuAjoTRTMbOia54S6qg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;选项2：基于编排的saga协调&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtySEsJvhFlPgSbVBCUyIfHGvudPINdqLrjGvB00ic2ia9EkCT9X2GYe8g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;saga（&lt;/span&gt;&lt;span&gt;orchestrator &lt;/span&gt;&lt;/span&gt;&lt;span&gt;） &lt;/span&gt;&lt;span&gt;是一个持久性对象，跟踪&lt;span&gt;saga&lt;/span&gt;的状态，以及调用参与者&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtdw7RWvDXEkKvoaWLgOYhVICVud6rEz40vDaibRW5nEw1ibXBMaqtfU9w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtEdZJjN8SlfGTIqWicZDt3X7JLw5mXyYTmppdzxdm2op91dQibibicunYPg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtS28AsqnmPOg2yzafEL7AZ2Mf73jYoz3YUWoCeiaV7qbiaDwcLCGj7fnw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZt7Pgm3bmhEXuuyIJe0tKRiacjdic236K33KHoj4VPdBvkUNibSEQasc31w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtFHXANQZRIibIHicw8Xo8IFXn7IqwtEEjD43uKNloYviccFc1b6UibSgGTQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里有一个例子，开源的saga 框架&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZt8uAxuOl7jccWsmfurGu9ghvK3C3NhYodXdGWU4GFRiaibBsKricvVUibmw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt; &lt;span&gt;优缺点&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Benefits&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Centralized coordination logic is easier to understand&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Reduced coupling, e.g. Customer knows less&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Reduces cyclic dependencies&lt;/span&gt;&lt;/p&gt;&lt;p&gt;
&lt;/p&gt;&lt;p&gt;&lt;span&gt;Drawbacks&lt;/span&gt;&lt;/p&gt;&lt;p&gt;
&lt;/p&gt;&lt;p&gt;&lt;span&gt;Risk of smart sagas
directing dumb services&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtwv1gVecKN4fV1NWIcvbmpicBH8ACbI1dEwMIiaJSbk98q8UlHlcRTMUw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtlyKpgCyMHJbd0WIfpvCaaqGNtkWM12MPgN4z3XWKF1GDX6ntiaWUvDw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtOJJm8Eia4oxicuy0W23v4G7f1QyMAekicGTyqua8fMHBLnfzicfdQ8QnJA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtpdNGeiaOIJTlGQiaoQkMVO0DjvcCsUhATomQVVd08zsKldMicVp1sGrcw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtbpFXz2jJcp4IeUxvTBk1wsRBkvL1yzWMHKQ0ibJKdLeACYwxY9kRZCg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;消息必须支持事务&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtFbwJNr8JANHNdkMrDpSrZzee9CRnxedWKIkrlHt3ibm4ZKMelEHhw5A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;选择1:使用数据库表作为消息队列，ebay的案例&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZta3NXqMazIsnvA7bpH3Jib8xZP59Bv1kJZ2OOPnXZm5VCbG9KGxuD3nw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtQFX580rBMGsEaUkAsUxTxngI3wte0gF6eY63210M7ACEibWRftlcGHA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7722222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtP4UwYx9iaicKndeyYOQtXWEaQ0WFPKUeGXbH5t11rZcKuggnicyqzYgicA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;选择2: 使用事件溯源：以事件为中心的持久化&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.77265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtD9acZ2vnvNh7NvpFC4BXUjhjam7RRSr4gUc90wpX29gdLicKRH1dhIw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.77265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZt6gEYeJUlootoiaJU5BzWPtia3mV9D5SM0hJbuIgB74bWDDccXAt05tFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.77265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE5JGuOWRPSRcfQgZeI2uZtY54reVHkia3zBNwl0F9gWrO81IzBgvPdP8XUWia3RHuVYLdkC3ZZQYIg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong data-darkmode-bgcolor-163209868118410=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-163209868118410=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-163209868118410=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-163209868118410=&quot;#fff|rgb(0, 0, 0)&quot; data-style=&quot;outline: 0px; font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; white-space: normal; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-size: 15px; text-align: left; word-spacing: 1.5px;&quot; class=&quot;js_darkmode__12&quot;&gt;版权申明：内容来源网络，版权归原创者所有。除非无法确认，我们都会标明作者及出处，如有侵权烦请告知，我们会立即删除并表示歉意。谢谢!&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI4NTkzODY0Mg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/pHA9SWvdL7OZ7UNTeEvwp3fPZ2gDJ6PGgic2LWdxhvV2hkWyzribx1DKynh4AtK8mdpr140bJ9aZcTNDicBNaVnmQ/0?wx_fmt=png&quot; data-nickname=&quot;大数据云技术&quot; data-alias=&quot;&quot; data-signature=&quot;大数据云技术，专注大数据技术、应用案例和数据可视化。从数据角度出发，讲述大数据健康医疗、互联网金融、电子商务、网络游戏、社交、舆情、教育、征信、物流、税务、工/农/商业等多个领域的应用！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>03bd42846b2fee101315716bc12fda20</guid>
<title>Spring Cache 带你飞</title>
<link>https://toutiao.io/k/a2tu88f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接着上一篇讲了 Spring Cache 如何被 Spring Aop 代理加载对应的代码，以及何如注入相关界面逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzNDcwNjQxMg==&amp;amp;mid=2247484906&amp;amp;idx=1&amp;amp;sn=c7229a2d77a0dc9a5bbe8bea39794182&amp;amp;chksm=e8f30169df84887f0a29274a3599ca4e1c56cd01f78127b527ec07b2f5e0d8ca776eaf4317b6&amp;amp;token=386732364&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Spring Cache 带你飞(一)&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本篇我们围绕两个要点展开：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;一个数据是如何被 Spring Cache 放入缓存的。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;Spring Cache 如何扩展存储源，即支持不同的缓存技术。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Spring Cache 的数据存储之路&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Spring Cache 相关的注解有 5 个：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;@Cacheable 在调用方法的同时能够根据方法的请求参数对结果进行缓存。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;@CachePut 调用发放的同时进行 Cache 存储，作用于方法上。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;@CacheEvict 删除，作用于方法上。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;@Caching 用于处理复杂的缓存情况，一次性设置多个缓存，作用于方法上。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;@CacheConfig 可以在类级别上标注一些公用的缓存属性，所有方法共享。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;@Cacheable&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;@Cacheable 是我们最常使用的注解：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;@Target&lt;/span&gt;({ElementType.METHOD, ElementType.TYPE})&lt;br/&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;br/&gt;&lt;span&gt;@Inherited&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Documented&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;@interface&lt;/span&gt; Cacheable {&lt;br/&gt;    &lt;span&gt;@AliasFor&lt;/span&gt;(&lt;span&gt;&quot;cacheNames&quot;&lt;/span&gt;)&lt;br/&gt;    String[] value() &lt;span&gt;default&lt;/span&gt; {};&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@AliasFor&lt;/span&gt;(&lt;span&gt;&quot;value&quot;&lt;/span&gt;)&lt;br/&gt;    String[] cacheNames() &lt;span&gt;default&lt;/span&gt; {};&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;key&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;keyGenerator&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;cacheManager&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;cacheResolver&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;condition&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;unless&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;sync&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;em&gt;cacheNames&lt;/em&gt; 和 &lt;em&gt;value&lt;/em&gt; 这两个属性任意使用一个都可以，它们的作用可以理解为 key 的前缀。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@Cacheable&lt;/span&gt;(value = &lt;span&gt;&quot;user:cache&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; User &lt;span&gt;findById&lt;/span&gt;&lt;span&gt;(String id)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    User user = &lt;span&gt;this&lt;/span&gt;.getById(id);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (user != &lt;span&gt;null&lt;/span&gt;){&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;user.name = &quot;&lt;/span&gt; + user.getName());&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;key 和 keyGenerator 是互斥的一对。当指定了 key 的时候就会使用你指定的 key + 参数 作为缓存 key。否则则使用默认 keyGenerator(SimpleKeyGenerator)或者你自定义的 Generator 来生成 key。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;默认的 SimpleKeyGenerator 通过源码我们能看到它的生成规则：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object &lt;span&gt;generateKey&lt;/span&gt;&lt;span&gt;(Object... params)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (params.length == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; SimpleKey.EMPTY;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (params.length == &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;   Object param = params[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (param != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !param.getClass().isArray()) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; param;&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; SimpleKey(params);&lt;br/&gt; }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果方法没有入参则抛异常，即必须要有入参才能构建 key；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果只有一个入参，则使用该入参作为 key=入参值。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果有多个入参则返回包含所有入参的构造函数 &lt;/span&gt;&lt;code&gt;&lt;span&gt;new SimpleKey(params)&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Spring 官方推荐使用显式指定 key 的方式来生成 key。当然你也可以通过自定义 KeyGenerator 来实现自己制定规则的 key 生成方式，只需要实现 KeyGenerator 接口即可。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注意 key 属性为 spEL 表达式，如果要写字符串需要将该字符串用单引号括起来。比如我们有如下配置：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@Cacheable&lt;/span&gt;(cacheNames = &lt;span&gt;&quot;userInfo&quot;&lt;/span&gt;, key = &lt;span&gt;&quot;&#x27;p_&#x27;+ #name&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getName&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;hello:&quot;&lt;/span&gt; + name;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设 &lt;/span&gt;&lt;code&gt;&lt;span&gt;name = xiaoming&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，那么缓存的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;key = userInfo::p_xiaoming&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;em&gt;condition&lt;/em&gt; 参数的作用是限定存储条件：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@Cacheable&lt;/span&gt;(cacheNames = &lt;span&gt;&quot;userInfo&quot;&lt;/span&gt;, key = &lt;span&gt;&quot;&#x27;p_&#x27;+ #name&quot;&lt;/span&gt;,condition = &lt;span&gt;&quot;#sex == 1&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getName&lt;/span&gt;&lt;span&gt;(String name, &lt;span&gt;int&lt;/span&gt; sex)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;hello:&quot;&lt;/span&gt; + name;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上例限制条件为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;sex == 1&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的时候才写入缓存，否则不走缓存。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;em&gt;unless&lt;/em&gt; 参数跟 &lt;em&gt;condition&lt;/em&gt; 参数相反，作用是当不满足某个条件的时候才写入缓存。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;em&gt;sync&lt;/em&gt; 字段上一篇说过，多线程情况下并发更新的情况是否只需要一个线程更新即可。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;还有个属性 &lt;em&gt;cacheManager&lt;/em&gt; 比较大头放在后面单独说，从命名上能看出它是 cache 的管理者，即指定当前 Cache 使用何种 Cache 配置，比如是 Redis 还是 local Cache 等等。这也是我们这一篇要讨论的重点。&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;@CacheConfig&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;CacheConfig 注解包含以下配置：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@Target&lt;/span&gt;({ElementType.TYPE})&lt;br/&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;br/&gt;&lt;span&gt;@Documented&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;@interface&lt;/span&gt; CacheConfig {&lt;br/&gt;    String[] cacheNames() &lt;span&gt;default&lt;/span&gt; {};&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;keyGenerator&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;cacheManager&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;cacheResolver&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果你在一个类中使用多个 Cache 注解，并且这些 Cache 注解有公共的基础操作，比如：使用相同的 Cache key 生成规则，使用相同的 Cache Name 前缀等等，那么你就可以定义一个 CacheConfig 来统一单独管理这些 Cache 操作。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@CacheConfig&lt;/span&gt;(cacheNames = &lt;span&gt;&quot;user&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Cacheable&lt;/span&gt;(key = &lt;span&gt;&quot;#userInfoDTO.uid&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; GirgirUser.&lt;span&gt;UserInfo &lt;span&gt;getUser&lt;/span&gt;&lt;span&gt;(UserInfoDTO userInfoDTO)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; xxx;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Cacheable&lt;/span&gt;(key = &lt;span&gt;&quot;&#x27;base_&#x27; + #userInfoDTO.uid&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; GirgirUser.&lt;span&gt;UserInfo &lt;span&gt;getBaseUser&lt;/span&gt;&lt;span&gt;(UserInfoDTO userInfoDTO)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; xxx;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面示例中的 两个 Cache Key 都会有一个公共前缀 ”user“。需要注意的是：CacheConfig 注解的优先级高于同类当中别的注解，如果你在 CacheConfig 中配置了 &lt;em&gt;cacheNames&lt;/em&gt;，方法中也配置了，那么 CacheConfig 中的 &lt;em&gt;cacheNames&lt;/em&gt; 会覆盖掉方法上的配置。&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;@Caching&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;@Caching 注解适用于复杂缓存操作的场景，当你有多个缓存操作的需求，比如下例：你需要先删除缓存，再插入新数据到缓存：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@Caching&lt;/span&gt;(evict = &lt;span&gt;@CacheEvict&lt;/span&gt;(key = &lt;span&gt;&quot;&#x27;base&#x27; + #userInfoDTO.uid&quot;&lt;/span&gt;),&lt;br/&gt;         put = &lt;span&gt;@CachePut&lt;/span&gt;(key = &lt;span&gt;&quot;&#x27;base&#x27; + #userInfoDTO.uid&quot;&lt;/span&gt;))&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; GirgirUser.&lt;span&gt;UserInfo &lt;span&gt;getBaseUser&lt;/span&gt;&lt;span&gt;(UserInfoDTO userInfoDTO)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; xxx;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么你可以使用 &lt;em&gt;@Caching&lt;/em&gt; 注解来操作多个缓存。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注解的使用就说到这里，其余几个注解的配置基本同 @Cacheable 差不多，剩下的大家可以自己学习。接下来我们要说的重点来了：待缓存的数据到底是如何被存储起来的。Spring Cache 如何知道当前要使用的数据源。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;Spring EL 对 Cache 的支持&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;Name&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;Location&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;Description&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;Example&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;methodName&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;Root object&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;被调用的方法的名称&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;&lt;span&gt;#root.methodName&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;method&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;Root object&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;被调用的方法&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;&lt;span&gt;#root.method.name&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;target&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;Root object&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;当前调用方法的对象&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;&lt;span&gt;#root.target&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;targetClass&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;Root object&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;当前调用方法的类&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;&lt;span&gt;#root.targetClass&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;args&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;Root object&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;当前方法的参数&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;&lt;span&gt;#root.args[0]&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;caches&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;Root object&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;当前方法的缓存集合&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;&lt;span&gt;#root.caches[0].name&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Argument name&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;Evaluation context&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;当前方法的参数名称&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;&lt;span&gt;#iban or #a0 (you can also use #p0 or #p&amp;lt;#arg&amp;gt; notation as an alias).&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;result&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;Evaluation context&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;方法返回的结果(要缓存的值)。只有在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;unless 、@CachePut(用于计算键)或@CacheEvict(beforeInvocation=false)&lt;/span&gt;&lt;/code&gt;&lt;span&gt;中才可用.对于支持的包装器(例如 Optional)，&lt;/span&gt;&lt;code&gt;&lt;span&gt;#result&lt;/span&gt;&lt;/code&gt;&lt;span&gt;引用的是实际对象，而不是包装器&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;&lt;span&gt;#result&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Spring Cache 数据源配置&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Spring 在 &lt;em&gt;application.yml&lt;/em&gt; 中提供配置文件支持，通过配置 &lt;/span&gt;&lt;code&gt;&lt;span&gt;spring.cache.type&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 标签来指定当前要使用的存储方案，目前支持的有：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; CacheType {&lt;br/&gt;    GENERIC,&lt;br/&gt;    JCACHE,&lt;br/&gt;    EHCACHE,&lt;br/&gt;    HAZELCAST,&lt;br/&gt;    INFINISPAN,&lt;br/&gt;    COUCHBASE,&lt;br/&gt;    REDIS,&lt;br/&gt;    CAFFEINE,&lt;br/&gt;    SIMPLE,&lt;br/&gt;    NONE;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;CacheType&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用的时候需要引入相关存储对应的 jar 包以及相关的配置。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Java Caching 定义了 5 个核心接口，分别是 CachingProvider, CacheManager, Cache, Entry 和 Expiry&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;CachingProvider 用于配置和管理 CacheManager，目前它只有一个唯一的实现类 &lt;em&gt;EhcacheCachingProvider&lt;/em&gt;，ehcache 也是 Spring 默认提供的实现之一。其余的第三方缓存组件都没有用到。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;CacheManager 定义了创建、配置、获取、管理和控制多个唯一命名的 Cache，这些 Cache 存在于 CacheManager 的上下文中。一个 CacheManager 仅被一个 CachingProvider 所拥有。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Cache 是一个类似 Map 的数据结构并临时存储以 Key 为索引的值。一个 Cache 仅被一个 CacheManager 所拥有。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Entry 是一个存储在 Cache 中的 key-value 对。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Expiry 每一个存储在 Cache 中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过 ExpiryPolicy 设置。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8164924506387921&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/K7IVueebAHkR13FmhUIl5w7TzsTj0OUp8TcNRvkHuvyF3ChcUz7X3XtAeXMkqv09BggibyWzxelWHnnUAFRup9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;861&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Spring 定义了&lt;/span&gt;&lt;code&gt;&lt;span&gt;org.springframework.cache.CacheManager&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;&lt;span&gt;org.springframework.cache.Cache&lt;/span&gt;&lt;/code&gt;&lt;span&gt;接口来统一不同的缓存技术。其中，CacheManager 是 Spring 提供的各种缓存技术抽象接口，Cache 接口包含了缓存的各种操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;针对不同的缓存方案需要提供不同的 CacheManager，Spring 提供的实现类包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6169934640522876&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/K7IVueebAHkR13FmhUIl5w7TzsTj0OUp17VzWVtBesicsKY2iaF2rMZBWdubiaOFwzF1YRGmibkVxc6IVc5mHf9nAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;765&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;SimpleCacheManager：使用简单的 Collection 来存储缓存，主要用来测试&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;ConcurrentMapCacheManager：使用 ConcurrentMap 来存储缓存&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;NoOpCacheManager：仅测试用途，不会实际存储缓存&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;EhCacheManager：使用 EhCache 作为缓存技术&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;GuavaCacheManager：使用 Google Guava 的 GuavaCache 作为缓存技术&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;HazelcastCacheManager：使用 Hazelcast 作为缓存技术&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;JCacheManager：支持 JCache（JSR—107）标准的实现作为缓存技术&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;RedisCacheManager：使用 Redis 作为缓存技术&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;CacheManager 的加载来自于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;spring.factories&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件中的配置：&lt;/span&gt;&lt;code&gt;&lt;span&gt;org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，即在 Spring 启动的时候加载：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@ConditionalOnClass&lt;/span&gt;(CacheManager&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;ConditionalOnBean&lt;/span&gt;(&lt;span&gt;CacheAspectSupport&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;ConditionalOnMissingBean&lt;/span&gt;(&lt;span&gt;value&lt;/span&gt; &lt;/span&gt;= CacheManager&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;name&lt;/span&gt; &lt;/span&gt;= &lt;span&gt;&quot;cacheResolver&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@EnableConfigurationProperties&lt;/span&gt;(CacheProperties&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;AutoConfigureBefore&lt;/span&gt;(&lt;span&gt;HibernateJpaAutoConfiguration&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;AutoConfigureAfter&lt;/span&gt;(&lt;/span&gt;{ CouchbaseAutoConfiguration&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;HazelcastAutoConfiguration&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;RedisAutoConfiguration&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt; })&lt;br/&gt;@&lt;span&gt;Import&lt;/span&gt;(&lt;span&gt;CacheConfigurationImportSelector&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;CacheAutoConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  ......&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那不同的存储实现是如何加载各自的 CacheManger 的呢？我们就拿 Redis 来说，在配置类：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@AutoConfigureAfter&lt;/span&gt;({RedisAutoConfiguration&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;@&lt;span&gt;ConditionalOnBean&lt;/span&gt;(&lt;/span&gt;{RedisConnectionFactory&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;@&lt;span&gt;ConditionalOnMissingBean&lt;/span&gt;(&lt;/span&gt;{CacheManager&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;@&lt;span&gt;Conditional&lt;/span&gt;(&lt;/span&gt;{CacheCondition&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RedisCacheConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; ......&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RedisCacheManager &lt;span&gt;cacheManager&lt;/span&gt;&lt;span&gt;(RedisConnectionFactory redisConnectionFactory, ResourceLoader resourceLoader)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        RedisCacheManagerBuilder builder = RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(&lt;span&gt;this&lt;/span&gt;.determineConfiguration(resourceLoader.getClassLoader()));&lt;br/&gt;        List&amp;lt;String&amp;gt; cacheNames = &lt;span&gt;this&lt;/span&gt;.cacheProperties.getCacheNames();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!cacheNames.isEmpty()) {&lt;br/&gt;            builder.initialCacheNames(&lt;span&gt;new&lt;/span&gt; LinkedHashSet(cacheNames));&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (RedisCacheManager)&lt;span&gt;this&lt;/span&gt;.customizerInvoker.customize(builder.build());&lt;br/&gt;    }&lt;br/&gt;  ......&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 的配置类启动的时候先检查 &lt;em&gt;CacheManager&lt;/em&gt; 是否有加载成功，有的话则去执行各种配置相关操作。上面代码截出来了初始化 &lt;em&gt;RedisCacheManager&lt;/em&gt; 的步骤。&lt;em&gt;RedisCacheManager&lt;/em&gt; 实现了 &lt;em&gt;CacheManager&lt;/em&gt; 接口。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当使用 &lt;em&gt;RedisCacheManager&lt;/em&gt; 进行存储的时候，通过被包装的 Cache 对象来使用相关的存储操作，我们看一下 &lt;em&gt;RedisCache&lt;/em&gt; 对应的操作：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RedisCache&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractValueAdaptingCache&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   ......&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;T &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(Object key, Callable&amp;lt;T&amp;gt; valueLoader)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ValueWrapper result = &lt;span&gt;this&lt;/span&gt;.get(key);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (result != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result.get();&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            T value = valueFromLoader(key, valueLoader);&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.put(key, value);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; value;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;put&lt;/span&gt;&lt;span&gt;(Object key, @Nullable Object value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Object cacheValue = &lt;span&gt;this&lt;/span&gt;.preProcessCacheValue(value);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.isAllowNullValues() &amp;amp;&amp;amp; cacheValue == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(String.format(&lt;span&gt;&quot;Cache &#x27;%s&#x27; does not allow &#x27;null&#x27; values. Avoid storing null via &#x27;@Cacheable(unless=\&quot;#result == null\&quot;)&#x27; or configure RedisCache to allow &#x27;null&#x27; via RedisCacheConfiguration.&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.name));&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.cacheWriter.put(&lt;span&gt;this&lt;/span&gt;.name, &lt;span&gt;this&lt;/span&gt;.createAndConvertCacheKey(key), &lt;span&gt;this&lt;/span&gt;.serializeCacheValue(cacheValue), &lt;span&gt;this&lt;/span&gt;.cacheConfig.getTtl());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以看到 Redis 的存储使用的是普通的 KV 结构，value 的序列化方式是 yml 文件中的配置。另外很重要的一点是 ttl 的配置，这里能看到也是获取配置文件的属性。所以当你想给每个 key 单独设置过期时间的话就不能使用默认的 Redis 配置。而是需要自己实现 CacheManager。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>56e349b470b4b52fc9cd947ae7b6df63</guid>
<title>无处不在的 Kubernetes，难用的问题解决了吗？</title>
<link>https://toutiao.io/k/wq5ltx6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;82&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.14106583072100312&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/qdzZBE73hWtObtu43aftW8t1XhQRHbvibHWNuYah3xo5Ymgh501WEo6xrricTstkOyK6iaYamOBKPia2cRFhkCrvdA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;638&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;作者：望宸、木环、溪洋 等&lt;/span&gt;&lt;/em&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;审核&amp;amp;校对：不瞋、宏良、张磊、志敏&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;编辑&amp;amp;排版：酒圆&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span/&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;容器本质是一项隔离技术，很好的解决了他的前任 - 虚拟化未解决的问题：运行环境启动速度慢、资源利用率低，而容器技术的两个核心概念，Namespace 和 Cgroup，恰到好处的解决了这两个难题。Namespace 作为看起来是隔离的技术，替代了 Hypervise 和 GuestOS，在原本在两个 OS 上的运行环境演进成一个，运行环境更加轻量化、启动快，Cgroup 则被作为用起来是隔离的技术，限制了一个进程只能消耗整台机器的部分 CPU 和内存。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;当然，容器技术之所以能流行，更因为他提供了标准化的软件开发交付物 - 容器镜像。基于容器镜像，持续交付这件事才能够真正落地。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们还能罗列出许多使用容器技术的理由，这里就不再一一赘述。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;同时，云计算解决了基础资源层的弹性伸缩，却没有解决 PaaS 层应用随基础资源层弹性伸缩而带来的批量、快速部署问题。于是，容器编排系统应运而生。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;从第三方的调研数据看，容器和 Kubernetes 已经成为云原生时代主流的选择，但实际落地的时候，却陷入了困境。我们尝试去总结了一些共通点，以及应对方案，也许能为正在落地容器技术的企业提供一些参考。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;01&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;难用在哪？&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;容器和 Kubernetes 的先进性毋庸置疑，但当大量的企业在开始拥抱容器编排领域的事实标准 Kubernetes 时，却陷入了困境。“K8s 就像一把双刃剑，既是最佳的容器编排技术，同时也存在相当高的复杂性和应用的高门槛，这个过程中往往会导致一些常见性错误”。就连 Kubernetes 的创立者和核心推动者 Google 本身都承认这个问题。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;一次采访中，阿里巴巴高级技术专家张磊分析了 Kubernetes 的本质，他指出，“Kubernetes 本身是一个分布式系统而不是一个简单的 SDK 或者编程框架，这本身已经将其复杂度提升到了系统级分布式开源项目的位置。此外，Kubernetes 第一次将声明式 API 的思想在开源基础设施领域普及开来，并以此为基础提出了一系列诸如容器设计模式和控制器模型等使用范式，这些具有一定先进性和前瞻性的设计也使得 Kubernetes 项目被大众接受时会存在一定的学习周期。”&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们大致总结了 Kubernetes 的 4 大复杂性。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、&lt;strong&gt;认知复杂&lt;/strong&gt;：他和原有的后端研发体系不同，延伸出一套全新的理论，并提供了一系列全新的技术概念，并且这些概念，例如 Pod、sidecar、Service、资源管理、调度算法和 CRD 等等，主要是面向平台研发团队而非应用开发者设计，提供很多强大灵活的能力。但是，这不仅带来了陡峭的学习曲线，影响了应用开发者的使用体验，甚至在很多情况下理解不当还会引发错误操作，乃至生产故障。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、&lt;strong&gt;开发复杂&lt;/strong&gt;：K8s 使用声明式方法来编排和管理容器。为了实现这一点，需要配置一个 YAML 文件，但再复杂的应用程序中，引入新环节影响了开发者的生产力和敏捷性。此外，缺乏内置的编程模型，开发者需要依赖第三方库来处理程序间的依赖关系，这些都会影响到开发效率，并增加不必要的 DevOps 开销。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3、&lt;strong&gt;迁移复杂&lt;/strong&gt;：将现有的应用程序迁移到 K8s 比较复杂，尤其是非微服务架构，在很多情况下，必须重构特定组件或整个架构，并且需要使用云原生原理重构应用程序，例如状态依赖，如写本地目录、有顺序，网络依赖，如写死 IP，数量依赖，如副本固定等等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4、&lt;strong&gt;运维复杂&lt;/strong&gt;：K8s 的声明式 API 颠覆了传统的过程式运维模式，声明式 API 对应的是面向终态的运维模式。而随着 K8s 集群规模的增长，徒手基于开源K8s，运维难度也会呈线性增长，呈现在集群管理、应用发布、监控、日志等多个环节，集群稳定性将面临极高的挑战。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;02&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;是否还有别的解法？&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;技术总有双面性，容器革新了云计算的基础设施，成为了新的计算界面。而 Kubernetes 则搭建了一个统一的基础设施抽象层，为平台团队屏蔽掉了“计算”、“网络”、“存储”等过去我们不得不关注的基础设施概念，使得我们能够基于 Kubernetes 方便地构建出任何我们想要的垂直业务系统而无需关心任何基础设施层的细节。这正是 Kubernetes 被称为云计算界的 Linux 以及 “Platform for Platforms” 的根本原因。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;但直接上手操作 Kubernetes 是否是我们应用容器技术的唯一选择呢？答案是否定的。在容器技术的演进过程中，我们也发现了不少能够降低容器编排门槛的开源项目和商业化产品，接下来，我们将从双手的解放程度由低到高，一一介绍。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;围绕 Kubernetes 生态的开源工具&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;OAM/KubeVela 是托管在 CNCF 中的开源项目，旨在降低 K8s 在应用开发和运维上的复杂性，最初由阿里云和微软云联合发起。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;KubeVela 作为开放应用架构模型 OAM 的标准实现，与底层基础设施和无关、原生可扩展，而且最重要的是它完全以应用为中心。在 KubeVela 中，“应用”被设计为整个平台的「一等公民」。应用团队只需要围绕组件、运维特征、工作流等几个跨平台、跨环境的上层抽象来进行应用的交付与管理，无需关注任何基础设施细节和差异性；平台管理员则可以随时以 IaC 的方式配置平台支持的组件类型和运维能力集等特性，以便适配任何应用托管场景。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;KubeVela 是完全基于 K8s 构建的，具备天然的被集成能力和普适性，天然透出 K8s 及其生态的所有能力，而不是往上叠加抽象。因此 KubeVela 适用于那些具备一定的 K8s 平台开发和运维能力，同时希望能够使用到全套 K8s 能力，不断扩展平台能力的技术团队。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;容器已经从一项隔离技术演进成一个生态，KubeVela 这类可以极大降低 K8s 使用复杂度的开源工具，会逐步释放其生命力，使开发人员无需成为 K8s 专家即可享受到云原生带来的高效与便捷。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;sealer 是一款开源的分布式应用打包交付运行的方案，极大的简化了容器项目的交付复杂性和一致性问题。sealer 构建出来的产物可称之为&quot;集群镜像&quot;，并内嵌了 K8s，该&quot;集群镜像&quot;可以 push 到 registry 中共享给其他用户使用，也可以在官方仓库中找到非常通用的分布式软件直接使用。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;交付是容器生态的另一个难题，面临着依赖复杂、一致性的问题，尤其是工业级的 Kubernetes 交付项目，交付周期变长、交付质量要求高，sealer 非常适合于软件开发商、ISV 等性质的企业，可将部署时间缩短至小时级别。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;开放、标准化的企业级 Kubernetes 服务&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大部分云厂商提供了 Kubernetes as a Service 的容器平台能力，比如 AWS EKS 和阿里云的 ACK，可以大幅简化 K8s 集群的部署、运维、网络存储、安全管理等能力，提供了通过 CNCF 标准化认证的 K8s服务，可以满足几乎全场景的工作负载需求，并提供了丰富的扩展和定制能力。&lt;/span&gt;&lt;span&gt;此外，大部分云厂商会基于开源 Kubernetes 框架，在上层做不同程度的封装，来适配不同企业背景和不同场景下的需求，以提供发行版和 Pro 版，例如阿里云的 ACK Pro 就提供了托管 master 和全托管节点池的能力，全面整合IaaS能力，更加高效、安全、智能，将容器集群的各种细分场景最佳实践和全栈优化作为内置服务提供给企业。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;从现有用户规模来看，这是大部分互联网企业落地容器技术的主流选择。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;更多信息请移步至：&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNzYxNjAzMg==&amp;amp;mid=2247516866&amp;amp;idx=1&amp;amp;sn=6031ee00b3b3fc2e984212ca3f8f7cf9&amp;amp;from=timeline&amp;amp;isappinstalled=0&amp;amp;scene=21&amp;amp;clicktime=1635165626&amp;amp;enterid=1635165626#wechat_redirect&quot; data-href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNzYxNjAzMg==&amp;amp;mid=2247516866&amp;amp;idx=1&amp;amp;sn=6031ee00b3b3fc2e984212ca3f8f7cf9&amp;amp;from=timeline&amp;amp;isappinstalled=0&amp;amp;scene=21&amp;amp;clicktime=1635165626&amp;amp;enterid=1635165626#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《阿里云容器服务多项重磅发布：高效智能、安全无界的新一代平台》&lt;/a&gt;&lt;span&gt; 。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;03&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;向 Serverless 演进的 Kubernetes 服务&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;传统的 Kubernetes 采用以节点为中心的架构&lt;/span&gt;&lt;span&gt;设计：&lt;/span&gt;&lt;span&gt;节点是 Pod 的运行载体，Kubernetes 调度器在工作节点池中选择合适的 node 来运行 Pod。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;而对于 Serverless Kubernetes 而言，最重要的一个概念是将容器的运行时和具体的节点运行环境解耦。用户无需关注 node 运维和安全，降低运维成本；而且极大简化了容器弹性实现，无需按照容量规划，按需创建容器应用 Pod 即可；此外 Serverless 容器运行时可以被整个云弹性计算基础设施所支撑，保障整体弹性的成本和规模。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;众多云厂商也将容器和 Serverless 做进一步的融合：例如阿里云的 Serverless 容器服务 ASK、Google GKE 的 AutoPilot，以免运维的方式降低了客户在 K8s 节点和集群上的操作复杂度，无需购买服务器即可直接部署容器应用；同时，仍然可以通过 K8s 命令行和 API 来部署容器应用，充分利用了 K8s 的编排能力，并且根据应用配置的 CPU 和内存资源量进行按需付费。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这类服务非常善于处理一些 Job 类的任务，例如 AI 领域的算法模型训练，同时拥有在 K8s 环境下比较一致的开发体验，是容器服务生态非常好的补充。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;更多信息可以移步至：《&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNzYxNjAzMg==&amp;amp;mid=2247500298&amp;amp;idx=1&amp;amp;sn=7a40ff9c10c9c9b56b65056919167232&amp;amp;scene=21#wechat_redirect&quot; data-href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNzYxNjAzMg==&amp;amp;mid=2247500298&amp;amp;idx=1&amp;amp;sn=7a40ff9c10c9c9b56b65056919167232&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Serverless Kubernetes：理想，现实与未来&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;04&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;容器和 Serverless 技术加持的新一代 PaaS 服务&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;企业级市场的需求总是分层的、多样化的，这和技术人才的分布紧密相关，并不是每家企业都能建立一个技术实力足够强的团队，尤其是在非北上广深的城市，并且落地一项新技术时，总是分阶段规划的，这就给更多的产品形态孕育了市场空间。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;K8s 虽然提供了容器应用的全生命周期管理，但是太丰富、太复杂、太灵活，这既是一种优势，有时候也是一种劣势。尤其是对于习惯了在虚拟机时代，以应用为视角来管理应用的研发运维人员而言，即便像 AWS EKS、阿里云 ASK 等已经在一定程度上降低了 K8s 的操作复杂度，他们仍然希望通过某种方式，可以进一步降低容器技术的使用门槛。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;容器和 K8s 并非一定要捆绑使用，在一些新型的 PaaS 服务中，例如阿里云的 Serverless应用引擎（SAE），底层将虚拟化技术改造成容器技术，充分利用了容器的隔离技术，来提升启动时间和资源利用率，而在应用管理层，则保留了原有的微服务应用的管理范式，使用者不必学习庞大而复杂的 K8s 来管理应用。这类新型的 PaaS 服务通常还会内置全套微服务治理能力，客户无需考虑框架选型、更无需考虑数据隔离、分布式事务、熔断设计、限流降级等，也无需担心社区维护力度有限二次定制开发的问题。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;此外，底层计算资源池化后，其天然的 Serverless 属性使得用户不必再单独购买和持续保有服务器，而是按 CPU 和内存资源量来配置所需的计算资源，让容器 + Serverless + PaaS 得以合三为一，使得技术先进性、资源利用率优化、不变的开发运维体验可以融合在一起。因此，相比于本文中的其他方案，这类方案的特色是提供了PaaS 体验，让新技术落地更加平稳。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;大部分传统行业、一些技术能力偏向于业务层的互联网企业、和一些不希望因受制于后端而影响业务快递迭代的创业公司，大多都会倾向于 PaaS 形态的产品，抛开企业属性，PaaS 类的服务在处理以下场景更具交付优势：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;上线了一个新的项目，想快速验证，不要出故障，同时控制人力的投入成本；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;业务体量上升快，用户越来越多，业务稳定性有点 hold 不住，新版本发布、线上应用管理等环节开始有点畏手畏脚，但技术储备还无法及时应对当前变化；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;决定要把原有的单体架构升级成微服务架构，但由于团队缺少微服务专家，评估完项目发现升级风险比较高。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;更多信息可以移步至：&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NzI5MDM1MQ==&amp;amp;mid=2247494376&amp;amp;idx=1&amp;amp;sn=f4cf545b2f9c69c1ebc38271cb87df2b&amp;amp;scene=21#wechat_redirect&quot; data-href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NzI5MDM1MQ==&amp;amp;mid=2247494376&amp;amp;idx=1&amp;amp;sn=f4cf545b2f9c69c1ebc38271cb87df2b&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《打破 Serverless 落地边界，阿里云 SAE 发布 5 大新特性》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;05&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;更为极致的 Serverless 服务 -  FaaS&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;FaaS 的出现，让具备弹性灵活诉求的业务场景，有了更好的选项。&lt;/span&gt;&lt;span&gt;越来越多的大中型企业将传统后端领域对扩容有灵活需求的执行单元剥离出来，运行在 Serverless 架构上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这使得 FaaS（函数计算）成为容器和 K8s 外，另一种通用算力的选择。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;和 Google Cloud Run、App Runner 等 Serverless 服务一样，FaaS 的产品形态正变得越来越开放，运行上的限制越来越少，除了适合事件驱动的计算模型，也适合 Web 单体应用、Job 等场景，可以帮助用户把弹性发挥到极致，进一步提升计算资源的利用率。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;例如，游戏行业的莉莉丝将函数计算应用于战斗校验，来验证玩家客户端上传的战斗是否有作弊的情况。战斗校验一般需要逐帧计算，CPU 消耗会非常高，通常 1 队 v 1 队的战斗需要 n 毫秒，而 5 队 v 5 队的战斗则需要相应 5n 毫秒，对弹性要求很高。此外，容器架构下挂载的 SLB，会因为轮询机制导致无法感知 Pod 的实际负载，由此引起的负载不均，产生死循环和稳定性风险。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;函数计算的调度系统帮助莉莉丝合理安排每个请求，对于死循环问题，也贴心的提供了超时杀进程机制，并将调度系统的复杂性下沉到了基础设施。此外，函数计算深度优化后的冷启动时延大幅下降，从调度、到获取计算资源、再到服务启动，基本在 1 秒+左右。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外，FaaS 的出现，也极大的解放了创业公司全栈工程师在 DevOps 上花费的精力，来承载小程序、网站等 Web 单体应用，例如，函数计算降低了 Node.js 等前端语言的服务器维护门槛，只要会写 JS 代码就可以维护 Node 服务。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;更多信息可以移步至：&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNzYxNjAzMg==&amp;amp;mid=2247516929&amp;amp;idx=2&amp;amp;sn=a82ae52d716415735d143095fb65fb0f&amp;amp;scene=21#wechat_redirect&quot; data-href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNzYxNjAzMg==&amp;amp;mid=2247516929&amp;amp;idx=2&amp;amp;sn=a82ae52d716415735d143095fb65fb0f&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《跨越行业绊脚石，阿里云函数计算发布 7 大技术突破》&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;h3&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h3&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;03&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;适合的才是最好的&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;需求的越多，投入的也会越多，这是恒古不变的道理。在我们决定引入容器技术后，使用 K8s 之前，需要想清楚为什么需要 K8s。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如果我们希望充分利用 K8s 的全套能力，并且团队具备一定的技术储备，那么 KubeVela 是理想的开源选型，sealer 还能帮助我们降低交付复杂度；如果希望将 K8s 上层不同程度的封装工作交给云厂商来处理，以更高效的适配不同业务场景下的需求，那么云厂商提供的商业化的容器服务是不错的选择；如果容器和 K8s 无法契合弹性业务类的诉求，则可以选择 FaaS。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;但又如果我们的应用并没有那么复杂，只是朴素的希望简化应用生命周期管理和底层基础设施，保障业务的高可用，并专注在业务开发上，那么可能就不需要使用 K8s 来编排容器应用了，毕竟 K8s 是源自 Google 的 Borg，他是用来管理 Google 海量的容器应用的。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;参考文章：&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;《云计算的前世今生》，刘超&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;《灵活、高效的云原生集群管理经验：用 K8s 管理 K8s》，淮右、临石&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;《复杂性会成为 Kubernetes 的“致命伤”吗？》，赵钰莹&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;《Simplifying Kubernetes For&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt; Developers》，&lt;/span&gt;&lt;/em&gt;&lt;em&gt;&lt;span&gt;Rishidot Research&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;《KubeVela 正式开源：一个高可扩展的云原生应用平台与核心引擎》，OAM项目维护者&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;《KubeVela 1.0 ：开启可编程式应用平台的未来》，OAM项目维护者&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;相关链接：&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;项目地址：&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span/&gt;&lt;span&gt;https://github.com/oam-dev/kubevela&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;项目地址：&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;https://github.com/alibaba/sealer&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>