<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>573f76f1e77eddaf7bee370a78e048fc</guid>
<title>以模型为中心，携程契约系统的演进</title>
<link>https://toutiao.io/k/mlv82jf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6c5dcf5d64acc049ffcfcb54fdc32154</guid>
<title>[译] 打造符合用户期望的应用质量</title>
<link>https://toutiao.io/k/4imqrw9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;&lt;i&gt;作者 / Android 应用质量部 Hoi Lam&lt;/i&gt;&lt;/p&gt;&lt;p&gt;自 Android 于 10 多年前发布以来，平台一直在不断地成长，用户的期望也随之不断上升。从 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//material.io/design&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Material Design&lt;/a&gt;&lt;/b&gt; 到 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/privacy&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;对于保护隐私的重视与推动&lt;/a&gt;&lt;/b&gt;，用户体验得到了显著改进。和您一样，我们希望为用户提供出色的应用体验。同时，我们也明白弄清楚从哪里入手解决问题并非易事。为此，我们在开发者网站上新推出了 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/quality&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;应用质量&quot; 部分&lt;/a&gt;&lt;/b&gt;，旨在帮助您及时了解应用质量的关键内容以及相关资源。&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.zhihu.com/zvideo/1353385056443076608&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://zhstatic.zhihu.com/assets/zhihu/editor/zhihu-card-default.svg&quot; class=&quot;LinkCard old LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;知乎视频&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.zhihu.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--square&quot; alt=&quot;图标&quot; src=&quot;https://zhstatic.zhihu.com/assets/zhihu/editor/zhihu-card-default.svg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;p&gt;在第一个版本中，我们更新了 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/docs/quality-guidelines/core-app-quality&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;核心应用质量核对清单&lt;/a&gt;&lt;/b&gt;，将最近的 Android 版本以及应用生态系统的当前趋势作为考量要素。以下是本次更新中的一些亮点:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;视觉体验&lt;/b&gt; - 我们着重介绍了使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//material.io/components&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Material Design&lt;/a&gt;&lt;/b&gt; 组件代替诸如按钮等平台组件的最佳实践。这将使您应用的外观更具现代感，并使诸如 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/guide/topics/ui/look-and-feel/darktheme&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;深色主题&lt;/a&gt;&lt;/b&gt; 等功能更易于实现。除了有关返回堆栈的建议以外，我们还将其扩展为保留应用的状态。即使在入门级手机中，&lt;b&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/281084168&quot; class=&quot;internal&quot;&gt;&quot;边到边&quot; 全面屏体验&lt;/a&gt;&lt;/b&gt; 和 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/DEI4bcmKkRBySUjO2AYEJA&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;手势导航&lt;/a&gt;&lt;/b&gt; 也已司空见惯，因此其重要性愈发显著。&lt;/li&gt;&lt;li&gt;&lt;b&gt;功能&lt;/b&gt; - 我们在三个方面更新了指导意见。对于媒体应用，我们更新了播放体验以及支持 HEVC 视频压缩编码方面的建议。对于应用间共享，我们着重说明了使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/sharing/send&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Android Sharesheet&lt;/a&gt;&lt;/b&gt; 的重要性。默认情况下，在 API 级别 30 中，&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/basics/intents/package-visibility-use-cases&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;其他已安装应用对您的应用的可见性有限&lt;/a&gt;&lt;/b&gt;，因此 Android Sharesheet 随之变得愈发重要。最后，我们丰富了在 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/about/versions/oreo/background%23services&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;后台服务&lt;/a&gt;&lt;/b&gt; 方面的建议。帮助用户延长电池寿命是 Android 的一项要务，我们将继续分享与此主题有关的动态。&lt;/li&gt;&lt;li&gt;&lt;b&gt;性能和稳定性&lt;/b&gt; - 我们在 Google Play 管理中心中加入了诸如 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/topic/performance/vitals&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Android Vitals&lt;/a&gt;&lt;/b&gt; 等目前可用的工具。在此，我们要着重介绍应用无响应 (ANR)。ANR 由线程问题引起，开发者是可以修复的。&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/topic/performance/vitals/anr&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ANR 问题排查指南&lt;/a&gt;&lt;/b&gt; 可以帮助您诊断和解决应用中存在的任何 ANR 问题。&lt;/li&gt;&lt;li&gt;&lt;b&gt;隐私和安全性&lt;/b&gt; - 我们总结了最新的建议内容，充分考虑了从运行时权限到安全使用 WebView 的最新保护措施。我们还进行了扩展，加入了从保护私密数据到不使用任何不可重置的硬件标识符等用户期待已久的隐私规范。&lt;/li&gt;&lt;li&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/mp/appmsgalbum%3F__biz%3DMzAwODY4OTk2Mg%3D%3D%26action%3Dgetalbum%26album_id%3D1334981818176831488%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Google Play&lt;/a&gt;&lt;/b&gt; - 在本部分中，我们重点介绍了一些对开发者而言最为重要的政策，并提供了相关指南的访问入口。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;未来，我们计划每季度更新一次此清单，从而为您提供最新的信息。此外，我们也将更新针对其他设备类型的质量核对清单。&lt;/p&gt;&lt;p&gt;我们还在不断探索其他工具和最佳实践，帮助您更加轻松地构建高质量的 Android 应用。希望您持续关注 &quot;谷歌开发者&quot; 公众号并通过留言或联系我们反馈您遇到的问题。我们已迫不及待，希望早日向您介绍这些新的改进。敬请期待！&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>23cb0c93be60becef56f6a63505ffdc2</guid>
<title>Redis 教程：Redis 知识体系详解</title>
<link>https://toutiao.io/k/av396i0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;theme-default-content content__default&quot;&gt;&lt;h1 id=&quot;♥redis教程---redis知识体系详解♥&quot;&gt;&lt;a href=&quot;#♥redis教程---redis知识体系详解♥&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; ♥Redis教程 - Redis知识体系详解♥&lt;/h1&gt; &lt;blockquote&gt;&lt;p&gt;本系列主要对Redis知识体系进行详解。@pdai&lt;/p&gt;&lt;/blockquote&gt;  &lt;h2 id=&quot;知识体系&quot;&gt;&lt;a href=&quot;#知识体系&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 知识体系&lt;/h2&gt; &lt;p&gt;&lt;em&gt;知识体系&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&lt;img alt=&quot;&quot; data-src=&quot;/_images/db/redis/db-redis-overview.png&quot; loading=&quot;lazy&quot; class=&quot;lazy&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;em&gt;相关文章&lt;/em&gt;&lt;/p&gt; &lt;blockquote&gt;&lt;p&gt;首先，我们通过学习Redis的概念基础，了解它适用的场景。&lt;/p&gt;&lt;/blockquote&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-introduce.html&quot;&gt;Redis入门 - Redis概念和基础&lt;/a&gt; &lt;ul&gt;&lt;li&gt;Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt; &lt;blockquote&gt;&lt;p&gt;其次，这些适用场景都是基于Redis支持的数据类型的，所以我们需要学习它支持的数据类型；同时在redis优化中还需要对底层数据结构了解，所以也需要了解一些底层数据结构的设计和实现。&lt;/p&gt;&lt;/blockquote&gt; &lt;p&gt;&lt;img alt=&quot;&quot; data-src=&quot;/_images/db/redis/db-redis-object-2-2.png&quot; loading=&quot;lazy&quot; class=&quot;lazy&quot;/&gt;&lt;/p&gt;  &lt;blockquote&gt;&lt;p&gt;再者，需要学习Redis支持的核心功能，包括持久化，消息，事务，高可用；高可用方面包括，主从，哨兵等；高可拓展方面，比如 分片机制等。&lt;/p&gt;&lt;/blockquote&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-rdb-aof.html&quot;&gt;Redis进阶 - 持久化：RDB和AOF机制详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;为了防止数据丢失以及服务重启时能够恢复数据，Redis支持数据的持久化，主要分为两种方式，分别是RDB和AOF; 当然实际场景下还会使用这两种的混合模式。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-pub-sub.html&quot;&gt;Redis进阶 - 消息传递：发布订阅模式详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-event.html&quot;&gt;Redis进阶 - 事件：Redis事件机制详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;Redis 采用事件驱动机制来处理大量的网络IO。它并没有使用 libevent 或者 libev 这样的成熟开源方案，而是自己实现一个非常简洁的事件驱动库 ae_event。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-trans.html&quot;&gt;Redis进阶 - 事务：Redis事务详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-copy.html&quot;&gt;Redis进阶 - 高可用：主从复制详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;我们知道要避免单点故障，即保证高可用，便需要冗余（副本）方式提供集群服务。而Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。本文主要阐述Redis的主从复制。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-sentinel.html&quot;&gt;Redis进阶 - 高可用：哨兵机制（Redis Sentinel）详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;在上文主从复制的基础上，如果注节点出现故障该怎么办呢？ 在 Redis 主从集群中，哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制模式下故障转移的问题。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-cluster.html&quot;&gt;Redis进阶 - 高可拓展：分片技术（Redis Cluster）详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;前面两篇文章，主从复制和哨兵机制保障了高可用，就读写分离而言虽然slave节点来扩展主从的读并发能力，但是写能力和存储能力是无法进行扩展的，就只能是master节点能够承载的上限。如果面对海量数据那么必然需要构建master（主节点分片)之间的集群，同时必然需要吸收高可用（主从复制和哨兵机制）能力，即每个master分片节点还需要有slave节点，这是分布式系统中典型的纵向扩展（集群的分片技术）的体现；所以在Redis 3.0版本中对应的设计就是Redis Cluster。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt; &lt;blockquote&gt;&lt;p&gt;最后，就是具体的实践以及实践中遇到的问题和解决方法了：在不同版本中有不同特性，所以还需要了解版本；以及性能优化，大厂实践等。&lt;/p&gt;&lt;/blockquote&gt;  &lt;h2 id=&quot;学习资料&quot;&gt;&lt;a href=&quot;#学习资料&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 学习资料&lt;/h2&gt; &lt;ul&gt;&lt;li&gt;&lt;p&gt;Redis官网:http://redis.io/&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Redis官方文档:http://redis.io/documentation&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Redis教程:http://www.w3cschool.cn/redis/redis-intro.html&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Redis下载:http://redis.io/download&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;redis英文文档 https://redis.io/topics/data-types&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;redis中文文档 http://www.redis.cn/documentation.html&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;《redis设计与实现 3.0版本》 http://redisbook.com/index.html&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;redis菜鸟教程 https://www.runoob.com/redis/redis-tutorial.html&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;redis源码解读 3.2.8版本 https://blog.csdn.net/men_wen/article/details/75668345&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;除此之外，我还推荐你看下 极客时间 《Redis核心技术与实战》（作者：蒋德钧）的相关内容，它是我看到的为数不多的含有实战经验比较多的专栏，部分文章中图片也来源于这个系列。&lt;/p&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>aa24a9edf54481fb0b270452b5dd0e07</guid>
<title>聊聊 Git 的三种传输协议及实现</title>
<link>https://toutiao.io/k/maymnjh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;摘要：众所周知，Git 是当前最流行的分布式版本控制系统，近两年由于 DevOps 的迅速发展，一切皆代码正在成为标准实践。而这一切，都需要有一个配置管理中心统一管控，Git 毫无疑问的成为了这个领域的宠儿。日常开发工作中，我们经常用不同方式去下载和上传代码到 Gitee，那么这背后是如何实现的呢，让我们一起来聊聊 Git 不同的传输协议以及具体的实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrJ3rMw1ABEbfDpJiaicxNRUB0EAFAdN34Zpb3vdlfIe496ZLxwZcBbXeJ2jjBJgCqpjrtJ8k8syTkxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; title=&quot;在这里输入图片标题&quot; data-ratio=&quot;0.3649906890130354&quot; data-w=&quot;1074&quot;/&gt;&lt;/p&gt;&lt;section&gt;前段时间在 InfoQ 公开课分享了 《Gitee 架构演进之路》主题（回放地址：https://live.infoq.cn/room/602），中间有简单介绍了集中 Git 传输协议，并展开讲解了一下 HTTP 协议的传输机制，分享后不少同学通过公众号反馈有没有更详细的实战介绍，除了推荐一些博客、官方文档，好像也没有更好的资料，于是想着写写文章来聊聊自己的理解。&lt;/section&gt;&lt;section&gt;Git 在官方文档介绍了四种传输协议，并且对比了它们之间的优劣，这里就不再赘述了，感兴趣的可以翻阅上面公开课的PPT或者直接查看官方文档。另外在源码设计文档非常详细的介绍了HTTP、SSH 及 Git 三种传输协议的定义和规范，后续所有的介绍均围绕官方文档进行，与官方文档不同的是本系列文章会通过具体的实战，使用 Go 语言来实现相关协议 Git 服务端，以此来加深对相关传输协议的理解。&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;Git 协议介绍：https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E5%8D%8F%E8%AE%AE源码设计文档：https://github.com/git/git/blob/master/Documentation/technical/&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;span&gt;HTTP 传输协议&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Git HTTP 协议主要分为两种，一种是哑协议（Dump），另外一种是智能协议（Smart），也是目前各个提供 Git 托管服务普遍所采用的协议。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;官方文档：https://github.com/git/git/blob/master/Documentation/technical/http-protocol.txt&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;&lt;span&gt;HTTP 哑协议（Dump Protocol）&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;在 Git 1.6.6 版本之前是只提供哑协议的，哑协议只需要一个标准的 HTTP 静态文件服务，这个服务只需要能够提供文件的下载即可，Git 客户端会自动进行文件的遍历和拉取。&lt;/section&gt;&lt;section&gt;无论是哑协议还是智能协议，Git 在使用 HTTP 协议进行 Fetch 操作的时候，总是要先获取&lt;code&gt;info/refs&lt;/code&gt;文件，这个文件是在裸仓库的目录下的，如果你已经有一个通过 Git 拉取的仓库，这个文件就在仓库根目录的&lt;code&gt;.git/info/refs&lt;/code&gt;。不过这个文件一般情况下是没有的，它需要你在相应的目录执行&lt;code&gt;git update-server-info&lt;/code&gt;进行生成：&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;➜&lt;/span&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;.git git:(master) cat info/refs&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;21f45f60fa582d085497fb2d3bb50163e59891ee&lt;/span&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;refs/heads/history&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;ef8021acf4c29eb35e3084b7dc543c173d67ad2a&lt;/span&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;refs/heads/master&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;文件内容主要是服务端上每个引用的版本，客户端拿到这些引用之后，就可以跟本地的引用进行对比，对于缺失的对象文件，则通过 HTTP 的方式进行下载。&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;Tips1: 关于 Git 存储格式请参见：https://github.com/git/git/blob/master/Documentation/gitrepository-layout.txt，后续文章会展开介绍&lt;/p&gt;&lt;p&gt;Tips2: 如果有更新都要手动执行&lt;code&gt;update-server-info&lt;/code&gt;？答案是 No，可以配置 Git 服务端的&lt;code&gt;post-receive&lt;/code&gt;钩子自动执行更新&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;所以，一次通过哑协议 Clone 的过程如下：（U：用户 C：客户端  S：服务端）&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;U：git clone https://gitee.com/kesin/taskover.git&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;C：GET https://gitee.com/kesin/taskover.git/info/refs&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;S：Response &lt;span class=&quot;code-snippet__keyword&quot;&gt;with&lt;/span&gt; taskover.git/info/refs&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;C：&lt;span class=&quot;code-snippet__keyword&quot;&gt;GET&lt;/span&gt; https://gitee.com/kesin/taskover.git/&lt;span class=&quot;code-snippet__keyword&quot;&gt;HEAD&lt;/span&gt; （默认分支）&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;S：Response &lt;span class=&quot;code-snippet__keyword&quot;&gt;with&lt;/span&gt; taskover.git/&lt;span class=&quot;code-snippet__keyword&quot;&gt;HEAD&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;C：&lt;span class=&quot;code-snippet__keyword&quot;&gt;Get&lt;/span&gt; https://gitee.com/kesin/taskover.git/objects/ef/&lt;span class=&quot;code-snippet__number&quot;&gt;8021&lt;/span&gt;acf4c29eb35e3084b7dc543c173d67ad2a 开始遍历对象，找出那些本地没有的，去服务端获取，如果服务端无法直接获取，则从 Pack 文件中进行抓取，直到全部拿到&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;C：根据 HEAD 中的默认分支执行 checkout 操作检出到本地&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;上面的那些地址是为了演示用，实际 Gitee 仅支持智能协议而不支持哑协议，毕竟对于一个公有云服务是不安全的。关于对象如何遍历这里也不再展开，后续文章会介绍&lt;/p&gt;&lt;/blockquote&gt;&lt;section&gt;哑协议的实现非常简单，通过&lt;code&gt;nginx&lt;/code&gt;即可简单实现，只需要配置一个静态文件服务器，然后将 Git 仓库以单目录的形式放上去即可；也可以使用 Go 快速实现一个简单的 Git HTTP Dump Server：&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/&lt;span class=&quot;code-snippet__regexp&quot;&gt;/ From: https:/&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/gitee.com/kesin&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/go-git-protocols/blob&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/master/http&lt;/span&gt;-dumb/git-http-dumb.go&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/&lt;span class=&quot;code-snippet__regexp&quot;&gt;/ Usage: ./http&lt;/span&gt;-dumb -repo=&lt;span class=&quot;code-snippet__regexp&quot;&gt;/xxx/xxx&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/xxx/&lt;/span&gt; -port=&lt;span class=&quot;code-snippet__number&quot;&gt;8881&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func main() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  repo &lt;span class=&quot;code-snippet__symbol&quot;&gt;:&lt;/span&gt;= flag.String(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;repo&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/Users/zoker/Tmp/repositories&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Specify a repositories root dir.&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  port &lt;span class=&quot;code-snippet__symbol&quot;&gt;:&lt;/span&gt;= flag.String(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;port&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;8881&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Specify a port to start process.&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  flag.Parse()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  http.Handle(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/&quot;&lt;/span&gt;, http.FileServer(http.Dir(*repo)))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.Printf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Dumb http server start at port %s on dir %s \n&quot;&lt;/span&gt;, *port, *repo)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__number&quot;&gt;_&lt;/span&gt; = http.ListenAndServe(fmt.Sprintf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;:%s&quot;&lt;/span&gt;, *port), &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;HTTP 智能协议（Smart Protocol）&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;HTTP 智能协议与哑协议最大的区别在于：哑协议在获取想要的数据的时候要自行指定文件资源的网络地址，并且通过多次的下载操作来达到目的；而智能协议的主动权则掌握在服务端，服务端提供的&lt;code&gt;info/refs&lt;/code&gt;可以动态更新，并且可以通过客户端传来的参数，决定本次交互客户端所需要的最小对象集，并打包压缩发给客户端，客户端会进行解压来拿到自己想要的数据，整个交互过程如下：&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.40831758034026466&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrJ3rMw1ABEbfDpJiaicxNRUB0J7bG90j4FhtUiceA2DzIbmtMibLFUvUKHJLscMm1w7tsdd6IkFS3ZRibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1058&quot;/&gt;&lt;/p&gt;&lt;p&gt;通过监听对应端口，我们可以看到整个过程客户端发送了两次请求：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.17890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrJ3rMw1ABEbfDpJiaicxNRUB0Nwzp0MI2gkV0dcBooYnBuQlhYy1bzqmcH8pHkNRLKR5Xvicpe1sdWGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;引用发现 &lt;code&gt;GET https://gitee.com/kesin/taskover/info/refs?service=git-{upload|receive}-pack&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据传输 &lt;code&gt;POST https://gitee.com/kesin/taskover/git-{upload|receive}-pack&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Git HTTP 协议要求无论是下载操作还是上传操作，都必须先执行引用发现，也就是需要知道服务端的各个引用的版本信息，这样的话才能让服务端或者客户端知道两方之间的差异以及需要什么样的数据。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;1. 引用发现&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;与哑协议不同的是，智能协议的的服务端是动态服务器，能够根据期望来提供相关的引用信息，你可以根据自己的业务需求来决定想让客户端知道什么样的信息，通过抓包我们可以看到客户端请求的数据以及 Gitee 服务端返回的引用信息格式&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;GET http://git.oschina.net/kesin/getingblog.git/info/refs?service=git-upload-pack HTTP/1.1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Host: git.oschina.net&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;User-Agent: git/2.24.3 (Apple Git-128)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Accept-Encoding: deflate, gzip&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Proxy-Connection: Keep-Alive&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;Pragma&lt;/span&gt;: &lt;span class=&quot;code-snippet__keyword&quot;&gt;no&lt;/span&gt;-&lt;span class=&quot;code-snippet__keyword&quot;&gt;cache&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;HTTP&lt;/span&gt;/&lt;span class=&quot;code-snippet__number&quot;&gt;1.1&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;200&lt;/span&gt; OK&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;Cache&lt;/span&gt;-Control: &lt;span class=&quot;code-snippet__keyword&quot;&gt;no&lt;/span&gt;-&lt;span class=&quot;code-snippet__keyword&quot;&gt;cache&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;max&lt;/span&gt;-age=&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, must-revalidate&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;Connection&lt;/span&gt;: &lt;span class=&quot;code-snippet__keyword&quot;&gt;keep&lt;/span&gt;-alive&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;Content&lt;/span&gt;-&lt;span class=&quot;code-snippet__keyword&quot;&gt;Type&lt;/span&gt;: application/x-git-upload-pack-advertisement&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Expires: Fri, &lt;span class=&quot;code-snippet__number&quot;&gt;01&lt;/span&gt; Jan &lt;span class=&quot;code-snippet__number&quot;&gt;1980&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;00&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;00&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;00&lt;/span&gt; GMT&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;Pragma&lt;/span&gt;: &lt;span class=&quot;code-snippet__keyword&quot;&gt;no&lt;/span&gt;-&lt;span class=&quot;code-snippet__keyword&quot;&gt;cache&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;Server&lt;/span&gt;: nginx&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;X-Frame-Options: DENY&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;X-Gitee-&lt;span class=&quot;code-snippet__keyword&quot;&gt;Server&lt;/span&gt;: Brzox/&lt;span class=&quot;code-snippet__number&quot;&gt;3.2&lt;/span&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;.3&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;X-Request-&lt;span class=&quot;code-snippet__keyword&quot;&gt;Id&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;96e0&lt;/span&gt;af82-dffe&lt;span class=&quot;code-snippet__number&quot;&gt;-4352&lt;/span&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;-9&lt;/span&gt;fa5&lt;span class=&quot;code-snippet__number&quot;&gt;-92&lt;/span&gt;f652ed39c7&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Transfer-&lt;span class=&quot;code-snippet__keyword&quot;&gt;Encoding&lt;/span&gt;: chunked&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;001&lt;/span&gt;e&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;0000&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;010&lt;/span&gt;fca6ce400113082241c1f45daa513fabacc66a20d HEADmulti_ack thin-pack side-band side-band&lt;span class=&quot;code-snippet__number&quot;&gt;-64&lt;/span&gt;k ofs-delta shallow deepen-since deepen-&lt;span class=&quot;code-snippet__keyword&quot;&gt;not&lt;/span&gt; deepen-&lt;span class=&quot;code-snippet__keyword&quot;&gt;relative&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;no&lt;/span&gt;-progress &lt;span class=&quot;code-snippet__keyword&quot;&gt;include&lt;/span&gt;-tag multi_ack_detailed &lt;span class=&quot;code-snippet__keyword&quot;&gt;no&lt;/span&gt;-done symref=&lt;span class=&quot;code-snippet__keyword&quot;&gt;HEAD&lt;/span&gt;:refs/heads/testbody &lt;span class=&quot;code-snippet__keyword&quot;&gt;object&lt;/span&gt;-&lt;span class=&quot;code-snippet__keyword&quot;&gt;format&lt;/span&gt;=&lt;span class=&quot;code-snippet__keyword&quot;&gt;sha1&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;agent&lt;/span&gt;=git/&lt;span class=&quot;code-snippet__number&quot;&gt;2.29&lt;/span&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;.2&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;003&lt;/span&gt;c351bad7fdb498c9634442f0c3f60396e8b92f4fb refs/heads/dev&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;004092&lt;/span&gt;ad3c48e627782980f82b0a8b05a1a5221d8b74 refs/heads/dev-pro&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;0040&lt;/span&gt;ae747d0a0094af3d27ee86c33e645139728b2a9a refs/heads/develop&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;0000&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;我们需要关注的信息在 Header 和 Body，这里简单介绍一下，更详细的介绍请参见上面提到的&lt;code&gt;http-protocol.txt&lt;/code&gt;文档
Header 包含了一些约定：&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Cache-Control 必须禁止缓存，不然可能看不到最新的提交信息&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Content-Type 必须是&lt;code&gt;application/x-$servicename-advertisement&lt;/code&gt;，不然客户端会以哑协议的方式去处理&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;客户端需要验证返回的状态码，如果是&lt;code&gt;401&lt;/code&gt;那么就提示输入用户名密码&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;另外我们能看到返回的 Body 格式跟哑协议所用的&lt;code&gt;info/refs&lt;/code&gt;内容是不一样的，这里是智能协议所约定的格式，客户端根据这个来识别支持的属性和验证信息，这是一个&lt;code&gt;pkt-line&lt;/code&gt;格式的数据：&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;客户端需要验证第一首行的四个字符符合正则&lt;code&gt;^[0-9a-f]{4}#&lt;/code&gt;，这里的四个字符是代表后面内容的长度&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;客户端需要验证第一行是&lt;code&gt;# service=$servicename&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;服务端得保证每一行结尾需要包含一个&lt;code&gt;LF&lt;/code&gt;换行符&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;服务端需要以&lt;code&gt;0000&lt;/code&gt;标识结束本次请求响应&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;在&lt;code&gt;HEAD&lt;/code&gt;引用后还有一系列的服务端能力的参数，这些参数会告诉客户端服务端具有什么样的能力，比如可以通过&lt;code&gt;multi_ack&lt;/code&gt;模式进行数据交互等，这里不在赘述。再往后就是具体的每一个引用的信息，每行的开头四个字符均是本行的长度。&lt;/section&gt;&lt;section&gt;在介绍哑协议的时候，我们使用通过&lt;code&gt;git update-server-info&lt;/code&gt;命令生成的&lt;code&gt;info/refs&lt;/code&gt;文件，但是很明显我们在智能协议这里无法直接使用，因为它不符合&lt;code&gt;pkt-line&lt;/code&gt;的格式，所以 Git 提供另外一种方式：通过 &lt;code&gt;git upload-pack&lt;/code&gt;命令来直接获取最新的&lt;code&gt;pkt-line&lt;/code&gt;格式的引用信息，来看看它的参数支持：&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;Do&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;not&lt;/span&gt; try &amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;directory&lt;/span&gt;&amp;gt;/.git/ &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; &amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;directory&lt;/span&gt;&amp;gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;no&lt;/span&gt; Git directory.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Interrupt transfer &lt;span class=&quot;code-snippet__keyword&quot;&gt;after&lt;/span&gt; &amp;lt;n&amp;gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;seconds&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;of&lt;/span&gt; inactivity.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Perform &lt;span class=&quot;code-snippet__keyword&quot;&gt;only&lt;/span&gt; a single &lt;span class=&quot;code-snippet__keyword&quot;&gt;read&lt;/span&gt;-write &lt;span class=&quot;code-snippet__keyword&quot;&gt;cycle&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;with&lt;/span&gt; stdin &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; stdout. This fits &lt;span class=&quot;code-snippet__keyword&quot;&gt;with&lt;/span&gt; the &lt;span class=&quot;code-snippet__keyword&quot;&gt;HTTP&lt;/span&gt; POST request processing&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; a program may &lt;span class=&quot;code-snippet__keyword&quot;&gt;read&lt;/span&gt; the request, write a response, &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; must exit.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;Only&lt;/span&gt; the &lt;span class=&quot;code-snippet__keyword&quot;&gt;initial&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;ref&lt;/span&gt; advertisement &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;output&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; the program exits immediately. This fits &lt;span class=&quot;code-snippet__keyword&quot;&gt;with&lt;/span&gt; the &lt;span class=&quot;code-snippet__keyword&quot;&gt;HTTP&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;GET&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;request &lt;span class=&quot;code-snippet__keyword&quot;&gt;model&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;no&lt;/span&gt; request &lt;span class=&quot;code-snippet__keyword&quot;&gt;content&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; received but a response must be produced.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;directory&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;The repository &lt;span class=&quot;code-snippet__keyword&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;sync&lt;/span&gt; from.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;code&gt;upload-pack&lt;/code&gt;是用来发送对象给客户端的一个远程调用模块，但是它提供了&lt;code&gt;--stateless-rpc&lt;/code&gt;和&lt;code&gt;--advertise-refs&lt;/code&gt;参数，能够让我们快速拿到当前的引用状态并退出，我们在服务端的裸仓库目录执行就可以直接拿到最新的引用信息：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;➜  .git git:(master) git upload-&lt;span class=&quot;code-snippet__keyword&quot;&gt;pack&lt;/span&gt; --stateless-rpc --advertise-refs .&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;010&lt;/span&gt;aef8021acf4c29eb35e3084b7dc543c173d67ad2a HEADmulti_ack thin-&lt;span class=&quot;code-snippet__keyword&quot;&gt;pack&lt;/span&gt; side-band side-band-&lt;span class=&quot;code-snippet__number&quot;&gt;64&lt;/span&gt;k ofs-delta shallow deepen-since deepen-&lt;span class=&quot;code-snippet__keyword&quot;&gt;not&lt;/span&gt; deepen-relative &lt;span class=&quot;code-snippet__keyword&quot;&gt;no&lt;/span&gt;-progress include-tag multi_ack_detailed &lt;span class=&quot;code-snippet__keyword&quot;&gt;no&lt;/span&gt;-done symref=HEAD:refs/heads/master agent=git/&lt;span class=&quot;code-snippet__number&quot;&gt;2.24&lt;/span&gt;.&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;.(Apple.Git-&lt;span class=&quot;code-snippet__number&quot;&gt;128&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;003&lt;/span&gt;fef8021acf4c29eb35e3084b7dc543c173d67ad2a refs/heads/master&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;0000&lt;/span&gt;%&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;这里的内容是不是似曾相识，跟上面我们抓包获取到的 Gitee 返回的引用数据格式一样，只是少了首行的&lt;code&gt;# service=git-upload-pack&lt;/code&gt;，所以我们现在思路非常清晰，可以先来实现第一步引用发现的服务端的处理，通过对参数的解析，我们可以拿到仓库名称以及相应的操作名称，就可以进一步整理出客户端要的响应格式：&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;handleRefs&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  vars := mux.Vars(r)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  repoName := vars[&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;repo&quot;&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  repoPath := fmt.Sprintf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;%s%s&quot;&lt;/span&gt;, *repoRoot, repoName)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  service := r.FormValue(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;service&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  pFirst := fmt.Sprintf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;# service=%s\n&quot;&lt;/span&gt;, service) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  handleRefsHeader(&amp;amp;w, service) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  cmdRefs := exec.Command(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;git&quot;&lt;/span&gt;, service[&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;:], &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;--stateless-rpc&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;--advertise-refs&quot;&lt;/span&gt;, repoPath)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  refsBytes, _ := cmdRefs.Output() &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  responseBody := fmt.Sprintf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;%04x# service=%s\n0000%s&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;len&lt;/span&gt;(pFirst)+&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;, service, &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;(refsBytes)) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  _, _ = w.Write([]&lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;(responseBody))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;handleRefsHeader&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(w *http.ResponseWriter, service &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  cType := fmt.Sprintf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;application/x-%s-advertisement&quot;&lt;/span&gt;, service)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  (*w).Header().Add(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;, cType)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  (*w).Header().Set(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Expires&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Fri, 01 Jan 1980 00:00:00 GMT&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  (*w).Header().Set(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Pragma&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;no-cache&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  (*w).Header().Set(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Cache-Control&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;no-cache, max-age=0, must-revalidate&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;上面我们也提到了，无论是拉取还是推送，都需要先进行引用发现，实际上&lt;code&gt;upload-pack&lt;/code&gt;和&lt;code&gt;receive-pack&lt;/code&gt;所处理的差别仅仅是调用的命令不同而已，这一点我们也在&lt;code&gt;handleRefs&lt;/code&gt;函数里面做了相应的兼容处理，这里不再赘述。&lt;/section&gt;&lt;h4&gt;&lt;span&gt;2. 数据传输&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;数据传输分为两部分：客户端向服务端传输（Push）、服务端向客户端传输（Fetch）。两者的区别在于：&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Fetch 操作在获取引用发现之后，由 &lt;span&gt;服务端&lt;/span&gt; 计算出客户端想要的数据，并把数据以&lt;code&gt;pkt-line&lt;/code&gt;的格式&lt;code&gt;POST&lt;/code&gt;给服务端，由服务端进行&lt;code&gt;Pack&lt;/code&gt;的计算和打包，将包作为 &lt;code&gt;POST&lt;/code&gt; 的响应发送给客户端，客户端进行解压和引用更新&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Push 操作获取到服务端的引用列表后，由 &lt;span&gt;客户端&lt;/span&gt; 本地计算出客户端所缺失的数据，将这些数据打包，并&lt;code&gt;POST&lt;/code&gt;给服务端，服务端接收到后进行解压和引用更新&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;Fetch 操作其实用到了上面我们提到的&lt;code&gt;upload-pack&lt;/code&gt;，它是一个发送对象给客户端的远程调用模块，为了实现拉取功能，我们只需要在服务端启动 &lt;code&gt;git upload-pack --stateless-rpc&lt;/code&gt; ，这个命令阻塞的接收一串参数，而这串参数是客户端的第二次请求发送过来的，把它传递给这个命令，Git 就会自动的计算客户端所需要的最小对象集并打包，以流的形式返回这个包数据，我们只需要把这个包作为 POST 请求的响应发给客户端就好了。&lt;/section&gt;&lt;section&gt;那么，在 Fetch 操作中，客户端第二次 POST 请求发过来的数据是什么呢，我们也来抓个包分析一下：&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;http&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;POST&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;http://gitee.com/kesin/bigRepo/git-upload-pack&lt;/span&gt; HTTP/1.1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;Host&lt;/span&gt;: gitee.com&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;User-Agent&lt;/span&gt;: git/2.24.3 (Apple Git-128)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;Accept-Encoding&lt;/span&gt;: deflate, gzip&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;Proxy-Connection&lt;/span&gt;: Keep-Alive&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;Content-Type&lt;/span&gt;: application/x-git-upload-pack-request&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;Accept&lt;/span&gt;: application/x-git-upload-pack-result&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;Content-Length&lt;/span&gt;: 443&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;00b4want&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;bee4d57e3adaddf355315edf2c046db33aa299e8 multi_ack_detailed no-done side-band-64k thin-pack include-tag ofs-delta deepen-since deepen-not agent=git/2.24.3.(Apple.Git-128)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;00000032have&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;82a8768e7fd48f76772628d5a55475c51ea4fa2f&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;0032have&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;4f7a2ea0920751a5501debbbc1debc403b46d7a0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;0032have&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;7c141974a30bd218d4257d4292890a9008d30111&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;0032have&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;f6bb00364bd5000a45185b9b16c028f485e842db&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;0032have&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;47b7bd17fcb7de646cf49a26efb43c7b708498f3&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;0009done&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;客户端在拿到第一次引用发现服务端返回的数据后，会根据服务端所提供的能力(&lt;code&gt;capabilities&lt;/code&gt;)列表以及引用（&lt;code&gt;refs&lt;/code&gt;）列表来计算出第二次需要发送的数据，比如会根据服务端的能力列表来决定客户端和服务端通信所需要的能力参数，这些能力参数服务端必须全部支持。另外，客户端发送的数据必须包含一个&lt;code&gt;want&lt;/code&gt;指令，我们在 Clone 一个仓库的时候所发送的数据全部都是&lt;code&gt;want&lt;/code&gt;指令，而不包含&lt;code&gt;have&lt;/code&gt;指令，因为本地什么都没有；而在进行有数据的更新的 Fetch 操作的时候，就会有&lt;code&gt;have&lt;/code&gt;指令。客户端会根据返回的引用信息计算出所需要的 &lt;code&gt;Commit&lt;/code&gt;、&lt;code&gt;Common Commit&lt;/code&gt; 以及 自己有服务端没有的 &lt;code&gt;Commit&lt;/code&gt;，并将这些数据一次性的通过第二次请求发给服务端，具体客户端的协商过程可以参见&lt;code&gt;http-protocol.txt&lt;/code&gt;，这里不再赘述。&lt;/section&gt;&lt;section&gt;服务端在收到这些数据之后，会先确认&lt;code&gt;want&lt;/code&gt;指令所指定的对象是否都能够在引用中找到，如果没有&lt;code&gt;want&lt;/code&gt;指令或者指令指定的对象中有不包含在服务端的，则会返回给客户端错误信息，服务端根据这些信息计算出客户端所需要的对象的集合，并把这些对象打包返回给客户端，客户端接收后解压包并更新引用。&lt;/section&gt;&lt;section&gt;Push 操作大同小异，只不过在第二步的时候，客户端会根据服务端的引用信息计算出服务端所需要的对象，直接通过 Post 请求发送给服务端，并同时附带一些指令信息，比如新增、删除、更新哪些引用，以及更新前后的版本，具体格式如下：&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__meta&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;https://github.com/git/git/blob/master/Documentation/technical/http-protocol.txt#L474&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attr&quot;&gt;C&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;POST $GIT_URL/git-receive-pack HTTP/1.0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attr&quot;&gt;C&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;Content-Type: application/x-git-receive-pack-request&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attr&quot;&gt;C&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attr&quot;&gt;C&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;....0a53e9ddeaddad63ad106860237bbf53411d11a7 441b40d833fdfa93eb2908e52742248faf0ee993 refs/heads/maint\0 report-status&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attr&quot;&gt;C&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;0000&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attr&quot;&gt;C&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;PACK....&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;这里的包数据格式为&lt;code&gt;&quot;PACK&quot; &amp;lt;binary data&amp;gt;&lt;/code&gt;，会以&lt;code&gt;PACK&lt;/code&gt;开头。服务端接收到这些数据后，启动一个远程调用命令&lt;code&gt;receive-pack&lt;/code&gt;，然后将数据以管道的形式传给这个命令即可。&lt;/section&gt;&lt;section&gt;所以，整个数据传输的过程无非就是客户端与服务端的&lt;code&gt;upload-pack&lt;/code&gt;和&lt;code&gt;receive-pack&lt;/code&gt;对规定格式的数据交换而已，根据这个思路，我们可以继续完善我们的 Smart Git HTTP Server，来增加对第二步的处理能力：&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;processPack&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  vars := mux.Vars(r)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  repoName := vars[&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;repo&quot;&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  repoPath := fmt.Sprintf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;%s%s&quot;&lt;/span&gt;, *repoRoot, repoName)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  service := vars[&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;service&quot;&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  handlePackHeader(&amp;amp;w, service)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  cmdPack := exec.Command(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;git&quot;&lt;/span&gt;, service[&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;:], &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;--stateless-rpc&quot;&lt;/span&gt;, repoPath)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  cmdStdin, err := cmdPack.StdinPipe()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  cmdStdout, err := cmdPack.StdoutPipe()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  _ = cmdPack.Start()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    _, _ = io.Copy(cmdStdin, r.Body)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    _ = cmdStdin.Close()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  _, _ = io.Copy(w, cmdStdout)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  _ = cmdPack.Wait() &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;完整的实现见：https://gitee.com/kesin/go-git-protocols/tree/master/http-smart&lt;/p&gt;&lt;h2&gt;&lt;span&gt;Git &amp;amp;&amp;amp; SSH 传输协议&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;Git 协议以及 SSH 协议都是四层的传输协议，而 HTTP 则是七层的传输协议，受限于 HTTP 协议的特点，HTTP 在 Git 相关的操作上存在传输限制、超时等问题，这个问题在大仓库的传输中尤为明显，相比与 HTTP 而言，Git 以及 SSH 协议在传输上更简单而且更稳定。&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;官方文档：https://github.com/git/git/blob/master/Documentation/technical/pack-protocol.txt&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;&lt;span&gt;Git 协议&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;Git 协议最大的优势就是速度快，因为它没有 HTTP 的传输协议的条条框框，也没有 SSH 加解密的成本，但受限于协议的缺点，Git 协议常用于开源项目的下载，不作为私有项目的传输协议。&lt;/section&gt;&lt;section&gt;在上面我们研究 HTTP 智能协议的实现的时候，我们知道 Git 客户端跟服务端的交互主要包含两个步骤：&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;获取服务端的引用&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;客户端根据服务端的引用数据与服务端进行数据交换&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;Git 协议也是如此，只不过相比于 HTTP 协议，Git 协议直接在四层与服务端建立连接，通过这个长链接直接完成两个步骤：&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4053156146179402&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrJ3rMw1ABEbfDpJiaicxNRUB0V4KwMIfEPUwhK0l93TevvgFcHsTxABgOvN8ic0UrydMMwkPXVJQrK2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1204&quot;/&gt;&lt;/p&gt;&lt;section&gt;在使用 Git 协议操作的时候，首先客户端会把相关的信息发给服务端，这个信息的格式同样的采用&lt;code&gt;pkt-line&lt;/code&gt;的格式：&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;003&lt;/span&gt;egit-upload-&lt;span class=&quot;code-snippet__keyword&quot;&gt;pack&lt;/span&gt; /project.git\0host=myserver.com\&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;\0version=&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;\&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;其中包含了命令、仓库名称、Host 等相关信息，服务端建立连接之后，接收到这串信息，需要对其中的信息进行加工，找到对应的仓库所在的位置也就是目录，当所有的信息都符合要求之后，只需要在服务端启动&lt;code&gt;upload-pack&lt;/code&gt;命令即可，这里需要注意的是我们不需要添加&lt;code&gt;--stateless-rpc&lt;/code&gt;参数，直接&lt;code&gt;git upload-pack {repo_path}&lt;/code&gt;，这个命令启动后会马上返回相关的引用信息并且阻塞等待下一次信息的输入：&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;➜  hello git:(master) ✗ git upload-&lt;span class=&quot;code-snippet__keyword&quot;&gt;pack&lt;/span&gt; .&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;010234&lt;/span&gt;d8ed9a9f73d2cac9f50a8c8c03e4643990a2bf HEADmulti_ack thin-&lt;span class=&quot;code-snippet__keyword&quot;&gt;pack&lt;/span&gt; side-band side-band-&lt;span class=&quot;code-snippet__number&quot;&gt;64&lt;/span&gt;k ofs-delta shallow deepen-since deepen-&lt;span class=&quot;code-snippet__keyword&quot;&gt;not&lt;/span&gt; deepen-relative &lt;span class=&quot;code-snippet__keyword&quot;&gt;no&lt;/span&gt;-progress include-tag multi_ack_detailed symref=HEAD:refs/heads/master agent=git/&lt;span class=&quot;code-snippet__number&quot;&gt;2.24&lt;/span&gt;.&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;.(Apple.Git-&lt;span class=&quot;code-snippet__number&quot;&gt;128&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;003&lt;/span&gt;f34d8ed9a9f73d2cac9f50a8c8c03e4643990a2bf refs/heads/master&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;0000&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;这个时候我们所做的其实就是数据的转发，命令的标准输出信息我们原封不动的发送给客户端，客户端则会进行跟 HTTP 协议类似的处理产生数据，接着会把数据发给服务端，我们再原封不动的发给&lt;code&gt;git upload-pack {repo_path}&lt;/code&gt;命令的标准输入，然后服务端处理完成后会把相应的包通过标准输出返回，我们原封不动的发给客户端，就完成了一次 Fetch 操作，而 Push 的 &lt;code&gt;receive-pack&lt;/code&gt; 操作原理相同，这里不再赘述。&lt;/section&gt;&lt;section&gt;需要注意的是，如果客户端发送的信息不符合要求，或者处理过程中出现了问题，我们返回错误告知客户端，这个错误的格式也是&lt;code&gt;pkt-line&lt;/code&gt;格式的，以&lt;code&gt;ERR&lt;/code&gt;开头：&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;exitSession&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(conn net.Conn, err error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  errStr := fmt.Sprintf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ERR %s&quot;&lt;/span&gt;, err.Error())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  pktData := fmt.Sprintf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;%04x%s&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;len&lt;/span&gt;(errStr)+&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;, errStr)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  _, _ = conn.Write([]&lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;(pktData))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  _ = conn.Close()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;客户端接收到这个信息之后，就会打印信息并关闭连接，整个过程的数据均可以通过转包获取到，感兴趣的同学可以通过抓包来进一步加深了解 Git 协议的传输过程。&lt;/section&gt;&lt;section&gt;了解了 Git 协议的过程之后，我们就可以通过代码来实现一个简单的 Git 协议服务器：&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;handleRequest&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(conn net.Conn)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    service, repo, err := parseData(conn) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; service != &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;git-upload-pack&quot;&lt;/span&gt; &amp;amp;&amp;amp; service != &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;git-receive-pack&quot;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    exitSession(conn, errors.New(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Not allowed command. \n&quot;&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  repoPath := fmt.Sprintf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;%s%s&quot;&lt;/span&gt;, *repoRoot, repo)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  cmdPack := exec.Command(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;git&quot;&lt;/span&gt;, service[&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;:], repoPath)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  cmdStdin, err := cmdPack.StdinPipe()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  cmdStdout, err := cmdPack.StdoutPipe()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  _ = cmdPack.Start()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; { _, _ = io.Copy(cmdStdin, conn) }()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  _, _ = io.Copy(conn, cmdStdout)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  err = cmdPack.Wait()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;完整的实现见：https://gitee.com/kesin/go-git-protocols/tree/master/git-server&lt;/p&gt;&lt;h3&gt;&lt;span&gt;SSH 协议&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;SSH 协议也是应用的比较广泛的一种 Git 传输协议，相比于 Git 协议，SSH 协议从数据传输和权限认证上都相对安全，但是受限于加解密的成本，速度会稍慢，但是这个时间成本在安全面前绝对是可以接受的。与 Git 协议比较，不同点是 SSH 协议传输的数据经过加密，相同点是 SSH 协议的传输过程与 Git 协议一致，都是跟服务端的进程做数据交换：&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrJ3rMw1ABEbfDpJiaicxNRUB0A1QMwXft12Y3XvWkibdQMPlXFSVjWENowZ8eEcQUgOI2Uajm8kS17eg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;SSH 的下载地址一般都是 &lt;code&gt;git@gitee.com:kesin/go-git-protocols.git&lt;/code&gt; 这种形式的，在执行 Clone 或者 Push 的时候，会拆解成：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;ssh&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;user&lt;/span&gt;@&lt;span class=&quot;code-snippet__keyword&quot;&gt;example&lt;/span&gt;.&lt;span class=&quot;code-snippet__keyword&quot;&gt;com&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;git-upload-pack &#x27;/project.git&#x27;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;所以 SSH 协议在首次传参的时候与 Git 协议的格式不同，其他情况基本一致，比如引用发现、Packfile 机制、错误处理等等，这里都不再做延伸，可以参加官方文档。&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;对 Packfile 的协商生成策略感兴趣的可以参见：https://github.com/git/git/blob/master/Documentation/technical/pack-protocol.txt#L229&lt;/p&gt;&lt;/blockquote&gt;&lt;section&gt;明白 SSH 协议是怎么回事后，我们想要实现一个 Git SSH 服务器就比较明确了，只需要实现一个 SSH Server 并且在对应的 Session 做对应的数据传输即可，我们来实现一个简单的 Git SSH 服务，代码如下：&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; hostOption ssh.Option&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  hostOption = ssh.HostKeyFile(*hostKeyPath)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  keyHandler := &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ctx ssh.Context, key ssh.PublicKey)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    pubKeyStr := gossh.MarshalAuthorizedKey(key)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  keyOption := ssh.PublicKeyAuth(keyHandler)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  pwdHandler := &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ctx ssh.Context, password &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; ctx.User() == &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;zoker&quot;&lt;/span&gt; &amp;amp;&amp;amp; password == &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;zoker&quot;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  pwdOption := ssh.PasswordAuth(pwdHandler)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ssh.Handle(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(s ssh.Session)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    handlePack(s) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  })&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  addr := fmt.Sprintf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;:%s&quot;&lt;/span&gt;, *port)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  log.Printf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Starting ssh server on port %s \n&quot;&lt;/span&gt;, *port)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  log.Fatal(ssh.ListenAndServe(addr, &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;, hostOption, pwdOption, keyOption))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;handlePack&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(s ssh.Session)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  args := s.Command()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  service := args[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  repoName := args[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; service != &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;git-upload-pack&quot;&lt;/span&gt; &amp;amp;&amp;amp; service != &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;git-receive-pack&quot;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    exitSession(s, errors.New(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Not allowed command. \n&quot;&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  repoPath := fmt.Sprintf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;%s%s&quot;&lt;/span&gt;, *repoRoot, repoName)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  cmdPack := exec.Command(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;git&quot;&lt;/span&gt;, service[&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;:], repoPath)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  cmdStdin, err := cmdPack.StdinPipe()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  cmdStdout, err := cmdPack.StdoutPipe()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  _ = cmdPack.Start()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; { _, _ = io.Copy(cmdStdin, s) }()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  _, _ = io.Copy(s, cmdStdout)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  _ = cmdPack.Wait()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;完整的实现见：https://gitee.com/kesin/go-git-protocols/tree/master/ssh-server&lt;/p&gt;&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;Git 传输协议还有很多进阶的用法由于篇幅的限制未介绍到，比如 Packfile 协商机制、Shallow mode、Protocol V2等等，基于这些机制我们可以发挥想象力，实现具有特定功能的 Git 服务来为某一场景的用户服务，更多的请研读官方文档，没有什么比官方文档更全面了。Git 是一个非常好的版本控制系统，相信未来它会有更广泛的应用，也会有更多的功能推出来适应飞速发展的研发效能体系。&lt;/section&gt;&lt;h3&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;本文在2020年底就计划要写，记得当时跟公司一个兄弟&lt;code&gt;五环&lt;/code&gt;在客户那里处理事情，忙完已经月残人稀，等车的途中聊到我要在元旦写篇 Git 传输协议的文章，来纪念这猝不及防的30岁，怎奈元旦到了最后一天才写了一半，紧接着就是铺天盖地的各项事务，把这篇文章忘的一干二净，好在及时在1月底的倒数第二个周末完成，也算是亡羊补牢了。&lt;/section&gt;&lt;section&gt;希望今后量力而行，做不到的不乱说，说出来的要做到，对于计划可能的偏离要有预备方案和追赶措施，人生果然如架构，亦如项目管理，连调优都如此雷同，也许为的就是能够承受更大的「压力」和「意外」吧。&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.33046875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrJ3rMw1ABEbfDpJiaicxNRUB0mdn1lp8zTia1JaicLrZS0uQrD0zkvcfJib91l0WGmxHwTIkD6yCL6hyFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;191&quot;/&gt;&lt;/p&gt;&lt;p&gt;转载请保留出处：&lt;/p&gt;&lt;p&gt;微信公众号「Zoker 随笔」（zokersay）&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8f9646e69c434071a1e118c15de502c0</guid>
<title>醒一醒，讲到 ZooKeeper 的选举机制了</title>
<link>https://toutiao.io/k/ft1r1q4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBjiaGXTfcIPriaxUMZb6jZP32vibu49ou0TicibZypAUuUt1K7nPea5fia3oQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.425531914893617&quot; data-w=&quot;940&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文作者：HelloGitHub-&lt;strong&gt;老荀&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hi，这里是 HelloGitHub 推出的 HelloZooKeeper 系列，&lt;strong&gt;免费开源、有趣、入门级的 ZooKeeper 教程&lt;/strong&gt;，面向有编程基础的新手。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;项目地址：https://github.com/HelloGitHub-Team/HelloZooKeeper&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天开始我们将继续深入 ZK 选举相关的知识&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRB06UXpO8zLrN3EDU1gY5wicAlofx1jZdcCrfHEM3v17myBic1tJibpu8oA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5885650224215246&quot; data-w=&quot;892&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、选举的基本规则&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZKr～这次我决定一反常态，先不讲故事了～先得聊聊在 ZK 选举中非常重要的一些东西。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 zxid&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;zxid 就是我们&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MzYyNzQ0MQ==&amp;amp;mid=2247499173&amp;amp;idx=1&amp;amp;sn=8d09888533c4a75d2915720c1242ee13&amp;amp;chksm=905848fba72fc1ed38659069914313885499d89bd3259fcc95ef0604c8bbc1851f2cc31e85f7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;之前&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;之前&lt;/a&gt;提到的事务编号，是一个 8 字节的整型数字，但是 ZK 设计的时候把这一个数字拆成了两部分使用，一鱼两吃！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;8 个字节的整数一共有 64 位长度，前 32 位用来记录 epoch，后 32 位就是用来计数。你可能要问了？epoch？是啥？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBT4B5ckWxBLpRwWZgibfzXtqYRgFpdFfNgKISIs2vkvdiaQhAMkVAJPYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.0623188405797102&quot; data-w=&quot;690&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;zxid 初始化是 0，也就是这样&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;00000000000000000000000000000000 00000000000000000000000000000000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一次写请求都会增加后 32 位，假设现在进行了 10 次写请求（无论该请求有没有真的修改到数据），zxid 就会变成这样&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;00000000000000000000000000000000 00000000000000000000000000001010&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当进行一次选举的时候，前 32 位就会增加 1，并且清零后 32 位&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;00000000000000000000000000000001 00000000000000000000000000000000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了选举以外，当后 32 位彻底用完（变成全 1，也就是 ZK 正常执行了 2^32 - 1 次写请求都没进行过一次选举，牛逼！）也会让前 32 位增加 1，相当于进位&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# 进位前&lt;/span&gt;&lt;br/&gt;00000000000000000000000000000000 11111111111111111111111111111111&lt;br/&gt;&lt;span&gt;# 进位后&lt;/span&gt;&lt;br/&gt;00000000000000000000000000000001 00000000000000000000000000000000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里我就可以回答大家前面的问题了，epoch 就是 zxid 前 32 位的这个数字，epoch 本身的翻译是“纪元，时代”的意思，意味着更新换代，而 zxid 的后 32 位数字仅仅是写请求的计数罢了&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 myid&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在之前的小故事里，我给 ZK 的集群中的各个节点都起了一个好记的名字（神特么好记！）。但是 ZK 官方自己是如何给每一个集群中的节点起名字的呢？用的就是 myid！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZK 的启动配置 &lt;code&gt;zoo.cfg&lt;/code&gt; 中有一项 &lt;code&gt;dataDir&lt;/code&gt; 指定了数据存放的路径（默认是 &lt;code&gt;/tmp/zookeeper&lt;/code&gt;)，在此路径下新建一个文本文件，命名为 &lt;code&gt;myid&lt;/code&gt;， 文本内容就是一个数字，这个数字就是当前节点的 myid&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;/tmp&lt;br/&gt;└── zookeeper&lt;br/&gt;    ├── myid&lt;br/&gt;    └── ...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在 &lt;code&gt;zoo.cfg&lt;/code&gt; 是这样配置集群信息&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;server.1=zoo1:2888:3888&lt;br/&gt;server.2=zoo2:2888:3888&lt;br/&gt;server.3=zoo3:2888:3888&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 &lt;code&gt;server.&lt;/code&gt; 之后的数字就是 myid，这个 myid 在整个集群中，各个节点之间是不能重复的。我忘记之前在哪儿看到的了，说是 myid 只能是 1 到 255 的数字，我一直信以为真，直到这次，我本着严谨的态度去做了实践，一切以事实为主，并且我的实验覆盖了 3.4、3.5、3.6 三大版本（都是三台机器的简单集群），结论是：myid 只要是不等于 -1 就行（-1 是一个固定的值会导致当前节点启动报错），不能大于 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 或者小于 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;，但是如果在当前的节点中配置了 &lt;code&gt;zookeeper.extendedTypesEnabled=true&lt;/code&gt; 那当前节点的最大 myid 是 254（负数不影响，我也不知道这个 254 的用意，但是代码中的确有判断） 是不是奇怪的知识又增加了呢～&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于配置更多的信息，之后单独再整理，今天就点到为止&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBmWobvpnHFRnicibuIwp4uDe0X0jPfcHHR2rcKMwxjgWf9QxGeVnTLK5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.141025641025641&quot; data-w=&quot;156&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3 选举规则&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道了上面这些有什么用呢？非常重要！因为选举 Leader 完全看的就是这几个值&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优先级从上到下逐级比较，谁大谁就更有资格成为 Leader，当前级一样就比较下一级，直到分出胜负为止！因为 myid 是不能重复的，所以最终是一定能分出胜负的！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，现在大家知道了最基本的选举规则了～让我们进入下一节吧&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、三马之争&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;马果果&lt;/strong&gt;一定想不到，这辈子自己可以和两位鼎鼎大名的明星企业家相提并论，让我们一起去看看发生了什么吧～&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 准备开工&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前&lt;strong&gt;马果果&lt;/strong&gt;规定了三个办事处在对外开张前必须选出一个 Leader，在正式开始选之前，每一个办事处也有一些准备工作需要做：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;每一个办事处必须得知道一共有多少个办事处&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;额外聘请一些专门负责和其他办事处沟通的话务员&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;准备好一个票箱用来对投票统计和归票&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为每一个办事处设置一个固定的 myid&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以现在办公室的布置变成了这样（我省略了之前章节的其他要素）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBwibejLVaFo8FpmGwGga6l6kT3LIibkicUWKcGHkicibAszWElefxKBoq1zQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6291469194312796&quot; data-w=&quot;844&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这些准备工作以后所有办事处都可以进入选举的阶段了，并且村委会规定了几种状态用于表示当前办事处正处在的阶段：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LOOKING，正在寻找 Leader，处于此阶段的办事处不能对外提供服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LEADING，当前办事处就是 Leader，可以对外提供服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;FOLLOWING，当前办事处正在跟随 Leader，可以对外提供服务&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显刚刚准备好的各个办事处现在都处于 LOOKING 状态，下面让我们正式进入选举流程吧&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 开始选举&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于各个办事处刚准备好，所以彼此之间还没有通过信，又加上大家都是姓马的，心里面都是想当老大的，所以每一个办事都会率先拟一张写着自己的选票发给其他办事处。主要有这些信息：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;sid：我是谁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;leader：我选谁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;state：我当前的状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;epoch：我当前的 epoch&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;zxid：我选择的 leader 的最大的事务编号&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以&lt;strong&gt;马果果&lt;/strong&gt;举例：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBAr9VvtBjeMwuyxRcll5R2C8u4nJduPNIZiaolUgN56NNV7T4BwIsWNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7513368983957219&quot; data-w=&quot;374&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;马小云&lt;/strong&gt;和&lt;strong&gt;马小腾&lt;/strong&gt;也一样，一开始都选了自己做 Leader 候选人，并且都把自己认为的候选人（当前场景下就是自己）的票分别发送给了其他两位（以及自己）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBEqXS6jBkstmyoa1pbkGic0c2zcq5AQjXt1GicekhuzSJ1By0cy9gZRicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6572700296735905&quot; data-w=&quot;674&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.1 马果果视角&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个办事处各自也会收到来自其他办事处的选票（也有可能是自己的），每拿到一张选票，都需要和当前自己认为的 Leader 候选人做比较，理论上自己投给自己的选票会先一步达到自己的票箱，因为不需要经过通讯减少了传输的路径，自己的选票和自己的候选人是一致的所以不需要比较，只需要在票箱中记上一笔，我们还是以&lt;strong&gt;马果果&lt;/strong&gt;举例：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBbx5LKkddhb1KVWvGpQ0kWy1HjIJHg352IOQ9icvTapibria730YIFFd1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.1829787234042553&quot; data-w=&quot;470&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;=》&lt;/code&gt;的左边是办事处的名字，右边是该办事处选的 Leader。当前投票统计是指，当前节点所选的 Leader 获得的选票统计。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设他再收到了&lt;strong&gt;马小云&lt;/strong&gt;的选票：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;马果果&lt;/strong&gt;首先看到的是&lt;strong&gt;马小云&lt;/strong&gt;也处在 LOOKING 状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接着就会比较自己候选人和&lt;strong&gt;马小云&lt;/strong&gt;的选票（左边代表当前办事处的候选人，右边代表收到的选票信息，下同）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;e:0      ==  e:0&lt;br/&gt;z:0      ==  z:0&lt;br/&gt;l: 马果果(69) &amp;gt;   l: 马小云(56)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终因为&lt;strong&gt;马果果&lt;/strong&gt;的 myid 69 要比&lt;strong&gt;马小云&lt;/strong&gt;的 myid 56 要大，所以&lt;strong&gt;马果果&lt;/strong&gt;最终胜出！虽然&lt;strong&gt;马小云&lt;/strong&gt;胜出了，但是当前投票统计是不能修改的，因为&lt;strong&gt;马小云&lt;/strong&gt;这一轮的选票就是选的&lt;strong&gt;马小云&lt;/strong&gt;，需要等待他重新改票后再投才能修改投票统计。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后会往投票箱记录：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBt45jKInnsQ1u2XTyNymQF7uyRiciblv5Zlpn8ic2iaPMDx3g1pkZOlD23g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.2273730684326711&quot; data-w=&quot;453&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;紧接着是&lt;strong&gt;马小腾&lt;/strong&gt;的投票：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;e:0      ==  e:0&lt;br/&gt;z:0      ==  z:0&lt;br/&gt;l: 马果果(69) &amp;gt;   l: 马小腾(49)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;马果果&lt;/strong&gt;还是胜出！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记录投票箱：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBOkiamv6bTHUbbAVZmd152BSg8wiaUoQ9B3yoZSngpQGdjwXzic8MC3exQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.2108695652173913&quot; data-w=&quot;460&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次收到投票的时候，&lt;strong&gt;马果果&lt;/strong&gt;都会依据当前的投票统计进行归票，但是很遗憾选举仍然无法结束，因为结束的规则必须有某一个办事处获得半数以上的选票，现在只有一个&lt;strong&gt;马果果&lt;/strong&gt;自己的选票，不满足半数以上，所以马果果只能再等等了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在&lt;strong&gt;马果果&lt;/strong&gt;这边忙的热火朝天的同时，&lt;strong&gt;马小云&lt;/strong&gt;和&lt;strong&gt;马小腾&lt;/strong&gt;也在进行着同样的动作。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.2 马小云视角&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们这省略描述&lt;strong&gt;马小云&lt;/strong&gt;记录自己选票的过程，假设他这边是先收到&lt;strong&gt;马果果&lt;/strong&gt;的选票，是怎么处理的呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;e:0      ==  e:0&lt;br/&gt;z:0      ==  z:0&lt;br/&gt;l: 马小云(56) &amp;lt;   l: 马果果(69)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;马小云&lt;/strong&gt;看到自己认为的 Leader 候选人被&lt;strong&gt;马果果&lt;/strong&gt;的选票击败了，所以将自己的候选人改为&lt;strong&gt;马果果&lt;/strong&gt;，并将新的选票重新广播出去&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBzibXDrF8fnWibaDwA8WyozRHEAvmSdTLyfebK9ibvII98bdm8Ln0V8spw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.511744966442953&quot; data-w=&quot;596&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在自己的投票箱中记录：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBu8lht826PU4vVicD0TBQ5hiaeK4yOAbbxLaiaF8EDISWOEFgT0IaH5R9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.193058568329718&quot; data-w=&quot;461&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了叙述的完整性，我们还是把&lt;strong&gt;马小腾&lt;/strong&gt;的票也看完&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;e:0      ==  e:0&lt;br/&gt;z:0      ==  z:0&lt;br/&gt;l: 马果果(69) &amp;gt;   l: 马小腾(49)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;马果果&lt;/strong&gt;还是胜出了，所以&lt;strong&gt;马小云&lt;/strong&gt;的投票箱最终变成这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBCEuYSAqzdmkbl7ZGLKxe5SiasvOvOa7EAoUAFxDoIBicvKPshmrUWKiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.2077922077922079&quot; data-w=&quot;462&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;讲道理接下来应该以&lt;strong&gt;马小腾&lt;/strong&gt;为主视角，再讲一遍刚才的过程，但是可以认为几乎和&lt;strong&gt;马小云&lt;/strong&gt;是一样的，为了故事的顺畅，我们需要回到&lt;strong&gt;马果果&lt;/strong&gt;的视角，因为&lt;strong&gt;马小云&lt;/strong&gt;输给&lt;strong&gt;马果果&lt;/strong&gt;之后改票了，又发了一轮选票&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.3 马果果视角（再）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;马果果&lt;/strong&gt;又再一次收到了&lt;strong&gt;马小云&lt;/strong&gt;的选票（改票后），投票箱就会改成这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBraDmicdFhuZHWiazS4LU50yEgbB18Roiazjzzhicb0YxEZ5KFaO12x2sicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.2350332594235034&quot; data-w=&quot;902&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;收到这个投票后，当前投票统计就会增加&lt;strong&gt;马小云&lt;/strong&gt;的记录，然后&lt;strong&gt;马果果&lt;/strong&gt;进行归票就发现了这次自己的选票超过半数了，然后会进行二次确认，会等待一会看看还能不能收到更新的选票，这里假设没有收到更新的投票，就会进行判断，当前过半数的候选人是不是自己？如果是的话，那自己就是 Leader，不是的话，自己就是 Follower。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显，&lt;strong&gt;马果果&lt;/strong&gt;就是 Leader，然后会把自己的状态修改为 LEADING。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与此同时，&lt;strong&gt;马小云&lt;/strong&gt;、&lt;strong&gt;马小腾&lt;/strong&gt;也进行归票，归票结果自己为 Follower，把自己状态修改为 FOLLOWING，然后各自都会和 Leader 进行数据的同步，同步完成之后整个办事处就都可以对外提供服务了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBpC4ZYAmutNc2rCsXiaxOib0rlHZFyhwAVLmiblITH2ZiaLzIglgFPliaBKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6472222222222223&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 马小腾停电啦&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选举本身涉及到集群间的通信、节点自身的状态管理和状态变更，本身就是一个比较复杂的过程，刚才只是举例了一个最简单的启动选举流程，下面会举更多的例子帮助大家能理解整个选举的逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在假设办事处安然无恙得对外提供了一段时间服务后，&lt;strong&gt;马小腾&lt;/strong&gt;的办事处突然停电了，就不能和另外两马进行通讯了，而另外两马在一段时间内都没有收到过&lt;strong&gt;马小腾&lt;/strong&gt;的信息的时候就知道，出事了！但是各自盘点了下目前仍然还有两个办事处可以对外提供服务，是达到整个集群总数的半数以上的，是可以继续让村民们来办理业务的，所以现在整个集群变成了这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBlCYsatibODUwBu3VVu9ZpOV5HKLFrxiaLsefnB6ibOvh2YMRo8np5h9MA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7166666666666667&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没过一会，因为电力公司的积极抢修，&lt;strong&gt;马小腾&lt;/strong&gt;的办事处恢复供电了，重新开张了，但是每一个办事处在开张前都是处在 LOOKING 状态的，还是会优先投票给自己，并会通过复盘本地的存档来得到自己办事处最新的数据，假设&lt;strong&gt;马小腾&lt;/strong&gt;停电前是这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;e:0     &lt;br/&gt;z:21      &lt;br/&gt;l: 马小腾(49)&lt;br/&gt;LOOKING&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他和之前一样会给另外两个办事处发自己的选票&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBLbze9kWR4ouRq6njiao0EEUqzVueeqRqgQJ1mFXqPJNQaSLIDDGlxYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6472222222222223&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但和之前的情况不同，无论是&lt;strong&gt;马果果&lt;/strong&gt;还是&lt;strong&gt;马小云&lt;/strong&gt;他们现在都处在工作的状态，收到了&lt;strong&gt;马小腾&lt;/strong&gt;的选票后就会把当前的 Leader 也就是&lt;strong&gt;马果果&lt;/strong&gt;的选票信息以及自己当前的状态发送给他。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;马果果&lt;/strong&gt;发送的选票信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;e:0     &lt;br/&gt;z:30      &lt;br/&gt;l: 马果果(69)&lt;br/&gt;LEADING&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;马小云&lt;/strong&gt;发送的选票信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;e:0     &lt;br/&gt;z:30      &lt;br/&gt;l: 马果果(69)&lt;br/&gt;FOLLOWING&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;马小腾&lt;/strong&gt;收到两位的选票信息后，知道了当前的 Leader 是&lt;strong&gt;马果果&lt;/strong&gt;，并且&lt;strong&gt;马果果&lt;/strong&gt;本人也确认了是 LEADING 状态，就马上把自己的状态修改为了 FOLLOWING 状态，并且会和之前一样与 Leader 进行数据的同步，关于具体怎么同步的，我打算留到之后再进行讲解～&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步之后，&lt;strong&gt;马小腾&lt;/strong&gt;的状态变成了和&lt;strong&gt;马小云&lt;/strong&gt;一样的了。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我再假设这里有一个平行世界，回到&lt;strong&gt;马小腾&lt;/strong&gt;刚恢复完供电准备开张上线的时候，此时的&lt;strong&gt;马小腾&lt;/strong&gt;的状态假设是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;e:1     &lt;br/&gt;z:7      &lt;br/&gt;l: 马小腾(49)&lt;br/&gt;LOOKING&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哪怕 epoch 比目前的 Leader 还要大，其实照道理是更有资格当 Leader，但是由于当前集群中的其他办事处已经有了一个明确的 Leader，&lt;strong&gt;马小腾&lt;/strong&gt;也只能忍辱负重（谁让你停电了呢）还是以 Follower 的身份加入到集群中来，并且仍然以当前 Leader 的信息来同步，你也可以理解为降级（把自己的 epoch 降级回 0 ）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;职场就是这么残忍，你稍微请个长假再回来可能已经是物是人非了～&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xBgIbW1vdNMNODI3zmERvmnRrthyMYRB7Xo8yk4MeL0ic4VOyYgrQrMW7ySK4F32qnh0A9HPm2q90xd2o0NhGRw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-ratio=&quot;1&quot; data-w=&quot;145&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 马果果又病啦&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;马果果&lt;/strong&gt;毕竟年事已高，又又又生病了，办事处只能含泪关门，但是和上一次&lt;strong&gt;马小腾&lt;/strong&gt;停电不同，这次是作为 Leader 的&lt;strong&gt;马果果&lt;/strong&gt;停止服务了，因为之前定下的规定，整个办事处集群必须得有一个 Leader。现在&lt;strong&gt;马小云&lt;/strong&gt;和&lt;strong&gt;马小腾&lt;/strong&gt;发现 Leader 联系不上了，说明 Leader 无法服务了，他们就知道必须选出一个新的 Leader。于是纷纷将自己的状态都修改为 LOOKING 状态，并且再次把候选人选为自己，重新向其他仍然可以提供服务的办事处广播自己的选票（当前这个场景就是互相发选票了）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRB4aYZWZQPtd2VH87Cmsg5ypSmr8uKO8HbfwzytEmVFO3gLesicDk0wHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.4718934911242604&quot; data-w=&quot;676&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论谁收到选票后经过比较后都会知道是&lt;strong&gt;马小腾&lt;/strong&gt;胜出&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;e:1      ==  e:1&lt;br/&gt;z:77      &amp;lt;   z:80&lt;br/&gt;l: 马小云(56)     l: 马小腾(49)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;马小云&lt;/strong&gt;会把自己的候选人修改为&lt;strong&gt;马小腾&lt;/strong&gt;之后重新再把自己的选票发出去，现在&lt;strong&gt;马小腾&lt;/strong&gt;就获得了 2 票通过，同时也满足大于整个办事处集群半数以上，所以&lt;strong&gt;马小腾&lt;/strong&gt;和&lt;strong&gt;马小云&lt;/strong&gt;各自修改状态为 LEADING 和 FOLLOWING 后，并且会和之前说的一样，把 epoch 加 1 同时清空计数部分，最后重新恢复对村民提供服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而&lt;strong&gt;马果果&lt;/strong&gt;这边病好以后，会重新开张和之前的例子一样也是先从 LOOKING 状态开始，最后会从其他两马那里得知目前的 Leader 是&lt;strong&gt;马小腾&lt;/strong&gt;之后，就会主动和&lt;strong&gt;马小腾&lt;/strong&gt;同步数据并以 Follower 的身份加入到办事处集群中对外提供服务。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 招商引资&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;办事处的热火朝天被村委会看在了眼里，心想只有三个办事处就能达到这样的效果，如果有更多的办事处呢？于是和三马商量了下，决定对外招商引入社会资本，让他们自己按照现有模式建立新的办事处，这样村委会不用出一分钱，村民还能获得实在的好处，秒啊！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRB7Gvkb6ibwdgkbyaFibg0aibNttNgYMYvP9ZUPHycA9ZbqZI5D3T9mscWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此举一度引来社会资本的大量关注，但是商量过后，三马又觉得如果过多的引入外部力量势必会削弱自己手中的权力，所以又出了一个规定，三马自封为 Participant 只有他们三个才有资格进行 Leader 的竞选，而引入的社会资本所创建的办事处只能作为 Observer 加入办事处的集群中对外提供只读服务，没有资格竞争 Leader，这样就可以在不增加选举复杂程度的同时，提升整个办事处集群对读请求的吞吐量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要声明当前节点是 Observer，需要在 &lt;code&gt;zoo.cfg&lt;/code&gt; 中先配置 &lt;code&gt;peerType=observer&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时声明的集群信息最后要多加一个 &lt;code&gt;:observer&lt;/code&gt; 用来标识，这样其他节点也会知道当前 myid 为 1 和 2 都是 Observer&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;server.69=maguoguo:2888:3888&lt;br/&gt;server.56=maxiaoyun:2888:3888&lt;br/&gt;server.49=maxiaoteng:2888:3888&lt;br/&gt;server.1=dongdong:2888:3888:observer&lt;br/&gt;server.2=jitaimei:2888:3888:observer&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在 LOOKING 状态的 Observer 一开始的 Leader 候选人也会选自己，但是选票信息被设置成了这样，以&lt;strong&gt;东东&lt;/strong&gt;举例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;e:Long.MIN_VALUE     &lt;br/&gt;z:Long.MIN_VALUE      &lt;br/&gt;l: 东东(1)&lt;br/&gt;LOOKING&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 epoch 被设置成了最小值所以这个选票等同于形同虚设，可以被直接忽略，并且在三马那里会维护一个 Participant 的列表，如果他们收到了来自 Participant 以外的办事处的选票会直接选择忽略，所以可以说 Observer 的选票对选举结果是完全没有影响的。最终是等待 Participant 之间的选举结果通知，Observer 自身修改状态为 OBSERVING，开始和 Leader 进行同步数据，这点和 Follower 没区别，之后 Observer 和 Follower 会统称为 Learner&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.6 小结&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;竞选 Leader 看的是 epoch、写请求操作数、myid 三个字段，依次比较谁大谁就更有资格成为 Leader&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获选超过半数以上的办事处正式成为 Leader，修改自己状态为 LEADING&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其他 Participant 修改为 FOLLOWING，Observer 则修改为 OBSERVING&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果集群中已经存在一个 Leader，其他办事处如果中途加入的话，直接跟随该 Leader 即可&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;还得提一句，如果当前可提供服务的节点已经不足半数以上了，那么这个选举就永远无法选出结果，每个节点都会一直处在 LOOKING 状态，整个办事处集群也就无法对外提供服务了&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、猿话一下&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扯蛋扯完了，现在用咱的行话对有一些概念再深入一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我必须要说的是，故事里的三马，为了一定的节目效果，我描述成了三个角色，但是实际中 ZK 服务端是不会做这样的区分的，都是相同的代码，根据不同的配置启动，才有了运行时期 Leader、Follower、Observer 的角色之分，所以更贴近于实际的应该类似于火影里的影分身或者龙珠里的残像拳之类的（好像混入了什么奇怪的东西）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRB8ibiaDmRc8oQ8MCY8Df3xeUGYL4Z8VcGCJzqB9xwjpicLZ9cW17cdy10w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6574074074074074&quot; data-w=&quot;540&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我画了下选举的简单流程图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRB06UXpO8zLrN3EDU1gY5wicAlofx1jZdcCrfHEM3v17myBic1tJibpu8oA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5885650224215246&quot; data-w=&quot;892&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他地方我基本上都讲过了，这里再讲下红色部分，因为可能一些网络因素，发出去的选票对方却没收到，这个发起重新广播投票就是为了能让对方再重新发一次刚刚的选票。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同监听客户端 2181 端口不同的是，服务端集群之间相互通信，直接使用的是原生的 Socket 并没有使用 NIO 或者是 Netty，因为服务端节点一共就这么几个而且针对每一个其他节点都会启动一个线程去监听，所以直接采用了这种比较原始的并且是阻塞的方式通信，更简单直接，而且假设对方服务不可用了的话， Socket 会直接报错退出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;收发选票也是采用了 ZK 中非常常见的生产者-消费者模式，分别维护了两个阻塞队列，一个对应发送出去的选票，一个对应收到的选票，各自使用一个子线程去轮询该阻塞队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前的 ZK 是拥有 3 种选举策略的，虽然另外两种之前都是被废弃的状态，不建议使用，但是通过配置文件还是可以强行使用的。不过在最新的 3.6.2 中另两种策略直接从源码中删除了，现在只有一种选举的策略，源码中对应 &lt;code&gt;FastLeaderElection&lt;/code&gt;，另外两个我也没研究过，就不展开了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于服务端之间的心跳检测：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;服务端之间的心跳检测（PING）是由 Leader 发起的，发向所有集群中的其他节点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Follower 收到 PING 后会回一个PING 给 Leader 并带上自己这边的客户端会话数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;而 Leader 收到 Follower 的 PING 后，就会对这些客户端进行会话连接&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于会话相关的知识点留到之后再说～&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们介绍了选举的规则，以及举例了一些选举的场景并加以说明。为了介绍 Follower 或者 Observer 是如何在选举完成之后和 Leader 同步数据的，下一篇我们会先介绍 ZK 是如何进行持久化的，期待一下吧，ZKr～&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMNODI3zmERvmnRrthyMYRBSaBicibF5pNSiaaf1KccGLsV264b3s9FiaJ9ofGcicDwFj1N7WmAaPap4JA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1&quot; data-w=&quot;450&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老规矩，如果你有任何对文章中的疑问也可以是建议或者是对 ZK 原理部分的疑问，欢迎来仓库中提问，或者&lt;strong&gt;&lt;span&gt;阅读原文&lt;/span&gt;&lt;/strong&gt;来语雀话题讨论。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;地址：&lt;span&gt;https://github.com/HelloGitHub-Team/HelloZooKeeper&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>