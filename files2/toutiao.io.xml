<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2e7e7a0d275e218af45c1639ca3a38d5</guid>
<title>华为 18 级工程师总结的 50W 字算法、LeetCode、操作系统、计算机底层刷题必备笔记</title>
<link>https://toutiao.io/k/u76was8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;article_content&quot; class=&quot;article_content clearfix&quot;&gt;
        
                &lt;div id=&quot;content_views&quot; class=&quot;htmledit_views&quot;&gt;
                    &lt;p&gt;最近又有不少老铁在后台留言说，想进大厂，但是算法不好。最近我整理了一份刷题实录，这份刷题实录，也让我进了心仪的大厂。现在开放分享给大家。希望对大家有所帮助。&lt;/p&gt; 
&lt;p&gt;任何的算法题，如同写作文一样，都有一些模板可以套用的。比如面试常考的DP（动态规划），难的是一些关键点是否能想清楚。比如你能写出动态转移方程，这题基本上就可以AC了。&lt;/p&gt; 
&lt;p&gt;整个刷题实录内容，包括 &lt;strong&gt;双子针、动态规划、二分查找、贪心算法、深度优先搜索、字符串、递归、字典树、排序、链表&lt;/strong&gt;等相关专题内容。图文并茂，附有刷题答案源码。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/4d5b4e16b7b88392a8f4203566034e97.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;刷题任务的题目，是根据题目的类型来汇总的，总结了八个类别，每个类别下面也总结了5个左右的题型，帮助大家分门别类的突破，所以刷起来相对会更有重点和针对性。如果从头到尾的刷，每周按顺序刷42题，很容易让自己坚持不下来，也会觉得很枯燥。所以在制定计划的时候可以让这个计划变得更“有趣&quot;和针对性，让它看起来更容易实现一点，才会更容易坚持。&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://docs.qq.com/doc/DTVZkZ3ZmeUt4Tk5n&quot;&gt;点击鸡可免费获取&lt;/a&gt;LeetCode刷题笔记、6000页Java教程、操作系统、计算机底层教程笔记&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/554976ea852cfba29fcdfc987974e2b6.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/c1cd9362e965cd112465ed3fd2cc8a5d.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/b8316656d9a071b49b02fec862aff81e.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;除此之外，我还写了一套 6000 页的 Java 学习手册，以及珍藏四本 Java 人必读4大神器&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;整个资料包内容专注 Java技术，包括 Spring、Spring Boot/Cloud、Dubbo、JVM、集合、多线程、JPA、MyBatis、MySQL、大数据、Nginx、Git、Docker、GitHub、Servlet、JavaWeb、IDEA、Redis、算法、面试题等相关内容。图文并茂，附有源码，还送一波电子书。内容包括但不限于：&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt;JavaWeb 相关（带答案）&lt;/li&gt;&lt;li&gt;精选面试题（带答案）&lt;/li&gt;&lt;li&gt;Spring 全家桶（带答案）&lt;/li&gt;&lt;li&gt;Linux 相关（带答案）&lt;/li&gt;&lt;li&gt;Spring Boot 教程和实战&lt;/li&gt;&lt;li&gt;MyBatis 框架（带答案）&lt;/li&gt;&lt;li&gt;MySQL（带答案）&lt;/li&gt;&lt;li&gt;Nginx（带答案）&lt;/li&gt;&lt;li&gt;Git（带答案）&lt;/li&gt;&lt;li&gt;GitHub（带答案）&lt;/li&gt;&lt;li&gt;IDEA 教程 &amp;amp; 实战（带答案）&lt;/li&gt;&lt;li&gt;Java基础：多线程，集合，JVM等（带答案）&lt;/li&gt;&lt;li&gt;DeBug 技巧（带答案）&lt;/li&gt;&lt;li&gt;Dubbo（带答案）&lt;/li&gt;&lt;li&gt;Redis（带答案）&lt;/li&gt;&lt;li&gt;. . .&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;每篇文章图文并茂，附有源码。还有电子书合集&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://docs.qq.com/doc/DTVZkZ3ZmeUt4Tk5n&quot;&gt;点击鸡可免费获取&lt;/a&gt;LeetCode刷题笔记、6000页Java教程、操作系统、计算机底层教程笔记&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d18dbd489dda93c92e8d8c79cd175bc8.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;最后一份资料是计算机的相关知识&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;看完能让你对计算机有一个基础的了解和入门，是培养你 内核 的基础，我们看下目录大纲&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/bae094059e837ffb34dce0f011e20012.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;基本上涵盖了计算机所有基础知识，从 CPU 到内存、讲解什么是二进制、磁盘、压缩算法、操作系统、汇编等知识。&lt;/p&gt; 
&lt;p&gt;我们来看下内容是怎样的&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/622591054cebd6d4eaf0560fefae49c2.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;这个图画的很漂亮啊，看起来就是作者在用心画的，而且排版非常精美。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/2f225d06f308e31f53d6c18cbb75b9e2.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;看起来一点不枯燥&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/e575d326fa9facb4ad891b0974f2854c.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/065707a3c53f7a74aad1e9e6df467972.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://docs.qq.com/doc/DTVZkZ3ZmeUt4Tk5n&quot;&gt;点击鸡可免费获取&lt;/a&gt;LeetCode刷题笔记、6000页Java教程、操作系统、计算机底层教程笔记 &lt;/p&gt; 
&lt;p&gt;关注我添加助理VX：MXW5308 即可免费获取LeetCode刷题笔记、6000页Java教程、操作系统、计算机底层教程笔记 &lt;/p&gt;
                &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7ba2146373f79b26545e3b8c9f386d04</guid>
<title>全网最全 Log 配置教程及框架性能比较，看这篇就够了</title>
<link>https://toutiao.io/k/d1m5297</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;一、摘要&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管是使用何种编程语言，何种框架，日志输出几乎无处不再，也是任何商业软件中必不可少的一部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结起来，日志的用途大致可以归纳成以下三种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;问题追踪&lt;/strong&gt;：通过日志不仅仅包括我们程序的一些bug，也可以在安装配置时，通过日志可以发现问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;状态监控&lt;/strong&gt;：通过实时分析日志，可以监控系统的运行状态，做到早发现问题、早处理问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;安全审计&lt;/strong&gt;：审计主要体现在安全上，通过对日志进行分析，可以发现是否存在非授权的操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以 Java 编程语言为例，打印日志的方式有很多，例如通过&lt;code&gt;System.out.print()&lt;/code&gt;方法将关键信息输出到控制台，也可以通过 JDK 自带的日志&lt;code&gt;Logger&lt;/code&gt;类输出，虽然 JDK 从1.4开始支持日志输出，但是功能单一，无法更好的满足商业要求，于是诞生了很多第三方日志库，像我们所熟悉的主流框架&lt;code&gt;log4j&lt;/code&gt;、&lt;code&gt;log4j2&lt;/code&gt;、&lt;code&gt;logback&lt;/code&gt;等，提供的 API 功能都远胜 JDK 提供的&lt;code&gt;Logger&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;二、Log4j&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1、介绍&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Log4j 是一种非常流行的日志框架，由&lt;code&gt;Ceki Gülcü&lt;/code&gt;首创，之后将其开源贡献给 Apache 软件基金会。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Log4j 有三个主要的组件：&lt;code&gt;Loggers&lt;/code&gt;(记录器)，&lt;code&gt;Appenders&lt;/code&gt; (输出源)和&lt;code&gt;Layouts&lt;/code&gt;(布局)。这里可简单理解为&lt;strong&gt;日志类别&lt;/strong&gt;、&lt;strong&gt;日志要输出的地方&lt;/strong&gt;和&lt;strong&gt;日志以何种形式输出&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综合使用这三个组件可以轻松地记录信息的类型和级别，并可以在运行时控制日志输出的样式和位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Log4j 的架构大致如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.35379061371841153&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/laEmibHFxFw4AzzT8jZibLlgwC0zwdoX4afMA3jjukl0ypPKHjKYRUricAgia4ajRZmARsXgA4LicczAh6maqIL02Cg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1108&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们使用 Log4j 输出一条日志时，Log4j 自动通过不同的&lt;code&gt;Appender&lt;/code&gt;（输出源）把同一条日志输出到不同的目的地。例如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;console&lt;/strong&gt;：输出到屏幕；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;file&lt;/strong&gt;：输出到文件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;socket&lt;/strong&gt;：通过网络输出到远程计算机；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;jdbc&lt;/strong&gt;：输出到数据库&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在输出日志的过程中，通过&lt;code&gt;Filter&lt;/code&gt;来过滤哪些&lt;code&gt;log&lt;/code&gt;需要被输出，哪些&lt;code&gt;log&lt;/code&gt;不需要被输出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Loggers&lt;/code&gt;(记录器)组件中，级别分五种：&lt;code&gt;DEBUG&lt;/code&gt;、&lt;code&gt;INFO&lt;/code&gt;、&lt;code&gt;WARN&lt;/code&gt;、&lt;code&gt;ERROR&lt;/code&gt;和&lt;code&gt;FATAL&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这五个级别是有顺序的，&lt;code&gt;DEBUG&lt;/code&gt; &amp;lt; &lt;code&gt;INFO&lt;/code&gt; &amp;lt; &lt;code&gt;WARN&lt;/code&gt; &amp;lt; &lt;code&gt;ERROR&lt;/code&gt; &amp;lt; &lt;code&gt;FATAL&lt;/code&gt;，分别用来指定这条日志信息的重要程度，明白这一点很重要，&lt;code&gt;Log4j&lt;/code&gt;有一个规则：&lt;strong&gt;只输出级别不低于设定级别的日志信息&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设&lt;code&gt;Loggers&lt;/code&gt;级别设定为&lt;code&gt;INFO&lt;/code&gt;，则&lt;code&gt;INFO&lt;/code&gt;、&lt;code&gt;WARN&lt;/code&gt;、&lt;code&gt;ERROR&lt;/code&gt;和&lt;code&gt;FATAL&lt;/code&gt;级别的日志信息都会输出，而级别比&lt;code&gt;INFO&lt;/code&gt;低的&lt;code&gt;DEBUG&lt;/code&gt;则不会输出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，通过&lt;code&gt;Layout&lt;/code&gt;来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体输出样式配置，可以参考如下内容Log4j2 - Layouts布局介绍&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2、项目应用&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以 Java 项目为例，在 Maven 的&lt;code&gt;pom.xml&lt;/code&gt;中添加如下依赖！&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.1、添加 maven 依赖&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;&lt;br/&gt;    &amp;lt;dependency&amp;gt;&lt;br/&gt;        &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;&lt;br/&gt;        &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;&lt;br/&gt;        &amp;lt;version&amp;gt;1.6.6&amp;lt;/version&amp;gt;&lt;br/&gt;    &amp;lt;/dependency&amp;gt;&lt;br/&gt;    &amp;lt;dependency&amp;gt;&lt;br/&gt;        &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;&lt;br/&gt;        &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;&lt;br/&gt;        &amp;lt;version&amp;gt;1.6.6&amp;lt;/version&amp;gt;&lt;br/&gt;    &amp;lt;/dependency&amp;gt;&lt;br/&gt;    &amp;lt;dependency&amp;gt;&lt;br/&gt;        &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;&lt;br/&gt;        &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;&lt;br/&gt;        &amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt;&lt;br/&gt;    &amp;lt;/dependency&amp;gt;&lt;br/&gt;&amp;lt;/dependencies&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.2、创建log4j配置&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际应用中，要使&lt;code&gt;Log4j&lt;/code&gt;在系统中运行须事先设定配置文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置文件实际上也就是对&lt;code&gt;Logger&lt;/code&gt;、&lt;code&gt;Appender&lt;/code&gt;及&lt;code&gt;Layout&lt;/code&gt;进行相应设定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Log4j&lt;/code&gt;支持两种配置文件格式，一种是&lt;code&gt;XML&lt;/code&gt;格式的文件，一种是&lt;code&gt;properties&lt;/code&gt;属性文件，二选一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个log4j.xml或者log4j.properties，将其放入项目根目录下。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1、XML格式&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;?xml version=&lt;span&gt;&quot;1.0&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;?&amp;gt;&lt;br/&gt;&amp;lt;!DOCTYPE log4j:configuration PUBLIC &lt;span&gt;&quot;-//APACHE//DTD LOG4J 1.2//EN&quot;&lt;/span&gt; &lt;span&gt;&quot;log4j.dtd&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;&amp;lt;log4j:configuration xmlns:log4j=&lt;span&gt;&quot;http://jakarta.apache.org/log4j/&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;!-- 控制台输出配置 --&amp;gt;&lt;br/&gt;    &amp;lt;appender name=&lt;span&gt;&quot;console&quot;&lt;/span&gt; class=&lt;span&gt;&quot;org.apache.log4j.ConsoleAppender&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;        &amp;lt;!-- 目标为控制台 --&amp;gt;&lt;br/&gt;        &amp;lt;param name=&lt;span&gt;&quot;Target&quot;&lt;/span&gt; value=&lt;span&gt;&quot;System.out&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;        &amp;lt;layout class=&lt;span&gt;&quot;org.apache.log4j.PatternLayout&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;            &amp;lt;!-- 输出格式 --&amp;gt;&lt;br/&gt;            &amp;lt;param name=&lt;span&gt;&quot;ConversionPattern&quot;&lt;/span&gt; value=&lt;span&gt;&quot;%d{yyyy-MM-dd HH:mm:ss} [%t] %-5p %l %m%n&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;        &amp;lt;/layout&amp;gt;&lt;br/&gt;    &amp;lt;/appender&amp;gt;&lt;br/&gt;    &amp;lt;!-- 文件输出配置 --&amp;gt;&lt;br/&gt;    &amp;lt;appender name=&lt;span&gt;&quot;log_file&quot;&lt;/span&gt; class=&lt;span&gt;&quot;org.apache.log4j.DailyRollingFileAppender&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;        &amp;lt;!-- 目标为文件 --&amp;gt;&lt;br/&gt;        &amp;lt;param name=&lt;span&gt;&quot;File&quot;&lt;/span&gt; value=&lt;span&gt;&quot;/logs/log/file.log&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;        &amp;lt;!-- 向文件追加输出 --&amp;gt;&lt;br/&gt;        &amp;lt;param name=&lt;span&gt;&quot;Append&quot;&lt;/span&gt; value=&lt;span&gt;&quot;true&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;        &amp;lt;!-- 每个小时生成一个&lt;span&gt;log&lt;/span&gt; --&amp;gt;&lt;br/&gt;        &amp;lt;param name=&lt;span&gt;&quot;DatePattern&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&#x27;.&#x27;yyyy-MM-dd-HH&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;        &amp;lt;layout class=&lt;span&gt;&quot;org.apache.log4j.PatternLayout&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;            &amp;lt;!-- 输出格式 --&amp;gt;&lt;br/&gt;            &amp;lt;param name=&lt;span&gt;&quot;ConversionPattern&quot;&lt;/span&gt; value=&lt;span&gt;&quot;%d{yyyy-MM-dd HH:mm:ss} [%t] %-5p %l %m%n&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;        &amp;lt;/layout&amp;gt;&lt;br/&gt;    &amp;lt;/appender&amp;gt;&lt;br/&gt;    &amp;lt;!-- Application Loggers --&amp;gt;&lt;br/&gt;    &amp;lt;logger name=&lt;span&gt;&quot;org.example&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;        &amp;lt;level value=&lt;span&gt;&quot;info&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;    &amp;lt;/logger&amp;gt;&lt;br/&gt;    &amp;lt;!-- 根目录 --&amp;gt;&lt;br/&gt;    &amp;lt;!-- Root Logger --&amp;gt;&lt;br/&gt;    &amp;lt;root&amp;gt;&lt;br/&gt;        &amp;lt;priority value=&lt;span&gt;&quot;info&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;        &amp;lt;appender-ref ref=&lt;span&gt;&quot;console&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;        &amp;lt;appender-ref ref=&lt;span&gt;&quot;log_file&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;    &amp;lt;/root&amp;gt;&lt;br/&gt;&amp;lt;/log4j:configuration&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、XML格式&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;log4j.rootLogger=INFO,M,C,E&lt;br/&gt;log4j.additivity.monitorLogger=&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# INFO级别文件输出配置&lt;/span&gt;&lt;br/&gt;log4j.appender.M=org.apache.log4j.DailyRollingFileAppender&lt;br/&gt;log4j.appender.M.File=/logs/info.log&lt;br/&gt;log4j.appender.M.ImmediateFlush=&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;log4j.appender.M.BufferedIO=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;log4j.appender.M.BufferSize=16384&lt;br/&gt;log4j.appender.M.Append=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;log4j.appender.M.Threshold=INFO&lt;br/&gt;log4j.appender.M.DatePattern=&lt;span&gt;&#x27;.&#x27;&lt;/span&gt;yyyy-MM-dd&lt;br/&gt;log4j.appender.M.layout=org.apache.log4j.PatternLayout&lt;br/&gt;log4j.appender.M.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss} %p %l %m %n&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# ERROR级别文件输出配置&lt;/span&gt;&lt;br/&gt;log4j.appender.E=org.apache.log4j.DailyRollingFileAppender&lt;br/&gt;log4j.appender.E.File=/logs/error.log&lt;br/&gt;log4j.appender.E.ImmediateFlush=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;log4j.appender.E.Append=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;log4j.appender.E.Threshold=ERROR&lt;br/&gt;log4j.appender.E.DatePattern=&lt;span&gt;&#x27;.&#x27;&lt;/span&gt;yyyy-MM-dd&lt;br/&gt;log4j.appender.E.layout=org.apache.log4j.PatternLayout&lt;br/&gt;log4j.appender.E.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss} %p %l %m %n&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 控制台输出配置&lt;/span&gt;&lt;br/&gt;log4j.appender.C=org.apache.log4j.ConsoleAppender&lt;br/&gt;log4j.appender.C.Threshold=INFO&lt;br/&gt;log4j.appender.C.layout=org.apache.log4j.PatternLayout&lt;br/&gt;log4j.appender.C.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} [%t] %-5p %l %m %n&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.3、log4j使用&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在需要打印日志的类中，引入&lt;code&gt;Logger&lt;/code&gt;类，在需要的地方打印即可！&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; org.example.log4j.service;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.slf4j.Logger;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.slf4j.LoggerFactory;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LogPrintUtil&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**log静态常量*/&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(LogPrintUtil&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;            logger.info(&lt;span&gt;&quot;info信息&quot;&lt;/span&gt;);&lt;br/&gt;            logger.warn(&lt;span&gt;&quot;warn信息&quot;&lt;/span&gt;);&lt;br/&gt;            logger.error(&lt;span&gt;&quot;error信息&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然你还可以这样写&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(logger.isInfoEnabled()) {&lt;br/&gt;    logger.info(&lt;span&gt;&quot;info信息&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(logger.isWarnEnabled()) {&lt;br/&gt;    logger.warn(&lt;span&gt;&quot;warn信息&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.4、isInfoEnabled()有何作用呢？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说，&lt;strong&gt;在某些场景下&lt;/strong&gt;，用&lt;code&gt;isInfoEnabled()&lt;/code&gt;方法判断下是能提升性能的！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如我们打印这段内容&lt;code&gt;logger.info(&quot;User:&quot; + userId + appId)&lt;/code&gt;，程序在打印这行代码时，先对内容&lt;code&gt;(&quot;User:&quot; + userId + appId)&lt;/code&gt;进行字符串拼接，然后再输出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果当前配置文件中日志输出级别是&lt;code&gt;info&lt;/code&gt;，是直接输出的，当日志输出级别是&lt;code&gt;error&lt;/code&gt;时，&lt;code&gt;logger.info()&lt;/code&gt;的内容时不输出的，但是我们却进行了字符串拼接，如果加上&lt;code&gt;if(logger.isInfoEnabled())&lt;/code&gt;进行一次判定，&lt;code&gt;logger.info()&lt;/code&gt;就不会执行，从而更好的提升性能，这个尤其是在高并发和复杂&lt;code&gt;log&lt;/code&gt;打印情况下提升非常显著。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，&lt;code&gt;ERROR&lt;/code&gt;及其以上级别的log信息是一定会被输出的，所以只有&lt;code&gt;logger.isDebugEnabled&lt;/code&gt;、&lt;code&gt;logger.isInfoEnabled&lt;/code&gt;和&lt;code&gt;logger.isWarnEnabled()&lt;/code&gt;方法，而没有&lt;code&gt;logger.isErrorEnabled&lt;/code&gt;方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;三、Log4j2&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1、介绍&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;log4j2 是 log4j 1.x 的升级版，参考了 logback 的一些优秀的设计，并且修复了一些问题，因此带来了一些重大的提升，主要特点有：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3508541392904074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/laEmibHFxFw4AzzT8jZibLlgwC0zwdoX4aGuZzJ0ngoiba7ksTVPWaBE6UlK8095kMyqmPv2lbyatOZphGicW33SWA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;761&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;异常处理&lt;/strong&gt;：在logback中，Appender中的异常不会被应用感知到，但是在log4j2中，提供了一些异常处理机制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;性能提升&lt;/strong&gt;， log4j2相较于log4j 1和logback都具有很明显的性能提升，后面会有官方测试的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;自动重载配置&lt;/strong&gt;：参考了logback的设计，当然会提供自动刷新参数配置，最实用的就是我们在生产上可以动态的修改日志的级别而不需要重启应用——那对监控来说，是非常敏感的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;无垃圾机制&lt;/strong&gt;：log4j2在大部分情况下，都可以使用其设计的一套无垃圾机制，避免频繁的日志收集导致的jvm gc。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2、项目应用&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.1、添加 maven 依赖&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;&lt;br/&gt;    &amp;lt;!-- slf4j核心包 --&amp;gt;&lt;br/&gt;    &amp;lt;dependency&amp;gt;&lt;br/&gt;        &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;&lt;br/&gt;        &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;&lt;br/&gt;        &amp;lt;version&amp;gt;1.7.13&amp;lt;/version&amp;gt;&lt;br/&gt;    &amp;lt;/dependency&amp;gt;&lt;br/&gt;    &amp;lt;!--用于与common-log保持桥接 --&amp;gt;&lt;br/&gt;    &amp;lt;dependency&amp;gt;&lt;br/&gt;        &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;&lt;br/&gt;        &amp;lt;artifactId&amp;gt;jcl-over-slf4j&amp;lt;/artifactId&amp;gt;&lt;br/&gt;        &amp;lt;version&amp;gt;1.7.13&amp;lt;/version&amp;gt;&lt;br/&gt;        &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;&lt;br/&gt;    &amp;lt;/dependency&amp;gt;&lt;br/&gt;    &amp;lt;!--核心log4j2jar包 --&amp;gt;&lt;br/&gt;    &amp;lt;dependency&amp;gt;&lt;br/&gt;        &amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt;&lt;br/&gt;        &amp;lt;artifactId&amp;gt;log4j-api&amp;lt;/artifactId&amp;gt;&lt;br/&gt;        &amp;lt;version&amp;gt;2.4.1&amp;lt;/version&amp;gt;&lt;br/&gt;    &amp;lt;/dependency&amp;gt;&lt;br/&gt;    &amp;lt;dependency&amp;gt;&lt;br/&gt;        &amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt;&lt;br/&gt;        &amp;lt;artifactId&amp;gt;log4j-core&amp;lt;/artifactId&amp;gt;&lt;br/&gt;        &amp;lt;version&amp;gt;2.4.1&amp;lt;/version&amp;gt;&lt;br/&gt;    &amp;lt;/dependency&amp;gt;&lt;br/&gt;    &amp;lt;!--用于与slf4j保持桥接 --&amp;gt;&lt;br/&gt;    &amp;lt;dependency&amp;gt;&lt;br/&gt;        &amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt;&lt;br/&gt;        &amp;lt;artifactId&amp;gt;log4j-slf4j-impl&amp;lt;/artifactId&amp;gt;&lt;br/&gt;        &amp;lt;version&amp;gt;2.4.1&amp;lt;/version&amp;gt;&lt;br/&gt;    &amp;lt;/dependency&amp;gt;&lt;br/&gt;    &amp;lt;!--需要使用log4j2的AsyncLogger需要包含disruptor --&amp;gt;&lt;br/&gt;    &amp;lt;dependency&amp;gt;&lt;br/&gt;        &amp;lt;groupId&amp;gt;com.lmax&amp;lt;/groupId&amp;gt;&lt;br/&gt;        &amp;lt;artifactId&amp;gt;disruptor&amp;lt;/artifactId&amp;gt;&lt;br/&gt;        &amp;lt;version&amp;gt;3.2.0&amp;lt;/version&amp;gt;&lt;br/&gt;    &amp;lt;/dependency&amp;gt;&lt;br/&gt;&amp;lt;/dependencies&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.2、创建log4j2配置&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在项目的根目录下创建一个&lt;code&gt;log4j2.xml&lt;/code&gt;的文件，与&lt;code&gt;log4j&lt;/code&gt;相比，&lt;code&gt;log4j2&lt;/code&gt;的异步输出日志性能非常强劲，配置如下：&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1、同步输出日志&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;?xml version=&lt;span&gt;&quot;1.0&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;?&amp;gt;&lt;br/&gt;&amp;lt;!-- status : 这个用于设置log4j2自身内部的信息输出,可以不设置,当设置成trace时。&lt;br/&gt; 注：本配置文件的目标是将不同级别的日志输出到不同文件，最大1MB一个文件， &lt;br/&gt;    文件数据达到最大值时，旧数据会被压缩并放进指定文件夹 ，最多存放20个文件--&amp;gt;&lt;br/&gt;&amp;lt;Configuration status=&lt;span&gt;&quot;error&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;!-- 配置日志文件输出目录，此配置将日志输出到根目录下的指定文件夹 --&amp;gt;&lt;br/&gt;    &amp;lt;Properties&amp;gt;&lt;br/&gt;        &amp;lt;Property name=&lt;span&gt;&quot;fileDir&quot;&lt;/span&gt;&amp;gt;/logs/log4j2&amp;lt;/Property&amp;gt;&lt;br/&gt;        &amp;lt;Property name=&lt;span&gt;&quot;fileHistory&quot;&lt;/span&gt;&amp;gt;/logs/log4j2/&lt;span&gt;history&lt;/span&gt;&amp;lt;/Property&amp;gt;&lt;br/&gt;    &amp;lt;/Properties&amp;gt;&lt;br/&gt;    &amp;lt;Appenders&amp;gt;&lt;br/&gt;        &amp;lt;!-- 优先级从高到低分别是 OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL --&amp;gt;&lt;br/&gt;        &amp;lt;!-- 单词解释：Match：匹配 DENY：拒绝 Mismatch：不匹配 ACCEPT：接受 --&amp;gt;&lt;br/&gt;        &amp;lt;!-- DENY，日志将立即被抛弃不再经过其他过滤器；NEUTRAL，有序列表里的下个过滤器过接着处理日志；ACCEPT，日志会被立即处理，不再经过剩余过滤器。 --&amp;gt;&lt;br/&gt;        &amp;lt;!--输出日志的格式&lt;br/&gt;        %d{yyyy-MM-dd HH:mm:ss, SSS} : 日志生产时间&lt;br/&gt;        %t 输出当前线程名称&lt;br/&gt;        %-5level 输出日志级别，-5表示左对齐并且固定输出5个字符，如果不足在右边补0&lt;br/&gt;        %logger 输出logger名称，因为Root Logger没有名称，所以没有输出&lt;br/&gt;        %msg 日志文本&lt;br/&gt;        %n 换行&lt;br/&gt;        其他常用的占位符有：&lt;br/&gt;        %F 输出所在的类文件名，如Client.java&lt;br/&gt;        %L 输出行号&lt;br/&gt;        %M 输出所在方法名&lt;br/&gt;        %l  输出语句所在的行数, 包括类名、方法名、文件名、行数&lt;br/&gt;         --&amp;gt;&lt;br/&gt;        &amp;lt;!--这个输出控制台的配置，这里输出all信息到System.out --&amp;gt;&lt;br/&gt;        &amp;lt;console name=&lt;span&gt;&quot;Console&quot;&lt;/span&gt; target=&lt;span&gt;&quot;SYSTEM_OUT&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;            &amp;lt;!-- 输出日志的格式 --&amp;gt;&lt;br/&gt;            &amp;lt;PatternLayout charset=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt; pattern=&lt;span&gt;&quot;%d{yyyy-MM-dd HH:mm:ss} [%t] %-5level %l %msg%n&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;        &amp;lt;/console&amp;gt;&lt;br/&gt;        &amp;lt;!--这个输出文件的配置，这里输出info信息到junbao_info.log --&amp;gt;&lt;br/&gt;        &amp;lt;RollingFile name=&lt;span&gt;&quot;RollingFileInfo&quot;&lt;/span&gt; fileName=&lt;span&gt;&quot;&lt;span&gt;${fileDir}&lt;/span&gt;/info.log&quot;&lt;/span&gt; filePattern=&lt;span&gt;&quot;&lt;span&gt;${fileHistory}&lt;/span&gt;/info/%d{yyyy-MM-dd}-%i.log&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;            &amp;lt;!-- 此Filter意思是，只输出info级别的数据 DENY，日志将立即被抛弃不再经过其他过滤器；NEUTRAL，有序列表里的下个过滤器过接着处理日志； &lt;br/&gt;                    ACCEPT，日志会被立即处理，不再经过剩余过滤器。 --&amp;gt;&lt;br/&gt;            &amp;lt;ThresholdFilter level=&lt;span&gt;&quot;info&quot;&lt;/span&gt; onMatch=&lt;span&gt;&quot;ACCEPT&quot;&lt;/span&gt; onMismatch=&lt;span&gt;&quot;DENY&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;            &amp;lt;PatternLayout charset=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt; pattern=&lt;span&gt;&quot;%d{yyyy-MM-dd HH:mm:ss} [%t] %-5level %l %msg%n&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;            &amp;lt;Policies&amp;gt;&lt;br/&gt;            &amp;lt;!-- 如果启用此配置，则日志会按文件名生成新文件， 即如果filePattern配置的日期格式为 %d{yyyy-MM-dd HH} &lt;br/&gt;                    ，则每小时生成一个压缩文件， 如果filePattern配置的日期格式为 %d{yyyy-MM-dd} ，则天生成一个压缩文件,默认为1 --&amp;gt;&lt;br/&gt;                &amp;lt;TimeBasedTriggeringPolicy /&amp;gt;&lt;br/&gt;                &amp;lt;!-- 每个日志文件最大1MB,超过1MB生产新的文件 ; --&amp;gt;&lt;br/&gt;                &amp;lt;SizeBasedTriggeringPolicy size=&lt;span&gt;&quot;100MB&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;            &amp;lt;/Policies&amp;gt;&lt;br/&gt;             &amp;lt;!--文件夹下最多的文件个数--&amp;gt;  &lt;br/&gt;            &amp;lt;DefaultRolloverStrategy max=&lt;span&gt;&quot;20&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;        &amp;lt;/RollingFile&amp;gt;&lt;br/&gt;        &amp;lt;RollingFile name=&lt;span&gt;&quot;RollingFileWarn&quot;&lt;/span&gt; fileName=&lt;span&gt;&quot;&lt;span&gt;${fileDir}&lt;/span&gt;/warn.log&quot;&lt;/span&gt; filePattern=&lt;span&gt;&quot;&lt;span&gt;${fileHistory}&lt;/span&gt;/warn/%d{yyyy-MM-dd}-%i.log&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;            &amp;lt;ThresholdFilter level=&lt;span&gt;&quot;warn&quot;&lt;/span&gt; onMatch=&lt;span&gt;&quot;ACCEPT&quot;&lt;/span&gt; onMismatch=&lt;span&gt;&quot;DENY&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;            &amp;lt;PatternLayout charset=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt; pattern=&lt;span&gt;&quot;%d{yyyy-MM-dd HH:mm:ss} [%t] %-5level %l %msg%n&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;            &amp;lt;Policies&amp;gt;&lt;br/&gt;                &amp;lt;TimeBasedTriggeringPolicy /&amp;gt;&lt;br/&gt;                &amp;lt;SizeBasedTriggeringPolicy size=&lt;span&gt;&quot;100MB&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;            &amp;lt;/Policies&amp;gt;&lt;br/&gt;            &amp;lt;DefaultRolloverStrategy max=&lt;span&gt;&quot;20&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;        &amp;lt;/RollingFile&amp;gt;&lt;br/&gt;        &amp;lt;RollingFile name=&lt;span&gt;&quot;RollingFileError&quot;&lt;/span&gt; fileName=&lt;span&gt;&quot;&lt;span&gt;${fileDir}&lt;/span&gt;/error.log&quot;&lt;/span&gt; filePattern=&lt;span&gt;&quot;&lt;span&gt;${fileHistory}&lt;/span&gt;/error/%d{yyyy-MM-dd}-%i.log&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;            &amp;lt;ThresholdFilter level=&lt;span&gt;&quot;error&quot;&lt;/span&gt; onMatch=&lt;span&gt;&quot;ACCEPT&quot;&lt;/span&gt; onMismatch=&lt;span&gt;&quot;DENY&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;            &amp;lt;PatternLayout charset=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt; pattern=&lt;span&gt;&quot;%d{yyyy-MM-dd HH:mm:ss} [%t] %-5level %l %msg%n&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;            &amp;lt;Policies&amp;gt;&lt;br/&gt;                &amp;lt;TimeBasedTriggeringPolicy /&amp;gt;&lt;br/&gt;                &amp;lt;SizeBasedTriggeringPolicy size=&lt;span&gt;&quot;100MB&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;            &amp;lt;/Policies&amp;gt;&lt;br/&gt;            &amp;lt;DefaultRolloverStrategy max=&lt;span&gt;&quot;20&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;        &amp;lt;/RollingFile&amp;gt;&lt;br/&gt;    &amp;lt;/Appenders&amp;gt;&lt;br/&gt;    &amp;lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效 --&amp;gt;&lt;br/&gt;    &amp;lt;Loggers&amp;gt;&lt;br/&gt;        &amp;lt;!--全异步输出info级以上的日志信息--&amp;gt; &lt;br/&gt;        &amp;lt;!-- &amp;lt;asyncRoot level=&lt;span&gt;&quot;info&quot;&lt;/span&gt; includeLocation=&lt;span&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;            &amp;lt;appender-ref ref=&lt;span&gt;&quot;Console&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;            &amp;lt;appender-ref ref=&lt;span&gt;&quot;RollingFileInfo&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;        &amp;lt;/asyncRoot&amp;gt; --&amp;gt;&lt;br/&gt;        &amp;lt;!--同步输出info级以上的日志信息--&amp;gt; &lt;br/&gt;        &amp;lt;root level=&lt;span&gt;&quot;info&quot;&lt;/span&gt; includeLocation=&lt;span&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;            &amp;lt;appender-ref ref=&lt;span&gt;&quot;Console&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;        &amp;lt;/root&amp;gt;&lt;br/&gt;    &amp;lt;/Loggers&amp;gt;&lt;br/&gt;&amp;lt;/Configuration&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、异步输出日志&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;?xml version=&lt;span&gt;&quot;1.0&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;?&amp;gt;&lt;br/&gt;&amp;lt;!-- status : 这个用于设置log4j2自身内部的信息输出,可以不设置,当设置成trace时。&lt;br/&gt; 注：本配置文件的目标是将不同级别的日志输出到不同文件，最大1MB一个文件， &lt;br/&gt;    文件数据达到最大值时，旧数据会被压缩并放进指定文件夹 ，最多存放20个文件--&amp;gt;&lt;br/&gt;&amp;lt;Configuration status=&lt;span&gt;&quot;error&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;!-- 配置日志文件输出目录，此配置将日志输出到根目录下的指定文件夹 --&amp;gt;&lt;br/&gt;    &amp;lt;Properties&amp;gt;&lt;br/&gt;        &amp;lt;Property name=&lt;span&gt;&quot;fileDir&quot;&lt;/span&gt;&amp;gt;/logs/log4j2&amp;lt;/Property&amp;gt;&lt;br/&gt;        &amp;lt;Property name=&lt;span&gt;&quot;fileHistory&quot;&lt;/span&gt;&amp;gt;/logs/log4j2/&lt;span&gt;history&lt;/span&gt;&amp;lt;/Property&amp;gt;&lt;br/&gt;    &amp;lt;/Properties&amp;gt;&lt;br/&gt;    &amp;lt;Appenders&amp;gt;&lt;br/&gt;        &amp;lt;!-- 优先级从高到低分别是 OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL --&amp;gt;&lt;br/&gt;        &amp;lt;!-- 单词解释：Match：匹配 DENY：拒绝 Mismatch：不匹配 ACCEPT：接受 --&amp;gt;&lt;br/&gt;        &amp;lt;!-- DENY，日志将立即被抛弃不再经过其他过滤器；NEUTRAL，有序列表里的下个过滤器过接着处理日志；ACCEPT，日志会被立即处理，不再经过剩余过滤器。 --&amp;gt;&lt;br/&gt;        &amp;lt;!--输出日志的格式&lt;br/&gt;        %d{yyyy-MM-dd HH:mm:ss, SSS} : 日志生产时间&lt;br/&gt;        %t 输出当前线程名称&lt;br/&gt;        %-5level 输出日志级别，-5表示左对齐并且固定输出5个字符，如果不足在右边补0&lt;br/&gt;        %logger 输出logger名称，因为Root Logger没有名称，所以没有输出&lt;br/&gt;        %msg 日志文本&lt;br/&gt;        %n 换行&lt;br/&gt;        其他常用的占位符有：&lt;br/&gt;        %F 输出所在的类文件名，如Client.java&lt;br/&gt;        %L 输出行号&lt;br/&gt;        %M 输出所在方法名&lt;br/&gt;        %l  输出语句所在的行数, 包括类名、方法名、文件名、行数&lt;br/&gt;         --&amp;gt;&lt;br/&gt;        &amp;lt;!--这个输出控制台的配置，这里输出all信息到System.out --&amp;gt;&lt;br/&gt;        &amp;lt;console name=&lt;span&gt;&quot;Console&quot;&lt;/span&gt; target=&lt;span&gt;&quot;SYSTEM_OUT&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;            &amp;lt;!-- 输出日志的格式 --&amp;gt;&lt;br/&gt;            &amp;lt;PatternLayout charset=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt; pattern=&lt;span&gt;&quot;%d{yyyy-MM-dd HH:mm:ss} [%t] %-5level %l %msg%n&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;        &amp;lt;/console&amp;gt;&lt;br/&gt;        &amp;lt;!--这个输出文件的配置，这里输出info信息到junbao_info.log --&amp;gt;&lt;br/&gt;        &amp;lt;RollingFile name=&lt;span&gt;&quot;RollingFileInfo&quot;&lt;/span&gt; fileName=&lt;span&gt;&quot;&lt;span&gt;${fileDir}&lt;/span&gt;/info.log&quot;&lt;/span&gt; filePattern=&lt;span&gt;&quot;&lt;span&gt;${fileHistory}&lt;/span&gt;/info/%d{yyyy-MM-dd}-%i.log&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;            &amp;lt;!-- 此Filter意思是，只输出info级别的数据 DENY，日志将立即被抛弃不再经过其他过滤器；NEUTRAL，有序列表里的下个过滤器过接着处理日志； &lt;br/&gt;                    ACCEPT，日志会被立即处理，不再经过剩余过滤器。 --&amp;gt;&lt;br/&gt;            &amp;lt;ThresholdFilter level=&lt;span&gt;&quot;info&quot;&lt;/span&gt; onMatch=&lt;span&gt;&quot;ACCEPT&quot;&lt;/span&gt; onMismatch=&lt;span&gt;&quot;DENY&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;            &amp;lt;PatternLayout charset=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt; pattern=&lt;span&gt;&quot;%d{yyyy-MM-dd HH:mm:ss} [%t] %-5level %l %msg%n&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;            &amp;lt;Policies&amp;gt;&lt;br/&gt;            &amp;lt;!-- 如果启用此配置，则日志会按文件名生成新文件， 即如果filePattern配置的日期格式为 %d{yyyy-MM-dd HH} &lt;br/&gt;                    ，则每小时生成一个压缩文件， 如果filePattern配置的日期格式为 %d{yyyy-MM-dd} ，则天生成一个压缩文件,默认为1 --&amp;gt;&lt;br/&gt;                &amp;lt;TimeBasedTriggeringPolicy /&amp;gt;&lt;br/&gt;                &amp;lt;!-- 每个日志文件最大1MB,超过1MB生产新的文件 ; --&amp;gt;&lt;br/&gt;                &amp;lt;SizeBasedTriggeringPolicy size=&lt;span&gt;&quot;100MB&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;            &amp;lt;/Policies&amp;gt;&lt;br/&gt;             &amp;lt;!--文件夹下最多的文件个数--&amp;gt;  &lt;br/&gt;            &amp;lt;DefaultRolloverStrategy max=&lt;span&gt;&quot;20&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;        &amp;lt;/RollingFile&amp;gt;&lt;br/&gt;        &amp;lt;RollingFile name=&lt;span&gt;&quot;RollingFileWarn&quot;&lt;/span&gt; fileName=&lt;span&gt;&quot;&lt;span&gt;${fileDir}&lt;/span&gt;/warn.log&quot;&lt;/span&gt; filePattern=&lt;span&gt;&quot;&lt;span&gt;${fileHistory}&lt;/span&gt;/warn/%d{yyyy-MM-dd}-%i.log&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;            &amp;lt;ThresholdFilter level=&lt;span&gt;&quot;warn&quot;&lt;/span&gt; onMatch=&lt;span&gt;&quot;ACCEPT&quot;&lt;/span&gt; onMismatch=&lt;span&gt;&quot;DENY&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;            &amp;lt;PatternLayout charset=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt; pattern=&lt;span&gt;&quot;%d{yyyy-MM-dd HH:mm:ss} [%t] %-5level %l %msg%n&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;            &amp;lt;Policies&amp;gt;&lt;br/&gt;                &amp;lt;TimeBasedTriggeringPolicy /&amp;gt;&lt;br/&gt;                &amp;lt;SizeBasedTriggeringPolicy size=&lt;span&gt;&quot;100MB&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;            &amp;lt;/Policies&amp;gt;&lt;br/&gt;            &amp;lt;DefaultRolloverStrategy max=&lt;span&gt;&quot;20&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;        &amp;lt;/RollingFile&amp;gt;&lt;br/&gt;        &amp;lt;RollingFile name=&lt;span&gt;&quot;RollingFileError&quot;&lt;/span&gt; fileName=&lt;span&gt;&quot;&lt;span&gt;${fileDir}&lt;/span&gt;/error.log&quot;&lt;/span&gt; filePattern=&lt;span&gt;&quot;&lt;span&gt;${fileHistory}&lt;/span&gt;/error/%d{yyyy-MM-dd}-%i.log&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;            &amp;lt;ThresholdFilter level=&lt;span&gt;&quot;error&quot;&lt;/span&gt; onMatch=&lt;span&gt;&quot;ACCEPT&quot;&lt;/span&gt; onMismatch=&lt;span&gt;&quot;DENY&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;            &amp;lt;PatternLayout charset=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt; pattern=&lt;span&gt;&quot;%d{yyyy-MM-dd HH:mm:ss} [%t] %-5level %l %msg%n&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;            &amp;lt;Policies&amp;gt;&lt;br/&gt;                &amp;lt;TimeBasedTriggeringPolicy /&amp;gt;&lt;br/&gt;                &amp;lt;SizeBasedTriggeringPolicy size=&lt;span&gt;&quot;100MB&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;            &amp;lt;/Policies&amp;gt;&lt;br/&gt;            &amp;lt;DefaultRolloverStrategy max=&lt;span&gt;&quot;20&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;        &amp;lt;/RollingFile&amp;gt;&lt;br/&gt;    &amp;lt;/Appenders&amp;gt;&lt;br/&gt;    &amp;lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效 --&amp;gt;&lt;br/&gt;    &amp;lt;Loggers&amp;gt;&lt;br/&gt;        &amp;lt;!--全异步输出info级以上的日志信息--&amp;gt; &lt;br/&gt;        &amp;lt;asyncRoot level=&lt;span&gt;&quot;info&quot;&lt;/span&gt; includeLocation=&lt;span&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;            &amp;lt;appender-ref ref=&lt;span&gt;&quot;Console&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;            &amp;lt;appender-ref ref=&lt;span&gt;&quot;RollingFileInfo&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;        &amp;lt;/asyncRoot&amp;gt;&lt;br/&gt;        &amp;lt;!--同步输出info级以上的日志信息--&amp;gt; &lt;br/&gt;        &amp;lt;!-- &amp;lt;root level=&lt;span&gt;&quot;info&quot;&lt;/span&gt; includeLocation=&lt;span&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;            &amp;lt;appender-ref ref=&lt;span&gt;&quot;Console&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;        &amp;lt;/root&amp;gt; --&amp;gt;&lt;br/&gt;    &amp;lt;/Loggers&amp;gt;&lt;br/&gt;&amp;lt;/Configuration&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细 API 可以参考官方网站！&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.3、log4j2使用&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与 log4j 类似，直接在需要位置打印日志即可&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package org.example.log4j.service;&lt;br/&gt;import org.slf4j.Logger;&lt;br/&gt;import org.slf4j.LoggerFactory;&lt;br/&gt;public class LogPrintUtil {&lt;br/&gt;    /**&lt;span&gt;log&lt;/span&gt;静态常量*/&lt;br/&gt;    private static final Logger logger = LoggerFactory.getLogger(LogPrintUtil.class);&lt;br/&gt;    public static void main(String[] args){&lt;br/&gt;            logger.info(&lt;span&gt;&quot;info信息&quot;&lt;/span&gt;);&lt;br/&gt;            logger.warn(&lt;span&gt;&quot;warn信息&quot;&lt;/span&gt;);&lt;br/&gt;            logger.error(&lt;span&gt;&quot;error信息&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;四、Logback&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1、介绍&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Logback 也是用 java 编写一款非常热门的日志开源框架，由 log4j 创始人写的，性能比 log4j 要好!&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;logback 主要分为3个模块：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;logback-core：核心代码模块&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;logback-classic：log4j的一个改良版本，同时实现了slf4j的接口，这样你如果之后要切换其他日志组件也是一件很容易的事&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;logback-access：访问模块与Servlet容器集成提供通过Http来访问日志的功能&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2、项目应用&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.1、添加 maven 依赖&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;!--这个依赖直接包含了 logback-core 以及 slf4j-api的依赖--&amp;gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt;&lt;br/&gt;    &amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&amp;lt;!-- 支持在xml中写判断标签 --&amp;gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;org.codehaus.janino&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;janino&amp;lt;/artifactId&amp;gt;&lt;br/&gt;    &amp;lt;version&amp;gt;2.7.8&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.2、创建logback配置文件&lt;span/&gt;&lt;/h5&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1、配置说明&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;logback在启动的时候，会按照下面的顺序加载配置文件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果java程序启动时指定了&lt;code&gt;logback.configurationFile&lt;/code&gt;属性，就用该属性指定的配置文件。如j&lt;code&gt;ava -Dlogback.configurationFile=/path/to/mylogback.xml Test&lt;/code&gt;，这样执行&lt;code&gt;Test&lt;/code&gt;类的时候就会加载&lt;code&gt;/path/to/mylogback.xml&lt;/code&gt;配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在&lt;code&gt;classpath&lt;/code&gt;中查找&lt;code&gt;logback.groovy&lt;/code&gt;文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在&lt;code&gt;classpath&lt;/code&gt;中查找&lt;code&gt;logback-test.xml&lt;/code&gt;文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在&lt;code&gt;classpath&lt;/code&gt;中查找&lt;code&gt;logback.xml&lt;/code&gt;文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是&lt;code&gt;jdk6+&lt;/code&gt;,那么会调用S&lt;code&gt;erviceLoader&lt;/code&gt;查找 &lt;code&gt;com.qos.logback.classic.spi.Configurator&lt;/code&gt;接口的第一个实现类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动使用&lt;code&gt;ch.qos.logback.classic.BasicConfigurator&lt;/code&gt;，在控制台输出日志&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的顺序表示优先级，使用&lt;code&gt;java -D&lt;/code&gt;配置的优先级最高，只要获取到配置后就不会再执行下面的流程。相关代码可以看&lt;code&gt;ContextInitializer#autoConfig()&lt;/code&gt;方法。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、同步输出日志&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;?xml version=&lt;span&gt;&quot;1.0&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;?&amp;gt;&lt;br/&gt;&amp;lt;!-- scan:当此属性设置为&lt;span&gt;true&lt;/span&gt;时，配置文件如果发生改变，将会被重新加载，默认值为&lt;span&gt;true&lt;/span&gt;。scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为&lt;span&gt;true&lt;/span&gt;时，此属性生效。默认的时间间隔为1分钟。 &lt;br/&gt;    debug:当此属性设置为&lt;span&gt;true&lt;/span&gt;时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为&lt;span&gt;false&lt;/span&gt;。 --&amp;gt;&lt;br/&gt;&amp;lt;configuration scan=&lt;span&gt;&quot;true&quot;&lt;/span&gt; scanPeriod=&lt;span&gt;&quot;60 seconds&quot;&lt;/span&gt; debug=&lt;span&gt;&quot;false&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;!-- 运行环境，dev:开发，&lt;span&gt;test&lt;/span&gt;:测试，pre:预生产，pro:生产 --&amp;gt;&lt;br/&gt;    &amp;lt;property name=&lt;span&gt;&quot;system_host&quot;&lt;/span&gt; value=&lt;span&gt;&quot;dev&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;    &amp;lt;property file=&lt;span&gt;&quot;system.properties&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;    &amp;lt;!-- 上下文变量设置,用来定义变量值,其中name的值是变量的名称，value的值时变量定义的值。 通过&amp;lt;property&amp;gt;定义的值会被插入到logger上下文中。定义变量后，可以使“&lt;span&gt;${}&lt;/span&gt;”来使用变量。 --&amp;gt;&lt;br/&gt;    &amp;lt;property name=&lt;span&gt;&quot;CONTEXT_NAME&quot;&lt;/span&gt; value=&lt;span&gt;&quot;logback-test&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;    &amp;lt;!-- 日志文件存放路径设置，绝对路径 --&amp;gt;&lt;br/&gt;    &amp;lt;property name=&lt;span&gt;&quot;logs.dir&quot;&lt;/span&gt; value=&lt;span&gt;&quot;/opt/logs&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;    &amp;lt;!-- 日志文件存放路径设置，tomcat路径 --&amp;gt;&lt;br/&gt;    &amp;lt;property name=&lt;span&gt;&quot;logs.dir&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;span&gt;${catalina.base}&lt;/span&gt;/logs&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;    &amp;lt;!-- 定义日志文件 相对输入位置 --&amp;gt;  &lt;br/&gt;    &amp;lt;property name=&lt;span&gt;&quot;log_dir&quot;&lt;/span&gt; value=&lt;span&gt;&quot;log&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;    &amp;lt;!-- 日志输出格式设置 --&amp;gt;&lt;br/&gt;    &amp;lt;!-- &lt;br/&gt;    %d{yyyy-MM-dd HH:mm:ss} [%level] - %msg%n&lt;br/&gt;      Logger: %logger&lt;br/&gt;      Class: %class&lt;br/&gt;      File: %file&lt;br/&gt;      Caller: %&lt;span&gt;caller&lt;/span&gt;&lt;br/&gt;      Line: %line&lt;br/&gt;      Message: %m&lt;br/&gt;      Method: %M&lt;br/&gt;      Relative: %relative&lt;br/&gt;      Thread: %thread&lt;br/&gt;      Exception: %ex&lt;br/&gt;      xException: %xEx&lt;br/&gt;      nopException: %nopex&lt;br/&gt;      rException: %rEx&lt;br/&gt;      Marker: %marker&lt;br/&gt;      newline:%n&lt;br/&gt;    --&amp;gt;&lt;br/&gt;    &amp;lt;property name=&lt;span&gt;&quot;CUSTOM_LOG_PATTERN&quot;&lt;/span&gt;&lt;br/&gt;        value=&lt;span&gt;&quot;%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{90} - %msg%n&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;    &amp;lt;!-- 上下文名称：&amp;lt;contextName&amp;gt;, 每个logger都关联到logger上下文， 默认上下文名称为“default”。但可以使用&amp;lt;contextName&amp;gt;设置成其他名字，用于区分不同应用程序的记录。 &lt;br/&gt;        一旦设置，不能修改。 --&amp;gt;&lt;br/&gt;    &amp;lt;contextName&amp;gt;&lt;span&gt;${CONTEXT_NAME}&lt;/span&gt;&amp;lt;/contextName&amp;gt;&lt;br/&gt;    &amp;lt;!-- &amp;lt;appender&amp;gt;是&amp;lt;configuration&amp;gt;的子节点，是负责写日志的组件。 有两个必要属性name和class。name指定appender名称， &lt;br/&gt;        class指定appender的实现类。 --&amp;gt;&lt;br/&gt;    &amp;lt;appender name=&lt;span&gt;&quot;console&quot;&lt;/span&gt; class=&lt;span&gt;&quot;ch.qos.logback.core.ConsoleAppender&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;        &amp;lt;!-- 对日志进行格式化。 --&amp;gt;&lt;br/&gt;        &amp;lt;encoder&amp;gt;&lt;br/&gt;            &amp;lt;pattern&amp;gt;&lt;span&gt;${CUSTOM_LOG_PATTERN}&lt;/span&gt;&amp;lt;/pattern&amp;gt;&lt;br/&gt;            &amp;lt;charset&amp;gt;UTF-8&amp;lt;/charset&amp;gt;&lt;br/&gt;        &amp;lt;/encoder&amp;gt;&lt;br/&gt;    &amp;lt;/appender&amp;gt;&lt;br/&gt;    &amp;lt;appender name=&lt;span&gt;&quot;file&quot;&lt;/span&gt;&lt;br/&gt;        class=&lt;span&gt;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;        &amp;lt;!-- 按天来回滚，如果需要按小时来回滚，则设置为{yyyy-MM-dd_HH} --&amp;gt;&lt;br/&gt;        &amp;lt;rollingPolicy class=&lt;span&gt;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;            &amp;lt;fileNamePattern&amp;gt;&lt;span&gt;log&lt;/span&gt;/testC.%d{yyyy-MM-dd}.%i.log&amp;lt;/fileNamePattern&amp;gt;&lt;br/&gt;            &amp;lt;!-- 如果按天来回滚，则最大保存时间为30天，30天之前的都将被清理掉 --&amp;gt;&lt;br/&gt;            &amp;lt;maxHistory&amp;gt;30&amp;lt;/maxHistory&amp;gt;&lt;br/&gt;            &amp;lt;!-- 按时间回滚的同时，按文件大小来回滚 --&amp;gt;&lt;br/&gt;            &amp;lt;timeBasedFileNamingAndTriggeringPolicy&lt;br/&gt;                class=&lt;span&gt;&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;                &amp;lt;maxFileSize&amp;gt;100MB&amp;lt;/maxFileSize&amp;gt;&lt;br/&gt;            &amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt;&lt;br/&gt;        &amp;lt;/rollingPolicy&amp;gt;&lt;br/&gt;        &amp;lt;!-- 过滤器，只记录WARN级别的日志 --&amp;gt;&lt;br/&gt;        &amp;lt;!-- 果日志级别等于配置级别，过滤器会根据onMath 和 onMismatch接收或拒绝日志。 --&amp;gt;&lt;br/&gt;        &amp;lt;filter class=&lt;span&gt;&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;            &amp;lt;!-- 设置过滤级别 --&amp;gt;&lt;br/&gt;            &amp;lt;level&amp;gt;WARN&amp;lt;/level&amp;gt;&lt;br/&gt;            &amp;lt;!-- 用于配置符合过滤条件的操作 --&amp;gt;&lt;br/&gt;            &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt;&lt;br/&gt;            &amp;lt;!-- 用于配置不符合过滤条件的操作 --&amp;gt;&lt;br/&gt;            &amp;lt;onMismatch&amp;gt;DENY&amp;lt;/onMismatch&amp;gt;&lt;br/&gt;        &amp;lt;/filter&amp;gt;&lt;br/&gt;        &amp;lt;!-- 日志输出格式 --&amp;gt;&lt;br/&gt;        &amp;lt;encoder&amp;gt;&lt;br/&gt;            &amp;lt;pattern&amp;gt;&lt;span&gt;${CUSTOM_LOG_PATTERN}&lt;/span&gt;&amp;lt;/pattern&amp;gt;&lt;br/&gt;            &amp;lt;charset&amp;gt;UTF-8&amp;lt;/charset&amp;gt;&lt;br/&gt;        &amp;lt;/encoder&amp;gt;&lt;br/&gt;    &amp;lt;/appender&amp;gt;&lt;br/&gt; &lt;br/&gt;    &amp;lt;appender name=&lt;span&gt;&quot;log_file&quot;&lt;/span&gt;&lt;br/&gt;        class=&lt;span&gt;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;        &amp;lt;!-- 被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。 --&amp;gt;&lt;br/&gt;        &amp;lt;file&amp;gt;&lt;span&gt;${logs.dir}&lt;/span&gt;/logback-test.log&amp;lt;/file&amp;gt;&lt;br/&gt;        &amp;lt;!-- 按照固定窗口模式生成日志文件，当文件大于20MB时，生成新的日志文件。窗口大小是1到3，当保存了3个归档文件后，将覆盖最早的日志 --&amp;gt;&lt;br/&gt;        &amp;lt;rollingPolicy class=&lt;span&gt;&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;            &amp;lt;!-- 必须包含“%i”例如，假设最小值和最大值分别为1和2，命名模式为 mylog%i.log,会产生归档文件mylog1.log和mylog2.log。还可以指定文件压缩选项，例如，mylog%i.log.gz &lt;br/&gt;                或者 没有&lt;span&gt;log&lt;/span&gt;%i.log.zip --&amp;gt;&lt;br/&gt;            &amp;lt;FileNamePattern&amp;gt;&lt;span&gt;${logs.dir}&lt;/span&gt;/logback-test.%i.log&amp;lt;/FileNamePattern&amp;gt;&lt;br/&gt;            &amp;lt;!-- 窗口索引最小值 --&amp;gt;&lt;br/&gt;            &amp;lt;minIndex&amp;gt;1&amp;lt;/minIndex&amp;gt;&lt;br/&gt;            &amp;lt;!-- 窗口索引最大值 --&amp;gt;&lt;br/&gt;            &amp;lt;maxIndex&amp;gt;3&amp;lt;/maxIndex&amp;gt;&lt;br/&gt;        &amp;lt;/rollingPolicy&amp;gt;&lt;br/&gt;        &amp;lt;!-- 日志级别过滤器 --&amp;gt;&lt;br/&gt;        &amp;lt;filter class=&lt;span&gt;&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;            &amp;lt;!-- 日志级别过滤器 --&amp;gt;&lt;br/&gt;            &amp;lt;level&amp;gt;INFO&amp;lt;/level&amp;gt;&lt;br/&gt;            &amp;lt;!-- 符合要求的日志级别，过滤，ACCEPT:接受 --&amp;gt;&lt;br/&gt;            &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt;&lt;br/&gt;            &amp;lt;!-- 不符合要求的日志级别，过滤，DENY:拒绝 --&amp;gt;&lt;br/&gt;            &amp;lt;onMismatch&amp;gt;DENY&amp;lt;/onMismatch&amp;gt;&lt;br/&gt;        &amp;lt;/filter&amp;gt;&lt;br/&gt;        &amp;lt;!-- 激活滚动的条件。 --&amp;gt;&lt;br/&gt;        &amp;lt;triggeringPolicy&lt;br/&gt;            class=&lt;span&gt;&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;            &amp;lt;!-- 活动文件的大小，默认值是10MB --&amp;gt;&lt;br/&gt;            &amp;lt;maxFileSize&amp;gt;30MB&amp;lt;/maxFileSize&amp;gt;&lt;br/&gt;        &amp;lt;/triggeringPolicy&amp;gt;&lt;br/&gt;        &amp;lt;!-- 对记录事件进行格式化。 --&amp;gt;&lt;br/&gt;        &amp;lt;encoder&amp;gt;&lt;br/&gt;            &amp;lt;pattern&amp;gt;&lt;span&gt;${CUSTOM_LOG_PATTERN}&lt;/span&gt;&amp;lt;/pattern&amp;gt;&lt;br/&gt;            &amp;lt;charset&amp;gt;UTF-8&amp;lt;/charset&amp;gt;&lt;br/&gt;        &amp;lt;/encoder&amp;gt;&lt;br/&gt;    &amp;lt;/appender&amp;gt;&lt;br/&gt; &lt;br/&gt;    &amp;lt;!-- 异步输出 --&amp;gt;&lt;br/&gt;    &amp;lt;appender name=&lt;span&gt;&quot;ASYNC_logback&quot;&lt;/span&gt; class=&lt;span&gt;&quot;ch.qos.logback.classic.AsyncAppender&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;        &amp;lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&amp;gt;&lt;br/&gt;        &amp;lt;!-- &amp;lt;discardingThreshold&amp;gt;0&amp;lt;/discardingThreshold&amp;gt; --&amp;gt;&lt;br/&gt;        &amp;lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&amp;gt;&lt;br/&gt;        &amp;lt;!-- &amp;lt;queueSize&amp;gt;256&amp;lt;/queueSize&amp;gt; --&amp;gt;&lt;br/&gt;        &amp;lt;!-- 添加附加的appender,最多只能添加一个 --&amp;gt;&lt;br/&gt;        &amp;lt;appender-ref ref=&lt;span&gt;&quot;log_file&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;    &amp;lt;/appender&amp;gt;&lt;br/&gt;    &amp;lt;!-- 指定包输出路径 --&amp;gt;&lt;br/&gt;    &amp;lt;!-- 用来设置某一个 包 或者具体的某一个 类 的日志打印级别、以及指定&amp;lt;appender&amp;gt;, name:用来指定受此logger约束的某一个包或者具体的某一个类。 &lt;br/&gt;        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。如果未设置此属性，那么当前loger将会继承上级的级别。 &lt;br/&gt;        additivity:是否向上级logger传递打印信息。默认是&lt;span&gt;true&lt;/span&gt;。(这个logger的上级就是上面的root) &amp;lt;logger&amp;gt;可以包含零个或多个&amp;lt;appender-ref&amp;gt;元素，标识这个appender将会添加到这个logger。 --&amp;gt;&lt;br/&gt;    &amp;lt;logger name=&lt;span&gt;&quot;org.logback.test&quot;&lt;/span&gt; level=&lt;span&gt;&quot;DEBUG&quot;&lt;/span&gt; additivity=&lt;span&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;        &amp;lt;appender-ref ref=&lt;span&gt;&quot;stdout&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;    &amp;lt;/logger&amp;gt;&lt;br/&gt;    &amp;lt;!-- 特殊的&amp;lt;logger&amp;gt;元素，是根logger。只有一个level属性，应为已经被命名为&lt;span&gt;&quot;root&quot;&lt;/span&gt;. level:设置打印级别，大小写无关：TRACE, &lt;br/&gt;        DEBUG, INFO, WARN, ERROR, ALL 和 OFF，不能设置为INHERITED或者同义词NULL。默认是DEBUG。 &amp;lt;root&amp;gt;可以包含零个或多个&amp;lt;appender-ref&amp;gt;元素，标识这个appender将会添加到这个loger。 --&amp;gt;&lt;br/&gt;    &amp;lt;root&amp;gt;&lt;br/&gt;        &amp;lt;level value=&lt;span&gt;&quot;WARN&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;        &amp;lt;!-- &lt;span&gt;if&lt;/span&gt;表达式，需要Janino jar --&amp;gt;&lt;br/&gt;        &amp;lt;!-- Janino 2.6.0版本开始，除了janino.jar之外， commons-compiler.jar也需要在类路径中 --&amp;gt;&lt;br/&gt;        &amp;lt;&lt;span&gt;if&lt;/span&gt; condition=&lt;span&gt;&#x27;property(&quot;system_host&quot;).contains(&quot;dev&quot;)&#x27;&lt;/span&gt;&amp;gt;&lt;br/&gt;            &amp;lt;&lt;span&gt;then&lt;/span&gt;&amp;gt;&lt;br/&gt;                &amp;lt;appender-ref ref=&lt;span&gt;&quot;stdout&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;            &amp;lt;/&lt;span&gt;then&lt;/span&gt;&amp;gt;&lt;br/&gt;        &amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;&lt;br/&gt;        &amp;lt;appender-ref ref=&lt;span&gt;&quot;file&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;    &amp;lt;/root&amp;gt;&lt;br/&gt;&amp;lt;/configuration&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：&lt;code&gt;logback&lt;/code&gt;如果配置要输出行号，性能会明显降低，如果不是必须，建议不要配置！&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.3、logback使用&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package org.example.logback.service;&lt;br/&gt;import org.slf4j.Logger;&lt;br/&gt;import org.slf4j.LoggerFactory;&lt;br/&gt;public class LogPrintUtil {&lt;br/&gt;    /**&lt;span&gt;log&lt;/span&gt;静态常量*/&lt;br/&gt;    private static final Logger logger = LoggerFactory.getLogger(LogPrintUtil.class);&lt;br/&gt;    public static void main(String[] args){&lt;br/&gt;         logger.info(&lt;span&gt;&quot;info信息&quot;&lt;/span&gt;);&lt;br/&gt;            logger.warn(&lt;span&gt;&quot;warn信息&quot;&lt;/span&gt;);&lt;br/&gt;            logger.error(&lt;span&gt;&quot;error信息&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;五、SLF4J桥接&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;细心的你，会发现上面代码使用时，都使用的是&lt;code&gt;private static final Logger logger = LoggerFactory.getLogger(LogPrintUtil.class)&lt;/code&gt;这个，其中都来自&lt;code&gt;org.slf4j&lt;/code&gt;包，&lt;code&gt;SLF4J&lt;/code&gt;是啥？有什么作用呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SLF4J&lt;/code&gt;本身并不输出日志，最大的特色是**：它可以通过适配的方式挂接不同的日志系统，属于一个日志接口**。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果项目适配到&lt;code&gt;log4j&lt;/code&gt;就使用&lt;code&gt;log4j&lt;/code&gt;日志库进行输出；如果适配到&lt;code&gt;logback&lt;/code&gt;就使用&lt;code&gt;logback&lt;/code&gt;日志库进行输出；如果适配到&lt;code&gt;log4j2&lt;/code&gt;就使用&lt;code&gt;log4j2&lt;/code&gt;日志库进行输出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样最大的好处，就是当你想将项目从&lt;code&gt;log4j&lt;/code&gt;换成&lt;code&gt;log4j2&lt;/code&gt;的时候，只需要在项目&lt;code&gt;pom.xml&lt;/code&gt;中进行桥接适配即可，&lt;strong&gt;不用修改具体需要打印日志的代码&lt;/strong&gt;！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;六、三大主流日志框架性能比较&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍了这么多，但是我们还不知道三个日志框架的日志输出性能如何，本文以&lt;strong&gt;10000&lt;/strong&gt;条数据进行打印，比较&lt;code&gt;log4j&lt;/code&gt;、&lt;code&gt;log4j2&lt;/code&gt;、&lt;code&gt;logback&lt;/code&gt;日志的输出时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本次测试采用的是本地电脑（win7），每个电脑的配置不一样，测试的结果也不一样，结果是真实的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.264&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/laEmibHFxFw4AzzT8jZibLlgwC0zwdoX4a5c5aurjujSlWseFZcur9eOPTxibcWrWG8zpLd0kaJq1Dpq5aqkexXdQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2716297786720322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/laEmibHFxFw4AzzT8jZibLlgwC0zwdoX4a9EbzIjujkSMLnn7stItN2ibaYzUODricdcwiausfLfjribicNq38LqWFib0A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;994&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从测试结果上可以看出：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不建议生产环境进行控制台输出；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在纯文件输出的环境下，&lt;code&gt;logback&lt;/code&gt;的输出优于&lt;code&gt;log4j2&lt;/code&gt;，而&lt;code&gt;log4j2&lt;/code&gt;要优于&lt;code&gt;log4j&lt;/code&gt;，如果要进行生产环境的部署，建议采用&lt;code&gt;logback&lt;/code&gt;，如果是使用&lt;code&gt;log4j2&lt;/code&gt;，建议使用异步方式进行输出，输出结果基本是实时输出；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后需要注意的地方是：&lt;code&gt;log&lt;/code&gt;有风险，输出需谨慎！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于输出&lt;code&gt;log&lt;/code&gt;过程需要进行磁盘操作，且&lt;code&gt;log4j&lt;/code&gt;为了保证&lt;code&gt;log&lt;/code&gt;输出过程的线程安全性而使用同步锁，就使得输出&lt;code&gt;log&lt;/code&gt;成为很耗时的操作，所以&lt;code&gt;log&lt;/code&gt;信息一定要言简意赅，不要输出一些无用的&lt;code&gt;log&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;七、总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要围绕项目中使用到的日志框架进行应用介绍，限于笔者的才疏学浅，对本文内容可能还有理解不到位的地方，如有阐述不合理之处还望留言一起探讨。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;八、参考&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、Log4j2官方地址&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、廖雪峰官方网站 - java教程&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4c331bea8e8f57d53602a42fd0839af5</guid>
<title>好的自我介绍，面试成功一大半</title>
<link>https://toutiao.io/k/lpyu6km</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;这里是Z哥的个人公众号&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;每周五11：45 按时送达&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;当然了，也会时不时加个餐～&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;我的第「164」篇原创敬上&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;大家好，我是Z哥。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关于面试时的自我介绍，我想大家遇到的情况都差不多，大部分面试的第一个环节基本都是这个。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;每个人也都知道留下好的第一印象很重要，但我估计很多人对这件事的解决方式，也就在网上找个自我介绍的模版就完事了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;先不说你找的模版会不会过于普通，导致面试官听到的千篇一律。更重要的是，如果你搞不清楚自我介绍背后的深意和价值，哪怕是套用模版也只是学了它的“形”而没学到“神”，效果自然不会太好。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我做面试官也有将近6年时间了，不管是从我自己的感受还是与其他面试官的交流后得到的信息来看，自我介绍环节能让人有惊喜的，只要后面不太“拉胯”基本都能被录用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;心理学中有一个概念阐述了这背后的原因——「&lt;/span&gt;&lt;strong&gt;&lt;span&gt;首因效应&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;」，由美国心理学家洛钦斯提出。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;71&quot; data-source-title=&quot;维基百科&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;首因效应是对“第一印象”或“先入为主”所产生的心理学现象，指在行为过程中，最先接触的事物会给人留下深刻的感知或认知，影响人对事物的感知和判断。&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22out%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%22%2C%22digestLen%22%3A71%2C%22text%22%3A%22%E9%A6%96%E5%9B%A0%E6%95%88%E5%BA%94%E6%98%AF%E5%AF%B9%E2%80%9C%E7%AC%AC%E4%B8%80%E5%8D%B0%E8%B1%A1%E2%80%9D%E6%88%96%E2%80%9C%E5%85%88%E5%85%A5%E4%B8%BA%E4%B8%BB%E2%80%9D%E6%89%80%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%83%E7%90%86%E5%AD%A6%E7%8E%B0%E8%B1%A1%EF%BC%8C%E6%8C%87%E5%9C%A8%E8%A1%8C%E4%B8%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E6%9C%80%E5%85%88%E6%8E%A5%E8%A7%A6%E7%9A%84%E4%BA%8B%E7%89%A9%E4%BC%9A%E7%BB%99%E4%BA%BA%E7%95%99%E4%B8%8B%E6%B7%B1%E5%88%BB%E7%9A%84%E6%84%9F%E7%9F%A5%E6%88%96%E8%AE%A4%E7%9F%A5%EF%BC%8C%E5%BD%B1%E5%93%8D%E4%BA%BA%E5%AF%B9%E4%BA%8B%E7%89%A9%E7%9A%84%E6%84%9F%E7%9F%A5%E5%92%8C%E5%88%A4%E6%96%AD%E3%80%82%22%2C%22article%22%3A%7B%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%5D%2C%22from%22%3A%22%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%22%7D&quot;&gt;&lt;span class=&quot;blockquote_other&quot;&gt;维基百科&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;那么我们如何能够把握住这个机会，借助「首因效应」让你在激烈的岗位竞争中占得先机呢？自然就得做好自我介绍的准备，下面我就来分享一些我的经验。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/01  自我介绍的意义/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;很多人都会告诉你，自我介绍是你主动展示自己更多信息的机会，所以自我介绍的时候要讲一些简历里没有提到的内容。这个方式没错，但是思路其实不完全对。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;阐述一个残酷的现实，面试你的面试官不一定就是筛选你简历的人，大家平时工作都很忙的，他很可能没有看过你的简历。所以自我介绍环节不但是你主动展示自己的机会，也是让面试官现场评估你简历的“刚需”环节。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以重点来了，你脑子里一定要有这样一个画面：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;我在向一个一心二用的人做自我介绍&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在这个场景下，你的终极目的是：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;提醒他注意到你的亮点，以及为什么适合这个职位&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;知己知彼才能百战不殆，那么对于面试官来说，除了获得了一个熟悉你简历的缓冲期还有什么意义呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;破冰。两个陌生人之间建立良好沟通的方式永远是开放性问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;初步判断你的沟通能力。在一个组织协作的中，1对1的对话是常见的场景，能不能把话讲明白决定了你未来与他人一起共事的能力下限。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;初步判断你的逻辑能力。通过你自我介绍阐述的内容顺序、结构，判断你的逻辑能力如何，是有条不紊的、还是混乱的。这决定了你未来做事能力的上限。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;判断你的可塑性。这个大多数时候只是一种感觉，感觉从何而来？除了语言外，你的表情、眼神等肢体语言也能传递出相关的信号。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;搞清楚了自我介绍的意义，那么我们就可以提炼出一些要点了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/02  六个要点/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&lt;strong&gt;时长控制&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一般来说，好的简历最多不超过3页A4纸，所以自我介绍不用准备的太长。因为面试官熟悉完你的简历后基本上就要准备发问了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大多数人快速阅读一页A4纸的内容大概也就1分钟，所以我建议自我介绍的时长控制在（简历页数*60 + 30）秒左右。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如，你的简历是3页，那么就是210秒，3分半；2页是150秒，2分半。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你是职场新人，那么最好能多准备一段1分钟左右的精简版，以防群面的时候做自我介绍。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;02&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&lt;strong&gt;内容构成&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先大家都知道的一点是，不要重复复述简历上的个人介绍，这就不多说了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外需要注意的是，不同的工作时长自我介绍的侧重点应该是不同的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如你作为一个拥有8年丰富工作经验的人，做自我介绍的时候还在花不少时间突出自己学习能力强、抗压能力强，其实反而会起反面效果（实际这样的人还不少）。而更应该突出自己解决问题的能力和所创造的价值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于不同资历的人需要阐述的内容组成，我大概划分了三个维度做了一个表供你参考，三个维度分别是：行业经历、业绩体现、可塑性。你在准备内容的时候可以参考这个比例来。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.410958904109589&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oB5bd6W6hI1YM0H3SbSu8C7sic16c1JslJOpa23NQ6oBgCQR9plLChJOWgXcvt58R9dzW4wYCmI2YMmkAD78CRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1022&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如果你对自己的能力有自信，也可以提高一级来写。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;03&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&lt;strong&gt;精简内容&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体的内容信息就像写作文、写报告一样，内容太拖沓，会让人觉得你的逻辑不清晰，概括能力差，没有重点。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;要知道，对逻辑能力的印象其实就是在别人眼里你是不是一个聪明人。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，尽量把不影响信息完整性的那部分文字删掉，比如一些空话（只说自己学习能力强，并不举例），一些修饰性形容词什么的。然后再把剩下的内容按照某个顺序组织起来，并且要把why和how讲清楚。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;04&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&lt;strong&gt;量化相关指标&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数字自己会说话，能量化的地方尽量去量化，这样可以减少很多冗长的文字描述。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&lt;strong&gt;注意做好内容承接准备，不要给自己挖坑&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;很多时候，面试官在你的自我介绍中发现了一个亮点，他后续会基于这个亮点展开来向你提问。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，在自我介绍部分你千万不能吹牛，不要把别人的业绩说成你的，否则面试官问你是怎么做到的，具体的细节是什么？你却支支吾吾的，那基本就要请你回家了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;06&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&lt;strong&gt;语气不要过于谦虚&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这点对有一定工作年限的小伙伴非常重要。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;职场新人谦虚一点也可以理解，但是作为老人，如果过度的谦虚，会让人觉得，你要么不够自信，在以后的工作中会出现沟通不畅的问题；要么是自身能力达不到你阐述的和简历上写的，心虚。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;好了，意义和要点都清楚了，那么具体该怎么准备内容呢？你可以试试&lt;/span&gt;&lt;strong&gt;&lt;span&gt;「PME」框架&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;「PME」中的三个字母分别表示热情（Passion）、匹配（Match）、出众（Excellence）。思路是，先展现出你对这个行业、这个岗位的「热情」，然后证明你是「匹配」这个岗位的，最后再亮出自己「出众」的地方说明比其他候选人更棒。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;体现Passion，你可以从下面三个方向入手：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你对该领域有深入的体验或研究&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。比如说你就读的是计算机相关的专业、学习过十几个「某时间」的课程等、看多二十多本XX领域的书。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;你时刻关注该领域动态&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。比如说你经常浏览XX网站、XX社区，会对各个大厂新出的框架花几天时间去折腾一下。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你的兴趣爱好相近&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。比如你平常会写点东西，会把所学到的知识重新整理后发表在自己的博客上。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;体现Match，需要从你过去的经历中做两件事情：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;体现Excellence就是做好一点：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;用数字量化&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。比如，你通过引入了某个技术框架，并做了二次改造，使得某个系统的负载上限提高了3倍，资源消耗降低 了50%。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;体现Excellence是最后一部分内容，也是最重要的内容，因为这里说的内容是在表达你比别人牛逼，所以&lt;/span&gt;&lt;strong&gt;&lt;span&gt;很容易成为面试官接下去发问的点&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，不过你这也是一个你引导面试导向的一个机会，所以要把握好。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后来举个例子，感受一下。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;212&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;我叫 XX，就读于 XX 大学 XX 专业。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;我每周会写博客，会将当周从书本或者「某时间」的课程上学到的知识进行整理，并用自己的语言写出来分享给所有人，对软件开发行业充满兴趣。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;我了解到贵公司有对分布式系统方面的要求，恰好我在上一家公司的系统就是分布式的。我在其中工作了3年，主导过多项核心技术的落地。比如在XX年，我引入了XXX框架并做了二次改造，使得某个系统的负载上限提高了3倍，资源消耗降低 了50%。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;所以对于胜任当前的岗位很有信心。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;好了，以后可千万不能再做下面这样的自我介绍了哦。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;98&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;我叫 XX，就读于 XX 大学 XX 专业，之前是 XX 公司的高级软件工程师。我在该公司负责的工作是A系统、B系统、C系统、……的开发。现在应聘贵公司高级软件工程师岗位，希望能得到这个宝贵的机会，非常感谢！&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;好了，总结一下。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这篇呢，Z哥和你聊的是面试的时候自我介绍这件事。虽然这是一件很小的事，但是由于「&lt;/span&gt;&lt;strong&gt;&lt;span&gt;首因效应&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;」的存在，它对你能否拿到offer起到的作用可不小。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;自我介绍的意义其实除了展现你自己之外，大多数时候也是面试官熟悉你简历的时候，所以面对这样一个一心二用的人，你要注意以下六个要点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;时长控制。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;内容构成。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;精简内容。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;量化相关指标。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;注意做好内容承接准备，不要给自己挖坑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;语气不好过于谦虚。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你还是无从下手，可以使用「PME」结构来试试。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;就这么多，希望对你有所帮助。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原创不易，如果你觉得这篇文章还不错，就「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」或者「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;分享&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」一下吧。鼓励我的创作 ：）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.4428822495606327&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/oB5bd6W6hI1Xrkr3iaFRP5fErfmjHqlBw160icnia8yicWBlicnPEfqGE80alzGl9FLj6FxyuibIuliceoH9zicibj95loQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1138&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你有关于软件架构、分布式系统、产品、运营的困惑&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以试试点击「&lt;strong&gt;阅读原文&lt;/strong&gt;」&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>59f4830fb3996eee82cb7ba983cb6103</guid>
<title>Golang 单元测试详尽指引</title>
<link>https://toutiao.io/k/aio979l</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-ratio=&quot;0.1575&quot; data-w=&quot;400&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;文末有彩蛋。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;作者：yukkizhang，腾讯 CSIG 专项技术测试工程师&lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;148&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;span&gt;本篇文章站在测试的角度，旨在给行业平台乃至其他团队的开发同学，进行一定程度的单元测试指引，让其能够快速的明确单元测试的方式方法。 本文主要从单元测试出发，对Golang的单元测试框架、Stub/Mock框架进行简单的介绍和选型推荐，列举出几种针对于Mock场景的最佳实践，并以具体代码示例进行说明。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、单元测试&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 单元测试是什么&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;单元&lt;/strong&gt;是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类、超类、抽象类等中的方法。&lt;strong&gt;单元测试&lt;/strong&gt;就是软件开发中对最小单位进行正确性检验的测试工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同地方对单元测试有的定义可能会有所不同，但有一些基本共识：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;单元测试是比较&lt;strong&gt;底层&lt;/strong&gt;的，关注代码的&lt;strong&gt;局部&lt;/strong&gt;而不是整体。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单元测试是&lt;strong&gt;开发人员&lt;/strong&gt;在写代码时候写的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单元测试需要比其他测试运行得&lt;strong&gt;快&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 单元测试的意义&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;提高代码质量&lt;/strong&gt;。代码测试都是为了帮助开发人员发现问题从而解决问题，提高代码质量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;尽早发现问题&lt;/strong&gt;。问题越早发现，解决的难度和成本就越低。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;保证重构正确性&lt;/strong&gt;。随着功能的增加，重构（修改老代码）几乎是无法避免的。很多时候我们不敢重构的原因，就是担心其它模块因为依赖它而不工作。有了单元测试，只要在改完代码后运行一下单测就知道改动对整个系统的影响了，从而可以让我们放心的重构代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;简化调试过程&lt;/strong&gt;。单元测试让我们可以轻松地知道是哪一部分代码出了问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;简化集成过程&lt;/strong&gt;。由于各个单元已经被测试，在集成过程中进行的后续测试会更加容易。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;优化代码设计&lt;/strong&gt;。编写测试用例会迫使开发人员仔细思考代码的设计和必须完成的工作，有利于开发人员加深对代码功能的理解，从而形成更合理的设计和结构。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;单元测试是最好的文档&lt;/strong&gt;。单元测试覆盖了接口的所有使用方法，是最好的示例代码。而真正的文档包括注释很有可能和代码不同步，并且看不懂。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 单元测试用例编写的原则&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 理论原则&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;快&lt;/strong&gt;。单元测试是回归测试，可以在开发过程的任何时候运行，因此运行速度必须快&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;一致性&lt;/strong&gt;。代码没有改变的情况下，每次运行得结果应该保持确定且一致&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;原子性&lt;/strong&gt;。结果只有两种情况：Pass / Fail&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;用例独立&lt;/strong&gt;。执行顺序不影响；用例间没有状态共享或者依赖关系；用例没有副作用（执行前后环境状态一致）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;单一职责&lt;/strong&gt;。一个用例只负责一个场景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;隔离&lt;/strong&gt;。功能可能依赖于数据库、web 访问、环境变量、系统时间等；一个单元可能依赖于另一部分代码，用例应该解除这些依赖&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;可读性&lt;/strong&gt;。用例的名称、变量名等应该具有可读性，直接表现出该测试的目标&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;自动化&lt;/strong&gt;。单元测试需要全自动执行。测试程序不应该有用户输入；测试结果应该能直接被电脑获取，不应该由人来判断。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 规约原则&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际编写代码过程中，不同的团队会有不同团队的风格，只要团队内部保持有一定的规约即可，比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;单元测试文件名必须以 xxx_test.go 命名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方法必须是 TestXxx 开头，建议风格保持一致（驼峰或者下划线）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方法参数必须 t *testing.T&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;测试文件和被测试文件必须在一个包中&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3 衡量原则&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单元测试是要写额外的代码的，这对开发同学的也是一个不小的工作负担，在一些项目中，我们合理的评估单元测试的编写，我认为我们不能走极端，当然理论上来说全写肯定时好的，但是从成本，效率上来说我们必须做出权衡，衡量原则如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;优先编写核心组件和逻辑模块的测试用例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;逻辑类似的组件如果存在多个，优先编写其中一种逻辑组件的测试用例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发现 Bug 时一定先编写测试用例进行 Debug&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关键 util 工具类要编写测试用例，这些 util 工具适用的很频繁，所以这个原则也叫做热点原则，和第 1 点相呼应。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;测试用户应该独立，一个文件对应一个，而且不同的测试用例之间不要互相依赖。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;测试用例的保持更新&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 单元测试用例设计方法&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 规范(规格)导出法&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;规范(规格)导出法&lt;/strong&gt;将需求”翻译“成测试用例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，一个函数的设计需求如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;函数：一个计算平方根的函数
输入：实数
输出：实数
要求：当输入一个 0 或者比 0 大的实数时，返回其正的平方根；当输入一个小于 0 的实数时，显示错误信息“平方根非法—输入之小于 0”，并返回 0；库函数&lt;code&gt;printf()&lt;/code&gt;可以用来输出错误信息。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个规范中有 3 个陈述，可以用两个测试用例来对应:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;测试用例 1：输入 4，输出 2。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;测试用例 2：输入-1，输出 0。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 等价类划分法&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;等价类划分法&lt;/strong&gt;假定某一特定的等价类中的所有值对于测试目的来说是等价的，所以在每个等价类中找一个之作为测试用例。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;按照 [输入条件][有效等价类][无效等价类] 建立等价类表，列出所有划分出的等价类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为每一个等价类规定一个唯一的编号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖地有效等价类。重复这一步，直到所有的有效等价类都被覆盖为止&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类。重复这一步，直到所有的无效等价类都被覆盖为止&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，注册邮箱时要求用 6~18 个字符，可使用字母、数字、下划线，需以字母开头。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvatjQUlWX0DiaibMDUm1NHKsKUEicAo3r76v7gQkPDUicEQYEJlNCnepf7X4v46yNuM6WPvicH0M5LMv9jQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2015&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试用例：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.44285007422068284&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvatjQUlWX0DiaibMDUm1NHKsKUw6dOMMDxtgLwWQ1njBjHu8C6eHfs1bveMAIPnmaE6QEZw2BtorIhMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2021&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3 边界值分析法&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;边界值分析法&lt;/strong&gt;使用与等价类测试方法相同的等价类划分，只是边界值分析假定
错误更多地存在于两个划分的边界上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;边界值测试在软件变得复杂的时候也会变得不实用。边界值测试对于非向量类型的值(如枚举类型的值)也没有意义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，和&lt;strong&gt;4.1&lt;/strong&gt;相同的需求：划分(ii)的边界为 0 和最大正实数；划分(i)的边界为最小负实数和 0。由此得到以下测试用例：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;输入 {最小负实数}&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;输入 {绝对值很小的负数}&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;输入 0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;输入 {绝对值很小的正数}&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;输入 {最大正实数}&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4 基本路径测试法&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;基本路径测试法&lt;/strong&gt;是在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。设计出的测试用例要保证在测试中程序的每个可执行语句至少执行一次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本路径测试法的基本步骤：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;程序的控制流图：描述程序控制流的一种图示方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;程序圈复杂度：McCabe 复杂性度量。从程序的环路复杂性可导出程序基本路径集合中的独立路径条数，这是确定程序中每个可执行语句至少执行一次所必须的测试用例数目的上界。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;导出测试用例：根据圈复杂度和程序结构设计用例数据输入和预期结果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;准备测试用例：确保基本路径集中的每一条路径的执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、Golang 的测试框架&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Golang 有这几种比较常见的测试框架：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2018664047151277&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvatjQUlWX0DiaibMDUm1NHKsKUoxNBfu7ne4Sic3qibwHvU0clTNngNwgtlJp9dpRxXHslVORnQzYpNNKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2036&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从测试用例编写的简易难度上来说：testify 比 GoConvey 简单；GoConvey 比 Go 自带的 testing 包简单。　　但在测试框架的选择上，我们更推荐 GoConvey。因为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;GoConvey 和其他 Stub/Mock 框架的兼容性相比 Testify 更好。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Testify 自带 Mock 框架，但是用这个框架 Mock 类需要自己写。像这样重复有规律的部分在 GoMock 中是一键自动生成的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. Go 自带的 testing 包&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;testing&lt;/code&gt; 为 Go 语言 package 提供自动化测试的支持。通过 &lt;code&gt;go test&lt;/code&gt; 命令，能够自动执行如下形式的任何函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestXxx&lt;/span&gt;&lt;span&gt;(*testing.T)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：&lt;code&gt;Xxx&lt;/code&gt; 可以是任何字母数字字符串，但是第一个字母不能是小写字母。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这些函数中，使用 &lt;code&gt;Error&lt;/code&gt;、&lt;code&gt;Fail&lt;/code&gt; 或相关方法来发出失败信号。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要编写一个新的测试套件，需要创建一个名称以 _test.go 结尾的文件，该文件包含 &lt;code&gt;TestXxx&lt;/code&gt; 函数，如上所述。将该文件放在与被测试文件相同的包中。该文件将被排除在正常的程序包之外，但在运行 &lt;code&gt;go test&lt;/code&gt; 命令时将被包含。有关详细信息，请运行 &lt;code&gt;go help test&lt;/code&gt; 和 &lt;code&gt;go help testflag&lt;/code&gt; 了解。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 第一个例子&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;被测代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Fib&lt;/span&gt;&lt;span&gt;(n &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; n &amp;lt; &lt;span&gt;2&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; n&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Fib(n&lt;span&gt;-1&lt;/span&gt;) + Fib(n&lt;span&gt;-2&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestFib&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; (&lt;br/&gt;        in       = &lt;span&gt;7&lt;/span&gt;&lt;br/&gt;        expected = &lt;span&gt;13&lt;/span&gt;&lt;br/&gt;    )&lt;br/&gt;    actual := Fib(in)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; actual != expected {&lt;br/&gt;        t.Errorf(&lt;span&gt;&quot;Fib(%d) = %d; expected %d&quot;&lt;/span&gt;, in, actual, expected)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行 &lt;code&gt;go test .&lt;/code&gt; ，输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; go &lt;span&gt;test&lt;/span&gt; .&lt;/span&gt;&lt;br/&gt;ok      chapter09/testing    0.007s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表示测试通过。我们将 &lt;code&gt;Sum&lt;/code&gt; 函数改为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Fib&lt;/span&gt;&lt;span&gt;(n &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; n &amp;lt; &lt;span&gt;2&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; n&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Fib(n&lt;span&gt;-1&lt;/span&gt;) + Fib(n&lt;span&gt;-1&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再执行 &lt;code&gt;go test .&lt;/code&gt; ，输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ go test .&lt;br/&gt;--- FAIL: TestSum (&lt;span&gt;0.00&lt;/span&gt;s)&lt;br/&gt;    t_test.go:&lt;span&gt;16&lt;/span&gt;: Fib(&lt;span&gt;10&lt;/span&gt;) = &lt;span&gt;64&lt;/span&gt;; expected &lt;span&gt;13&lt;/span&gt;&lt;br/&gt;FAIL&lt;br/&gt;FAIL    chapter09/testing    &lt;span&gt;0.009&lt;/span&gt;s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 Table-Driven 测试&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Table-Driven 的方式将多个 case 在同一个测试函数中测到：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestFib&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;var&lt;/span&gt; fibTests = []&lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;       in       &lt;span&gt;int&lt;/span&gt; &lt;span&gt;// input&lt;/span&gt;&lt;br/&gt;       expected &lt;span&gt;int&lt;/span&gt; &lt;span&gt;// expected result&lt;/span&gt;&lt;br/&gt;   }{&lt;br/&gt;       {&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;},&lt;br/&gt;       {&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;},&lt;br/&gt;       {&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;},&lt;br/&gt;       {&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;},&lt;br/&gt;       {&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;},&lt;br/&gt;       {&lt;span&gt;6&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;},&lt;br/&gt;       {&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;13&lt;/span&gt;},&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; _, tt := &lt;span&gt;range&lt;/span&gt; fibTests {&lt;br/&gt;       actual := Fib(tt.in)&lt;br/&gt;       &lt;span&gt;if&lt;/span&gt; actual != tt.expected {&lt;br/&gt;           t.Errorf(&lt;span&gt;&quot;Fib(%d) = %d; expected %d&quot;&lt;/span&gt;, tt.in, actual, tt.expected)&lt;br/&gt;       }&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter09/09.1.html&quot; data-linktype=&quot;2&quot;&gt;Go 自带 testing 包的更多用法&lt;/a&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. GoConvey：简单断言&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Convey 适用于书写单元测试用例，并且可以兼容到 testing 框架中，&lt;code&gt;go test&lt;/code&gt;命令或者使用&lt;code&gt;goconvey&lt;/code&gt;命令访问&lt;code&gt;localhost:8080&lt;/code&gt;的 Web 测试界面都可以查看测试结果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Convey(&lt;span&gt;&quot;Convey return : &quot;&lt;/span&gt;, t, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        So(...)&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般 Convey 用&lt;code&gt;So&lt;/code&gt;来进行断言，断言的方式可以传入一个函数，或者使用自带的&lt;code&gt;ShouldBeNil&lt;/code&gt;、&lt;code&gt;ShouldEqual&lt;/code&gt;、&lt;code&gt;ShouldNotBeNil&lt;/code&gt;函数等。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1. 基本用法&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;被测代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;StringSliceEqual&lt;/span&gt;&lt;span&gt;(a, b []&lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(a) != &lt;span&gt;len&lt;/span&gt;(b) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (a == &lt;span&gt;nil&lt;/span&gt;) != (b == &lt;span&gt;nil&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i, v := &lt;span&gt;range&lt;/span&gt; a {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; v != b[i] {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;testing&quot;&lt;/span&gt;&lt;br/&gt;    . &lt;span&gt;&quot;github.com/smartystreets/goconvey/convey&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestStringSliceEqual&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    Convey(&lt;span&gt;&quot;TestStringSliceEqual的描述&quot;&lt;/span&gt;, t, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        a := []&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;hello&quot;&lt;/span&gt;, &lt;span&gt;&quot;goconvey&quot;&lt;/span&gt;}&lt;br/&gt;        b := []&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;hello&quot;&lt;/span&gt;, &lt;span&gt;&quot;goconvey&quot;&lt;/span&gt;}&lt;br/&gt;        So(StringSliceEqual(a, b), ShouldBeTrue)&lt;br/&gt;    })&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2. 双层嵌套&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;testing&quot;&lt;/span&gt;&lt;br/&gt;    . &lt;span&gt;&quot;github.com/smartystreets/goconvey/convey&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestStringSliceEqual&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    Convey(&lt;span&gt;&quot;TestStringSliceEqual&quot;&lt;/span&gt;, t, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        Convey(&lt;span&gt;&quot;true when a != nil  &amp;amp;&amp;amp; b != nil&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;            a := []&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;hello&quot;&lt;/span&gt;, &lt;span&gt;&quot;goconvey&quot;&lt;/span&gt;}&lt;br/&gt;            b := []&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;hello&quot;&lt;/span&gt;, &lt;span&gt;&quot;goconvey&quot;&lt;/span&gt;}&lt;br/&gt;            So(StringSliceEqual(a, b), ShouldBeTrue)&lt;br/&gt;        })&lt;br/&gt;&lt;br/&gt;        Convey(&lt;span&gt;&quot;true when a ＝= nil  &amp;amp;&amp;amp; b ＝= nil&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;            So(StringSliceEqual(&lt;span&gt;nil&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;), ShouldBeTrue)&lt;br/&gt;        })&lt;br/&gt;    })&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内层的 Convey 不需要再传入 t *testing.T 参数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://www.jianshu.com/p/e3b2b1194830&quot; data-linktype=&quot;2&quot;&gt;GoConvey 的更多用法&lt;/a&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. testify&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;testify 提供了 assert 和 require，让你可以简洁地写出&lt;code&gt;if xxx { t.Fail() }&lt;/code&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1. assert&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestSomething&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;//断言相等&lt;/span&gt;&lt;br/&gt;  assert.Equal(t, &lt;span&gt;123&lt;/span&gt;, &lt;span&gt;123&lt;/span&gt;, &lt;span&gt;&quot;they should be equal&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;//断言不相等&lt;/span&gt;&lt;br/&gt;  assert.NotEqual(t, &lt;span&gt;123&lt;/span&gt;, &lt;span&gt;456&lt;/span&gt;, &lt;span&gt;&quot;they should not be equal&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;//对于nil的断言&lt;/span&gt;&lt;br/&gt;  assert.Nil(t, object)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;//对于非nil的断言&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; assert.NotNil(t, object) {&lt;br/&gt; &lt;span&gt;// now we know that object isn&#x27;t nil, we are safe to make&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// further assertions without causing any errors&lt;/span&gt;&lt;br/&gt; assert.Equal(t, &lt;span&gt;&quot;Something&quot;&lt;/span&gt;, object.Value)&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2. require&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;require 和 assert 失败、成功条件完全一致，区别在于 assert 只是返回布尔值（true、false），而 require 不符合断言时，会中断当前运行&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3. 常用的函数&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Equal&lt;/span&gt;&lt;span&gt;(t TestingT, expected, actual &lt;span&gt;interface&lt;/span&gt;{}, msgAndArgs ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NotEqual&lt;/span&gt;&lt;span&gt;(t TestingT, expected, actual &lt;span&gt;interface&lt;/span&gt;{}, msgAndArgs ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Nil&lt;/span&gt;&lt;span&gt;(t TestingT, object &lt;span&gt;interface&lt;/span&gt;{}, msgAndArgs ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NotNil&lt;/span&gt;&lt;span&gt;(t TestingT, object &lt;span&gt;interface&lt;/span&gt;{}, msgAndArgs ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Empty&lt;/span&gt;&lt;span&gt;(t TestingT, object &lt;span&gt;interface&lt;/span&gt;{}, msgAndArgs ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NotEmpty&lt;/span&gt;&lt;span&gt;(t TestingT, object &lt;span&gt;interface&lt;/span&gt;{}, msgAndArgs ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NoError&lt;/span&gt;&lt;span&gt;(t TestingT, err error, msgAndArgs ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;&lt;span&gt;(t TestingT, err error, msgAndArgs ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Zero&lt;/span&gt;&lt;span&gt;(t TestingT, i &lt;span&gt;interface&lt;/span&gt;{}, msgAndArgs ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NotZero&lt;/span&gt;&lt;span&gt;(t TestingT, i &lt;span&gt;interface&lt;/span&gt;{}, msgAndArgs ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;span&gt;(t TestingT, value &lt;span&gt;bool&lt;/span&gt;, msgAndArgs ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;&lt;span&gt;(t TestingT, value &lt;span&gt;bool&lt;/span&gt;, msgAndArgs ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Len&lt;/span&gt;&lt;span&gt;(t TestingT, object &lt;span&gt;interface&lt;/span&gt;{}, length &lt;span&gt;int&lt;/span&gt;, msgAndArgs ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NotContains&lt;/span&gt;&lt;span&gt;(t TestingT, s, contains &lt;span&gt;interface&lt;/span&gt;{}, msgAndArgs ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NotContains&lt;/span&gt;&lt;span&gt;(t TestingT, s, contains &lt;span&gt;interface&lt;/span&gt;{}, msgAndArgs ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Subset&lt;/span&gt;&lt;span&gt;(t TestingT, list, subset &lt;span&gt;interface&lt;/span&gt;{}, msgAndArgs ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;(ok &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NotSubset&lt;/span&gt;&lt;span&gt;(t TestingT, list, subset &lt;span&gt;interface&lt;/span&gt;{}, msgAndArgs ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;(ok &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;FileExists&lt;/span&gt;&lt;span&gt;(t TestingT, path &lt;span&gt;string&lt;/span&gt;, msgAndArgs ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;DirExists&lt;/span&gt;&lt;span&gt;(t TestingT, path &lt;span&gt;string&lt;/span&gt;, msgAndArgs ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://s0godoc0org.icopy.site/github.com/stretchr/testify&quot; data-linktype=&quot;2&quot;&gt;testify 的更多用法&lt;/a&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、Stub/Mock 框架&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Golang 有以下 Stub/Mock 框架：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，GoConvey 可以和 GoStub、GoMock、Monkey 中的一个或多个搭配使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Testify 本身有自己的 Mock 框架，可以用自己的也可以和这里列出来的 Stub/Mock 框架搭配使用。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. GoStub&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GoStub 框架的使用场景很多，依次为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;基本场景：为一个全局变量打桩&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基本场景：为一个函数打桩&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基本场景：为一个过程打桩&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;复合场景：由任意相同或不同的基本场景组合而成&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1. 为一个全局变量打桩&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设 num 为被测函数中使用的一个全局整型变量，当前测试用例中假定 num 的值大于 100，比如为 150，则打桩的代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;stubs := Stub(&amp;amp;num, &lt;span&gt;150&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;defer&lt;/span&gt; stubs.Reset()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;stubs 是 GoStub 框架的函数接口 Stub 返回的对象，该对象有 Reset 操作，即将全局变量的值恢复为原值。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2. 为一个函数打桩&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们产品的既有代码中有下面的函数定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Exec&lt;/span&gt;&lt;span&gt;(cmd &lt;span&gt;string&lt;/span&gt;, args ...&lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;string&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以对 Exec 函数打桩，代码如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;stubs := StubFunc(&amp;amp;Exec,&lt;span&gt;&quot;xxx-vethName100-yyy&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;defer&lt;/span&gt; stubs.Reset()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3. 为一个过程打桩&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个函数没有返回值时，该函数我们一般称为过程。很多时候，我们将资源清理类函数定义为过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们对过程 DestroyResource 的打桩代码为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;stubs := StubFunc(&amp;amp;DestroyResource)&lt;br/&gt;&lt;span&gt;defer&lt;/span&gt; stubs.Reset()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://www.jianshu.com/p/70a93a9ed186&quot; data-linktype=&quot;2&quot;&gt;GoStub 的更多用法以及 GoStub+GoConvey 的组合使用方法&lt;/a&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. GoMock&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GoMock 是由 Golang 官方开发维护的测试框架，实现了较为完整的基于 interface 的 Mock 功能，能够与 Golang 内置的 testing 包良好集成，也能用于其它的测试环境中。GoMock 测试框架包含了 GoMock 包和 mockgen 工具两部分，其中 GoMock 包完成对桩对象生命周期的管理，mockgen 工具用来生成 interface 对应的 Mock 类源文件。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1. 定义一个接口&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先定义一个打算 mock 的接口 Repository。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Repository 是领域驱动设计中战术设计的一个元素，用来存储领域对象，一般将对象持久化在数据库中，比如 Aerospike，Redis 或 Etcd 等。对于领域层来说，只知道对象在 Repository 中维护，并不 care 对象到底在哪持久化，这是基础设施层的职责。微服务在启动时，根据部署参数实例化 Repository 接口，比如 AerospikeRepository，RedisRepository 或 EtcdRepository。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; db&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Repository &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt;    Create(key &lt;span&gt;string&lt;/span&gt;, value []&lt;span&gt;byte&lt;/span&gt;) error&lt;br/&gt;    Retrieve(key &lt;span&gt;string&lt;/span&gt;) ([]&lt;span&gt;byte&lt;/span&gt;, error)&lt;br/&gt;    Update(key &lt;span&gt;string&lt;/span&gt;, value []&lt;span&gt;byte&lt;/span&gt;) error&lt;br/&gt;    Delete(key &lt;span&gt;string&lt;/span&gt;) error&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2. 生成 mock 类文件&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这下该 mockgen 工具登场了。mockgen 有两种操作模式：源文件和反射。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源文件模式通过一个包含 interface 定义的文件生成 mock 类文件，它通过 -source 标识生效，-imports 和 -aux_files 标识在这种模式下也是有用的。举例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mockgen -source=foo.go [other options]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反射模式通过构建一个程序用反射理解接口生成一个 mock 类文件，它通过两个非标志参数生效：导入路径和用逗号分隔的符号列表（多个 interface）。举例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mockgen database/sql/driver Conn,Driver&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成的 mock_repository.go 文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Automatically generated by MockGen. DO NOT EDIT!&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Source: infra/db (interfaces: Repository)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;package&lt;/span&gt; mock_db&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    gomock &lt;span&gt;&quot;github.com/golang/mock/gomock&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// MockRepository is a mock of Repository interface&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; MockRepository &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    ctrl     *gomock.Controller&lt;br/&gt;    recorder *MockRepositoryMockRecorder&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// MockRepositoryMockRecorder is the mock recorder for MockRepository&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; MockRepositoryMockRecorder &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    mock *MockRepository&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// NewMockRepository creates a new mock instance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewMockRepository&lt;/span&gt;&lt;span&gt;(ctrl *gomock.Controller)&lt;/span&gt; *&lt;span&gt;MockRepository&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    mock := &amp;amp;MockRepository{ctrl: ctrl}&lt;br/&gt;    mock.recorder = &amp;amp;MockRepositoryMockRecorder{mock}&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; mock&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// EXPECT returns an object that allows the caller to indicate expected use&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(_m *MockRepository)&lt;/span&gt; &lt;span&gt;EXPECT&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;MockRepositoryMockRecorder&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; _m.recorder&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Create mocks base method&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(_m *MockRepository)&lt;/span&gt; &lt;span&gt;Create&lt;/span&gt;&lt;span&gt;(_param0 &lt;span&gt;string&lt;/span&gt;, _param1 []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    ret := _m.ctrl.Call(_m, &lt;span&gt;&quot;Create&quot;&lt;/span&gt;, _param0, _param1)&lt;br/&gt;    ret0, _ := ret[&lt;span&gt;0&lt;/span&gt;].(error)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; ret0&lt;br/&gt;}&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3. 使用 mock 对象进行打桩测试&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3.1. 导入 mock 相关的包&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;testing&quot;&lt;/span&gt;&lt;br/&gt;    . &lt;span&gt;&quot;github.com/golang/mock/gomock&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;test/mock/db&quot;&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3.2. mock 控制器&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mock 控制器通过 NewController 接口生成，是 mock 生态系统的顶层控制，它定义了 mock 对象的作用域和生命周期，以及它们的期望。多个协程同时调用控制器的方法是安全的。当用例结束后，控制器会检查所有剩余期望的调用是否满足条件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;控制器的代码如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ctrl := NewController(t)&lt;br/&gt;&lt;span&gt;defer&lt;/span&gt; ctrl.Finish()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mock 对象创建时需要注入控制器，如果有多个 mock 对象则注入同一个控制器，如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ctrl := NewController(t)&lt;br/&gt;&lt;span&gt;defer&lt;/span&gt; ctrl.Finish()&lt;br/&gt;mockRepo := mock_db.NewMockRepository(ctrl)&lt;br/&gt;mockHttp := mock_api.NewHttpMethod(ctrl)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3.3. mock 对象的行为注入&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 mock 对象的行为注入，控制器是通过 map 来维护的，一个方法对应 map 的一项。因为一个方法在一个用例中可能调用多次，所以 map 的值类型是数组切片。当 mock 对象进行行为注入时，控制器会将行为 Add。当该方法被调用时，控制器会将该行为 Remove。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设有这样一个场景：先 Retrieve 领域对象失败，然后 Create 领域对象成功，再次 Retrieve 领域对象就能成功。这个场景对应的 mock 对象的行为注入代码如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mockRepo.EXPECT().Retrieve(Any()).Return(&lt;span&gt;nil&lt;/span&gt;, ErrAny)&lt;br/&gt;mockRepo.EXPECT().Create(Any(), Any()).Return(&lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;mockRepo.EXPECT().Retrieve(Any()).Return(objBytes, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;objBytes 是领域对象的序列化结果，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;obj := Movie{...}&lt;br/&gt;objBytes, err := json.Marshal(obj)&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当批量 Create 对象时，可以使用 Times 关键字：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mockRepo.EXPECT().Create(Any(), Any()).Return(&lt;span&gt;nil&lt;/span&gt;).Times(&lt;span&gt;5&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当批量 Retrieve 对象时，需要注入多次 mock 行为:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mockRepo.EXPECT().Retrieve(Any()).Return(objBytes1, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;mockRepo.EXPECT().Retrieve(Any()).Return(objBytes2, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;mockRepo.EXPECT().Retrieve(Any()).Return(objBytes3, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;mockRepo.EXPECT().Retrieve(Any()).Return(objBytes4, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;mockRepo.EXPECT().Retrieve(Any()).Return(objBytes5, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://www.jianshu.com/p/f4e773a1b11f&quot; data-linktype=&quot;2&quot;&gt;GoMock 的更多用法以及 GoStub+GoConvey+GoMock 的组合使用方法&lt;/a&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. Monkey&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，我们已经知道：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;全局变量可通过 GoStub 框架打桩&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;过程可通过 GoStub 框架打桩&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;函数可通过 GoStub 框架打桩&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;interface 可通过 GoMock 框架打桩&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但还有两个问题比较棘手：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;方法（成员函数）无法通过 GoStub 框架打桩，当产品代码的 OO 设计比较多时，打桩点可能离被测函数比较远，导致 UT 用例写起来比较痛&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;过程或函数通过 GoStub 框架打桩时，对产品代码有侵入性&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Monkey 是 Golang 的一个猴子补丁（monkeypatching）框架，在运行时通过汇编语句重写可执行文件，将待打桩函数或方法的实现跳转到桩实现，原理和热补丁类似。通过 Monkey，我们可以解决函数或方法的打桩问题，但 Monkey 不是线程安全的，不要将 Monkey 用于并发的测试中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Monkey 框架的使用场景很多，依次为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;基本场景：为一个函数打桩&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基本场景：为一个过程打桩&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基本场景：为一个方法打桩&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;复合场景：由任意相同或不同的基本场景组合而成&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;特殊场景：桩中桩的一个案例&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;另有 GoMonkey 框架https://github.com/agiledragon/gomonkey，对比Monkey来说，写法更简单，有兴趣的读者可以尝试使用。&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1. 为一个函数打桩&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Exec 是 infra 层的一个操作函数，实现很简单，代码如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Exec&lt;/span&gt;&lt;span&gt;(cmd &lt;span&gt;string&lt;/span&gt;, args ...&lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;string&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    cmdpath, err := exec.LookPath(cmd)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        fmt.Errorf(&lt;span&gt;&quot;exec.LookPath err: %v, cmd: %s&quot;&lt;/span&gt;, err, cmd)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;, infra.ErrExecLookPathFailed&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; output []&lt;span&gt;byte&lt;/span&gt;&lt;br/&gt;    output, err = exec.Command(cmdpath, args...).CombinedOutput()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        fmt.Errorf(&lt;span&gt;&quot;exec.Command.CombinedOutput err: %v, cmd: %s&quot;&lt;/span&gt;, err, cmd)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;, infra.ErrExecCombinedOutputFailed&lt;br/&gt;    }&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;CMD[&quot;&lt;/span&gt;, cmdpath, &lt;span&gt;&quot;]ARGS[&quot;&lt;/span&gt;, args, &lt;span&gt;&quot;]OUT[&quot;&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;(output), &lt;span&gt;&quot;]&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;(output), &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Monkey 的 API 非常简单和直接，我们直接看打桩代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;testing&quot;&lt;/span&gt;&lt;br/&gt;    . &lt;span&gt;&quot;github.com/smartystreets/goconvey/convey&quot;&lt;/span&gt;&lt;br/&gt;    . &lt;span&gt;&quot;github.com/bouk/monkey&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;infra/osencap&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; any = &lt;span&gt;&quot;any&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestExec&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    Convey(&lt;span&gt;&quot;test has digit&quot;&lt;/span&gt;, t, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        Convey(&lt;span&gt;&quot;for succ&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;            outputExpect := &lt;span&gt;&quot;xxx-vethName100-yyy&quot;&lt;/span&gt;&lt;br/&gt;            guard := Patch(&lt;br/&gt;             osencap.Exec,&lt;br/&gt;             &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(_ &lt;span&gt;string&lt;/span&gt;, _ ...&lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;string&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;                 &lt;span&gt;return&lt;/span&gt; outputExpect, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;             })&lt;br/&gt;            &lt;span&gt;defer&lt;/span&gt; guard.Unpatch()&lt;br/&gt;            output, err := osencap.Exec(any, any)&lt;br/&gt;            So(output, ShouldEqual, outputExpect)&lt;br/&gt;            So(err, ShouldBeNil)&lt;br/&gt;        })&lt;br/&gt;    })&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Patch 是 Monkey 提供给用户用于函数打桩的 API：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一个参数是目标函数的函数名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二个参数是桩函数的函数名，习惯用法是匿名函数或闭包&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回值是一个 PatchGuard 对象指针，主要用于在测试结束时删除当前的补丁&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2. 为一个过程打桩&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个函数没有返回值时，该函数我们一般称为过程。很多时候，我们将资源清理类函数定义为过程。我们对过程 DestroyResource 的打桩代码为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;guard := Patch(DestroyResource, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(_ &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;})&lt;br/&gt;&lt;span&gt;defer&lt;/span&gt; guard.Unpatch()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3. 为一个方法打桩&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当微服务有多个实例时，先通过 Etcd 选举一个 Master 实例，然后 Master 实例为所有实例较均匀的分配任务，并将任务分配结果 Set 到 Etcd，最后 Master 和 Node 实例 Watch 到任务列表，并过滤出自身需要处理的任务列表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们用类 Etcd 的方法 Get 来模拟获取任务列表的功能，入参为 instanceId：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Etcd &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(e *Etcd)&lt;/span&gt; &lt;span&gt;Get&lt;/span&gt;&lt;span&gt;(instanceId &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; []&lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    taskList := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; taskList&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们对 Get 方法的打桩代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; e *Etcd&lt;br/&gt;guard := PatchInstanceMethod(&lt;br/&gt; reflect.TypeOf(e),&lt;br/&gt; &lt;span&gt;&quot;Get&quot;&lt;/span&gt;,&lt;br/&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(_ *Etcd, _ &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; []&lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; []&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;task1&quot;&lt;/span&gt;, &lt;span&gt;&quot;task5&quot;&lt;/span&gt;, &lt;span&gt;&quot;task8&quot;&lt;/span&gt;}&lt;br/&gt; })&lt;br/&gt;&lt;span&gt;defer&lt;/span&gt; guard.Unpatch()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PatchInstanceMethod API 是 Monkey 提供给用户用于方法打桩的 API：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在使用前，先要定义一个目标类的指针变量 x&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第一个参数是 reflect.TypeOf(x)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二个参数是字符串形式的函数名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回值是一个 PatchGuard 对象指针，主要用于在测试结束时删除当前的补丁&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://www.jianshu.com/p/2f675d5e334e&quot; data-linktype=&quot;2&quot;&gt;Monkey 的更多用法以及 Monkey 和前几种框架的组合使用方法&lt;/a&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、Mock 场景最佳实践&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 实例函数 Mock：Monkey&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Monkey 用于对依赖的函数进行 Mock 替换，从而可以完成仅针对当前模块的单元测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例子：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;test&lt;/code&gt;包是真实的函数&lt;code&gt;mock_test&lt;/code&gt;包是即将用于 mock 的函数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;test.go&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; test&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;PrintAdd&lt;/span&gt;&lt;span&gt;(a, b &lt;span&gt;uint32&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; fmt.Sprintf(&lt;span&gt;&quot;a:%v+b:%v&quot;&lt;/span&gt;, a, b)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; SumTest &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(*SumTest)&lt;/span&gt;&lt;span&gt;PrintSum&lt;/span&gt;&lt;span&gt;(a, b &lt;span&gt;uint32&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; fmt.Sprintf(&lt;span&gt;&quot;a:%v+b:%v&quot;&lt;/span&gt;, a, b)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;mock_test.go&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; mock_test&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;test/24_mock/test&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;PrintAdd&lt;/span&gt;&lt;span&gt;(a, b &lt;span&gt;uint32&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; fmt.Sprintf(&lt;span&gt;&quot;a:%v+b:%v=%v&quot;&lt;/span&gt;, a, b, a+b)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//对应test文件夹下的PrintSum&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;PrintSum&lt;/span&gt;&lt;span&gt;(_ *test.SumTest, a, b &lt;span&gt;uint32&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; fmt.Sprintf(&lt;span&gt;&quot;a:%v+b:%v=%v&quot;&lt;/span&gt;, a, b,a+b)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;main.go&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;     monkey.Patch(test.PrintAdd, mock_test.PrintAdd)&lt;br/&gt;     p := test.PrintAdd(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;     fmt.Println(p)&lt;br/&gt;     monkey.UnpatchAll() &lt;span&gt;//解除所有替换&lt;/span&gt;&lt;br/&gt;     p = test.PrintAdd(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;     fmt.Println(p)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;     structSum := &amp;amp;test.SumTest{}&lt;br/&gt;     &lt;span&gt;//para1:获取实例的反射类型,para2:被替换的方法名,para3:替换方法&lt;/span&gt;&lt;br/&gt;     monkey.PatchInstanceMethod(reflect.TypeOf(structSum), &lt;span&gt;&quot;PrintSum&quot;&lt;/span&gt;, mock_test.PrintSum)&lt;br/&gt;     p := structSum.PrintSum(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;     fmt.Println(p)&lt;br/&gt;     monkey.UnpatchAll() &lt;span&gt;//解除所有替换&lt;/span&gt;&lt;br/&gt;     p = structSum.PrintSum(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;     fmt.Println(p)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 未实现函数 Mock：GoMock&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设场景：&lt;code&gt;Company&lt;/code&gt;公司、&lt;code&gt;Person&lt;/code&gt;人。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;公司可以开会。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;公司内部的人继承了&lt;code&gt;Talker&lt;/code&gt;讨论者接口，拥有&lt;code&gt;SayHello&lt;/code&gt;说话的方法。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如现在要测试这个场景，在所有类都实现的情况下，测试应该是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//正常测试&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestCompany_Meeting&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;//直接调用Person类的New方法，创建一个Person对象&lt;/span&gt;&lt;br/&gt; talker := NewPerson(&lt;span&gt;&quot;小微&quot;&lt;/span&gt;, &lt;span&gt;&quot;语音服务助手&quot;&lt;/span&gt;)&lt;br/&gt; company := NewCompany(talker)&lt;br/&gt; t.Log(company.Meeting(&lt;span&gt;&quot;lyt&quot;&lt;/span&gt;, &lt;span&gt;&quot;intern&quot;&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但现在&lt;code&gt;Person&lt;/code&gt;类并未实现，则可以通过 GoMock 工具来模拟一个&lt;code&gt;Person&lt;/code&gt;对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义一个&lt;code&gt;Talker.go&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; pojo&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Talker &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt;   SayHello(word, role &lt;span&gt;string&lt;/span&gt;) (response &lt;span&gt;string&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据该接口，用&lt;code&gt;mockgen&lt;/code&gt;命令生成一个 Mock 对象&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mockgen [-&lt;span&gt;source&lt;/span&gt;] [-destination] [-package] ... Talker.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着进行测试用例的编写：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;NewController()&lt;/code&gt;: 新建 Mock 控制器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;NewMockXXX()&lt;/code&gt;: 新建 Mock 对象，这里是调用 NewMockTalker()&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;talker.EXPECT().XXX().XXX()..&lt;/code&gt;：撰写一些断言测试&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;之前 Mock 建立的对象传入到待测方法当中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;测试结果通过 testing 框架返回&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//通过Mock测试&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestCompany_Meeting2&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;//新建Mock控制器&lt;/span&gt;&lt;br/&gt;   ctrl := gomock.NewController(t)&lt;br/&gt;   &lt;span&gt;//新建Mock对象-Talker&lt;/span&gt;&lt;br/&gt;   talker := mock_pojo.NewMockTalker(ctrl)&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;//断言&lt;/span&gt;&lt;br/&gt;   talker.EXPECT().SayHello(gomock.Eq(&lt;span&gt;&quot;震天嚎&quot;&lt;/span&gt;), gomock.Eq(&lt;span&gt;&quot;学生&quot;&lt;/span&gt;)).Return(&lt;span&gt;&quot;Hello Faker(身份：学生), welcome to GoLand IDE. My name is 震天嚎&quot;&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;//mock对象传入方法&lt;/span&gt;&lt;br/&gt;   company := NewCompany(talker)&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;//Pass的例子&lt;/span&gt;&lt;br/&gt;   t.Log(company.Meeting(&lt;span&gt;&quot;震天嚎&quot;&lt;/span&gt;, &lt;span&gt;&quot;学生&quot;&lt;/span&gt;))&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;//报错的例子&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;//t.Log(company.Meeting(&quot;小白&quot;, &quot;学生&quot;))&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 系统内置函数 Mock：Monkey&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;monkey.Patch(json.Unmarshal, mockUnmarshal)&lt;/code&gt;，用 Monkey 的 patch 来 mock 系统内置函数&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;mockUnmarshal&lt;/span&gt;&lt;span&gt;(b []&lt;span&gt;byte&lt;/span&gt;, v &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;   v = &amp;amp;Common.LoginMessage{&lt;br/&gt;      UserId: &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;      UserName: &lt;span&gt;&quot;admin&quot;&lt;/span&gt;,&lt;br/&gt;      UserPwd: &lt;span&gt;&quot;admin&quot;&lt;/span&gt;,&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果需要取消替换，可以使用&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;monkey.UnPatch(target &lt;span&gt;interface&lt;/span&gt;{}) &lt;span&gt;//解除单个Patch&lt;/span&gt;&lt;br/&gt;monkey.UnPatchAll()        &lt;span&gt;//解除所有Patch&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 数据库行为 Mock&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestSql&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;      fmt.Println(&lt;span&gt;&quot;fail to open sqlmock db: &quot;&lt;/span&gt;, err)&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; db.Close()&lt;br/&gt;   rows := sqlmock.NewRows([]&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;id&quot;&lt;/span&gt;, &lt;span&gt;&quot;pwd&quot;&lt;/span&gt;}).&lt;br/&gt;      AddRow(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;apple&quot;&lt;/span&gt;).&lt;br/&gt;      AddRow(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;banana&quot;&lt;/span&gt;)&lt;br/&gt;   mock.ExpectQuery(&lt;span&gt;&quot;SELECT id, pwd FROM users&quot;&lt;/span&gt;).WillReturnRows(rows)&lt;br/&gt;   res, err := db.Query(&lt;span&gt;&quot;SELECT id, pwd FROM users&quot;&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;      fmt.Println(&lt;span&gt;&quot;fail to match expected sql.&quot;&lt;/span&gt;)&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; res.Close()&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; res.Next() {&lt;br/&gt;      &lt;span&gt;var&lt;/span&gt; id &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;var&lt;/span&gt; pwd &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;      res.Scan(&amp;amp;id, &amp;amp;pwd)&lt;br/&gt;      fmt.Printf(&lt;span&gt;&quot;Sql Result:\tid = %d, password = %s.\n&quot;&lt;/span&gt;,id, pwd)&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; res.Err() != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;      fmt.Println(&lt;span&gt;&quot;Result Return Error!&quot;&lt;/span&gt;, res.Err())&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 服务器行为 Mock：Monkey&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 net/http/httptest 模拟服务器行为&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestHttp&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   handler := &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;      io.WriteString(w, &lt;span&gt;&quot;{ \&quot;status\&quot;: \&quot;expected service response\&quot;}&quot;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   req := httptest.NewRequest(&lt;span&gt;&quot;GET&quot;&lt;/span&gt;, &lt;span&gt;&quot;https://test.net&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;   w := httptest.NewRecorder()&lt;br/&gt;   handler(w, req)&lt;span&gt;//处理该Request&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;   resp := w.Result()&lt;br/&gt;   body, _ := ioutil.ReadAll(resp.Body)&lt;br/&gt;   fmt.Println(resp.StatusCode)&lt;br/&gt;   fmt.Println(resp.Header.Get(&lt;span&gt;&quot;Content-Type&quot;&lt;/span&gt;))&lt;br/&gt;   fmt.Println(&lt;span&gt;string&lt;/span&gt;(body))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里只使用了 Monkey 的 Patch 进行简单测试，但在更一般的情况下，更多的函数还是通过实例函数来编写的，对这部分函数要用&lt;code&gt;PatchInstanceMethod&lt;/code&gt;才可以进行替换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;func PatchInstanceMethod(target reflect.Type, methodName string, replacement interface{})&lt;/code&gt;接收三个参数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;reflect.Tpye&lt;/code&gt;通过新建一个待测实例对象，调用 reflect 包的&lt;code&gt;TypeOf()&lt;/code&gt;方法就可以得到&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;methodName&lt;/code&gt;是待测实例对象的函数名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;replacement&lt;/code&gt;是用于替换的函数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; ts *utils.Transfer&lt;br/&gt;monkey.PatchInstanceMethod(reflect.TypeOf(ts), &lt;span&gt;&quot;WritePkg&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(_ *utils.Transfer, _ []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设有如下一个函数&lt;code&gt;ServerProcessLogin&lt;/code&gt;，用于接收用户名密码，向当前连接的服务器请求登陆，测试如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestServerProcessLogin&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   mess := &amp;amp;Common.Message{&lt;br/&gt;      Type: Common.LoginMesType,&lt;br/&gt;      Data: &lt;span&gt;&quot;default&quot;&lt;/span&gt;,&lt;br/&gt;   }&lt;br/&gt;   user := &amp;amp;UserProcess{&lt;br/&gt;      Conn: &lt;span&gt;nil&lt;/span&gt;,&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;//对涉及到的单元以外系统函数打Patch&lt;/span&gt;&lt;br/&gt;   monkey.Patch(json.Unmarshal, mockUnmarshal)&lt;br/&gt;   monkey.Patch(json.Marshal, mockMarshal)&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;//单元测试不涉及实际服务器，故对实例函数Login，WritePkg打Patch&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;var&lt;/span&gt; udao *model.UserDao&lt;br/&gt;   monkey.PatchInstanceMethod(reflect.TypeOf(udao), &lt;span&gt;&quot;Login&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(_ *model.UserDao, _ &lt;span&gt;int&lt;/span&gt;, _ &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(*Common.User,error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &amp;amp;Common.User{&lt;br/&gt;         UserId: &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;         UserName: &lt;span&gt;&quot;admin&quot;&lt;/span&gt;,&lt;br/&gt;         UserPwd: &lt;span&gt;&quot;admin&quot;&lt;/span&gt;,&lt;br/&gt;      }, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;   })&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;var&lt;/span&gt; ts *utils.Transfer&lt;br/&gt;   monkey.PatchInstanceMethod(reflect.TypeOf(ts),&lt;span&gt;&quot;WritePkg&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(_ *utils.Transfer, _ []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;   })&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;//执行测试&lt;/span&gt;&lt;br/&gt;   convey.Convey(&lt;span&gt;&quot;Test Server Login.&quot;&lt;/span&gt;, t, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;      err := user.ServerProcessLogin(mess)&lt;br/&gt;      convey.So(err, convey.ShouldBeNil)&lt;br/&gt;   })&lt;br/&gt;&lt;br/&gt;   monkey.UnpatchAll()&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//用于替换的函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;mockUnmarshal&lt;/span&gt;&lt;span&gt;(b []&lt;span&gt;byte&lt;/span&gt;, v &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;   v = &amp;amp;Common.LoginMessage{&lt;br/&gt;      UserId: &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;      UserName: &lt;span&gt;&quot;admin&quot;&lt;/span&gt;,&lt;br/&gt;      UserPwd: &lt;span&gt;&quot;admin&quot;&lt;/span&gt;,&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;mockMarshal&lt;/span&gt;&lt;span&gt;(v &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;([]&lt;span&gt;byte&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;var&lt;/span&gt; rer = []&lt;span&gt;byte&lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;&#x27;a&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;d&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;m&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;i&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;n&#x27;&lt;/span&gt;,&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; rer, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;五、具体案例：聊天室&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 概览&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该项目是一个具有登录、查看在线用户、私聊、群聊等功能的命令行聊天室 Demo。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目分为 Client、Server 子项目，都通过 model、Controllor(Processor）、View（Main）来进行功能划分。还有一个 Common 包放置通用性的工具类。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;├─Client&lt;br/&gt;│  ├─main&lt;br/&gt;│  ├─model&lt;br/&gt;│  ├─processor&lt;br/&gt;│  └─utils&lt;br/&gt;├─Common&lt;br/&gt;└─Server&lt;br/&gt;    ├─main&lt;br/&gt;    ├─model&lt;br/&gt;    ├─processor&lt;br/&gt;    └─utils&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;预期目的：对实现的功能模块补充单元测试代码，度量确保每一个模块的功能的正确性、完整性、健壮性，并在未来修改代码后也能第一时间自测验收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单元测试应包括模块接口测试、模块局部数据结构测试、模块异常处理测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于接口测试，应对接口的传入参数测试样例设计进行全面的考察，判断每一个参数是否有是有必要的，参数间有没有冗余，进入函数体前引用的指针是否有错等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于局部数据结构测试，应检查局部数据结构是为了保证临时存储在模块内的数据在程序执行过程中完整性、正确性。局部数据结构往往是错误的根源，应仔细设计测试用例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于异常处理，主要有如下几种常见错误：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;输出的出错信息提示不足&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对异常没有进行处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;出错信息与实际不相符&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;出错信息中未能准确定位出错信息&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上几种错误，都是模块中经常会出现的错误，要针对这些错误来进行边界条件测试检查，只有异常处理机制正确，日后软件的维护和迭代才会更加高效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本案例中，Model 层对服务层提供的接口不多，就&lt;code&gt;WritePkg&lt;/code&gt;，&lt;code&gt;ReadPkg&lt;/code&gt;两个核心函数，在服务层对其进行封装抽象为具体的业务逻辑。由于涉及网络连接，所以对其进行的测试必须编写桩函数。在服务层，涉及到对多个网络连接调用、数据库调用其它模块依赖，所以也要为其进行 Mock。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于涉及 Mock 和桩函数编写，可以使用&lt;code&gt;GoStub&lt;/code&gt;、&lt;code&gt;Monkey&lt;/code&gt;两个包进行这些工作，它们较简洁地实现了很多实用的测试方式，只需要用户编写依赖的接口文件、用于替换的 Mock 函数，就可以仅在测试过程中替换掉系统函数或者其它依赖的功能模块，使得单元测试起到它应有的作用。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. Model 层、数据库相关测试&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于是单元测试，所以需要获取一个 Mock 数据库实例，测试增删改查 SQL 语句是否可执行。&lt;code&gt;userDao_test.go&lt;/code&gt;代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; (&lt;br/&gt;   sql1 = &lt;span&gt;&quot;SELECT id, pwd FROM users&quot;&lt;/span&gt;&lt;br/&gt;   sql2 = &lt;span&gt;&quot;DELETE FROM users where id &amp;gt; 600 and id &amp;lt; 700&quot;&lt;/span&gt;&lt;br/&gt;   sql3 = &lt;span&gt;&quot;update users set pwd = newPwd where id = 1 and id = 2&quot;&lt;/span&gt;&lt;br/&gt;   sql4 = &lt;span&gt;&quot;INSERT INTO users (id, pwd) VALUES (405, &#x27;Lyt&#x27;)&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestGetUserById&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;      fmt.Println(&lt;span&gt;&quot;fail to open sqlmock db: &quot;&lt;/span&gt;, err)&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; db.Close()&lt;br/&gt;   rows1 := sqlmock.NewRows([]&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;id&quot;&lt;/span&gt;, &lt;span&gt;&quot;pwd&quot;&lt;/span&gt;}).&lt;br/&gt;      AddRow(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;apple&quot;&lt;/span&gt;).&lt;br/&gt;      AddRow(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;banana&quot;&lt;/span&gt;)&lt;br/&gt;   rows2 := sqlmock.NewRows([]&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;id&quot;&lt;/span&gt;, &lt;span&gt;&quot;pwd&quot;&lt;/span&gt;}).&lt;br/&gt;      AddRow(&lt;span&gt;601&lt;/span&gt;, &lt;span&gt;&quot;goland&quot;&lt;/span&gt;).&lt;br/&gt;      AddRow(&lt;span&gt;602&lt;/span&gt;, &lt;span&gt;&quot;java&quot;&lt;/span&gt;)&lt;br/&gt;   rows3 := sqlmock.NewRows([]&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;id&quot;&lt;/span&gt;, &lt;span&gt;&quot;pwd&quot;&lt;/span&gt;}).&lt;br/&gt;      AddRow(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;newPwd&quot;&lt;/span&gt;).&lt;br/&gt;      AddRow(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;newPwd&quot;&lt;/span&gt;)&lt;br/&gt;   rows4 := sqlmock.NewRows([]&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;id&quot;&lt;/span&gt;, &lt;span&gt;&quot;pwd&quot;&lt;/span&gt;}).&lt;br/&gt;      AddRow(&lt;span&gt;405&lt;/span&gt;, &lt;span&gt;&quot;Lyt&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;   mock.ExpectQuery(sql1).WillReturnRows(rows1)&lt;br/&gt;   mock.ExpectQuery(sql2).WillReturnRows(rows2)&lt;br/&gt;   mock.ExpectQuery(sql3).WillReturnRows(rows3)&lt;br/&gt;   mock.ExpectQuery(sql4).WillReturnRows(rows4)&lt;br/&gt;&lt;br/&gt;   assert.New(t)&lt;br/&gt;   &lt;span&gt;var&lt;/span&gt; tests = []&lt;span&gt;struct&lt;/span&gt;{&lt;br/&gt;      inputSql &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;      expected &lt;span&gt;interface&lt;/span&gt;{}&lt;br/&gt;   } {&lt;br/&gt;      {sql1,&lt;span&gt;nil&lt;/span&gt;},&lt;br/&gt;      {sql2,&lt;span&gt;nil&lt;/span&gt;},&lt;br/&gt;      {sql3,&lt;span&gt;nil&lt;/span&gt;},&lt;br/&gt;      {sql4, &lt;span&gt;nil&lt;/span&gt;},&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; _, test := &lt;span&gt;range&lt;/span&gt; tests {&lt;br/&gt;      res, err := db.Query(test.inputSql)&lt;br/&gt;      assert.Equal(t, err, test.expected)&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; res.Next() {&lt;br/&gt;         &lt;span&gt;var&lt;/span&gt; id &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;var&lt;/span&gt; pwd &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;         res.Scan(&amp;amp;id, &amp;amp;pwd)&lt;br/&gt;         fmt.Printf(&lt;span&gt;&quot;Sql Result:\tid = %d, password = %s.\n&quot;&lt;/span&gt;,id, pwd)&lt;br/&gt;      }&lt;br/&gt;      assert.Equal(t, res.Err(), test.expected)&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 私聊功能测试&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于涉及底层数据库交互时需要发送 JSON 转码字符串（&lt;code&gt;WritePkg&lt;/code&gt;函数），因此将其 Mock 处理，只需关注本函数逻辑是否正确即可。&lt;code&gt;smsProcess_test.go&lt;/code&gt;如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestSmsProcess_SendOnePerson&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;var&lt;/span&gt; conn net.Conn&lt;br/&gt;   tf := &amp;amp;utils.Transfer{&lt;br/&gt;      Conn: conn,&lt;br/&gt;   }&lt;br/&gt;   monkey.PatchInstanceMethod(reflect.TypeOf(tf), &lt;span&gt;&quot;WritePkg&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(_ *utils.Transfer,_ []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;   })&lt;br/&gt;   convey.Convey(&lt;span&gt;&quot;test send one person:&quot;&lt;/span&gt;, t, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;      err := tf.WritePkg([]&lt;span&gt;byte&lt;/span&gt;{})&lt;br/&gt;      convey.So(err, convey.ShouldBeNil)&lt;br/&gt;      fmt.Println(&lt;span&gt;&quot;OK.&quot;&lt;/span&gt;)&lt;br/&gt;   })&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 登录功能测试&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;登录涉及服务器连接操作，服务器的连接逻辑可通过&lt;code&gt;httptest&lt;/code&gt;包来进行检测，Mock 一个 HTTP 连接，示例代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestHttp&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   handler := &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// here we write our expected response, in this case, we return a&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// JSON string which is typical when dealing with REST APIs&lt;/span&gt;&lt;br/&gt;      io.WriteString(w, &lt;span&gt;&quot;{ \&quot;status\&quot;: \&quot;expected service response\&quot;}&quot;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   req := httptest.NewRequest(&lt;span&gt;&quot;GET&quot;&lt;/span&gt;, &lt;span&gt;&quot;https://test.net&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;   w := httptest.NewRecorder()&lt;br/&gt;   handler(w, req)&lt;br/&gt;&lt;br/&gt;   resp := w.Result()&lt;br/&gt;   body, _ := ioutil.ReadAll(resp.Body)&lt;br/&gt;   fmt.Println(resp.StatusCode)&lt;br/&gt;   fmt.Println(resp.Header.Get(&lt;span&gt;&quot;Content-Type&quot;&lt;/span&gt;))&lt;br/&gt;   fmt.Println(&lt;span&gt;string&lt;/span&gt;(body))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为登录模块编写用于测试替换的函数以及单元测试主体，&lt;code&gt;userProcess_test.go&lt;/code&gt;代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;mockUnmarshal&lt;/span&gt;&lt;span&gt;(b []&lt;span&gt;byte&lt;/span&gt;, v &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   v = &amp;amp;Common.LoginMessage{&lt;br/&gt;      UserId:   &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;      UserName: &lt;span&gt;&quot;admin&quot;&lt;/span&gt;,&lt;br/&gt;      UserPwd:  &lt;span&gt;&quot;admin&quot;&lt;/span&gt;,&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;mockMarshal&lt;/span&gt;&lt;span&gt;(v &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;([]&lt;span&gt;byte&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;var&lt;/span&gt; rer = []&lt;span&gt;byte&lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;&#x27;a&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;d&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;m&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;i&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;n&#x27;&lt;/span&gt;,&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; rer, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestServerProcessLogin&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   mess := &amp;amp;Common.Message{&lt;br/&gt;      Type: Common.LoginMesType,&lt;br/&gt;      Data: &lt;span&gt;&quot;default&quot;&lt;/span&gt;,&lt;br/&gt;   }&lt;br/&gt;   user := &amp;amp;UserProcess{&lt;br/&gt;      Conn: &lt;span&gt;nil&lt;/span&gt;,&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;//对涉及到的单元以外系统函数打Patch&lt;/span&gt;&lt;br/&gt;   monkey.Patch(json.Unmarshal, mockUnmarshal)&lt;br/&gt;   monkey.Patch(json.Marshal, mockMarshal)&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;//对实例函数打Patch&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;var&lt;/span&gt; udao *model.UserDao&lt;br/&gt;   monkey.PatchInstanceMethod(reflect.TypeOf(udao), &lt;span&gt;&quot;Login&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(_ *model.UserDao, _ &lt;span&gt;int&lt;/span&gt;, _ &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(*Common.User, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &amp;amp;Common.User{&lt;br/&gt;         UserId:   &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;         UserName: &lt;span&gt;&quot;admin&quot;&lt;/span&gt;,&lt;br/&gt;         UserPwd:  &lt;span&gt;&quot;admin&quot;&lt;/span&gt;,&lt;br/&gt;      }, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;   })&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;var&lt;/span&gt; ts *utils.Transfer&lt;br/&gt;   monkey.PatchInstanceMethod(reflect.TypeOf(ts), &lt;span&gt;&quot;WritePkg&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(_ *utils.Transfer, _ []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;   })&lt;br/&gt;   &lt;span&gt;//执行测试&lt;/span&gt;&lt;br/&gt;   convey.Convey(&lt;span&gt;&quot;Test Server Login.&quot;&lt;/span&gt;, t, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;      err := user.ServerProcessLogin(mess)&lt;br/&gt;      convey.So(err, convey.ShouldBeNil)&lt;br/&gt;   })&lt;br/&gt;   monkey.UnpatchAll()&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 工具类测试&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;utils_test.go&lt;br/&gt;func mockRead(conn net.Conn, _ []byte) (int, error) {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; 4, nil&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func mockMarshal(v interface{}) ([]byte, error) {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; []byte{&lt;span&gt;&#x27;a&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;b&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;c&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;d&#x27;&lt;/span&gt;}, nil&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func mockUnmarshal(data []byte, v interface{}) error {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; nil&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func TestTransfer_ReadPkg(t *testing.T) {&lt;br/&gt;&lt;br/&gt;   monkey.Patch(net.Conn.Read, mockRead)&lt;br/&gt;   monkey.Patch(json.Marshal, mockMarshal)&lt;br/&gt;   monkey.Patch(json.Unmarshal, mockUnmarshal)&lt;br/&gt;&lt;br/&gt;   listen, _ := net.Listen(&lt;span&gt;&quot;tcp&quot;&lt;/span&gt;, &lt;span&gt;&quot;localhost:8888&quot;&lt;/span&gt;)&lt;br/&gt;   defer listen.Close()&lt;br/&gt;   go net.Dial(&lt;span&gt;&quot;tcp&quot;&lt;/span&gt;, &lt;span&gt;&quot;localhost:8888&quot;&lt;/span&gt;)&lt;br/&gt;   var c net.Conn&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;      c, _ = listen.Accept()&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; c != nil {&lt;br/&gt;         &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;   transfer := &amp;amp;Transfer{&lt;br/&gt;      Conn: c,&lt;br/&gt;      Buf : [8096]byte{&lt;span&gt;&#x27;a&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;b&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;c&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;d&#x27;&lt;/span&gt;},&lt;br/&gt;   }&lt;br/&gt;   convey.Convey(&lt;span&gt;&quot;test ReadPkg&quot;&lt;/span&gt;, t, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;      mes, err := transfer.ReadPkg()&lt;br/&gt;      convey.So(err, convey.ShouldBeNil)&lt;br/&gt;      convey.So(mes, convey.ShouldEqual, &lt;span&gt;&quot;ab&quot;&lt;/span&gt;)&lt;br/&gt;   })&lt;br/&gt;   monkey.UnpatchAll()&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func TestTransfer_WritePkg(t *testing.T) {&lt;br/&gt;&lt;br/&gt;   monkey.Patch(json.Marshal, mockMarshal)&lt;br/&gt;   monkey.Patch(json.Unmarshal, mockUnmarshal)&lt;br/&gt;   transfer := &amp;amp;Transfer{&lt;br/&gt;      Conn: nil,&lt;br/&gt;      Buf : [8096]byte{},&lt;br/&gt;   }&lt;br/&gt;   convey.Convey(&lt;span&gt;&quot;test ReadPkg&quot;&lt;/span&gt;, t, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;      err := transfer.WritePkg([]byte{&lt;span&gt;&#x27;a&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;b&#x27;&lt;/span&gt;})&lt;br/&gt;      convey.So(err, convey.ShouldBeNil)&lt;br/&gt;   })&lt;br/&gt;   monkey.UnpatchAll()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 项目总结&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在编写桩模块时会发现，模块之间的调用关系在工程规模并不大的本案例中，也依然比较复杂，需要开发相应桩函数，代码量会增加许多，也会消耗一些开发人员的时间，因此反推到之前流程的开发实践中，可以得出结论就是提高模块的内聚度可简化单元测试，如果每个模块只能完成一个，所需测试用例数目将显著减少，模块中的错误也更容易发现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 单元测试框架是相当易用的，其它的第三方库基本都是建立在 testing 原生框架的基础上进行的增补扩充，在日常开发中，原生包可以满足基本需求，但同样也有缺陷，原生包不提供断言的语法使得代码中的这种片段非常多：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以引入了 convey、assert 包的断言语句，用于简化判断逻辑，使得程序更加易读。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在完成项目单测时，遇到了不少问题，比较重要的比如由于架构分层不够清晰，还是有部分耦合代码，导致单测时需要屏蔽的模块太多，代码写起来不便。因此还是需要倒推到开发模块之前，就要设计更好的结构，在开发的过程中遵循相应的规则，通过测试先行的思想，使开发的工程具有更好的可测试性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发过程中遇到的场景肯定不局限于本文所讨论的范围，有关更丰富的最佳实践案例可以参照：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;六、结语&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 实践小结&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单元测试大多是由开发人员进行编写，本篇文章旨在指引，不在于面面俱到，具体的单元测试框架的使用语法，开发同学可以自行 Google。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以测试的角度，推行单元测试是不易的，最佳的方式莫过于开发人员，在一定的指引之后，以实际项目出发进行实践，然后自行总结具体的 case，有针对性、有感染力进行内部分享，测试同学及时提供测试用例的指引和规范的约束。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 特别鸣谢&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;两位实习生罗宇韬和钟梓轩，在暑假实习期间，协助整理了 Golang 单测的代码示例。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 推荐阅读&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;书籍《google 的软件测试之道》&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;书籍《单元测试的艺术》&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;欢迎关注我们的视频号：腾讯程序员&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;最新视频：10月24日到底是啥日子？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAfMsltHnDLgAAAAstQy6ubaLX4KHWvLEZgBPE96EIIkNQKLb5zNPgMIvrrwl60VwjMKf0i3ESyOUV&quot; data-url=&quot;https://findermp.video.qq.com/251/20350/stodownload?encfilekey=jEXicia3muM3GjTlk1Z3kYCefzc4VU4EASlYemibTwMTBwDJuHmThjdgsORunbwjT66JhlJJtOUnCibc67qPPmD22w4o5G4POQ2elWHsEexNnZLbYcV5icHPSSLJxUQibSz6MPibmjrGoYEsUnicZLGhfY3NE3heXY56u8wkhTG0icoftElM&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=b73d05bb01c62c7d4ca2fc8cd05e012f&amp;amp;token=cztXnd9GyrGhE2iaHGOXDiaIjVjZZA7aTh0MDU6XAmh3TSCHicL8HU5yibqBqOk0C28B&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xEecUymmic8cw4v7Y2zbnVDuo/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;10月24日是个很特别的日子，看完视频你就知道了。你身边有程序员么，欢迎留言@腾讯程序员 说说他们是什么样的。 #1024# #程序员#  @微信派 @微信视频号创造营 &quot; data-nonceid=&quot;16354131248651355178&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>899398eb4768f1e974b1a025cd0ebe39</guid>
<title>Android 存储空间的最佳实践</title>
<link>https://toutiao.io/k/zn8845z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;为了提高文件的规整程度并让用户可以更好地控制他们的文件，Android 10 为应用引入了名为 &quot;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/data-storage%23scoped-storage&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;分区存储&lt;/a&gt;&lt;/b&gt;&quot; 的新范式。分区存储改变了应用在外置存储中保存和访问文件的方式，为了帮您迁移应用并支持分区存储，我们概括了常见用例的最佳实践并分享给大家。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;处理媒体文件&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这部分内容描述了处理媒体文件 (如视频、图片、音频文件) 的一些常见用例，并概要说明了应用可以使用的方法。我们制作了一个简单的图片，列出了每种用例以及其在不同系统版本的实践总结:&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5605a0b47cf01e6fe5e1fbd714c3c6a8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1000&quot; data-rawheight=&quot;541&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-5605a0b47cf01e6fe5e1fbd714c3c6a8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1000&quot; data-rawheight=&quot;541&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-5605a0b47cf01e6fe5e1fbd714c3c6a8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5605a0b47cf01e6fe5e1fbd714c3c6a8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;展示多个文件夹中的图片和视频文件&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/content/ContentResolver%23query%28android.net.Uri%2C%2520java.lang.String%255B%255D%2C%2520java.lang.String%2C%2520java.lang.String%255B%255D%2C%2520java.lang.String%2C%2520android.os.CancellationSignal%29&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;query()&lt;/a&gt;&lt;/b&gt; API &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/data-storage/shared/media%23query-collection&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;查询媒体集合&lt;/a&gt;&lt;/b&gt;。您可以通过调整 &lt;code&gt;projection&lt;/code&gt;、 &lt;code&gt;selection&lt;/code&gt;、 &lt;code&gt;selectionArgs&lt;/code&gt; 与 &lt;code&gt;sortOrder&lt;/code&gt; 参数来对媒体文件进行过滤和排序。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;展示特定文件夹内的文件和视频&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;使用以下方法:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;使用 &quot;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/permissions/requesting&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;请求应用权限&lt;/a&gt;&lt;/b&gt;&quot; 一文中描述的最佳实践来请求 &lt;b&gt;&lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/Manifest.permission%23READ_EXTERNAL_STORAGE&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;READ_EXTERNAL_STORAGE&lt;/a&gt;&lt;/code&gt;&lt;/b&gt; 权限。&lt;/li&gt;&lt;li&gt;使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/android/provider/MediaStore.MediaColumns%23data&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MediaColumns.DATA&lt;/a&gt;&lt;/b&gt; 中的值来检索媒体文件，其中包含了磁盘中媒体文件的绝对文件系统路径。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;访问照片内的位置信息&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果您的应用使用了分区存储，可以遵循媒体存储指南中的 &quot;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/data-storage/shared/media%23location-info-photos&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;照片中的位置信息&lt;/a&gt;&lt;/b&gt;&quot; 部分进行操作。&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;注意:&lt;/b&gt;  就算您选择停用分区存储，在使用  &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/provider/MediaStore&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MediaStore&lt;/a&gt;&lt;/b&gt;  API 访问图像并读取未修改的位置信息时，您也需要请求  &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/Manifest.permission%23ACCESS_MEDIA_LOCATION&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ACCESS_MEDIA_LOCATION&lt;/a&gt;&lt;/b&gt;  权限。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;在单个操作中修改或删除多个媒体文件&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;您需要根据运行应用的 Android 版本来整合逻辑。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;在 Android 11 上运行&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;使用以下方法:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/provider/MediaStore%23createWriteRequest%28android.content.ContentResolver%2C%2520java.util.Collection%253Candroid.net.Uri%253E%29&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MediaStore.createWriteRequest()&lt;/a&gt;&lt;/b&gt; 或 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/provider/MediaStore%23createTrashRequest%28android.content.ContentResolver%2C%2520java.util.Collection%253Candroid.net.Uri%253E%2C%2520boolean%29&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MediaStore.createTrashRequest()&lt;/a&gt;&lt;/b&gt; 为应用的写入或删除请求创建待定 intent，然后通过调用该 intent 提示用户授予修改一组文件的权限。&lt;/li&gt;&lt;li&gt;评估用户的响应:&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;如果获得了权限，执行修改或删除操作；&lt;/li&gt;&lt;li&gt;如果未能获得权限，向用户解释为什么您的应用需要此权限。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;详细了解如何使用 Android 11 引入的这些方法执&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/preview/privacy/storage%23media-batch-operations&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;行批量操作&lt;/a&gt;&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;在 Android 10 上运行&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果您的应用目标 API 为 Android 10 (API level 29)，&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/data-storage/use-cases%23opt-out-scoped-storage&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;请停用分区存储&lt;/a&gt;&lt;/b&gt;并继续使用 Android 9 及更低版本所使用的方法来执行这类操作。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;在 Android 9 及更低版本上运行&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;使用以下方法:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;使用 &quot;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/permissions/requesting&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;请求应用权限&lt;/a&gt;&lt;/b&gt;&quot; 一文中描述的最佳实践来请求 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/Manifest.permission%23WRITE_EXTERNAL_STORAGE&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;WRITE_EXTERNAL_STORAGE&lt;/a&gt;&lt;/b&gt; 权限。&lt;/li&gt;&lt;li&gt;使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/provider/MediaStore&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MediaStore API&lt;/a&gt;&lt;/b&gt; 来修改和删除媒体文件。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;导入已存在的单个图片&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果您想要导入一张已存在的图片 (例如将照片用于用户个人资料)，您的应用可以使用自己的 UI 或者系统图片选择器来执行这一操作。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;提供您自己的用户界面&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;使用以下方法:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;使用 &quot;请求应用权限&quot; 一文中描述的最佳实践来请求 &lt;code&gt;READ_EXTERNAL_STORAGE&lt;/code&gt; 权限。&lt;/li&gt;&lt;li&gt;使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/content/ContentResolver%23query%28android.net.Uri%2C%2520java.lang.String%255B%255D%2C%2520java.lang.String%2C%2520java.lang.String%255B%255D%2C%2520java.lang.String%2C%2520android.os.CancellationSignal%29&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;query()&lt;/a&gt;&lt;/b&gt; API &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/data-storage/shared/media%23query-collection&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;查询媒体集合&lt;/a&gt;&lt;/b&gt;。&lt;/li&gt;&lt;li&gt;将结果显示到您的 UI 上。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;使用系统选择器&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/content/Intent%23ACTION_GET_CONTENT&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ACTION_GET_CONTENT&lt;/a&gt;&lt;/b&gt; intent 来要求用户选择要导入的图片。如果您希望过滤系统选择器向用户展示的图片类型，可以使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/content/Intent%23setType%28java.lang.String%29&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;setType()&lt;/a&gt;&lt;/b&gt; 或 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/content/Intent%23EXTRA_MIME_TYPES&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;EXTRA_MIME_TYPES&lt;/a&gt;&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;拍摄单张图片&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当您想要拍摄一张图片并用于您的应用时 (例如将照片用于用户个人资料)，使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/provider/MediaStore%23ACTION_IMAGE_CAPTURE&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ACTION_IMAGE_CAPTURE&lt;/a&gt;&lt;/b&gt; intent 来要求用户使用设备的相机拍摄一张照片。系统会将拍摄的照片存储于 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/provider/MediaStore.Images&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MediaStore.Images&lt;/a&gt;&lt;/b&gt; 表中。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;与其他应用共享媒体文件&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/content/ContentResolver%23insert%28android.net.Uri%2C%2520android.content.ContentValues%29&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;insert()&lt;/a&gt;&lt;/b&gt; 方法将记录直接加入 MediaStore。详细信息，可以参阅媒体存储指南中 &quot;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/data-storage/shared/media%23add-item&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;添加项目&lt;/a&gt;&lt;/b&gt;&quot; 部分。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;与特定应用共享媒体文件&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;使用 Android FileProvider 组件，相关内容在 &quot;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/secure-file-sharing/setup-sharing&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;设置文件分享&lt;/a&gt;&lt;/b&gt;&quot; 指南中有描述。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;从代码或依赖库中使用直接文件路径访问文件&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;您需要根据运行应用的 Android 版本来整合逻辑。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;在 Android 11 上运行&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;使用以下方法:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;使用 &quot;请求应用权限&quot; 一文中描述的最佳实践来请求 READ_EXTERNAL_STORAGE 权限。&lt;/li&gt;&lt;li&gt;使用直接文件路径访问文件。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;详细信息，请参阅 &quot;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/preview/privacy/storage%23media-files-raw-paths&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;使用原始路径访问文件&lt;/a&gt;&lt;/b&gt;&quot;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;在 Android 10 上运行&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果您的应用目标 API 为 Android 10 (API level 29)，请停用分区存储并继续使用 Android 9 及更低版本所使用的方法来执行这类操作。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;在 Android 9 及更低版本上运行&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;使用以下方法:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;使用 &quot;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/permissions/requesting&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;请求应用权限&lt;/a&gt;&lt;/b&gt;&quot; 一文中描述的最佳实践来请求 &lt;b&gt;&lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/Manifest.permission%23WRITE_EXTERNAL_STORAGE&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;WRITE_EXTERNAL_STORAGE&lt;/a&gt;&lt;/code&gt;&lt;/b&gt; 权限。&lt;/li&gt;&lt;li&gt;使用直接文件路径访问文件。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;打开文档文件&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;使用 &lt;b&gt;&lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/content/Intent%23ACTION_OPEN_DOCUMENT&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ACTION_OPEN_DOCUMENT&lt;/a&gt;&lt;/code&gt;&lt;/b&gt; intent 来要求用户通过系统选择器选择需要打开的文件。如果您想要过滤系统选择器展示给用户的文件类型，可以使用 &lt;b&gt;&lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/content/Intent%23setType%28java.lang.String%29&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;setType()&lt;/a&gt;&lt;/code&gt;&lt;/b&gt; 或 &lt;b&gt;&lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/content/Intent%23EXTRA_MIME_TYPES&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;EXTRA_MIME_TYPES&lt;/a&gt;&lt;/code&gt;&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;举例来说，您可以通过以下代码找到所有的 PDF、ODT 和 TXT 文件:&lt;/p&gt;&lt;p&gt;Kotlin 代码&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;startActivityForResult(
     Intent(Intent.ACTION_OPEN_DOCUMENT).apply {
         addCategory(Intent.CATEGORY_OPENABLE)
         type = &quot;*/*&quot;
         putExtra(Intent.EXTRA_MIME_TYPES, arrayOf(
              &quot;application/pdf&quot;, // .pdf
               &quot;application/vnd.oasis.opendocument.text&quot;, // .odt
               &quot;text/plain&quot; // .txt
         ))
      },
      REQUEST_CODE
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Java 代码&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
    intent.addCategory(Intent.CATEGORY_OPENABLE);
    intent.setType(&quot;*/*&quot;);
    intent.putExtra(Intent.EXTRA_MIME_TYPES, new String[] {
          &quot;application/pdf&quot;, // .pdf
          &quot;application/vnd.oasis.opendocument.text&quot;, // .odt
          &quot;text/plain&quot; // .txt
     });
     startActivityForResult(intent, REQUEST_CODE);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;从旧的存储位置迁移现有文件&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果一个目录既不是特定应用的目录，也不是公开共享目录，那么它就会被视为旧版存储位置。如果您的应用创建或使用位于旧版存储位置的文件，我们建议您将应用的文件迁移至可被分区存储访问的位置，同时对应用进行必要的修改，以使用分区存储中的文件。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;保留对旧版存储位置的访问以进行数据迁移&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;您的应用需要保留对旧版存储位置的访问，以便可以将任何文件迁移至可被分区存储访问的位置。您应该的使用的方法取决于您应用的目标 API 级别。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;如果您的应用目标平台为 Android 11&lt;/b&gt;&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;使用 &lt;code&gt;preserveLegacyExternalStorage&lt;/code&gt; 标志来 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/preview/privacy/storage%23migrate-data-for-scoped-storage&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;保留旧版存储模型&lt;/a&gt;&lt;/b&gt;，这样您的应用就可以在用户将应用升级为目标平台为 Android 11 的新版本时迁移用户数据。&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;b&gt;注意:&lt;/b&gt;  如果您使用  &lt;b&gt;preserveLegacyExternalStorage&lt;/b&gt; ，保持旧存储模型的效果只会在用户卸载应用之前有效。如果用户在运行 Android 11 的设备上安装或重装您的应用，则无论  &lt;b&gt;preserveLegacyExternalStorage&lt;/b&gt;  的值是什么，您的应用都无法停用分区存储模型。&lt;/blockquote&gt;&lt;ol&gt;&lt;li&gt;继续 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/data-storage/use-cases%23opt-out-scoped-storage&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;停用分区存储&lt;/a&gt;&lt;/b&gt;，以便您的应用可以继续访问运行 Android 10 的设备上旧版存储位置中的文件。&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;b&gt;如果您的应用目标平台为 Android 10&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;停用分区存储，以便您可以更轻松地在多个 Android 版本间保持应用行为不变。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;迁移应用数据&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;当您的应用已经做好迁移的准备时，使用以下方法:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;检查您应用在工作中是否使用了位于 &lt;code&gt;/sdcard/&lt;/code&gt; 目录或其任何子目录中的文件；&lt;/li&gt;&lt;li&gt;将应用的所有私有文件从现在的 &lt;code&gt;/sdcard/&lt;/code&gt; 下的目录中移动至 &lt;code&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/content/Context%23getExternalFilesDir%28java.lang.String%29&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;getExternalFilesDir()&lt;/a&gt;&lt;/b&gt;&lt;/code&gt; 方法所返回的目录中；&lt;/li&gt;&lt;li&gt;将所有共享的非媒体文件从现在的 &lt;code&gt;/sdcard/&lt;/code&gt; 下的目录中移动至 &lt;code&gt;/sdcard/&lt;/code&gt; 目录下的一个应用专用子目录；&lt;/li&gt;&lt;li&gt;从 &lt;code&gt;/sdcard/&lt;/code&gt; 目录移除应用程序的旧存储目录。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;与其他应用共享内容&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;您可以使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/secure-file-sharing&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;FileProvider&lt;/a&gt;&lt;/b&gt; 分享应用的文件给某个其他应用。而对于那些需要互相之间分享文件的所有应用，我们推荐为每一个应用使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/guide/topics/providers/content-provider-basics&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;内容提供程序&lt;/a&gt;&lt;/b&gt;，然后在将应用添加到集合中时同步数据。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;缓存非媒体文件&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;您应使用的方法取决于需要缓存的文件类型。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;暂时停用分区存储&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在您的应用完全兼容分区存储之前，您可以通过以下方法之一停用分区存储:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;目标平台设置为 Android 9 (API level 28) 或更低。&lt;/li&gt;&lt;li&gt;如果您的目标平台为 Android 10 (API level 29) 或者更高版本，将您应用 manifest 中的 requestLegacyExternalStorage 属性设置为 &quot;true&quot;:&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;manifest ... &amp;gt;
&amp;lt;!-- 该属性在目标 API 为 Android 10 或更高版本的应用中默认为 &quot;false&quot; --&amp;gt;
  &amp;lt;application android:requestLegacyExternalStorage=&quot;true&quot; ... &amp;gt;
    ...
  &amp;lt;/application&amp;gt;
&amp;lt;/manifest&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;b&gt;注意&lt;/b&gt; : 在您将应用的目标 API 更新为 Android 11 (API level 30) 后，如果应用运行在 Android 11 的设备上， &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/preview/privacy/storage%23scoped-storage&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;系统会忽略 requestLegacyExternalStorage 属性&lt;/a&gt;&lt;/b&gt; 。所以您的应用必须为支持分区存储做好准备，并为使用该设备的用户 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/data-storage/use-cases%23migrate-legacy-storage&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;迁移数据&lt;/a&gt;&lt;/b&gt;。&lt;/blockquote&gt;&lt;p&gt;为了测试目标 API 为 Android 9 及更低版本的应用在使用分区存储时的行为，您可以通过设置 &lt;code&gt;requestLegacyExternalStorage&lt;/code&gt; 的值设置为 false 来使应用选择启用行为。如果要在 Android 11 设备上进行测试，则还可以使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/preview/privacy/storage%23test-scoped-storage&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;应用兼容性标志&lt;/a&gt;&lt;/b&gt; 在使用或不使用分区存储的情况下测试应用的行为。&lt;/p&gt;&lt;p&gt;了解有关 Android 平台文件存储与访问的详细信息，请参阅以下资源:&lt;/p&gt;&lt;p&gt;如果您想了解更多最新关于使用存储空间的最佳实践，请查阅 Android 官方中文文档网站中 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/data-storage/use-cases%3Fhl%3Dzh-CN&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Android 存储用例和最佳做法&lt;/a&gt;&lt;/b&gt; 部分。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>