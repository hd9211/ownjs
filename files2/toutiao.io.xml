<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>a66a404513aced0b40d2a229af55229c</guid>
<title>轻松搞懂5种IO模型</title>
<link>https://toutiao.io/k/o77uhyt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;同步阻塞IO、同步非阻塞IO、IO多路复用、异步阻塞IO、异步非阻塞IO，这五种IO模型有没有朋友记过多次了，但是总是记不住？那是因为没有理解本质。5年前我记住了，到现在发现记忆和区分仍然很清晰，今天把理解方法介绍给大家。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先，大家先思考一个问题：&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;vote_area&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;IO操作其实主要为了读和写。本文以读数据做说明。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当程序调用read方法时，会切换到系统内核来完成真正的读取。而读取又分为等待数据和复制数据两个阶段。如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.591002044989775&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibwAicyibKwptvaTrLpel9o7xWE8NHicicu68aYkU1HRQSDEu0XOZcKZJDGJA5Jr5ddHf2vN6roGX0zBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;489&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同步阻塞IO&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5967413441955194&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibwAicyibKwptvaTrLpel9o7xdZlbgqv5kQRQCKQVxD7RKyFjKIE80nDaWJGKJ7OkKwEd6R9xU5AYng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;491&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上图所示，用户线程发起一个read请求，会切换到内核空间。这时候如果没有数据过来，则用户线程和对应的内核线程什么都做不了，一直等到有数据进来，并且完成了内核态的数据复制才继续返回用户空间继续执行。这整个过程是阻塞的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同步非阻塞IO&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5925925925925926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibwAicyibKwptvaTrLpel9o7xcicUu1licMQMqp5hCbA590GcR4TicHLbPZU9GcRqKFDJoeD85RB2w9K6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;486&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上图所示，用户线程发起一个read请求，会切换到内核空间。这时候如果没有数据过来，则直接返回。它可以再次轮循发起read，如果某一次发现有数据过来，则等待完成了内核态的数据复制才继续返回用户空间继续执行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个过程中，没有数据时是非阻塞的。有数据时是阻塞的，被称为非阻塞IO。这种方式涉及多次内核切换，某些情况下反而会影响性能。之前业界发生过一个由阻塞切换成非阻塞，流量高峰时性能不足引起的重大故障。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;IO多路复用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5876288659793815&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibwAicyibKwptvaTrLpel9o7x3R6o8o1QLpLXicnnBktC7rCnwib7AknBhK3XicTdoMdBSx1mlKbgtCoPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;485&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上图所示，用户线程发起一个select请求，会切换到内核空间。这时候如果没有数据过来，则阻塞直到有数据时返回给用户线程。用户线程收到有数据的消息，发起read操作同步等待直到完成内核态的数据复制才继续返回用户空间继续执行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这时候，是不是有朋友冒出来一个问题：似乎看不到多路复用的优势啊。似乎阻塞才是最佳选择啊。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上面都是以最简单的例子来介绍的，下面来看一个复杂一些的阻塞IO。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0589430894308942&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibwAicyibKwptvaTrLpel9o7xplOGIzPYnKtkRa7cibope8SBxPp6sR9mqdBNoqg0S1uJvjBeKPu4NwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;492&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上图所示，用户线程发起一个read请求，会切换到内核空间。这时候又有另外一个连接请求过来。这个线程不会立即影响这个连接请求，而是一直等到有数据进来，并且完成了内核态的数据复制才继续返回用户空间继续执行。处理完第一个连接的所有read操作之后，才会响应新的连接。新连接从accept（netty中建立连接的函数）到read都是同步阻塞的，每次只能处理一个连接的事件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7582644628099173&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibwAicyibKwptvaTrLpel9o7x60ehaqKgCXiciadN6g65vhRgJRnwyv1BU2cLzMiaDbricyZbwxnnuDjBcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;484&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上图所示，多路复用时，用户程序发起一个select操作，会返回一批事件，有read、write、accept（netty中建立连接的事件）。这时候，该等的时间select操作都已经做了。这时候，用户线程可以用新的线程(worker线程)直接去建立连接、复制数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;异步非阻塞IO&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里就要明确IO模型中，同步和异步的概念了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;同步：线程自己去获取结果。(一个线程)&lt;/p&gt;&lt;p&gt;异步：线程自己不去获取结果，而由其他线程送结果。(至少两个线程)&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6081632653061224&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibwAicyibKwptvaTrLpel9o7xt7uXTkFdFoPwoZdMWodV4Mic1JwZFDZo26aS8tKQUYaeJSN2eHcY9Pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;490&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上图所示，异步是通过回调来完成的。用户程序发起read操作只是去通知操作系统我在等待数据。另外一个线程等待数据复制完成回调read方法返回结果。异步IO从实现上是基于操作系统信号驱动的，也叫信号驱动IO。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;异步阻塞IO和异步非阻塞IO又有什么区别呢？看上面的过程，异步read操作去通知完操作系统肯定是直接返回的，也就是肯定是非阻塞的。其实根本没有异步阻塞这种说法，纯属误传。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最近发现，为了把一件事情讲清楚，要写的字越来越多。因为写的过程中会引出一些额外层面的问题需要解释。两者没有分离好反而不好理解。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我就想出来现在的办法，先在一篇文章中阐述一件事，同时抛出来一个问题让大家思考。然后另起一篇把问题讲透。就像本周的&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486533&amp;amp;idx=1&amp;amp;sn=a7a6bb50bb1ce4fb88510ab5b1fb9288&amp;amp;chksm=fafde6ebcd8a6ffd53ade8cd730c7436b93199b8bfcfa160d29056312432e4db5bfba3568eb0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《HTTP状态码1XX深入理解》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《&lt;span&gt;HTTP状态码1XX深入理解&lt;/span&gt;》&lt;/a&gt;和&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486543&amp;amp;idx=1&amp;amp;sn=e61c5e6e427fca705414108e3cc4fd64&amp;amp;chksm=fafde6e1cd8a6ff773e553fd317b64a8f78dc15e8c340fa9762cacef25a7b811c7322839dbfc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《【答案公布】客户端与服务端通信时，所有的http状态码是否都是服务端返回的？》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《&lt;span&gt;【&lt;/span&gt;&lt;span&gt;答案公布】客户端与服务端通信时，所有的http状态码是否都是服务端返回的？&lt;/span&gt;》&lt;/a&gt;。自己觉得这种方式更加清晰，大家觉得如何呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>16223002993e63e0fd319b68c9bd74e1</guid>
<title>你分库分表的姿势对么？——详谈水平分库分表</title>
<link>https://toutiao.io/k/eteqw6s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;22&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;作者：vivo平台产品开发团队-Han Lei&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、背景&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;提起分库分表，对于大部分服务器开发来说，其实并不是一个新鲜的名词。随着业务的发展，我们表中的数据量会变的越来越大，字段也可能随着业务复杂度的升高而逐渐增多，我们为了解决单表的查询性能问题，一般会进行分表操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;同时我们业务的用户活跃度也会越来越高，并发量级不断加大，那么可能会达到单个数据库的处理能力上限。此时我们为了解决数据库的处理性能瓶颈，一般会进行分库操作。不管是分库操作还是分表操作，我们一般都有两种方式应对，一种是垂直拆分，一种是水平拆分。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;关于两种拆分方式的区别和特点，互联网上参考资料众多，很多人都写过相关内容，这里就不再进行详细赘述，有兴趣的读者可以自行检索。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此文主要详细聊一聊，我们最实用最常见的水平分库分表方式中的一些特殊细节，希望能帮助大家避免走弯路，找到最合适自身业务的分库分表设计。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;87&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;【注1】本文中的案例均基于Mysql数据库，下文中的分库分表统指水平分库分表。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;【注2】后文中提到到M库N表，均指共M个数据库，每个数据库共N个分表，即总表个数其实为M*N。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、什么是一个好的分库分表方案？&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.1 方案可持续性&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;前期业务数据量级不大，流量较低的时候，我们无需分库分表，也不建议分库分表。但是一旦我们要对业务进行分库分表设计时，就一定要考虑到分库分表方案的可持续性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;那何为可持续性？&lt;/strong&gt;其实就是：业务数据量级和业务流量未来进一步升高达到新的量级的时候，我们的分库分表方案可以持续使用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一个通俗的案例，假定当前我们分库分表的方案为10库100表，那么未来某个时间点，若10个库仍然无法应对用户的流量压力，或者10个库的磁盘使用即将达到物理上限时，我们的方案能够进行平滑扩容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在后文中我们将介绍下目前业界常用的翻倍扩容法和一致性Hash扩容法。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2 数据偏斜问题&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一个良好的分库分表方案，它的数据应该是需要比较均匀的分散在各个库表中的。如果我们进行一个拍脑袋式的分库分表设计，很容易会遇到以下类似问题：&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;135&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;a、某个数据库实例中，部分表的数据很多，而其他表中的数据却寥寥无几，业务上的表现经常是延迟忽高忽低，飘忽不定。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;b、数据库集群中，部分集群的磁盘使用增长特别块，而部分集群的磁盘增长却很缓慢。每个库的增长步调不一致，这种情况会给后续的扩容带来步调不一致，无法统一操作的问题。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这边我们定义分库分表最大数据偏斜率为 ：（数据量最大样本 - 数据量最小样本）/ 数据量最小样本。一般来说，如果我们的最大数据偏斜率在5%以内是可以接受的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008465&quot; data-ratio=&quot;0.5117773019271948&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZgAnfMNvQibZvq4LtEbZeoBN27oY1KicgZHAXDu0Fs8ax3HeUjQYh2pKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;467&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、常见的分库分表方案&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.1 Range分库分表&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;顾名思义，该方案根据数据范围划分数据的存放位置。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;举个最简单例子，我们可以把订单表按照年份为单位，每年的数据存放在单独的库（或者表）中。如下图所示：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt; * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@return&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; String &lt;span class=&quot;code-snippet__title&quot;&gt;rangeShardByYear&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String orderId)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; year = Integer.parseInt(orderId.substring(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;t_order_&quot;&lt;/span&gt; + year;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过数据的范围进行分库分表，该方案是最朴实的一种分库方案，它也可以和其他分库分表方案灵活结合使用。时下非常流行的分布式数据库：TiDB数据库，针对TiKV中数据的打散，也是基于Range的方式进行，将不同范围内的[StartKey,EndKey)分配到不同的Region上。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面我们看看该方案的缺点：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;39&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;这点非常容易被遗忘，尤其是稳定跑了几年没有迭代任务，或者人员又交替频繁的模块。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里就需要注意了，因为是通过年份进行分库分表，那么元旦的那一天，你的定时任务很有可能会漏掉上一年的最后一天的数据扫描。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.2 Hash分库分表&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;虽然分库分表的方案众多，但是Hash分库分表是最大众最普遍的方案，也是本文花最大篇幅描述的部分。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;针对Hash分库分表的细节部分，相关的资料并不多。大部分都是阐述一下概念举几个示例，而细节部分并没有特别多的深入，如果未结合自身业务贸然参考引用，后期非常容易出现各种问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在正式介绍这种分库分表方式之前，我们先看几个常见的错误案例。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;常见错误案例一：非互质关系导致的数据偏斜问题&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; ShardCfg &lt;span class=&quot;code-snippet__title&quot;&gt;shard&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String userId)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; hash = userId.hashCode();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;// 对库数量取余结果为库序号&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; dbIdx = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(hash % DB_CNT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;// 对表数量取余结果为表序号&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; tblIdx = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(hash % TBL_CNT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShardCfg(dbIdx, tblIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;上述方案是初次使用者特别容易进入的误区，用&lt;span&gt;Hash&lt;/span&gt;值分别对分库数和分表数取余，得到库序号和表序号。其实稍微思索一下，我们就会发现，以10库100表为例，如果一个&lt;span&gt;Hash&lt;/span&gt;值对100取余为0，那么它对10取余也必然为0。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这就意味着只有0库里面的0表才可能有数据，而其他库中的0表永远为空！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;类似的我们还能推导到，0库里面的共100张表，只有10张表中(个位数为0的表序号)才可能有数据。这就带来了非常严重的数据偏斜问题，因为某些表中永远不可能有数据，最大数据偏斜率达到了无穷大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么很明显，该方案是一个未达到预期效果的错误方案。数据的散落情况大致示意图如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;303&quot; data-backw=&quot;578&quot; data-fileid=&quot;100008466&quot; data-ratio=&quot;0.5237449118046132&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZpIKzw3xB1jE6WvhrjwNfpRA2W6cPuvco1Lqm6bxgsmWChU7IegDqaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;737&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;事实上，只要库数量和表数量非互质关系，都会出现某些表中无数据的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;证明如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008467&quot; data-ratio=&quot;0.4548440065681445&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZJz6wCq1zwxLI062iahVEGn80PS0RcDfAdQ5hQWrB5kXPpwBcYyCrrKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;609&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;那么是不是只要库数量和表数量互质就可用用这种分库分表方案呢？比如我用11库100表的方案，是不是就合理了呢？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;答案是否定的，我们除了要考虑数据偏斜的问题，还需要考虑可持续性扩容的问题，一般这种&lt;span&gt;Hash&lt;/span&gt;分库分表的方案后期的扩容方式都是通过翻倍扩容法，那11库翻倍后，和100又不再互质。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当然，如果分库数和分表数不仅互质，而且分表数为奇数(例如10库101表)，则理论上可以使用该方案，但是我想大部分人可能都会觉得使用奇数的分表数比较奇怪吧。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;常见错误案例二：扩容难以持续&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如果避开了上述案例一的陷阱，那么我们又很容易一头扎进另一个陷阱，大概思路如下；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们把10库100表看成总共1000个逻辑表，将求得的Hash值对1000取余，得到一个介于[0，999)中的数，然后再将这个数二次均分到每个库和每个表中，大概逻辑代码如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; ShardCfg &lt;span class=&quot;code-snippet__title&quot;&gt;shard&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String userId)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ① 算Hash&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; hash = userId.hashCode();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ② 总分片数&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; sumSlot = DB_CNT * TBL_CNT;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ③ 分片序号&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; slot = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(hash % sumSlot);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ④ 计算库序号和表序号的错误案例&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; dbIdx = slot % DB_CNT ;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; tblIdx = slot / DB_CNT ;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShardCfg(dbIdx, tblIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;该方案确实很巧妙的解决了数据偏斜的问题，只要&lt;span&gt;Hash&lt;/span&gt;值足够均匀，那么理论上分配序号也会足够平均，于是每个库和表中的数据量也能保持较均衡的状态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008468&quot; data-ratio=&quot;0.7772357723577236&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZiaBvZ7pLrTdsmfFPRC4FlJvHbqGNRXYHQ6JyA7WJhC4lJC08466l5ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;615&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是该方案有个比较大的问题，那就是在计算表序号的时候，依赖了总库的数量，那么后续翻倍扩容法进行扩容时，会出现扩容前后数据不在同一个表中，从而无法实施。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如上图中，例如扩容前&lt;span&gt;Hash&lt;/span&gt;为1986的数据应该存放在6库98表，但是翻倍扩容成20库100表后，它分配到了6库99表，表序号发生了偏移。这样的话，我们在后续在扩容的时候，不仅要基于库迁移数据，还要基于表迁移数据，非常麻烦且易错。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;看完了上面的几种典型的错误案例，那么我们有哪些比较正确的方案呢？下面将结合一些实际场景案例介绍几种Hash分库分表的方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;常用姿势一：标准的二次分片法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上述错误案例二中，整体思路完全正确，只是最后计算库序号和表序号的时候，使用了库数量作为影响表序号的因子，导致扩容时表序号偏移而无法进行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;事实上，我们只需要换种写法，就能得出一个比较大众化的分库分表方案。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; ShardCfg &lt;span class=&quot;code-snippet__title&quot;&gt;shard2&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String userId)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ① 算Hash&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; hash = userId.hashCode();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ② 总分片数&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; sumSlot = DB_CNT * TBL_CNT;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ③ 分片序号&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; slot = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(hash % sumSlot);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ④ 重新修改二次求值方案&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; dbIdx = slot / TBL_CNT ;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; tblIdx = slot % TBL_CNT ;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShardCfg(dbIdx, tblIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;大家可以注意到，和错误案例二中的区别就是通过分配序号重新计算库序号和表序号的逻辑发生了变化。它的分配情况如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;426&quot; data-backw=&quot;568&quot; data-fileid=&quot;100008469&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZSdnFhxmkHZicZX7P3W6iceeraNwiaNibp2cexGiacNAmHNy1aMMEOVib60fQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;568&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那为何使用这种方案就能够有很好的扩展持久性呢？我们进行一个简短的证明：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008470&quot; data-ratio=&quot;0.5790251107828656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZG1Wg0sVFvdcAhJfwjfTgLpw0gtwLYbiaBiarNibLsAPLThFMHLIMj3r9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;677&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过上面结论我们知道，通过翻倍扩容后，我们的表序号一定维持不变，库序号可能还是在原来库，也可能平移到了新库中(原库序号加上原分库数)，完全符合我们需要的扩容持久性方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008471&quot; data-ratio=&quot;0.8562992125984252&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZII2eI7xAY7V3wxpXEO6LoU41HA0pQo1WpicEbq0UibFpqshjdp83B1RQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;508&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;【方案缺点】&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1、翻倍扩容法前期操作性高，但是后续如果分库数已经是大几十的时候，每次扩容都非常耗费资源。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2、连续的分片键&lt;span&gt;Hash&lt;/span&gt;值大概率会散落在相同的库中，某些业务可能容易存在库热点（例如新生成的用户&lt;span&gt;Hash&lt;/span&gt;相邻且递增，且新增用户又是高概率的活跃用户，那么一段时间内生成的新用户都会集中在相邻的几个库中）。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;常用姿势二：关系表冗余&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们可以将分片键对应库的关系通过关系表记录下来，我们把这张关系表称为&quot;路由关系表&quot;。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; ShardCfg &lt;span class=&quot;code-snippet__title&quot;&gt;shard&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String userId&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; tblIdx = Math.abs(userId.hashCode() % TBL_CNT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 从缓存获取&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Integer dbIdx = loadFromCache(userId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; == dbIdx) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// 从路由表获取&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            dbIdx = loadFromRouteTable(userId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; != dbIdx) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__comment&quot;&gt;// 保存到缓存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                saveRouteCache(userId, dbIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; == dbIdx) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// 此处可以自由实现计算库的逻辑&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            dbIdx = selectRandomDbIdx();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            saveToRouteTable(userId, dbIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            saveRouteCache(userId, dbIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShardCfg(dbIdx, tblIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;该方案还是通过常规的&lt;span&gt;Hash&lt;/span&gt;算法计算表序号，而计算库序号时，则从路由表读取数据。因为在每次数据查询时，都需要读取路由表，故我们需要将分片键和库序号的对应关系记录同时维护在缓存中以提升性能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上述实例中&lt;strong&gt;selectRandomDbIdx方法&lt;/strong&gt;作用为生成该分片键对应的存储库序号，这边可以非常灵活的动态配置。例如可以为每个库指定一个权重，权重大的被选中的概率更高，权重配置成0则可以将关闭某些库的分配。当发现数据存在偏斜时，也可以调整权重使得各个库的使用量调整趋向接近。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;该方案还有个优点，就是理论上后续进行扩容的时候，仅需要挂载上新的数据库节点，将权重配置成较大值即可，无需进行任何的数据迁移即可完成。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如下图所示：最开始我们为4个数据库分配了相同的权重，理论上落在每个库的数据概率均等。但是由于用户也有高频低频之分，可能某些库的数据增长会比较快。当挂载新的数据库节点后，我们灵活的调整了每个库的新权重。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008472&quot; data-ratio=&quot;0.44283121597096187&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZ9icic99AgSdJ8CpmiboWqb2Js9gMZw5qqfKn6icBRakKVlr3T0FbChF5Tw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;551&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;该方案似乎解决了很多问题，那么它有没有什么不适合的场景呢？当然有，该方案在很多场景下其实并不太适合，以下举例说明。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;a、每次读取数据需要访问路由表，虽然使用了缓存，但是还是有一定的性能损耗。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;b、路由关系表的存储方面，有些场景并不合适。例如上述案例中用户id的规模大概是在10亿以内，我们用单库百表存储该关系表即可。但如果例如要用文件MD5摘要值作为分片键，因为样本集过大，无法为每个md5值都去指定关系（当然我们也可以使用md5前N位来存储关系）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;c、&lt;strong&gt;饥饿占位问题，如下详叙&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们知道，该方案的特点是后续无需扩容，可以随时修改权重调整每个库的存储增长速度。但是这个愿景是比较缥缈，并且很难实施的，我们选取一个简单的业务场景考虑以下几个问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;【&lt;strong&gt;业务场景&lt;/strong&gt;】：以用户存放文件到云端的云盘业务为例，需要对用户的文件信息进行分库分表设计，有以下假定场景：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们使用路由表记录每个用户所在的库序号信息。那么该方案会有以下问题：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一：&lt;/strong&gt;我们总共有2亿个用户，只有3000W个产生过事务的用户。若程序不加处理，用户发起任何请求则创建路由表数据，会导致为大量实际没有事务数据的用户提前创建路由表。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;笔者最初存储云盘用户数据的时候便遇到了这个问题，客户端app会在首页查询用户空间使用情况，这样导致几乎一开始就为每个使用者分配好了路由。随着时间的推移，这部分没有数据的&quot;静默&quot;的用户，随时可能开始他的云盘使用之旅而“复苏”，从而导致它所在的库迅速增长并超过单个库的空间容量极限，从而被迫拆分扩容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解决这个问题的方案，其实就是只针对事务操作(例如购买空间，上传数据，创建文件夹等等)才进行路由的分配，这样对代码层面便有了一些倾入。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二、&lt;/strong&gt;按照前面描述的业务场景，一个用户最终平均有2000条数据，假定每行大小为1K，为了保证B+数的层级在3层，我们限制每张表的数据量在2000W，分表数为100的话，可以得到理论上每个库的用户数不能超过100W个用户。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;也就是如果是3000W个产生过事务的用户，我们需要为其分配30个库，这样会在业务前期，用户平均数据量相对较少的时候，存在非常大的数据库资源的浪费。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解决第二个问题，我们一般可以将很多数据库放在一个实例上，后续随着增长情况进行拆分。也可以后续针对将满的库，使用常规手段进行拆分和迁移。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;常用姿势三：基因法&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;还是由错误案例一启发，我们发现案例一不合理的主要原因，就是因为库序号和表序号的计算逻辑中，有公约数这个因子在影响库表的独立性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么我们是否可以换一种思路呢？我们使用相对独立的&lt;span&gt;Hash&lt;/span&gt;值来计算库序号和表序号。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; ShardCfg &lt;span class=&quot;code-snippet__title&quot;&gt;shard&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String userId)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; dbIdx = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(userId.substring(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;).hashCode() % DB_CNT );&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; tblIdx = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(userId.hashCode() % TBL_CNT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShardCfg(dbIdx, tblIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如上所示，我们计算库序号的时候做了部分改动，我们使用分片键的前四位作为&lt;span&gt;Hash&lt;/span&gt;值来计算库序号。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这也是一种常用的方案，我们称为基因法，即使用原分片键中的某些基因（例如前四位）作为库的计算因子，而使用另外一些基因作为表的计算因子。该方案也是网上不少的实践方案或者是其变种，看起来非常巧妙的解决了问题，然而在实际生成过程中还是需要慎重。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;笔者曾在云盘的空间模块的分库分表实践中采用了该方案，使用16库100表拆分数据，上线初期数据正常。然而当数据量级增长起来后，发现每个库的用户数量严重不均等，故猜测该方案存在一定的数据偏斜。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了验证观点，进行如下测试，随机2亿个用户id（16位的随机字符串），针对不同的M库N表方案，重复若干次后求平均值得到结论如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;8库100表&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;min=248305(dbIdx=2, tblIdx=64), max=251419(dbIdx=7, tblIdx=8), rate= 1.25%            √&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;16库100表&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;min=95560(dbIdx=8, tblIdx=42), max=154476(dbIdx=0, tblIdx=87), rate= 61.65%           ×&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;20库100表&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;min=98351(dbIdx=14, tblIdx=78), max=101228(dbIdx=6, tblIdx=71), rate= 2.93%&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们发现该方案中，分库数为16，分表数为100，数量最小行数仅为10W不到，但是最多的已经达到了15W+，最大数据偏斜率高达61%。按这个趋势发展下去，后期很可能出现一台数据库容量已经使用满，而另一台还剩下30%+的容量。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;该方案并不是一定不行，而是我们在采用的时候，要综合分片键的样本规则，选取的分片键前缀位数，库数量，表数量，四个变量对最终的偏斜率都有影响。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如上述例子中，如果不是16库100表，而是8库100表，或者20库100表，数据偏斜率都能降低到了5%以下的可接受范围。所以该方案的隐藏的&quot;坑&quot;较多，我们不仅要估算上线初期的偏斜率，还需要测算若干次翻倍扩容后的数据偏斜率。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如你用着初期比较完美的8库100表的方案，后期扩容成16库100表的时候，麻烦就接踵而至。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;常用姿势四：剔除公因数法&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;还是基于错误案例一启发，在很多场景下我们还是希望相邻的&lt;span&gt;Hash&lt;/span&gt;能分到不同的库中。就像N库单表的时候，我们计算库序号一般直接用&lt;span&gt;Hash&lt;/span&gt;值对库数量取余。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么我们是不是可以有办法去除掉公因数的影响呢？下面为一个可以考虑的实现案例：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; ShardCfg &lt;span class=&quot;code-snippet__title&quot;&gt;shard&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String userId)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; dbIdx = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(userId.hashCode() % DB_CNT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 计算表序号时先剔除掉公约数的影响&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; tblIdx = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;((userId.hashCode() / TBL_CNT) % TBL_CNT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShardCfg(dbIdx, tblIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;经过测算，该方案的最大数据偏斜度也比较小，针对不少业务从N库1表升级到N库M表下，需要维护库序号不变的场景下可以考虑。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;常用姿势五：一致性Hash法&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一致性Hash算法也是一种比较流行的集群数据分区算法，比如RedisCluster即是通过一致性Hash算法，使用16384个虚拟槽节点进行每个分片数据的管理。关于一致性Hash的具体原理这边不再重复描述，读者可以自行翻阅资料。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这边详细介绍如何使用一致性Hash进行分库分表的设计。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们通常会将每个实际节点的配置持久化在一个配置项或者是数据库中，应用启动时或者是进行切换操作的时候会去加载配置。配置一般包括一个[StartKey,Endkey)的左闭右开区间和一个数据库节点信息，例如：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;503&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;195&quot; data-fileid=&quot;100008473&quot; data-ratio=&quot;0.38911290322580644&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7AWBMjESn4VYZibMW4Z0ScG0EwOmwf17qWyia5Y2OsNDia6qk0D8HZbY9vDVCsQwKD2Zvh88luLJJeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;496&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;示例代码：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; TreeMap&amp;lt;Long, Integer&amp;gt; nodeTreeMap = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; TreeMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@&lt;span class=&quot;code-snippet__function&quot;&gt;Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;afterPropertiesSet&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;// 启动时加载分区配置&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    List&amp;lt;HashCfg&amp;gt; cfgList = fetchCfgFromDb();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (HashCfg cfg : cfgList) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        nodeTreeMap.put(cfg.endKey, cfg.nodeIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; ShardCfg &lt;span class=&quot;code-snippet__title&quot;&gt;shard&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String userId)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; hash = userId.hashCode();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; dbIdx = nodeTreeMap.tailMap((&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt;) hash, &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;).firstEntry().getValue();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; tblIdx = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(hash % &lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShardCfg(dbIdx, tblIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们可以看到，这种形式和上文描述的Range分表非常相似，Range分库分表方式针对分片键本身划分范围，而一致性Hash是针对分片键的&lt;span&gt;Hash&lt;/span&gt;值进行范围配置。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;正规的一致性Hash算法会引入虚拟节点，每个虚拟节点会指向一个真实的物理节点。这样设计方案主要是能够在加入新节点后的时候，可以有方案保证每个节点迁移的数据量级和迁移后每个节点的压力保持几乎均等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是用在分库分表上，一般大部分都只用实际节点，引入虚拟节点的案例不多，主要有以下原因：&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;188&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;a、应用程序需要花费额外的耗时和内存来加载虚拟节点的配置信息。如果虚拟节点较多，内存的占用也会有些不太乐观。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;b、由于mysql有非常完善的主从复制方案，与其通过从各个虚拟节点中筛选需要迁移的范围数据进行迁移，不如通过从库升级方式处理后再删除冗余数据简单可控。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;c、虚拟节点主要解决的痛点是节点数据搬迁过程中各个节点的负载不均衡问题，通过虚拟节点打散到各个节点中均摊压力进行处理。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而作为OLTP数据库，我们很少需要突然将某个数据库下线，新增节点后一般也不会从0开始从其他节点搬迁数据，而是前置准备好大部分数据的方式，故一般来说没有必要引入虚拟节点来增加复杂度。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、常见扩容方案&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.1 翻倍扩容法&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;翻倍扩容法的主要思维是每次扩容，库的数量均翻倍处理，而翻倍的数据源通常是由原数据源通过主从复制方式得到的从库升级成主库提供服务的方式。故有些文档将其称作&quot;&lt;strong&gt;从库升级法&lt;/strong&gt;&quot;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;理论上，经过翻倍扩容法后，我们会多一倍的数据库用来存储数据和应对流量，原先数据库的磁盘使用量也将得到一半空间的释放。如下图所示:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008475&quot; data-ratio=&quot;0.5273775216138329&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZwJlqfTzSZEDuiaibgRibNrqFj5CcibPicbBHlkvg3KO9tW4YDH1PnibrCPRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;694&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;具体的流程大致如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;①、时间点t1：为每个节点都新增从库，开启主从同步进行数据同步。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;②、时间点t2：主从同步完成后，对主库进行禁写。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;153&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;此处禁写主要是为了保证数据的正确性。若不进行禁写操作，在以下两个时间窗口期内将出现数据不一致的问题：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;a、断开主从后，若主库不禁写，主库若还有数据写入，这部分数据将无法同步到从库中。&lt;/p&gt;&lt;p&gt; b、应用集群识别到分库数翻倍的时间点无法严格一致，在某个时间点可能两台应用使用不同的分库数，运算到不同的库序号，导致错误写入。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;③、时间点t3：同步完全完成后，断开主从关系，理论上此时从库和主库有着完全一样的数据集。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;④、时间点t4：从库升级为集群节点，业务应用识别到新的分库数后，将应用新的路由算法。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;161&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;一般情况下，我们将分库数的配置放到配置中心中，当上述三个步骤完成后，我们修改分库数进行翻倍，应用生效后，应用服务将使用新的配置。这里需要注意的是，业务应用接收到新的配置的时间点不一定一致，所以必定存在一个时间窗口期，该期间部分机器使用原分库数，部分节点使用新分库数。这也正是我们的禁写操作一定要在此步完成后才能放开的原因。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;⑤、时间点t5：确定所有的应用均接受到库总数的配置后，放开原主库的禁写操作，此时应用完全恢复服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;⑥、启动离线的定时任务，清除各库中的约一半冗余数据。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;65&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;为了节省磁盘的使用率，我们可以选择离线定时任务清除冗余的数据。也可以在业务初期表结构设计的时候，将索引键的Hash值存为一个字段。&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;257&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;那么以上述常用姿势四为例，我们离线的清除任务可以简单的通过sql即可实现（需要防止锁住全表，可以拆分成若干个id范围的子sql执行）：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;delete from db0.tbl0 where hash_val mod 4 &amp;lt;&amp;gt; 0; &lt;/p&gt;&lt;p&gt;delete from db1.tbl0 where hash_val mod 4 &amp;lt;&amp;gt; 1;&lt;/p&gt;&lt;p&gt;delete from db2.tbl0 where hash_val mod 4 &amp;lt;&amp;gt; 2;&lt;/p&gt;&lt;p&gt;delete from db3.tbl0 where hash_val mod 4 &amp;lt;&amp;gt; 3;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;具体的扩容步骤可参考下图：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008476&quot; data-ratio=&quot;1.0336&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZfaZ1SZUkySuiccD7xiayc6kOPvIcWnVB3MnuvTQocGOCTmhvfbpl2hTw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;625&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：通过上述迁移方案可以看出，从时间点t2到t5时间窗口呢内，需要对数据库禁写，相当于是该时间范围内服务器是部分有损的，该阶段整体耗时差不多是在分钟级范围内。若业务可以接受，可以在业务低峰期进行该操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当然也会有不少应用无法容忍分钟级写入不可用，例如写操作远远大于读操作的应用，此时可以结合canel开源框架进行窗口期内数据双写操作以保证数据的一致性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;该方案主要借助于mysql强大完善的主从同步机制，能在事前提前准备好新的节点中大部分需要的数据，节省大量的人为数据迁移操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是缺点也很明显，一是过程中整个服务可能需要以有损为代价，二是每次扩容均需要对库数量进行翻倍，会提前浪费不少的数据库资源。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.2 一致性Hash扩容&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们主要还是看下不带虚拟槽的一致性Hash扩容方法，假如当前数据库节点DB0负载或磁盘使用过大需要扩容，我们通过扩容可以达到例如下图的效果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下图中，扩容前配置了三个&lt;span&gt;Hash&lt;/span&gt;分段，发现[-Inf，-10000）范围内的的数据量过大或者压力过高时，需要对其进行扩容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008477&quot; data-ratio=&quot;0.548460661345496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZVUcTNVh9jBUiaplWhveGiapBAxdNFVpicm6vyX77ylMziaqtryJv0Pia1vA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;877&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;主要步骤如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;①、&lt;strong&gt;时间点t1&lt;/strong&gt;：针对需要扩容的数据库节点增加从节点，开启主从同步进行数据同步。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;②、&lt;strong&gt;时间点t2&lt;/strong&gt;：完成主从同步后，对原主库进行禁写。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;35&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt; 此处原因和翻倍扩容法类似，需要保证新的从库和原来主库中数据的一致性。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;③、&lt;strong&gt;时间点t3&lt;/strong&gt;：同步完全完成后，断开主从关系，理论上此时从库和主库有着完全一样的数据集。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;④、&lt;strong&gt;时间点t4&lt;/strong&gt;：修改一致性Hash范围的配置，并使应用服务重新读取并生效。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;⑤、&lt;strong&gt;时间点t5&lt;/strong&gt;：确定所有的应用均接受到新的一致性Hash范围配置后，放开原主库的禁写操作，此时应用完全恢复服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;⑥、&lt;strong&gt;启动离线的定时任务&lt;/strong&gt;，清除冗余数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可以看到，该方案和翻倍扩容法的方案比较类似，但是它更加灵活，可以根据当前集群每个节点的压力情况选择性扩容，而无需整个集群同时翻倍进行扩容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、小结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;本文主要描述了我们进行水平分库分表设计时的一些常见方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们在进行分库分表设计时，可以选择例如范围分表，&lt;span&gt;Hash&lt;/span&gt;分表，路由表，或者一致性Hash分表等各种方案。进行选择时需要充分考虑到后续的扩容可持续性，最大数据偏斜率等因素。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;文中也列举了一些常见的错误示例，例如库表计算逻辑中公约数的影响，使用前若干位计算库序号常见的数据倾斜因素等等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们在实际进行选择时，一定要考虑自身的业务特点，充分验证分片键在各个参数因子下的数据偏斜程度，并提前规划考虑好后续扩容的方案。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:94.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c6a73aaa425dc10d4b723e20dac76821</guid>
<title>一种开发 Chrome 扩展程序的新姿势</title>
<link>https://toutiao.io/k/zq92ag2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6669921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/QRibyjewM1IDFSXtDKxJq496uG4ZQvgzPSRzTcJ5vskkdHyOWYTU0mAHYG1ibXNlcB39hIvtKEnMcTNyAgX6rU9g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在日常工作和生活中经常会使用到各种各样的 Chrome 扩展程序，比如 1Password 能自动帮你填充密码，Adblock 能帮你拦截广告，又或者是开发时经常会使用的 React Developer Tools，Redux DevTools 等等。这些扩展程序对效率的提升是巨大的。在日常开发过程中，我们也可以尝试开发自己的扩展程序，来辅助提升团队的开发体验和效率。本文首先会展示一个实际开发扩展程序的例子，从而让读者体会到当前开发时存在的问题，并基于此提出解决方案。如果你已经对如何开发一个扩展程序很熟悉了，那么直接看下文中【新的开发方式】部分，或者直接浏览对应的框架—— browser-extension-kit（https://github.com/alibaba/browser-extension-kit）即可。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;一个例子&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们要做一个可以重定向请求的扩展程序（类似 XSwitch），可以将当前页面的某个请求重定向到用户输入的地址，比如将某个环境下当前页面的 js 重定向到本地 webpack-dev-server 提供的 js，这样就可以实现线上调试功能了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了实现这个功能，我们首先需要一个页面能够让用户输入重定向前后对应的 url，这个页面会在用户点击该扩展程序的 icon 时展开，在 Chrome 官方文档中称为 popup。同时，实现具体重定向逻辑是在一个叫 background 的地方。根据官方指南，任何一个扩展程序都必须有一个 background，这个 background 存在于扩展程序的整个生命周期。通常情况下，你应该把所有核心业务逻辑和状态定义在 background 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在扩展程序的世界中，background 和 popup 都是完全独立的执行环境，这意味着彼此之间无法直接获取对方定义的变量、函数等。而用户输入的参数，需要从 popup 传递到 background 中，在扩展程序的场景下，官方提供了基于消息的机制来完成数据的流转。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们在 popup 中处理用户输入：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// popup.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; React &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 在这里向 background 发起连接，之后会通过这个 port 来监听或者发送消息&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; port = chrome.runtime.connect();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; App = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;&amp;gt;&lt;br/&gt;      &amp;lt;div&amp;gt;&lt;br/&gt;        原始 URL：&amp;lt;input onChange={&lt;span&gt;&lt;span&gt;e&lt;/span&gt; =&amp;gt;&lt;/span&gt; port.postMessage({ originalUrl: e.target.value })} /&amp;gt;&lt;br/&gt;      &amp;lt;&lt;span&gt;/div&amp;gt;&lt;br/&gt;     &amp;lt;div&amp;gt;&lt;br/&gt;        新 URL：&amp;lt;input onChange={e =&amp;gt; port.postMessage({ newUrl: e.target.value })} /&lt;/span&gt;&amp;gt;&lt;br/&gt;      &amp;lt;&lt;span&gt;/div&amp;gt;&lt;br/&gt;    &amp;lt;/&lt;/span&gt;&amp;gt;&lt;br/&gt;  );&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在 background 中，我们需要等待连接建立，之后即可监听消息，拿到对应的数据，并且处理重定向逻辑：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// background.js&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; originalUrl = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; newUrl = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;chrome.runtime.onConnect.addListener(&lt;span&gt;&lt;span&gt;port&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt; port.onMessage.addListener(&lt;span&gt;&lt;span&gt;message&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (message.originalUrl) {&lt;br/&gt;     originalUrl = message.originalUrl;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (message.newUrl) {&lt;br/&gt;     newUrl = message.newUrl;&lt;br/&gt;    }&lt;br/&gt;  });&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;chrome.webRequest.onBeforeRequest.addListener(&lt;span&gt;&lt;span&gt;request&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (!originalUrl || !newUrl || request.url !== originalUrl) {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; { redirectUrl: newUrl };&lt;br/&gt;}, {}, [&lt;span&gt;&#x27;blocking&#x27;&lt;/span&gt;])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个最简单的例子就写好了。当然，要让这个例子实际能跑起来，还需要提供一个 manifest.json 给浏览器，在这个文件中声明该扩展程序的元信息，在此略过。如果你有兴趣，还可以看看官方指南（https://developer.chrome.com/docs/extensions/mv3/getstarted/），浏览器提供了丰富的 API，能够帮助你实现任何你想做的事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然这个例子很简单，但是可以看到，如果要开发一个扩展程序，少不了要和消息机制打交道。对一个有实际业务逻辑的扩展程序来说，发送消息、接受消息是一个极高频的场景。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;实际的场景&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一个功能完整的扩展程序来说，显然不会像刚才的例子那样简单。通常来说，一个扩展程序会涉及到多个执行环境（如 content-script、 popup 等，这些都是 Chrome 提供的彼此互相独立的执行环境），同时可能提供多个功能，而 background 负责全局的状态管理和逻辑串联。在这个假设下，我们很自然的构造出如下的目录结构：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，我们应该会在 &lt;/span&gt;&lt;code&gt;background/index.ts&lt;/code&gt;&lt;span&gt;里初始化我们的 background 功能，在这里开始监听全局所有的消息，再根据消息的某个标识符（这里是 &lt;/span&gt;&lt;code&gt;port.name&lt;/code&gt;&lt;span&gt; ）分发到对应的模块中，由这些模块处理具体的业务逻辑，整个流程和 Redux 很像：&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里使用了 rxjs，很适合处理类似消息这样的场景，当然不用也行，这不是本文的重点&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { fromEventPattern, merge } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;rxjs&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { module1Processer, observable1 } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./module1&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { module2Processer, observable2 } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./module2&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 为了保存不同执行环境发来的消息，考虑到每个 port 生成时机、消息流向等不同，不得不保存外部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; devtoolPort: chrome.runtime.Port | &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; contentScript: chrome.runtime.Port | &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; pageScriptPort: chrome.runtime.Port | &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 以下 2 个 fromEventPattern，分别处理内部、外部消息&lt;/span&gt;&lt;br/&gt;fromEventPattern&amp;lt;chrome.runtime.Port&amp;gt;(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;handler&lt;/span&gt; =&amp;gt;&lt;/span&gt; chrome.runtime.onConnect.addListener(handler),&lt;br/&gt;  &lt;span&gt;&lt;span&gt;handler&lt;/span&gt; =&amp;gt;&lt;/span&gt; chrome.runtime.onConnect.removeListener(handler)&lt;br/&gt;).subscribe(&lt;span&gt;&lt;span&gt;port&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (port.name === &lt;span&gt;&#x27;devtool&#x27;&lt;/span&gt;) {&lt;br/&gt;   devtoolPort = port;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  port.onMessage.addListener(&lt;span&gt;&lt;span&gt;message&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; (message.type) {&lt;br/&gt;      &lt;span&gt;// 分发消息到具体的 module&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; module1: { module1Processer() }&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; module2: { module2Processer() }&lt;br/&gt;    }&lt;br/&gt;  });&lt;br/&gt;})&lt;br/&gt;fromEventPattern&amp;lt;chrome.runtime.Port&amp;gt;(&lt;br/&gt;  &lt;span&gt;&lt;span&gt;handler&lt;/span&gt; =&amp;gt;&lt;/span&gt; chrome.runtime.onConnectExternal.addListener(handler),&lt;br/&gt;  &lt;span&gt;&lt;span&gt;handler&lt;/span&gt; =&amp;gt;&lt;/span&gt; chrome.runtime.onConnectExternal.removeListener(handler)&lt;br/&gt;).subscribe(&lt;span&gt;&lt;span&gt;port&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (port.name === &lt;span&gt;&#x27;devtool&#x27;&lt;/span&gt;) {&lt;br/&gt;   devtoolPort = port;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 有些功能需要整合多个 module 内的数据，放在这里处理&lt;/span&gt;&lt;br/&gt;merge(observable1, observable1).pipe(...).subscribe(...)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在 UI 部分（如 popup ）中，不出意外肯定需要调用 background 的能力，并且监听来自 background 的消息。如果使用 React 来写 UI 的话，我们可能会将这部分功能包装到顶层 Context 里，向下传递：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { createContext, useState, useRef } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 手动建立连接&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; port = chrome.runtime.connect({ name: BACKGROUND_MESSAGE_NAME });&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; defaultStore: Store = {&lt;br/&gt;  &lt;span&gt;// 功能 1 的 state&lt;/span&gt;&lt;br/&gt;  module1: {...},&lt;br/&gt;  &lt;span&gt;// 功能 2 的 state&lt;/span&gt;&lt;br/&gt;  module2: {...},&lt;br/&gt;  &lt;span&gt;// 类似 Redux 中的 dispatch，用来传递消息，发送事件&lt;/span&gt;&lt;br/&gt;  dispatch: {&lt;br/&gt;    &lt;span&gt;// 功能 1 的 action&lt;/span&gt;&lt;br/&gt;    module1: &lt;span&gt;(&lt;span&gt;payload&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      port.postMessage({ &lt;span&gt;type&lt;/span&gt;: MessageType.emit, payload: { ...payload, domain: &lt;span&gt;&#x27;module1&#x27;&lt;/span&gt; } });&lt;br/&gt;    },&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; Context = createContext&amp;lt;Store&amp;gt;(defaultStore);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; ContextProvider = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; [store, setStore] = useState(defaultStore);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; storeRef = useRef(defaultStore);&lt;br/&gt;&lt;br/&gt;  useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    port.onMessage.addListener(&lt;span&gt;&lt;span&gt;msg&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// 手动监听事件，根据不同的事件更新不同的 state&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;switch&lt;/span&gt; (msg.type) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; MessageType.storeChanged: {&lt;br/&gt;          storeRef.current = {&lt;br/&gt;            ...storeRef.current,&lt;br/&gt;            [msg.payload.domain]: msg.payload.store,&lt;br/&gt;          };&lt;br/&gt;          setStore(storeRef.current);&lt;br/&gt;          &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;          &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;    });&lt;br/&gt;    &lt;span&gt;// eslint-disable-next-line react-hooks/exhaustive-deps&lt;/span&gt;&lt;br/&gt;  }, []);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;Context.Provider value={store}&amp;gt;&lt;br/&gt;      &amp;lt;App /&amp;gt;&lt;br/&gt;    &amp;lt;&lt;span&gt;/Context.Provider&amp;gt;&lt;br/&gt;  );&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;export default ContextProvider;&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在这种代码组织方式下，一旦功能变的复杂起来，会变的很难维护。而每当新增一个功能模块时，都少不了一大堆模板代码（监听消息并派发、UI 中初始化对应 store 等）。类比一下的话，我们在写原生 Redux 时不爽的地方，就是这里会感到不爽的地方。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;存在的问题&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过刚才的例子，我们可以看出，在开发 Chrome 扩展程序时，处理不同执行环境下的消息流转是一件很麻烦的事。事实上，执行环境还有很多：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;background&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;popup&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;content-script&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;page-script&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;devtools&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些环境之间互相隔离，通信只能依靠 message。在实际开发过程中，我们遇到了 2 类问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;框架能力缺失：社区中没有针对开发扩展程序的最佳实践，自然也就没有对应的框架能力，导致每个项目、模块之间重复建设或者逻辑混乱，例如如下这些常用模块或功能：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实际经验缺失：由于不是经常会开发到的场景，在初次上手时踩坑是在所难免的，例如：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;content-script 插入带 iframe 的页面时执行环境错乱（this 指向问题，意外创建多实例等）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Chrome API 在不同执行环境下可用性差异大&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要特别强调一下消息机制的问题，这是目前开发扩展程序面临的最大的问题。Chrome 扩展程序本身提供了基于&lt;code&gt;postMessage&lt;/code&gt;的消息传递机制，在实际开发中遇到如下问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不同执行环境之间，需要区分内部消息和外部消息（如 page-script 和 background 通信），他们的 API 存在差异&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;建立连接的顺序：主动建立连接的一方应该是生命周期较短的一方，但是生命周期在不同的场景下可能完全相反，例如 devtool 和 page-script 之间，完全取决于 devtool 的打开关闭时机&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并不是任意 2 个执行环境之间都可以直接建立连接，例如 page-script -&amp;gt; content-script -&amp;gt; background -&amp;gt; devtool，当扩展程序慢慢变的复杂起来之后，消息传递路径不明确，排查困难&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;message 传递方式有多种，需要根据实际情况区分使用，例如 page-script -&amp;gt; content-script，即可以使用 chrome 的 API（需要 background 中转），也可以直接使用 &lt;code&gt;window.postMessage&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单条 message 最大支持的数据大小是有限的，这在大部分开发场景下不是问题，但是如果扩展程序承载的功能对此有要求，那就比较麻烦了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;message 序列化：同样是一些特殊场景下凸显的问题，消息只能传递可被序列化的数据，导致该场景下需要认真考虑序列化方案，否则带来严重的性能问题，例如：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;循环引用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存占用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;嵌套&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类型（object/Map/Set/Regexp/Funtion）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;新的开发方式&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩展程序中不同执行环境相互隔离这一点无法改变，但是，在每个执行环境中，开发中应该专注于自己的逻辑，不用关心事件注册、逻辑派发、公共方法调用等这些通用能力，这些东西都应该交给框架去做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体上来说，新的方式下，业务逻辑通过继承特定的类，获取到父类上的公共方法，这些公共方法中包装好了关于消息、日志等的逻辑，可供直接使用。基于这个想法，我们可以设计出新的编写形式：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;module1/background.ts&lt;/code&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; rxjs &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;rxjs&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { Background } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;browser-extension-kit/background&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { subject, observable } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;browser-extension-kit&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyBackground &lt;span&gt;extends&lt;/span&gt; Background {&lt;br/&gt; &lt;span&gt;constructor&lt;/span&gt;(&lt;span/&gt;) {&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 对 myObservable1$ 额外的处理逻辑&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.myObservable1$.subscribe(&lt;span&gt;&lt;span&gt;data&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// do something with data&lt;/span&gt;&lt;br/&gt;    });&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 订阅消息&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.on(&lt;span&gt;&#x27;messageID&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;message&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;     &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    });&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 接受外界传来的 id 为 &#x27;uniqueID&#x27; 的消息，并且自动转化为 mySubject 的下一个值&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@subject&lt;/span&gt;(&lt;span&gt;&#x27;uniqueID&#x27;&lt;/span&gt;) &lt;span&gt;private&lt;/span&gt; mySubject = &lt;span&gt;new&lt;/span&gt; rxjs.Subject&amp;lt;&lt;span&gt;number&lt;/span&gt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 通过 @observable.popup 来声明当 myObservable1$ 发出一个值时，自动通过消息传递给 popup&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 这个消息的默认 id 为 &#x27;MyBackground::myObservable1$&#x27;，可自定义&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@observable&lt;/span&gt;.popup &lt;span&gt;private&lt;/span&gt; myObservable1$ = rxjs.from(...).pipe(&lt;br/&gt;    rxjs.shareReplay(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  );&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 当多个环境都需要订阅这个消息时，可以使用 @observable([&#x27;background&#x27;, &#x27;popup&#x27;])&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@observable&lt;/span&gt;([&lt;span&gt;&#x27;background&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;popup&#x27;&lt;/span&gt;]) &lt;span&gt;private&lt;/span&gt; myObservable2$ = rxjs.concat(&lt;br/&gt;    rxjs.from(...),&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.mySubject&lt;br/&gt;  ).pipe(&lt;br/&gt;    rxjs.shareReplay(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  );&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;module1/popup.tsx&lt;/code&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 popup、devtools 等环境中，通常都是一个 React 组件，这种情况下，框架提供了相应的 hooks 来帮助实现逻辑：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; React  &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { useMessage, usePostMessage } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;browser-extension-kit/popup&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; App = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; active = useMessage(&lt;span&gt;&#x27;MyBackground::active$&#x27;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; port = usePostMessage();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; toggleActive = useCallback(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    port.background(&lt;span&gt;&#x27;MyBackground::active&#x27;&lt;/span&gt;, !active);&lt;br/&gt;  }, [port]);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;div&amp;gt;&lt;br/&gt;      active: {active}&lt;br/&gt;   &amp;lt;button onClick={toggleActive}&amp;gt;click me&amp;lt;&lt;span&gt;/button&amp;gt;&lt;br/&gt;    &amp;lt;/&lt;/span&gt;div&amp;gt;&lt;br/&gt;  );&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; App;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;实现方式&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5594974131559497&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QRibyjewM1IDFSXtDKxJq496uG4ZQvgzPj2qsXHnJrTyQ0sfFwMGdFjfrKiaQ1twRm7UnVjr289CaSic4GPwKB6dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2706&quot;/&gt;&lt;br/&gt;可以猜到，如果要使用上述新的开发方式，核心是要在各个基类中内置处理消息的逻辑，background 负责所有消息的接受和转发，这一点依然不变，对外只暴露处理好的消息即可：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先，每当 content-script/page-script/devtools/popup 加载时，框架会自动向 background  建立连接，每一个 context 下，只会建立一次连接，连接建立后的 port 会存储在中心化的 port hub 内&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对每个 port，系统会自动对其订阅消息，这里的 port 和 port 内的 message，全部由框架接管，不对外暴露&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有的时候，开发者希望向某个 context 发送消息，但是对应的 context 还没有加载，考虑到这种情况，框架内部使用 rxjs 的 ReplaySubject  来中转 port 产生的 message，这样保证当一个 context 加载后，可以立即获取到加载前向这个 context 发送的消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;background 还会生成一个 dispatcher，用来分发消息。由于所有的消息都汇集到 background 中，dispatcher 会检查每个消息的接受方，如果是 background ，则直接派发给对应的处理者，如果是其他 context，则调用 port 将该消息传递给对应的 context&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后，每个 context 初始化时，也会生成一个 controller，这个 controller 订阅 ReplaySubject， 用来真正处理属于自己的 message&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，在这种方案下，所有的消息都会由 background 中转一下，在一定程度上造成了性能损失，这也算是在简洁和性能之间的一种取舍。而对于 devtools 和 popup 这 2 个 UI 的部分，目前只考虑了在 React 下的场景。此外，虽然监控、埋点、鉴权等也是较为通用的功能，但是不同的业务也存在着不同的诉求，所以这一部分无法集成到框架中，需要业务自行实现。如果符合你的口味，可以直接安装体验一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm i browser-extension-kit -S&lt;br/&gt;&lt;span&gt;// or&lt;/span&gt;&lt;br/&gt;yarn add browser-extension-kit&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多使用方式和 API 可在 https://github.com/alibaba/browser-extension-kit 查看，如果感兴趣，欢迎一起交流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg4MjE5OTI4Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/QRibyjewM1IBw49BrMXhuGAyhmAKA0jiabJkQx7dXYbRWRSffHNGyahxmAdToib28VaTjzFqyMKgcnvA4iaiczGy3ug/0?wx_fmt=png&quot; data-nickname=&quot;Alibaba F2E&quot; data-alias=&quot;alibabaf2e&quot; data-signature=&quot;阿里巴巴前端官方公众号&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关注&lt;/span&gt;&lt;span&gt;「Alibaba F2E」&lt;/span&gt;&lt;span&gt;微信公众号&lt;/span&gt;&lt;span&gt;把握阿里巴巴前端新动向&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>492648e91b5b0f73105be2abc7dbcc42</guid>
<title>2022 年升职加薪就靠它了！抓紧时间！</title>
<link>https://toutiao.io/k/fitvcz1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>10d857b4d18f9b949eff04d7e4c8f343</guid>
<title>学到了！将缓冲 channel 当做 Mutex 来使用</title>
<link>https://toutiao.io/k/moc4cef</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;作为 Go 官方包的一部分，sync 包有下面这段声明：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;sync 包提供了基本的同步原语，例如互斥锁。除了 Once 和 WaitGroup 类型之外，大多数其他类型都是为底层函数库准备的。通过 channel 和通信更好地完成更高级别的同步.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在你能找到的关于允许并发访问的绝大多数例子中，很多都是使用互斥锁来解决问题。然而，几乎很少有示例给我们展示如何使用 channel 提供同步机制。所以，这篇文章我们就来讨论下。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;互斥锁的特性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了使互斥锁起作用，访问共享变量时需要加锁，操作完成之后需要解锁。相同的互斥锁不允许多次加锁，以免出现竞态条件。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;无缓冲 channel 及其不足之处&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有接收方，发送者将会阻塞；相同地，如果没有发送方，接收者将会阻塞。基于这种特性，所以我们不能将无缓冲的 channel 作为锁来使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看看缓冲 channel 是否可以当做互斥锁来使用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;缓冲为 1 的 channel 的特性及其可取之处&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓冲大小为 1 的 channel 具有如下的特性：如果缓冲满了，发送时将会阻塞；如果缓存腾空，发送时就会解除阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，这种 channel 的阻塞特性是可取的，与互斥锁的特性做个对比：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓冲满时 &amp;lt;--&amp;gt; 上锁&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓冲腾空 &amp;lt;--&amp;gt; 解锁&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一起通过代码演示下这种特性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;演示：如何将缓冲 channel 作为 “锁” 来使用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们假设有一列名字需要写入到文件中，每个名字需要连续写 1000 次，且不允许不同名字出现交叉情况。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;errors&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; file, err := os.Create(&lt;span&gt;&quot;record.txt&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err := &lt;span&gt;recover&lt;/span&gt;(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   fmt.Printf(&lt;span&gt;&quot;Error encounter: %w&quot;&lt;/span&gt;, err)&lt;br/&gt;  }&lt;br/&gt;  file.Close()&lt;br/&gt; }()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;panic&lt;/span&gt;(errors.New(&lt;span&gt;&quot;Cannot create/open file&quot;&lt;/span&gt;))&lt;br/&gt; }&lt;br/&gt; ss := []&lt;span&gt;string&lt;/span&gt;{ &lt;span&gt;//string slice literals&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;James&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;Avery&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;Peter&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;John&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;Beau&quot;&lt;/span&gt;,&lt;br/&gt; }&lt;br/&gt; chanLock := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;//1&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, str := &lt;span&gt;range&lt;/span&gt; ss { &lt;span&gt;//2&lt;/span&gt;&lt;br/&gt;  wg.Add(&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;//amended thanks to response from Wang&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//Sheng&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(aString &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;   chanLock &amp;lt;- &lt;span&gt;1&lt;/span&gt; &lt;span&gt;//3&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1000&lt;/span&gt;; i++ {&lt;br/&gt;    file.WriteString(aString + &lt;span&gt;&quot;\n&quot;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;   &amp;lt;-chanLock &lt;span&gt;//4&lt;/span&gt;&lt;br/&gt;   wg.Done() &lt;span&gt;//5&lt;/span&gt;&lt;br/&gt;  }(str) &lt;span&gt;//pass by value&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码中，//1 我们创建了缓冲为 1 的 channel。//2 我们创建了个数与名字数量相同的 goroutine。//3 相当于加锁，//4 相当于解锁，这样就实现了多 goroutine 之间同步地将名字写入到 record.txt 文件，但每次只会有一个 goroutine 操作该文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，我们通过 WaitGroup 来保证子 goroutine 完成任务之前，主协程不会退出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希望这篇文章对你有帮助，enjoy coding!&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;via:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;https://mipsmonsta.medium.com/golang-using-buffered-channel-like-a-mutex-9c7c80ec5c27&lt;/span&gt;&lt;br/&gt;&lt;span&gt;作者：&lt;/span&gt;&lt;span&gt;Mipsmonsta&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span&gt;&lt;strong&gt;福利&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span/&gt;&lt;span&gt;我为大家整理了一份&lt;/span&gt;&lt;span&gt;从入门到进阶的Go学习资料礼包&lt;/span&gt;&lt;span&gt;，包含学习建议：入门看什么，进阶看什么。&lt;/span&gt;&lt;span&gt;关注公众号 「polarisxu」，回复 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;ebook&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 获取；还可以回复「&lt;strong&gt;进群&lt;/strong&gt;」，和数万 Gopher 交流学习。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMqm8cgtrMXjG1BLGg46vQNmUompBL02uYYwic9RicPbCnlKdZiacBF5Wv6RLgmGIqnBnwuWyP82ibYusiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>