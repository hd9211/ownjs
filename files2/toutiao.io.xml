<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>69e5df930ad0d682964fdf05d01c82fc</guid>
<title>MySQL 索引优化</title>
<link>https://toutiao.io/k/wwi18sc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-body&quot; itemprop=&quot;articleBody&quot;&gt;

      
        &lt;p&gt;千万不要看到 WHERE 条件中出现的字段就直接创建索引，因为创建太多的单列索引，反而会造成性能降低。&lt;/p&gt;
&lt;a id=&quot;more&quot;/&gt;

&lt;p&gt;无需一开始就创建索引，可以等到业务场景明确后，或者是数据量超过 1 万、查询变慢后，再针对需要查询、排序或分组的字段创建索引。我们可以把所有的请求记录到 general log 里面，或者我们把 long_query_time 设置为 0 把所有的 sql 都当成慢查询 sql，记录所有的 sql，然后在针对这些慢查询 sql 进行分析，看看哪些 sql 出现的频率最高，或者是哪些 sql 的执行耗时更高，然后我们针对这些 sql，再进行有针对性的去创建合适的索引。&lt;/p&gt;
&lt;p&gt;尽量索引轻量级的字段，比如能索引 int 字段就不要索引 varchar 字段。索引字段可以是部分前缀，在创建的时候指定字段索引长度。&lt;/p&gt;
&lt;p&gt;尽量不要再 sql 语句中使用 &lt;code&gt;SELECT *&lt;/code&gt;，而是 SELECT 必要的字段，甚至可以考虑使用联合索引来包含我们要搜索的字段，既能实现索引加速，又可以避免回表的开销。&lt;/p&gt;
&lt;h1 id=&quot;索引定义&quot;&gt;&lt;a href=&quot;#索引定义&quot; class=&quot;headerlink&quot; title=&quot;索引定义&quot;/&gt;索引定义&lt;/h1&gt;&lt;p&gt;索引是辅助存储引擎高效获取数据的一种数据结构，索引是数据的目录，便于存储引擎快速地定位数据，从而加快数据查询的效率。&lt;/p&gt;
&lt;h1 id=&quot;索引类型&quot;&gt;&lt;a href=&quot;#索引类型&quot; class=&quot;headerlink&quot; title=&quot;索引类型&quot;/&gt;索引类型&lt;/h1&gt;&lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;/&gt;数据结构&lt;/h2&gt;
&lt;p&gt;MySQL 常见的存储引擎，InnoDB、MyISAM 和 Memory 分别支持的索引类型&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;/&gt;
&lt;th align=&quot;center&quot;&gt;InnoDB&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;MyISAM&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;Memory&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;B+tree&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Yes&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Yes&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Hash&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;No&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;No&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Full-text&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Yes&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Yes&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;No&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;在 MySQL5.5 及以上版本中，InnoDB 存储引擎是 MySQL 关系型数据库默认使用的存储引擎，B+tree索引是 InnoDB存储引擎的默认索引类型。&lt;/p&gt;
&lt;p&gt;B+tree 和 B-tree 的区别：&lt;br/&gt;B+tree 只在叶子节点存储数据，而 B-tree 的非叶子节点也存储数据，所以 B+tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下能查询更多的节点，存储更高效，另外 B+tree 叶子节点在节点内部（也就是页结构的内部）记录之间是一个单链表，更适合 MySQL 中常见的基于范围的顺序检索场景，而 B-tree 无法做到这一点。&lt;/p&gt;
&lt;p&gt;B+tree 和红黑树的区别：&lt;br/&gt;对于有 N 个节点的 B+tree，其查询复杂度为 O(logdN)，d 为 B+tree 的度，表示节点允许的最大子节点个数为 d 个，在实际的运用中 d 值是大于 100 的，即使数据达到千万级别时 B+tree 的高度依然维持在 3-4 左右，保证了 3-4 次磁盘 I/O 操作就能查询到目标数据；而红黑树是二叉树，节点的子节点数为两个，意味着其查询复杂度为 O(logN)，比 B+tree 高出不少，因此红黑树检索到目标数据所需经历的磁盘 I/O 次数更多。&lt;/p&gt;
&lt;p&gt;B+tree 和 Hash 的区别：&lt;br/&gt;范围查询时 MySQL 常见的查询场景，Hash 表不适合做范围查询，更适合做等值查询，另外 Hash 表还存在 Hash 函数选择和 Hash 值冲突等问题。因为这些原因，B+tree 要比 Hash 有更广的适用场景。&lt;/p&gt;
&lt;h2 id=&quot;物理存储&quot;&gt;&lt;a href=&quot;#物理存储&quot; class=&quot;headerlink&quot; title=&quot;物理存储&quot;/&gt;物理存储&lt;/h2&gt;
&lt;h3 id=&quot;InnoDB&quot;&gt;&lt;a href=&quot;#InnoDB&quot; class=&quot;headerlink&quot; title=&quot;InnoDB&quot;/&gt;InnoDB&lt;/h3&gt;&lt;p&gt;InnoDB 表的索引按叶子节点存储的是否为完整表数据分为聚簇索引和二级索引，全表数据就是存储在聚簇索引中的，聚簇索引以外的其他索引叫做二级索引。InnDB 默认创建的主键索引就是聚簇索引，其他索引都是二级索引，也叫辅助索引或非聚簇索引。&lt;/p&gt;
&lt;p&gt;InnoDB 表要求必须有聚簇索引，默认在主键字段上建立聚簇索引，在没有主键字段情况下，表的第一个 NOT NULL 的唯一索引将被建立为聚簇索引，在前两者都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列，并在此列上创建聚簇索引。&lt;/p&gt;
&lt;p&gt;二级索引的叶子节点并不存储一行完整的表数据，而是存储了聚簇索引所在列的值，由于二级索引的叶子节点不存储完整的表数据，所以当通过二级索引查询到聚簇索引所在的列值后，还需要回到聚簇索引，也就是表数据本身进一步获取数据，也就是回表查询，回表查询需要额外的 B+tree 查询过程，必然增大查询耗时。&lt;/p&gt;
&lt;p&gt;需要注意的是，通过二级索引查询时，回表查询也不是必须的过程，当查询的所有字段在二级索引中就能找到时，就不需要回表，不需要回表查询的二级索引被称为覆盖索引，也称为触发了索引覆盖。通常可以使用 Explain 查看索引计划的 Extra 列的值是否为 Using index，如果是Using index则触发了索引覆盖，不需要回表查询，如果是 NUll，则未触发索引覆盖，需要回表查询。&lt;/p&gt;
&lt;h3 id=&quot;MyISAM&quot;&gt;&lt;a href=&quot;#MyISAM&quot; class=&quot;headerlink&quot; title=&quot;MyISAM&quot;/&gt;MyISAM&lt;/h3&gt;&lt;p&gt;MyISAM 存储引擎的表不存在聚簇索引，而使用的是二级索引，MyISAM 表中的主键索引和非主键索引的结构是一样的，它们的叶子节点不存放表数据，存放的是表数据的地址，即行指针，所以 MyISAM 表可以没有主键，MyISAM 表的数据和索引是分开的，是单独存放的，MyISAM 表中的主键索引和非主键索引的区别仅在与主键索引 B+tree 上的 key 必须符合主键的限制，非主键索引 B+tree 上的 key 只要符合相应字段的特性就可以了。&lt;/p&gt;
&lt;h2 id=&quot;字段特性&quot;&gt;&lt;a href=&quot;#字段特性&quot; class=&quot;headerlink&quot; title=&quot;字段特性&quot;/&gt;字段特性&lt;/h2&gt;
&lt;p&gt;主键索引是建立在主键字段上的索引，一张表最多只有一个主键索引，索引列值不允许有空值，通常在创建表的时候一起创建。&lt;/p&gt;
&lt;p&gt;唯一索引是建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列值允许为空。&lt;/p&gt;
&lt;p&gt;普通索引是建立在普通字段上的索引，即不要求字段是主键，也不就要求字段是 UNIQUE。&lt;/p&gt;
&lt;p&gt;前缀索引是指对字符类型的前几个字符或对二进制类型字段的前几个 bytes 建立的索引，而不是在整个字段上建立索引，前缀索引可以建立在类型为 char、varchar、binary、varbinary 的列上，可以大大减少索引占用的存储空间，也能提升索引的查询效率。但是，前缀索引也具有局限性，比如 order by 就无法使用前缀索引，无法把前缀索引用作覆盖索引。&lt;/p&gt;
&lt;h2 id=&quot;字段个数&quot;&gt;&lt;a href=&quot;#字段个数&quot; class=&quot;headerlink&quot; title=&quot;字段个数&quot;/&gt;字段个数&lt;/h2&gt;
&lt;p&gt;建立在单个列上的索引称为单列索引，建立在多个列上的索引称为联合索引，也叫复合索引。联合索引的非叶子节点保存了两个字段的值作为 B+tree 的 key 值，当 B+tree 上插入数据时，先按字段 id 比较，在 id 相同的情况下按 name 字段比较。&lt;/p&gt;
&lt;h1 id=&quot;创建索引&quot;&gt;&lt;a href=&quot;#创建索引&quot; class=&quot;headerlink&quot; title=&quot;创建索引&quot;/&gt;创建索引&lt;/h1&gt;&lt;h2 id=&quot;建立前缀索引&quot;&gt;&lt;a href=&quot;#建立前缀索引&quot; class=&quot;headerlink&quot; title=&quot;建立前缀索引&quot;/&gt;建立前缀索引&lt;/h2&gt;&lt;p&gt;通常字符类型的字段只需要对它前面几位字符建立索引就能满足性能要求了，过长的索引会使用更多的空间，也影响查找效率。&lt;/p&gt;
&lt;h2 id=&quot;建立覆盖索引&quot;&gt;&lt;a href=&quot;#建立覆盖索引&quot; class=&quot;headerlink&quot; title=&quot;建立覆盖索引&quot;/&gt;建立覆盖索引&lt;/h2&gt;&lt;p&gt;覆盖索引是指sql 中查询的所有字段，在索引 B+tree 的叶子节点上都能找得到的那些索引，使用覆盖索引查询时无需回表查询。&lt;/p&gt;
&lt;p&gt;如果 sql 中查询的字段无法触发已有索引的索引覆盖，就可以考虑去掉查询中不必要的字段，或者查询的字段数不多的话，可以再对这些字段建立新的联合索引，以便使用新的联合索引的索引覆盖。&lt;/p&gt;
&lt;p&gt;联合索引具有最左匹配原则，这个原则指明联合索引中的某个字段，如果想要被用到联合索引的过滤当中，除了这个字段不会使联合索引失效以外，另外一个必要的前提是这个字段的前一个字段也被用到了联合索引的过滤中，所以建立联合索引时的字段顺序对索引效率是有很大影响的，越靠前的字段被用于索引过滤的概率越高。&lt;/p&gt;
&lt;p&gt;通常会把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 sql 使用到，所谓区分度就是某个字段中不同值得个数与表的总行数的比值，比如性别字段，区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，相反像 uuid 这类字段就比较适合做索引或排在联合索引列的靠前的位置。&lt;/p&gt;
&lt;p&gt;依据联合索引的最左匹配原则，当联合索引中的某个字段使得索引失效时，这个字段就不能被联合索引用于索引过滤了。MySQL 从 5.6 版本开始对这种情况引入了索引下推机制，索引下推机制能减少二级索引的回表次数，也能减少查询引擎和 MySQL Server 层之间的数据传递量。&lt;/p&gt;
&lt;p&gt;json、group by、order by 语句的查询条件，要使用索引。&lt;br/&gt;参与 join 的字段上一般需要加上索引，尽量结合现有的索引字段进行 order by 操作，尽量避免低效的文件排序，group by 操作中，分组的字段一般需要加上索引，尽量避免创建临时表。&lt;/p&gt;
&lt;p&gt;尽量将数据表的字段设置为 NOT NULL 约束，这样做的好处是可以更好地使用索引，节省空间，甚至加速 sql 的运行。因为判断索引列是否为 NOT NULL，往往需要走全表扫描，因此我们最好在设计数据表的时候就将字段设置为 NOT NULL 约束，比如你可以将 INT 类型的字段，默认值设置为 0，将字符串类型的字段的默认值设置为空字符串。&lt;/p&gt;
&lt;p&gt;「&lt;a href=&quot;//cnswift.cn/posts/MySQL/mysql-index.html&quot;&gt;MySQL 索引创建与删除&lt;/a&gt;」&lt;/p&gt;
&lt;h1 id=&quot;索引的缺点&quot;&gt;&lt;a href=&quot;#索引的缺点&quot; class=&quot;headerlink&quot; title=&quot;索引的缺点&quot;/&gt;索引的缺点&lt;/h1&gt;&lt;p&gt;索引会带来数据写入延迟&lt;br/&gt;索引会引入额外的空间损耗&lt;br/&gt;索引能提升查询效率的场景是有限的，大数据量时，需要使用其他的，如读写分离、分库分表等方案&lt;/p&gt;
&lt;p&gt;sql 中使用了索引，但是查询仍然很慢的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sql 查询是事务中依赖多版本并发控制（MVCC）的快照读，需要多次版本回退&lt;/li&gt;
&lt;li&gt;索引失效&lt;/li&gt;
&lt;li&gt;锁等待，触发表锁，或行锁升级为表锁，或死锁&lt;/li&gt;
&lt;li&gt;不恰当的 sql 语句，比如，&lt;code&gt;SELECT *&lt;/code&gt;、&lt;code&gt;SELECT COUNT(*)&lt;/code&gt;、 在大数据表中使用&lt;code&gt;LIMIT M,N&lt;/code&gt; 分页查询，以及对非索引字段进行排序等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;索引优化&quot;&gt;&lt;a href=&quot;#索引优化&quot; class=&quot;headerlink&quot; title=&quot;索引优化&quot;/&gt;索引优化&lt;/h1&gt;&lt;h2 id=&quot;使用-EXPLAIN-查看-sql-执行计划&quot;&gt;&lt;a href=&quot;#使用-EXPLAIN-查看-sql-执行计划&quot; class=&quot;headerlink&quot; title=&quot;使用 EXPLAIN 查看 sql 执行计划&quot;/&gt;使用 EXPLAIN 查看 sql 执行计划&lt;/h2&gt;&lt;p&gt;我们通过 EXPLAIN 查看 sql 语句的执行计划，explain + sql 语句。&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;EXPLAIN &lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt; id,name &lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; blog_tag &lt;span class=&quot;keyword&quot;&gt;WHERE&lt;/span&gt; id &lt;span class=&quot;operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt; id &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt; select_type &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt;    &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt; partitions &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt; type  &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt; possible_keys &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt; key     &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt; key_len &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;ref&lt;/span&gt;  &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt; filtered &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt; Extra       &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt; SIMPLE      &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt; blog_tag &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;NULL&lt;/span&gt;       &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;PRIMARY&lt;/span&gt;       &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;       &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;100.00&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;Using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;|&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; warning (&lt;span class=&quot;number&quot;&gt;0.00&lt;/span&gt; sec)&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;id：每个执行计划都有一个 id，如果是一个联合查询，这里还将有多个 id。&lt;/li&gt;
&lt;li&gt;select_type：表示 SELECT 查询类型，常见的有 SIMPLE（普通查询、即没有联合查询、子查询）、PRIMARY（主查询）、UNION（UNION 中后面的查询）、SUBQUERT（子查询）等。&lt;/li&gt;
&lt;li&gt;table：当前执行计划查询的表，如果给表起别名了，则显示别名信息。&lt;/li&gt;
&lt;li&gt;partitions：访问的分区表信息。&lt;/li&gt;
&lt;li&gt;type：数据扫描类型，常见扫描类型的效率从低到高依次为 ALL（全表扫描）、index（全索引扫描）、range（索引范围扫描）、ref（非唯一索引扫描）、eq_ref（唯一索引扫描）、const（结果只有一条的主键或唯一索引扫描）。其中，ALL（全表扫描）和 index（全索引扫描）是要尽量避免的。&lt;/li&gt;
&lt;li&gt;possible_keys：可能使用的字段&lt;/li&gt;
&lt;li&gt;key：实际使用的字段&lt;/li&gt;
&lt;li&gt;key_len：索引的长度&lt;/li&gt;
&lt;li&gt;ref：关联 id 等信息。&lt;/li&gt;
&lt;li&gt;rows：扫描数据的行数&lt;/li&gt;
&lt;li&gt;filtered：查找到所需记录占总扫描记录数的比例&lt;/li&gt;
&lt;li&gt;Extra：额外的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中重点介绍一下 type 列的值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;system/const：表示只有一行数据匹配，此时根据索引查询一次就能找到对应的数据。&lt;/li&gt;
&lt;li&gt;eq_ref：使用唯一索引扫描，常见于多表连接中使用主键和唯一索引作为关联条件。&lt;/li&gt;
&lt;li&gt;ref：非唯一索引扫描，还可见于唯一索引最左前缀原则匹配扫描。&lt;/li&gt;
&lt;li&gt;range：索引范围扫描，比如 &lt;code&gt;&amp;lt;&lt;/code&gt;，&lt;code&gt;&amp;gt;&lt;/code&gt;，&lt;code&gt;between&lt;/code&gt; 等操作。&lt;/li&gt;
&lt;li&gt;index：索引全表扫描，此时遍历整个索引树。&lt;/li&gt;
&lt;li&gt;ALL：表示全表扫描，需要遍历全表来找到对应的行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;使用-Show-Profile-分析-sql-执行性能&quot;&gt;&lt;a href=&quot;#使用-Show-Profile-分析-sql-执行性能&quot; class=&quot;headerlink&quot; title=&quot;使用 Show Profile 分析 sql 执行性能&quot;/&gt;使用 Show Profile 分析 sql 执行性能&lt;/h2&gt;&lt;p&gt;MySQL 在 v5.0.37版本之后支持 SHow Profile 功能，可以分析执行线程的状态和时间，还支持进一步选择 ALL、CPU、MEMORY、BLOCK IO、CONTEXT SWITCHES 等类型来查询 sql 语句在不同系统资源上所消耗的时间。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SHOW PROFILE [type [, type] ... ]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;[FOR QUERY n]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;[LIMIT row_count [OFFSET offset]]&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;type 参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ALL：显示所有开销信息&lt;/li&gt;
&lt;li&gt;BLOCK IO：阻塞的输入输出次数&lt;/li&gt;
&lt;li&gt;CONTEXT SWITCHES：上下文切换相关开销信息&lt;/li&gt;
&lt;li&gt;CPU：显示CPU的相关开销信息 &lt;/li&gt;
&lt;li&gt;IPC：接收和发送消息的相关开销信息&lt;/li&gt;
&lt;li&gt;MEMORY ：显示内存相关的开销，目前无用&lt;/li&gt;
&lt;li&gt;PAGE FAULTS ：显示页面错误相关开销信息&lt;/li&gt;
&lt;li&gt;SOURCE ：列出相应操作对应的函数名及其在源码中的调用位置(行数) &lt;/li&gt;
&lt;li&gt;SWAPS：显示swap交换次数的相关开销信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MySQL 最新版本是默认开启 Show Profile 功能的，旧版本默认是关闭该功能的。&lt;/p&gt;
&lt;h1 id=&quot;索引失效&quot;&gt;&lt;a href=&quot;#索引失效&quot; class=&quot;headerlink&quot; title=&quot;索引失效&quot;/&gt;索引失效&lt;/h1&gt;&lt;h2 id=&quot;必定失效&quot;&gt;&lt;a href=&quot;#必定失效&quot; class=&quot;headerlink&quot; title=&quot;必定失效&quot;/&gt;必定失效&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;被使用的索引列上有表达式计算&lt;/li&gt;
&lt;li&gt;被使用的索引列上有函数操作&lt;/li&gt;
&lt;li&gt;被使用的索引列上有隐式类型转换操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;失效原因：&lt;br/&gt;索引的使用时依赖于整个 B-tree 索引树的遍历，而索引树的遍历依赖于索引树底层叶子节点的有序性，当被索引字段做了表达式计算，函数，隐式类型转换时，有可能这个字段新的排列顺序和原来在索引树的叶子节点层的排列顺序不一样了，这就破坏了索引树叶子节点层的有序性，当 sql 语句被执行时，MySQL 数据库的 sql 语句执行器无法判断原来的索引树还能否还能被检索使用，所以最后的结果就是 sql 语句执行器不使用该索引了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;like 匹配使用了左模糊匹配符’%abc’ 和使用了左右模糊匹配符’%abc%’，都会造成索引失效，只有 like 关键字的右模糊匹配’abc%’，能够依旧使用到索引&lt;/li&gt;
&lt;li&gt;被使用的索引字段，不是联合索引的最左字段&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;失效原因：&lt;br/&gt;因为 MySQL 中的索引树检索遵循最左匹配原则，B-tree 索引树的叶子节点的有序性也是建立在最左匹配的基础上的，如果直接使用索引键的中部或者后部进行 sql 查询，由于违背了最左匹配原则。MySQL 的 sql 语句执行器无法利用这个索引树进行检索。&lt;/p&gt;
&lt;p&gt;如果查询条件中使用 or，并且 or 的前后条件中有一个列没有索引，那么涉及的索引都不会被使用到。&lt;/p&gt;
&lt;p&gt;需要注意的是，如果查询过程中发生了索引覆盖，也就是不需要回表时，索引树还是可以被使用的。&lt;/p&gt;
&lt;h2 id=&quot;可能失效&quot;&gt;&lt;a href=&quot;#可能失效&quot; class=&quot;headerlink&quot; title=&quot;可能失效&quot;/&gt;可能失效&lt;/h2&gt;&lt;p&gt;索引列上用了!=、&amp;gt;、&amp;gt;=、&amp;lt;、&amp;lt;=、or、in 等&lt;br/&gt;索引列上用了 is null，is not null&lt;/p&gt;
&lt;p&gt;之所以说可能失效，是因为以上这些条件有比较大的概率会造成要扫描更多的数据，数据库一旦要扫描的数据量超过 20% 到 30% 范围的时候，会直接把执行计划变成一个全表扫描，不管有没有索引，它都会直接默认变成全表扫描。因为 MySQL 认为随机扫描的数据量太大了，还不如直接来一次全表扫描。&lt;/p&gt;
&lt;p&gt;需要注意的是，并不是所有情况下，都会使索引失效，都一定会变成全表扫描，应该是要根据实际扫描的数据库来决定是否会导致索引失效。也就是说如果 MySQL 查询优化器预估走索引的代价比全表扫描的代价还要大，则不走响应的索引，直接全表扫描，如果走索引比全表扫描的代价小，则使用索引。&lt;/p&gt;
&lt;p&gt;MySQL 查询优化器的预估并不是精确的，当优化器判定索引失效的情况下，我们可以通过 force index 的方式强制查询引擎走特定的索引。&lt;/p&gt;

    &lt;/div&gt;

    
    
    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3132a3b6e8c49410e92f445015ef42fe</guid>
<title>加班是努力还是表演？</title>
<link>https://toutiao.io/k/ezqj4ad</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;各位熟悉我文章的读者，肯定知道我文章的套路，以小见大。从管理者的角度给大家剖析，身边小事的真相。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天熟悉的旋律又来了。本文就来简单的聊一聊加班和努力这两个程序员绕不开的话题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大家都知道，年底了嘛，跟我们公司关系好的政府相关部门，他们的经费都急着要用掉，所以最近项目是异常的多。事情多，但人员又没有增加，自然而然的大家人均任务数就暴增。事情干不完，唯一能解决的，那就只能加班了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然加班有很多原因造成，但是最直接的原因就是短时间内任务太多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;116&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;插句题外话：我还是很能感受得到程序员们的那种痛苦的，因为我也是这样一步步走来，深知不易。当然作为老大，为了体现组织的人文关怀，感谢他们的付出，就组织了一次周边游，犒劳他们。由于公司的明文限制，不能出大杭州区域，只能选择附近的景点了。&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，加班等于努力吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;答案显而易见，当然不等于。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我给大家举一个例子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我团队内有一个小伙子，暂且就叫小憨吧。小憨虽然很老实，有一种憨憨的厚实感。工作特别勤奋，埋头苦干，每天几乎最晚下班的那个人，但是碰上复杂bug的时候，他却解决不了，还是需要寻求同事的帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他的努力更像是一种演出，根本没有深入工作之中，获取到其中的精华。&lt;/span&gt;&lt;span&gt;这种像演员一样的“表演努力”的人很多，人和人的差距，在每一件小事中，拉开距离。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小憨很忙，加班迟，工作不懈怠。每天甚至12小时的工作，那这12小时，都具体干了啥？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;真正工作的时间有多少？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;拉一泡屎用了30分钟？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开小差30分钟？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;刷&lt;/span&gt;&lt;span&gt;手机30分钟？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扯皮半小时？&lt;/span&gt;&lt;/p&gt;&lt;p lang=&quot;en-US&quot;&gt;&lt;span&gt;…&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我可以很确定的告诉大家，每个人的有效工作时间差异会非常大，所以最大的差异点：&lt;strong&gt;时间利用率&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;没有成效的忙碌，是低品质的勤奋，意味着你应该提升自己的学习逻辑了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如像小憨这样所谓的努力，好看不中用，其实对自己来说，就只是一种毫无意义，自我陶醉的表演。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然我还没有和小憨深入的聊过，还不确定他是否时间利用率真的很低。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是确实我们身边会存在这种人。在工作时间内玩着手机，刷着微博，或者只是做些简单的工作，而把重要的、复杂的工作放到一边，等到晚上或者截止日期临近之时再做，当他们不得不做时，才加班加点去赶进度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样的拖延症患者，实际正处在极不正常的工作状态之中。为了弥补前期的工作，而不断利用休息时间赶进度，这样只会让效率越来越低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然还存在这种可能性，&lt;strong&gt;他们为了感动自己，也是想通过这种行为说服自己，制造一种心理安慰&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;其实，真正的努力不是比谁把自己虐得更惨，也不是比谁花得时间更多，而是做好事，做对事，用有效的行动让每一天都看到自己的成长。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，我想说有一点。加班这个屎盆子的锅，当然得扣在某些无良企业了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在，很多企业都盛行一种加班风。从上至下，都以加班为荣，无论今天的工作需不需要加班，只要你来加班了，就说明你这个员工很不错，能吃苦，有潜力。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然你今天的工作内容已经完成了，可以准时下班了，但看到老板还在加班，你就不能走。领导都需要加班，又何况你一个小员工呢？不加点班，怎么能体现你的刻苦，上进呢？你只能大呼冤枉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;so，这种企业文化的公司，我劝大家还是不要考虑了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后总结下：加班当然不等于努力，因为有可能自己时间利用率太低，也有可能是你的公司太坑了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;最后，祝大家，2021万事如意。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;我是袁吴范，专注技术人的认知提升和职业成长&lt;span&gt;，&lt;/span&gt;公众号：”pointers“&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;你可以扫码加我微信：pointersss，空位不多。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PVZcww4Su3icxqW28rtgt1ib4Iia7XUeWT9EdiapicwxdyHQCKDTRFDWqvErKb0FiaLWzZXQkPANFr00h9RRBC249MHQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;记得备注下技术方向，我会将你拉进一个高品质群，&lt;/span&gt;&lt;span&gt;&lt;span&gt;群里有开发、产品、技术经理、技术总监&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt; &lt;em&gt;&lt;span&gt;推荐阅读（干货）&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-16033270487548=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16033270487548=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-right: 8px; margin-left: 8px; white-space: normal; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__135&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MTU0NTkxNA==&amp;amp;mid=2247484159&amp;amp;idx=1&amp;amp;sn=5d3b5d416a98f6a0d91e3d105b464924&amp;amp;chksm=cf65052af8128c3c1af6649b83d8ebdb5c0aad01f8bc9757976b7ab7418af68c155cdcf114d7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;7年，从“游戏少年”到大厂技术总监的逆袭之路&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;7年，从“游戏少年”到大厂技术总监的逆袭之路&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-16033270487548=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16033270487548=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-right: 8px; margin-left: 8px; white-space: normal; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__135&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MTU0NTkxNA==&amp;amp;mid=2247484330&amp;amp;idx=1&amp;amp;sn=0dc5e73f99dd1aa294bdb3ba574db586&amp;amp;chksm=cf65047ff8128d69dee9f6ce0a94f76df09159b2e45c0e78e1b760d5ace866283d8e0e0ff315&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;职场PUA，管理者的五宗罪&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-16033270487548=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16033270487548=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-right: 8px; margin-left: 8px; white-space: normal; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__135&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MTU0NTkxNA==&amp;amp;mid=2247484150&amp;amp;idx=1&amp;amp;sn=a75d0eb3811746b204007b36f260d7cc&amp;amp;chksm=cf650523f8128c356ef04f44ca060566d711e2aa8c83927c1206598ba9ae43b17fa23fc8fd08&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;35岁以后，不要成为程序员中的钻石&lt;/a&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>76579b6d89d4982899b271e42ee90947</guid>
<title>Java 并发编程之 JMM &amp; volatile 详解</title>
<link>https://toutiao.io/k/imzo6m8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、现代计算机理论模型与工作原理&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.1 冯诺依曼计算机模型&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;让我们来一起回顾一下大学计算机基础，现代计算机模型——冯诺依曼计算机模型，是一种将程序指令存储器和数据存储器合并在一起的计算机设计概念结构。依据冯·诺伊曼结构设计出的计算机称做冯.诺依曼计算机，又称存储程序计算机。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;计算机在运行指令时，会从存储器中一条条指令取出，通过译码（控制器），从存储器中取出数据，然后进行指定的运算和逻辑等操作，然后再按地址把运算结果返回内存中去。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;接下来，再取出下一条指令，在控制器模块中按照规定操作。依此进行下去。直至遇到停止指令。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;程序与数据一样存贮，按程序编排的顺序，一步一步地取出指令，自动地完成指令规定的操作是计算机最基本的工作模型。这一原理最初是由美籍匈牙利数学家冯.诺依曼于1945年提出来的，故称为冯.诺依曼计算机模型。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.521486643437863&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4sgOZHzHNvicJRyGy63jfjPRdVm71KtGxj9kC9tVrfCIHZhhZPPQmtE7Q79km5tDMuYyBraavllKw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;861&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;运算器：&lt;/strong&gt;顾名思义，主要进行计算，算术运算、逻辑运算等都由它来完成。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;存储器：&lt;/strong&gt;这里存储器只是内存，不包括内存，用于存储数据、指令信息。实际就是我们计算机中内存（RAM）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;控制器：&lt;/strong&gt;控制器是是所有设备的调度中心，系统的正常运行都是有它来调配。CPU包含控制器和运算器。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;输入设备：&lt;/strong&gt;负责向计算机中输入数据，如鼠标、键盘等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;输出设备：&lt;/strong&gt;负责输出计算机指令执行后的数据，如显示器、打印机等。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5556831228473019&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4sgOZHzHNvicJRyGy63jfjPJLGrvHibwibANn0sc6Q85iajVFUbCVpzKwFy2qrS87MJHzfA18gsgibEIw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;871&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;图中结构可以关注两个重点：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;I/O总线：&lt;/strong&gt;所有的输入输出设备都与I/O总线对接，保存我们的内存条、USB、显卡等等，就好比一条公路，所有的车都在上面行驶，但是毕竟容量有限，IO频繁或者数据较大时就会引起“堵车”&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;CPU：&lt;/strong&gt;当CPU运行时最直接也最快的获取存储的是寄存器，然后会通过CPU缓存从L1-&amp;gt;L2-&amp;gt;L3寻找，如果缓存都没有则通过I/O总线到内存中获取，内存中获取到之后会依次刷入L3-&amp;gt;L2-&amp;gt;L1-&amp;gt;寄存器中。现代计算机上我们CPU一般都是 1.xG、2.xG的赫兹，而我们内存的速度只有每秒几百M，所以为了为了不让内存拖后腿也为了尽量减少I/O总线的交互，才有了CPU缓存的存在，CPU型号的不同有的是两级缓存，有的是三级缓存，运行速度对比：&lt;strong&gt;寄存器 &amp;gt; L1 &amp;gt; L2 &amp;gt; L3 &amp;gt; 内存条&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.2 CPU多级缓存和内存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;CPU缓存即高速缓冲存储器，是位于CPU与主内存之间容量很小但速度很高的存储器。CPU直接从内存中存取数据后会保存到缓存中，当CPU再次使用时可以直接从缓存中调取。如果有数据修改，也是先修改缓存中的数据，然后经过一段时间之后才会重新写回主内存中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;CPU缓存最小单元是缓存行（cache line），目前主流计算机的缓存行大小为64Byte，CPU缓存也会有LRU、Random等缓存淘汰策略。CPU的三级缓存为多个CPU共享的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8151571164510166&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4sgOZHzHNvicJRyGy63jfjP79BiaArVUJ2pibNNFc6ecPjibaAHMLu7pqSGHl10YyphWYLEl4qpMSRhg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;541&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;（1）先读取寄存器的值，如果存在则直接读取&lt;/p&gt;&lt;p&gt;（2）再读取L1，如果存在则先把cache行锁住，把数据读取出来，然后解锁&lt;/p&gt;&lt;p&gt;（3）如果L1没有则读取L2，如果存在则先将L2中的cache行加锁，然后将数据拷贝到L1，再执行读L1的过程，最后解锁&lt;/p&gt;&lt;p&gt;（4）如果L2没有则读取L3，同上先加锁，再往上层依次拷贝、加锁，读取到之后依次解锁&lt;/p&gt;&lt;p&gt;（5）如果L3也没有数据则通知内存控制器占用总线带宽，通知内存加锁，发起内存读请求，等待回应，回应数据保存到L3（如果没有就到L2），再从L3/2到L1，再从L1到CPU，之后解除总线锁定。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在多处理器系统中，每个处理器都有自己的缓存，于是也引入了新的问题：缓存一致性。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致的情况。为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI、MOSI等等。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4sgOZHzHNvicJRyGy63jfjP2gqs0ibomibdxCOe4l4XoXduhf5Libvekaf1Th2nib9augs072GticHBIRw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;542&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.3 MESI缓存一致性协议&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存一致性协议中应用最广泛的就是MESI协议。主要原理是 CPU 通过总线&lt;strong&gt;嗅探机制&lt;/strong&gt;（监听）可以感知数据的变化从而将自己的缓存里的数据失效，缓存行中具体的几种状态如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.48059701492537316&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4GTiaAukSH0XSIvK4hMfoDF1uUhO8jdVTT3LWDnd8QnDEuBSBbziarDQwnay5RkIDPloBVxdJtianiaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;670&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.906396255850234&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4sgOZHzHNvicJRyGy63jfjPBMgl3twiaEd1MsicU3A58FibIXJQn8hmiaia2LLQVr76vVjgbJ6wXyjtGQA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;641&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;以上图为例，假设主内存中有一个变量x=1，CPU1和CPU2中都会读写，MESI的工作流程为：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（1）假设CPU1需要读取x的值，此时CPU1从主内存中读取到缓存行后的状态为E，代表只有当前缓存中独占数据，并利用CPU嗅探机制监听总线中是否有其他缓存读取x的操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（2）此时如果CPU2也需要读取x的值到缓存行，则在CPU2中缓存行的状态为S，表示多个缓存中共享，同时CPU1由于嗅探到CPU2也缓存了x所以状态也变成了S。并且CPU1和CPU2会同时嗅探是否有另缓存失效获取独占缓存的操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（3）当CPU1有写入操作需要修改x的值时，CPU1中缓存行的状态变成了M。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（4）CPU2由于嗅探到了CPU1的修改操作，则会将CPU2中缓存的状态变成 I 无效状态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（5）此时CPU1中缓存行的状态重新变回独占E的状态，CPU2要想读取x的值的话需要重新从主内存中读取。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、JMM模型&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.1  Java 线程与系统内核的关系&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Java线程在JDK1.2之前，是基于称为“绿色线程”（Green Threads）的用户线程实现的，而在JDK1.2中，线程模型替换为基于操作系统原生线程模型来实现。因此，在目前的JDK版本中，操作系统支持怎样的线程模型，在很大程度上决定了Java虚拟机的线程是怎样映射的，这点在不同的平台上没有办法达成一致，虚拟机规范中也并未限定Java线程需要使用哪种线程模型来实现。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.47757009345794393&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4sgOZHzHNvicJRyGy63jfjPNRnnUEJuWjA1icXAP6sianVItanlmxPRAjvVXLzrJaR3sChzOYXU2JQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1070&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;用户线程：&lt;/strong&gt;指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。另外，用户线程是由应用进程利用线程库创建和管理，不依赖于操作系统核心。不需要用户态/核心态切换，速度快。操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;内核线程： &lt;/strong&gt;线程的所有管理操作都是由操作系统内核完成的。内核保存线程的状态和上下文信息，当一个线程执行了引起阻塞的系统调用时，内核可以调度该进程的其他线程执行。在多处理器系统上，内核可以分派属于同一进程的多个线程在多个处理器上运行，提高进程执行的并行度。由于需要内核完成线程的创建、调度和管理，所以和用户级线程相比这些操作要慢得多，但是仍然比进程的创建和管理操作要快。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;基于线程的区别，我们可以引出java内存模型的结构。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2  什么是 JMM 模型&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Java内存模型(Java Memory Model简称JMM)是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝。工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5795006570302234&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4sgOZHzHNvicJRyGy63jfjPFcMNw9Y00UicxlYP1ziawt5WRC1FjbKmcsE5h6BJRyiaDM4RSgc26ia25g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;761&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;主内存&lt;/strong&gt;&lt;br/&gt;主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，从某个程度上讲应该包括了JVM中的堆和方法区。多条线程对同一个变量进行访问可能会发生线程安全问题。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;工作内存&lt;/strong&gt;&lt;br/&gt;主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。所以则应该包括JVM中的程序计数器、虚拟机栈以及本地方法栈。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.3 JMM 详解&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;需要注意的是JMM只是一种抽象的概念，一组规范，并不实际存在。对于真正的计算机硬件来说，计算机内存只有寄存器、缓存内存、主内存的概念。不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;工作内存同步到主内存之间的实现细节，JMM定义了以下八种操作：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.0973451327433628&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4GTiaAukSH0XSIvK4hMfoDFicQxaGJexVOc1oFEd5QLKw7iakWicrYDuaNFC8p2dsP3owCQ3Yr9XmNLw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;452&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如果要把一个变量从主内存中复制到工作内存中，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步到主内存中，就需要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4713804713804714&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4sgOZHzHNvicJRyGy63jfjPhnTakttUEjk3Xywp5snibphFGqvP0o3jI9QW8eufeD82s3HePKsAK6A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;891&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;（1）不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（2）一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或者assign）的变量。即就是对一个变量实施use和store操作之前，必须先自行assign和load操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(3）一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(4）如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新执行load或assign操作初始化变量的值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(5）如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(6）对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.4 JMM 如何解决多线程并发引起的问题&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;多线程并发下存在：&lt;strong&gt;原子性、可见性、有序性&lt;/strong&gt;三种问题。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。但是当线程运行的过程中，由于CPU上下文的切换，则线程内的多个操作并不能保证是保持原子执行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;解决：&lt;/strong&gt;除了JVM自身提供的对基本数据类型读写操作的原子性外，可以通过 synchronized和Lock实现原子性。因为synchronized和Lock能够保证任一时刻只有一个线程访问该代码块。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;之前我们分析过，程序运行的过程中是分工作内存和主内存，工作内存将主内存中的变量拷贝到副本中缓存，假如两个线程同时拷贝一个变量，但是当其中一个线程修改该值，另一个线程是不可见的，这种工作内存和主内存之间的数据同步延迟就会造成可见性问题。另外由于指令重排也会造成可见性的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;解决：&lt;/strong&gt;volatile关键字保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值立即被其他的线程看到，即修改的值立即更新到主存中，当其他线程需要读取时，它会去内存中读取新值。synchronized和Lock也可以保证可见性，因为它们可以保证任一时刻只有一个线程能访问共享资源，并在其释放锁之前将修改的变量刷新到内存中。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;有序性&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;在单线程下我们认为程序是顺序执行的，但是多线程环境下程序被编译成机器码的后可能会出现指令重排的现象，重排后的指令与原指令未必一致，则可能会造成程序结果与预期的不同。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;解决：&lt;/strong&gt;在Java里面，可以通过volatile关键字来保证一定的有序性。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、volatile关键字&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.1 volatile 的作用&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;volatile是 Java 虚拟机提供的轻量级的同步机制。volatile关键字有如下&lt;strong&gt;两个作用：&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.2 volatile 保证可见性&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;以下是一段多线程场景下存在可见性问题的程序。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;VolatileTest&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Thread&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; index = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; flag = &lt;span class=&quot;code-snippet__keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (!flag) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            index++;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        VolatileTest volatileTest = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; VolatileTest();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        volatileTest.start();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Thread.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;10000000&lt;/span&gt;; i++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            volatileTest.flag = &lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.out.println(volatileTest.index);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;运行可以发现，当 volatileTest.index 输出打印之后程序仍然未停止，表示线程依然处于运行状态，子线程读取到的flag的值仍为false。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; flag = &lt;span class=&quot;code-snippet__keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;尝试给flag增加volatile关键字后程序可以正常结束， 则表示子线程读取到的flag值为更新后的true。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;那么为什么volatile可以保证可见性呢？&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;可以尝试在JDK中下载hsdis-amd64.dll后使用参数-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly 运行程序，可以看到程序被翻译后的汇编指令，发现增加volatile关键字后给flag赋值时汇编指令多了一段 &quot;lock addl $0x0,(%rsp)&quot;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.33156498673740054&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4sgOZHzHNvicJRyGy63jfjPHgDKZLJq3KNd7zvV6XEhC58dNLTfOIwDEnsGtgu9cJYL5eoSazpJicw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;754&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;说明volatile保证了可见性正是这段lock指令起到的作用，查阅IA-32手册，可以得知该指令的主要作用：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;锁总线，其它CPU对内存的读写请求都会被阻塞，直到锁释放，不过实际后来的处理器都采用锁缓存替代锁总线，因为锁总线的开销比较大，锁总线期间其他CPU没法访问内存。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;lock后的写操作会回写已修改的数据，同时让其它CPU相关缓存行失效，从而重新从主存中加载最新的数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不是内存屏障却能完成类似内存屏障的功能，阻止屏障两遍的指令重排序。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.3 volatile 禁止指令重排&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Java 语言规范规定JVM线程内部维持顺序化语义。即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。指令重排序的意义是什么？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以下是源代码到最终执行的指令集的示例图：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.06064209274673008&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4sgOZHzHNvicJRyGy63jfjPmzmibiaNeBOeyX97lnR3eEEUGVDLDLYFusXibwRicBjZRLtuuWKg1ysmZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;841&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;as-if-serial原则：不管怎么重排序，单线程程序下编译器和处理器不能对存在数据依赖关系的操作做重排序。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;下面是一段经典的发生指令重排导致结果预期不符的例子：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;VolatileTest&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; a, b, x, y;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; boolean &lt;span class=&quot;code-snippet__title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;) throws InterruptedException&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        a = b = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        x = y = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Thread t1 = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            a = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            x = b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Thread t2 = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            b = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            y = a;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        t1.start();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        t2.start();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        t1.&lt;span class=&quot;code-snippet__keyword&quot;&gt;join&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        t2.&lt;span class=&quot;code-snippet__keyword&quot;&gt;join&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (x == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; y == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String[] args&lt;/span&gt;) throws InterruptedException&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; ; i++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            VolatileTest volatileTest = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; VolatileTest();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (volatileTest.test()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(i);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;按照我们正常的逻辑理解，在不出现指令重排的情况下，x、y永远只会有下面三种情况，不会出现都为0，即循环永远不会退出。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;x = 1、y = 1&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;x = 1、y = 0&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;x = 0、y = 1&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;但是当我们运行的时候会发现一段时间之后循环就会退出，即出现了x、y都为0的情况，则是因为出现了指令重排，时线程内的对象赋值顺序发生了变化。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而这个问题给参数增加volatile关键字即可以解决，此处是因为JMM针对重排序问题限制了规则表。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4200913242009132&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4GTiaAukSH0XSIvK4hMfoDFPIr4eq9sB4S3AnqdaCkR5U2LxH9ZZRV8Ribp1knzDKEJQnQwXxdHqpA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;438&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。一个读的操作为load，写的操作为store。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;在每个volatile写操作的前面插入一个StoreStore屏障。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在每个volatile写操作的后面插入一个StoreLoad屏障。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在每个volatile读操作的后面插入一个LoadLoad屏障。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在每个volatile读操作的后面插入一个LoadStore屏障。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.18005540166205&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4sgOZHzHNvicJRyGy63jfjP8CGktic0tnmApgPqrDNBK0q1yeUF3yXuAg0R32wc6yzneENwqGSTOzQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;361&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以上图为例，普通写与volatile写之间会插入一个StoreStore屏障，另外有一点需要注意的是，volatile写后面可能有的volatile读/写操作重排序，因为编译器常常无法准确判断是否需要插入StoreLoad屏障。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;则JMM采用了比较保守的策略：&lt;strong&gt;在每个volatile写的后面插入一个StoreLoad屏障。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么存汇编指令的角度，CPU是怎么识别到不同的内存屏障的呢：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;(1）sfence：&lt;/strong&gt;实现Store Barrior 会将store buffer中缓存的修改刷入L1 cache中，使得其他cpu核可以观察到这些修改，而且之后的写操作不会被调度到之前，即sfence之前的写操作一定在sfence完成且全局可见。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;（2）lfence：&lt;/strong&gt;实现Load Barrior 会将invalidate queue失效，强制读取入L1 cache中，而且lfence之后的读操作不会被调度到之前，即lfence之前的读操作一定在lfence完成（并未规定全局可见性）。&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（3）mfence：&lt;/strong&gt;实现Full Barrior 同时刷新store buffer和invalidate queue，保证了mfence前后的读写操作的顺序，同时要求mfence之后写操作结果全局可见之前，mfence之前写操作结果全局可见。&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（4）lock&lt;/strong&gt;：用来修饰当前指令操作的内存只能由当前CPU使用，若指令不操作内存仍然由用，因为这个修饰会让指令操作本身原子化，而且自带Full Barrior效果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以可以发现我们上述分析到的&quot;lock addl&quot;指令也是可以实现内存屏障效果的。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、volatile 拓展&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.1 滥用 volatile 的危害&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;经过上述的总结我们可以知道volatile的实现是根据MESI缓存一致性协议实现的，而这里会用到CPU的嗅探机制，需要不断对总线进行内存嗅探，大量的交互会导致总线带宽达到峰值。因此滥用volatile可能会引起&lt;strong&gt;总线风暴&lt;/strong&gt;，除了volatile之外大量的CAS操作也可能会引发这个问题。所以我们使用过程中要视情况而定，适当的场景下可以加锁来保证线程安全。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.2 如何不用 volatile 不加锁禁止指令重排？&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;指令重排的示例中我们既然已经知道了插入内存屏障可以解决重排问题，那么用什么方式可以手动插入内存屏障呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;JDK1.8之后可以在Unsafe魔术类中发现新增了插入屏障的方法。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;loadFence&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt; * Ensures lack of reordering of stores before the fence&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt; * with loads or stores after the fence.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt; * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@since&lt;/span&gt; 1.8&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;storeFence&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt; * Ensures lack of reordering of loads or stores before the fence&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt; * with loads or stores after the fence.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt; * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@since&lt;/span&gt; 1.8&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;fullFence&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;（1）loadFence()表示该方法之前的所有load操作在内存屏障之前完成。&lt;/p&gt;&lt;p&gt;（2）storeFence()表示该方法之前的所有store操作在内存屏障之前完成。&lt;/p&gt;&lt;p&gt;（3）fullFence()表示该方法之前的所有load、store操作在内存屏障之前完成。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可以看到这三个方法正式对应了CPU插入内存屏障的三个指令lfence、sfence、mfence。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因此我们如果想手动添加内存屏障的话，可以用Unsafe的这三个native方法完成，另外由于Unsafe必须由bootstrap类加载器加载，所以我们想使用的话需要用反射的方式拿到实例对象。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt; * 反射获取到unsafe&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; Unsafe &lt;span class=&quot;code-snippet__title&quot;&gt;reflectGetUnsafe&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;) throws NoSuchFieldException, IllegalAccessException&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Field field = Unsafe.class.getDeclaredField(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;theUnsafe&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    field.setAccessible(&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; (Unsafe) field.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 上述示例中手动插入内存屏障&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Thread t1 = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    a = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;// 插入LoadStore()屏障&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    reflectGetUnsafe().storeFence();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    x = b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Thread t2 = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    b = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;// 插入LoadStore()屏障&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    reflectGetUnsafe().storeFence();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    y = a;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.3 单例模式的双重检查锁为什么需要用 volatile&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;以下是单例模式双重检查锁的初始化方式：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; Singleton instance = &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; Singleton &lt;span class=&quot;code-snippet__title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;synchronized&lt;/span&gt; (Singleton.class) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                instance = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;那么为什么初始化对象加了双重检查和synchronized加锁来保证原子性，可是实例对象instance还要用volatile修饰呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为synchronized虽然加了锁，但是代码块内的程序是无法保证指令重排的，其中instance = new Singleton(); 方法其实是拆分成多个指令，我们用javap -c 查看字节码，可以发现这段对象初始化操作是分成了三步：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3695652173913043&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4sgOZHzHNvicJRyGy63jfjPTTapFiaiauEdOZm4Eu5MCurJxJENxa4sf46fkJ2RmxMyx3YsV7yj1Bjw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;644&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;（1）new ：创建对象实例，分配内存空间&lt;/p&gt;&lt;p&gt;（2）invokespecial ：调用构造器方法，初始化对象&lt;/p&gt;&lt;p&gt;（3）aload_0 ：存入局部方法变量表&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以上三步如果顺序执行的话是没问题的，但是如果2、3步发生指令重排，则极端并发情况下可能出现下面这种情况：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5320910973084886&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4GTiaAukSH0XSIvK4hMfoDFu3FZwZwb5dIW2ffArn1LKvmtS6t213picp4dH5OMudbxC3787YA75dA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;483&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;所以，为了保证单例对象顺利的初始化完成，应该给对象加上volatile关键字禁止指令重排。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;随着计算机和CPU的逐步升级，CPU缓存帮我们大大提高了数据读写的性能，在高并发的场景下，CPU通过MESI缓存一致性协议针对缓存行的失效进行处理。基于JMM模型，将用户态和内核态进行了划分，通过java提供的关键字和方法可以帮助我们解决原子性、可见性、有序性的问题。其中volatile关键字的使用最为广泛，通过添加内存屏障、lock汇编指令的方式保证了可见性和有序性，在我们开发高并发系统的过程中也要注意volatile关键字的使用，但是不能滥用，否则会导致总线风暴。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;参考资料&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;书籍：《java并发编程实战》&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-1-manual.html&quot; textvalue=&quot; IA-32手册&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt; IA-32手册&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://segmentfault.com/a/1190000020959908&quot; textvalue=&quot;双重检查锁为什么要使用volatile？&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;双重检查锁为什么要使用volatile？&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://zhuanlan.zhihu.com/p/29881777&quot; textvalue=&quot;java内存模型总结&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;java内存模型总结&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://stackoverflow.com/questions/23603304/java-8-unsafe-xxxfence-instructions&quot; textvalue=&quot;Java 8 Unsafe: xxxFence() instructions&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;Java 8 Unsafe: xxxFence() instructions&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2accab01d9ee5a9c80deedf79328684f</guid>
<title>性能优化那些事</title>
<link>https://toutiao.io/k/ml4lzrd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot; itemprop=&quot;articleBody&quot;&gt;&amp;#13;
&lt;p&gt;性能在软件工程诞生时就占据着非常重要的位置，如何用更少的硬件资源来支撑更多的功能、来完成更多的任务是软件工程师的职责，也是用来衡量一个软件工程师技艺高低的标准。这跟炒菜是一个道理，同样的食材，在饭店的师傅手里跟普通人手里的做法是有很大的差别的；食堂师傅是工程化的做法，讲究是短时间炒制更多的菜，而且味道不能掉；而普通人则比较随意，没有什么章法，而且可能只是爱好或者放松的渠道，所以不用考虑炮制的性能如何，能不能达到预计的目标。简单来说，厨师是靠手艺去赚钱，而其他人只是玩玩。那么程序员的手艺体现在哪呢？可以肯定的说，性能调优是最重要的一环，也是最基本的一环，甚至我觉得只有掌握这个技能后才能够进阶做构架或者做设计，否则如果反其道而行之则会举步维艰。&lt;/p&gt;
&lt;p&gt;这时你可能会说，我是觉得性能是很重要，但是怎么去学呢？IT是个发展迅速的行业，每年涌现的新技术，新框架数不胜数，多如繁星，往往还没学懂Java，Go都快被淘汰了……一茬接一茬，无从下手。如果你常常有这个感觉，那么这篇文章可能对你有帮助。&lt;/p&gt;
&lt;h3&gt;性能优化的套路&lt;/h3&gt;
&lt;p&gt;先说结论，性能优化或者说如何能够开发出效率更高的程序来（当然硬件资源一样且使用率一样的条件下），只有两条路：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 掌握局部性原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 掌握基本的算法设计与分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在现有计算机构架下（冯诺依曼构架）这是调优的充分必要条件，换句话说就是，如果你写了一个性能比别人好的程序，那么只有两种情况，要么是局部性原理用得更好，要么是就是采用了更好的算法；同时，如果你想要写出比别人好的程序，那么你也只有两条路可以走，运用更底层的局部性优化设计，或者设计更好的算法来解决这个问题。&lt;/p&gt;
&lt;h4&gt;局部性原理&lt;/h4&gt;
&lt;p&gt;如果你在软件工程领域“阅历”足够丰富，你就会有恍然大悟的感觉，因为这种例子实在太多：Linux中的硬盘缓冲、页缓存，Redis中元素较少的时候用ziplist代替hashmap可能还会带来性能的提升，内存的减少；Kafka依赖的磁盘缓存，分区存储机制，Mysql的B+树索引；更底层的CPU的Cacheline技术，分页技术等等其实都是用了局部性原理来作为理论基础的。那么什么是局部性原理呢？&lt;/p&gt;
&lt;p&gt;简单来说分为三个要点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;程序总是按照“批”来处理数据，这样效率最高；比如：CPU读取内存是按照批来处理如：一个cacheline=64/128byte,内存与硬盘按照4KB来读取。因为计算机结构的特点，各级设备（CPU到内存到硬盘与外设）之间的访问速度是有数量级的差别；所以就注定不能一个个字节来读取；这个现象决定计算机优化的方向，被称为&lt;strong&gt;冯诺依曼瓶颈&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最近访问过的资源（内存位置），可能近期内还会被访问，这个叫做&lt;strong&gt;时间局部性&lt;/strong&gt;，对应的解决方案是&lt;strong&gt;缓存&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当前位置内存被访问过，那么大概率旁边的内存也会被后续访问，这个叫做&lt;strong&gt;空间局部性&lt;/strong&gt;，对应的解决方案是&lt;strong&gt;预加载&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以推导的顺序是：正是因为现代计算机有冯诺依曼瓶颈所以需要用缓存与预加载来提高程序的性能，否则会因为IO过重，资源得不到利用而效率偏低。&lt;/p&gt;
&lt;p&gt;还是拿做饭这件事举例子。当我们去买菜的时候，会尽可能的减少去菜市场的时间，也肯定不可能发现什么菜没有了再临时去菜市场购买，这样“IO”就太重了，要使用局部性原理来解决。就炒菜的例子来说，我们要炒青椒炒肉这个菜；首先是买菜，我们发现在买青椒的时候可以把葱姜蒜也都一并买了，因为蔬菜区往往是相邻的；而买肉的时候，尽量也把酱油醋都一并买了，它们也是很可能也是挨着的；这种在空间上相邻的提前加载这就是“&lt;strong&gt;预加载&lt;/strong&gt;”了；而回到家，我们开始炒菜的时候，厨房的布置往往是炒菜的锅子跟油盐酱醋是分开放置的，但是炒菜的时候要经常加盐、放酱油，所以为了减少来回取油盐的时间，会在炒菜的时候将配菜与油盐放置在炒锅的附近，加快炒菜的速度，等炒完后又重新放回去，这个就叫做“&lt;strong&gt;缓存&lt;/strong&gt;”的思维——把经常使用的资源放在工作较近的地方，等使用完再释放。&lt;/p&gt;
&lt;p&gt;在Linux内核中，我们可以看到很多的buffer与cache，这些数据结构都是局部性原理的具体使用实例。比如，我们知道内存跟磁盘之间IO速度相差5个数量级。那么往往会出现，一个进程刚写入磁盘的数据，又要被其他进程读取，那么一来一回CPU都在等待磁盘读取数据，十分浪费资源，那么如果将磁盘的数据放入磁盘写buffer，读的时候优先从buffer中读取，而buffer都是在内存中，这样就弥补了这个性能的gap，这就是“时间局部性”原理的使用，也就是我们常说的“缓存”，或者“空间换时间”；&lt;/p&gt;
&lt;p&gt;Mysql数据库有个特点就是数据是存在磁盘上，读取记录时需要将数据从磁盘加载到内存然后进入CPU计算得出结果，所以会横跨三个IO边界——磁盘、内存与CPU，它们之间都有好几个数量级的延迟，所以IO性能的平衡就十分的重要。其中比较典型的就是B+树这种针对外部存储型的数据结构的引入，它十分贴合磁盘IO的“口味”。磁盘IO有个特点，就是读取写入都很慢，但是可以一次读取大量的数据。根据这个特点，B+树采用多叉树的结构进行设计，这样做相比二叉树来说可以减少树的高度，这样带来的好处是每一层数据都可以是在物理空间相邻的，从而可以通过最少的IO次数加载更多的数据到内存；而这些数据往往是业务相关的，所以一次IO读取的数据可以供后续很多计算工作使用而不用重复IO。比如，一个表有20列，那么每一行数据就有20个字段，这些字段往往在磁盘中是连续存放的，当我们通过id查询其中某个字段a的值时，Mysql其实会将整个记录都取出来，加载到内存，而程序访问完a字段，再访问记录中其他字段时就不需要磁盘IO了，直接读取内存中记录的缓存就行，这就是“空间局部性”的使用实例，也就是我们常说的“预加载”，系统预热。&lt;/p&gt;
&lt;h4&gt;算法分析与设计&lt;/h4&gt;
&lt;p&gt;这是计算机科学的范畴，也是最引人注目的领域，就好比武侠小说里面的武功，华丽的招式比不过强大的内功，练招式容易练内功难，一旦内功深厚，招式什么的都是分分钟被秒杀，就好比《一拳超人》中的琦玉老师，专治各种花里胡哨。而我想说的是，算法设计技术就是软件工程领域的内功心法。当然我远远没有达到可以对这个领域品头论足的程度，就想抛砖引玉，介绍点皮毛，希望对有天赋的同学有所启发。&lt;/p&gt;
&lt;h4&gt;数据结构&lt;/h4&gt;
&lt;p&gt;数据结构之所以重要是因为不同的数据结构表现出来的数学性质是构成特定算法的基础。就好比各种化学元素可以搭建各种性质不同的化合物，而不同性质的化合物正式化学工程所依赖的基础。计算机科学的数据结构可以大致分为两种，一种是数组，另一种是链表。两种性质截然相反的“物质”。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数组——线性性能最好，支持随机访问，按照索引取数组中的元素时间复杂度是O(1)，而插入与删除元素时间复杂度是O(n)；&lt;/li&gt;
&lt;li&gt;链表——扩展性能最好，支持动态的增减元素，插入、删除元素的时间复杂度是O(1)，而检索元素的时间复杂度变成了O(n)；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（注：O标记是数学语言，用于标记一个函数的增长快慢，是一个渐进界函数，具体细节可以参考屈婉玲教授的详细解释）&lt;/p&gt;
&lt;p&gt;这个世界有时候是惊人对称的，对称是美妙的。这样一对性质完全互斥的结构就是构成所有高等数据结构的基础。就像中国传统文化中的太极一样，你中有我我中有你，互相补充，世间万物的运行法则皆可解释。&lt;/p&gt;
&lt;p&gt;举几个例子，有些高等数据结构具有耀眼的数学特性，比如“堆”，或者叫做优先级队列、二叉堆，就是以数组作为基础的。它在插入、删除、查询元素时的性能可以稳定在O(logn)量级；在互联网行业中，只有logn级别的算法可以适用，因为当数据规模急剧增加的时候，对数函数能够很好的平稳压力，所以，&quot;logn&quot;的算法对互联网行业贡献巨大，具有整流器的作用。比如，在微服务流量控制，大数据流处理、topN、高性能定时器都有很多应用。而堆只有在数组实现的算法中才能保持这个特性，如果用链表就会退化为O(nlogn)，失去魔力。&lt;/p&gt;
&lt;p&gt;另一个例子是二叉树，这就是链表的一个使用场景。二叉树是一种树状结构，其中平衡二叉树在插入与删除的过程中只要移动logn次就能找到自己的新位置，而且代码简单易于维护（不容易写错也是工程中一个重要的考虑点，如果写得代码过于复杂就要反思下是否使用错了数据结构）。比如：红黑树就是一个综合性能很好的平衡二叉查找树；它是一个动态的数据结构，可以在动态添加与查找过程中稳定在O(logn)量级；在Linux内核中大量使用；而且在Java中的ConcurrentHashMap在冲突大的情况下，冲突元素大于8也会升级成红黑树存储冲突元素，来平衡工程与算法效率之间的矛盾。&lt;/p&gt;
&lt;p&gt;当然，数据结构是可以融合的，比如Java中的LinkedHashMap就是融合了数组、哈希表与链表的优秀实践。普通的哈希表因为通过哈希函数将元素链接到数组的索引号上面，实现高速的查找性能，但是丢失了元素的插入顺序，而有时候我们需要这个顺序性来实现特殊的需求，比如缓存淘汰策略；而如果使用链表，形成一个插入的队列，先插入的在队列头，后插入在队列尾部；但是这样虽然保存了插入的顺序但是丢失了查找性能；为了平衡，我们可以在哈希表的基础上，每个元素再增加一个指针用来连接前后插入的元素，形成队列，这样没插入一个元素不仅在哈希表上挂载新的索引点，还要将新元素挂接到队列的尾部，而每一步都是O（1）的开销，是可以接受的，这就是LinkedHashMap的实现原理。&lt;/p&gt;
&lt;h4&gt;算法设计技术&lt;/h4&gt;
&lt;p&gt;算法设计技术是使用数据结构解决实际问题的技术，就好比化合物特性研究与化学工程的关系，一个是偏重科学特性的研究，一个是解决实际问题。为了能够让科学能够指导生产，能够造福世间，必须将科学落地，那么这个过程中最重要的一步就是对实际问题的建模，建模是对问题的模拟，越准确越能够解决好问题。那么，在算法设计层面有哪些建模方式呢？大体可以分为四个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;蛮力算法&lt;/li&gt;
&lt;li&gt;贪心算法&lt;/li&gt;
&lt;li&gt;分治算法&lt;/li&gt;
&lt;li&gt;动态规划&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中，蛮力算法是对问题建模的初期阶段，是对问题的程序再现，追求的是定性，性能不一定重要，但是问题描述没问题；分治与贪心是在蛮力基础上的一次降阶，往往可以将问题优化到O(nlogn)的规模以内；而动态规划可以进一步将问题的阶降到O(n)级别。降阶是设计算法的初衷，前提是问题本身计算的各个阶段是有冗余的，有重复计算的地方，而找到这个重复的点并不容易，就拿动态规划来说吧，虽然有极致的性能但是发现递推方程并不容易，当然这一切都要经过严格的数学证明才行，这就更加难能可贵。我们这里没有考虑空间的优化，往往降阶的过程中最好保证空间的复杂度不会激增，这样才会有效。这方面我们不展开了，有很多资料可以参考，其中我推荐&lt;em&gt;&lt;a href=&quot;https://www.bilibili.com/video/av83623454?p=1&quot;&gt;屈婉玲教授的算法设计分析&lt;/a&gt;&lt;/em&gt; 。&lt;/p&gt;
&lt;h3&gt;写在最后&lt;/h3&gt;
&lt;p&gt;细心的你可能会发现，为什么没有讲多线程？多线程也是常用的优化手段啊。对，工程上多线程往往可以优化程序的运行效率，但是这里有个基础就是硬件的资源并没有被充分利用，也就是说，如果因为IO导致CPU利用率不足，当然我们就要想办法去构建可以充分利用硬件资源的方法，而&lt;strong&gt;多线程、多路复用&lt;/strong&gt;这些技术都是为了提高硬件的利用“&lt;strong&gt;带宽&lt;/strong&gt;”的技术，所以并不在我们讨论范围之内。这篇文章还有更加详细的另一篇姐妹篇，&lt;a href=&quot;https://www.jianshu.com/p/b2cb46d105ed&quot;&gt;&lt;em&gt;在这里&lt;/em&gt;&lt;/a&gt;，希望对你有所帮助。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;更多精彩洞见，请关注微信公众号：ThoughtWorks洞见&lt;/strong&gt;&lt;/p&gt;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3c1e9ee860acb4ade3f8b95d6ad7a36b</guid>
<title>从零打造一款轻量且天然支持 SSR 的 CMS 系统：simpleCMS</title>
<link>https://toutiao.io/k/xino5n2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5264900662251656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114icA94wNZOuBGZlxDaQApld1Kxia2SEzMyic4lG5SXQrNQ21hHtqjwyR81PZ5UVicDQnVFVBB6v1micaiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2416&quot;/&gt;&lt;/section&gt;&lt;p&gt;2年前笔者开发了一款基于 &lt;strong&gt;nodejs&lt;/strong&gt; 的全栈开源 &lt;strong&gt;cms&lt;/strong&gt; 系统 XPCMS, 主要是为了解决技术开发者搭建自身内容平台的局限以及降低使用成本, 虽然1.0版本已经完成, 但是从整体部署和二次开发的便捷度上还是存在很多缺点, 更加适合有一定技术能力的开发者来使用.&lt;/p&gt;&lt;p&gt;为了解决 XPCMS 的不足, 去年笔者和朋友特地开发了一款轻量便捷的内容管理系统——&lt;strong&gt;simpleCMS&lt;/strong&gt;, 目前已在 &lt;strong&gt;github&lt;/strong&gt; 上开源, 且能同时适配PC端和移动端.&lt;/p&gt;&lt;p&gt;目前市面上已经有很多成熟的 &lt;strong&gt;cms&lt;/strong&gt; 系统, 比如 &lt;strong&gt;worldPress&lt;/strong&gt;, 博客系统 &lt;strong&gt;hexo&lt;/strong&gt;, 对于技术开发者来说使用和部署很简单, 但是定制和自定义扩展方面, 却需要一定的技术门槛和开发成本.&lt;/p&gt;&lt;p&gt;基于以上一些痛点和局限, 我们开发了一款简单易用, 且天然支持服务端渲染(SSR)的全栈 &lt;strong&gt;cms&lt;/strong&gt; 系统, 方便大家轻松定制自己的博客网站. 笔者接下来就来带大家一起分析 &lt;strong&gt;simpleCMS&lt;/strong&gt; 的功能和技术实现.&lt;/p&gt;&lt;h2&gt;技术架构和实现方案&lt;/h2&gt;&lt;p&gt;为了降低大家的使用和部署成本, 我们采用了如下技术实现:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;服务层: &lt;strong&gt;koa2 + nodejs + jsonSchema&lt;/strong&gt;(当然其中还使用了很多&lt;code&gt;nodejs&lt;/code&gt;中间件)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;前台页面: &lt;strong&gt;pug&lt;/strong&gt;(结合&lt;code&gt;nodejs&lt;/code&gt;实现前后端同构, 且天然的&lt;code&gt;ssr&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;后台管理: &lt;strong&gt;umi3.0 + react + antd + axios + typescript&lt;/strong&gt;(当然还用了很多前端插件, 比如富文本, &lt;code&gt;md&lt;/code&gt;编辑器)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;系统/服务器相关: &lt;strong&gt;linux / pm2 / nginx&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;基本架构模式如下图所示:&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5945945945945946&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114icA94wNZOuBGZlxDaQApld1Y8pDpJ0Vm2D1jbAgGJX2l4Yc1ZcwbFMESxibDKWkYJsR0MvFEFpsR3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;666&quot;/&gt;&lt;/p&gt;&lt;p&gt;系统页面架构图:&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9340175953079178&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114icA94wNZOuBGZlxDaQApld1Z7jEzymYp0ibiaucjib8w49BhU15KORX84H24Mxr1MZVqHYvW2Lw06eRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1364&quot;/&gt;&lt;/p&gt;&lt;h2&gt;功能分析&lt;/h2&gt;&lt;p&gt;接下来笔者就来介绍 &lt;strong&gt;simpleCMS&lt;/strong&gt; 的功能点. 我们先来分析一下后台管理系统.&lt;/p&gt;&lt;h3&gt;后台管理系统功能分析&lt;/h3&gt;&lt;p&gt;后台管理系统是动态博客系统必备的模块, 它能很方便的管理我们的网站数据. 这里笔者先来带大家看一下后台管理系统的基本模块:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;登录页面&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据大盘&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;内容管理&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;页面配置&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;广告配置&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户信息管理&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;多语言支持&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以上是 &lt;code&gt;cms&lt;/code&gt; 管理系统必备的模块, 这里我们基本上采用&lt;code&gt;react hooks&lt;/code&gt; 来写, 具体页面如下:&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;登录页面&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4767772511848341&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114icA94wNZOuBGZlxDaQApld1XnMA92JDLhErvjgXlJjyNshITVkfStHHEEtodhx6uujrpOGQPExIew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2110&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据大盘&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4729064039408867&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114icA94wNZOuBGZlxDaQApld1BtR8fAx3VNkA4zlL6iaBWyX0xIkLWLB8kRlS7ibGjsX41elhn4vnvWKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2842&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;文章管理&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.38628411476557034&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114icA94wNZOuBGZlxDaQApld15qeJZSRLsevaZMMiaPKMTrIZkbzD4ZKMFMRAFoBY1G89XhqXYybAvgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2858&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;内容编辑&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5283605283605284&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114icA94wNZOuBGZlxDaQApld1b1XKyhZIlGZq7hV79VDyFqTyeic7TFraibgs2mXDfgIkcoMmL1ZfW6pg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2574&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;多语言支持&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4542916957431961&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114icA94wNZOuBGZlxDaQApld1GQENyrTvfM7xmpQQODoycyCibuYFb2AeicN98oSFdbEI6n2ZmSoeJibcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2866&quot;/&gt;&lt;/p&gt;&lt;p&gt;其他页面就不一一展示了, 感兴趣的朋友可以体验一下. 主要技术采用 &lt;strong&gt;umi + antd + react + typescript&lt;/strong&gt; 实现, 感兴趣可以在 github 上参考学习.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;前台基本功能分析&lt;/h3&gt;&lt;p&gt;前台主要是我们的博客网站, 这里采用 &lt;code&gt;pug&lt;/code&gt; 这个模版引擎来实现, 交互功能使用大家最熟悉的&lt;code&gt;jquery&lt;/code&gt;.前台基本模块有:&lt;/p&gt;&lt;p&gt;对应的交互功能有&lt;strong&gt;点赞&lt;/strong&gt;, &lt;strong&gt;评论&lt;/strong&gt;, &lt;strong&gt;文章搜索&lt;/strong&gt;功能等, 基本页面如下:&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;首页&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.53628023352794&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114icA94wNZOuBGZlxDaQApld1JD0V3UETib5dKIJDpVsbRYibq8TX2ByTtGpxS490flYYboRldaTXg0TQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2398&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;列表页&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4956647398843931&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114icA94wNZOuBGZlxDaQApld1VibAc5MsVDgSImFBmfEf9vrL05Fiaiae4x6d5jIUicbJic3PeF18AjtT7jA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2768&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;详情页&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5138369483919222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114icA94wNZOuBGZlxDaQApld1iatZkMk29AVibib9VBFZ1DWXJdpoicR2cemFeL9Zibk5Hx902wnP1lLRYdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2674&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;评论和点赞&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5259541984732824&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114icA94wNZOuBGZlxDaQApld1w8o2JuoiblD3tYKGOMwNgnticR85oJTibAVRBdhheej06qC3qcbMSibwYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2620&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;由于&lt;code&gt;pug&lt;/code&gt;模版引擎适合做一些展示型的网站, 所以非常适合用在&lt;code&gt;cms&lt;/code&gt;系统中, 我们也可以使用&lt;code&gt;ejs&lt;/code&gt;等模版引擎.&lt;/p&gt;&lt;h2&gt;技术实现细节&lt;/h2&gt;&lt;p&gt;由于整个&lt;code&gt;cms&lt;/code&gt; 系统是一个完整的技术闭环, 数据流转都是相关的, 这里笔者主要总结一下实现一个&lt;code&gt;cms&lt;/code&gt;的技术细节.&lt;/p&gt;&lt;h3&gt;数据统计功能实现&lt;/h3&gt;&lt;p&gt;数据统计主要是统计网站的pv, 单篇文章阅读量和点赞量, 为了更好的进行分析我们需要对单日的数据进行统计和存库, 具体实现就是利用定时任务在一天结束前进行数据的统计, 这里我们用 &lt;code&gt;node-schedule&lt;/code&gt;来实现, 具体使用方式笔者也在之前的文章中做了介绍, 感兴趣可以参考一下.&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.30505415162454874&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114icA94wNZOuBGZlxDaQApld1LGaClN8QiajMsW7JYZbHvBM03DQ5NURxgKBRhTLE2zr94l6gmPWPF8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1108&quot;/&gt;&lt;/p&gt;&lt;p&gt;基本使用如下:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; schedule = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;node-schedule&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; testJob = schedule.scheduleJob(&lt;span&gt;&#x27;42 * * * *&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span/&gt;)&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;将在未来的每个时刻的42分时执行此代码, 比如22:42, 23:42&#x27;&lt;/span&gt;);&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;富文本和md编辑器方案实现&lt;/h3&gt;&lt;p&gt;这里我们用的富文本组件是&lt;code&gt;braft&lt;/code&gt;, 功能和可扩展性基本满足业务需求, &lt;code&gt;md&lt;/code&gt;编辑器是程序员写博客的基本方式, 这里主要采用了&lt;code&gt;for-editor&lt;/code&gt;, 其次就是对其进行了二次封装来实现支持剪切板功能.&lt;/p&gt;&lt;h3&gt;国际化方案&lt;/h3&gt;&lt;p&gt;多语言主要使用的&lt;code&gt;react-intl&lt;/code&gt;, 由于&lt;code&gt;umi&lt;/code&gt; 对其有很好的集成, 所以说我们只需要搭建基本的多语言规则即可. 比如在项目目录里建立&lt;code&gt;locales&lt;/code&gt;文件夹, 然后存放&lt;code&gt;zh&lt;/code&gt;(中文)/&lt;code&gt;en&lt;/code&gt;(英文)文件即可, 基本的代码如下:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// locales/en/user&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;simpleCMS_DESC&lt;/span&gt;: &lt;span&gt;&#x27;Easy to use CMS system, help everyone to have their own website blog.&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;CopyrightText&lt;/span&gt;: &lt;span&gt;&#x27;SimpleCMS r&amp;amp;d team&#x27;&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// locales/zh/user&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;simpleCMS_DESC&lt;/span&gt;: &lt;span&gt;&#x27;简单易用的cms系统, 助力每个人都能拥有自己的网站博客。&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;CopyrightText&lt;/span&gt;: &lt;span&gt;&#x27;SimpleCMS 研发团队&#x27;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;如果对多语言实现方案感兴趣的, 可以参考&lt;code&gt;simpleCMS&lt;/code&gt;源码.&lt;/section&gt;&lt;section&gt;后期笔者会继续写对应的文章来介绍具体的实现方案, 感兴趣可以持续关注和交流.&lt;/section&gt;&lt;section&gt;github🔍: MrXujiang/simpleCMS&lt;/section&gt;&lt;section&gt;cms技术交流:&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.2659176029962547&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114icA94wNZOuBGZlxDaQApld12ZZnicD1icXO50ib1yQLHDE25ReRtfL8EOibGBASic3FRkhz4uFhibO93VMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;534&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-category=&quot;模板&quot; data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.5789473684210527&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WeHSriasp3viaaXbIRuEoZVIicy8TKbjvsMPuS5vIAAZEhOiaPPRNv2iazhibjUnqFuhEhJialhUzte2gG9R7v9CU3ibnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;152&quot;/&gt;&lt;img data-ratio=&quot;1.453125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/r2RNYibI5L5n69XPwgmAZUo9PpCZnbR6icVUaNj4fxLOE0oVn7H8c9k6tmLjtg9QQRwXxOqITd29Uj14Roic5Y2UA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;64&quot;/&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;阅&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;读原文，即可体验simpleCMS&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>