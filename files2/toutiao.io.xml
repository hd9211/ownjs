<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>28fc89c56a2f09e1e5c6fb76d4be875c</guid>
<title>推荐几个开源类库，超好用，远离 996</title>
<link>https://toutiao.io/k/oi7zdzy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天给大家分享几个 Java 的开源类库，亲测非常好用！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了它们之后，你就可以和很多重复劳动说再见了。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;1. MapStruct&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2806349206349206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KSnhEmJ0hk51vGmlPGAia7cBuEstA8ecmrWian3mjF0VvoAiaibNWTC5K3QMZ6yK4QwDYYo401lOymRrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3150&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;MapStruct是干什么的？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MapStruct是个代码产生器，它能直接根据注解生成 Java 对象对应的转换器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，直接把一个 A 类型的 Java 对象，给转成 B 类型的 Java 对象，只需要在他们之间配置上字段之间的映射关系即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么在项目里用它？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在随便一个项目都是多层的，尤其是 Web 项目，经常需要在多层之间做对象模型转换，比如 DTO 转换成 BO。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;DTO（Data Transfer Object）：数据传输对象，Service 向外传输的对象。&lt;br/&gt;BO（Business Object）：业务对象，由 Service 层输出的封装业务逻辑的对象。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这种转换工作就像是小时候，老师罚我们抄写名人名言 100 遍一样，十分枯燥，还容易出错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CarMapper&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;CarDto &lt;span&gt;carDoToCarDto&lt;/span&gt;&lt;span&gt;(Car car)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        CarDto carDto = &lt;span&gt;new&lt;/span&gt; CarDto();&lt;br/&gt;        carDto.setCarId(car.getCarId());&lt;br/&gt;        carDto.setWheel(car.getWheel());&lt;br/&gt;        carDto.setCarType(car.getCarType());&lt;br/&gt;        carDto.setCarColor(car.getCarColor());&lt;br/&gt;        ......&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要是 Car 有几十个字段，像 Car 一样的又有几十个类，你可以想一下，这种繁琐程度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 MapStruct 之前，我们都是通过 Apache 或者 Spring 的 BeanUtils 工具，去自动做这种事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这类工具有两个问题：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.性能比较差&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;性能差主要是 Apache 的 BeanUtils 这套东西，它每次都要针对字段，做是否可读写的检查，还要根据字段生成对应的 PropertyDescriptor。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些严重影响了它的性能，所以，在阿里 Java 手册里，也不推荐用它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 的 BeanUtils，虽然精简了很多 Apache 的 BeanUtils 的读写检查以及对应的属性信息记录，但是它依然是通过反射调用，而且是大量反射调用。这种性能也不能令人满意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.运行期做转换，出错就代表损失&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BeanUtils 这类工具，有个统一的名称，叫做 Java 对象映射框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们大部分的实现都是在运行期去执行代码，然后在 Java 对象之间去拷贝对应的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行期间做这种事儿，有个最大的问题——整个项目启动运行后，才能发现错误。比如，转换的时候，类型不一致导致报错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于此种情况，咱们大家都知道，这事儿就像开业酬宾没搞好，变成了开业仇宾……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果能写完代码，编译的时候就发现问题，这种损失就可以避免了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MapStruct 的引入就是为了解决以上这两个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MapStruct 首先是个代码产生器，它是根据注解，去产生一个专门用来转换的工具类，这个工具类，就像我们自己写的 Java 类一样，可以直接被使用，这样就避免了反射。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，它产生的转换类也特别简单，就是默认会在两个类型的 Java 对象之间，拷贝同名属性的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有了配置，属性不同名也可以拷贝。所以它的性能很好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Mapper&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;CarMapper&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    CarMapper INSTANCE = Mappers.getMapper( CarMapper&lt;span&gt;.&lt;span&gt;class&lt;/span&gt; )&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Mapping&lt;/span&gt;(target = &lt;span&gt;&quot;seatCount&quot;&lt;/span&gt;, source = &lt;span&gt;&quot;numberOfSeats&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;CarDto &lt;span&gt;carBoToCarDto&lt;/span&gt;&lt;span&gt;(Car car)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MapStruct由于是个代码产生器，就带来了个巨大的好处，就是这家伙是在编译阶段就会生成对应的类，所以，如果有了类似类型转换不过去的问题，直接就编译报错了，根本等不到运行才发现。这样的话，就不会造成什么损失，这真是件十分 Nice 的事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码库地址&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/mapstruct/mapstruct&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;2. Retrofit&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2265193370165746&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KSnhEmJ0hk51vGmlPGAia7cBuMJpksx3ddxxaG2lyQlMjUZesVMWOJ64E1NkRLHOrziaCj9N1af8Qow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1086&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Retrofit 是干什么的？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Retrofit 就是一套 Http 客户端，可以用来访问第三方的 Http 服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，咱们代码里想调用一个 Http 协议的 URL，就可以用它来访问这个 URL，获取响应结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么在项目里用它？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在公司里，我们有些项目有如下的特点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不是基于 Spring 的项目&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要经常访问大量的第三方 Http 服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;访问 Http 服务的模型通常是异步回调&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以前的时候，我们访问 Http 服务，都是直接用的 HttpClient。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可是吧，HttpClient 用起来实在够麻烦的。主要也存在两个问题：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.请求参数和 URL 拼接实在繁琐&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求参数和 URL 拼接实在是太烦人了。你想想，每调用一个接口，就需要自己去拼接参数，有的 URL，甚至十几二十个参数需要拼接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拼接这事儿简单、枯燥、重复，还没有技术含量，但是工作量却不小，时间真的算浪费了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;URIBuilder uriBuilder = &lt;span&gt;new&lt;/span&gt; URIBuilder(uriBase);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;valuea&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;valueb&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;&quot;valuec&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;d&quot;&lt;/span&gt;, &lt;span&gt;&quot;valued&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;e&quot;&lt;/span&gt;, &lt;span&gt;&quot;valuee&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;f&quot;&lt;/span&gt;, &lt;span&gt;&quot;valuef&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;g&quot;&lt;/span&gt;, &lt;span&gt;&quot;valueg&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;h&quot;&lt;/span&gt;, &lt;span&gt;&quot;valueh&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;i&quot;&lt;/span&gt;, &lt;span&gt;&quot;valuei&quot;&lt;/span&gt;);&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.异步回调需要自己搞&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步回调这种模型不好处理，主要就是需要自己去搞线程池，还要对线程池管理，还要考虑出错的重试之类的容错问题，实在麻烦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们就需要一套能用法简单，不用我们一直搞拼接参数，自己搞线程管理就能完成对第三方 Http 服务访问的库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实我们也想过用 Feign 这套框架的。但是，这套东西和 Spring 绑定的太紧了。如果离开 Spring，它的一些功能就没法简单的通过注解直接使用，必须自己写代码调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且，Feign 要实现异步回调方式使用，尤其在协程方面，还是需要自己开发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，Retrofit 就跳进了我们的选型里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Retrofit 的模型里，异步回调模型它支持的很好，我们只需要实现一个 Callable 就够了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且最清爽的是，它和 Spring 没什么关系。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Retrofit retrofit = &lt;span&gt;new&lt;/span&gt; Retrofit.Builder()&lt;br/&gt;        .baseUrl(&lt;span&gt;&quot;http://xxx.example.com/&quot;&lt;/span&gt;)&lt;br/&gt;        .build();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;BlogService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@GET&lt;/span&gt;(&lt;span&gt;&quot;blog/{id}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;Call&amp;lt;ResponseBody&amp;gt; &lt;span&gt;getBlog&lt;/span&gt;&lt;span&gt;(@Path(&lt;span&gt;&quot;id&quot;&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id)&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;BlogService service = retrofit.create(BlogService&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;Call&amp;lt;ResponseBody&amp;gt; call = service.getBlog(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 用法和OkHttp的call如出一辙,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 回调&lt;/span&gt;&lt;br/&gt;call.enqueue(&lt;span&gt;new&lt;/span&gt; Callback&amp;lt;ResponseBody&amp;gt;() {&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onResponse&lt;/span&gt;&lt;span&gt;(Call&amp;lt;ResponseBody&amp;gt; call, Response&amp;lt;ResponseBody&amp;gt; response)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            System.out.println(response.body().string());&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onFailure&lt;/span&gt;&lt;span&gt;(Call&amp;lt;ResponseBody&amp;gt; call, Throwable t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        t.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你看，只需要写上这些代码，我们就不需要操心恼人的 Url 拼接和异步回调的管理问题了。全交给了 Retrofit，着实推荐。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码库地址&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/square/retrofit&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;3. Faker&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.18406593406593408&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KSnhEmJ0hk51vGmlPGAia7cBhx1f8kKSm5BYewyLsib7J37r8wwGLIlVL9PThILUwLgUYaJKGia37NVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;728&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Faker 是干什么的？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Faker 是专门用来产生各种假数据的辅助工具库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，你想产生个和真实数据一样的有姓名、有地址的用户。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么在项目里用它？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们经常需要造数据去测试，但是，如果没有工具辅助，我们自己造数据，存在一些问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.数据是需要格式的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多关于项目，都需要一些格式上尽量能模仿真实世界的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，国内用户的姓名，大部分都是两字、三字的姓名，叫王大，就不能叫 王da 这种。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又比如，国内的地址是 xx市xx区xx街道xx号 这种的，就不能胡写一个几个没意义的汉字来当地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用贴近真实格式的数据，一来可以测出我们对用户的数据解析是否存在问题，二来可以测出数据库内的字段长度是否没问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，格式对产生出可靠地测试结果，是很重要的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.数据的量大&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的测试数据量都是上十万、百万的，这些量级的数据并不是只会产生一次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;甚至几乎每个项目，每个项目的每次测试，可能都会需要新的数据，需要能源源不断地产生出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更甚至的是，有时候还想要根据我们的要求，在恰当的时候，产生某种关系的数据，或者以某些特定频率产生。比如，两秒后产生一次数据；比如，产生一批姓王的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上这三种要求综合起来，要是我们自己造数据，那真是要了命了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与其自己开发，不如用现成的——Faker 库被我们找到了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Faker库可以创造三百多种数据，而且还很容易对它进行扩展改造，去产生更多的贴合我们需求的数据。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Faker faker = &lt;span&gt;new&lt;/span&gt; Faker();&lt;br/&gt;&lt;br/&gt;String name = faker.name().fullName(); &lt;span&gt;// Miss Samanta Schmidt&lt;/span&gt;&lt;br/&gt;String firstName = faker.name().firstName(); &lt;span&gt;// Emory&lt;/span&gt;&lt;br/&gt;String lastName = faker.name().lastName(); &lt;span&gt;// Barton&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;String streetAddress = faker.address().streetAddress(); &lt;span&gt;// 60018 Sawayn Brooks Suite 449&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;几行代码，我们需要的一个用户就有了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用上 Faker 后，小伙伴们纷纷表示“有更多的时间摸鱼了”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码库地址&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/DiUS/java-faker&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;4. Wiremock&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5228758169934641&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KSnhEmJ0hk51vGmlPGAia7cBxTkowASXfAumC5G20fMry7hyiciaI6F3jaRfkO7AicibBtwopQibIz4HlVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;306&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Wiremock 是干什么的？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Wiremock 是一个可以模拟服务的测试框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，你想测试访问阿里的支付相关接口的代码逻辑，就可以用它来做测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么在项目里用它？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，我们需要调用银行接口去做资金业务，调用微信接口去做微信登录……这些调用第三方服务的测试存在一个问题：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即太过依赖对方的平台。假如对方平台限制了一些 IP，或者限制了访问频率，又或者就是服务出现了维护，都会影响我们自身的功能测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决上述问题，在之前，我们需要自己写代码模仿第三方的接口，等我们自己全部测试没问题了，再去和第三方联调。对于这种模拟出来的接口，我们称作挡板。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可是，这种方式是个苦活，没人愿意干。因为每接入一个第三方，可能都需要做挡板。辛苦做个挡板，就是单纯为了测试。如果第三方的接口做了改造，你这边还得跟着改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家可以想想，换成你自己，你愿意做这么件事儿吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，Wiremock 的价值就体现出来了。有了 Wiremock，挡板这种东西就再也不存在了，直接在单元测试里模拟测试即可，像这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;WireMock.stubFor(get(urlPathMatching(&lt;span&gt;&quot;/aliyun/.*&quot;&lt;/span&gt;))&lt;br/&gt;                .willReturn(aResponse()&lt;br/&gt;                        .withStatus(&lt;span&gt;200&lt;/span&gt;)&lt;br/&gt;                        .withHeader(&lt;span&gt;&quot;Content-Type&quot;&lt;/span&gt;, APPLICATION_JSON)&lt;br/&gt;                        .withBody(&lt;span&gt;&quot;\&quot;testing-library\&quot;: \&quot;WireMock\&quot;&quot;&lt;/span&gt;)));&lt;br/&gt;&lt;br/&gt;CloseableHttpClient httpClient = HttpClients.createDefault();&lt;br/&gt;HttpGet request = &lt;span&gt;new&lt;/span&gt; HttpGet(String.format(&lt;span&gt;&quot;http://localhost:%s/aliyun/wiremock&quot;&lt;/span&gt;, port));&lt;br/&gt;HttpResponse httpResponse = httpClient.execute(request);&lt;br/&gt;String stringResponse = convertHttpResponseToString(httpResponse);&lt;br/&gt;&lt;br/&gt;verify(getRequestedFor(urlEqualTo(ALIYUN_WIREMOCK_PATH)));&lt;br/&gt;assertEquals(&lt;span&gt;200&lt;/span&gt;, httpResponse.getStatusLine().getStatusCode());&lt;br/&gt;assertEquals(APPLICATION_JSON, httpResponse.getFirstHeader(&lt;span&gt;&quot;Content-Type&quot;&lt;/span&gt;).getValue());&lt;br/&gt;assertEquals(&lt;span&gt;&quot;\&quot;testing-library\&quot;: \&quot;WireMock\&quot;&quot;&lt;/span&gt;, stringResponse);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码库地址&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/wiremock/wiremock&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;结语&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 Java 有很多遭人诟病的地方，但是 Java 最重要的优点之一，就是它的生态，有其琳琅满目的各种工具类库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希望大家都“懒”一点，不要埋头去做无效的苦干，不要自己造轮子，你要相信：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;你遇到的问题，基本已经有很多人遇到过了，而且已经被牛人给解决了，把轮子都给你造好了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完有收获，可以随手点个&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你好，我是四猿外。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一家上市公司的技术总监，管理的技术团队一百余人。想了解我如何管理团队——&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247485282&amp;amp;idx=1&amp;amp;sn=f368ffae1845809ccf06859f988a88a8&amp;amp;chksm=fcd8cb23cbaf4235db644759c3d8099045d10fc952b950d429e4a5e07ed9a806fddf85c451d3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;我，管理100多人团队的二三事&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我从一名非计算机专业的毕业生，转行到程序员，一路打拼，一路成长。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我会通过公众号，&lt;br/&gt;把自己的成长故事写成文章，&lt;br/&gt;把枯燥的技术文章写成故事。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我建了一个读者交流群，里面大部分是程序员，一起聊技术、工作、八卦。欢迎加我微信，拉你入群。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9852216748768473&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6nbNnibOq5KQibCDibpTo0kqofPehQvDDibibcb3bQUELdY3Knsl4r0RcgsV9l4icr3icmZQfaBXtSFNTxmdQlAZT1OQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;609&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9bfd7b5d30a6f953b408a594addd1c8d</guid>
<title>K8s 云原生时代的操作系统</title>
<link>https://toutiao.io/k/o9i0zik</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1&gt;k8s云原生时代的操作系统&lt;/h1&gt;&lt;h2&gt;一、背景&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;kvm主机扩缩容需要运维、开发协同处理效率不高，遇到节假日流量突增处理繁琐&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;kvm主机普遍cpu、内存利用率不高，造成浪费资源&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;监控有open-falcon、zabbix组件太多，需要统一到prometheus平台&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;缺乏中间件、存储的监控和告警&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;二、核心概念&lt;/h2&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.53515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtnMBnnXh0SMH4FVwBI7O8WWApZCGwTH6ZH2QlD43g9VkM8VPgzYia3FVDCDqzCTAasFZ4aiay7ibTQrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;h3&gt;1、Master组件&lt;br/&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1、kube-apiserver&lt;br/&gt;   Kubernetes API，集群的统一入口，各组件协调者，以RESTful API提供接口服务，所有对象资源的增删改查和监听操作都交给APIServer处理后再提交给Etcd存储。&lt;br/&gt;2、kube-controller-manager&lt;br/&gt;   处理集群中常规后台任务，一个资源对应一个控制器，而ControllerManager就是负责管理这些控制器的。&lt;br/&gt;3、kube-scheduler&lt;br/&gt;   根据调度算法为新创建的Pod选择一个Node节点，可以任意部署,可以部署在同一个节点上,也可以部署在不同的节点上。&lt;br/&gt;4、etcd&lt;br/&gt;   分布式键值存储系统。用于保存集群状态数据，比如Pod、Service等对象信息。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;2、Node组件&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1、kubelet&lt;br/&gt;   kubelet是Master在Node节点上的Agent，管理本机运行容器的生命周期，比如创建容器、Pod挂载数据卷、下载secret、获取容器和节点状态等工作。kubelet将每个Pod转换成一组容器。&lt;br/&gt;2、kube-proxy&lt;br/&gt;   在Node节点上实现Pod网络代理，维护网络规则和四层负载均衡工作。&lt;br/&gt;3、docker或rocket&lt;br/&gt;   容器引擎，运行容器。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;3、名词解释&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7527443805541035&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtnMBnnXh0SMH4FVwBI7O8WW0yLzR31IUj04QdiczEyOLaibBN89xlibjfOibUfrPkyrKyiblgicTkDatH2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1913&quot;/&gt;&lt;/p&gt;&lt;p&gt;￼&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;1、Pod&lt;br/&gt;   最小部署单元、一组容器的集合、一个Pod中的容器共享网络命名空间、 Pod是短暂的 &lt;br/&gt;2、Controllers&lt;br/&gt;   Deployment ：无状态应用部署                                          &lt;br/&gt;   DaemonSet ：确保所有Node运行同一Pod                       &lt;br/&gt;   StatefulSet ：有状态应用部署&lt;br/&gt;   Job ：一次性任务&lt;br/&gt;   Cronjob ：定时任务、更高级层次对象，部署和管理Pod&lt;br/&gt;3、Service&lt;br/&gt;   防止Pod失联&lt;br/&gt;   定义一组Pod的访问策略&lt;br/&gt;4、Label&lt;br/&gt;   标签，附加到某个资源上，用于关联对象、查询和筛选&lt;br/&gt;5、Namespaces&lt;br/&gt;   命名空间，将对象逻辑上隔离&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;4、CICD规划图&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.415234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtnMBnnXh0SMH4FVwBI7O8WWticHjJFGOE0lEKlK8d9IZQuibdE8JW12vMbtWbIIiao67FBqibj7cHl9OQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;￼&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;三、踩坑经验分享&lt;/h2&gt;&lt;p&gt;1、磁盘故障导致pod被oom？&lt;/p&gt;&lt;pre&gt;&lt;code&gt;问题：广告、代理层的pod同时触发了pod的重启告警，赶紧登上服务器看看咋回事？&lt;br/&gt;&lt;br/&gt;原因：分析发现pod被oom后并未触发node节点的扩容，而是一直处于pengding的状态，这就比较奇怪了，赶紧联系ucloud得知E区的云盘出现问题，而咱们有部分node节点正好在E区，沟通得知硬盘故障pod处于pengding状态这属于k8s官方的bug并未修复。&lt;br/&gt;&lt;br/&gt;解决办法：创建node节点尽量选多个可用区分散风险。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、滚动更新之流量的丢失？&lt;/p&gt;&lt;pre&gt;&lt;code&gt;问题：研发反馈代理层上线期间所有的pod都从consul-server注销了,从而引发服务抖动?&lt;br/&gt;&lt;br/&gt;原因：因为yaml文件没有设置钩子，滚动更新默认30秒就删除容器导致业务逻辑处理不过来，而且yaml副本数默认设置为1，导致滚动更新期间只保留1个pod可用。&lt;br/&gt;&lt;br/&gt;解决方案：修改yaml的副本数和hpa最小值一致，增加容器删除等待时间为60秒&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;钩子配置&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5627240143369175&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtnMBnnXh0SMH4FVwBI7O8WWpNP9iashhTK0L44JHicLP7PUSMkGIE8BPVswY0v2tKpKc58gNG3P9zXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;279&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;副本数配置&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6307901907356949&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtnMBnnXh0SMH4FVwBI7O8WWKChNTeyAWGrdkYicqW6qaLk6ZicRSY7L8HibvvbmezRYrBYT2cJHaGxXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;734&quot;/&gt;&lt;/p&gt;&lt;p&gt;￼&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;3、pod内的consul-client容器内存溢出，导致注册失败？&lt;/p&gt;&lt;pre&gt;&lt;code&gt;问题：收到告警，详情、流服务、代理层的qps都低于阈值，赶紧登录k8s看看出什么问题了？&lt;br/&gt;&lt;br/&gt;原因：排查发现consul-client容器内存溢出超过了200M，导致consul-client容器重启consul-id变更，导致服务用之前的consul-id无法注册到consul-server。&lt;br/&gt;&lt;br/&gt;解决方案：代理层、流服务、广告、日志上报的consul-clinet最大内存调整为500M，增加容器内存使用大于90%告警。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;内存限制&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7246376811594203&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtnMBnnXh0SMH4FVwBI7O8WWMTkywdEibGhnBkibkXLFrQ8v1XpG9gRBrbYhKy7ZT8yr2cfQkCbiaLZJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;276&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;内存告警&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2450037009622502&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtnMBnnXh0SMH4FVwBI7O8WWTScvbcvE5z006ibOSDR7lOtYhYRokoMibnMPSR0XUsG40zN2atrhcuCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1351&quot;/&gt;&lt;/p&gt;&lt;p&gt;￼&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bae3f51fb6140426e8a7d106047e3671</guid>
<title>Java 实现 5 种负载均衡算法</title>
<link>https://toutiao.io/k/pvq2wz7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2&gt;概念&lt;/h2&gt;&lt;p&gt;负载均衡是将客户端请求访问，通过提前约定好的规则转发给各个server。其中有好几个种经典的算法，下面我们用Java实现这几种算法。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8311111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ExViakhaSiafEYLyaGAObOnrl34Aap2moCODRd8Er9J8Nu0gLzKPa6ibT50KfZHZUvvEfWwMwPRG79un7m6VHK1Tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1350&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;轮询算法&lt;/h2&gt;&lt;p&gt;轮询算法按顺序把每个新的连接请求分配给下一个服务器，最终把所有请求平分给所有的服务器。&lt;/p&gt;&lt;p&gt;优点：绝对公平&lt;/p&gt;&lt;p&gt;缺点：无法根据服务器性能去分配，无法合理利用服务器资源。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.monkeyjava&lt;/span&gt;&lt;span&gt;.learn&lt;/span&gt;&lt;span&gt;.basic&lt;/span&gt;&lt;span&gt;.robin&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.google&lt;/span&gt;&lt;span&gt;.common&lt;/span&gt;&lt;span&gt;.collect&lt;/span&gt;&lt;span&gt;.Lists&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.HashMap&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.List&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.Map&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestRound&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer  index = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;List&lt;/span&gt;&amp;lt;String&amp;gt; ips = Lists.newArrayList(&lt;span&gt;&quot;192.168.1.1&quot;&lt;/span&gt;, &lt;span&gt;&quot;192.168.1.2&quot;&lt;/span&gt;, &lt;span&gt;&quot;192.168.1.3&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;roundRobin&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;String&lt;/span&gt; serverIp;&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt;(index){&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;index&lt;/span&gt; &amp;gt;= ips.size()){&lt;br/&gt;                &lt;span&gt;index&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            serverIp= ips.&lt;span&gt;get&lt;/span&gt;(index);&lt;br/&gt;            &lt;span&gt;//轮询+1&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;index&lt;/span&gt; ++;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; serverIp;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        TestRound &lt;span&gt;test&lt;/span&gt;RoundRobin =new TestRound();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt; &lt;span&gt;10&lt;/span&gt; ;i++){&lt;br/&gt;            String serverIp= &lt;span&gt;test&lt;/span&gt;RoundRobin.roundRobin();&lt;br/&gt;            &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out&lt;/span&gt;&lt;span&gt;.println&lt;/span&gt;(&lt;span&gt;serverIp&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;输出结果:&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2&gt;加权轮询法&lt;/h2&gt;&lt;p&gt;该算法中，每个机器接受的连接数量是按权重比例分配的。这是对普通轮询算法的改进，比如你可以设定：第三台机器的处理能力是第一台机器的两倍，那么负载均衡器会把两倍的连接数量分配给第3台机器，轮询可以将请求顺序按照权重分配到后端。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.monkeyjava&lt;/span&gt;&lt;span&gt;.learn&lt;/span&gt;&lt;span&gt;.basic&lt;/span&gt;&lt;span&gt;.robin&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.ArrayList&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.HashMap&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.List&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.Map&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestWeight&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer index = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    static &lt;span&gt;Map&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, Integer&amp;gt; ipMap=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&lt;span&gt;String&lt;/span&gt;, Integer&amp;gt;(&lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 1.map, key-ip,value-权重&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;ipMap&lt;/span&gt;&lt;span&gt;.put&lt;/span&gt;(&quot;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&quot;, 1);&lt;br/&gt;        &lt;span&gt;ipMap&lt;/span&gt;&lt;span&gt;.put&lt;/span&gt;(&quot;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&quot;, 2);&lt;br/&gt;        &lt;span&gt;ipMap&lt;/span&gt;&lt;span&gt;.put&lt;/span&gt;(&quot;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&quot;, 4);&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt; &lt;span&gt;getServerIpByWeight&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; ips = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt;(&lt;span&gt;32&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;Map&lt;/span&gt;.Entry&amp;lt;&lt;span&gt;String&lt;/span&gt;, Integer&amp;gt; entry : ipMap.entrySet()) {&lt;br/&gt;            &lt;span&gt;String&lt;/span&gt; ip = entry.getKey();&lt;br/&gt;            &lt;span&gt;Integer&lt;/span&gt; weight = entry.getValue();&lt;br/&gt;            &lt;span&gt;// 根据权重不同，放入list 中的数量等同于权重，轮询出的的次数等同于权重&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; ipCount =&lt;span&gt;0&lt;/span&gt;; ipCount &amp;lt; weight; ipCount++) {&lt;br/&gt;                &lt;span&gt;ips&lt;/span&gt;&lt;span&gt;.add&lt;/span&gt;(&lt;span&gt;ip&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ips;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;weightRobin&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        List&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; ips = &lt;span&gt;this&lt;/span&gt;.getServerIpByWeight();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;index&lt;/span&gt; &amp;gt;= ips.size()){&lt;br/&gt;            &lt;span&gt;index&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        String serverIp= ips.&lt;span&gt;get&lt;/span&gt;(index);&lt;br/&gt;        &lt;span&gt;index&lt;/span&gt; ++;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;  serverIp;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        TestWeight &lt;span&gt;test&lt;/span&gt;WeightRobin=new TestWeight();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt;0&lt;/span&gt;;i&amp;lt; &lt;span&gt;10&lt;/span&gt; ;i++){&lt;br/&gt;            String server=&lt;span&gt;test&lt;/span&gt;WeightRobin.weightRobin();&lt;br/&gt;            &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out&lt;/span&gt;&lt;span&gt;.println&lt;/span&gt;(&lt;span&gt;server&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;输出结果:&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2&gt;加权随机法&lt;/h2&gt;&lt;p&gt;获取带有权重的随机数字，随机这种东西，不能看绝对，只能看相对，我们不用index 控制下标进行轮询，只用random 进行随机取ip，即实现算法。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.monkeyjava&lt;/span&gt;&lt;span&gt;.learn&lt;/span&gt;&lt;span&gt;.basic&lt;/span&gt;&lt;span&gt;.robin&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java.util.*&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestRandomWeight&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;    static &lt;span&gt;Map&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, Integer&amp;gt; ipMap=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&lt;span&gt;String&lt;/span&gt;, Integer&amp;gt;(&lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 1.map, key-ip,value-权重&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;ipMap&lt;/span&gt;&lt;span&gt;.put&lt;/span&gt;(&quot;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&quot;, 1);&lt;br/&gt;        &lt;span&gt;ipMap&lt;/span&gt;&lt;span&gt;.put&lt;/span&gt;(&quot;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&quot;, 2);&lt;br/&gt;        &lt;span&gt;ipMap&lt;/span&gt;&lt;span&gt;.put&lt;/span&gt;(&quot;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&quot;, 4);&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt; &lt;span&gt;getServerIpByWeight&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; ips = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt;(&lt;span&gt;32&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;Map&lt;/span&gt;.Entry&amp;lt;&lt;span&gt;String&lt;/span&gt;, Integer&amp;gt; entry : ipMap.entrySet()) {&lt;br/&gt;            &lt;span&gt;String&lt;/span&gt; ip = entry.getKey();&lt;br/&gt;            &lt;span&gt;Integer&lt;/span&gt; weight = entry.getValue();&lt;br/&gt;            &lt;span&gt;// 根据权重不同，放入list 中的数量等同于权重，轮询出的的次数等同于权重&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; ipCount =&lt;span&gt;0&lt;/span&gt;; ipCount &amp;lt; weight; ipCount++) {&lt;br/&gt;                &lt;span&gt;ips&lt;/span&gt;&lt;span&gt;.add&lt;/span&gt;(&lt;span&gt;ip&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ips;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;randomWeightRobin&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        List&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; ips = &lt;span&gt;this&lt;/span&gt;.getServerIpByWeight();&lt;br/&gt;        &lt;span&gt;//循环随机数&lt;/span&gt;&lt;br/&gt;        Random random=&lt;span&gt;new&lt;/span&gt; Random();&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; =random.nextInt(ips.size());&lt;br/&gt;        String serverIp = ips.&lt;span&gt;get&lt;/span&gt;(index);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;  serverIp;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        TestRandomWeight &lt;span&gt;test&lt;/span&gt;RandomWeightRobin=new TestRandomWeight();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt;0&lt;/span&gt;;i&amp;lt; &lt;span&gt;10&lt;/span&gt; ;i++){&lt;br/&gt;            String server= &lt;span&gt;test&lt;/span&gt;RandomWeightRobin.randomWeightRobin();&lt;br/&gt;            &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out&lt;/span&gt;&lt;span&gt;.println&lt;/span&gt;(&lt;span&gt;server&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;输出结果:&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2&gt;随机法&lt;/h2&gt;&lt;p&gt;负载均衡方法随机的把负载分配到各个可用的服务器上，通过随机数生成算法选取一个服务器，这种实现算法最简单，随之调用次数增大，这种算法可以达到每台服务器的请求量接近于平均。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.monkeyjava&lt;/span&gt;&lt;span&gt;.learn&lt;/span&gt;&lt;span&gt;.basic&lt;/span&gt;&lt;span&gt;.robin&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.google&lt;/span&gt;&lt;span&gt;.common&lt;/span&gt;&lt;span&gt;.collect&lt;/span&gt;&lt;span&gt;.Lists&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.List&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.Random&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestRandom&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;List&lt;/span&gt;&amp;lt;String&amp;gt; ips = Lists.newArrayList(&lt;span&gt;&quot;192.168.1.1&quot;&lt;/span&gt;, &lt;span&gt;&quot;192.168.1.2&quot;&lt;/span&gt;, &lt;span&gt;&quot;192.168.1.3&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;randomRobin&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//随机数&lt;/span&gt;&lt;br/&gt;        Random random=&lt;span&gt;new&lt;/span&gt; Random();&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; =random.nextInt(ips.size());&lt;br/&gt;        String serverIp= ips.&lt;span&gt;get&lt;/span&gt;(index);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;  serverIp;&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        TestRandom &lt;span&gt;test&lt;/span&gt;RandomdRobin =new TestRandom();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt; &lt;span&gt;10&lt;/span&gt; ;i++){&lt;br/&gt;            String serverIp= &lt;span&gt;test&lt;/span&gt;RandomdRobin.randomRobin();&lt;br/&gt;            &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out&lt;/span&gt;&lt;span&gt;.println&lt;/span&gt;(&lt;span&gt;serverIp&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;输出&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2&gt;IP_Hash算法&lt;/h2&gt;&lt;p&gt;hash(ip)%N算法，通过一种散列算法把客户端来源IP根据散列取模算法将请求分配到不同的服务器上&lt;/p&gt;&lt;p&gt;优点：保证了相同客户端IP地址将会被哈希到同一台后端服务器，直到后端服务器列表变更。根据此特性可以在服务消费者与服务提供者之间建立有状态的session会话&lt;/p&gt;&lt;p&gt;缺点: 如果服务器进行了下线操作，源IP路由的服务器IP就会变成另外一台，如果服务器没有做session 共享话，会造成session丢失。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.monkeyjava&lt;/span&gt;&lt;span&gt;.learn&lt;/span&gt;&lt;span&gt;.basic&lt;/span&gt;&lt;span&gt;.robin&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.google&lt;/span&gt;&lt;span&gt;.common&lt;/span&gt;&lt;span&gt;.collect&lt;/span&gt;&lt;span&gt;.Lists&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.List&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestIpHash&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;List&lt;/span&gt;&amp;lt;String&amp;gt; ips = Lists.newArrayList(&lt;span&gt;&quot;192.168.1.1&quot;&lt;/span&gt;, &lt;span&gt;&quot;192.168.1.2&quot;&lt;/span&gt;, &lt;span&gt;&quot;192.168.1.3&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;ipHashRobin&lt;/span&gt;&lt;span&gt;(String clientIp)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        int &lt;span&gt;hash&lt;/span&gt;Code=clientIp.hashCode();&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; serverListsize=ips.size();&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; = hashCode%serverListsize;&lt;br/&gt;        String serverIp= ips.&lt;span&gt;get&lt;/span&gt;(index);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;  serverIp;&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        TestIpHash &lt;span&gt;test&lt;/span&gt;IpHash =new TestIpHash();&lt;br/&gt;        String servername= &lt;span&gt;test&lt;/span&gt;IpHash.ipHashRobin(&lt;span&gt;&quot;192.168.88.2&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out&lt;/span&gt;&lt;span&gt;.println&lt;/span&gt;(&lt;span&gt;servername&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;输出结果&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;每次运行结果都一样&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA4Mzk3NDAyOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ExViakhaSiafF9PQBaFnQkD6AO43WQdToSxBpzal8BoephuEeVU2X9rcGWwiavCibNLibQ4ib454XU0aTEibqx8y0o5yA/0?wx_fmt=png&quot; data-nickname=&quot;猴哥说Java&quot; data-alias=&quot;MonkeyTalkProgram&quot; data-signature=&quot;互联网码农一枚，Java 技术爱好者，喜欢分享交流&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fcad1337192e95e7de4626fb255d0bbe</guid>
<title>领域驱动设计下的服务高可用设计</title>
<link>https://toutiao.io/k/avyw7bz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;td class=&quot;blog_detail&quot;&gt;
&lt;input id=&quot;js_detail&quot; type=&quot;hidden&quot; value=&quot;我们知道领域驱动设计已经逐步应用落地，系统架构设计在后微服务时代，更快速的向DDD演进，微服务架构的设计面向系统维度的拆分，实现快速的独立部署，解决DevOps的效能问题，进入后微服务时代，领域模型的理解逐步深入，简单的设计微服务架构会使得系统过于松散，尤其在服务的高可用设计上，领域驱动设计的边界如何考量和把控，成为我们后微服务架构设计必须考虑的要素。&amp;#10;&amp;#10;今天的话题是讨论领域驱动设计下的服务高可用设计，首先举个例子，A调用B，B的服务高可用如何设计？&amp;#10;&amp;#10;方案一，A与B实现1:1的服务保障能力，RPC调用的SLA保障；&amp;#10;&amp;#10;方案二，A与B通过共享资源，降低RPC损耗，基于共享资源实现SLA保障；&amp;#10;&amp;#10;方案三，B提供二方包，封装RPC调用和存储资源，提供A本地调用的SLA保障。&amp;#10;&amp;#10;![](http://misc.linkedkeeper.com/misc/img/blog/202109/linkedkeeper0_63334c66-8187-431b-95c6-c7d9da964ed7.jpg)&amp;#10;&amp;#10;如何进行三种方案的技术选型？&amp;#10;&amp;#10;方案一，优点是架构简单，功能松耦合，领域定义清晰；缺点是1:1流量的服务保障，B服务的容器资源、调用性能、稳定性等衍生的稳定性风险，会有较大的高可用设计成本，尤其是若B提供的是一些配置数据，这个架构设计的性价比较低。&amp;#10;&amp;#10;方案二，优点是架构不复杂，功能清晰，领域定义明确，解决了静态数据1:1流量调度的弊端；缺点是A服务依赖了B服务的存储资源，在一定程度上形成了耦合，这体现在变更后的整体发布。这个架构设计降低了高可用设计的成本，但是随着时间推移A和B会演进成大泥潭。&amp;#10;&amp;#10;方案三，优点是功能清晰，领域定义明确，解决了A依赖B的耦合问题；缺点是架构复杂，B提供的Jar包变更仍需要A发布，存在一定的耦合。若A提供SPI的服务能力，成本会降低，但是A的高可用设计成本会加大。这个架构设计在选型时需慎重。&amp;#10;&amp;#10;&amp;lt;font size=1&amp;gt;微服务的九个核心特征：围绕业务能力构建，分散治理，通过服务来实现独立自治的组件，产品化思维，数据去中心化，强终端弱管道，容错性设计，演进式设计，基础设施自动化。&amp;lt;/font&amp;gt;&amp;#10;&amp;#10;其中，**通过服务来实现独立自治的组件**，微服务之所以强调通过服务Service而不是类库Library来构建组建，是因为类库在编译期静态连接到程序里，通过本地调用来提供功能，而服务时通过进程外调度，通过远程调度来提供服务。尽管远程服务有更高昂的调用成本，但这是为组件带来自治与隔离能力的必要代价。—— 摘自《凤凰架构》&amp;#10;&amp;#10;那么，基于微服务的设计理论基础，以及通过实践得出效果来看，绝大多数的业务架构都应该基于通过服务Service的模式进行设计，那么这就涉及到高可用的设计归属域的边界问题？就我个人而言，A服务已经完成领域的建模，那么高可用的设计则归属A服务，并与B确认服务的SLA。&amp;#10;&amp;#10;其中，**数据去中心化**，微服务明确提倡数据应该按领域分散管理、更新、维护、存储，那么通过共享资源的架构设计，这是否违背了微服务的设计原则？共享资源使得领域都必须修改和映射到同一个实体之中，这很可能使不同服务之间相互影响而丧失独立性。除此之外，共享资源带来的潜在隐患，B若是Ops系统，其发生问题可能影响到核心链路上的系统，比如A。&amp;#10;&amp;#10;那么，回到最开始的话题，A调用B，B的高可用设计就有了设计的变化。&amp;#10;&amp;#10;![](http://misc.linkedkeeper.com/misc/img/blog/202109/linkedkeeper0_dc2297ab-9fe5-46a9-becb-fb209f83c34d.jpg)&amp;#10;&amp;#10;如何进行三个方案的调整？&amp;#10;&amp;#10;方案二，共享缓存的架构设计，会造成A与B之间相互影响，进而调成独立缓存的架构设计。A与B共享缓存的设计，常见在系统已拆分，但组织架构未拆分的情况，这隐藏的约束是共享缓存专门服务于该业务，而非为领域服务。&amp;#10;&amp;#10;方案三，B提供二方包嵌入A，会造成A与B之间的相互影响，进而调整对B服务进行架构拆分的设计。这其实是领域设计已经逐步演进成需要对B服务进行垂直拆分的诉求，这也是B Jar出现的原罪，由此更应对B进行领域内的系统拆分。&amp;#10;&amp;#10;综述，今天讨论的内容就结束了，主要讨论了在分布式架构设计中服务间调用的高可用设计，以上不同的方案都有过实践，虽说代码写在哪里都可以，但领域驱动设计的愿景就是降低软件架构的设计复杂度，否则，终将是行走的恐龙巨兽。&quot;/&gt;
&lt;p id=&quot;markdown_detail&quot;/&gt;
&lt;br/&gt;
&lt;p&gt;本文受原创保护，未经作者授权，禁止转载。 linkedkeeper.com (文／然行)  &lt;a href=&quot;/site/copyright.action&quot;&gt;©著作权归作者所有&lt;/a&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7bedac8f7f233af483f94b0af5f755ea</guid>
<title>设计模式系列：单例模式</title>
<link>https://toutiao.io/k/sv1qgtx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;单例模式顾名思义，就是保证系统中一个类只有一个唯一的对象实例。实际开发过程中经常会碰到这种需求。&lt;/p&gt;&lt;p&gt;单例模式有两种实现方式，一种称为&lt;em&gt;饿汉式&lt;/em&gt;，一种称为&lt;em&gt;懒汉式&lt;/em&gt;。&lt;/p&gt;&lt;p&gt;先来看一下&lt;code&gt;UML&lt;/code&gt;图：&lt;/p&gt;&lt;figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5507936507936508&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/jmjNkE9L9QjvOWCaI6Z1MxjWW1H0oDyaoOH2JiczFQZXaXIG93zoYVl0yo7ia38NcGA51QZWdCAay5tkbKS2KbpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;630&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;饿汉式&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;之所以称为饿汉，是因为该种实现方式是在类被加载&lt;/span&gt;的&lt;span&gt;时候就初始化对象，而且是通过&lt;/span&gt;&lt;code&gt;JVM&lt;/code&gt;&lt;span&gt;的类加载机制保证系统中只有一个类实例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;先看饿汉式的完整代码&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SingleObject&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//create an object  of SingleObject&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SingleObject instance = &lt;span&gt;new&lt;/span&gt; SingleObject();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//make the constuctor private so that this class cannot be instantiated&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SingleObject&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SingleObject &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; instance;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;showMessage&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;       System.out.println(&lt;span&gt;&quot;I&#x27;m eager&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;饿汉式的关键代码在第一行，通过&lt;code&gt;static&lt;/code&gt;关键字修饰了&lt;code&gt;instance&lt;/code&gt;变量了，这样在类被加载的时候就会初始化&lt;code&gt;SingleObject&lt;/code&gt;。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;懒汉式&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;所谓的懒汉式就是在需要的时候在创建对象，懒汉式比较复杂，需要通过锁加双重检查机制来保障多线程环境下，只有一个实例被创建。完整代码如下&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LazySingleObject&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; LazySingleObject instance = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;LazySingleObject&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; LazySingleObject &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//第一重检查&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (instance == &lt;span&gt;null&lt;/span&gt;){&lt;br/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (LazySingleObject&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;               &lt;span&gt;//第二重检查&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (instance == &lt;span&gt;null&lt;/span&gt;){&lt;br/&gt;                    instance = &lt;span&gt;new&lt;/span&gt; LazySingleObject();&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; instance;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;showMessage&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;I&#x27;m lazy&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样使用单例模式&lt;/p&gt;&lt;pre&gt;&lt;code&gt;SingleObject object = SingleObject.getInstance();&lt;br/&gt;&lt;span&gt;//show the message&lt;/span&gt;&lt;br/&gt;object.showMessage();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;单例模式也是创建型模式之一，实现该模式的时候都要把实例变量设置为静态的，其次构造函数都要变成私有的，防止在外部被引用并创建对象。饿汉式实现起来比较容易，但是初始化的实例对象比较耗时和占用资源的话，在系统启动时会比较浪费时间和资源；相反懒汉式则是在需要的时候进行初始化，不会占用系统启动资源，但是实现起来比较麻烦，特别是在多线程的场景下，除非有特殊要求，否则建议使用饿汉式。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484022&amp;amp;idx=1&amp;amp;sn=d3176ea73e48360b64c3f50e8fd622bf&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;1. Java并发编程那些事儿(十)——最后的总结&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484130&amp;amp;idx=1&amp;amp;sn=eb09dd99d1a8e892a3de73d898c04b0c&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;2. 程序员应该掌握的常用网络问题定位工具&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247483893&amp;amp;idx=1&amp;amp;sn=85f6a2063048cc244aedde3172444e32&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;3. Awk这件上古神兵你会用了吗&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247483852&amp;amp;idx=1&amp;amp;sn=6efb0db3d5dff639fae2aaec978c2160&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;4. 手把手教你搭建一套ELK日志搜索运维平台&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>