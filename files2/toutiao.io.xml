<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0299745d12d7fed8f5f3ad9c48692bdc</guid>
<title>面试官问：如何保证 MQ 消息是有序的？</title>
<link>https://toutiao.io/k/cemwgzn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是Tom哥~&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了系统间解耦，我们通常会引入&lt;/span&gt;&lt;code&gt;&lt;span&gt;MQ&lt;/span&gt;&lt;/code&gt;&lt;span&gt;框架，大家各司其职共同完成上下游的业务流程。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.275&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweLJVZ3yKhblYxiaXUBL3CMYwSdHxu9LiadrVdUVT3Lic3HVToiavEGbdEr0qEZfwfiab1qmFiaGd4xR8tA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;大致过程：&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;生产端，创建一条消息，通过网络发送到MQ Server&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;MQ将 消息存储在topic 的&lt;strong&gt;一个分区&lt;/strong&gt;里&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;消费端，从分区中拉取消息，消费处理&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;但现实往往不一样！MQ 架构设计要满足高并发、高性能、高可用等指标&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweLJVZ3yKhblYxiaXUBL3CMYMBwt2sBKy4a5aoXvHAJ5B0ZiaiaGOtxZIkhAib7WB8NoNclGjX56eic9fg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;225&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;单分区，达不到我们的吞吐量要求，我们考虑采用&lt;/span&gt;&lt;code&gt;&lt;span&gt;多分区&lt;/span&gt;&lt;/code&gt;&lt;span&gt;架构设计，正所谓 ”三个臭皮匠赛过一个诸葛亮“，多分区可以有效分摊全局压力，提升整体系统性能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.48984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweLJVZ3yKhblYxiaXUBL3CMYOBHyObVr0FZ3zcZqZVbusiblH1azsU0SIt5IIkep8nHq4CVkaicaSFCA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;两台 MQ机器，组成一个集群，原先一个分区存储&lt;/span&gt;&lt;code&gt;&lt;span&gt;6条消息&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，现在分摊到两个分区，每个分区各存储&lt;/span&gt;&lt;code&gt;&lt;span&gt;3条消息&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，性能比上面那个提升一倍。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;貌似可以满足我们的需求，但任何事情都有两面性！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;我们看看下面业务场景：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个用户在电商网站上下订单到交易完成，中间会经历一系列动作，订单的状态也会随之变化，一个订单会产生多条MQ消息，&lt;/span&gt;&lt;code&gt;&lt;span&gt;下单&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;付款&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;发货&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;买家确认收货&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，消费端需要严格按照业务状态机的顺序处理，否则，就会出现业务问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们发现，消息带上了状态，不再是一个个独立的个体，有了上下文依赖关系！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于这个问题，突然想到&lt;/span&gt;&lt;code&gt;&lt;span&gt;HTTP协议&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，其本身也是无状态的，也就是说前后两次请求没有关联，但有些业务功能有登录要求，那怎么解决？&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;引入Cookie机制，每次请求客户端额外传输一些数据，来达到上下文关联。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;回到MQ的消息顺序问题，我们要如何解决？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweLJVZ3yKhblYxiaXUBL3CMYQZ2OGJWDBPX9OOictn1wveZv7d9vxGK4dKMFc1DKQ60ePhS3q8buyWw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：各退一步，保证局部有序。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;比如上面的电商例子，只要保证一个订单的多条状态消息在同一个分区，便可以满足业务需求，这个方案可以覆盖大部分的业务场景。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里面只需要有一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;路由策略&lt;/span&gt;&lt;/code&gt;&lt;span&gt;组件，由它决定消息该放到哪个分区中！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;考虑到市面MQ开源框架很多，常见的如：Kafka、Pulsar、RabbitMQ、RocketMQ 等，API方法略有区别，但设计思路是相通的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来，我们以 &lt;/span&gt;&lt;code&gt;&lt;span&gt;RocketMQ&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 为例：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;生产端提供了一个接口 &lt;/strong&gt;&lt;strong&gt;&lt;code&gt;MessageQueueSelector&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;public interface MessageQueueSelector {&lt;br/&gt;   MessageQueue select(final List&amp;lt;MessageQueue&amp;gt; mqs, final Message msg, final Object arg);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接口内定义一个select方法，具体参数含义：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;mqs：该Topic下所有的队列分片&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;msg：待发送的消息&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;arg：发送消息时传递的参数&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于&lt;/span&gt;&lt;code&gt;&lt;span&gt;MessageQueueSelector&lt;/span&gt;&lt;/code&gt;&lt;span&gt;接口，RocketMQ 框架提供了三个默认实现类：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;1、SelectMessageQueueByHash：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;arg参数的hashcode的绝对值，然后对mqs.size()取余，得到目标队列在mqs的下标&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;2、SelectMessageQueueByRandom：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;对mqs.size()值取随机数作为目标队列在mqs的下标&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;3、SelectMessageQueueByMachineRoom&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;返回null&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;特别注意：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;虽然保证了单个分片的消息有序，但每个分片的消费者只能是单线程处理，因为多线程无法控制消费顺序。这个可能会损失一些性能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;这里又引出另一个问题，如何保证一个队列只能有一个消费端呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;org.apache.rocketmq.client.impl.consumer.RebalanceImpl#updateProcessQueueTableInRebalance&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.72578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweLJVZ3yKhblYxiaXUBL3CMYl2pt0ywfYicNtMhvibW69wZttFKtGPWr8WwIKRMU34sefEibh2iapxlLCA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;遍历一个topic下所有的&lt;/span&gt;&lt;code&gt;&lt;span&gt;MessageQueue&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;isOrder &amp;amp;&amp;amp; !this.lock(mq)&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 尝试对它加锁，确保一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;MessageQueue&lt;/span&gt;&lt;/code&gt;&lt;span&gt;只能被一个消费者处理&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、将&lt;/span&gt;&lt;code&gt;&lt;span&gt;PullRequest&lt;/span&gt;&lt;/code&gt;&lt;span&gt;对象放入&lt;/span&gt;&lt;code&gt;&lt;span&gt;PullMessageService&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的&lt;/span&gt;&lt;code&gt;&lt;span&gt;pullRequestQueue&lt;/span&gt;&lt;/code&gt;&lt;span&gt;队列中&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;public void dispatchPullRequest(List&amp;lt;PullRequest&amp;gt; pullRequestList) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (PullRequest pullRequest : pullRequestList) {&lt;br/&gt;        this.defaultMQPushConsumerImpl.executePullRequestImmediately(pullRequest);&lt;br/&gt;        log.info(&lt;span&gt;&quot;doRebalance, {}, add a new pull request {}&quot;&lt;/span&gt;, consumerGroup, pullRequest);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、org.apache.rocketmq.client.impl.consumer.PullMessageService#run&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5194585448392555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweLJVZ3yKhblYxiaXUBL3CMYNtXfYvjXiaA3pklFgicmE4opBJLcHpXFX2icosQRmaJaibIUZCJXX54OMA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1182&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;PullMessageService&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/code&gt;&lt;span&gt;线程任务&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;无限循环，从队列中拉取、处理消息&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;另一个问题，如何保证一个队列，只有一个线程在处理消息呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、&lt;span&gt; DefaultMQPushConsumerImpl#pullMessage&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweLJVZ3yKhblYxiaXUBL3CMYU9ZoJd7icmutNLRvKn4hpjrmQappjyVuJw6Wp7uuME61Ex5RkdQvCXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;ConsumeMessageService&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中有两个实现类，因为我们有消费顺序要求，会选择&lt;/span&gt;&lt;code&gt;&lt;span&gt;ConsumeMessageOrderlyService&lt;/span&gt;&lt;/code&gt;&lt;span&gt;来处理业务&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、 ConsumeMessageOrderlyService.ConsumeRequest&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.38671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweLJVZ3yKhblYxiaXUBL3CMYibywA90B6mrYy7tQMhou6Pz1ZUiaQOyzf2PerklFzU8oyxy09HYvRX1g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;br/&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从&lt;/span&gt;&lt;code&gt;&lt;span&gt;ConcurrentMap&lt;/span&gt;&lt;/code&gt;&lt;span&gt;中获取&lt;/span&gt;&lt;code&gt;&lt;span&gt;messageQueue&lt;/span&gt;&lt;/code&gt;&lt;span&gt;对应的锁对象&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 关键字，线程来抢占锁，互斥关系，从而保证了一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;MessageQueue&lt;/span&gt;&lt;/code&gt;&lt;span&gt;只能有一个线程并发处理&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;继续往下看，如果扩容了怎么办？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原来有6个分区，&lt;/span&gt;&lt;code&gt;&lt;span&gt;order_id_1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的消息在&lt;/span&gt;&lt;code&gt;&lt;span&gt;MessageQueue6&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中，此时扩容一倍，现在12个分区，&lt;/span&gt;&lt;code&gt;&lt;span&gt;order_id_1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;订单后面产生的消息可能路由到了&lt;/span&gt;&lt;code&gt;&lt;span&gt;MessageQueue8&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中，同一个订单的消息分布在两个分区中，无法保证顺序。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们能做的是，先将存量消息处理完，再扩容。如果是在线业务，可以搞个临时topic，先将消息暂时堆积，待扩容后，按新的路由规则重新发送。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;顺序消息，如果某条失败了怎么办？会不会一直阻塞？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、如果失败，不会提交消费位移，系统会自动重试（有重试上限），此时会阻塞后面的消息消费，直到这条消息处理完&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、如果这个消息达到重试上限，依然失败，会进入&lt;/span&gt;&lt;code&gt;&lt;span&gt;死信队列&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，可以继续处理后面的消息&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关于我：前阿里P7技术专家，出过专利，竞赛拿过奖，CSDN博客专家，负责过电商交易、社区生鲜、互联网金融等业务，多年团队管理经验。&lt;/span&gt;&lt;/section&gt;&lt;h1 accuse=&quot;qTitle&quot;&gt;&lt;span&gt;&lt;span&gt;关注「微观技术」，后台回复 “算法”、“书单” 关键字，免费领取资料&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.069090909090909&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwcdJhGaQRdAk0VWLIAIU548z3Izf6mwqwwUX9X86hvNHZq158VYMEaxegjfRg8ic02O0HeWD4xIsiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247485551&amp;amp;idx=1&amp;amp;sn=533259fc15567b9f44e169943be4a305&amp;amp;chksm=ceb9f4c4f9ce7dd2debac27430c17c39fdb6ffadbd35c5494c68d39615a513336b7432b2ec1a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;聊聊 Kafka 那点破事！&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247485467&amp;amp;idx=1&amp;amp;sn=de5105db459f8ffd60f34850784c8e48&amp;amp;chksm=ceb9f4b0f9ce7da6f3c25b039148d2193e3623a8fc7290debbf908e050613eb402c7fe80567c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;什么是布隆过滤器？如何解决高并发缓存穿透问题？&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247484980&amp;amp;idx=1&amp;amp;sn=25a530689f0657750d579263800369a6&amp;amp;chksm=ceb9fa9ff9ce7389974d2f33bea9d861920cb75cca559f1f2810c89f729011bb3c2839ac46da&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;学会这10个设计原则，离架构师又进了一步！！！&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247484929&amp;amp;idx=1&amp;amp;sn=d8cb3306dea9f1b92fd30d59da3f536a&amp;amp;chksm=ceb9faaaf9ce73bca59b46021a450fdc84aa0f85d6b49ff0e5578cc3abaa1433447f7dffc5e4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;人人都是架构师？？？谈何容易！！&lt;/span&gt;&lt;/a&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4a3b521edd93674fcdcf84f322b51b56</guid>
<title>Android 端权限隐私的合规化处理实践</title>
<link>https://toutiao.io/k/7eoe7fm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;是什么&lt;/span&gt;&lt;/section&gt;&lt;section&gt;对客户端而言，权限隐私可分为权限和隐私两个大的方面。&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;权限为用户通过app内弹窗设置或者手机设置内对应app的权限设置方式给予对应app相应的权限，如电话权限，定位权限，相机权限等，本文主要集中介绍隐私相关的权限部分。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;隐私为app使用过程中与用户个人相关的个人信息，如所在位置，Mac地址，设备id等。就Android端而言，多数隐私信息需要对应授权后才能获取，但目前仍存在部分隐私信息无需授权就可以拿到的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;为什么&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;大众隐私意识觉醒，权限隐私安全性差会直接导致用户不愿使用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;日趋严格的权限治理和隐私安全治理，工信部和市场的严格管控；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端作为与用户最直接的交互信息收集入口，有义务合规化的收集和使用用户信息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;具体实践&lt;/h3&gt;&lt;h4&gt;一.Android各版本对权限的适配处理&lt;/h4&gt;&lt;h5&gt;1.1 早期的注册权限&lt;/h5&gt;&lt;section&gt;Android6.0(SDK版本为23)之前的版本，安装App页面会列出当前app所注册的所有权限，无同意与否按钮，只有安装和取消，开发App时只需要在清单文件中注册所需的对应权限即可：&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;code&gt;&amp;lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&amp;gt;&lt;br/&gt;&amp;lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&amp;gt;&lt;br/&gt;&amp;lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&amp;gt;&lt;br/&gt;&amp;lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h5&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5&gt;1.2 动态权限授予&lt;/h5&gt;&lt;section&gt;Android自6.0(SDK版本为23)开始，将权限分为普通权限，危险权限，特殊权限。而其中的&lt;strong&gt;危险权限&lt;/strong&gt;需要在调用某些系统方法之前需要用户手动授予对应权限，包括PHONE,LOCATION,STORAGE等多个权限组。如果在没授权的情况下直接调用相关方法，就会抛出，应用也随之崩溃。报错信息类似下方这种：&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;code&gt;java.lang.SecurityException: getDeviceId: has android.permission.READ_PHONE_STATE.&lt;br/&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;而要解决以上的报错问题，可以自行封装权限处理类工具，也可使用一些开源的权限工具进行处理。核心代码都逃不过：&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;code&gt;//判断某个权限是否已经被同意&lt;br/&gt;ContextCompat.checkSelfPermission(context, perm) ==  PackageManager.PERMISSION_GRANTED)&lt;br/&gt;//请求某个权限，调用后会弹出权限系统弹窗&lt;br/&gt;ActivityCompat.requestPermissions((Activity) object, perms, requestCode);&lt;br/&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;注：如果用户拒绝权限且不让再次显示系统权限授权弹窗的话，最好是提供端内可点击进入手机系统的权限设置页面以让用户可以选择开启对应权限。&lt;/section&gt;&lt;h5&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5&gt;1.3 READ_PHONE_STATE权限的变化&lt;/h5&gt;&lt;h6&gt;1.3.1 演变&lt;/h6&gt;&lt;h6&gt;&lt;br/&gt;&lt;/h6&gt;&lt;h6&gt;1.3.2 适配处理&lt;/h6&gt;&lt;h5&gt;1.4 存储分区的处理&lt;/h5&gt;&lt;section&gt;自Android10.0之后，Google开始采用存储分区，主要目的是改变现有App胡乱使用手机存储导致垃圾和其他安全问题。适配 Android11 后强制使用存储分区。具体分区如下，扩展的外部存储是无权限进行读取的。而其他私有存储会在App卸载后清理掉：&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.49663526244952894&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtk1iadicGZOnHmjo6G9u1LBe6ysr1HanurCZRafmCC7dG7mH8W0PatfTyQkq39AMB6eNyO5iceNx3RAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;743&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体部分代码改动如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;1.拍照存储路径：&lt;br/&gt;&lt;code&gt;Environment.getExternalStorageDirectory().getAbsolutePath()&lt;/code&gt;修改为&lt;code&gt;getExternalFilesDir(Environment.DIRECTORY_DCIM)&lt;/code&gt;；&lt;/section&gt;&lt;section&gt;2.原本的存储路径 /storage/emulated/0 改为 /storage/emulated/0/Android/data&lt;br/&gt;具体调用的修改为:&lt;br/&gt;&lt;code&gt;Environment.getExternalStorageDirectory()&lt;/code&gt;改为&lt;code&gt;context.getExternalFilesDir()&lt;/code&gt;;&lt;/section&gt;&lt;section&gt;3.如果App在sdcard中有重要存储，可以在适配android10.0的过渡阶段将之前的数据复制出来到新的存储分区中。&lt;/section&gt;&lt;h4&gt;二.隐私信息合规化处理&lt;/h4&gt;&lt;section&gt;上半部分较为粗略的过了一下权限相关的部分改动和对应修改，接下来说一说隐私信息的合规化处理。当然，权限作为隐私处理的前提，如果权限都没有合理的修改完毕，那隐私处理合规化更谈不上了，毕竟很多隐私是依赖于权限的。&lt;/section&gt;&lt;h5&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5&gt;2.1 隐私信息获取告知的直接化和透明化&lt;/h5&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在首次打开App时，需要在进行初始化之前就向用户展示用户协议与隐私保护弹窗或页面，只有用户在同意之后才能进入App进行使用。而对于&lt;strong&gt;手机号、MAC地址、IMEI、所在位置信息、手机存储权限、相册访问权限&lt;/strong&gt;，&lt;strong&gt;手机流量使用&lt;/strong&gt;等敏感信息需要让用户在第一屏就能够看到。并且提供用户协议和隐私政策链接，能让用户点击后查看具体详细的条款。设计完成后要让法务进行确认，是否符合。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在处理1.2中的动态权限时，需要在系统弹窗中或者之前说明需要用户授予该权限的原因。如：获取定位权限之前需要告知用户该权限是为了获取定位信息，然后精准推送相关内容。获取相机权限是为了要使用摄像头进行拍照。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在进入App操作三步以内能看到法律条款和隐私政策入口，正常处理方式会在App的&lt;strong&gt;设置页&lt;/strong&gt;内加上对应入口。同时在注册登录页面，需要明显展示出法律条款和隐私条款入口，且需要默认不勾选，需要用户主动同意后才能进行账号注册和登录。如下图：&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.15965583173996176&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtk1iadicGZOnHmjo6G9u1LBe6OfrL54NNPjtwA7WvSzbKFqPkYHibib7YZtIhpYL9s5SS4icviaV7hnNBmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分发广告的App需要注意处理广告下载逻辑，在用户点击后需要展示所下载App的信息，所需的权限和隐私条款，让用户清楚的知道下载的App是否是自己想要的，且不允许自动下载。这样能很好的解决用户无意识的在手机上下载了很多无用App，这对很多老年人使用手机很有帮助。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5&gt;2.2 隐私信息获取和传输的安全化&lt;/h5&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;避免频繁的调用系统方法获取隐私信息，可以在单次启动App调用该获取数据后使用全局变量进行缓存，之后每次使用时直接调用全局变量使用就行，不必每次都调用系统方法。包括&lt;code&gt;getDeviceId&lt;/code&gt;,&lt;code&gt;getMacAddress&lt;/code&gt;等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;诸如imei，mac，定位的经纬度等敏感信息，需要避免多次在网络中传输，可以处理为单独接口收集相关信息一次后保存在服务端即可，无需每次传输；另外需要避免以明文的方式在数据接口中传输。像imei可以通过MD5加密算法进行加密处理，并不会影响用户的区分；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于READ_PHONE_STATE权限升级为了系统权限&lt;strong&gt;READ_PRIVILEGED_PHONE_STATE&lt;/strong&gt;，部分通过native方式(C代码)直接调用imei等信息时也会报错或者为空。建议这部分尽量使用java方式调用，如果有变动可以明显的感知到错误并修改，不至于需要重新修改C代码，然后又进行jni编译。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5&gt;2.3 部分隐私Api调用的严格化&lt;/h5&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在未授权的情况下，需要保证App中与该权限无关联的功能可以正常使用。所以就不能简单的处理为1.3.1中提到的不给权限就不让使用App的方案了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Android端目前尚存在部分无需动态授权就可以获取的隐私，如用户手机上的应用安装列表。此信息可用于分析用户喜好，如小说类产品还是视频类产品；也可以用于分析用户某些App还未安装，便于推送广告的拉新。但目前国内市场已经开始治理，如果存在获取手机内应用列表的情况，会进行下架处理或者不予上架。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;目前工信部和各应用市场对App上架要求严格，使用第三方检测工具可以很细致的检测出App中存在哪些不合理的系统方法调用，比如：在未同意协议与隐私之前就进行了网络请求；在未同意协议与隐私之前获取了Mac地址；在未获取定位权限的情况下就获取了手机的基站信息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;三.遇到的一些问题和坑&lt;/h4&gt;&lt;section&gt;这里总结部分在开发过程中遇到的一些隐蔽小点，希望能帮助到大家。&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;早期的腾讯X5内核会在隐私协议展示时就会获取mac地址，如下图。可尝试更新到新的版本继续查看。由于我方对X5内核需求不高，所以直接进行了删除清理。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.22109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtk1iadicGZOnHmjo6G9u1LBe65qTsZDeghEqRIDbNnXwQ4XtibSibf3nicDHG2cgfQbUTDBebLgzy748aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;集成开源库或者第三方sdk的初始化均需要处理为同意隐私之后再进行，大多数sdk在初始化时都会调用相关无需授权的api方法。如语音相关的讯飞sdk会在初始化的时候调用MAC地址信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部分统计库如umeng，talkingdata sdk需要升级到新版本的接入方式。老版本的talkingdata sdk在尚未授定位权限时进行初始化仍会调用手机基站信息api(属于定位)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自有代码逻辑中相关隐私信息的获取和赋值，也都要放到隐私同意之后去进行，故在用户协议和隐私同意之前尽量少的进行代码逻辑处理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;总结&lt;/h3&gt;&lt;p&gt;&lt;span&gt;权限隐私的发展趋势只会越来越严格和规范。在日常的客户端开发当中，我们就需要时刻持有隐私安全的意识，让自己站在用户的角度上合理的保证隐私安全。并紧跟隐私安全的发展，提前布局。这样才能不至于临时出问题后手忙脚乱的去处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;本文仅粗略的记录了一些权限隐私相关的一些情况和做法，如有不当，欢迎指正&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1127a48939f9a0152cc9708575c65b6d</guid>
<title>初探自动化部署 Jenkins 安装及配置</title>
<link>https://toutiao.io/k/7n84pl9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;感谢赞赏，一起进步&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>15a29d3a5bd730b6d1e09794be791cc7</guid>
<title>Kubernetes 多集群架构探索</title>
<link>https://toutiao.io/k/6xcvtu3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;7月17日，在Cloud Native Days China云原生多云多集群专场，有赞技术专家王兵发表了《Kubernetes多集群架构探索》主题演讲，介绍了有赞多集群的落地实践，以及如何使用Karmada进行多集群管理。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6755162&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnBxmiaDGF9iaGE3QwjUH8ukaPiafQRcswXUC4dmtMibwr03tnKVQcXBXKiawSNk0yC78lR2uVvAcciaxncQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;678&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;演讲主要包含三部分的内容：&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;为什么要使用多集群&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;有赞多集群使用情况及存在的问题&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;多集群方案探索与选择&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;为什么要使用多集群？&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;关于多集群的使用我们主要有三方面的考虑：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1、单集群限制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;现在K8s是开发到1.22版本了，但是单集群限制目前来看还是没有改变。比如单个node还是110，一个集群也就是5000个节点左右。根据我们的使用经验，在单集群时，1个集群内部有2000个service时，其实我们的集群已经出现了一些瓶颈。我们都知道 Service会自己产生一些service的环境变量，当我们去创建对应的 development，然后去创建对应的service时，发现每个pod会产生大量的service，当然这里边有个前提，我们的service都在同一个namespace下面，比如在生产环境，一个namespace下的service可能有几千个，当我们去执行某些命令时会非常卡，另外环境变量比较多的话，会影响应用的启动。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、多云架构：&lt;/strong&gt;有赞最开始是一个多云多机房架构，就是说我们天然最少在一个云上应该有一个机器人。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、容灾&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在我们最开始容器化的时候一朵云上只有一个集群 , 流量是两边都存在的。在17年~18年时出现了一个故障：我们内部有一个自研的ingress controller出现bug之后，入口的一个核心应用发布的时候 endpoint更新了，结果我们自研的ingress controller并没有把endpoint更新到它的off stream里面，因为所有的流量基本都会经过核心应用，导致机房无法使用。因此我们就开始拆集群，最起码要保证一朵云上有两个集群。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;有赞多集群使用情况及存在的问题&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们现在使用 K8s多级群主要分为4个部分：&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;整体的部署架构&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6943649&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnBxmiaDGF9iaGE3QwjUH8ukaPz5D2vdLFTUkrYoGGJPvoQyicrckrLNn12a4pGnLjVpNkOVNy3mvrGVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1047&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如上图我们内部目前是这样使用的：在不同云上的不同的机房，最上面的组件yz7是统一接入层，上文提到的提到的ingress controller就是和它交互的。在每一朵云上有的云我们可能直接用它的公有云，有的云可能是有托管的机房，也可能会用它的公有云。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;每朵云最少有两个K8s集群，这里不一样的地方是因为有托管还有云上的，下面是一个VK的节点，我们最开始这个地方的云是自建的，会有伸缩性受限的问题存在，在使用了开源社区的某个组件后，增加了一个虚拟节点，这个虚拟的节点其实往上套了一下，对应的它机房里边的一个公有云的一个k8s的集群。因此从整体来说，在集群的层面都是可以任意扩展的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;应用部署&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;有了集群之后，如何将应用和程序部署到k8s？有赞内部最开始有4个环境：daily、 QA、预发和生产4个环境，最开始的daily是给研发提供环境去验证代码；QA用于测试，其环境相对是比较稳定的，但是它连的数据库与线上环境基本是一致的，所以可以在最终发到真正的线上时，还能在预发环境进行验证。后面我们把 daily环境去掉了，做了一个持续交付的环境来替代 Daily的需求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;应用部署方面，还有其他相关联的一些系统，比如我们内部的ingress controller这样的系统，其实它也是需要和K8s交互的，目前来说我们内部90%以上的无状态的业务应用都已全部容器化，都是通过我们的发布系统发布到对应的K8s集群。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5014451&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnBxmiaDGF9iaGE3QwjUH8ukaPoRFZBXVw4PHTRlf9bQ7NT0j8lR00ojV9lgY6aCHwF9ianicpCKjGye3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;692&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;服务发现和暴露&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;服务发现和暴露，主要分两块，最外面接入层的流量HTTP和内部的RPC流量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;HTTP&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5515289&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnBxmiaDGF9iaGE3QwjUH8ukaP4qTX8xsm2GCerYdO7E9Z8KiaNIzlrjiaTicq7icykyEichrkiatYIfgzibxHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;883&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HTTP流程：我们内部有一个统一的接入软件yz7，yz7有个组件yz7-k8s-sync，这个组件和开源ingress controller做的工作类似，然后将对应的endpoint写到yz7的配置里，在内存里日更新。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;RPC&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6784141&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnBxmiaDGF9iaGE3QwjUH8ukaP7aic4icFkexYwROELxsibBnZmicb4GibChpEaib4ROVmvNGz9d5uwAVHjb2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;681&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;RPC服务发现最开始其实是一个大的单体应用，后面逐渐进行了拆分，微服务化，然后使用了国内用的比较多的Dubbo。我们最开始做容器化时，它的服务发现都还是依托Dubbo框架，因此刚提到的使用macvlan有一个优势，在切容器化时，虚机和容器其实是无所谓的，都注册到Dubbo里，它的注册中心都能注册到，它的调用方也都可以调到，因为网络是可达的，这是我们微服务化后使用Dubbo的第一步。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第二步是我们基于Istio 1.1版本拉出来的分支做的服务发现，相当于依托K8s的原数据做的服务发现，也是一个逐渐渐进的过程，所以中间也是会存在它的服务发现同时依托于K8s的原数据和Dubbo的etc原数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;下图其实是最终我们想要呈现的架构图：&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6726519&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnBxmiaDGF9iaGE3QwjUH8ukaP0Ipu1Mrx7wDncQbppDcNKzWAEMz04T2MQFibyH6qHicdCHelS3tZLdow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;724&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这里边相当于所有的服务注册或服务发现的数据都依托于K8s里的原数据。里边的 Pilot组件就是我们基于Istio社区1.1拉出来一个分支进行迭代的。Tether组件时我们自研的，最终是要接管在容器里面进出的所有流量。它现在也提供了一些能力，比如能够通过它的接口去自己实现服务的注册。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;弹性伸缩&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;弹性伸缩我们现在主要分两块：一个是应用程序的弹性伸缩，还有一个是集群的弹性伸缩。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;应用的弹性伸缩，首先有个前提集群的规模是可以弹性的，集群的弹性伸缩，我们现在主要做了两件事：第一个是在托管的或者叫自建的机房里，我们使用了Virtual Kubelet，让其作为一个虚拟节点存在于自建的机房里，和对应机房公有云上的k8s去联通；另外我们自研了一套集群节点伸缩系统，可以在上面配置节点相对应的弹性规则。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;使用多集群存在的问题&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;运维困难：我们是在多环境多云多机房，然后有N个开发者的集群，对于开发者的管理员来说是非常痛苦的。比如我们新建了一个集群，如果这份原数据需要在很多系统里都进行配置，对于运维同学来说是相当痛苦的，因为相关的系统跑不起来或者程序发不起来。第二个问题多集群在新建集群时，目前来说它这份配置需要一个check list，所有的系统都要去完成变更将这份配置给加上，这个周期是比较长的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;多集群间元数据的同步：主要是workload方面，目前我们的workload是通过发布系统，逐步的向每个集群发布，如此可能会导致如果一个集群挂了，就没有办法进行发布。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;多集群方案探索与选择&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们是在今年年初开始对业界的一些多集群管理系统进行调研：&lt;/p&gt;&lt;p&gt;1）kubefed v2：对于我们来说，API需要重新试配，其他的一些周边或配套系统也要跟着更改，改动成本比较大。&lt;/p&gt;&lt;p&gt;2）karmada：调研过程中Karmada正好开源，非常符合我们的需求。&lt;/p&gt;&lt;p&gt;3）OpenClusterManagement：组件比较多，后期运维起来会比较麻烦，而且感觉它是openshift里边一个组件，后期是否会和openshift耦合性太强，这也是我们担心的点。&lt;/p&gt;&lt;p&gt;4）kcp：项目比较早期&lt;/p&gt;&lt;p&gt;因此，&lt;strong&gt;最终我们选择了Karmada&lt;/strong&gt;。其主要的优势有以下几个方面：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;灵活的分发策略&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;支持多集群间的灵活调度&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;可使用原生 Kubernetes API&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;支持自定义调度&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目前来说Karmada已经满足我们的需求了，后期我们会选择Karmada作为多集群管理的方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下图为我们期望的最终应用部署架构图：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9493464&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnBxmiaDGF9iaGE3QwjUH8ukaPOWmib5V3jicsSJL8WuveKkS3d66vzI5rUd92CqP3nlhmV6zqq01D2r7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;612&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Control Plane为最上面的控制面，它是纯粹的控制面的集群，不会部署真正的workload，包含Karmada和Pandora，Pandora是放置我们内部写的operator；下面为Runtime集群，也就是我们现在的K8s架构，这里有个很大的变化：之前我们做发布或其他周边系统需要和K8s进行交互时，可能直接通到最下面，但改成这样的话，就不需要和下边的runtime集群去交互，如何需要交互，是和Control Plane里边的对象进行交互。这样的好处是下边的集群无论怎么变化，它在这里是可以感知和控制的，可以解决我们上文提到的一些问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;下图为我们做的pass平台，其主要解决应用交付的问题：&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.8882083&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnBxmiaDGF9iaGE3QwjUH8ukaPSK8ATDRY41H0GBiafuyWN2dMxkxZcgUDBr0uKBBPwTpOo94LLiaficFOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;653&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们期望的效果是发布系统将程序或应用分发到集群里，和K8s 里的API Server直接交互。上面是面向用户也就是研发人员进行应用发布动作；中间层是我们pass平台对外暴露的APIServer，我们希望做的 pass平台能将无状态应用和有状态应用都能收拢到一起。整块的话，这里有Control Plane cluster的，Sync我们会同步一些原数据，主要是给UI这一层使用，然后会同步到RDS；控制面的Control Plane集群，它里边有很多operator，其中就包括了Karmada的countrol manager，去往下面分发，这里边workload是没有的，最下面是runtime的环境。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;总的来说，其优点主要有：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;统一控制面，所有元数据都在控制面系统中&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;底层集群不可用无影响&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;控制系统无需感知底层集群变化&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.74&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/ZPtdzESiawhdMHyNfDvj0a36SiaN499NjK0BKean9ibV1T8rYe2gLG8OTSjeCB1NesY09JLKujB7DqpO8DGu4HFxw/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNzU5NTYzMA==&amp;amp;mid=2247493941&amp;amp;idx=1&amp;amp;sn=d6f22061d25c8f3917a39e3e92c4b934&amp;amp;chksm=e8c497b4dfb31ea297c290054ac9e2c723d03b778cd144e5be973a1e7cc6d479a66256694786&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;科普 | 除了容器的发家史，你还想了解啥？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNzU5NTYzMA==&amp;amp;mid=2247493935&amp;amp;idx=1&amp;amp;sn=41bf964db631b998f63e612e837263bc&amp;amp;chksm=e8c497aedfb31eb830408d10b0699dd45c7fa98f23d20a1a44342ca78bb263c2a0a29d1e49db&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;云原生动态周报 | Istio 1.11正式发布&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNzU5NTYzMA==&amp;amp;mid=2247493814&amp;amp;idx=1&amp;amp;sn=45eb1d83218aa8ce41eb05920df4561e&amp;amp;chksm=e8c49637dfb31f2191289af1ccef43e375f0451c6529bf877fbd14a60afd15595b42e05c4c47&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;科普 | 从零开始入门容器，看这篇就够了！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;111&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;111&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ia1Z7HH4plnCqgkia6XMVK2WHqxZTTxdjOrOVKE3oBVsIRbB7hbhQTt3ll0pJo5icuicoKjAxAnoN07lu1ohK82w4A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;扫描二维码 ｜ 加入Karmada技术交流群&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/6aVaON9Kibf5ibKRPQgZ9XgbVNsIeQUnfKSiaErmr8dtdicicS3A8m6TiavR6ZB0Eah3pD0kjQg8ACyNb1x5ibdqRg2jA/640?wx_fmt=gif&quot;/&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;戳原文，&lt;span&gt;观看完整演讲视频&lt;/span&gt;！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>854a49ca81b421039408dc9bf1890e95</guid>
<title>小样本学习及其在美团场景中的应用</title>
<link>https://toutiao.io/k/j8tgo23</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;[4] Wei J, Huang C, Vosoughi S, et al. Few-Shot Text Classification with Triplet Networks, Data Augmentation, and Curriculum Learning[J]. arXiv preprint arXiv:2103.07552, 2021.&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>