<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1f7e8d2ac0645384db7f9323f59b202a</guid>
<title>大吉大利虎年春节猫福盒，点击链接立即领券购买！</title>
<link>https://toutiao.io/k/y5ztper</link>
<content:encoded>&lt;div&gt;&lt;body data-spm=&quot;10720394/n&quot; id=&quot;readabilityBody&quot;&gt;
    
    
    
    
    
    
      
      
    
    
    
    
    
  &lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9281a42de0566df0d10cc3a0cdc1dded</guid>
<title>[推荐] 从零打造 Instagram</title>
<link>https://toutiao.io/k/hufqvji</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;article&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;Instagram是全球最大的照片、视频分享社区，如果让我们自己设计一个Instagram这样的服务，应该怎么做呢？这篇文章解析了Instagram的功能和架构，从中我们可以看到设计一个内容分享服务所需要关注的部分。原文：Instagram System Architecture&lt;span&gt;[1]&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkYgmP5bxr4BnkLICz0NUnl4VBFperNf5840Gib4iclwqJlZpJXRvNRhfw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;625&quot;/&gt;&lt;/p&gt;&lt;p&gt;Instagram是一个免费的照片和视频分享社交网络，有很多人每天在上面分享故事，记录生活中的点点滴滴。&lt;/p&gt;&lt;h4&gt;功能性需求&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;用户可以上传照片和视频&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户可以查看照片和视频&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户可以根据照片标题进行搜索&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户可以关注/取消关注其他用户&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户可以通过搜索栏搜索用户id&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;为关注的每个用户创建信息流&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可以把照片存档&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可以通过聊天窗口分享故事&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可以拉黑/限制其他用户&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可以在其他用户的帖子下面点赞和评论&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户可以发帖&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3376436781609196&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkxPNuKGbw5bc0hnkw1WX5oOCR00X71lOO90RjicEDX8hkZnwv6p8P1Rg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;696&quot;/&gt;&lt;/p&gt;&lt;h4&gt;非功能性需求&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;高可扩展性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;高一致性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;高可用性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;高可靠性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户数据应该是持久化的（任何上传的照片都不应该丢失）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;生成信息流的最大延迟是150毫秒&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;接下来我们做一下&lt;span&gt;系统容量估算&lt;/span&gt;。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;假设注册用户 = 5亿&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;30%的活跃用户 = 1.5亿&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;注册名人人数 = 10k&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;读请求数 = 100 *上传(写)请求数&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;高峰时刻，假设平均流量 = X，目标处理上限是6X&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;活跃用户：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;每周发帖3次，每个帖子包含1 MB的图片和文本&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每个帖子至少收到10个赞和2-3条评论&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;关注100个用户，有50个粉丝&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每天刷新2次信息流&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;名人：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;每周发帖2次，每个帖子包含大于500K的图片和文本&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每个帖子至少收到50K个赞和至少1K条评论&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;拥有500万粉丝&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每天刷新2次信息流&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;每秒请求数（QPS）：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;发帖&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;点赞&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;评论&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;关注信息流&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;5&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;数据量&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;64base([‘a-z’,‘A-Z’,‘0–9’,‘-’,‘_’])编码的user_id，需要5 bits ~ 1Byte&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;500 Million + 10K * 5 bits ~ 1 Byte = 1G user&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;容量估计：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;每天上传的活跃用户 = 100万&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每天上传的照片 = 500万张&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每天每秒上传的照片 = 57张照片&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;平均照片大小 = 150 KB&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每天存储开销 = 500万* 150KB = 716GB&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据保存10年，所需存储容量为716 GB * 365 * 10年 = 2553 TB ≈ 2.6 PB&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;日活跃用户查看 = 1000万&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每小时的信息流产生量为1000万，即2800 RPS(每秒请求数)。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果用户每天搜索一次，那就是每天1000万次搜索，也就是115个RPS。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;hr/&gt;&lt;h4&gt;系统组件设计&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5037878787878788&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkRqLeUR9ibkSsicLALrdzWxPibBEwFZpoO3To17RyL8M7xLScsF6z8wYHg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;528&quot;/&gt;&lt;/p&gt;&lt;p&gt;因此，更好的方法是用2个数据库分别处理读写操作。此外，分离照片的读写请求可以帮助我们独立的扩展和优化每个过程。下图显示了读写的过程。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44567219152854515&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkFZicQrFia4cTpvm6ZdicUPOxBKZoiatFVFLZd8NMpPibUroo4BGaAtyeRicQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;543&quot;/&gt;&lt;/p&gt;&lt;h5&gt;1. 信息流生成服务（News Feed Generation services）&lt;/h5&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;为用户更新所关注的用户的最新帖子&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每个用户的信息流都是独一无二的，组合非常复杂&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;为了生成新的信息流，系统必须获取这些照片的元数据(喜欢、评论、时间、位置等)，并将其传递给排名算法，以决定哪些照片应该根据元数据安排在信息流中&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;后端需要同时查询大量的表，然后使用预定义的参数对它们进行排序，这种方法将导致更高的延迟，需要大量的时间来生成新的信息流&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;因此，可以采用预生成的信息流。创建专门用于生成每个用户独有信息流的服务器，并将其结果存储在单独的信息流表中。当用户点击更新时，直接从数据库中读取信息流并显示给用户。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5&gt;2. 提供信息流（Serving the News Feed）&lt;/h5&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;推模式（Push）&lt;/span&gt; — 当用户上传了新的照片/视频，他/她的所有粉丝都会获得更新。如果用户关注了很多人或名人，服务器就必须非常频繁的向用户推送更新。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;拉模式（Pull）&lt;/span&gt; — 用户主动刷新他们的信息流(向服务器发出一个拉取请求)。在用户刷新之前，新帖子是不可见的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;混合模式（Hybrid Approach）&lt;/span&gt; — 对拥有大量粉丝的名人用户应用拉模式，普通用户采用推模式。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5&gt;3. 负载均衡（Load Balancing）&lt;/h5&gt;&lt;hr/&gt;&lt;h4&gt;数据架构&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4835294117647059&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkicf91n5kVWlM88ia8S5o3a8UMHtlns0h4Bzl1hicJ1E5kns3GSiaatkAZA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;h5&gt;数据库设计&lt;/h5&gt;&lt;p&gt;&lt;span&gt;1. 用户相关数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 照片相关数据（AWS S3）&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;photo id&lt;/span&gt;（主键）：10字节长度的唯一照片id，用于标识每一张照片&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;UserId&lt;/span&gt;：上传照片的用户id&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Path&lt;/span&gt;：存放照片的对象存储路径/URL&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Latitude &amp;amp; Longitude（纬度和经度）&lt;/span&gt;：存储这些信息来找到照片的位置&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Date &amp;amp; time（日期和时间）&lt;/span&gt;：照片上传的日期和时间戳&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49335548172757476&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkze1bEqtBwAlOkML5cB0ff043F7sNy6x5HeILZZe1XyEFf6sLhKmuKA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;602&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. 用户关注和粉丝相关数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5905882352941176&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkoyXKHeAqXXNK804hsXVGNPBxqiclo1TCS8FJVRkOeL68TMpETSBy6ibw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;425&quot;/&gt;&lt;/p&gt;&lt;p&gt;因此，我们需要两种不同的数据库：&lt;br/&gt;1）关系型数据库（MySQL）&lt;br/&gt;2）NoSQL数据库（Cassandra）&lt;/p&gt;&lt;h5&gt;数据模型&lt;/h5&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24142857142857144&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkDhicUtj3Myl2Lycy0TvLJpVZpanv2ZzcfLGEEwxRicvibqPA6aJsmPhLw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1742857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkmZgdic3I84RsRnL0gQTbYdAkUlyoaks1whI3K9icb1ME9kzR9zeWr71A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.82&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkMcVTo5uDlwpPDZIhyj7s8zBHrdyLjKVoqQW2dtmmGKxMuqaziaB2N4Q/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7171428571428572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkU0pbsqT36wocwcICLeic6miaSmlOExBjcfGTKPHkcMpDicibgIKqvoLyJA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;典型查询&lt;/span&gt;：&lt;/p&gt;&lt;hr/&gt;&lt;h4&gt;接口/API&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;create_post(user_id, image, text, timestamp) -&amp;gt; success/failure&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;comment_post(user_id, post_id, comment, timestamp) -&amp;gt; success/failure&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;like_post(user_id, post_id, timestamp) -&amp;gt; success/failure&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;get_follow_feed(user_id, timestamp) -&amp;gt; list of newest posts from user follow list, ordered by time, limit 20&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;get_profile_feed(user_id, user2_id, timestamp) -&amp;gt; list of newest posts from user2, ordered by time, limit 20&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;hr/&gt;&lt;h4&gt;系统架构&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3514285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkTLTERrvjwxBC5eSCMu0XCRo7D3J5FiccFWJ3Kian8b2qdIUCdXlWVZKA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7114285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkiaXgIodH7DiaYyjntqn5Q6bWoho6jJ1KjRs0AltnJ75wR28flm4URWGw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发帖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5571428571428572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkBBSUSLfHG9ZhBA9icRM2AH0G5jCmnHpzK9iblo0jUHZuIzL4kydt9IYw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;信息流&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3585714285714286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkJCnpgt4242jCVAyIVCJr6RPV9Y0zfQrTQrSKW982lP9iaN1ZiaWqMVxw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进一步细化&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发帖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6928571428571428&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkCXZXTTIBtUfVCpbAqdljDZd0HHIp5YVD9K9LLxQjRoRDCl7al1ysMg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;信息流&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4514285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkOx9dpib3C2kFZXqCeRV9DcoQLc9Fq4ZtDRb2ib3hG9roHDpbNr9zw6hg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8485714285714285&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkp3ic6DbUU4PE5sBfPGYnRzkdEmma1pQgjAm2WBBsrenU8OwHBTbKQ2g/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6728571428571428&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkuKnTFebwY06gicf4z7GcfO117v7LqHVtYJc3yh9ulPPcjOf2nia1ib2HQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9557142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnk1slyVp0NO6ZOwa0yTkU6ibl2EnxYxp41G4TchpKHxA7baDJ02GetxJg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;hr/&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;延伸阅读：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Instagram Engineering: https://medium.com/@InstagramEng&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Instagram System Design: https://youtu.be/da7mdMz0g0g&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Designing Instagram: https://www.educative.io/courses/grokking-the-system-design-interview/m2yDVZnQ8lG&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Design Photo Sharing Platform - Instagram: https://techtakshila.com/system-design-interview/chapter-4/&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Designing Instagram: https://www.codercrunch.com/design/634265/designing-instagram&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Designing Instagram Architecture: https://nlogn.in/designing-instagram-architecture-system-design/&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;System Design Analysis of Instagram: https://towardsdatascience.com/system-design-analysis-of-instagram-51cd25093971&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;References:&lt;/span&gt;&lt;br/&gt;[1] Instagram System Architecture: https://medium.com/interviewnoodle/instagram-system-architecture-fdbec22e48ee&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。&lt;br/&gt;微信公众号：DeepNoMind&lt;/p&gt;&lt;/blockquote&gt;&lt;/article&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c23d048cdaa3a668d501f399e25bacf1</guid>
<title>[推荐] 再见了 VMware，一款更轻量级的虚拟机！</title>
<link>https://toutiao.io/k/xw2lnva</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;pre&gt;&lt;section class=&quot;js_darkmode__1&quot;&gt;&lt;span&gt;公众号关注&lt;/span&gt;&lt;span&gt; “GitHubDaily”&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;设为 “&lt;/span&gt;&lt;span&gt;星标&lt;/span&gt;&lt;span&gt;”，每天带你逛 GitHub！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcs8C07b1Ih2doNmiaicSttMccejE1onYNcszau24r6lIzHr6Fib3XlicibHcg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;大家好，我是小 G。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近，打算在 &lt;/span&gt;&lt;strong&gt;Mac&lt;/strong&gt;&lt;span&gt; 电脑上安装一个虚拟机，用来学习 &lt;/span&gt;&lt;strong&gt;K8S&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;首先想到的是 &lt;strong&gt;Vmware&lt;/strong&gt; 和 &lt;strong&gt;Parallels Desktop&lt;/strong&gt;，然后打开浏览器找了找，发现都只提供付费版本，只有 &lt;strong&gt;Parallels Desktop&lt;/strong&gt; 提供了 &lt;strong&gt;14&lt;/strong&gt; 天的免费试用。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsCKOCmkQFvjvr9uqCL45fUVicA4uFf5iaNiaicY6kcTXK9rxfOWicwicWwh4Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot; title=&quot;无法白嫖&quot;/&gt;&lt;figcaption&gt;无法白嫖&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;然后，开始尝试使用免费 &lt;strong&gt;VirtualBox&lt;/strong&gt;，但是在安装 &lt;strong&gt;CentOS&lt;/strong&gt; 的时候，貌似因为 &lt;strong&gt;MacOS&lt;/strong&gt; 最新版本的原因，总是报错，花费了好几天的时间，试过各种方案，最终解决无果，就放弃了。。&lt;/p&gt;&lt;p&gt;就在陌溪要放弃的时候，突然在 &lt;strong&gt;Ubuntu&lt;/strong&gt; 官网进行冲浪的时候，发现了一款叫 &lt;strong&gt;Multipass&lt;/strong&gt; 的东西。&lt;/p&gt;&lt;p&gt;它可以快速在电脑上快速搭建一个轻量级的虚拟机，并且相比于 &lt;strong&gt;Vmware&lt;/strong&gt; 更加轻量，只需一行命令快速创建 &lt;strong&gt;Ubuntu&lt;/strong&gt; 虚拟机。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Multipass&lt;/strong&gt; 是一个轻量虚拟机管理器，是由 &lt;strong&gt;Ubuntu&lt;/strong&gt; 运营公司 &lt;strong&gt;Canonical&lt;/strong&gt; 所推出的开源项目。运行环境支持 &lt;strong&gt;Linux&lt;/strong&gt;、&lt;strong&gt;Windows&lt;/strong&gt;、&lt;strong&gt;macOS&lt;/strong&gt;。在不同的操作系统上，使用的是不同的虚拟化技术。在 &lt;strong&gt;Linux&lt;/strong&gt; 上使用的是 &lt;strong&gt;KVM&lt;/strong&gt;、&lt;strong&gt;Window&lt;/strong&gt; 上使用 &lt;strong&gt;Hyper-V&lt;/strong&gt;、&lt;strong&gt;macOS&lt;/strong&gt; 中使用 &lt;strong&gt;HyperKit&lt;/strong&gt; 以最小开销运行VM，支持在笔记本模拟小型云。&lt;/p&gt;&lt;p&gt;同时，&lt;strong&gt;Multipass&lt;/strong&gt; 提供了一个命令行界面来启动和管理 &lt;strong&gt;Linux&lt;/strong&gt; 实例。下载一个全新的镜像需要几秒钟的时间，并且在几分钟内就可以启动并运行 &lt;strong&gt;VM&lt;/strong&gt;。（直呼好家伙，大大降低的我们安装虚拟机的成本了）&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Multipass官网：https://multipass.run/&lt;/p&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5435185185185185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsQ45NQiaofsON9YRJTedbwFRuqjGRIxDJ3icaxa7jicJRXoxrI4iapRSyGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;Multipass官网&quot;/&gt;&lt;figcaption&gt;Multipass官网&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;span&gt;开始使用&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在使用 &lt;strong&gt;Multipass&lt;/strong&gt; 之前 ，首先需要安装 &lt;strong&gt;Multipass&lt;/strong&gt; 工具，可以打开官网进行下载&lt;/p&gt;&lt;pre&gt;&lt;code&gt;https:&lt;span&gt;//multipass.run/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;选择对应的操作系统，因为我的是 &lt;strong&gt;Mac&lt;/strong&gt; 电脑，所以选择 MacOS，点击 &lt;strong&gt;Download&lt;/strong&gt; 开始下载&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36018518518518516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsw2biaGewZU8V4TKK2tE67EnX91WqwFBhLu1lbMewrialrl419NIdwfIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;image-20211120120019913&quot;/&gt;&lt;figcaption&gt;选择对应版本安装&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如果电脑装了 &lt;strong&gt;brew&lt;/strong&gt; 可以直接命令行下载安装:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;brew&lt;/span&gt; cask install multipass&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下载安装成功后, 执行以下命令可以查看当前软件版本:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; --version&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装成功后，点击运行，即可打开 &lt;strong&gt;Multipass&lt;/strong&gt; 客户端，这里能够快速的通过 &lt;strong&gt;Open Shell&lt;/strong&gt; 创建和启动一个虚拟机&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7735849056603774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcs8hqCKQmRFhia7ic3pgBhtL2gd9M55Rf0Gib3icFE6YeqZ28P2b7hiaNyf5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;424&quot; title=&quot;Multipass客户端&quot;/&gt;&lt;figcaption&gt;Multipass客户端&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;下面，我们来介绍如何通过命令的方式，创建一台虚拟机&lt;/p&gt;&lt;h2&gt;&lt;span&gt;创建Ubuntu虚拟机&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;首先，通过以下指令查看可供下载的 &lt;strong&gt;Ubuntu&lt;/strong&gt; 镜像&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; find&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行成功后，可以看到下面的这些镜像列表，包含各种版本的&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;Image&lt;/span&gt;                       &lt;span&gt;Aliases&lt;/span&gt;           &lt;span&gt;Version&lt;/span&gt;          &lt;span&gt;Description&lt;/span&gt;&lt;br/&gt;&lt;span&gt;core&lt;/span&gt;                        &lt;span&gt;core16&lt;/span&gt;            20200818         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Core&lt;/span&gt; 16&lt;br/&gt;&lt;span&gt;core18&lt;/span&gt;                                        20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Core&lt;/span&gt; 18&lt;br/&gt;18&lt;span&gt;.04&lt;/span&gt;                       &lt;span&gt;bionic&lt;/span&gt;            20211109         &lt;span&gt;Ubuntu&lt;/span&gt; 18&lt;span&gt;.04&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;&lt;br/&gt;20&lt;span&gt;.04&lt;/span&gt;                       &lt;span&gt;focal&lt;/span&gt;,&lt;span&gt;lts&lt;/span&gt;         20211118         &lt;span&gt;Ubuntu&lt;/span&gt; 20&lt;span&gt;.04&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;&lt;br/&gt;21&lt;span&gt;.04&lt;/span&gt;                       &lt;span&gt;hirsute&lt;/span&gt;           20211119         &lt;span&gt;Ubuntu&lt;/span&gt; 21&lt;span&gt;.04&lt;/span&gt;&lt;br/&gt;21&lt;span&gt;.10&lt;/span&gt;                       &lt;span&gt;impish&lt;/span&gt;            20211103         &lt;span&gt;Ubuntu&lt;/span&gt; 21&lt;span&gt;.10&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:adguard-home&lt;/span&gt;                        20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;AdGuard&lt;/span&gt; &lt;span&gt;Home&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:mosquitto&lt;/span&gt;                           20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Mosquitto&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:nextcloud&lt;/span&gt;                           20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Nextcloud&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:openhab&lt;/span&gt;                             20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;openHAB&lt;/span&gt; &lt;span&gt;Home&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:plexmediaserver&lt;/span&gt;                     20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Plex&lt;/span&gt; &lt;span&gt;Media&lt;/span&gt; &lt;span&gt;Server&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;anbox-cloud-appliance&lt;/span&gt;                         &lt;span&gt;latest&lt;/span&gt;           &lt;span&gt;Anbox&lt;/span&gt; &lt;span&gt;Cloud&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;minikube&lt;/span&gt;                                      &lt;span&gt;latest&lt;/span&gt;           &lt;span&gt;minikube&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; &lt;span&gt;Kubernetes&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下载最新版的 &lt;strong&gt;Ubuntu&lt;/strong&gt; 镜像并运行，初次创建时需要下载 &lt;strong&gt;Ubuntu&lt;/strong&gt; 镜像，网络畅通的情况下，稍等片刻即可。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; launch -n vm01 -c &lt;span&gt;1&lt;/span&gt; -m &lt;span&gt;1G&lt;/span&gt; -d &lt;span&gt;10G&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;自定义配置创建可以参考如下方式:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;-n, --name: 名称&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-c, --cpus: cpu核心数, 默认: 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-m, --mem: 内存大小, 默认: 1G&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-d, --disk: 硬盘大小, 默认: 5G&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;操作虚拟机&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;查看虚拟机列表&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;虚拟机创建完成后，可以使用 &lt;strong&gt;multipass list&lt;/strong&gt; 命令进行查看虚拟机列表&lt;/p&gt;&lt;pre&gt;&lt;code&gt;% &lt;span&gt;multipass&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Name&lt;/span&gt;                    &lt;span&gt;State&lt;/span&gt;             &lt;span&gt;IPv4&lt;/span&gt;             &lt;span&gt;Image&lt;/span&gt;&lt;br/&gt;&lt;span&gt;vm01&lt;/span&gt;                    &lt;span&gt;Running&lt;/span&gt;           192&lt;span&gt;.168.64.2&lt;/span&gt;     &lt;span&gt;Ubuntu&lt;/span&gt; 20&lt;span&gt;.04&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到目前正在运行一台 &lt;strong&gt;Ubuntu 20.04&lt;/strong&gt; 版本的虚拟机，并且对应的 &lt;strong&gt;IP&lt;/strong&gt; 地址为 &lt;strong&gt;192.168.64.2&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;外部操作虚拟机&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;通过 &lt;strong&gt;multipass exec&lt;/strong&gt; 命令在实例内执行给定的命令。第一个参数是运行命令的实例，也就是 &lt;strong&gt;vm01&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们通过 &lt;strong&gt;exec&lt;/strong&gt; 命令，就可以在外部操作刚刚创建的虚拟机，例如查看内部所处的目录，执行 &lt;strong&gt;pwd&lt;/strong&gt; 命令&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; multipass &lt;span&gt;exec&lt;/span&gt; vm01 &lt;span&gt;pwd&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;/home/ubuntu&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;查看虚拟机信息&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;通过 &lt;strong&gt;multipass info&lt;/strong&gt; 命令，即可查看当前运行的虚拟机信息&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# &lt;span&gt;multipass&lt;/span&gt; &lt;span&gt;info&lt;/span&gt; &lt;span&gt;vm01&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Name&lt;/span&gt;:           &lt;span&gt;vm01&lt;/span&gt;&lt;br/&gt;&lt;span&gt;State&lt;/span&gt;:          &lt;span&gt;Running&lt;/span&gt;&lt;br/&gt;&lt;span&gt;IPv4&lt;/span&gt;:           192&lt;span&gt;.168.64.2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Release&lt;/span&gt;:        &lt;span&gt;Ubuntu&lt;/span&gt; 20&lt;span&gt;.04.3&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Image&lt;/span&gt; &lt;span&gt;hash&lt;/span&gt;:     91740&lt;span&gt;d72ffff&lt;/span&gt; (&lt;span&gt;Ubuntu&lt;/span&gt; 20&lt;span&gt;.04&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;Load&lt;/span&gt;:           0&lt;span&gt;.00&lt;/span&gt; 0&lt;span&gt;.00&lt;/span&gt; 0&lt;span&gt;.00&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Disk&lt;/span&gt; &lt;span&gt;usage&lt;/span&gt;:     1&lt;span&gt;.3G&lt;/span&gt; &lt;span&gt;out&lt;/span&gt; &lt;span&gt;of&lt;/span&gt; 9&lt;span&gt;.5G&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Memory&lt;/span&gt; &lt;span&gt;usage&lt;/span&gt;:   170&lt;span&gt;.9M&lt;/span&gt; &lt;span&gt;out&lt;/span&gt; &lt;span&gt;of&lt;/span&gt; 1&lt;span&gt;.9G&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Mounts&lt;/span&gt;:         &lt;span&gt;--&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;进入虚拟机&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;通过 &lt;strong&gt;multipass shell&lt;/strong&gt; 命令，即可进入到虚拟机内部&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; shell vm01&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行后的结果如下所示，可以看到目前虚拟机的一些系统配置信息，以及内存和磁盘的使用情况&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7129629629629629&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcskVp6KUe7Mm9HbLT6dmUhJzpnabyPt7rKHAbulLKO6ib1UUMNrsN0xXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;image-20211121085114961&quot;/&gt;&lt;figcaption&gt;进入虚拟机内部&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;同时会运行一个新的 &lt;strong&gt;Ubuntu&lt;/strong&gt; 系统，此时便进入到了&lt;strong&gt;Ubuntu&lt;/strong&gt; 环境中, 在里面可以执行相关的 &lt;strong&gt;linux&lt;/strong&gt; 指令&lt;/p&gt;&lt;p&gt;当然如果不想进入系统内部，也可以通过上述提到的 &lt;strong&gt;multipass exce&lt;/strong&gt; 命令，来操作 &lt;strong&gt;Ubuntu&lt;/strong&gt; 系统&lt;/p&gt;&lt;p&gt;首先执行下面命令，给系统设置一个 &lt;strong&gt;root&lt;/strong&gt; 密码，设置好密码后，使用 &lt;strong&gt;su root&lt;/strong&gt; 切换到 &lt;strong&gt;root&lt;/strong&gt; 用户&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 设置密码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;sudo&lt;/span&gt; passwd&lt;br/&gt;&lt;span&gt;# 切换 root&lt;/span&gt;&lt;br/&gt;su root&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;ubuntu&lt;/strong&gt; 是使用 &lt;strong&gt;apt-get&lt;/strong&gt; 来进行包管理的，首先更新一下 &lt;strong&gt;apt-get&lt;/strong&gt;，然后安装 &lt;strong&gt;nginx&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 更新apt&lt;/span&gt;&lt;br/&gt;apt-get &lt;span&gt;update&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 安装 nginx&lt;/span&gt;&lt;br/&gt;apt-&lt;span&gt;get&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; nginx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装好 &lt;strong&gt;nginx&lt;/strong&gt; 后，可以到 /etc/nginx 目录即可看到刚刚的 &lt;strong&gt;nginx&lt;/strong&gt; 配置信息&lt;/p&gt;&lt;pre&gt;&lt;code&gt;root@vm01&lt;span&gt;:/lost+found&lt;/span&gt;&lt;span&gt;# cd /etc/nginx/&lt;/span&gt;&lt;br/&gt;root@vm01&lt;span&gt;:/etc/nginx&lt;/span&gt;&lt;span&gt;# ls&lt;/span&gt;&lt;br/&gt;conf.d        fastcgi_params  koi-win     modules-available  nginx.conf    scgi_params      sites-enabled  uwsgi_params&lt;br/&gt;fastcgi.conf  koi-utf         mime.types  modules-enabled    proxy_params  sites-available  snippets       win-utf&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面我们可以测试一下，&lt;strong&gt;nginx&lt;/strong&gt; 是否安装成功，在 &lt;strong&gt;mac&lt;/strong&gt; 上打开浏览器，输入虚拟机的 &lt;strong&gt;ip&lt;/strong&gt; 地址 &lt;strong&gt;192.168.64.2&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2759259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsUBdjGbOeCEodmicmTpQIYIe9oBNlhExhKudlB5HqryPI1YeAa5UKvGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;image-20211121094727506&quot;/&gt;&lt;figcaption&gt;nginx安装成功&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;可以看出，目前 &lt;strong&gt;nginx&lt;/strong&gt; 已经成功运行了，后续的话，可能会考虑在上面部署更多的应用，感兴趣的小伙伴欢迎关注～&lt;/p&gt;&lt;h3&gt;&lt;span&gt;挂载数据卷&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;multipass&lt;/strong&gt; 还提供和 &lt;strong&gt;Docker&lt;/strong&gt; 一样的挂载数据卷的功能，能够与外部宿主机的文件保持同步。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 挂载格式&lt;/span&gt;&lt;br/&gt;&lt;span&gt;multipass&lt;/span&gt; mount 宿主机目录  实例名:虚拟机目录&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面，我在用户的目录下，创建一个 &lt;strong&gt;hello&lt;/strong&gt; 目录&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 创建hello目录&lt;/span&gt;&lt;br/&gt;&lt;span&gt;mkdir&lt;/span&gt; hello&lt;br/&gt;&lt;span&gt;# 挂载&lt;/span&gt;&lt;br/&gt;multipass mount /Users/moxi/hello  vm01:/hello&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;挂载完成后，我们回到实例 vm01 中，可以看出多了一个 &lt;strong&gt;hello&lt;/strong&gt; 文件夹，说明已经成功挂载～&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18181818181818182&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsWKnic6p04c1vu5iaTib7bziaz2iaZwXCZutNm18U6wng3t7ljIBUldLHiayA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;528&quot; title=&quot;image-20211121110217283&quot;/&gt;&lt;figcaption&gt;挂载成功&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;因此，以后在 &lt;strong&gt;vm01&lt;/strong&gt; 的 &lt;strong&gt;hello文件夹&lt;/strong&gt; 中创建的文件，都会在的宿主机的 &lt;strong&gt;hello 文件夹&lt;/strong&gt;同步显示&lt;/p&gt;&lt;h3&gt;&lt;span&gt;卸载数据卷&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;如果以后不需要用到挂载了，可以使用 &lt;strong&gt;unmount&lt;/strong&gt; 命令卸载&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#卸载数据卷&lt;/span&gt;&lt;br/&gt;&lt;span&gt;multipass&lt;/span&gt; umount 容器名&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;传输文件&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;除了使用上述的 &lt;strong&gt;mount&lt;/strong&gt; 挂载卷的方式实现文件的交互，同时还可以通过 transfer 命令，将宿主机的文件，发送到虚拟机内部&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; transfer 主机文件 容器名:容器目录&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如，将 &lt;strong&gt;hello.txt&lt;/strong&gt; 发送到&lt;/p&gt;&lt;pre&gt;&lt;code&gt;multipass transfer hello.txt vm01:&lt;span&gt;/home/ubuntu/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;删除和释放实例&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;使用下面的命令，可以开启、停止、删除和释放实例&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 启动实例&lt;/span&gt;&lt;br/&gt;multipass &lt;span&gt;start&lt;/span&gt; vm01&lt;br/&gt;&lt;span&gt;# 停止实例&lt;/span&gt;&lt;br/&gt;multipass &lt;span&gt;stop&lt;/span&gt; vm01&lt;br/&gt;&lt;span&gt;# 删除实例（删除后，还会存在）&lt;/span&gt;&lt;br/&gt;multipass &lt;span&gt;delete&lt;/span&gt; vm01&lt;br/&gt;&lt;span&gt;# 释放实例（彻底删除）&lt;/span&gt;&lt;br/&gt;multipass &lt;span&gt;purge&lt;/span&gt; vm01&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;容器配置自动化&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;为了保持开发环境和线上环境一致性 同时节省部署时间 &lt;strong&gt;multipass&lt;/strong&gt; 给我们提供了 &lt;strong&gt;--cloud-init&lt;/strong&gt; 选项进行容器启动初始化配置:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; &lt;span&gt;launch&lt;/span&gt; &lt;span&gt;--name&lt;/span&gt; &lt;span&gt;ubuntu&lt;/span&gt; &lt;span&gt;--cloud-init&lt;/span&gt; &lt;span&gt;config&lt;/span&gt;&lt;span&gt;.yaml&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面 &lt;strong&gt;config.yaml&lt;/strong&gt; 则是容器的初始化配置文件，例如，我们想在初始化容器的时候，自动下载安装 &lt;strong&gt;Node.js&lt;/strong&gt;，内容如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#cloud-config&lt;/span&gt;&lt;br/&gt;runcmd:&lt;br/&gt;  - curl -sL https:&lt;span&gt;//deb.nodesource.com/setup_12.x | sudo -E bash -&lt;/span&gt;&lt;br/&gt;  - sudo apt-&lt;span&gt;get&lt;/span&gt; install -y nodejs&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;runcmd&lt;/code&gt; 可以指定容器 &lt;strong&gt;首次启动&lt;/strong&gt; 时运行的命令&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;凡是用户自定义的cloud-init的配置文件,必须以#cloud-config开头，这是cloud-init识别它的方式。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;yaml&lt;/strong&gt; 配置文件可以参考下面的文章&lt;/p&gt;&lt;pre&gt;&lt;code&gt;https://cloudinit.readthedocs.io/en/latest/topics/examples.html?highlight=&lt;span&gt;lock&lt;/span&gt;-passwd&lt;span&gt;#including-users-and-groups&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更多关于 &lt;strong&gt;multipass&lt;/strong&gt; 的高阶的技巧，欢迎访问 &lt;strong&gt;multipass&lt;/strong&gt; 官方文档&lt;/p&gt;&lt;pre&gt;&lt;code&gt;https:&lt;span&gt;//m&lt;/span&gt;ultipass.run&lt;span&gt;/docs/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;好了，本期关于 &lt;strong&gt;Multipass&lt;/strong&gt; 的基础学习就到这里了，感兴趣的小伙伴环境下载自己动手学习呢～&lt;/p&gt;&lt;h2&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;使用了一阵子后，&lt;strong&gt;Multipass&lt;/strong&gt; 在使用起来很简洁直观，在整体操作上和 &lt;strong&gt;docker&lt;/strong&gt; 类似，如果想在自己电脑上快速搭建一个 &lt;strong&gt;Linux&lt;/strong&gt; 系统用于学习的话，选择使用 &lt;strong&gt;Multipass&lt;/strong&gt; 还是非常方便的。&lt;/p&gt;&lt;p&gt;唯一不足的地方就是，&lt;strong&gt;Multipass&lt;/strong&gt; 是由 &lt;strong&gt;Ubuntu&lt;/strong&gt; 背后的 &lt;strong&gt;Canonical&lt;/strong&gt; 公司开发的，因此 &lt;strong&gt;Multipass&lt;/strong&gt; 所使用的镜像也都是 &lt;strong&gt;Ubuntu&lt;/strong&gt; 镜像（这也可以理解，毕竟支持自家的产品），不过对于习惯了使用 &lt;strong&gt;CentOS&lt;/strong&gt; 的用户来说，还是用些许不太习惯。&lt;/p&gt;&lt;p&gt;不过瑕不掩瑜，&lt;strong&gt;Multipass&lt;/strong&gt; 在我看来还是一款非常棒的软件～&lt;/p&gt;&lt;p&gt;另外，它的代码也在 GitHub 开源了，需要进一步研究的小伙伴也可以看下：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;GitHub：https://github.com/canonical/multipass&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAxOTcxNTIwNQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28ia8xsyOClt8NDDCTAZNaDsEic4EEpUG1FPduFr5TUMK1GbDiaFX0qNCJiaS2XPfHzWlFicK95v1a9ic7Vg/0?wx_fmt=png&quot; data-nickname=&quot;GitHubDaily&quot; data-alias=&quot;GitHubDaily&quot; data-signature=&quot;专注于分享 GitHub 上知名的 Python、Java、Web、AI、数据分析等多个领域的优质学习资源、开源项目及开发者工具，为 GitHub 开发者提供优质编程资讯。&quot; data-from=&quot;0&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c6958515e606acc952427f125467dc6a</guid>
<title>[推荐] JVM调优的几种场景（建议收藏）</title>
<link>https://toutiao.io/k/0mfx2nd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;大家好，我是冰河~~&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近很多小伙伴跟我说，自己学了不少JVM的调优知识，但是在实际工作中却不知道何时对JVM进行调优。今天，冰河就为大家介绍几种JVM调优的场景。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg4MjU0OTM1OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwGzljlbsOzVRib0A41LgChOaWdo7OSYAl43icUjIdMIicibjljZNvVGSZ7s7E95lAQf6k1q5AvGMZFoJQ/0?wx_fmt=png&quot; data-nickname=&quot;冰河技术&quot; data-alias=&quot;hacker-binghe&quot; data-signature=&quot;分享各种编程语言、开发技术、分布式与微服务架构、分布式数据库、分布式事务、云原生、大数据与云计算技术和渗透技术。另外，还会分享各种面试题和面试技巧。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;点击上方卡片关注我&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在阅读本文时，冰河假定大家已经了解了运行时的数据区域和常用的垃圾回收算法，也了解了Hotspot支持的垃圾回收器。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;cpu占用过高&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cpu占用过高要分情况讨论，是不是业务上在搞活动，突然有大批的流量进来，而且活动结束后cpu占用率就下降了，如果是这种情况其实可以不用太关心，因为请求越多，需要处理的线程数越多，这是正常的现象。话说回来，如果你的服务器配置本身就差，cpu也只有一个核心，这种情况，稍微多一点流量就真的能够把你的cpu资源耗尽，这时应该考虑先把配置提升吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二种情况，cpu占用率&lt;strong&gt;长期过高&lt;/strong&gt;，这种情况下可能是你的程序有那种循环次数超级多的代码，甚至是出现死循环了。排查步骤如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）用top命令查看cpu占用情况&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2616580310880829&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwHbzcdlXpjOX5mgMoHdSnWooq05hR8mqwpicaEl0HrteUDMfE7AWnBPRNzrtK5wYeTiaGp8J5Micn8CQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1158&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就可以定位出cpu过高的进程。在linux下，top命令获得的进程号和jps工具获得的vmid是相同的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.075809199318569&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwHbzcdlXpjOX5mgMoHdSnWornbuib9ANC4kPwxibWCmKWxD14z3CplafMLFxkX8icsUzaz8RPSq9wL2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1174&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）用top -Hp命令查看线程的情况&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6779359430604982&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwHbzcdlXpjOX5mgMoHdSnWoCIoucEaHuJJst2XCl9y0cTkCGM4IzSeswBBwzRjXbW6oCID2ibAAr2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1124&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到是线程id为7287这个线程一直在占用cpu&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（3）把线程号转换为16进制&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[root@localhost ~]# printf &quot;%x&quot; 7287&lt;br/&gt;1c77&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记下这个16进制的数字，下面我们要用&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（4）用jstack工具查看线程栈情况&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[root@localhost ~]# jstack 7268 | grep 1c77 -A 10&lt;br/&gt;&quot;http-nio-8080-exec-2&quot; #16 daemon prio=5 os_prio=0 tid=0x00007fb66ce81000 nid=0x1c77 runnable [0x00007fb639ab9000]&lt;br/&gt;   java.lang.Thread.State: RUNNABLE&lt;br/&gt; at com.spareyaya.jvm.service.EndlessLoopService.service(EndlessLoopService.java:19)&lt;br/&gt; at com.spareyaya.jvm.controller.JVMController.endlessLoop(JVMController.java:30)&lt;br/&gt; at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt; at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)&lt;br/&gt; at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&lt;br/&gt; at java.lang.reflect.Method.invoke(Method.java:498)&lt;br/&gt; at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)&lt;br/&gt; at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)&lt;br/&gt; at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过jstack工具输出现在的线程栈，再通过grep命令结合上一步拿到的线程16进制的id定位到这个线程的运行情况，其中jstack后面的7268是第（1）步定位到的进程号，grep后面的是（2）、（3）步定位到的线程号。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从输出结果可以看到这个线程处于运行状态，在执行&lt;code&gt;com.spareyaya.jvm.service.EndlessLoopService.service&lt;/code&gt;这个方法，代码行号是19行，这样就可以去到代码的19行，找到其所在的代码块，看看是不是处于循环中，这样就定位到了问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;死锁&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死锁并没有第一种场景那么明显，web应用肯定是多线程的程序，它服务于多个请求，程序发生死锁后，死锁的线程处于等待状态（WAITING或TIMED_WAITING），等待状态的线程不占用cpu，消耗的内存也很有限，而表现上可能是请求没法进行，最后超时了。在死锁情况不多的时候，这种情况不容易被发现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用jstack工具来查看&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）jps查看java进程&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[root@localhost ~]# jps -l&lt;br/&gt;8737 sun.tools.jps.Jps&lt;br/&gt;8682 jvm-0.0.1-SNAPSHOT.jar&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）jstack查看死锁问题&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于web应用往往会有很多工作线程，特别是在高并发的情况下线程数更多，于是这个命令的输出内容会十分多。jstack最大的好处就是会把产生死锁的信息（包含是什么线程产生的）输出到最后，所以我们只需要看最后的内容就行了&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Java stack information for the threads listed above:&lt;br/&gt;===================================================&lt;br/&gt;&quot;Thread-4&quot;:&lt;br/&gt; at com.spareyaya.jvm.service.DeadLockService.service2(DeadLockService.java:35)&lt;br/&gt; - waiting to lock &amp;lt;0x00000000f5035ae0&amp;gt; (a java.lang.Object)&lt;br/&gt; - locked &amp;lt;0x00000000f5035af0&amp;gt; (a java.lang.Object)&lt;br/&gt; at com.spareyaya.jvm.controller.JVMController.lambda$deadLock$1(JVMController.java:41)&lt;br/&gt; at com.spareyaya.jvm.controller.JVMController$$Lambda$457/1776922136.run(Unknown Source)&lt;br/&gt; at java.lang.Thread.run(Thread.java:748)&lt;br/&gt;&quot;Thread-3&quot;:&lt;br/&gt; at com.spareyaya.jvm.service.DeadLockService.service1(DeadLockService.java:27)&lt;br/&gt; - waiting to lock &amp;lt;0x00000000f5035af0&amp;gt; (a java.lang.Object)&lt;br/&gt; - locked &amp;lt;0x00000000f5035ae0&amp;gt; (a java.lang.Object)&lt;br/&gt; at com.spareyaya.jvm.controller.JVMController.lambda$deadLock$0(JVMController.java:37)&lt;br/&gt; at com.spareyaya.jvm.controller.JVMController$$Lambda$456/474286897.run(Unknown Source)&lt;br/&gt; at java.lang.Thread.run(Thread.java:748)&lt;br/&gt;&lt;br/&gt;Found 1 deadlock.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发现了一个死锁，原因也一目了然。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;内存泄漏&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，java和c++的最大区别是前者会自动收回不再使用的内存，后者需要程序员手动释放。在c++中，如果我们忘记释放内存就会发生内存泄漏。但是，不要以为jvm帮我们回收了内存就不会出现内存泄漏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序发生内存泄漏后，进程的可用内存会慢慢变少，最后的结果就是抛出OOM错误。发生OOM错误后可能会想到是内存不够大，于是把-Xmx参数调大，然后重启应用。这么做的结果就是，过了一段时间后，OOM依然会出现。最后无法再调大最大堆内存了，结果就是只能每隔一段时间重启一下应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存泄漏的另一个可能的表现是请求的响应时间变长了。这是因为频繁发生的GC会暂停其它所有线程（Stop The World）造成的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了模拟这个场景，使用了以下的程序&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.ExecutorService;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.Executors;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Main&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Main main = &lt;span&gt;new&lt;/span&gt; Main();&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;            main.run();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ExecutorService executorService = Executors.newCachedThreadPool();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++) {&lt;br/&gt;            executorService.execute(() -&amp;gt; {&lt;br/&gt;                &lt;span&gt;// do something...&lt;/span&gt;&lt;br/&gt;            });&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行参数是&lt;code&gt;-Xms20m -Xmx20m -XX:+PrintGC&lt;/code&gt;，把可用内存调小一点，并且在发生gc时输出信息，运行结果如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;[GC (Allocation Failure)  12776K-&amp;gt;10840K(18432K), 0.0309510 secs]&lt;br/&gt;[GC (Allocation Failure)  13400K-&amp;gt;11520K(18432K), 0.0333385 secs]&lt;br/&gt;[GC (Allocation Failure)  14080K-&amp;gt;12168K(18432K), 0.0332409 secs]&lt;br/&gt;[GC (Allocation Failure)  14728K-&amp;gt;12832K(18432K), 0.0370435 secs]&lt;br/&gt;[Full GC (Ergonomics)  12832K-&amp;gt;12363K(18432K), 0.1942141 secs]&lt;br/&gt;[Full GC (Ergonomics)  14923K-&amp;gt;12951K(18432K), 0.1607221 secs]&lt;br/&gt;[Full GC (Ergonomics)  15511K-&amp;gt;13542K(18432K), 0.1956311 secs]&lt;br/&gt;...&lt;br/&gt;[Full GC (Ergonomics)  16382K-&amp;gt;16381K(18432K), 0.1734902 secs]&lt;br/&gt;[Full GC (Ergonomics)  16383K-&amp;gt;16383K(18432K), 0.1922607 secs]&lt;br/&gt;[Full GC (Ergonomics)  16383K-&amp;gt;16383K(18432K), 0.1824278 secs]&lt;br/&gt;[Full GC (Allocation Failure)  16383K-&amp;gt;16383K(18432K), 0.1710382 secs]&lt;br/&gt;[Full GC (Ergonomics)  16383K-&amp;gt;16382K(18432K), 0.1829138 secs]&lt;br/&gt;[Full GC (Ergonomics) Exception in thread &quot;main&quot;  16383K-&amp;gt;16382K(18432K), 0.1406222 secs]&lt;br/&gt;[Full GC (Allocation Failure)  16382K-&amp;gt;16382K(18432K), 0.1392928 secs]&lt;br/&gt;[Full GC (Ergonomics)  16383K-&amp;gt;16382K(18432K), 0.1546243 secs]&lt;br/&gt;[Full GC (Ergonomics)  16383K-&amp;gt;16382K(18432K), 0.1755271 secs]&lt;br/&gt;[Full GC (Ergonomics)  16383K-&amp;gt;16382K(18432K), 0.1699080 secs]&lt;br/&gt;[Full GC (Allocation Failure)  16382K-&amp;gt;16382K(18432K), 0.1697982 secs]&lt;br/&gt;[Full GC (Ergonomics)  16383K-&amp;gt;16382K(18432K), 0.1851136 secs]&lt;br/&gt;[Full GC (Allocation Failure)  16382K-&amp;gt;16382K(18432K), 0.1655088 secs]&lt;br/&gt;java.lang.OutOfMemoryError: Java heap space&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到虽然一直在gc，占用的内存却越来越多，说明程序有的对象无法被回收。但是上面的程序对象都是定义在方法内的，属于局部变量，局部变量在方法运行结果后，所引用的对象在gc时应该被回收啊，但是这里明显没有。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了找出到底是哪些对象没能被回收，我们加上运行参数-XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=heap.bin，意思是发生OOM时把堆内存信息dump出来。运行程序直至异常，于是得到heap.dump文件，然后我们借助eclipse的MAT插件来分析，如果没有安装需要先安装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后File-&amp;gt;Open Heap Dump... ，然后选择刚才dump出来的文件，选择Leak Suspects&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5155367231638418&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwHbzcdlXpjOX5mgMoHdSnWoR33SJF7kQD6fTIVRiaicBzicAuibHzoUQ30SWYaZalKiaxibUbRevktuzscQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1416&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MAT会列出所有可能发生内存泄漏的对象&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4652482269503546&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwHbzcdlXpjOX5mgMoHdSnWo9pO3JhOZchmHylpvPwX0vG78hpoSrku9Xb1QdLDejfVkEolwmsFzQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1410&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到居然有21260个Thread对象，3386个ThreadPoolExecutor对象，如果你去看一下&lt;code&gt;java.util.concurrent.ThreadPoolExecutor&lt;/code&gt;的源码，可以发现线程池为了复用线程，会不断地等待新的任务，线程也不会回收，需要调用其shutdown方法才能让线程池执行完任务后停止。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实线程池定义成局部变量，好的做法是设置成单例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;上面只是其中一种处理方法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在线上的应用，内存往往会设置得很大，这样发生OOM再把内存快照dump出来的文件就会很大，可能大到在本地的电脑中已经无法分析了（因为内存不足够打开这个dump文件）。这里介绍另一种处理办法：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）用jps定位到进程号&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;C:\Users\spareyaya\IdeaProjects\maven-project\target\classes\org\example\net&amp;gt;jps -l&lt;br/&gt;24836 org.example.net.Main&lt;br/&gt;62520 org.jetbrains.jps.cmdline.Launcher&lt;br/&gt;129980 sun.tools.jps.Jps&lt;br/&gt;136028 org.jetbrains.jps.cmdline.Launcher&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为已经知道了是哪个应用发生了OOM，这样可以直接用jps找到进程号135988&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）用jstat分析gc活动情况&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jstat是一个统计java进程内存使用情况和gc活动的工具，参数可以有很多，可以通过jstat -help查看所有参数以及含义&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;C:\Users\spareyaya\IdeaProjects\maven-project\target\classes\org\example\net&amp;gt;jstat -gcutil -t -h8 24836 1000&lt;br/&gt;Timestamp         S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT&lt;br/&gt;           29.1  32.81   0.00  23.48  85.92  92.84  84.13     14    0.339     0    0.000    0.339&lt;br/&gt;           30.1  32.81   0.00  78.12  85.92  92.84  84.13     14    0.339     0    0.000    0.339&lt;br/&gt;           31.1   0.00   0.00  22.70  91.74  92.72  83.71     15    0.389     1    0.233    0.622&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面是命令意思是输出gc的情况，输出时间，每8行输出一个行头信息，统计的进程号是24836，每1000毫秒输出一次信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出信息是Timestamp是距离jvm启动的时间，S0、S1、E是新生代的两个Survivor和Eden，O是老年代区，M是Metaspace，CCS使用压缩比例，YGC和YGCT分别是新生代gc的次数和时间，FGC和FGCT分别是老年代gc的次数和时间，GCT是gc的总时间。虽然发生了gc，但是老年代内存占用率根本没下降，说明有的对象没法被回收（当然也不排除这些对象真的是有用）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（3）用jmap工具dump出内存快照&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jmap可以把指定java进程的内存快照dump出来，效果和第一种处理办法一样，不同的是它不用等OOM就可以做到，而且dump出来的快照也会小很多。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jmap -dump:live,format=b,file=heap.bin 24836&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时会得到heap.bin的内存快照文件，然后就可以用eclipse来分析了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上三种严格地说还算不上jvm的调优，只是用了jvm工具把代码中存在的问题找了出来。我们进行jvm的主要目的是尽量减少停顿时间，提高系统的吞吐量。但是如果我们没有对系统进行分析就盲目去设置其中的参数，可能会得到更坏的结果，jvm发展到今天，各种默认的参数可能是实验室的人经过多次的测试来做平衡的，适用大多数的应用场景。如果你认为你的jvm确实有调优的必要，也务必要取样分析，最后还得慢慢多次调节，才有可能得到更优的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;好了，今天就到这儿吧，我是冰河，我们下期见~~&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5312f2f6b6089c2a33ecea5695ba8a9b</guid>
<title>[推荐] 服务探活的五种方式</title>
<link>https://toutiao.io/k/1wuwmui</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;几个月前，我在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI5NjE2MDQwNg==&amp;amp;mid=2247485634&amp;amp;idx=1&amp;amp;sn=31722e2343e8ff9d56300133c2011237&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《4个实验，彻底搞懂TCP连接的断开》&lt;/a&gt;这篇文章中给自己挖了个坑：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.09038901601830664&quot; data-type=&quot;png&quot; data-w=&quot;1748&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0Sc6x9H0p6efiaPVFAuxHOicSL84fF5SVSpaiaUFHK31slByEnTF28298l4ffyLpqHG9aASvlzwEw3NQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文中提到的&lt;code&gt;实际问题&lt;/code&gt;就是服务探活，今天来填上这个坑。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在微服务架构下，服务提供方（Provider）的节点一般不止一个，消费方（Consumer）根据负载均衡算法挑选一个&lt;code&gt;健康&lt;/code&gt;的节点进行调用。识别Provider节点是否健康，这便是&lt;strong&gt;服务探活&lt;/strong&gt; 要讨论的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;健康的节点&lt;/code&gt;可定义为能正常响应Consumer请求的节点，不健康自然是不能正常响应Consumer请求的节点&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;不健康&lt;/code&gt;的原因可能是物理上的断电、断网、硬件故障，也可能是网络延迟、进程异常退出或进程无法处理请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之一句话总结起来就是Provider节点没有摘除流量前，就无法处理请求了。可以分为三类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;系统异常：如断电、断网、其他硬件故障、或操作系统异常退出&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;进程异常退出：进程异常退出，端口挂掉，如有注销机制但没来得及注销，如执行了kill -9&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;进程无法处理请求：端口还在，但服务无法正常响应，如Full GC期间&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个Provider节点的状态只有健康和不健康，由健康到不健康称之为&lt;code&gt;探死&lt;/code&gt;，由不健康到健康称之为&lt;code&gt;探活&lt;/code&gt;，一般我们不分这么细，统一叫&lt;code&gt;探活&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于是谁来探，可能是Consumer，也可能是注册中心，甚至是某个单独的探活组件。我们就从探活的发起者来列举目前主流的探活方式。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Consumer被动探活&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最简单的是在Consumer侧进行探活，如果Consumer调用Provider报错，则Consumer将该Provider剔掉，为了防止偶发的网络抖动或其他干扰，可设置一个时间窗口，窗口内失败达N 次则剔除，当过了这段时间，再把这个Provider重置为正常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式的典型代表是Nginx，Nginx可配置多长时间内，失败多少次则认为该Provider不可用，其失败可以是连接失败、也可以是某些http状态码（如4xx，5xx）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案的缺点很明显，需要真实流量去检测，如果配置了失败继续转发给下一个Provider，则时间窗口的开始的一段时间内耗时上升，未配置则直接报错，所以无论怎么配置，对服务都是有影响的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Consumer主动探活&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consumer被动健康检查的主要问题在于使用了真实流量检测，其实只要稍微改一改，使用旁路的方式去检测即可避免。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阿里的Tengine开源了一个&lt;code&gt;nginx_upstream_check_module&lt;/code&gt;模块来做主动健康检查。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个旁路可以一直去探测Provider，当检测到异常时，将其标记为不可用状态，请求不再发往该Provider，若检测到Provider 健康时，再将其标记为健康。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consumer侧的探活在RPC框架实现的比较少，不知道是基于怎样的一种考虑，其实有些企业内会在Consumer侧已经加入了探活机制，比如&lt;code&gt;爱奇艺&lt;/code&gt;在Dubbo的Consumer侧增加了探活机制，其实我所在的公司内部RPC框架也是有Consumer侧的服务探活。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;参考《爱奇艺在 Dubbo 生态下的微服务架构实践》https://developer.aliyun.com/article/771495&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但Dubbo官方没有集成，至于为什么，我也去github上问过，不过没人回复~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Provider上报心跳&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当有一个注册中心时，探活这项任务就可以交给注册中心了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最简单的，我们想到了心跳保持这个策略，Provider注册成功后，一直向注册中心发送心跳包，注册中心定时检查Provider，如果长时间未发送心跳包，就将其置为不可用，并告知Consumer，如果心跳恢复，则将其恢复并通知。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某些组件也支持这种&lt;code&gt;续约&lt;/code&gt;的特性，如etcd、redis等都可以构建类似的系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式的代表是Nacos 1.x 版本中的&lt;code&gt;临时实例&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;慢慢你会发现这种方式摘除故障节点的时效性和资源的使用成正相关，如果你想要更好的时效性，就必须缩短心跳间隔，从而会增加心跳请求量，每次心跳得更新每个节点的&lt;code&gt;上次心跳时间&lt;/code&gt;，占用了大量资源。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Provider与注册中心会话保持&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决心跳请求占用大量资源的问题，我们想到了TCP 连接不是一个天然的健康检查机制吗？如果仅仅依靠TCP连接可以吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是之前文章埋下的坑，再次总结一下这篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI5NjE2MDQwNg==&amp;amp;mid=2247485634&amp;amp;idx=1&amp;amp;sn=31722e2343e8ff9d56300133c2011237&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《4个实验，彻底搞懂TCP连接的断开》&lt;/a&gt;中关于TCP连接断开的场景：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果是进程终止、无论是正常或者是异常，只要操作系统还在，TCP连接就会正确断开&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是断电、断网或其他因素导致操作系统挂掉，则网络不一定能正确断开，还得分情况&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果此时注册中心有往Provider发送数据，那么是能及时感知到Provider的异常，并断开连接的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果注册中心没有往Provider发送数据，是不能及时感知连接的断开，即使配置了TCP的KeepAlive，也需要大概2小时才能感知到&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2小时肯定不能接受，为了防止这种情况，光靠TCP是不够的，还得在应用层实现一个心跳检测，为了节省资源，可以将心跳包设计的很小，发送频率不需要那么高，通常1分钟内能感知即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为只有断电、断网或硬件故障才会导致无法感知连接的断开，这个比例很小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以参考下图，虽然图中的数据是我杜撰的，但八九不离十吧，可以看到系统异常只占1%，这1%中未发数据可能更少，所以可以认为这个概率很小。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6687402799377916&quot; data-type=&quot;png&quot; data-w=&quot;1286&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0Sc6x9H0p6efiaPVFAuxHOicSdHrJavc2xKK0StoRsvMwtJMISs0xs0iaCxGj8lHhsGvu6icGlmFLzD1A/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式比较常见，像Dubbo使用的Zookeeper，Nacos 2.x版本（gRPC）的临时实例，SOFARegistry等等都用了这这种方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中SOFARegistry比较有意思，它提出了一种&lt;code&gt;连接敏感&lt;/code&gt;的长连接，乍一看以为用了什么黑科技，后来看了代码发现就是TCP连接加应用层的心跳检测，这些被他们封装在&lt;code&gt;SOFABolt&lt;/code&gt;通信框架中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40308988764044945&quot; data-type=&quot;png&quot; data-w=&quot;1424&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0Sc6x9H0p6efiaPVFAuxHOicSDJbAx8Xll4F5pjqh5Mg7yNR3rvUZQ2Yd6RHmumatKyMicGvUA9NpohQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;参考《海量数据下的注册中心 - SOFARegistry 架构介绍》https://mp.weixin.qq.com/s/mZo7Dg6gfNqXoetaqgwMww&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这个方式也有一个明显的缺点，如果网络状况不好的情况下，TCP连接比较容易断开，会导致节点频繁上下线。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;注册中心主动探测&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上述的方式，还有一种注册中心（甚至是一个单独的组件）主动探测Provider的方式，与Consumer主动探测类似，只不过把探测任务移交给了注册中心或一个单独的组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主动探测有个最大的优势是可以扩展非常丰富的探测方式，比如最常见的探测端口是否存活，又或者探测Provider的一个http接口返回是否符合预期，甚至可以扩展为MySQL、Redis等等协议的探测。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是种能解决服务假死的探活方式，Nacos中的&lt;code&gt;永久实例&lt;/code&gt;探活就是采用的这种方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这种方式在实际使用的时候要考虑主动探测组件的高可用，高可用就得存在副本，可采取主备方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果单机存在性能瓶颈，还得分布式探活，主备可能就不适合，得有一个分布式协调者，这要说又得长篇大论。但这里你知道有这么个事儿就可以了。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考量探活的指标有三个：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;能不能探出来？——功能性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么时候探出来？——时效性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;会不会探错了？——稳定性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;功能上最强的是带语义的主动探测，时效性最强的要属长连接会话保持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稳定性不好说谁强谁弱，但一般会给一个集群设置一个探活摘除的比例，比如最多摘除50%机器，防止探活错误导致节点全部下线，这也算是一种兜底策略吧。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;搜索关注微信公众号&quot;捉虫大师&quot;，回复关键字「Nacos」送你一本《Nacos架构与原理》电子书，Dubbo资料也在准备中，不想错过可以点个关注。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另外我也准备组建一个技术交流群，但现在也不知道会有多少人，所以大家先加我微信 &lt;strong&gt;MrRoshi&lt;/strong&gt;，备注加群，一起交流技术，超过一定人数我就拉一个~&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>