<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>51d0261714e236e9df7c1b87856bbf7f</guid>
<title>JSON 是什么</title>
<link>https://toutiao.io/k/ojtkz91</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1299342105263158&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JDtbHnrHRnMpIuTiaib1W7V0AkYNvfFEmsicdDdicT9T57dD1EYgMKwjXjJjmdSK5qBmN0yQkaQA2gUzricFLCMMPXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;608&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;提起 JSON，作为如今最受欢迎的数据交换格式，可以说是无人不知、无人不晓了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;JSON 全称 JavaScript Object Notation（ JS 对象简谱），自诞生之初的小目标就是为了取代XML的江湖地位，短短几年，凭借其简洁易用的特性，早就实现了当初的小目标。最近微信支付的数据格式从最初的 XML 更新为 JSON 也算是迷途知返了&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JDtbHnrHRnODppzRfg1zkhAG9ftfveeh8b6OiaD8Wc8FZ70zQeLqm6z22cIDwPSZeSnkF9VCZUb5ZtcXkElpRHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因为 JavaScript 语言本身具有很明显 C语言风格，导致 JSON 也保持了 C系&lt;span&gt;语言&lt;/span&gt;的习惯，熟悉 C语言、Java、Python 等语言的开发人员可以很容易的接受 JSON。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;JSON 的核心思想之一就是“轻量化”，但是 “keep it simple” 说起容易，做起来难。今天就仔细研究一下 JSON 的标准到底怎样简洁，看看其广受欢迎的背后原因。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;0.  概述&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;JSON 定义了6种数据类型，分别是 null、boolean（包括true，false）、number、string、array 以及 object。其中前四个是基本类型，后两个为数据集合。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面就借助编译里面经常用到的有穷状态机，详细的介绍一下 JSON 的数据类型。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;1. null、true 和 false&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;69&quot; data-cropselx2=&quot;430&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;261&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.524609843937575&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JDtbHnrHRnODppzRfg1zkhAG9ftfveehIjNpb9qHiaIQYCJiaKun4TupVAqamKmdIcgribra5uEiaMibXBcIiaUwBMibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;833&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;null 是 JS 中一个特殊的空对象，而且也很容易映射到其他语言，比如Python中的None。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;boolean类型的两个值 true 和 false，同 null 一样，也很直观。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;null、true、false，这三个类型的状态机相对简单，都是按照字母拼写的直线。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;     &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. number&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;288&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3205551883674818&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JDtbHnrHRnMEqyHF9ATdxekxT2DpufjMJ9KuGoAEg4h4BgBlaw5OAhmTrribVwJWXsoafibXfaqyqlffVVRHw7uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1513&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;number的状态机就比较复杂了&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本来 JavaScript 里面表示数值只有 number 一种类型，没有区分 int 跟 float ，JSON 更进一步，规定其中的数值只能是十进制数，&lt;strong&gt;其形式包含可选的负号、整数部分、可选的小数部分、可选的指数部分&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为number的状态机比较复杂，这里给出对应的正则表达式，可以跟状态机一起加深理解：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;markdown&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;-?([0]|([1-9]\d*))(\.\d*)?([eE][-+]?\d*)?&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. String&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6925925925925925&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JDtbHnrHRnMEqyHF9ATdxekxT2DpufjMlaak70nibNFiclV4zOShzNicDibH4Uv06sUibibuCDVtBsU44sX30eSxIQYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相&lt;span&gt;较&lt;/span&gt;于 JS 宽松的语言规范，&lt;strong&gt;JSON 对 string 做出了更严格的限制，要求其只能被双引号(&quot;)包裹。&lt;/strong&gt;但是相较于 C语言需要严格区分字符和字符串，JSON 又显得宽松许多，双引号包裹的零个或者一个字符都是正确的 string。特殊字符可以使用反斜线(\)进行转义，比如换行符（\n）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要注意的是关于 Unicode 的表示，由于 Unicode 的码点范围为 0 至 0x10FFFF，对于超过 0xFFFF 的码点在 JSON 里需要高低位两组 &quot;\uXXXX&quot; 来表示：&lt;/span&gt;&lt;span&gt;如果第一个码点是 0xD800 至 0xDBFF，我们便知道它的代码对的高代理项（high surrogate），之后应该伴随一个 &lt;span&gt;0x&lt;/span&gt;DC00 至 &lt;span&gt;0x&lt;/span&gt;DFFF 的低代理项（low surrogate）。&lt;/span&gt;&lt;span&gt;其转换规则如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;codepoint = 0x10000 + (高位 − 0xD800) × 0x400 + (低位 − &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;xDC00)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. array&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3261571582346609&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JDtbHnrHRnMEqyHF9ATdxekxT2DpufjMLgEWicRaePW7muCejIvmMCB1cZ2tOMyA6sS7als1pdNKHShBOk3Xhag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;929&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;array 是值的有序集合，其中值可以为任何合法的 JSON 类型。一个 array 以左中括号（[）开始， 右中括号（]）结束。多个值之间使用 逗号（,） 分隔。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;ar&lt;/span&gt;&lt;span&gt;ray 在许多语言中都有含义相似的集合形式，比如 Java 的 List 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5. obj&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;ect&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;156&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.293790546802595&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JDtbHnrHRnNpjpQia536fCJibFnu0EC3aM7tCq8Y3icT67MLTIweVvpiad7yibPrfLqeap4aat9ppAATTPEfdbcMuNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1079&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;object，即对象，是一个无序的“‘键/值’对”集合。一个对象以左大括号（ {） 开始， 右大括号（}） 结束。“键”跟“值”之间使用冒号 （:）分割，多个“‘键/值’对”之间使用逗号（ ,） 分隔。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JSON 的对象就是哈希表，在很多编程语言里面都有对应的内置结构，只不过是 JSON 要求 key 必须为字符串。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;6. 总结&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个合法的JSON串为可选的空白符包裹任意值类型。其中空白符的范围限定于：空格、换行(\n)、回车(\r)和制表符(\t)。集合类型的值之间是可以任意嵌套的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;了解了标准规范会发现 JSON 真的确实简单，不过话又说回来，我们也要了解 JSON 也并非完美无缺的，举个例子：因为 JSON 只有词法特性，没有语法特性，所以通信双方的协商就显得特别关键。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;hr/&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4789736279401283&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JDtbHnrHRnMFWvHpbLLK3ZqZQMFicJcRATp9hiawZiaGibXXQribsl2RCwo1vM2GKiawDSw3GHZ6ser13okz1DkK4icCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1403&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6b6afa41e7d82aa344f0ba3c03f2bff2</guid>
<title>[译] Kubernetes 的自动伸缩你用对了吗？</title>
<link>https://toutiao.io/k/fi3i498</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;本文翻译自 learnk8s 的 &lt;span&gt;Architecting Kubernetes clusters — choosing the best autoscaling strategy&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;，&lt;span&gt;有增删部分内容&lt;/span&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6652653704676826&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwyRbxKyfWG6ibKuqVplVnM8NEkXvdv04qVmziaeStlCibgkiatl01V1cz8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3806&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;TL;DR: 在默认设置下，扩展 Kubernetes 集群中的 pod 和节点可能需要几分钟时间。了解如何调整集群节点的大小、配置水平和集群自动缩放器以及过度配置集群以加快扩展速度。&lt;/p&gt;&lt;h2&gt;自动扩展器&lt;/h2&gt;&lt;p&gt;在 Kubernetes 中，常说的“自用扩展”有：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;HPA：Pod 水平缩放器&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;VPA：Pod 垂直缩放器&lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;CA：集群自动缩放器&lt;sup&gt;[4]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;不同类型的自动缩放器，使用的场景不一样。&lt;/p&gt;&lt;h3&gt;HPA&lt;/h3&gt;&lt;p&gt;HPA 定期检查内存和 CPU 等指标，自动调整 Deployment 中的副本数，比如流量变化：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8152350081037277&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwKKUgLFuFMLTYh7WTOBjiaZaUWPNSh3HVH0AeBdOCZlKtHiaXbEC4F8CA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1234&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;调整前&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.819935691318328&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwbzZEX8erZNg0T1JibEhd4sicaBozoeMu2qH6kicGxS7mrOBSQRYAlm0Mg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1244&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;调整后&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;VPA&lt;/h3&gt;&lt;p&gt;有些时候无法通过增加 Pod 数来扩容，比如数据库。这时候可以通过 VPA 增加 Pod 的大小，比如调整 Pod 的 CPU 和内存：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8250825082508251&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwXFjqtvYka1WhAVAWHPMxKrRVE5a3cjtA2WwQJeqLF30Zgl3pJNmegg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1212&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;调整前&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8175895765472313&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwaic9OL5RF6zw5uqPUYQKYF8MwTx80WGqJFNM24JtWr8CcvxPYs4382w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1228&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;调整后&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;CA&lt;/h3&gt;&lt;p&gt;当集群资源不足时，CA 会自动配置新的计算资源并添加到集群中：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.91796875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwUvw7yEf59JXNXZfgaS4WJicEEoHFYPuc7gN4sbx0NmpFjDXyByQz8aA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;512&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;调整前&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7015558698727016&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuw7uw6GMTjTRMAzIcCBfsPnjmEews2kib24pqFSx4iaz2RRDCbcIic3pDibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1414&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;调整后&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;自动缩放 Pod 出错时&lt;/h2&gt;&lt;p&gt;比如一个应用需要 1.5 GB 内存和 0.25 个 vCPU。一个 8GB 和 2 个 vCPU 的节点，可以容纳 4 个这样的 Pod，完美！&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6002785515320335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwPy83vV1ibmd2unxK9GYlD7yCyo1vFCMpcO4I3johDFSHsX82oNaG4ibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1436&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;做如下配置：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;HPA：每增加 10 个并发，增加一个副本。即 40 个并发的时候，自动扩展到 4 个副本。（这里使用自定义指标，比如来自 Ingress Controller 的 QPS）&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;CA：在资源不足的时候，增加计算节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;当并发达到 30 的时候，系统是下面这样。完美！HPA 工作正常，CA 没工作。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.1160220994475138&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwhzCkBorOaksaIOw2m8mMa7iaqhMwQicgiaj59lIK2TbUhltCYCee82JDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;724&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当增加到 40 个并发的时候，系统是下面的情况：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;HPA 增加了一个 Pod&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;Pod 挂起&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;CA 增加了一个节点&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6100151745068285&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuw28I2cQVqqhgbVqcuHML27d3hGTvkCUcWhYKaHH3tia8gwtaGEaia5xZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1318&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;HPA 工作&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5751445086705202&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwJJtBSNj83fWVyJicjCSUc7KeuXDiaQzkvyhIgBChOTH3HAUIMftELmYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1384&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;CA 工作&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;为什么 Pod 没有部署成功？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;节点上的操作系统进程和 kubelet 也会消耗一部分资源，8G 和 2 vCPU 并不是全都可以提供给 Pod 用的。并且还有一个&lt;span&gt;驱逐阈值&lt;sup&gt;[5]&lt;/sup&gt;&lt;/span&gt;：在节点系统剩余资源达到阈值时，会驱逐 Pod，避免 OOM 的发生。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5619718309859155&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwwsPRLWGBK8VFAKN8vBXSFRhL73nArEq0NmbkpfZ7e6RclELCRHJ9og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1420&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当然上面的这些都是&lt;span&gt;可配置&lt;sup&gt;[6]&lt;/sup&gt;&lt;/span&gt;的。&lt;/p&gt;&lt;p&gt;&lt;span&gt;那为什么在创建该 Pod 之前，CA 没有增加新的节点呢？&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;CA 如何工作？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;CA 在触发自动缩放时，不会查看可用的内存或 CPU。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;CA 是面向事件工作的，并每 10 秒检查一次是否存在不可调度（Pending）的 Pod。&lt;/p&gt;&lt;p&gt;当调度器无法找到可以容纳 Pod 的节点时，这个 Pod 是不可调度的。&lt;/p&gt;&lt;p&gt;此时，CA 开始创建新节点：CA 扫描集群并检查是否有不可调度的 Pod。&lt;/p&gt;&lt;p&gt;当集群有多种节点池，CA 会通过选择下面的一种策略：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;random&lt;/code&gt;：默认的扩展器，随机选择一种节点池&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;most-pods&lt;/code&gt;：能够调度最多 Pod 的节点池&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;least-waste&lt;/code&gt;：选择扩展后，资源空闲最少的节点池&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;price&lt;/code&gt;：选择成本最低的节点池&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;priority&lt;/code&gt;：选择用户分配的具有最高优先级的节点池&lt;/span&gt;&lt;/p&gt;&lt;p&gt;确定类型后，CA 会调用相关 API 来创建资源。（云厂商会实现 API，比如 AWS 添加 EC2；Azure 添加 Virtual Machine；阿里云增加 ECS；GCP 增加 Compute Engine）&lt;/p&gt;&lt;p&gt;计算资源就绪后，就会进行&lt;span&gt;节点的初始化&lt;sup&gt;[7]&lt;/sup&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;注意，这里需要一定的耗时，通常比较慢。&lt;/p&gt;&lt;h2&gt;探索 Pod 自动缩放的前置时间&lt;/h2&gt;&lt;p&gt;四个因素：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;HPA 的响应耗时&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;CA 的响应耗时&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;节点的初始化耗时&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;Pod 的创建时间&lt;/span&gt;&lt;/p&gt;&lt;p&gt;默认情况下，&lt;span&gt;kubelet 每 10 秒抓取一次 Pod 的 CPU 和内存占用情况&lt;sup&gt;[8]&lt;/sup&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;&lt;span&gt;每分钟，Metrics Server 会将聚合的指标开放&lt;sup&gt;[9]&lt;/sup&gt;&lt;/span&gt;给 Kubernetes API 的其他组件使用。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.29542302357836336&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwiaweojBU2HMxT9A8NUed6Ue6vG2ibOTjl4HXzyftKSzXCbvosGqTEgUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1442&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;CA 每 10 秒排查不可调度的 Pod。&lt;sup&gt;[10]&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;少于 100 个节点，且每个节点最多 30 个 Pod，时间不超过 30s。平均延迟大约 5s。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;100 到 1000个节点，不超过 60s。平均延迟大约 15s。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3157162726008345&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwfS75RpibXibAcicSzsCNGuib3OgcQNw57ubryxRbmPBXcia9foEGcY2xR3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1438&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;节点的配置时间，取决于云服务商。通常在 3~5 分钟。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3608815426997245&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwBxS1CdibTicoThOC8LkVA5yPZia5pZOzMZZyumPSUibgWjmbOZOv5UvDjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1452&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;容器运行时创建 Pod：启动容器的几毫秒和&lt;strong&gt;下载镜像的几秒钟&lt;/strong&gt;。如果不做镜像缓存，几秒到 1 分钟不等，取决于层的大小和梳理。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3784916201117318&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuw1eUPjqiaquSexIHGdgMZTfzKhvjFkdPvhfRrgOWBdKuvltLRF6XMjOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1432&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;对于小规模的集群，最坏的情况是 6 分 30 秒。对于 100 个以上节点规模的集群，可能高达 7 分钟。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;HPA delay&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;1m30s&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;CA delay&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;           &lt;/span&gt;&lt;span&gt;0m30s&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;Cloud&lt;/span&gt;&lt;span&gt; provider&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;4m&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;Container&lt;/span&gt;&lt;span&gt; runtime&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;0m30s&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;=========================&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;Total&lt;/span&gt;&lt;span&gt;               &lt;/span&gt;&lt;span&gt;6m30s&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;突发情况，比如流量激增，你是否愿意等这 7 分钟？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这 7 分钟，如何优化压缩？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;HPA 的刷新时间，默认 15 秒，通过 &lt;code&gt;--horizontal-pod-autoscaler-sync-period&lt;/code&gt; 标志控制。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Metrics Server 的指标抓取时间，默认 60 秒，通过 &lt;code&gt;metric-resolution&lt;/code&gt; 控制。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;CA 的扫描间隔，默认 10 秒，通过 &lt;code&gt;scan-interval&lt;/code&gt; 控制。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;节点上缓存镜像，比如 &lt;span&gt;kube-fledged&lt;sup&gt;[11]&lt;/sup&gt;&lt;/span&gt; 等工具。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;即使调小了上述设置，依然会受云服务商的时间限制。&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，如何解决？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;两种尝试：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;尽量避免被动创建新节点&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;主动创建新节点&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;为 Kubernetes 选择最佳规格的节点&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;这会对扩展策略产生巨大影响。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样的场景&lt;/span&gt;&lt;/p&gt;&lt;p&gt;应用程序需要 1GB 内存和 0.1 vCPU；有一个 4GB 内存和 1 个 vCPU 的节点。&lt;/p&gt;&lt;p&gt;排除操作系统、kubelet 和阈值保留空间后，有 2.5GB 内存和 0.7 个 vCPU 可用。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5879828326180258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwQtPp3UPRUNemJy8GIjWLA4V8ciaX1357NBGsRCicfibLCfU2he4xvyLLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1398&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;最多只能容纳 2 个 Pod，扩展副本时最长耗时 7 分钟（HPA、CA、云服务商的资源配置耗时）&lt;/p&gt;&lt;p&gt;假如节点的规格是 64GB 内存和 16 个 vCPU，可用的资源为 58.32GB 和 15.8 个 vCPU。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;这个节点可以托管 58 个 Pod。只有扩容第 59 个副本时，才需要创建新的节点。&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9729241877256317&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwyiaolHlatVU4HDO3Y0o6gwErEvA3TUV3RKBmJ4h5jE6B3mqaZrn57kw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1108&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;CleanShot 2021-06-08 at 23.16.56@2x&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这样触发 CA 的机会更少。&lt;/p&gt;&lt;p&gt;选择大规格的节点，还有另外一个好处：资源的利用率会更高。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.579020979020979&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwXWKrHPdu78ojP3e8uN2VK9gSBv9PeeNB8cpkiba0m28SYo0QeaRWXfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1430&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;节点上可以容纳的 Pod 数量，决定了效率的峰值。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;物极必反！更大的实例，并不是一个好的选择：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;爆炸半径（Blast radius）：节点故障时，少节点的集群和多节点的集群，前者影响更大。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;自动缩放的成本效益低：增加一个大容量的节点，其利用率会比较低（调度过去的 Pod 数少）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;即使选择了正确规格的节点，配置新的计算单元时，延迟仍然存在。怎么解决？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;能否提前创建节点？&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;为集群过度配置节点&lt;/h2&gt;&lt;p&gt;即为集群增加备用节点，可以：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;创建一个节点，并留空 （比如 SchedulingDisabled）&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;一旦空节点中有了一个 Pod，马上创建新的空节点&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.595703125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwOTdakKby3AYbYXmX42QR80zLGWgt0nP25oMHjzzeucVmg1TDlnEGNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.42702702702702705&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwxwhprLaSrqLcSibHyueY4Q3N7hHsn7ib2aKJq7qkwAxGyZNTB3CjXMbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1480&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;CleanShot 2021-06-08 at 23.26.26@2x&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;这种会产生额外的成本，但是效率会提升。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;CA 并不支持此功能 -- 总是保留一个空节点。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;但是，可以伪造。创建一个只占用资源，不使用资源的 Pod 占用整个 Node 节点。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5807692307692308&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwFsR7hzBSbFebL8lKyibR88ODnoKJgDN9ib7pdw94GDP9RaZjHlh0lFibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1040&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;一旦有了真正的 Pod，驱逐占位的 Pod。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7297668038408779&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwbVe0KSIcyaIHQ8NFqaCzdSOPbsXqa5DcfQKAekkPm1zsL3U5kfxtew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1458&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;待后台完成新的节点配置后，将“占位” Pod 再次占用整个节点。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4272108843537415&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwkCM5c4KrHtzMmicmxGjibCzlBa0USM2D12z7jgew9gI6lboxYww9icsMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1470&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这个“占位”的 Pod 可以通过永久休眠来实现空间的保留。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;yaml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;apiVersion&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; apps&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;kind&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Deployment&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  name&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; overprovisioning&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;spec&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  replicas&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  selector&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    matchLabels&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      run&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; overprovisioning&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    metadata&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      labels&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        run&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; overprovisioning&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    spec&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      containers&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; pause&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;          image&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; k8s&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;gcr&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;io&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;pause&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;          resources&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            requests&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;              cpu&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&#x27;1739m&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;              memory&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&#x27;5.9G&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;使用&lt;span&gt;优先级和抢占&lt;sup&gt;[12]&lt;/sup&gt;&lt;/span&gt;，来实现创建真正的 Pod 后驱逐“占位”的 Pod。&lt;/p&gt;&lt;p&gt;使用 &lt;code&gt;PodPriorityClass&lt;/code&gt; 在配置 Pod 优先级：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;yaml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;apiVersion&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; scheduling&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;k8s&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;io&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;v1beta1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;kind&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;PriorityClass&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  name&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; overprovisioning&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;#默认的是 0，这个表示比默认的低&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;globalDefault&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&#x27;Priority class used by overprovisioning.&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;为“占位” Pod 配置优先级：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;yaml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;apiVersion&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; apps&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;kind&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Deployment&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  name&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; overprovisioning&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;spec&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  replicas&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  selector&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    matchLabels&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      run&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; overprovisioning&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    metadata&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      labels&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        run&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; overprovisioning&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    spec&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      priorityClassName&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; overprovisioning &lt;/span&gt;&lt;span&gt;#HERE&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      containers&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; reserve&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;resources&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;          image&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; k8s&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;gcr&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;io&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;pause&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;          resources&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            requests&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;              cpu&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&#x27;1739m&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;              memory&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&#x27;5.9G&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;已经做完过度配置，应用程序是否需要优化？&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;为 Pod 选择正确的内存和 CPU 请求&lt;/h2&gt;&lt;p&gt;Kubernetes 是根据 Pod 的内存和 CPU 请求，为其分配节点。&lt;/p&gt;&lt;p&gt;如果 Pod 的资源请求配置不正确，可能会过晚（或过早）触发自动缩放器。&lt;/p&gt;&lt;p&gt;这样一个场景：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;应用程序平均负载下消耗 512MB 内存和 0.25 个 vCPU。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;高峰时，消耗 4GB 内存 和 1 个 vCPU。（即资源限制，Limit）&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7031963470319634&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwkGBhLI1uPQe33fMjJbdNT6hk3Als9UDuSjz136DCmNnupWUgXH6kVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1314&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;有三种请求的配置选择：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;远低于平均使用量&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;匹配平均使用量&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;尽量接近限制&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6708333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuw8WJjIXUia4HTaicK20sSRwfWhhLMicbKeO7LUCZ7yiaf4716FR9AwsQEVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1440&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;2&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7094499294781382&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwfd7FDH8yxMcgrDxewOia9MVt1MEC6p01pAhdQ23vVHgibNFs3Eia8BDAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1418&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;2&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.670028818443804&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwEA0AIxqZY2WRibBRH632z4CA0k0CcDygkZ62JXsCnHBicQhsaGOe24Dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1388&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;3&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;第一种的问题在于&lt;strong&gt;超卖严重，过度使用节点&lt;/strong&gt;。kubelet 负载高，稳定性差。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6865671641791045&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwnOdXuLs92IjzKG9WrvR0lWQBndlgm1ViceEZicbXEbgPlJh2Apz0LCqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1340&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;1&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;第三种，会造成资源的利用率低，浪费资源。这种通常被称为 &lt;/span&gt;&lt;span&gt;QoS：Quality of Service class&lt;sup&gt;[13]&lt;/sup&gt;&lt;/span&gt;&lt;span&gt; 中的 &lt;/span&gt;&lt;code&gt;Guaranteed&lt;/code&gt;&lt;span&gt; 级别，Pod 不会被终止和驱逐。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6011315417256011&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxc0iajSzrcr9hOW2Qbw3iczuwvXZgu5TyBBWTsDgL6rPfGgJ3lH3EicYv2ibhdGcBrMETBa37tauia38hg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1414&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;3&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;如何在稳定性和资源使用率间做权衡？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这就是 &lt;span&gt;QoS：Quality of Service class&lt;sup&gt;[14]&lt;/sup&gt;&lt;/span&gt; 中的 &lt;code&gt;Burstable&lt;/code&gt; 级别，即 Pod 偶尔会使用更多的内存和 CPU。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;如果节点中有可用资源，应用程序会在返回基线（baseline）前使用这些资源。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;如果资源不足，Pod 将竞争资源（CPU），kubelet 也有可能尝试驱逐 Pod（内存）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在 &lt;code&gt;Guaranteed&lt;/code&gt; 和 &lt;code&gt;Burstable&lt;/code&gt; 之前如何做选择？取决于：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;想尽量减少 Pod 的重新调度和驱逐，应该是用 &lt;code&gt;Guaranteed&lt;/code&gt;。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;如果想充分利用资源时，使用 &lt;code&gt;Burstable&lt;/code&gt;。比如弹性较大的服务，Web 或者 REST 服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何做出正确的配置？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;应该分析应用程序，并测算空闲、负载和峰值时的内存和 CPU 消耗。&lt;/p&gt;&lt;p&gt;甚至可以通过部署 VPA 来自动调整。&lt;/p&gt;&lt;h2&gt;如何进行集群缩容？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;每 10 秒，当请求（request）利用率低于 50%时，CA 才会决定删除节点。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;CA 会汇总同一个节点上的所有 Pod 的 CPU 和内存请求。小于节点容量的一半，就会考虑对当前节点进行缩减。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;需要注意的是，CA 不考虑实际的 CPU 和内存使用或者限制（limit），只看请求（request）。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;移除节点之前，CA 会：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;&lt;span&gt;检查 Pod&lt;sup&gt;[15]&lt;/sup&gt;&lt;/span&gt; 确保可以调度到其他节点上。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;&lt;span&gt;检查节点&lt;sup&gt;[16]&lt;/sup&gt;&lt;/span&gt;，避免节点被过早的销毁，比如两个节点的请求都低于 50%。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;检查都通过之后，才会删除节点。&lt;/p&gt;&lt;h2&gt;为什么不根据内存或 CPU 进行自动缩放？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;基于内存和 CPU 的自动缩放器，不关进 pod。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;比如配置缩放器在节点的 CPU 达到总量的 80%，就自动增加节点。&lt;/p&gt;&lt;p&gt;当你创建 3 个副本的 Deployment，3 个节点的 CPU 达到了 85%。这时会创建一个节点，但你并不需要第 4 个副本，新的节点就空闲了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;不建议使用这种类型的自动缩放器。&lt;/strong&gt;&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;定义和实施成功的扩展策略，需要掌握以下几点：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;节点的可分配资源。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;微调 Metrics Server、HPA 和 CA 的刷新间隔。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;设计集群和节点的规格。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;缓存容器镜像到节点。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;应用程序的基准测试和分析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;配合适当的监控工具，可以反复测试扩展策略并调整集群的缩放速度和成本。&lt;/p&gt;&lt;h4&gt;引用链接&lt;/h4&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; Architecting Kubernetes clusters — choosing the best autoscaling strategy: &lt;em&gt;https://learnk8s.io/kubernetes-autoscaling-strategies#when-autoscaling-pods-goes-wrong&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; HPA：Pod 水平缩放器: &lt;em&gt;https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; VPA：Pod 垂直缩放器: &lt;em&gt;https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[4]&lt;/code&gt; CA：集群自动缩放器: &lt;em&gt;https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[5]&lt;/code&gt; 驱逐阈值: &lt;em&gt;https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/#eviction-thresholds&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[6]&lt;/code&gt; 可配置: &lt;em&gt;https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[7]&lt;/code&gt; 节点的初始化: &lt;em&gt;https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[8]&lt;/code&gt; kubelet 每 10 秒抓取一次 Pod 的 CPU 和内存占用情况: &lt;em&gt;https://github.com/kubernetes/kubernetes/blob/2da8d1c18fb9406bd8bb9a51da58d5f8108cb8f7/pkg/kubelet/kubelet.go#L1855&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[9]&lt;/code&gt; 每分钟，Metrics Server 会将聚合的指标开放: &lt;em&gt;https://github.com/kubernetes-sigs/metrics-server/blob/master/FAQ.md#how-often-metrics-are-scraped&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[10]&lt;/code&gt; CA 每 10 秒排查不可调度的 Pod。: &lt;em&gt;https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#how-does-scale-up-work&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[11]&lt;/code&gt; kube-fledged: &lt;em&gt;https://github.com/senthilrch/kube-fledged&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[12]&lt;/code&gt; 优先级和抢占: &lt;em&gt;https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[13]&lt;/code&gt; QoS：Quality of Service class: &lt;em&gt;https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/#qos-classes&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[14]&lt;/code&gt; QoS：Quality of Service class: &lt;em&gt;https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/#qos-classes&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[15]&lt;/code&gt; 检查 Pod: &lt;em&gt;https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-types-of-pods-can-prevent-ca-from-removing-a-node&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[16]&lt;/code&gt; 检查节点: &lt;em&gt;https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#i-have-a-couple-of-nodes-with-low-utilization-but-they-are-not-scaled-down-why&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9f065d6e69517d5506a0e0af2b205f44</guid>
<title>一文带你深究无线缓冲 channel 的实现</title>
<link>https://toutiao.io/k/x0hrwl9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.49375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lkVfNnnUQnn0vOUOzBwmMnzFx0uZC5hDQsJYkxkvwxjb0bZytic4v3PE5uNYBm5oQxs3Yn0IJKhBaT0r6WgeeibQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;图片拍摄于2020年4月20日。&lt;/span&gt;&lt;/p&gt;&lt;h2 md-src-pos=&quot;97..105&quot;&gt;chanx&lt;/h2&gt;&lt;p md-src-pos=&quot;106..229&quot;&gt;&lt;span&gt;&lt;span&gt;上篇文章&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyMzIwMDcyOA==&amp;amp;mid=2247484692&amp;amp;idx=1&amp;amp;sn=96cf848909097fef7e44baed52912e18&amp;amp;chksm=c1e9f8a3f69e71b570e79424f0a6ac84456eea15e07698977f4365a5950cde7c8784be0c092a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;无限缓冲的channel(1)&lt;/a&gt;我们提到，当我们创建一个有缓冲的通道并指定了容量，那么在这个通道的生命周期内，我们将再也无法改变它的容量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;106..229&quot;&gt;&lt;span&gt;&lt;span&gt;由此引发了关于无限缓存的 &lt;/span&gt;&lt;span&gt;channel&lt;/span&gt;&lt;span&gt; 话题讨论。 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;106..229&quot;&gt;&lt;span&gt;&lt;span&gt;我们还分析了一个实现无限缓冲的代码。 最后，我们也提到了它还可以继续优化的点&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;231..269&quot;&gt;&lt;span&gt;&lt;span&gt;鸟窝的&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;235..242&quot;&gt;&lt;span&gt;chanx&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;正是基于此方案改造而成的，我们来看看他俩的不同之处&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;271..309&quot;&gt;&lt;span&gt;&lt;span&gt;上篇文章说过，所谓的无限缓冲，无非是借助一个中间层的数据结构，暂存临时数据&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;311..330&quot;&gt;&lt;span&gt;&lt;span&gt;在&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;313..320&quot;&gt;&lt;span&gt;chanx&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;中，结构是这样的:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; UnboundedChan struct {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  In chan&amp;lt;- T // channel &lt;span&gt;for&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  Out &amp;lt;-chan T // channel &lt;span&gt;for&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;buffer&lt;/span&gt; *RingBuffer // &lt;span&gt;buffer&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p md-src-pos=&quot;483..563&quot;&gt;&lt;code md-src-pos=&quot;483..487&quot;&gt;&lt;span&gt;in&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;和&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;490..495&quot;&gt;&lt;span&gt;out&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;的职责在上篇文章已经说明，这里的&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;513..521&quot;&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;就是我们所谓的中间临时存储层。其中的&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;541..553&quot;&gt;&lt;span&gt;RingBuffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;结构我们后面再说&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewUnboundedChan&lt;/span&gt;&lt;span&gt;(initCapacity &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;UnboundedChan&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;return&lt;/span&gt; NewUnboundedChanSize(initCapacity, initCapacity, initCapacity)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewUnboundedChanSize&lt;/span&gt;&lt;span&gt;(initInCapacity, initOutCapacity, initBufCapacity &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;UnboundedChan&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  in := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; T, initInCapacity)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  out := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; T, initOutCapacity)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  ch := UnboundedChan{In: in, Out: out, buffer: NewRingBuffer(initBufCapacity)}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;go&lt;/span&gt; process(in, out, ch)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;return&lt;/span&gt; ch&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;995..1085&quot;&gt;&lt;span&gt;&lt;span&gt;它提供了两个初始化&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;1005..1020&quot;&gt;&lt;span&gt;UnboundedChan&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; 的方法，从代码中我们可以明显的看出&lt;/span&gt;,&lt;/span&gt;&lt;code md-src-pos=&quot;1039..1061&quot;&gt;&lt;span&gt;NewUnboundedChanSize&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;可以给每个属性自定义自己的容量大小。仅此而已。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;1087..1171&quot;&gt;&lt;code md-src-pos=&quot;1087..1094&quot;&gt;&lt;span&gt;chanx&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;中 关&lt;/span&gt;于 &lt;/span&gt;&lt;code md-src-pos=&quot;1100..1104&quot;&gt;&lt;span&gt;in&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;和 &lt;/span&gt;&lt;/span&gt;&lt;code md-src-pos=&quot;1107..1112&quot;&gt;&lt;span&gt;out&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;都是带缓冲的通道，而上篇文章中的&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;1130..1134&quot;&gt;&lt;span&gt;in&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;和 &lt;/span&gt;&lt;/span&gt;&lt;code md-src-pos=&quot;1137..1142&quot;&gt;&lt;span&gt;out&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;都是无缓冲的通道&lt;/span&gt;。 &lt;span&gt;这和他们对数据的流转处理有很大关系&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;1174..1274&quot;&gt;&lt;span&gt;&lt;span&gt;我们接下去看&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;1181..1201&quot;&gt;&lt;span&gt;process(in,out,ch)&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; 最核心的方法&lt;/span&gt;。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.20078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lkVfNnnUQnn0vOUOzBwmMnzFx0uZC5hDPNCPMx99YfZj2Aqzw4q0zwVpMpClnucEbicbwhkKiaUt9LVaLDENKJLw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;1276..1292&quot;&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;1276..1292&quot;&gt;&lt;span&gt;这时候，我们再放上一篇核心代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.5796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lkVfNnnUQnn0vOUOzBwmMnzFx0uZC5hDxP8XK5WC6ZULeUA3hzwUBuaEjj6xYv4gyPZB4ePBbvztNAjSJUDk4Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;1358..1373&quot;&gt;&lt;span&gt;可以很明显他们看出它俩的区别。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;1375..1520&quot;&gt;&lt;span&gt;&lt;span&gt;上篇从&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;1379..1383&quot;&gt;&lt;span&gt;in&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;通道读数据会先&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;1392..1400&quot;&gt;&lt;span&gt;append&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; 到&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;1403..1411&quot;&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;span&gt;然后从&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;1416..1424&quot;&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; 中取数据写入&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;1432..1437&quot;&gt;&lt;span&gt;out&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;通道&lt;/span&gt;。 &lt;span&gt;而&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;1444..1451&quot;&gt;&lt;span&gt;chanx&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;从&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;1454..1458&quot;&gt;&lt;span&gt;in&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;通道取出数据先尝试写入&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;1471..1476&quot;&gt;&lt;span&gt;out&lt;/span&gt;&lt;/code&gt;&lt;span&gt;(&lt;span&gt;没有中间商赚差价?&lt;/span&gt;)，&lt;span&gt;只有在&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;1492..1497&quot;&gt;&lt;span&gt;out&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;已经满的情况下&lt;/span&gt;，&lt;span&gt;才塞入到&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;1511..1519&quot;&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;1522..1605&quot;&gt;&lt;code md-src-pos=&quot;1522..1529&quot;&gt;&lt;span&gt;chanx&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;还有一段小细节代码&lt;/span&gt;。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lkVfNnnUQnn0vOUOzBwmMnzFx0uZC5hDBQ6CuUdia3Z5JicftXbnmMv7Sib0lickKkvu9ehrpDp2VoOHCibTxLLvg6w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;1607..1760&quot;&gt;&lt;span&gt;&lt;span&gt;能走到这里，一定是因为&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;1619..1624&quot;&gt;&lt;span&gt;out&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;通道满了。我们把值追加到&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;1638..1646&quot;&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;的同时&lt;/span&gt;，&lt;span&gt;需要尝试把&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;1657..1665&quot;&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;中的数据写入&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;1673..1678&quot;&gt;&lt;span&gt;out&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 。 &lt;span&gt;此时&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;1684..1688&quot;&gt;&lt;span&gt;in&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;通道也许还在持续的写入数据， 为了避免&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;1709..1713&quot;&gt;&lt;span&gt;in&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;通道塞满，阻塞业务写入&lt;/span&gt;，&lt;span&gt;我们同时需要尝试从 &lt;/span&gt;&lt;/span&gt;&lt;code md-src-pos=&quot;1736..1740&quot;&gt;&lt;span&gt;in&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;通道中读数据追加到&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;1751..1759&quot;&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2 md-src-pos=&quot;1762..1771&quot;&gt;buffer&lt;/h2&gt;&lt;p md-src-pos=&quot;1773..1798&quot;&gt;&lt;span&gt;&lt;span&gt;上篇文章我提到了关于&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;1784..1792&quot;&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 优化的点&lt;/span&gt;。&lt;/p&gt;&lt;p md-src-pos=&quot;1800..1815&quot;&gt;&lt;code md-src-pos=&quot;1800..1807&quot;&gt;&lt;span&gt;chanx&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;是如何优化的?&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// type T interface{}&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;type&lt;/span&gt; RingBuffer &lt;span&gt;struct&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  buf []T &lt;br mpa-from-tpl=&quot;t&quot;/&gt;  initialSize &lt;span&gt;int&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  size &lt;span&gt;int&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  r &lt;span&gt;int&lt;/span&gt; &lt;span&gt;// read pointer&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  w &lt;span&gt;int&lt;/span&gt; &lt;span&gt;// write pointer&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p md-src-pos=&quot;1995..2013&quot;&gt;&lt;span&gt;这是 &lt;/span&gt;&lt;code md-src-pos=&quot;1998..2006&quot;&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的结构，其中&lt;/span&gt;&lt;/p&gt;&lt;ul md-src-pos=&quot;2014..2115&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code md-src-pos=&quot;2017..2022&quot;&gt;&lt;span&gt;buf&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;具体存储数据的结构&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code md-src-pos=&quot;2036..2049&quot;&gt;&lt;span&gt;initialSize&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;初始化&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;2055..2060&quot;&gt;&lt;span&gt;buf&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;的长度&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code md-src-pos=&quot;2067..2073&quot;&gt;&lt;span&gt;size&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;当前&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;2077..2082&quot;&gt;&lt;span&gt;buf&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;的长度&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code md-src-pos=&quot;2089..2092&quot;&gt;&lt;span&gt;r&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;当前读数据位置&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code md-src-pos=&quot;2103..2106&quot;&gt;&lt;span&gt;w&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;当前写入数据位置&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p md-src-pos=&quot;2117..2177&quot;&gt;&lt;code md-src-pos=&quot;2117..2125&quot;&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;本质上就是一个环形的队列，目的是达到资源的复用&lt;/span&gt;。 &lt;span&gt;并且当&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;2155..2163&quot;&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;满时，提供自动扩容的功能&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;2179..2269&quot;&gt;&lt;span&gt;&lt;span&gt;我们来看具体把数据写入&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;2191..2199&quot;&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;的源码&lt;/span&gt;。&lt;/span&gt; &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.45546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnn0vOUOzBwmMnzFx0uZC5hDkzLn9Yxe82lLfVtjUmvhKNoECTvNmnSG7YdD4PFCX6u8vKebxZoC4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;2271..2342&quot;&gt;&lt;span&gt;&lt;span&gt;接着看扩容&lt;/span&gt;。&lt;/span&gt; &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.534375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnn0vOUOzBwmMnzFx0uZC5hDRFguY8Sz9EPbdcsaNJsrmic2mDvdCSQTIickytD0liaOmQiciczh2BSWo9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;2344..2384&quot;&gt;&lt;span&gt;这段代码唯一难理解的就是数据迁移了。这里的数据迁移目的是为了保证先入先出的原则。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;2386..2412&quot;&gt;&lt;span&gt;&lt;span&gt;可能加了注释有些人也无法理解，那么就再加一个草率图&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;2414..2480&quot;&gt;&lt;span&gt;&lt;span&gt;假设我们&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;code md-src-pos=&quot;2419..2427&quot;&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;的长度是 8&lt;/span&gt;&lt;span md-src-pos=&quot;2433..2435&quot;&gt;。 &lt;/span&gt;&lt;span&gt;当前读和写的&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;code md-src-pos=&quot;2443..2450&quot;&gt;&lt;span&gt;index&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;都是5&lt;/span&gt;&lt;span md-src-pos=&quot;2451..2457&quot;&gt;。&lt;/span&gt;&lt;span&gt;说明&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;code md-src-pos=&quot;2458..2466&quot;&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;满了&lt;/span&gt;&lt;span md-src-pos=&quot;2467..2486&quot;&gt;，&lt;/span&gt;&lt;span&gt;触发自动扩容规则，进行数据迁移&lt;/span&gt;&lt;span md-src-pos=&quot;2467..2486&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;2482..2497&quot;&gt;&lt;span&gt;&lt;span&gt;那么迁移的过程就是下图这样的&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6548672566371682&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnn0vOUOzBwmMnzFx0uZC5hDTLNPuZ4A7woquVpOzx2DhP8r5s0W31CFnRcAzwNd2fjrnUVUEsibnRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;791&quot;/&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;2565..2629&quot;&gt;&lt;span&gt;&lt;span&gt;当&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;2570..2578&quot;&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;为空并且当前的&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;2587..2593&quot;&gt;&lt;span&gt;size&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;比初始化&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;2599..2605&quot;&gt;&lt;span&gt;size&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;还大，那么可以考虑重置&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;2618..2626&quot;&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; 了&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;//if ch.buffer.IsEmpty() &amp;amp;&amp;amp; ch.buffer.size &amp;gt; ch.buffer.initialSize { &lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;// ch.buffer.Reset()&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;// }&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(r *RingBuffer)&lt;/span&gt; &lt;span&gt;Reset&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;r.r = &lt;span&gt;0&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;r.w = &lt;span&gt;0&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;r.size = r.initialSize&lt;br mpa-from-tpl=&quot;t&quot;/&gt;r.buf = &lt;span&gt;make&lt;/span&gt;([]T, r.initialSize)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p md-src-pos=&quot;2850..2865&quot;&gt;&lt;span&gt;&lt;span&gt;剩下的代码,就没什么好说的了&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h3 md-src-pos=&quot;2867..2873&quot;&gt;总结&lt;/h3&gt;&lt;p md-src-pos=&quot;2874..2990&quot;&gt;&lt;span&gt;&lt;span&gt;继上篇文章后，这篇文章我们主要讲解了&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;2893..2900&quot;&gt;&lt;span&gt;chanx&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;是如何实现无限缓冲的&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;2912..2921&quot;&gt;&lt;span&gt;channel&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;span&gt; 其中最重要的一个点在于&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;2935..2942&quot;&gt;&lt;span&gt;chanx&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;中 &lt;/span&gt;&lt;/span&gt;&lt;code md-src-pos=&quot;2945..2953&quot;&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;span&gt;实现采用的是&lt;/span&gt; &lt;/span&gt;&lt;code md-src-pos=&quot;2961..2973&quot;&gt;&lt;span&gt;ringbuffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;span&gt;达到资源复用的同时还能自动扩容&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h3 md-src-pos=&quot;2867..2873&quot;&gt;交流&lt;/h3&gt;&lt;p&gt;&lt;span&gt;之前就创建了一个自习群，不过当初那个群定下规矩，除了学习的东西，不能闲聊，导致这个群和僵尸群没什么区别。这个故事告诉我们，真的呆在一个完全不闲聊的群也是一件很扯🥚的事。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为目前主力是 Go，所以专门建了一个 Go 交流技术少摸鱼群，取名:&lt;strong&gt;我的眼里只有 Go&lt;/strong&gt;。欢迎各位加入。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外也欢迎加我个人微信交流:&lt;/span&gt;&lt;span&gt;&lt;strong&gt;remember_wuqinqiang&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cfa1be48df81e72c2b266c16f5e87141</guid>
<title>工作多年，Linux 文件系统还不太了解？</title>
<link>https://toutiao.io/k/pcu7stg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;▲&lt;/span&gt;&lt;span&gt;&lt;strong&gt; 点击上方“架构精进之路”&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;关注公众号&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回复&lt;/span&gt;&lt;span&gt;“01”&lt;/span&gt;&lt;span&gt;领&lt;/span&gt;&lt;span&gt;取「&lt;/span&gt;&lt;span&gt;程序员进阶大礼包&lt;/span&gt;&lt;span&gt;」&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3MDg5MDkzOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQmUQ0Aca9qSYNFn0tQEXQc5EibBkqQLYtibYBj1hXuagwXkNc3kVwplHxIl7KQfBIiagysgn9GDUUibw/0?wx_fmt=png&quot; data-nickname=&quot;架构精进之路&quot; data-alias=&quot;jiagou_jingjin&quot; data-signature=&quot;十年研发风雨路，大厂架构师，CSDN博客专家。专注软件架构研究，技术学习与职业成长，坚持分享接地气儿的架构技术干货文章！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;这是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;「&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;架构精进之路」公众号&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的第&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;67&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;篇原创文章&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们作为“码农”，每天都在接触编程，接触linux系统，那么常见的Linux目录和文件都有哪些，它们又有什么作用呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;想必大家经常会忽略这点，作为工作多年的你而言也不例外，今天就带大家来一起了解一下吧~&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1 初识目录结构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6410748560460653&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQvGrTHjTMAnlNuYPZ66qcVn5XBAf6h7JeUaFsGYXiblmHbaIGu0vBEiabn0dtHCkcZgg38pYCEALCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;521&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2 初识文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.1 文件类型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.1.1 文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;第一个属性为 [-]。最常用的类型，包括：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;纯文本文件(ASCII)；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;二进制文件(binary)；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据格式的文件(data)；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;各种压缩文件。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.1.2 目录&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;第一个属性为 [d]&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.1.3 链接文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;第一个属性为 [l]&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.1.4 管道&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;第一个属性为 [p] &lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.1.5 块设备&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;第一个属性为 [b] 。储数据以供系统存取的接口设备，简单而言就是硬盘。&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;ll&lt;/span&gt; /dev/vda1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;brw-rw---- &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; root disk &lt;span class=&quot;code-snippet__number&quot;&gt;253&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;11&lt;/span&gt;月 &lt;span class=&quot;code-snippet__number&quot;&gt;28&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;19&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;17&lt;/span&gt; /dev/vda1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1.6 字符设备文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;第一个属性为 [c] 。即串行端口的接口设备，例如键盘、鼠标等等。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.1.7 套接字&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;第一个属性为 [s]。最常在 /var/run目录中看到这种文件类型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;查看文件类型的方法：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;/span&gt;file, &lt;span class=&quot;code-snippet__built_in&quot;&gt;stat&lt;/span&gt;, ls&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;讲到这里，可以有些疑问，到底文件是个什么东东？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.2 文件是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3264781491002571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQvGrTHjTMAnlNuYPZ66qcVK4qr1aXbxKe2W0WCdmn6sjzGr972CqyVkPOoDSTv0EUH4DV71JNYEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;389&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如上图所示，一般文件包括两部分：&lt;strong&gt;元数据和用户数据&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了有效管理文件，引入了文件系统。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.3 文件系统&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;文件系统，本身是对存储设备上的文件，进行组织管理的机制。所以根据组织机制的不同，可以分为不同的文件系统。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;文件系统系统包括4大要素：&lt;strong&gt;索引节点，目录项，逻辑块，超级块&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6064593301435407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQvGrTHjTMAnlNuYPZ66qcVVKibDB0HfVLKmKoiciazQKAywgfJz2APRtDbQog6xPeCsg1TEibRnAO7qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;836&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2.3.1 索引节点&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同上面讲的元数据部分，索引节点和文件是一一对应的，它和文件内容一样，是存储在磁盘中的。所以索引节点是占用磁盘空间的。所以它不会随着进程的消亡而消失。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.3.2 目录项&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;简称dentry，用来记录文件的名称，索引节点指针以及目录项之间的关联关系，会形成一棵树状结构。多个关联的目录项，就形成了目录结构。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;它是由内存维护的一个内存数据结构，所以通常被称作“目录项缓冲”。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.3.3 逻辑块&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;索引节点和目录项记录了文件的元数据，那么文件内容是怎么存储的？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;实际上，磁盘上最小的读写单位是“扇区”，只有512B大小，也就是0.5K，为了读写效率，系统会将连续的扇区组合一个”块“，一般一个“块”是8个扇区，也就是4K，4096B。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从磁盘中读取内容是特别慢的，所以系统会将读取的内容存到“页缓冲”中。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.3.4 超级块&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;一个超级块对应一个文件系统。超级块会保存文件系统的大小和状态、块设备的引用和元数据信息（比如空闲列表等等）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;文件系统有多种，比如Ext4, NFS等，根据存储位置不一样，可以分为三类。&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;基于磁盘的文件系统：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;也就是数据直接存储在计算机本地挂载的磁盘中。常见的Ext4, Ext3,XFS。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;基于内存的文件系统：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;也就是虚拟文件系统。这类文件系统，不需要任何磁盘分配存储空间，但会占用内存。比如/proc文件系统，/sys文件系统。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;网络文件系统：&lt;/strong&gt;用来访问其他计算机数据的文件系统，比如NFS，SMB。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;每个文件系统是独立的，有自己的组织方法，操作方法。那么对于用户来说，不可能所有的文件系统都了解，那么怎么做到让用户透明的去处理文件呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;2.4 VFS虚拟文件系统&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;img data-ratio=&quot;1.1132075471698113&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQvGrTHjTMAnlNuYPZ66qcVZuRaPmlZ3AoHiajUb8tSwuXfVMg5mXtMdY2AxUQVx7mVNiby6WIyYKzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;530&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;虚拟文件系统定义了一组所有文件系统都支持的数据结构和标准接口。用户进程和内核中的其他子系统，只需要跟VFS提供的统一接口交互就OK，不需要关心底层文件系统实现细节。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;磁盘的操作是非常慢的，所以为了协调磁盘的访问速度，内核提供了“索引节点缓存”，“目录项缓存”，“页缓冲”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2.5 文件系统I/O&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据文件读写方式的各种差异，导致I/O的分类多种多种。最常见的为以下4类：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2.5.1 缓冲IO和非缓冲IO&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第一种，根据是否利用标准库缓存，分为：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;需要说明的是：“缓冲”指的是标准库的缓冲，而不是内核提供的高速缓冲区（也就是页缓冲）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2.5.2 直接IO和非直接IO&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;是否跳过页缓冲。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;要想实现直接IO，可以在系统调用的时候，指定O_DIRECT标志。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;直接IO和非直接IO，本质上还是和文件系统打交道，如果跳过文件系统直接读写磁盘，就是我们通常说的裸IO。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2.5.3 阻塞和非阻塞IO&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;设置O_NONBLOCK&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.5.4 同步和非同步IO&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;设置O_SYNC或者O_DSYNC标志，就代表同步IO。设置O_DSYNC，会等待数据写入磁盘才返回；设置O_SYNC，则是在O_DSYNC的基础上，要求文件元数据也要返回磁盘后，才返回。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;·················· &lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt; ··················&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关注公众号，免费领学习资料&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3MDg5MDkzOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQmUQ0Aca9qSYNFn0tQEXQc5EibBkqQLYtibYBj1hXuagwXkNc3kVwplHxIl7KQfBIiagysgn9GDUUibw/0?wx_fmt=png&quot; data-nickname=&quot;架构精进之路&quot; data-alias=&quot;jiagou_jingjin&quot; data-signature=&quot;十年研发风雨路，大厂架构师，CSDN博客专家。专注软件架构研究，技术学习与职业成长，坚持分享接地气儿的架构技术干货文章！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;十年研发路，大厂架构师，&lt;/span&gt;&lt;span&gt;CSDN博客专家&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;专注架构技术学习及分享，职业与认知升级&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;坚持分享接地气儿的干货，&lt;span&gt;期待与你一起成长&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA3MDg5MDkzOA==&amp;amp;action=getalbum&amp;amp;album_id=1536564239870558210#wechat_redirect&quot; textvalue=&quot;消息中间件&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;消息中间件&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA3MDg5MDkzOA==&amp;amp;action=getalbum&amp;amp;album_id=1536567322449117185#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;架构应用汇总&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA3MDg5MDkzOA==&amp;amp;action=getalbum&amp;amp;album_id=1536569434063077381#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; data-linktype=&quot;2&quot;&gt;认知升级迭代&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA3MDg5MDkzOA==&amp;amp;action=getalbum&amp;amp;album_id=1536561900824657922#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;MySQL实用探秘&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98311&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgTqLjdQBs7fV8zqHRaQhA2ibia13fFn6ibS5qr5PpmZoxd8nlhAyJu7d1CjLicAruicOEb7uxibEGM476xg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87502&quot;&gt;&lt;p&gt;&lt;span&gt;「架构精进之路」专注架构研究，技术分享&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97708&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;点“赞”和“在看”哦&lt;/span&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;1.5925925925925926&quot; data-type=&quot;gif&quot; data-w=&quot;135&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/noz2jw2hPlWiaCrGuJxBicU5mcib3QapDLyo6eKnNVm9dPTV4Z1SicHLtrCCwOG9gblMBFlKf7p9cvwL6wIkZJvamg/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2515d6159c254b81d0d3a88bc478deb7</guid>
<title>硅谷的数据科学家究竟是什么？</title>
<link>https://toutiao.io/k/lii07l7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;sqs-block-content&quot;&gt;&lt;p class=&quot;&quot;&gt;今天在google搜索data scientist，或者what skills are needed to be a data scientist，你会被大量的信息淹没 - Medium，LinkedIn，新闻门户，做Coaching 培训的私站。所有的通用信息都会告诉我们，DS是这个时代被广泛需要的职业，成为一名DS需要掌握统计，编程，机器学习。可大量的信息真的带给我们大量的价值吗？真正的工业界的数据科学家，究竟是在做着怎样的一份工作呢？&lt;/p&gt;&lt;p class=&quot;&quot;&gt;工作是报酬与自我实现的结合，每一次的选择都是在这两条线勾勒出的空间里找准一个让我们最大化满足的点。想成为DS，或者想成为更好的DS，取决于你能在工作中提供什么样的价值，以及在职业生涯中做到怎样的自我实现。&lt;/p&gt;&lt;p class=&quot;&quot;&gt;德国人说，世界是具体的。今天我就具体聊一聊我所熟悉的硅谷科技公司，对DS的不同需求，DS的工作需要什么技能，如何在这个岗位上成长，以及查理芒格告诉我们的&lt;/p&gt;&lt;blockquote&gt;&lt;p class=&quot;&quot;&gt;如果我知道我会死在哪里，那我永远不会去那个地方&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;我的工作&lt;/h3&gt;&lt;p class=&quot;&quot;&gt;从UIUC毕业之后，我加入了微软在硅谷的办公室，到现在已经4年。我们组负责的方向是语言模型 (Language Model)， 是微软云平台Azure提供的语音识别服务的核心组成部分。&lt;/p&gt;&lt;p class=&quot;&quot;&gt;作为一名DS，我在过去的几年里给公司创造了什么样的影响和价值呢？&lt;/p&gt;&lt;ul data-rte-list=&quot;default&quot;&gt;&lt;li&gt;&lt;p class=&quot;&quot;&gt;基于深度学习Neural Network的口语化语音中不流畅语流的检测和修正系统，部署在Office系列语音实时转录服务，提高模型检测准确度26.2%，提升语音识别可读性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p class=&quot;&quot;&gt;基于深度学习Neural Network的N-gram语言模型降噪系统，降低噪音比7%&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p class=&quot;&quot;&gt;Bing Voice Search的深度神经网络语言模型，提高语音识别准确率16.8%&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&quot;&quot;&gt;我的工作偏向于自然语言处理中的机器学习，也就是大家常说的NLP，而这只是广大DS中的一个小分支。在硅谷，不同的公司不同的组所需要的DS，技能可能是完全不一样的。下一个章节我就来聊聊大方向上硅谷对DS的需求分类。&lt;/p&gt;&lt;h3&gt;硅谷DS的需求分类&lt;/h3&gt;&lt;p class=&quot;&quot;&gt;总体来说，硅谷对于DS有三种岗位&lt;/p&gt;&lt;p class=&quot;&quot;&gt;首先，这三种岗位所需要的技能是有区别的。&lt;/p&gt;&lt;ul data-rte-list=&quot;default&quot;&gt;&lt;li&gt;&lt;p class=&quot;&quot;&gt;第一种，Data Analyst。负责使用SQL等语言处理数据，总结数据并从中提取商业见解，进行数据统计的可视化，并完成基于数据分析的报告。当然，在Facebook有基于Analytics的DS岗位，主要负责设计统计实验，A/B Testing等。举个例子，我们现在设计了一套新的新闻推荐系统，那么如何知道这套新的系统能不能提高用户粘性，并且帮助我们提高用户订阅人数来增长revenue呢？这时候我们就需要基于A/B Testing思想的online evaluation以及一系列的实验设计和统计分析。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p class=&quot;&quot;&gt;第二种，Data Engineer。严格来说这是Software engineer的一个分支，主要是大规模数据基础设施的设计和建造。比如在淘宝上，每一次的浏览，点击，甚至是浏览两个商品之间的间隔时间，都是可以沉淀的实时用户反馈数据，这些数据可以帮助我们构造用户画像，更精准地推送推荐商品。而涉及到所有这些数据的存储，处理，读取，优化，就是data engineer的工作。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p class=&quot;&quot;&gt;第三种，Machine Learning Engineer。负责设计，建造大规模的机器学习系统，需要对机器学习，深度学习系统的深度理解，优秀的编程能力，以及我认为最重要的，如何把一个商业问题转化成机器学习问题。设计可量化的指标定义问题，收集并大规模处理数据，通过智能算法的迭代优化，达到机器决策提高整体表现的目的。生活中无处不在的推荐系统就是机器学习的典型应用，比如YouTube的视频推荐，Spotify的每日歌单，Amazon的商品推荐等等。除此之外，我们使用的Google Assistant、Alexa的智能语音识别和人机交互，机器翻译，智能辅助驾驶，在线广告，背后都是机器学习系统。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&quot;&quot;&gt;其次，从工资水平来说，和engineering相关的岗位总体上优于analysis，这是由市场的供需关系决定的。相对来说，通过一系列商业软件来进行图表可视化的学习曲线，低于机器学习和编程，而有真正行业经验的人才更是稀少，这就是供求端的稀缺。从需求端来看，云计算平台对于很多行业的渗透，使得大规模数据的在线化，流动化成为可能，而数据智能化的快速扩展增加了对于这方面人才的需求。&lt;/p&gt;&lt;p class=&quot;&quot;&gt;&lt;em&gt;Machine Learning Engineer &amp;gt;= Data Engineer &amp;gt;&amp;gt; Data Analyst&lt;/em&gt;&lt;/p&gt;&lt;p class=&quot;&quot;&gt;当然，硅谷需要最多的岗位还是SDE。在很多产品里，机器学习是icing on the cake。比如我们都会用Zoom来开视频会议，一些机器学习帮助提供的功能会帮助提高用户体验和用户粘性，但从第一性原理出发，我们首先需要的是一款低延迟无障碍的视频通讯软件。除此之外，如今很多新的产品和服务完全是从数据在线化智能化的角度出发，建立工程系统，收集行为数据，通过机器学习推动系统的智能迭代升级，吸引更多用户，从而跑通数据-&amp;gt;模型-&amp;gt;产品的飞轮，比如抖音和AI智能教育。总的来说，工业界的机器学习系统，本质上是工程问题，而不完全是科学问题。关于这个部分，我会在之后的博文中给大家讲一些具体的例子。&lt;/p&gt;&lt;h3&gt;DS所需要的技能&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>