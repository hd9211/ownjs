<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>7bd8d52e55ebe6bb5cb15556e3060cc7</guid>
<title>工具 | 一个异步非阻塞的网络协议解析包</title>
<link>https://toutiao.io/k/4i8nuot</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0ODkyMA==&amp;amp;mid=2655077223&amp;amp;idx=2&amp;amp;sn=05d40fd92b2ed441b4bfcaaab853a1d2&amp;amp;chksm=bd2913508a5e9a46683351f781991e7e2ad2a4a1c63a4acd499df91a8861e07ba5f713df0f96&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;加入「码农周刊VIP会员」，一起牛起来！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;862&quot; data-ratio=&quot;1.8266666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicGt7KKp6l7hcLjQGF3SheXAyR6oIPGDibDcYloiceS9fCHxCJOBdC9Nneyw78ZZmiagibZQGD7B53q1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;322&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;350&quot; data-ratio=&quot;1.318840579710145&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8pVYfXHFZnJw6GmED4PucZvQd6m3AP8fUG1IKJyBgicmJ3P5ygQjO5r6Bib2x190MFOlb6PwExNQuA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3e0b0b969dfb48bb6c9915b0d14b56fa</guid>
<title>玩转直播系列之消息模块演进（三）</title>
<link>https://toutiao.io/k/2deq8i8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;vivo互联网技术&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;微信号&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;vivoVMIC&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;功能介绍&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>482ac65815bbbb0944f77b8e721c21da</guid>
<title>Swift 5.5 新特性抢先看，async/await 将重磅来袭</title>
<link>https://toutiao.io/k/09mr8qi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA5NzMwODI0MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/3QD99b9DjVGfeXc8qHD8oDBNdb8uo6pOPHJNLSiblhSDaHA3XwFiblJEOr1UEAD2IZlqH1AOgfdicRvZV3tfCnWiaw/0?wx_fmt=png&quot; data-nickname=&quot;知识小集&quot; data-alias=&quot;zsxjtip&quot; data-signature=&quot;追踪移动大前端最新技术和行业发展，关注移动研发的架构、性能、底层探索、工程化和跨平台方案&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;再过一周的时间，WWDC21 就正式举行了，如果不出意外的话，Swift 5.5 测试版也会在期间发布。早在 3 月 13 日，官方论坛就公布了 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NzMwODI0MA==&amp;amp;mid=2647769384&amp;amp;idx=1&amp;amp;sn=cf5d68db2a2c4a0add50bb8323560e7d&amp;amp;chksm=8887ba17bff033015d200f19b95d6ef3c79ad0f297e2fe2922ebf2cbe461794f059ed64f292c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Swift 5.5 版本的发布计划&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Swift 5.5 版本的发布计划&lt;/a&gt;，并在 4 月 16 日拉出了 release/5.5 分支。经过几个月时间的准备，从 Swift Evolution 中，我们能发现 Swift 5.5 将为我们带来许多期待已久的特性，如 async/await。我们今天就来简单整理一下这些 &lt;strong/&gt;&lt;span&gt;&lt;strong&gt;可能 &lt;/strong&gt;&lt;/span&gt;将在 Swift 5.5 中出现的新特性。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;SE-0291 包集合&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.30718954248366015&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3QD99b9DjVHbBCZDQxhGyBE06b6PwNDTCs5omoLVH9PcFBwuhF9Jnj8canL2zGUSFs3u2dXJMmqmc25x0ZeN0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1836&quot;/&gt;&lt;/p&gt;&lt;p&gt;这个 proposal 旨在为 SwiftPM 添加对包集合的支持。包集合是包和相关元数据的列表，可以更轻松地发现特定用例的现有包。SwiftPM 将允许用户订阅这些集合，通过 &lt;code&gt;swift package-collection&lt;/code&gt; 命令行界面搜索它们，并使 libSwiftPM 的任何客户端都可以访问它们的内容。这个 proposal 关注于以命令行界面和包集合想着的配置数据格式。&lt;/p&gt;&lt;p&gt;例如，&lt;code&gt;list&lt;/code&gt; 命令将列出用户配置的所有集合：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ swift &lt;span&gt;package&lt;/span&gt;-collection list [&lt;span&gt;--json]&lt;/span&gt;&lt;br/&gt;My organisation&lt;span&gt;&#x27;s&lt;/span&gt; packages - https://example.com/packages.json&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;describe&lt;/code&gt; 命令显示来自包本身的元数据。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ swift &lt;span&gt;package&lt;/span&gt;-collection describe [--json] &lt;span&gt;https:&lt;/span&gt;&lt;span&gt;//github.com/jpsim/yams&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Description:&lt;/span&gt; A sweet and swifty YAML parser built on LibYAML.&lt;br/&gt;Available &lt;span&gt;Versions:&lt;/span&gt; &lt;span&gt;4.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;, &lt;span&gt;3.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;, ...&lt;br/&gt;&lt;span&gt;Watchers:&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Readme:&lt;/span&gt; &lt;span&gt;https:&lt;/span&gt;&lt;span&gt;//github.com/jpsim/Yams/blob/master/README.md&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Authors:&lt;/span&gt; &lt;span&gt;@norio&lt;/span&gt;-nomura, &lt;span&gt;@jpsim&lt;/span&gt;&lt;br/&gt;--------------------------------------------------------------&lt;br/&gt;Latest &lt;span&gt;Version:&lt;/span&gt; &lt;span&gt;4.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;br/&gt;Package &lt;span&gt;Name:&lt;/span&gt; Yams&lt;br/&gt;&lt;span&gt;Modules:&lt;/span&gt; Yams, CYaml&lt;br/&gt;Supported &lt;span&gt;Platforms:&lt;/span&gt; iOS, macOS, Linux, tvOS, watchOS&lt;br/&gt;Supported Swift &lt;span&gt;Versions:&lt;/span&gt; &lt;span&gt;5.3&lt;/span&gt;, &lt;span&gt;5.2&lt;/span&gt;, &lt;span&gt;5.1&lt;/span&gt;, &lt;span&gt;5.0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;License:&lt;/span&gt; MIT&lt;br/&gt;&lt;span&gt;CVEs:&lt;/span&gt; ...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;https://github.com/apple/swift-evolution/blob/main/proposals/0291-package-collections.md&lt;/p&gt;&lt;h3&gt;&lt;span&gt;SE-0293 将属性包装器扩展到函数和闭包参数&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.34702702702702704&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3QD99b9DjVHbBCZDQxhGyBE06b6PwNDTgibPl2vyfu5gNYdicWOIiaFsq5cVLlEFJcFvdBNODlpEcVy6Kia1Gd1BVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1850&quot;/&gt;&lt;/p&gt;&lt;p&gt;Property Wrappers 用于抽象出常见的属性访问器模式，在 Swift 5.1 中引入。不过之前仅允许在局部变量和类型属性上应用属性包装器。而这个 proposal 的目标是将属性包装器扩展到函数和闭包参数。&lt;/p&gt;&lt;p&gt;例如，使用来自 PropertyKit 的验证，我们可以将各种前提条件抽象到一个属性包装器中：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@propertyWrapper&lt;/span&gt;&lt;br/&gt;struct Asserted&amp;lt;Value&amp;gt; {&lt;br/&gt;  &lt;span&gt;init&lt;/span&gt;(&lt;br/&gt;    &lt;span&gt;wrappedValue&lt;/span&gt;: Value, &lt;br/&gt;    &lt;span&gt;validation&lt;/span&gt;: Validation&amp;lt;Value&amp;gt;,&lt;br/&gt;  ) { ... }&lt;br/&gt;&lt;br/&gt;  var &lt;span&gt;wrappedValue&lt;/span&gt;: Value { ... }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将 &lt;code&gt;@Asserted&lt;/code&gt; 应用于参数以对参数值断言某些先决条件会很有用。例如，下面的代码断言传递给 &lt;code&gt;quantity&lt;/code&gt; 参数的参数大于或等于1：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;buy&lt;/span&gt;(&lt;br/&gt;  &lt;span&gt;@Asserted&lt;/span&gt;(.&lt;span&gt;greaterOrEqual&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;)) &lt;span&gt;quantity&lt;/span&gt;: &lt;span&gt;Int&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;of&lt;/span&gt; &lt;span&gt;product&lt;/span&gt;: &lt;span&gt;Product&lt;/span&gt;,&lt;br/&gt;) { ... }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;https://github.com/apple/swift-evolution/blob/main/proposals/0293-extend-property-wrappers-to-function-and-closure-parameters.md&lt;/p&gt;&lt;h3&gt;&lt;span&gt;SE-0295 有关联值的枚举的 Codable 合成&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3372972972972973&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3QD99b9DjVHbBCZDQxhGyBE06b6PwNDTEicFjZ9FiaaakuHaYZX0lfjJSUBDnZJBZkLicFWB0WruVxxA5eKgsEz6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1850&quot;/&gt;&lt;/p&gt;&lt;p&gt;在 SE-0166 中引入了 Codable，它支持合成类和结构类型的 Encodable 和 Decodable 一致性，其中仅包含也符合各自协议的值。&lt;/p&gt;&lt;p&gt;这个 proposal 将扩展对枚举关联值的一致性的自动合成的支持。&lt;/p&gt;&lt;p&gt;如以下枚举有关联值：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;enum&lt;/span&gt; &lt;span&gt;Command&lt;/span&gt;: &lt;span&gt;Codable&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; load(&lt;span&gt;key:&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; store(&lt;span&gt;key:&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;, &lt;span&gt;value:&lt;/span&gt; &lt;span&gt;Int&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将会被编码为&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;  &quot;&lt;span&gt;load&lt;/span&gt;&quot;: &lt;span&gt;{&lt;br/&gt;    &quot;&lt;span&gt;key&lt;/span&gt;&quot;: &lt;span&gt;&lt;span&gt;&quot;MyKey&quot;&lt;/span&gt;&lt;br/&gt;  &lt;/span&gt;}&lt;br/&gt;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;{&lt;br/&gt;  &quot;&lt;span&gt;store&lt;/span&gt;&quot;: &lt;span&gt;{&lt;br/&gt;    &quot;&lt;span&gt;key&lt;/span&gt;&quot;: &lt;span&gt;&lt;span&gt;&quot;MyKey&quot;&lt;/span&gt;&lt;/span&gt;,&lt;br/&gt;    &quot;&lt;span&gt;value&lt;/span&gt;&quot;: &lt;span&gt;&lt;span&gt;42&lt;/span&gt;&lt;br/&gt;  &lt;/span&gt;}&lt;br/&gt;&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编译器将生成以下 CodingKeys 声明：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// &lt;span&gt;contains&lt;/span&gt; keys for &lt;span&gt;all&lt;/span&gt; cases of the &lt;span&gt;enum&lt;/span&gt;&lt;br/&gt;&lt;span&gt;enum&lt;/span&gt; CodingKeys: CodingKey {&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; load&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; store&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// &lt;span&gt;contains&lt;/span&gt; keys for &lt;span&gt;all&lt;/span&gt; &lt;span&gt;associated&lt;/span&gt; values of `&lt;span&gt;case&lt;/span&gt; load`&lt;br/&gt;&lt;span&gt;enum&lt;/span&gt; LoadCodingKeys: CodingKey {&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; key&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// &lt;span&gt;contains&lt;/span&gt; keys for &lt;span&gt;all&lt;/span&gt; &lt;span&gt;associated&lt;/span&gt; values of `&lt;span&gt;case&lt;/span&gt; store`&lt;br/&gt;&lt;span&gt;enum&lt;/span&gt; StoreCodingKeys: CodingKey {&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; key&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;https://github.com/apple/swift-evolution/blob/main/proposals/0295-codable-synthesis-for-enums-with-associated-values.md&lt;/p&gt;&lt;h3&gt;&lt;span&gt;SE-0296 async/await&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.27747551686615884&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3QD99b9DjVHbBCZDQxhGyBE06b6PwNDTDxdvbpMV2m3ysg2sllRyFicm5kAGamwfqRxgEEbLfl7h7cd6PxRL6VQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1838&quot;/&gt;&lt;/p&gt;&lt;p&gt;现代 Swift 开发涉及大量使用闭包和完成处理程序的异步编程，但这些 API 都很难使用。当使用许多异步操作、错误处理或异步调用之间的控制流变得复杂时，会让问题变得很复杂。我们先看一个简单的例子：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 一系列简单的异步操作通常需要深度嵌套的闭包&lt;br/&gt;func processImageData1(completionBlock: (_ &lt;span&gt;result&lt;/span&gt;: &lt;span&gt;Image&lt;/span&gt;) -&amp;gt; &lt;span&gt;Void&lt;/span&gt;) {&lt;br/&gt;    loadWebResource(&lt;span&gt;&quot;dataprofile.txt&quot;&lt;/span&gt;) { dataResource &lt;span&gt;in&lt;/span&gt;&lt;br/&gt;        loadWebResource(&lt;span&gt;&quot;imagedata.dat&quot;&lt;/span&gt;) { imageResource &lt;span&gt;in&lt;/span&gt;&lt;br/&gt;            decodeImage(dataResource, imageResource) { imageTmp &lt;span&gt;in&lt;/span&gt;&lt;br/&gt;                dewarpAndCleanupImage(imageTmp) { imageResult &lt;span&gt;in&lt;/span&gt;&lt;br/&gt;                    completionBlock(imageResult)&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;processImageData1 { image &lt;span&gt;in&lt;/span&gt;&lt;br/&gt;    display(image)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而这个提案则引入了一种语言扩展，大大简化了这些操作，让代码更加自然而不易出错。这种设计为 Swift 引入了一个协程模型。函数可以是 &lt;code&gt;async&lt;/code&gt;，允许程序员使用正常的控制流机制编写涉及异步操作的复杂逻辑。编译器负责将异步函数转换为一组合适的闭包和状态机。实际上 async/await 语义早已是现代编程语言的标配。我们来看看，async/await 如何让代码变得更加简洁：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;loadWebResource&lt;/span&gt;&lt;span&gt;(&lt;span&gt;_&lt;/span&gt; path: String)&lt;/span&gt;&lt;/span&gt; async &lt;span&gt;throws&lt;/span&gt; -&amp;gt; &lt;span&gt;Resource&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;decodeImage&lt;/span&gt;&lt;span&gt;(&lt;span&gt;_&lt;/span&gt; r1: Resource, &lt;span&gt;_&lt;/span&gt; r2: Resource)&lt;/span&gt;&lt;/span&gt; async &lt;span&gt;throws&lt;/span&gt; -&amp;gt; &lt;span&gt;Image&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;dewarpAndCleanupImage&lt;/span&gt;&lt;span&gt;(&lt;span&gt;_&lt;/span&gt; i : Image)&lt;/span&gt;&lt;/span&gt; async &lt;span&gt;throws&lt;/span&gt; -&amp;gt; &lt;span&gt;Image&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;processImageData&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; async &lt;span&gt;throws&lt;/span&gt; -&amp;gt; &lt;span&gt;Image&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; dataResource  = &lt;span&gt;try&lt;/span&gt; await loadWebResource(&lt;span&gt;&quot;dataprofile.txt&quot;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; imageResource = &lt;span&gt;try&lt;/span&gt; await loadWebResource(&lt;span&gt;&quot;imagedata.dat&quot;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; imageTmp      = &lt;span&gt;try&lt;/span&gt; await decodeImage(dataResource, imageResource)&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; imageResult   = &lt;span&gt;try&lt;/span&gt; await dewarpAndCleanupImage(imageTmp)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; imageResult&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不过，这个 proposal 并不提供并发，结构化并发问题由另一个 proposal 引入，它将异步函数与并发执行的任务相关联，并提供用于创建、查询和取消任务的 API。&lt;/p&gt;&lt;p&gt;https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md&lt;/p&gt;&lt;h3&gt;&lt;span&gt;SE-0297 与 Objective-C 的并发互操作性&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.30306345733041573&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3QD99b9DjVHbBCZDQxhGyBE06b6PwNDTAWwpSjJhpsE7FAWVibWyHdDibhqKgPns4wFzUY2ov66wicfz8vAt8P9Fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1828&quot;/&gt;&lt;/p&gt;&lt;p&gt;在 Apple 平台上，Swift 与 Objective-C 的混编与交互目前来讲还是一个很大的课题。在 Objective-C 中，异步 API 随处可见，在 iOS 14.0 SDK 中就包含了近 1000 个接受 completion 处理器的方法。例如以下 PassKit API 中的方法&lt;/p&gt;&lt;pre&gt;&lt;code&gt;- (&lt;span&gt;void&lt;/span&gt;)signData:(&lt;span&gt;NSData&lt;/span&gt; *)signData &lt;br/&gt;withSecureElementPass:(PKSecureElementPass *)secureElementPass &lt;br/&gt;      completion:(&lt;span&gt;void&lt;/span&gt; (^)(&lt;span&gt;NSData&lt;/span&gt; *signedData, &lt;span&gt;NSData&lt;/span&gt; *signature, &lt;span&gt;NSError&lt;/span&gt; *error))completion;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这些方法包括可以直接在 Swift 中调用的方法，可以在 Swift 定义的子类中覆盖的方法，以及可以实现的协议中的方法。&lt;/p&gt;&lt;p&gt;当前，以上 Objective-C 函数在 Swift 中会被翻译成以下函数：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@objc&lt;/span&gt; func &lt;span&gt;sign&lt;/span&gt;(_ &lt;span&gt;signData&lt;/span&gt;: Data, &lt;br/&gt;    using &lt;span&gt;secureElementPass&lt;/span&gt;: PKSecureElementPass, &lt;br/&gt;    &lt;span&gt;completion&lt;/span&gt;: &lt;span&gt;@escaping&lt;/span&gt; (Data?, Data?, Error?) -&amp;gt; Void&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个 proposal 旨在为 Swift 并发结构与 Objective-C 之间提供互操作性，并实现以下目标：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;将 Objective-C 完成处理程序方法转换为 Swift 中的 &lt;code&gt;async&lt;/code&gt; 方法；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;允许将 Swift 中定义的 &lt;code&gt;async&lt;/code&gt; 方法标记为 &lt;code&gt;@objc&lt;/code&gt;，在这种情况下，它们将作为完成处理程序方法导出；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;提供 Objective-C 属性来控制如何将基于完成处理程序的 API 转换为 &lt;code&gt;async&lt;/code&gt;Swift 函数。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;基于这些假设，以上 Objective-C 函数将会被翻译为以下 &lt;code&gt;async&lt;/code&gt; 函数：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@objc&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;sign&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;    &lt;span&gt;_&lt;/span&gt; signData: Data, &lt;br/&gt;    using secureElementPass: PKSecureElementPass&lt;br/&gt;)&lt;/span&gt;&lt;/span&gt; async &lt;span&gt;throws&lt;/span&gt; -&amp;gt; (&lt;span&gt;Data&lt;/span&gt;, &lt;span&gt;Data&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同时可以通过以下方式来调用：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; (signedValue, signature) = &lt;span&gt;try&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; passLibrary.sign(signData, &lt;span&gt;using&lt;/span&gt;: pass)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;https://github.com/apple/swift-evolution/blob/main/proposals/0297-concurrency-objc.md&lt;/p&gt;&lt;h3&gt;&lt;span&gt;SE-0298 Async/Await: 序列&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.31453362255965295&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3QD99b9DjVHbBCZDQxhGyBE06b6PwNDTq7ibM3arQ22k5js9nf4FHKCmR1zVMEZ1nkD52v1CnuXM4LADKFIoPwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1844&quot;/&gt;&lt;/p&gt;&lt;p&gt;SE-0296 的 &lt;code&gt;async/await&lt;/code&gt; 特性为 Swift 提供了更直观的异步编程方式。而这个 proposal 的目标是基于 &lt;code&gt;async/await&lt;/code&gt;，以内置的方式更直观地编写和使用随时间返回多个值的函数。&lt;/p&gt;&lt;p&gt;这个 proposal 主要由三个部分组成：&lt;/p&gt;&lt;p&gt;基于这个 proposal，迭代异步值序列像迭代同步值序列一样简单。一个示例用例是迭代文件中的行，如下所示：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;try&lt;/span&gt; await &lt;span&gt;line&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; myFile.&lt;span&gt;lines&lt;/span&gt;() {&lt;br/&gt; &lt;span&gt; // Do something with each line&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为此，标准库中定义了以下协议&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;protocol&lt;/span&gt; &lt;span&gt;AsyncSequence&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  associatedtype &lt;span&gt;AsyncIterator&lt;/span&gt;: &lt;span&gt;AsyncIteratorProtocol&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;AsyncIterator&lt;/span&gt;.&lt;span&gt;Element&lt;/span&gt; == &lt;span&gt;Element&lt;/span&gt;&lt;br/&gt;  associatedtype &lt;span&gt;Element&lt;/span&gt;&lt;br/&gt;  __consuming &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;makeAsyncIterator&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span&gt;AsyncIterator&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;protocol&lt;/span&gt; &lt;span&gt;AsyncIteratorProtocol&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  associatedtype &lt;span&gt;Element&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;mutating&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; async &lt;span&gt;throws&lt;/span&gt; -&amp;gt; &lt;span&gt;Element&lt;/span&gt;?&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编译器生成的代码将允许在符合 &lt;code&gt;AsyncSequence&lt;/code&gt; 的任何类型上使用for in循环。标准库还将扩展协议以提供熟悉的通用算法。如以下示例：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;struct &lt;span&gt;Counter&lt;/span&gt; : &lt;span&gt;AsyncSequence&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; howHigh: &lt;span&gt;Int&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  struct &lt;span&gt;AsyncIterator&lt;/span&gt; : &lt;span&gt;AsyncIteratorProtocol&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; howHigh: &lt;span&gt;Int&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; current = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    mutating func next() async -&amp;gt; &lt;span&gt;Int&lt;/span&gt;? {&lt;br/&gt;      // &lt;span&gt;We&lt;/span&gt; could use the `&lt;span&gt;Task&lt;/span&gt;` &lt;span&gt;API&lt;/span&gt; to check &lt;span&gt;for&lt;/span&gt; cancellation here &lt;span&gt;and&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; early.&lt;br/&gt;      guard current &amp;lt;= howHigh &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;let&lt;/span&gt; &lt;span&gt;result&lt;/span&gt; = current&lt;br/&gt;      current += &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;result&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  func makeAsyncIterator() -&amp;gt; &lt;span&gt;AsyncIterator&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;AsyncIterator&lt;/span&gt;(howHigh: howHigh)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在调用端，则可以如下使用：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;for&lt;/span&gt; await i in &lt;span&gt;Counter&lt;/span&gt;&lt;span&gt;(howHigh: &lt;span&gt;3&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  print(i)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/* &lt;br/&gt;Prints the following, and finishes the loop:&lt;br/&gt;1&lt;br/&gt;2&lt;br/&gt;3&lt;br/&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;for&lt;/span&gt; await i in &lt;span&gt;Counter&lt;/span&gt;&lt;span&gt;(howHigh: &lt;span&gt;3&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  print(i)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; i == &lt;span&gt;2&lt;/span&gt; { &lt;span&gt;break&lt;/span&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/*&lt;br/&gt;Prints the following:&lt;br/&gt;1&lt;br/&gt;2&lt;br/&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;https://github.com/apple/swift-evolution/blob/main/proposals/0298-asyncsequence.md&lt;/p&gt;&lt;h3&gt;&lt;span&gt;SE-0299 在通用上下文中扩展静态成员查找&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3258064516129032&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3QD99b9DjVHbBCZDQxhGyBE06b6PwNDTD8JFJG43XwdXm8MnoXPzr6NwGNrPTUyb3iaP8ZqXUEpkQhwuFyPQ6uQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1860&quot;/&gt;&lt;/p&gt;&lt;p&gt;Swift 支持对具体类型的静态成员查找，并通过类似枚举的 &lt;code&gt;.&lt;/code&gt; 语法来调用。例如，SwiftUI 中使用预定义的常用值作为静态属性扩展了 Font 和 Color 等类型。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;extension&lt;/span&gt; &lt;span&gt;Font&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;let&lt;/span&gt; headline: &lt;span&gt;Font&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;let&lt;/span&gt; subheadline: &lt;span&gt;Font&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;let&lt;/span&gt; body: &lt;span&gt;Font&lt;/span&gt;&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;extension&lt;/span&gt; &lt;span&gt;Color&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;let&lt;/span&gt; red: &lt;span&gt;Color&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;let&lt;/span&gt; green: &lt;span&gt;Color&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;let&lt;/span&gt; blue: &lt;span&gt;Color&lt;/span&gt;&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可通过以下方式来调用：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;VStack {&lt;br/&gt;  Text(item&lt;span&gt;.title)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;.font(.headline)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;.foregroundColor(.primary)&lt;/span&gt;&lt;br/&gt;  Text(item&lt;span&gt;.subtitle)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;.font(.subheadline)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;.foregroundColor(.secondary)&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不过，静态成员查找目前存在一个问题：不支持泛型函数中的协议成员，所以没有办法使用 &lt;code&gt;.&lt;/code&gt; 语法来调用，如 SwiftUI 定义了一个 toggleStyle 视图装饰器：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;extension&lt;/span&gt; &lt;span&gt;View&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;toggleStyle&lt;/span&gt;&lt;span&gt;&amp;lt;S: ToggleStyle&amp;gt;&lt;/span&gt;&lt;span&gt;(&lt;span&gt;_&lt;/span&gt; style: S)&lt;/span&gt;&lt;/span&gt; -&amp;gt; some &lt;span&gt;View&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;protocol&lt;/span&gt; &lt;span&gt;ToggleStyle&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  associatedtype &lt;span&gt;Body&lt;/span&gt;: &lt;span&gt;View&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;makeBody&lt;/span&gt;&lt;span&gt;(configuration: Configuration)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span&gt;Body&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;DefaultToggleStyle&lt;/span&gt;: &lt;span&gt;ToggleStyle&lt;/span&gt; &lt;/span&gt;{ ... }&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;SwitchToggleStyle&lt;/span&gt;: &lt;span&gt;ToggleStyle&lt;/span&gt; &lt;/span&gt;{ ... }&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;CheckboxToggleStyle&lt;/span&gt;: &lt;span&gt;ToggleStyle&lt;/span&gt; &lt;/span&gt;{ ... }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;目前的调用方式是，在使用 toggleStyle 修饰符时将具体类型以全名方式写入 ToggleStyle：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;Toggle&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;Wi-Fi&quot;&lt;/span&gt;, isOn: &lt;span&gt;$isWiFiEnabled&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;  .&lt;span&gt;&lt;span&gt;toggleStyle&lt;/span&gt;&lt;span&gt;(SwitchToggleStyle()&lt;/span&gt;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而这个 proposal 的目标是放宽对协议上访问静态成员的限制，让泛型 API 具有更好的可读性，即通过以下方式来调用：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;Toggle&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;Wi-Fi&quot;&lt;/span&gt;, isOn: &lt;span&gt;$isWiFiEnabled&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;  .&lt;span&gt;&lt;span&gt;toggleStyle&lt;/span&gt;&lt;span&gt;(.switch)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;https://github.com/apple/swift-evolution/blob/main/proposals/0299-extend-generic-static-member-lookup.md&lt;/p&gt;&lt;h3&gt;&lt;span&gt;SE-0300 异步任务与同步代码接口&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.28743169398907104&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3QD99b9DjVHbBCZDQxhGyBE06b6PwNDTroIeUTpqrZIFf2NLoaiaNiazWIKc1IeGHQ3NS2r2uBelTvGnMmrNmAsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1830&quot;/&gt;&lt;/p&gt;&lt;p&gt;异步 Swift 代码需要能够与使用诸如完成回调和委托方法之类的技术的现有同步代码一起工作以响应事件。异步任务可以将自己暂停，然后同步代码可以捕获并调用它们以响应事件来恢复任务。&lt;/p&gt;&lt;p&gt;标准库将提供 API 来获取当前异步任务的延续，这会挂起任务，并产生一个值，同步代码随后可以通过该值使用句柄来恢复任务。例如&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;beginOperation&lt;/span&gt;&lt;span&gt;(completion: &lt;span&gt;(OperationResult)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span&gt;Void&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以通过挂起任务并在调用回调时使用其连续性将其恢复为异步接口，然后将传递给回调的参数转换为异步函数的正常返回值：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;func operation() async -&amp;gt; &lt;span&gt;OperationResult&lt;/span&gt; {&lt;br/&gt;  // &lt;span&gt;Suspend&lt;/span&gt; the current task, &lt;span&gt;and&lt;/span&gt; pass its continuation into a closure&lt;br/&gt;  // that executes immediately&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; await withUnsafeContinuation { continuation &lt;span&gt;in&lt;/span&gt;&lt;br/&gt;    // &lt;span&gt;Invoke&lt;/span&gt; the synchronous callback-based &lt;span&gt;API&lt;/span&gt;...&lt;br/&gt;    beginOperation(completion: { &lt;span&gt;result&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;br/&gt;      // ...&lt;span&gt;and&lt;/span&gt; resume the continuation &lt;span&gt;when&lt;/span&gt; the callback &lt;span&gt;is&lt;/span&gt; invoked&lt;br/&gt;      continuation.resume(returning: &lt;span&gt;result&lt;/span&gt;)&lt;br/&gt;    }) &lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;https://github.com/apple/swift-evolution/blob/main/proposals/0300-continuation.md&lt;/p&gt;&lt;h3&gt;&lt;span&gt;SE-0304 结构化并发&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.24451754385964913&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3QD99b9DjVHbBCZDQxhGyBE06b6PwNDTcXz4mM7eRFr5hZyfAhaRyltdgFLDzt1qjgsJNzXnnEErRJXnO1lujA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1824&quot;/&gt;&lt;/p&gt;&lt;p&gt;async/await proposal 本向并没有引入并发性：它只是忽略异步函数中的挂起点，它将以与同步函数基本相同的方式执行。而这个 proposal 的目标就是在 Swift 中引入结构化并发的支持，并允许高效实现的模型来并发执行异步代码。&lt;/p&gt;&lt;p&gt;例如以下一段准备晚餐的代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;chopVegetables&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; async &lt;span&gt;throws&lt;/span&gt; -&amp;gt; [&lt;span&gt;Vegetable&lt;/span&gt;] { ... }&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;marinateMeat&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; async -&amp;gt; &lt;span&gt;Meat&lt;/span&gt; { ... }&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;preheatOven&lt;/span&gt;&lt;span&gt;(temperature: Double)&lt;/span&gt;&lt;/span&gt; async &lt;span&gt;throws&lt;/span&gt; -&amp;gt; &lt;span&gt;Oven&lt;/span&gt; { ... }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;makeDinner&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; async &lt;span&gt;throws&lt;/span&gt; -&amp;gt; &lt;span&gt;Meal&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; veggies = &lt;span&gt;try&lt;/span&gt; await chopVegetables()&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; meat = await marinateMeat()&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; oven = &lt;span&gt;try&lt;/span&gt; await preheatOven(temperature: &lt;span&gt;350&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; dish = &lt;span&gt;Dish&lt;/span&gt;(ingredients: [veggies, meat])&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;try&lt;/span&gt; await oven.cook(dish, duration: .hours(&lt;span&gt;3&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;makeDinner 中的每个步骤都是异步操作，不过整个流程每个点都会暂停，直到当前步骤完成。而为了更快地准备好晚餐，我们需要同时执行其中一些步骤，为此，可以将步骤分解为可以并行发生的不同任务。而这个 proposal 所提的结构化并发，就可以完成这种任务。proposal 中的概念很多，在此不详细介绍。在使用结构化并发对上述代码改造后，代码类似于以下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func &lt;span&gt;makeDinner&lt;/span&gt;(&lt;span/&gt;) &lt;span&gt;async&lt;/span&gt; throws -&amp;gt; Meal &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// Prepare some variables to receive results from our concurrent child tasks&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; veggies: [Vegetable]?&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; meat: Meat?&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; oven: Oven?&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;enum&lt;/span&gt; CookingStep { &lt;br/&gt;    &lt;span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;veggies&lt;/span&gt;(&lt;span&gt;[Vegetable]&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;meat&lt;/span&gt;(&lt;span&gt;Meat&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;oven&lt;/span&gt;(&lt;span&gt;Oven&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;// Create a task group to scope the lifetime of our three child tasks&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; await &lt;span&gt;withThrowingTaskGroup&lt;/span&gt;(&lt;span&gt;of: CookingStep.self&lt;/span&gt;) &lt;/span&gt;{ &lt;span&gt;group&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;group&lt;/span&gt;.&lt;span&gt;async&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;try&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; .veggies(chopVegetables())&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;group&lt;/span&gt;.&lt;span&gt;async&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;await&lt;/span&gt; .meat(marinateMeat())&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;group&lt;/span&gt;.&lt;span&gt;async&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;try&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; .oven(preheatOven(temperature: &lt;span&gt;350&lt;/span&gt;))&lt;br/&gt;    }&lt;br/&gt;                                             &lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;try&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; finishedStep &lt;span&gt;in&lt;/span&gt; &lt;span&gt;group&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;switch&lt;/span&gt; finishedStep {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; .veggies(&lt;span&gt;let&lt;/span&gt; v): veggies = v&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; .meat(&lt;span&gt;let&lt;/span&gt; m): meat = m&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; .oven(&lt;span&gt;let&lt;/span&gt; o): oven = o&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// If execution resumes normally after `withTaskGroup`, then we can assume&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// that all child tasks added to the group completed successfully. That means&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// we can confidently force-unwrap the variables containing the child task&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// results here.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; dish = Dish(ingredients: [veggies!, meat!])&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;try&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; oven!.cook(dish, duration: .hours(&lt;span&gt;3&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;https://github.com/apple/swift-evolution/blob/main/proposals/0304-structured-concurrency.md&lt;/p&gt;&lt;h3&gt;&lt;span&gt;SE-0306 Actors&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2994535519125683&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3QD99b9DjVHbBCZDQxhGyBE06b6PwNDTDRh1Ec4eU0Jx7rT0lo6qSKfufTIwW32Mpu022Rut01PHicY5MFxVuibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1830&quot;/&gt;&lt;/p&gt;&lt;p&gt;Swift 并发模型旨在提供一种安全的编程模型，该模型可静态检测数据竞争和其他常见的并发错误。结构化并发提议引入了一种定义并发任务的方法，并为函数和闭包提供了数据争用安全性。该模型适用于许多常见的设计模式，包括诸如并行映射和并发回调模式之类，但仅限于使用由闭包捕获的状态。&lt;/p&gt;&lt;p&gt;Swift 包含一些类，这些类提供了一种声明可变状态的机制，这些状态可以在程序之间共享。然而，类很难在并发程序中正确使用，需要手动同步以避免数据竞争。我们希望提供使用共享可变状态的功能，同时仍提供对数据竞争和其他常见并发错误的静态检测。&lt;/p&gt;&lt;p&gt;actor 模型定义了称为该角色的实体，非常适合此任务。Actor 允许声明并发域中包含的状态包，然后定义对其执行操作的多个操作。每个 actor 都通过数据隔离来保护自己的数据，从而确保即使在许多客户端同时发出参与者请求的情况下，在给定的时间也只有一个线程可以访问该数据。作为 Swift 并发模型的一部分，actor 提供了与结构化并发相同的竞争和内存安全属性。&lt;/p&gt;&lt;p&gt;actor 是一种引用类型，可保护对其可变状态的访问，并随关键字 actor 一起引入：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;actor BankAccount {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; accountNumber: &lt;span&gt;Int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; balance: &lt;span&gt;Double&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  init(accountNumber: &lt;span&gt;Int&lt;/span&gt;, initialDeposit: &lt;span&gt;Double&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;self&lt;/span&gt;.accountNumber = accountNumber&lt;br/&gt;    &lt;span&gt;self&lt;/span&gt;.balance = initialDeposit&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;像其他 Swift 类型一样，actor 可以有初始化器，方法，属性和下标。它们可以扩展并符合协议，可以是通用的，也可以与通用一起使用。&lt;/p&gt;&lt;p&gt;主要区别在于 actor 可以保护其状态免受数据争夺。这是 Swift 编译器通过强制使用 actor 及其实例成员的方式受到一系列限制而静态地强制实施的，统称为 actor 隔离。&lt;/p&gt;&lt;p&gt;https://github.com/apple/swift-evolution/blob/main/proposals/0306-actors.md&lt;/p&gt;&lt;h3&gt;&lt;span&gt;SE-0307 允许互换使用 CGFloat 和 Double 类型&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2888165038002172&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3QD99b9DjVHbBCZDQxhGyBE06b6PwNDTx3cKBX1icEqBFXAeOltAP6aNAQZ2lbXjb1QX3Iy9UEsr7W65LKiaH6wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1842&quot;/&gt;&lt;/p&gt;&lt;p&gt;Swift 首次发布时，CGFloat 的类型的使用就是一项挑战。当时，大多数 iOS 设备仍为 32 位。诸如 CoreGraphics 之类的 SDK 提供的 API 在 32 位平台上采用 32 位浮点值，在 64 位平台上采用 64 位值。首次引入这些 API 时，在 32 位平台上 32 位标量算术速度更快，但是到 Swift 发行时，情况已不再如此：直到今天， 64 位标量算术速度与 32 位一样快。甚至在 32 位平台上也是如此。之所以仍然保留了 32/64 位分割，主要是出于源和 ABI 稳定性的原因。&lt;/p&gt;&lt;p&gt;而这个 proposal 目标是允许 Double 和 CGFloat 类型通过将一种类型透明转换为另一种类型。&lt;/p&gt;&lt;p&gt;https://github.com/apple/swift-evolution/blob/main/proposals/0307-allow-interchangeable-use-of-double-cgfloat-types.md&lt;/p&gt;&lt;h3&gt;&lt;span&gt;SE-0308 #if 支持后缀成员表达式&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2793478260869565&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3QD99b9DjVHbBCZDQxhGyBE06b6PwNDTpZexDz9qB8MXK9XbGlpDg5O589mPjIo72sibOu2iafxoUFm5DqwhLKOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1840&quot;/&gt;&lt;/p&gt;&lt;p&gt;Swift 有条件编译块 &lt;code&gt;#if ... #endif&lt;/code&gt;，它允许根据一个或多个编译条件的值对代码进行条件编译。当前，与 C 语言中的 &lt;code&gt;#if&lt;/code&gt; 不同的是，每个子句的主体必须包含完整的语句。但是，在某些情况下，尤其是在结果生成器上下文中，出现了将 &lt;code&gt;#if&lt;/code&gt; 应用于部分表达式的需求。这个该 proposal 扩展了 &lt;code&gt;#if ... #endif&lt;/code&gt;以便能够包围后缀成员表达式。&lt;/p&gt;&lt;p&gt;例如当前使用的如下代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;VStack {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; basicView = Text(&lt;span&gt;&quot;something&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;#&lt;span&gt;if&lt;/span&gt; os(iOS)&lt;/span&gt;&lt;br/&gt;  basicView&lt;br/&gt;    .iOSSpecificModifier()&lt;br/&gt;    .commonModifier()&lt;br/&gt;&lt;span&gt;#&lt;span&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;  basicView&lt;br/&gt;    .commonModifier()&lt;br/&gt;&lt;span&gt;#&lt;span&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以改成以下这种方式&lt;/p&gt;&lt;pre&gt;&lt;code&gt;VStack {&lt;br/&gt;  Text(&lt;span&gt;&quot;something&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;#&lt;span&gt;if&lt;/span&gt; os(iOS)&lt;/span&gt;&lt;br/&gt;    .iOSSpecificModifier()&lt;br/&gt;&lt;span&gt;#&lt;span&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    .commonModifier()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;https://github.com/apple/swift-evolution/blob/main/proposals/0308-postfix-if-config-expressions.md&lt;/p&gt;&lt;h3&gt;&lt;span&gt;SE-0310 有效的只读属性&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.30345572354211664&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3QD99b9DjVHbBCZDQxhGyBE06b6PwNDT6mribFzRtcwlLpN6v9j9VeTAQib4qEZyA0soMqIZ7SkyXmAiaCDYX0pmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1852&quot;/&gt;&lt;/p&gt;&lt;p&gt;异步函数旨在用于可能会或始终会在返回之前暂停执行上下文切换的计算，但缺乏有效的只读计算属性和下标，因此这个 proposal 升级了 Swift 的只读属性以支持异步并单独或一起抛出关键字，从而使它们明显更灵活。&lt;/p&gt;&lt;p&gt;为了说明这一点，我们可以创建一个 BundleFile 结构体，尝试将其内容加载到应用程序的资源包中。由于文件可能不存在，或者可能存在但由于某种原因而无法读取，或者可能可读但太大，因此需要花费一些时间才能读取，因此我们可以将 contents 属性标记为异步抛出，如下所示：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;enum&lt;/span&gt; &lt;span&gt;FileError&lt;/span&gt;: &lt;span&gt;Error&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; missing, unreadable&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;BundleFile&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; filename: &lt;span&gt;String&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; contents: &lt;span&gt;String&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;get&lt;/span&gt; async &lt;span&gt;throws&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;guard&lt;/span&gt; &lt;span&gt;let&lt;/span&gt; url = &lt;span&gt;Bundle&lt;/span&gt;.main.url(forResource: filename, withExtension: &lt;span&gt;nil&lt;/span&gt;) &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;FileError&lt;/span&gt;.missing&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;try&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;(contentsOf: url)&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;FileError&lt;/span&gt;.unreadable&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为 content 既是异步的又是抛出的，所以我们在尝试读取它时必须使用 try await：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;printHighScores&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; async &lt;span&gt;throws&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; file = &lt;span&gt;BundleFile&lt;/span&gt;(filename: &lt;span&gt;&quot;highscores&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; await &lt;span&gt;print&lt;/span&gt;(file.contents)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;https://github.com/apple/swift-evolution/blob/main/proposals/0310-effectful-readonly-properties.md&lt;/p&gt;&lt;h3&gt;&lt;span&gt;SE-0316 全局 actors&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.24675324675324675&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3QD99b9DjVHbBCZDQxhGyBE06b6PwNDTzJfI2kic2ia5WD9QEY4Hf59eQ6vp24gp46BG7YAtcPvmwkIib1uBFw2xg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1848&quot;/&gt;&lt;/p&gt;&lt;p&gt;Actor 非常适合隔离实例数据，但是当需要隔离的数据分散在整个程序中，或者表示程序外部存在的某种状态时，将所有代码和数据都放入单个actor 实例中可能是不切实际的（例如，大型程序）甚至是不可能的（与那些假设无处不在的系统进行交互时）。&lt;/p&gt;&lt;p&gt;global actors 的主要目标是将 actor 模型应用于只能由主线程访问的状态和操作。在应用程序中，主线程通常负责执行主要的事件处理循环，该循环处理来自各种来源的事件并将其传递给应用程序代码。global actors 提供了一种机制，可以利用 actor 的角色来描述主线程，利用 Swift 的 actor 隔离模型来帮助正确使用主线程。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@MainActor&lt;/span&gt; var globalTextSize: &lt;span&gt;Int&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@MainActor&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;increaseTextSize&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; { &lt;/span&gt;&lt;br/&gt;  globalTextSize += &lt;span&gt;2&lt;/span&gt;   // okay: &lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;notOnTheMainActor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  globalTextSize = &lt;span&gt;12&lt;/span&gt;  // error: globalTextSize is isolated &lt;span&gt;to&lt;/span&gt; MainActor&lt;br/&gt;  increaseTextSize()   // error: increaseTextSize is isolated &lt;span&gt;to&lt;/span&gt; MainActor, cannot &lt;span&gt;call&lt;/span&gt; synchronously&lt;br/&gt;  await increaseTextSize() // okay: asynchronous &lt;span&gt;call&lt;/span&gt; hops over &lt;span&gt;to&lt;/span&gt; the main thread &lt;span&gt;and&lt;/span&gt; executes there&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;https://github.com/apple/swift-evolution/blob/main/proposals/0316-global-actors.md&lt;/p&gt;&lt;h3&gt;&lt;span&gt;SE-0317 async let bindings&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.25432900432900435&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3QD99b9DjVHbBCZDQxhGyBE06b6PwNDTkZN21zUASBiaOls4zHBYPoGtaj0pdiclI0XtNGZexTMkAuK2RDUpdz0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1848&quot;/&gt;&lt;/p&gt;&lt;p&gt;结构化并发提供了一个范式，用于在有范围的任务组中生成并发子任务，建立定义明确的任务层次结构，从而可以透明地处理并发管理的取消，错误传播，优先级管理和其他棘手的细节。&lt;/p&gt;&lt;p&gt;这个 proposal 旨在使用类似于 let 绑定的轻量级语法，使生成子任务的常规任务异步运行，并将最终结果传递给父任务。&lt;/p&gt;&lt;p&gt;还是以午餐为例，使用 &lt;code&gt;async let&lt;/code&gt;，那么代码看起来是下面这种：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func &lt;span&gt;makeDinner&lt;/span&gt;(&lt;span/&gt;) &lt;span&gt;async&lt;/span&gt; throws -&amp;gt; Meal &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;async&lt;/span&gt; &lt;span&gt;let&lt;/span&gt; veggies = chopVegetables()&lt;br/&gt;  &lt;span&gt;async&lt;/span&gt; &lt;span&gt;let&lt;/span&gt; meat = marinateMeat()&lt;br/&gt;  &lt;span&gt;async&lt;/span&gt; &lt;span&gt;let&lt;/span&gt; oven = preheatOven(temperature: &lt;span&gt;350&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; dish = Dish(ingredients: &lt;span&gt;await&lt;/span&gt; [&lt;span&gt;try&lt;/span&gt; veggies, meat])&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;try&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; oven.cook(dish, duration: .hours(&lt;span&gt;3&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;https://github.com/apple/swift-evolution/blob/main/proposals/0317-async-let.md&lt;/p&gt;&lt;h3&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;这里只是整理了部分在 Swift 5.5 中实现的 proposal 或者是在当前 main 快照中审核的 proposal。可以看到 async/await 及一些异步模型将会是 Swift 5.5 的重点内容。当然，最终 Swift 5.5 会新增哪些特性，还需要等最后的结果。也许 Swift 团队会将一些新特性放到 Swift 6 中发布。让我们期待一下 WWDC21 吧。&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;推荐阅读&lt;br/&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;☞  &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NzMwODI0MA==&amp;amp;mid=2647769621&amp;amp;idx=1&amp;amp;sn=5493c1125ce179808028c0740623c44f&amp;amp;chksm=8887b92abff0303c3522e3c0343fae6737528d812911c3defbabae0d4609017f9011130f70fd&amp;amp;token=2095692&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;为 iPad 部署基于 VS Code 的远程开发环境&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;☞  &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NzMwODI0MA==&amp;amp;mid=2647769636&amp;amp;idx=1&amp;amp;sn=cc1ce02a6f3313a037edf070e38c0787&amp;amp;chksm=8887b91bbff0300d3effe35dd1b2e6d56c1494645de734a5ce854971fa7b2e0fbc7d9e915bdf&amp;amp;token=2095692&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;“And away we code. ” WWDC21 超 200 个 Session 等着你&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;☞  &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NzMwODI0MA==&amp;amp;mid=2647769642&amp;amp;idx=1&amp;amp;sn=a3f30063345eea1ca10f8ca8abb62571&amp;amp;chksm=8887b915bff030032aab1de7081a7c5ba40310d206a528258c6909a126ee5ecd49fadadb1616&amp;amp;token=2095692&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Google 正式发布 Fuchsia OS，Flutter 集成尚存问题&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;☞  &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NzMwODI0MA==&amp;amp;mid=2647769644&amp;amp;idx=1&amp;amp;sn=d874e57b216d0f51701516d4b853da9a&amp;amp;chksm=8887b913bff03005c7bf5a7b83daeb0bab562b928c1c0e62316fa9857e2aa1b5c8a75af726d2&amp;amp;token=2095692&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;京东APP订单业务Swift优化总结&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;就差您点一下了 👇👇👇&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>346d2340a504e47e8535006e9dec0ee1</guid>
<title>渐进式 Unbundled 开发工具探索之路</title>
<link>https://toutiao.io/k/59gsxs1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;简短摘要：得益于现代浏览器内置了模块处理系统(ESM), 业界新兴开发工具 Snowpack、WMR、Vite 等直接将模块解析加载过程直接交给浏览器， Dev Server 能够秒级启动。和传统开发工具编译时解析加载模块最终打包到 JS Bundle 中相比，本地开发体验提升明显&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;传统 Bundled Development&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;复杂项目构建太慢&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业界主流的开发工具还是以 Webpack 为主，随着项目体积增大，开发阶段一次性将源代码和第三方依赖编译处理打包到一起的耗时会显著增加。在我们团队内部的 monorepo 仓库中，应用项目开发时，为了开发阶段调试方便，通常也会对一些公共库源码一起打包编译，成千上万个模块导致首次 dev server 启动耗时在几分钟甚至十几分钟，严重影响了开发效率与体验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Webpack 打包慢的问题相信也是大家都会遇到的问题。随手一搜，各种 Webpack 配置优化以及最佳实践之类的文档数不胜数。大部分也都是遵循  &lt;span&gt;Webpack&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; &lt;span&gt;Build Performance Guide&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;粗略一看上面的一些优化方式很多， 但是在我们的场景中很多都是不够通用，比如 thread-loader 结合 babel-loader 的方式在业务项目中经常会遇到报错的情况，原因是业务项目通常会使用 babel-plugin-import 针对业务内部的组件库按需加载组件以及样式，配置大致如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[&lt;br/&gt;  &lt;span&gt;&quot;babel-plugin-import&quot;&lt;/span&gt;,&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;libraryName&quot;&lt;/span&gt;: &lt;span&gt;&quot;custom-ui-components&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;style&quot;&lt;/span&gt;: (name: string, file: Object) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; `&lt;span&gt;${name}&lt;/span&gt;/style/2x`;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道 JavaScript 中线程间共享的数据必须序列化，上述 &lt;code&gt;style&lt;/code&gt; 函数在序列化时会直接报错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;esbuild 作为一个 bundle 工具性能很不错，但是针对应用生产环境打包还存在一些问题，如降级到 ES5，Code Split 、 CSS 处理等。社区内有提供替换 babel-loader 的 esbuild-loader, 通过 loader 的方式在 Webpack JS 运行时中编译单个文件的方式在速度上也不如单纯用 esbuild 一把梭快。对浏览器兼容性有要求的项目，平滑使用也比较困难。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;减少处理的模块数量方面，针对 MPA，简单的做法是在 dev 时显式指定需要开发的页面，但是比较局限不够灵活， Webpack 5 提供的实验性特性 Lazy Compilation 在开发阶段能够做到真正的按需编译提升 dev server 启动速度:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.26171875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyblazERCQCgGiayzlLicjo8kFf0fhlbQZyJDExWPwibm2byRUxSOPBRwcydzZsQqwcM7BYeK97bpDtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首次 dev server 启动时， 会代理 Webpack 入口以及 dynamic import 导出的模块，打开浏览器页面后，代理模块在运行时通过 Server-Send-Events 与 Lazy Compilation Backend Server 通信决定需要真正编译处理的资源。但是作为实验功能，目前还不是很稳定，笔者在使用时，遇到过初次打开页面白屏必须手动刷新的问题。而且后续对需要编译的入口通过 babel-loader 或者 ts-loader 重新编译打包时，仍然会有慢的问题存在。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Webpack 4 中通过插件 &lt;span&gt;lazy-compile-webpack-plugin&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt; 也可以实现类似的效果。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多的优化方式这里不一一列举， 总结下来，现有的一些 Webpack 打包优化方式或多或少都不够通用，或者存在一些问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;打包工具之上的探索&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;沿着减少 Webpack 处理模块数量的思路，node_modules 下的第三方依赖如果能够从打包环节剔除，仅对业务代码打包，对构建速度肯定会有明显的提升。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较常见的方法是将常用的第三方库在 Webpack 构建时配置 external， Html 中直接通过 script 标签引入 UMD 产物, 这种方式有以下问题:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;每个依赖的 UMD 产物会增加额外的一段兼容代码，造成冗余。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;浏览器中直接使用可能会污染全局变量，以及容易被修改覆盖。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;很多公司内部包，并没有提供 UMD 产物。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然 UMD 产物不太符合我们的场景，那么直接替换依赖为对应的 ESM 产物呢？业界也有类似的思路:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Rollup 社区有 &lt;span&gt;rollup-plugin-cdn&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt; 支持代码中从 unpkg 引入依赖的 ESM 产物:&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import hyper from &lt;span&gt;&#x27;https://unpkg.com/hyperhtml@latest/esm/index.js&#x27;&lt;/span&gt;;&lt;br/&gt;hyper(document.body)`&lt;br/&gt;  &amp;lt;h1&amp;gt;Hello ESM&amp;lt;/h1&amp;gt;`;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Pika（Skypack 前身）提供了 &lt;span&gt;@pika/cdn-webpack-plugin&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt; 支持生产环境构建时将 package.json 中的依赖替换为 Pika CDN 上对应的链接，同时 html 中通过 &lt;code&gt;script type=module&lt;/code&gt; 加载打包后的 js 产物, 以 React 为例在最终 JS Chunk 中大致如下:&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; import __mun2tz2a_default, * as __mun2tz2a_all from &lt;span&gt;&quot;https://cdn.skypack.dev/react&quot;&lt;/span&gt;;&lt;br/&gt;    window[&lt;span&gt;&quot;https://cdn.skypack.dev/react&quot;&lt;/span&gt;] = Object.assign((__mun2tz2a_default || {}), __mun2tz2a_all);&lt;br/&gt;(window[&lt;span&gt;&quot;webpackJsonptask_activity&quot;&lt;/span&gt;] = window[&lt;span&gt;&quot;webpackJsonptask_activity&quot;&lt;/span&gt;] || []).push([[&lt;span&gt;&quot;vendors&quot;&lt;/span&gt;],{&lt;br/&gt; /***/ &lt;span&gt;&quot;50ab&quot;&lt;/span&gt;:&lt;br/&gt;/*!****************************************!*\&lt;br/&gt;  !*** ./node_modules/__pika__/react.js ***!&lt;br/&gt;  \****************************************/&lt;br/&gt;/*! no static exports found */&lt;br/&gt;/***/ (&lt;span&gt;function&lt;/span&gt;(module, exports) {&lt;br/&gt;module.exports = window[&lt;span&gt;&quot;https://cdn.skypack.dev/react&quot;&lt;/span&gt;];&lt;br/&gt;/***/ }),&lt;br/&gt;}])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到利用浏览器对 ESM 的原生支持，直接从 Skypack CDN import 导入 React ，之后以全局变量的方式挂到 window 变量上。其他模块中导入 React ，最终会是 window 上存在的变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考虑到我们主要是想提升 dev server 启动时构建的速度，并且很多依赖都是公司内部包，笔者在 &lt;span&gt;@pika/cdn-webpack-plugin&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt; 的基础上，结合团队内部的 CJS 转 ESM 服务，在 dev 环节将用到的第三方依赖改成从线上 import 导入。最终在实际业务项目中测试效果并不理想，主要有以下一些问题:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第三方依赖以及依赖的依赖都会直接在浏览器中请求，请求数量成指数增长，浏览器中白屏时间过长，甚至请求数量会直接爆炸，运行报错。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;速度上面，一些项目确实能够在 6s 左右 dev 完成，但是在一些比较大的内部 monorepo 中，仍然是需要几十秒的时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CJS 转 ESM 中间的坑太多: 大部分依赖都还是只提供了 CJS 版本，在转换过程中不论是用 rollup-plugin-commonjs 还是 esbuild ，一些问题都避免不了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同样会污染全局变量。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Webpack 生态基础上将第三方依赖以 ESM 形式直接加载看起来也不太能满足我们的场景，那么如何更好地提升 dev server 启动速度呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;迈入 Unbundled Development&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;业界现状&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 ESM 的现代 unbundled 开发工具在社区如雨后春笋不断发展，es-dev-server、Snowpack 、Wmr 、Vite 等工具直接直接抛弃 Webpack，通过内部的 Dev Server 接收请求后实时对 JS、TS、CSS 等资源实时编译处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5671875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyblazERCQCgGiayzlLicjo8kYtgyyGVib6ibnztj5L7S3DdXibZjTsp6jNSic6xicaAVdsg7ZicRcP8ibuCTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;图片来自 Snowpack 官网: https://www.snowpack.dev/concepts/how-snowpack-works&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和 Webpack 等打包工具相比，这类的 unbundled 开发工具有如下优点:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;飞快的启动速度：dev server 启动时仅需要对依赖预处理编译成 ESM 格式，一次处理之后，后续依赖没有变化时，可以做到秒级启动，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实时按需编译：运行时浏览器第一次请求对应模块时，dev server 本地实时编译处理返回对应内容。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更快的热更新：针对具体修改的文件，根据模块的依赖关系图， 逐步向上寻找 accept 该模块 HMR 更新的文件，重新请求文件内容。和 Webpack 的热更新需要重新整体构建相比会更快。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种新兴 Unbundled Development 模式看着能够满足我们对 dev server 启动速度的需求，下面的问题就是针对使用我们内部应用开发工具的业务项目来说如何平滑的接入这些工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于我们的应用开发工具提供了一套现代 Web 项目开发范式，从应用入口和各种资源的处理使用，以及服务端 API 的一体化调用上都有内部一些标准。直接在项目中使用上述工具会有很多问题，免不了对上面的工具进行二次开发，这就要求这些工具提供足够灵活的扩展自定义方式，这里就业界用的比较多的 Snowpack 和 Vite 2.0 简单对比如下:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;156&quot; data-backw=&quot;558&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;156&quot; data-ratio=&quot;0.2800480769230769&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyblazERCQCgGiayzlLicjo8kV0qC5L8eZrT0Guk4ccRJeUNWQzboIiaPkQgo9y01ibiaBibOeqrVhOHH8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1664&quot;/&gt;（点击查看大图）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的简单对比，以及文档丰富程度上来看， Vite 2.0 扩展起来会更加灵活方便。因此在给我们的应用开发工具提供 Unbundled Development 模式前期，也是果断选择了 Vite 2.0 作为底层， 但是最终实现版本里面我们选择借鉴 Vite、Wmr 等工具自主开发实现 dev server 部分，主要有以下几个角度的考虑:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;依赖预处理过程需要深度定制：一些公司内部包需要特殊处理，这部分我们最终决定放到内部的 CJS 转 ESM 服务上，同一个 package 的具体版本，只会处理一次，后续使用时直接下载转换后的产物即可。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;深度定制需求：在我们的设计体系里面，用户并不会直接接触到具体底层工具的配置，比如 babel.config.js、postcss.config.js 等，而是集中在我们提供的配置文件进行自定义的需求。Vite 2.0 本身是支持这些文件的加载，另一方面具体资源文件处理的标准也有不同的地方，比如 CSS Modules 处理上，我们默认支持文件后缀 &lt;code&gt;.module.css&lt;/code&gt; 的形式，也支持关闭文件后缀的约定。这些有的可以通过配置实现，但是大部分还是要接管 Vite 内部的资源的编译处理过程，如果通过 Vite 提供的插件可以完成，这样对 Vite 利用不是很充分，也显得比较冗余。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后续维护与发展：初期我们打算提供基本的 dev server 解决开发环节慢的问题，后期需要结合已有 SSR、SSG 等建设补齐对应的能力。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上，实现 Unbundled Dev Server 对我们来说更容易维护以及后续添加一些能力更方便。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Unbundled Dev Server 原理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更好的理解 Unbudled 开发工具的细节，我们从下面几个方面分别介绍:&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;依赖预处理&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文我们提到，业务项目中使用到的依赖很多只提供了 CJS 产物， 首先，我们需要将第三方依赖转换成 ESM 格式。业界常用的工具主要是 Rollup 和 esbuild 等构建工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本思路是分析项目源码中使用到的依赖， 这些依赖作为构建工具的入口整体打包，好处是整体将依赖打包得到 common chunks，浏览器中打开页面加载第三方依赖的请求数量会少很多。缺点是添加依赖或者删除一些依赖改动了 package.json 或者 lock 文件时， 需要重新对依赖编译打包，在一些比较大的中后台项目中，依赖预处理耗时还是存在的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们目前采用的方案是，沿用之前内部已有的 CJS 转 ESM 服务，直接下载线上依赖已经转换好的的 ESM 产物。后续针对下载的 ESM 文件，用 esbuild 做一次 bundle 减少浏览器中运行的请求数量。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.65234375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyblazERCQCgGiayzlLicjo8k8zYwIcWBXSQbSfedqZ4C8yAm90HoV4w1xn6xP0aoaiajnr3vEsIkudw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;借助 CJS 转ESM 服务和直接本地编译转换相比，有以下好处:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首次对项目依赖预处理之后，后续添加依赖只需要从云端下载新添加的依赖 ESM 产物，之后借助 esbuild 重新 bundle 耗时也不会很多。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一些需要特殊处理的第三方依赖，统一在云端处理修复，业务项目不依赖开发工具的发版升级。针对一些通用的处理场景，我们会提供 UI 界面引导用户输入依赖对应信息，自动修复。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CJS 到 ESM 转换的产物可以在本地全局缓存，跨项目复用已经编译好的产物， 也就是说，随着使用项目增加，云端和本地双重缓存级联，能够大幅度减少 CJS 转 ESM 的时间。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时我们针对内部模块比较多的依赖，如 antd，在线上 CJS 转 ESM 时，会将内部模块打包到单个产物中，这样能减少成百上千的网络请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以 React 为例， 直接从云端下载的 ESM 产物内容截图如下:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.184375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyblazERCQCgGiayzlLicjo8kUpUYCsWzF4bswfEZanXYsjsrQCsyqmKxkKfyc7ibk3rd42dHy0oKIiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到依赖项 object-assign 会额外带有版本号信息。在递归下载第三方依赖 ESM 文件后，能够得到如下的 json 文件，存储某个版本依赖实际 ESM 文件的路径, 如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;   &lt;span&gt;&quot;react?16.14.0&quot;&lt;/span&gt;: &lt;span&gt;&quot;/Library/Caches/__web_modules__/react@16.14.0.js&quot;&lt;/span&gt;,&lt;br/&gt;   &lt;span&gt;&quot;react-dom?16.14.0&quot;&lt;/span&gt;: &lt;span&gt;&quot;/Library/Caches/__web_modules__/react-dom@16.14.0.js&quot;&lt;/span&gt;,&lt;br/&gt;   &lt;span&gt;&quot;object-assign?4.1.1&quot;&lt;/span&gt;: &lt;span&gt;&quot;/Library/Caches/__web_modules__/object-assign@4.1.1.js&quot;&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;版本号是直接在 node_modules 中解析对应依赖位置获取的，也就是说，项目下存在某个依赖多个版本也是支持的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后通过 esbuild 打包时借助 onResolve hook 从上面的 json 文件中匹配具体的 ESM 文件路径, 示例代码如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const bundleResult = await require(&lt;span&gt;&#x27;esbuild&#x27;&lt;/span&gt;).build({&lt;br/&gt;    entryPoints: [&lt;span&gt;&#x27;react&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;react-dom&#x27;&lt;/span&gt;],&lt;br/&gt;    bundle: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;    splitting: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;    chunkNames: &lt;span&gt;&#x27;chunks/[name]-[hash]&#x27;&lt;/span&gt;,&lt;br/&gt;    metafile: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;    outdir: webModulesDir,&lt;br/&gt;    format: &lt;span&gt;&#x27;esm&#x27;&lt;/span&gt;,&lt;br/&gt;    treeShaking: &lt;span&gt;&#x27;ignore-annotations&#x27;&lt;/span&gt;,&lt;br/&gt;    plugins: [&lt;br/&gt;      {&lt;br/&gt;         name: &lt;span&gt;&#x27;resolve-deps-plugin&#x27;&lt;/span&gt;,&lt;br/&gt;         setup(build) {&lt;br/&gt;            build.onResolve({filter: /^/}, async args =&amp;gt; {&lt;br/&gt;               const { kind, path } = args;&lt;br/&gt;               &lt;span&gt;if&lt;/span&gt; ([&lt;span&gt;&#x27;import-statement&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;entry-point&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;dynamic-import&#x27;&lt;/span&gt;].includes(kind)) {&lt;br/&gt;                 &lt;span&gt;if&lt;/span&gt; (kind === &lt;span&gt;&#x27;entrypoint&#x27;&lt;/span&gt;) {&lt;br/&gt;                   //  针对 bundle 入口， 直接本地 resolve 得到版本号&lt;br/&gt;                   // 在上面的 json 文件中拿到具体路径返回&lt;br/&gt;                 } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (path.startsWith(&lt;span&gt;&#x27;/esm/bv&#x27;&lt;/span&gt;)) {&lt;br/&gt;                   // 针对依赖的依赖，比如 object-assign^4.1.1&lt;br/&gt;                   // 通过 semver 在文件中匹配获取实际的 ESM 文件路径返回&lt;br/&gt;                 }&lt;br/&gt;               }&lt;br/&gt;            })&lt;br/&gt;         }&lt;br/&gt;      }&lt;br/&gt;    ]&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，依赖预处理已经完成了，最终通过 &lt;code&gt;bundleResult.metafile&lt;/code&gt; 能够得到我们最终的 import-map.json 后续在请求模块时用来解析模块依赖路径到转换后的 esm 文件， 目录结构和内容大致如下:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2980209545983702&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyblazERCQCgGiayzlLicjo8kDiaRK6XCdcgFyADqQN2BAkh8OHLIIqeLjO6gQzgGABCeQ9kCSqy8L2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;859&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对 monorepo 中某些 package 并不发布，在应用中直接使用源码统一构建的场景， 在分析使用到的依赖时，也会收集这些 package 用到的依赖，统一预处理成 ESM 格式。某些 package build 后提供产物在应用中使用时，会根据当前 package 最新代码， 本地实时编译转换成 ESM，这里本地编译转换和云端会复用底层代码，效果上也类似。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;资源文件处理&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体 Server 的实现部分借鉴了 WMR 和 Vite 的 插件系统设计， Plugin 作为 Rollup Plugin 的超集，通过 Plugin Container 提供统一的插件接口， 和 Snowpack、es-dev-server 在 Server 中间件中处理请求、文件转换不同，WMR 、Vite 的插件体系将文件转换以及 Server 中间件分离开来，概念上比较清晰， 也比较易于维护。WMR、Vite 这种插件系统也有利于 dev 和 build 时复用文件转换相关的逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从浏览器发出请求到 Server 返回对应资源的流程如下图所示:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46328125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyblazERCQCgGiayzlLicjo8kfoqwCM1w3qHRCZJh6n87kbCcPlGRvkncY7Ce96HlFHbFqQhFLWNDcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 resolveId hook 中根据 url 解析出具体文件路径。load hook 主要加载文件内容。transform hook 是编译转换各种类型资源文件的核心。下面对几种资源文件在 Server 内部的处理展开描述:&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;JSX/TSX 编译转换&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道 JSX或 TSX 不能直接在浏览器中运行，这里因为 dev 环节对浏览器兼容性没有要求以及追求更快的实时编译速度，直接使用 esbuild transform 即可:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const result = await esbuild.transform(code, {&lt;br/&gt;  loader: &lt;span&gt;&#x27;tsx&#x27;&lt;/span&gt;,&lt;br/&gt;  sourcefile: importer,&lt;br/&gt;  sourcemap: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  target: &lt;span&gt;&#x27;chrome63&#x27;&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在业务项目中实践时，遇到的一些问题举例如下:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;esbuild 不支持 React 17 jsx transformer，inject 配置选项 transform api 也没有提供，当业务项目使用 React 版本为 17 时，并且没有显示导入 React 时， 我们在 esbuild transform 的结果上自动注入 &lt;code&gt;import React from &#x27;react&#x27;&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务 TS 项目中有很多使用了 const enum 导致 esbuild 无法处理，只能切换到 typescript api 处理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老项目业务代码中依赖 babel 生态的插件， 比如 &lt;span&gt;babel-plugin-macros&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;， 这就导致我们额外需要提供 babel 编译的流程。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基础的语法转换完成后，接下来就是 Bare Import 的处理问题，我们的业务代码中直接通过包名导入依赖的方式经过打包工具处理能够正常运行, 如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import React from &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是在浏览器中直接运行会直接报错， &lt;span&gt;import-maps&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt; 提案可以解决这个问题，但是只有最新版本 Chrome 支持。这里我们采用的方案和业界的做法一致，编译完成后改写 import 语句, 以 React 为例, 最终返回的内容如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import React from &lt;span&gt;&quot;/node_modules/.web_modules/react.js&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;node_modules/.web_modules&lt;/code&gt; 目录就是我们在依赖预处理时生成的第三方依赖 ESM 文件目录。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;CSS、JSON、图片等资源处理&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;浏览器中直接 import 导入资源，要求返回的类型是 &lt;code&gt;application/javascript&lt;/code&gt;，因此这些文件在对应的插件中最终都会被处理成 JavaScript。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CSS 默认会用 PostCSS 处理之后直接创建 style 标签插入 head 节点就能生效，以 &lt;code&gt;import ./App.css&lt;/code&gt; 为例，返回的内容大致如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// src/App.css&lt;br/&gt;const code = &lt;span&gt;&quot;body {\n  margin: 0;\n}\n&quot;&lt;/span&gt;&lt;br/&gt;const filename = &lt;span&gt;&quot;/Users/songzhenwei/Documents/test/full-demo/src/App.css&quot;&lt;/span&gt;&lt;br/&gt;const styleEl = document.createElement(&lt;span&gt;&#x27;style&#x27;&lt;/span&gt;);&lt;br/&gt;const codeEl = document.createTextNode(code);&lt;br/&gt;styleEl.type = &lt;span&gt;&#x27;text/css&#x27;&lt;/span&gt;;&lt;br/&gt;styleEl.appendChild(codeEl);&lt;br/&gt;document.head.appendChild(styleEl);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里只是简单展示返回文件的内容，真正可用还需要考虑热更新时 Style 标签的删除、CSS 文件中通过 [url function](&amp;lt;https://developer.mozilla.org/en-US/docs/Web/CSS/url( &quot;url function&quot;)&amp;gt;) 加载字体图片等场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JSON 文件比较简单，这里我们只需要读取文件 default 导出即可:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; default { &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;example&quot;&lt;/span&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务代码中使用图片等资源时, 我们会在 import 语句后面添加 &lt;code&gt;?assets&lt;/code&gt; query 表示为资源请求需要编译处理, 如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import logo from &lt;span&gt;&#x27;./logo.png&#x27;&lt;/span&gt;;&lt;br/&gt;// =&amp;gt; rewrite to &lt;br/&gt;import logo from &lt;span&gt;&#x27;/src/logo.png?assets&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;/src/logo.png?assets&lt;/code&gt; 直接返回对应资源的实际 url 即可:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; default &lt;span&gt;&#x27;/src/logo.png&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于图片资源，实际业务场景中我们还需要支持根据文件尺寸决定是否通过 base64 编码内联、svgr 等特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里通过不同的插件完成了一些文件类型的编译转换，页面已经可以在浏览器中正确渲染。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;热更新功能&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Webpack 等打包工具里面，热更新相关代码通常写在入口文件内如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// src/index.jsx&lt;br/&gt;import App from &lt;span&gt;&#x27;./App&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;module.hot.accept(&lt;span&gt;&#x27;./App&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;   renderApp();&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;App 根组件中引用到的文件修改时，会触发入口文件中注册的 accept 回调函数重新渲染 App 组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ESM 场景下的 HMR API, 业界也有一些规范：Snowpack 联合 Vue、Preact 提出了 &lt;span&gt;ESM-HMR Spec&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;，类似 &lt;code&gt;module.hot&lt;/code&gt;， unbundled 开发工具需要提供 &lt;code&gt;import.meta.hot&lt;/code&gt; 对象，比如常用的 &lt;code&gt;accept&lt;/code&gt; 函数使用如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import.meta.hot.accept();&lt;br/&gt;&lt;br/&gt;import.meta.hot.accept([&lt;span&gt;&#x27;./dep1&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;./dep2&#x27;&lt;/span&gt;], ()=&amp;gt; {})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分实现参考了 Snowpack 和 Vite ， 文件更新时，通过内部建立好的依赖关系，上溯至 accept 该文件或自身的文件节点，重新在浏览器请求该文件， 如下图:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.678125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyblazERCQCgGiayzlLicjo8kOyEdgzMwu3cAHd21jv6uW3XXGOFvKKqVCM0BicriaX7IOw0LPFGACHGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改 &lt;code&gt;dep-b.js&lt;/code&gt; 向上遍历依赖树时，找到 accept 的文件节点 &lt;code&gt;App.tsx&lt;/code&gt; , 同时会依赖路径上文件节点的编译缓存失效，之后通过 HMR client api 重新请求 &lt;code&gt;App.tsx&lt;/code&gt; ，为了保证返回的内容是最新的，重新请求时会加上时间戳。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和 Webpack 等打包工具热更新相比，Unbundled Development 开发工具热更新只会重新编译加载依赖路径上的文件， 因此速度也会更快。同时也能结合 React Fast Refresh 做组件级别的热更新。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面通过一些小点，介绍了我们内部解决 Webpack 打包慢的一些探索以及最终实现 Unbundled Development 模式的一些做法， 最终实现的版本和我们应用开发的标准范式一一对齐。在业务项目中使用 Unbundled Development 模式后开发体验有很大提升:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6036960985626283&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyblazERCQCgGiayzlLicjo8kK6nGZpQEo5hKFNDrvd5s5lgtG6Dy8hgrOky1mD2RQia4RLBLP8zbgkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;974&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产环境现阶段还是通过 Webpack 打包出 JS Bundle ，在一些基础编译能力以及使用方式上尽最大努力抹平 Unbundled Development 模式和生产环境 Webpack 打包的差异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过实际业务项目接入 Unbundled Development 模式实践，我们这边也针对 CJS 转 ESM 积累了一定的解决方案。通过云端统一处理的方式，后续也能发挥出更大的作用。一些新的方案如免依赖安装也在持续探索中，最后，我们也希望能对 Unbundled Development 生态添砖加瓦，最后反哺生态。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Webpack: &lt;em&gt;https://webpack.js.org/guides/build-performance/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;Build Performance Guide: &lt;em&gt;https://webpack.js.org/guides/build-performance/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;lazy-compile-webpack-plugin: &lt;em&gt;https://github.com/liximomo/lazy-compile-webpack-plugin&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;rollup-plugin-cdn: &lt;em&gt;https://github.com/WebReflection/rollup-plugin-cdn&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;@pika/cdn-webpack-plugin: &lt;em&gt;https://www.npmjs.com/package/@pika/cdn-webpack-plugin&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;@pika/cdn-webpack-plugin: &lt;em&gt;https://www.npmjs.com/package/@pika/cdn-webpack-plugin&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;babel-plugin-macros: &lt;em&gt;https://github.com/kentcdodds/babel-plugin-macros&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;import-maps: &lt;em&gt;https://github.com/WICG/import-maps#the-basic-idea&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;ESM-HMR Spec: &lt;em&gt;https://github.com/snowpackjs/esm-hmr&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>15bc83d182f26b0756f8ba6a58b2474b</guid>
<title>[推荐] 有了这款运维自动化神器，可以抛弃 Ansible 了</title>
<link>https://toutiao.io/k/d139zzl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;span&gt;△点击上方“&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Python猫&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;”关注 ，回复“&lt;/span&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;”领取电子书&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5820568927789934&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LLRiaS9YfFTOMxUibn1y4x16tmFKvia0O6Wm3aSVibvTT02x5NKGQxmPV1ezLcOluTz5iavAQ44BvibFxichCAlZTqEicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;914&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;文末赠书&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作者：九净&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来源：NetDevOps加油站&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天开始一个新的大坑，绝对是巨坑了，给大家安利一款网络运维自动化工具Nornir（北欧神话里的命运女神三姐妹的名字）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提起运维自动化的工具，扛把子目前还是ansible。究其原因还是高度的封装，良好的生态，基于这两个大杀器，简单写个yaml文件就可以编排出一个符合我们预期的自动化场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，看过我文章的小伙伴都知道，我对ansible是爱恨交加，大爱无言，就此掠过，我就说说“恨”：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;国产网络设备的适配之路，难于上青天，说多了都是泪，国产的除了华为官方支持，其他的我真是见不到了。基于ssh采集设备信息时没大问题，但是配置起来，那就是几乎不敢用，因为网络配置回显提示不断在变化，low level的调用，无法加以分情况的判断。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能问题，逻辑设计过于复杂，层层的调用等各种原因导致其性能不佳，主要体现在并发不行，执行效率略低，大家对之诟病不少。如果网络设备多点，就得多弄几台服务器了。也有人提出ansible可以调优，但是对于大多数用户来说，过于复杂。性能问题也主要针对一个中大型的网络环境，其实几台设备，无所谓效率，for循环就可以了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;它想简化或者弱化编程语言的内容，倡导低代码开发，但是在一些复杂场景，个人觉得适得其反，循环判断等的使用，让人感觉犬牙交错，不如if else while for等简单快捷易读。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ansible是基于Python开发的，我感觉是有点矛盾的，有时候刻意的弱化Python，某些情况下debug及其麻烦，如果能用pycharm debug一个脚本该多好；有时候又宣称是Python开发的，可以二次开发，自己写一些module，但是这个过程又是debug麻烦，且封装的过于高深，用户自己开发的时候，我觉得门槛过高。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不一一列举了，再写，这篇文章又偏了，可以改成细数ansible在略微复杂的网络中运维自动化的N种罪状。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Nornir简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回归主题，介于以上种种，作为一个懂点Python的网络工程师，我们有没有一个更好的工具呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是有的，开题就告诉了大家，我们今天的主角闪亮登场——Nornir！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nornir是一个用python编写的自动化框架，主要是针对网络运维自动化，只要你懂一点点Python，就可以非常方便的使用nornir了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于Nornir允许用户使用纯Python代码，所以我们可以使用与其他Python代码相同的方法对其进行故障排除和调试，这就解决了那些低代码的自动化工具的调试和排障困难的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nornir自比是自动化界的Flask，侧面反映它的强大与灵活。（笔者是一个django的死忠粉，手动狗头）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;flask是一个Python的web开发框架，flask没有限制过多的接口，所以用户可以基于恰到好处的接口，基于自己的方式构建一个功能强大的web网站。nornir也是同样的事情，它无外乎实现了几种核心的功能，比如管理好资产、变量，内置一些与设备的常见的连接方式，自动关联并批量执行、支持插件这些自动化框架最基本的功能，你可以写自己的各种插件，实现任何你想实现的功能，而且是基于Python的，想想就让人很兴奋，再也不用去看那些过于复杂的playbook或者类似的配置文件了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了这么多，我们来看看nornir的runbook长什么样子吧。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; nornir &lt;span&gt;import&lt;/span&gt; InitNornir&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; nornir_utils.plugins.functions &lt;span&gt;import&lt;/span&gt; print_result&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; nornir_napalm.plugins.tasks &lt;span&gt;import&lt;/span&gt; napalm_get&lt;br/&gt;&lt;br/&gt;nr = InitNornir(&lt;br/&gt;    config_file=&lt;span&gt;&quot;nornir.yaml&quot;&lt;/span&gt;, dry_run=&lt;span&gt;True&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;results = nr.run(&lt;br/&gt;    task=napalm_get, getters=[&lt;span&gt;&quot;facts&quot;&lt;/span&gt;, &lt;span&gt;&quot;interfaces&quot;&lt;/span&gt;]&lt;br/&gt;)&lt;br/&gt;print_result(results)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上是一个简单的官方示例，通过一个官方的内置插件nornir_napalm（其实需要单独安装，并不在本体里），集成了napalm（这又是一个我要吐槽的工具包，功能甚少，缺乏高层构建，改天再写写文章）。通过napalm获取了端口和基本的fact信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从代码上来看，清晰易读，加载了nornir的yaml配置文件，获取设备的清单及其他变量分组等等，然后全部设备批量执行信息获取，输出结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个代码，核心逻辑实际只有1行，获取信息，比ansible的，我觉得要简单好多，对于一个稍微懂点Python的网工而言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于绝大多数的使用，nornir不需要用户知道过多的python知识，什么并发、异步、写log、回调，统统都走开，你只需要会最基本的Python技能即可，知晓基本的&lt;strong&gt;数据类型、定义变量、循环、判断、函数的定义与使用&lt;/strong&gt;，基本就足够了。Noinir也是这样主张的，Python其实是一门易上手的语言，但是任务编程语言的精通都是需要时间和精力的。但是幸运的是，作为网络工程师，我们只是想写一些脚本，实现自动化，并不是要成为一位master。所以Nornir认为我们掌握基本的Python知识即可。（对于绝大多数网络运维工程师，我觉得这个是适用的，有意精通此道的，仍需不断努力精进）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说实话，作为一名NetDevOps工程师，多进程、多线程、协程等等这些我在日常中几乎没有使用过，包括我也从来没写过这方面的内容，因为我认为这块对于一个网络运维工程师来说，过于深奥，使用起来坑很多，其实是过于简单的使用并发推配置，我都是坚决反对的，无知者无畏，对于生产中的网络配置，我从来都是怀揣着一颗敬畏之心。我也推荐大家使用一些自动化框架或者其他工具实现并发，同时如果是推送配置，一定要慎重，可以的话尽量设计的是有检查机制或者可以终止的，防止手抖了后没有后悔的机会，不行连并发都别用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Nornir的安装、版本及插件说明&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方是建议大家使用虚拟环境安装的，我也建议大家使用虚拟环境安装，因为它里面的很多版本管理的比较精细，不建议放到我们的系统或者自己常用的Python环境中去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它支持3.6.2及以上的Python版本，这点我表示很赞，就不该给python2活路，赶紧演进。我建议大家使用3.7、3.8的版本。之前也讲过，我们用的Python都是最基础的Python知识，所以脚本的版本兼容会比较好一些。笔者使用的是3.8.3的版本，究竟原因，是因为我懒，装了一个anaconda。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本系列讲的是基于Nornir3.0.0这个版本，同时解释一下，网上关于Nornir的讲解本来就少（基本都是国外的），大多数是基于2.4和2.5的版本，3.0版本今年才发布（2020年），发生了一些变化，导致了一些配置文件的不兼容，所以大家不管是看我的还是其他人的视频或者文章也好，一定要留意版本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老规矩，&lt;code&gt;pip install nornir&lt;/code&gt;即可安装&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; pip install nornir&lt;/span&gt;&lt;br/&gt;Collecting nornir&lt;br/&gt;  Downloading nornir-3.0.0-py3-none-any.whl (28 kB)&lt;br/&gt;Requirement already satisfied: typing_extensions&amp;lt;4.0,&amp;gt;=3.7 in /home/dbarroso/.virtualenvs/tmp-nornir/lib/python3.8/site-packages (from nornir) (3.7.4.2)&lt;br/&gt;Requirement already satisfied: mypy_extensions&amp;lt;0.5.0,&amp;gt;=0.4.1 in /home/dbarroso/.virtualenvs/tmp-nornir/lib/python3.8/site-packages (from nornir) (0.4.3)&lt;br/&gt;Collecting ruamel.yaml&amp;lt;0.17,&amp;gt;=0.16&lt;br/&gt;  Using cached ruamel.yaml-0.16.10-py2.py3-none-any.whl (111 kB)&lt;br/&gt;Collecting ruamel.yaml.clib&amp;gt;=0.1.2; platform_python_implementation == &quot;CPython&quot; and python_version &amp;lt; &quot;3.9&quot;&lt;br/&gt;  Using cached ruamel.yaml.clib-0.2.0-cp38-cp38-manylinux1_x86_64.whl (578 kB)&lt;br/&gt;Installing collected packages: colorama, ruamel.yaml.clib, ruamel.yaml, nornir&lt;br/&gt;Successfully installed nornir-3.0.0 ruamel.yaml-0.16.10 ruamel.yaml.clib-0.2.0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装之后，可以打开ipython试试，没报错即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ python&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; nornir &lt;span&gt;import&lt;/span&gt; InitNornir&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于插件，我们也得唠唠，2.4 2.5的时候，很多东西都是内置的，但是3.0版本发生了很大的变化，官方把一些插件，分拆了出去，nornir变得更加纯粹了。比如以前的时候nornir支持netmiko和napalm等，现在统统分拆出去了，创建了新工具包，比如nornir_napalm就是nornir的一个对napalm封装，同样的也有nornir_netmiko，很多很多工具包都被这样分解出去了。有点像flask，它只提供最基础的web开发框架，如果想实现一些admin后台或者表单相关的，需要安装对应的flask工具包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nornir的官方网站是https://nornir.tech/ 在https://nornir.tech/nornir/plugins/ 我们可以看到官方的插件list，插件list分成几种：任务类的、连接类的、资源管理类的、进程管理、函数功能等等，比如netmiko就是一个任务类和连接类的插件包&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.3020565552699228&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y7BXgWR9x8bxI4XYcviaZnUdoOVvv3iaWsIF9exq9iaPAkBGIvFGoZ6SS1wRiaVNvmHm4l7xEQQZojmTicDBbFr9dXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;778&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个都会连接到github上，非常棒的是nornir_netmiko的作者就是netmiko的作者。所以回归到我们之前说的第一个问题，国产化问题，ansible的大难题（开源版本至少是这样的，不知道有没有收费的隐藏资源），在nornir面前就不再是问题了，因为netmiko对国产设备支持的还是比较好的，目前ruijieos都支持了，撒花！所以nornir可以非常方便的对国产设备进行批量操作，包含配置下发。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个简单的Nornir runbook&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;讲了这么多，我们赶紧来简简单单看看nornir是如何简单的开发出一个runbook的吧。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Nornir的文件组织架构及基本配置&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个nornir的runbook，类似ansible的，也有配置和设备清单及playbook的类似概念。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9463722397476341&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y7BXgWR9x8bxI4XYcviaZnUdoOVvv3iaWssibgN9LQyGYSK4XFGQTULPjibL7TMXVibo9iaO1KWia2WXqmsm2a2HlqGtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;317&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是一个nornir的文件结构。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;配置文件 config.yaml&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先看看它的配置文件,nornir的配置文件使用的是可读性和书写便利性比较好的yaml文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们打开config.yaml文件，当然你也可以改成其他名称。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;inventory:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;plugin:&lt;/span&gt; &lt;span&gt;SimpleInventory&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;options:&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;host_file:&lt;/span&gt; &lt;span&gt;&quot;inventory/hosts.yaml&quot;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;group_file:&lt;/span&gt; &lt;span&gt;&quot;inventory/groups.yaml&quot;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;defaults_file:&lt;/span&gt; &lt;span&gt;&quot;inventory/defaults.yaml&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;runner:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;plugin:&lt;/span&gt; &lt;span&gt;threaded&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;options:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;num_workers:&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从配置上来看，我们也可以看出它的两个主要功能：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;指定加载资产的方式和路径&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;指定运行的方式，比如默认的线程及并发量&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;资产清单相关配置&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;plugin: SimpleInventory，我们就用默认的即可，它的意思是用SimpleInventory这个插件来加载清单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以重写这个插件来对接我们的CMDB或者是csv文件都可以，只要按标准格式返回资产数据即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认它有几个重要的参数就是资产相关的文件的path。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;资产清单相关配置，一般放到inventory的文件夹内，内含三个文件：&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;host.yaml&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设备清单，字典的方式梳理所有设备，key值为设备名称，value值是个字典，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设备的属性分为三个大部分：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;设备基本信息：包含设备的IP或者hostname，用户名密码，连接的端口，设备的platform，这些参数都可以无缝对接netmiko和napalm。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;所属组groups，list形式，每个组都有很多属性，比如接入交换机有些基本的配置，类似的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;参数data，字典格式，用户可以根据需求自己定义，比如定义一个role后续筛选，或者自己的一些配置预定义等等&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6822107081174439&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y7BXgWR9x8bxI4XYcviaZnUdoOVvv3iaWs6icjUQH04pT8RkMvOdkdgqso5RnMyhICwUibmLDKeGiaVr1dpQiaUyntpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;579&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;groups.yaml&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设备会划拨给一些组，组里会有一些公用的属性，这个后续我们再详细分解&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;default.yaml&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全局默认的一些参数，按下不表，后续章节我们再详细分解&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这三个最最核心的我觉得是hosts，资产清单是最最核心的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;初始化对象，尝试打印出资产清单&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过引入InitNornir初始化一个Nornir对象&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; nornir &lt;span&gt;import&lt;/span&gt; InitNornir&lt;br/&gt;nr = InitNornir(&lt;br/&gt;    config_file=&lt;span&gt;&quot;nornir.yaml&quot;&lt;/span&gt;&lt;br/&gt;    )&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们就可以直接打印出我们的设备清单了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# list hosts&lt;/span&gt;&lt;br/&gt;print(nr.inventory.hosts)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;{&#x27;dev01&#x27;: Host: dev01, &#x27;dev02&#x27;: Host: dev02, &#x27;dev03&#x27;: Host: dev03}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它返回的是一个字典，key是设备名称，value是一个复杂的nornir内置的host对象，可以获取yaml文件内的一切，甚至更多。后续我也会尝试讲解一下Nornir的内置的一些重要的基本类。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;给每台设备一个自定义task运行&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多自动化框架的逻辑，基本就是有设备清单，然后在设备清单中做出筛选（默认全部），然后每台设备去执行自己的task。nornir也是这个逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们已经有了资产清单，我们想给每个设备安排一个任务，该怎么处理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以自己定义一个灵活的task，它的写法如下。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; nornir &lt;span&gt;import&lt;/span&gt; InitNornir&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; nornir_utils.plugins.functions &lt;span&gt;import&lt;/span&gt; print_result&lt;br/&gt;&lt;br/&gt;devices = InitNornir(&lt;br/&gt;    config_file=&lt;span&gt;&quot;nornir.yaml&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;hi&lt;/span&gt;&lt;span&gt;(task)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    words = &lt;span&gt;f&quot;Hi!I&#x27;m a network device. My name is &lt;span&gt;{task.host.name}&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; words&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;results = devices.run(task=hi,name=&lt;span&gt;&#x27;A task for saying hi!&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;print_result(results)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;自定义函数|task&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点是hi这个函数，它的第一个参数是task，这个地方可以简单理解成一个任务的上下文。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续是我们自己定义的参数，第一个，我们写的简单点，默认就让每台设备介绍一下自己。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每台设备都可以从task中取出自己的name，如上task.host.name&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们把想要返回的打印到屏幕上的return即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际过程中，我们可以写成每个设备执行自己的业务逻辑，比如信息采集、配置推送、起关端口等等，这个逻辑内部的很多都是可以受我们控制的，比如基本设备信息都可以从task中获取，然后调用netmiko或者ncclient等等，当然netmiko都有官方的插件包。这样就非常灵活了，我们简单写几个代码，借助netmiko批量配置就非常简单，后续也会展开介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nornir的灵活有一部分就体现在task里，可以非常灵活的定制自己的业务逻辑。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;批量执行自定义的task&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个重点来了，devices.run，devices就是我们初始化的Nornir对象，早期版本及官方版本会使用nr作为代替，类似pd代替pandas，有一些博主的视频代码里会写成筛选出来的设备，比如路由就写routers作为Nornir对象的变量名，这样可读性更好，有点所有设备执行任务的感觉。这个run有几个重要参数，我们今天初步介绍，最重要的是task，就是我们要调用哪个函数，这个时候我们传入自己定义函数（本例是hi），name是打印的时候显示的会比较好的而设计的，不写也没事。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;漂亮的打印出来&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们调用官方的插件包nornir_utils，这个需要pip安装。引入print_result，直接打印返回的结果即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看看效果&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4220472440944882&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y7BXgWR9x8bxI4XYcviaZnUdoOVvv3iaWsYWWcVbbUB8dx05vFVUc1b86fzbh1vdAOiaIhz3DPV1lyvm7WN9tbznw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;635&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常仿Ansible，有木有，每台设备并发执行，结果统统显示出来。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小结与脑洞大开&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是一个Nornir的最最基础的使用方式了，在定义好hosts文件之后，我们可以写自己的task函数，可以写的很简单，也可以写的很复杂，开个脑洞，比如基于netmiko或者paramiko，配置备份，传到指定FTP，或者git仓库，作为一个版本备份及管理的脚本；中间的设备可以不停的筛选，同时根据返回的信息不停的判断，从而执行一些复杂场景，比如一些应急场景，或者涉及到多台设备的联动配置等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再奉上一段代码，我们后续也会深入讲解，基于官方netmiko插件包写的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对设备进行一个批量执行，我们之前也讲过很多netmiko的例子，这个官方的插件包与Nornir无缝对接，我们不用再去构建连接，Nornir自动帮我们创建连接&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; nornir &lt;span&gt;import&lt;/span&gt; InitNornir&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; nornir_utils.plugins.functions &lt;span&gt;import&lt;/span&gt; print_result&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; nornir_netmiko &lt;span&gt;import&lt;/span&gt; netmiko_send_command&lt;br/&gt;&lt;br/&gt;nr = InitNornir(&lt;br/&gt;    config_file=&lt;span&gt;&quot;nornir.yaml&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;show_cmds&lt;/span&gt;&lt;span&gt;(task)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    cmds = task.host.data[&lt;span&gt;&#x27;cmds&#x27;&lt;/span&gt;]&lt;br/&gt;    outputs = []&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; cmd &lt;span&gt;in&lt;/span&gt; cmds:&lt;br/&gt;        outputs.append(task.run(netmiko_send_command,command_string=cmd))&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; outputs&lt;br/&gt;results = nr.run(task=show_cmds)&lt;br/&gt;print_result(results)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码也比较简单，我们就是获取了设备里配置的data中的cmds命令行列表，然后执行了官方插件的netmiko_send_command命令，传入了cmd命令，并将结果放入outputs返回，这中间可以做的实际非常多，我们可以用textfsm解析归档，可以show run 备份，可以下发配置，看看结果，每台设备执行的情况我们都可以一目了然。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个设备是一台华为的ce系列交换机（模拟器），我们都知道，netmiko对国产化设备支持目前是比较好的，我们通过这种方式，对华为华三的配置都可以实现，ansible支持的网络设备实在有限，且和设备软件版本有一定关联，但是基于netmiko，我们使用ssh加命令行即可，目前为止，在一个中大型或者是不单纯的网络环境中，我个人习惯称之超融合网络，命令行辅之以其他方式，有能力的上层封装统一，能力暂时不足或者没特殊想法的单纯命令行一梭子到底即可，这是我认为的，&lt;strong&gt;目前&lt;/strong&gt;NetDevOps的最佳实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6198473282442748&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y7BXgWR9x8bxI4XYcviaZnUdoOVvv3iaWseID7EkJx3uO9qaN0dXgI9WInwKEkOwKz3WcBjZCCWK6PM3oJxV2dQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;655&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在国外，NetDevOps的使用比较广泛的还有napalm、netbox，Nornir与之都可以很方便对接，它也是有一定生态的，同时也可以非常方便的自己写插件扩展，或者硬编码连接方式到task中非常暴力的执行命令等等。nornir的核心代码据说5000+，我看了看，真的是非常简单，但是考虑的很周全灵活，灵活我们讲了，简单的设计，还有一个非常好的结果就是执行效率高，在中大型网络环境中，真的是可以秒杀ansible，大家如果写过ansible，也应该深有体会，我们就是想执行一个show version，结果要等很长时间处理一堆东西，返回的巨慢，但是nornir就非常赞，很快就完成与设备的交互返回结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时之前也说过，它是pure python写的，所以我们可以非常灵活的定制很多内容。这其实是一把双刃剑，根据使用者能力和脑洞，用好了可以帮我们解决很多问题，但是python本身就对使用者的Python有了一定要求，无法像ansible那样去低代码开发，所以Nornir的目标用户还是NetDevOps工程师多一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好吧，今天的分享就到这里结束了，后续有机会也与大家继续分享，毕竟这也是一个大坑。关于Nornir的相关博文非常少，中文的应该是没，也不成体系，本系列后续会不断给大家分享一些nornir的分析与讲解，希望在国内网工界引入这个非常棒的网络运维自动化框架，网络人专属的“ansible”，喷完了ansible，又碰瓷ansible，手动狗头！&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.8095238095238095&quot; data-type=&quot;svg&quot; data-w=&quot;21&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/lpHDr05YrIRQgT2sib9SWGE99gWsPW7x8FP6LoMYvgkmO9jSQjFqfcMVBUsiaSKickqickc7k2Kwah52tbzMnA316k2WA88rXLAX/640?wx_fmt=svg&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.4074074074074074&quot; data-type=&quot;svg&quot; data-w=&quot;27&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/ibKHP1TZZeXLuZkD53jFWzc8iauhHlerlWDib9Dgm1JiaSF9LB4RGxxD4cSFrUoIeI4fvic7VPGpKGv8AqCJgcUeqLoOAXBW6kKov/640?wx_fmt=svg&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;送书活动&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2185501066098081&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTOMxUibn1y4x16tmFKvia0O6WTSXVDxF5MX4UpLNJSpybT3RFBhWia7r7jVj6C0czDEsK9xIJMAHforQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;938&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;新一期的赠书活动，感谢北京大学出版社赞助。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、内容全面:借助5大 Python工具库,实现数据分析从获取到建模全流程覆&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、贴合实际:不空讲 Python语法,清晰简明地介绍如何用Python来处理、分析数据&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3、热点案例:覆盖6大热点应用领域,可直接参考研发,实现数据变现&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;赠书规则&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;赠书本数&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：本次共包邮送书 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;本&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;参与方式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;：在&lt;strong&gt;Python猫&lt;/strong&gt;读者群抽奖，&lt;strong&gt;仅限群友&lt;/strong&gt;参与。后台发“&lt;/span&gt;&lt;span&gt;交流群&lt;/span&gt;&lt;span&gt;”，获取入群方式。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;开奖时间&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：2021年5月30日18:00&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;section&gt;&lt;mpcps frameborder=&quot;0&quot; class=&quot;js_editor_cps&quot; data-datakey=&quot;1622033712513_0.7636753855311949&quot; data-uid=&quot;1622033712515&quot; data-type=&quot;1&quot; data-product=&quot;&quot; data-templateid=&quot;list&quot; data-pid=&quot;29122980&quot; data-categoryid=&quot;3&quot; data-appuin=&quot;3084391334&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.45454545454545453&quot; data-w=&quot;22&quot; title=&quot;音符&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/cZV2hRpuAPiaJQXWGyC9wrUzIicibgXayrgibTYarT3A1yzttbtaO0JlV21wMqroGYT3QtPq2C7HMYsvicSB2p7dTBg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Python猫技术交流群开放啦！&lt;/span&gt;&lt;/strong&gt;群里既有国内一二线大厂在职员工，也有国内外高校在读学生，既有十多年码龄的编程老鸟，也有中小学刚刚入门的新人，学习氛围良好！想入群的同学，请在公号内回复『&lt;strong&gt;&lt;span&gt;交流群&lt;/span&gt;&lt;/strong&gt;』，获取猫哥的微信&lt;span&gt;（谢绝广告党，非诚勿扰！）&lt;/span&gt;~&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;还不过瘾？试试它们&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▲&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247492392&amp;amp;idx=1&amp;amp;sn=b0c7f15697c043eaf043730a0f9639cb&amp;amp;chksm=fa5ba4adcd2c2dbbf47059091d6a535bab4b14a7265bc9014a646780f556c2618f2c780472b4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;坚持原创很难，但我不会放弃！&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▲&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247485430&amp;amp;idx=1&amp;amp;sn=f27591dfb2fc4a30a411f370182cd5ef&amp;amp;chksm=fa584073cd2fc965c812ed3a697f0302c422fbc8f66acbcabec186eb291374dc7af6e05ac85b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Python 的缩进是不是反人类的设计？&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▲&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247488237&amp;amp;idx=1&amp;amp;sn=cf0c6860c751934f531b4dd460ba9780&amp;amp;chksm=fa585568cd2fdc7edcd3dfc1025401f0cbe16af1d56421518fece3dc450756eab641a841af67&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;冗长的 Python 代码，如何重构？&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▲&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247486931&amp;amp;idx=1&amp;amp;sn=93fff422b7b8b9f06019ef0562ed4d84&amp;amp;chksm=fa584a56cd2fc340220656d88a1da5554367786e8d375ec4fce74197c32995264fc0984a42fd&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;耗时两年，我终于出了一本电子书！&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▲&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247491934&amp;amp;idx=1&amp;amp;sn=880cb94ca57f37f3994202e9519b54d8&amp;amp;chksm=fa5ba6dbcd2c2fcda8b378b67eba0b71a18d7ab010d31420b43cd4e0169be39e6ec9582c48de&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Python 性能测试工具 Locust 极简入门&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▲&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247484794&amp;amp;idx=1&amp;amp;sn=53fae7b1274734a299e1e81b110c7e1c&amp;amp;chksm=fa5842ffcd2fcbe9b641f62b5212fda821f31258df58607c85ccd7f0d260074e3a58b1a756b4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;由浅入深：Python 中如何实现自动导入缺失的库？&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如果你觉得本文有帮助&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;请慷慨&lt;/span&gt;&lt;span&gt;分享&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;和&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;点赞&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;，感谢啦&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>