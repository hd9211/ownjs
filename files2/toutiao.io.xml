<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>8eac27e8ac73fb4af476210845acda44</guid>
<title>4.23世界读书日，推荐9本好书｜附读书笔记</title>
<link>https://toutiao.io/k/d8e0mjw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;40&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.23世界读书日，推荐9本好书。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;喜欢，也欢迎转发给您的朋友们，好东西要分享哦～&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、《横向领导力》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;270&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;1.3942505133470227&quot; data-type=&quot;jpeg&quot; data-w=&quot;974&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFFtWsoPAicr3xgbptSUJ56rYpj2m8EmtJZZdKXM2R04vKQxLicOZNbsOw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【内容简介】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与人合作绝对是世界上最难的事情之一，时间往往在摩擦中白白消耗，分到与自身能力不相称的任务，或是由于某种差异而冲突不断，长达数小时但结果欠奉的会议可以说是司空见惯。有时我们磨合团队所花的时间甚至远远超出完成实质性工作的周期。大多数人宁可多花一些工夫独立完成任务，也不愿意与他人合作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只有“一把手”才能领导，这是职场最大的误区和陷阱！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;罗杰·费希尔，谈判、沟通领域久负盛名的权威专家，汇聚哈佛大学肯尼迪政府学院、哈佛大学谈判项目的核心资源，砥砺七年，终于成就这部职场沟通经典:你无须拥有高于同事的权力，就能游刃有余地完成比难更难的事。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【读书笔记】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5616113744075829&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFqOpMMwL3kGuNEX4lkPk9qgdt1Tiauw0KKmbmHBxBFUD8xFPUmrqgNtA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、《工作、消费主义和新穷人》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;270&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;1.382867132867133&quot; data-type=&quot;jpeg&quot; data-w=&quot;572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFXYU1hhibicuLL0Q5DM6LVVmzym6sHumCpyLa6FqiaUahAc0YdB6c7GccA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【内容简介】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在生产者和普遍就业的社会中，贫穷是一回事。在消费者社会中，穷人是另一回事。在后者社会中，生活项目围绕消费者的选择而建立，而不是围绕工作、专业技能而建立。“贫穷”曾经与失业联系在一起，如今，它主要指向有缺陷消费者的困境。这种差异改变了贫穷的体验方式，对于拯救苦难产生重大影响。著名社会学家和思想家鲍曼的这部作品，对于消费者社会及其影响进行了反思和论述。在本书中，鲍曼书追溯现代历史上发生的这种变化，对其社会后果进行盘点，并考虑了与贫困作斗争和减轻困苦的各种方式的有效性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;社会学、政治学和社会政策学的研究者会发现，这是关于含义不断变化的一个持久社会问题的一本无价之书。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【读书笔记】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;422&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;237&quot; data-ratio=&quot;0.5616113744075829&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFaXTkcBVz5ibev4T9FicBDSGTYjIdMuYpiaicHnMyW4NkCPqTELX1lUjWbA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、《也许你该找个人聊聊》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;272&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;1.5105932203389831&quot; data-type=&quot;jpeg&quot; data-w=&quot;472&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicCxFCn1O6dLssq32qiaTRhF6hqcadzBHj43GkUNBT83sfxbicmHIlJ4GSZdqaRQGFYM7ibJ5JsI7M6g/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【内容简介】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一位心理治疗师的回忆录，讲述了发生在诊室中的故事。在这个小小的密闭空间里，人们会展现出最真实、最脆弱的一面；也是在这里，人们获得了陪伴和倾听，也获得了宝贵的觉察、成长与改变。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在书中，我们会看到四个来访者的故事，他们是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个四十多岁、事业成功、自以为是，认为身边所有人都是蠢货的好莱坞制片人；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个三十多岁、刚刚新婚就被诊断出患有绝症，时日不多的大学女教师；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个六十九岁、离过三次婚，感觉孤独绝望，声称生活再不好转就要在七十岁生日当天自杀的老太太；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个二十多岁、有原生家庭创伤和酗酒问题，在爱情中频频受挫的姑娘。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时，书中还有第五个寻求帮助的人，那就是治疗师自己。她是一个单身的职场妈妈，四十多岁时遭遇失恋，几乎崩溃。有朋友对她说“或许你该找个人聊聊”，于是她也给自己找了一位心理治疗师。当她切换到来访者的位置，坐到另一位心理治疗师的沙发上诉说自己内心的脆弱与悲伤，就更能感受到心理治疗为何具有治愈和改变的力量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这本书从治疗师和来访者的双重视角展现了心理治疗的过程，让我们发现：无论身份背景有多相异，人类面对的烦恼其实都相通——爱与被爱、遗憾、选择、控制、不确定、死亡，这些都是我们身而为人必须共同学习面对的议题。我们在现实生活中所遭遇的切肤之痛和生命困境，都能在这本书中得到共鸣、找到希望。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【读书笔记】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;422&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;237&quot; data-ratio=&quot;0.5616113744075829&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFq5lNQDR1F1x4ibkRYe2sYcmiab4qGyWwvicVpKNsS5hicyU5ia4Ma31NDUQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4、《爱的五种语言》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;272&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;0.850925925925926&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFib5tCRP71laOBspm50VlpIibv2kJRiceHhO9vzkRhc4Rw0pRia963jCvLQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【内容简介】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全球婚恋辅导经典之作&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一本关系建造的精彩指南&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;帮助无数的婚姻从危机当中扭转局面，并有美好结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;连续17年名列【纽约时报排行榜】，并数次荣登。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全球突破1000万册，译成50国语言！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【读书笔记】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;422&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;237&quot; data-ratio=&quot;0.5616113744075829&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFaAHBsibVvLzqzA7bqbH4kibQviaqC9qre798qKYLfc9fRntolF1iaOsGYg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;加入我们，一起读好书！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;即刻加入，立享9折，仅此一天！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;52&quot; data-cropselx2=&quot;324&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;377&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;580&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFK6MbK8O0IXjObLicvHLPHkhBhgRzlj11MQleMJeA02qHbKM9ptrWRNg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5、《终身成长》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;272&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;1.3876923076923078&quot; data-type=&quot;jpeg&quot; data-w=&quot;650&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFXQia0SAfSlsfDljBvdNpK6K7HxicCAFrZwqPc5ma6I9SbOAvbJ3ODrRg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【内容简介】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在对成功的数十年研究后，斯坦福大学心理学家卡罗尔·德韦克发现了思维模式的力量。她在《终身成长》中表明，我们获得的成功并不是能力和天赋决定的，更受到我们在追求目标的过程中展现的思维模式的影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;她介绍了两种思维模式：固定型与成长型，它们体现了应对成功与失败、成绩与挑战时的两种基本心态。你认为才智和努力哪个重要，能力能否通过努力改变，决定了你是会满足于既有成果还是会积极探索新知。只有用正确的思维模式看待问题，才能更好地达成人生和职业目标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;德韦克揭示的成功法则已被很多具有发展眼光的父母、老师、运动员和管理者应用，并在实践中得到了验证。通过了解自己的思维模式并做出改变，人们能以最简单的方式培养对学习的热情，和在任何领域内取得成功都需要的抗压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【读书笔记】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;422&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;237&quot; data-ratio=&quot;0.5616113744075829&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFL456uVbuCLtRvVPqTUgEo7ULGhicbqwqia2a1ppqZRk3sO96ukmDVA1A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6、《麦肯锡工作法》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;272&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;1.40702947845805&quot; data-type=&quot;jpeg&quot; data-w=&quot;882&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicCxFCn1O6dLssq32qiaTRhF66XicicUF1b2ibcTzG4M6NLMEic5j1f1icNQV7BiaWLUQqYGt7rZl2rsTbew/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【内容简介】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“麦肯锡人”总带着闪耀的光环，但他们在这家全球顶级管理咨询公司的平均工作年限仅是3~5年。为何他们从麦肯锡毕业后，还能活跃于各个行业，取得非凡的成绩？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原因就在于麦肯锡独特的工作法，7堂课让员工的竞争力大大提升，并且终生受用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;麦肯锡资深培训师大嶋祥誉在《麦肯锡工作法》中拆解了公司内部的秘密武器：麦肯锡的专业作风、解决问题的技巧、分析框架的养成、处理信息的能力、提升自我的策略、展现成果的方法，还有麦肯锡式的思考方式。学会《麦肯锡工作法》，让你不进麦肯锡也能变成优秀的“麦肯锡人”，在团队中脱颖而出！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【读书笔记】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;422&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;237&quot; data-ratio=&quot;0.5616113744075829&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFyBiaO2tPyibnNV7sF7E0T9nMBicISr5IS1ibV6ZPBuTW8J966sYsJ9ibeIQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7、《蛤蟆先生去看心理医生》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;272&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;1.3046875&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFUloV0Sr6vDCggZQqR4iaCI9UAVgibN8KLiaz5rpjsnMdATDo0AicpLIJOQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【内容简介】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;蛤蟆先生一向爱笑爱闹，如今却一反常态地郁郁寡欢，他一个人躲在屋里，连起床梳洗的力气都没有。朋友们非常担心他，建议他去做心理咨询。在10次心理咨询中，蛤蟆在咨询师苍鹭的带领下，勇敢地探索了自己的内心世界，也逐渐找回了信心与希望……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这并不是一本写给孩子看的书，而是一本非常有深度的心理疗愈读物。出版20多年来，已成为英国国民级心理咨询入门书。它基于TA沟通分析心理学的理论，讲述了一个抑郁症病人通过十次心理咨询，终于找回快乐和自信的全过程。在书中，可以看到心理咨询的倾听、共情、沟通技巧，也可以看到一个标准的心理咨询流程的模板。读者犹如亲临现场，体验心理咨询的每一个细节，见证疗愈和改变的发生。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这本书里，作者借由蛤蟆和心理咨询师苍鹭的互动，探索了蛤蟆自卑、软弱、爱炫耀的个性与抑郁的情绪究竟来源于何处，让读者看到童年经历对人格的深刻影响，以及如何才能在心理上真正长大成人，独立、自信、充满希望地生活。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【读书笔记】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;422&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;237&quot; data-ratio=&quot;0.5616113744075829&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFjEAeoaxhQgxjncibYchfoVavB0iaG9gVCibHgs0ibcYCzicL2jPyCbbf5lg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8、《谈判》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;272&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;1.4285714285714286&quot; data-type=&quot;jpeg&quot; data-w=&quot;280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFMP7TPckwIhtOu23hqJiaPcmULYibUkV0icEBUxOm1U7bSGUj8EOJFJ2pw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【内容简介】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本书从第一版至今已畅销35年，是全世界亿万富翁的枕边书，全球十余种版本累积销售已超200万册。在本次全新版本中，不仅回顾了前三个版本的全部内容，还增补了适应当前商业谈判的新的策略和案例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;寸步不让，除非交换！不要接受对方的第一次出价！谈判最有利的两个字是什么？最有用的问题是什么？寓教于乐的谈判学权威读物，25个有趣实用的策略和自我测试，以四两拨千斤的技巧，在博弈中获得更多，让全世界都听你的！&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【读书笔记】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;422&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;237&quot; data-ratio=&quot;0.5616113744075829&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFiargL4qu3TNXGKTPAMjET9cicGRXgPJQs4lLQicjlSgR6hibX1NhgxI3RQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;9、《一生的旅程》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;272&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;1.4678899082568808&quot; data-type=&quot;jpeg&quot; data-w=&quot;545&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFiclPrEPDSZrVGMKKicp7dA9ReuEIGSfcaM0ebXQ2qOz4RwYsEc5Lt3gA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【内容简介】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作为迪士尼的董事长兼首席执行官，罗伯特·艾格在书中回顾了自己45年的职业生涯，分享了《复仇者联盟》《星球大战》《黑豹》等超级IP的诞生过程，记录了他与乔布斯惺惺相惜的深厚友谊，分析了并购皮克斯、漫威、卢卡斯影业以及二十一世纪福克斯的前因后果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2005年，内忧外患中的迪士尼面临着被出售的风险，艾格在一片争议声中赴任，将迪士尼的未来之路聚焦为三个方向：打造高质量品牌内容；拥抱科技；着眼全球。他邀请乔布斯加入董事会，招募创意天才拉塞特、技术专家卡特姆拯救迪士尼动画，深耕漫威宇宙，续写《星球大战》科幻史诗，全程参与创建上海迪士尼乐园，成功推出流媒体Disney+ ，让迪士尼的快乐魔法遍布全世界每个角落。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【读书笔记】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;422&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;237&quot; data-ratio=&quot;0.5616113744075829&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFUghpSYnZW1NFRdUlexlKBoibb5qx8ib5Mu6ib8VGciaHvzCy7Eqaicfyp4w/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;加入我们，一起读好书！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;即刻加入，立享9折，仅此一天！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;52&quot; data-cropselx2=&quot;324&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;377&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;580&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFK6MbK8O0IXjObLicvHLPHkhBhgRzlj11MQleMJeA02qHbKM9ptrWRNg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6358ae4acfe92b7b08e52a24bc802de9</guid>
<title>Kubernetes 网络模型基础指南</title>
<link>https://toutiao.io/k/1w97stn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Kubernetes 是为运行分布式集群而建立的，分布式系统的本质使得网络成为 Kubernetes 的核心和必要组成部分，了解 Kubernetes 网络模型可以使你能够正确运行、监控和排查应用程序故障。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.4255555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgxXjFVCRuH7qy64U3chiaiahczklvicicPLs7TpRKqLNds92VMUXiaEC2iaJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网络是非常复杂的，拥有许多概念，对于不熟悉这个领域的用户来说，这可能会有一定的难度，这里面有很多概念需要理解，并且还需要把这些概念整合起来形成一个连贯的整体，比如网络命名空间、虚拟接口、IP 转发、NAT 等概念。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Kubernetes 中对任何网络实现都规定了以下的一些要求：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;所有 Pod 都可以在不使用 NAT 的情况下与所有其他 Pod 进行通信&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;所有节点都可以在没有 NAT 的情况下与所有 Pod 进行通信&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Pod 自己的 IP 与其他 Pod 看到的 IP 是相同的&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;鉴于这些限制，我们需要解决几个不同的网络问题：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;容器到容器的网络&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Pod 到 Pod 的网络&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Pod 到 Service 的网络&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;互联网到 Service 的网络&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来我们将来讨论这些问题及其解决方案。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;容器到容器网络&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下我们将虚拟机中的网络通信视为直接与以太网设备进行交互，如图1所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5014245014245015&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgCV9T9zxQ7pfMHEiauW3V6z9TiaUIrm4TfdVibb5hNJMJO7OticAOK1v6Ng/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;702&quot;/&gt;&lt;figcaption&gt;图1.网络设备的理想视图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实际的情况肯定比这要复杂，在 Linux 中，每个正在运行的进程都在一个网络命名空间内进行通信，该命名空间提供了一个具有自己的路由、防火墙规则和网络设备的逻辑网络栈，从本质上讲，网络命名空间为命名空间内的所有进程提供了一个全新的网络堆栈。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Linux 用户可以使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ip&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 命令创建网络命名空间。例如，以下命令将创建一个名为 ns1 的网络命名空间。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; ip netns add ns1 &lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;命名空间创建后，会在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/var/run/netns&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 下面为其创建一个挂载点，即使没有附加任何进程，命名空间也是可以保留的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你可以通过列出 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/var/run/netns&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 下的所有挂载点或使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ip&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 命令来列出可用的命名空间。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; ls /var/run/netns&lt;/span&gt;&lt;br/&gt;ns1&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; ip netns&lt;/span&gt;&lt;br/&gt;ns1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;默认情况下，Linux 将为每个进程分配到 root network namespace，以提供访问外部的能力，如图2所示。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5014245014245015&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgoTjJmceqShbEoZ6ibwMOA1VZOV2yYQmN6z9BovoSiafExusQt9dpyu0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;figcaption&gt;图2.root network namespace&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于 Docker 而言，一个 Pod 会被构建成一组共享网络命名空间的 Docker 容器，Pod 中的容器都有相同的 IP 地址和端口空间，它们都是通过分配给 Pod 的网络命名空间来分配的，并且可以通过 localhost 访问彼此，因为它们位于同一个命名空间中。这是使用 Docker 作为 Pod 容器来实现的，它持有网络命名空间，而应用容器则通过 Docker 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-net=container:sandbox-container&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 功能加入到该命名空间中，图3显示了每个 Pod 如何由共享网络命名空间内的多个 Docker 容器（&lt;/span&gt;&lt;code&gt;&lt;span&gt;ctr*&lt;/span&gt;&lt;/code&gt;&lt;span&gt;）组成的。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5014245014245015&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgx14N89bgPKjXwqTDV2ia9FbbLyLP2fGEvBrMUT5U4ibvq87nySmZ1xTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;figcaption&gt;图3.每个 Pod 的网络命名空间&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此外 Pod 中的容器还可以访问共享卷，这些卷被定义为 Pod 的一部分，并且可以挂载到每个容器的文件系统中。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Pod 到 Pod 网络&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 Kubernetes 中，每个 Pod 都有一个真实的 IP 地址，每个 Pod 都使用该 IP 地址与其他 Pod 进行通信。接下来我们将来了解 Kubernetes 如何使用真实的 IP 来实现 Pod 与 Pod 之间的通信的。我们先来讨论同一节点上的 Pod 通信的方式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从 Pod 的角度来看，它存在于自己的网络命名空间中，需要与同一节点上的其他网络命名空间进行通信。值得庆幸的时候，命名空间可以使用 Linux 虚拟以太网设备或由两个虚拟接口组成的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对进行连接，这些虚拟接口可以分布在多个命名空间上。要连接 Pod 命名空间，我们可以将 veth 对的的一侧分配给 root network namespace，将另一侧分配给 Pod 的网络命名空间。每个 veth 对就像一根网线，连接两侧并允许流量在它们之间流动。这种设置可以复制到节点上的任意数量的 Pod。图4显示了连接虚拟机上每个 Pod 的 root network namespace 的 veth 对。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5014245014245015&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgiav7goAhdM2Fg40BpBNia6OmnP1yZJ0O2aD9ajK98r46EfkGxIfMYJzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;figcaption&gt;图4.Pod 的 veth 对&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在 Pod 都有自己的网络命名空间，这样它们就有自己的网络设备和 IP 地址，并且它们连接到节点的 root 命名空间，现在我们希望 Pod 能够通过 root 命名空间进行通信，那么我们将要使用一个网络 &lt;em&gt;bridge（网桥）&lt;/em&gt;来实现。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Linux bridge 是用纯软件实现的虚拟交换机，有着和物理交换机相同的功能，例如二层交换，MAC 地址学习等。因此我们可以把 veth pair 等设备绑定到网桥上，就像是把设备连接到物理交换机上一样。bridge 的工作方式是通过检查通过它的数据包目的地，并决定是否将数据包传递给连接到网桥的其他网段，从而在源和目的地之间维护一个转发表。bridge 通过查看网络中每个以太网设备的唯一 MAC 地址来决定是桥接数据还是丢弃数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Bridges 实现了 ARP 协议来发现与指定 IP 地址关联的链路层 MAC 地址。当 bridge 接收到数据帧的时候，bridge 将该帧广播给所有连接的设备（原始发送者除外），响应该帧的设备被存储在一个查找表中，未来具有相同 IP 地址的通信使用查找表来发现正确的 MAC 地址来转发数据包。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5584045584045584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgaC5x2L2NGESEDibAC2J9Y4cSics1zvr3vlQEubR88po8icKdIZnzVDGag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;figcaption&gt;图5.使用桥接连接命名空间&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同节点 Pod 通信&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网络命名空间将每个 Pod 隔离到自己的网络堆栈中，虚拟以太网设备将每个命名空间连接到根命名空间，以及一个将命名空间连接在一起的网桥，这样我们就准备好在同一节点上的 Pod 之间发送流量了，如下图6所示。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4390467461044913&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgbMZZruJE0xAuacLiaia0y3HtN4ic5QJWsCEEpHgfoWsQMboak31eaeXOg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1091&quot;/&gt;&lt;figcaption&gt;同节点上的Pod间的数据包移动&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这上图中，pod1 向自己的网络设备 &lt;/span&gt;&lt;code&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 发送了一个数据包，对于 pod1 来说，&lt;/span&gt;&lt;code&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 通过虚拟网络设备连接到 root netns 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth0(1)&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，网桥 &lt;/span&gt;&lt;code&gt;&lt;span&gt;cbr0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 被配置为与 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 一端相连，一旦数据包到达网桥，网桥就会使用 ARP 协议将数据包发送到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth1(3)&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。当数据包到达虚拟设备 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth1&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 时，它被直接转发到 pod2 的命名空间内的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;eth0(4)&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 设备。这整个过程中，每个 Pod 仅与 &lt;/span&gt;&lt;code&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 上的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 进行通信，流量就会被路由到正确的 Pod。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Kubernetes 的网络模型决定了 Pod 必须可以通过其 IP 地址跨节点访问，也就是说，一个 Pod 的 IP 地址始终对网络中的其他 Pod 是可见的，每个 Pod 看待自己的 IP 地址的方式与其他 Pod 看待它的方式是相同的。接下来我们来看看不同节点上的 Pod 之间的流量路由问题。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;跨节点 Pod 通信&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在研究了如何在同一节点上的 Pod 之间路由数据包之后，接下来我们来看下不同节点上的 Pod 之间的通信。Kubernetes 网络模型要求 Pod 的 IP 是可以通过网络访问的，但它并没有规定必须如何来实现。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通常集群中的每个节点都分配有一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CIDR&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，用来指定该节点上运行的 Pod 可用的 IP 地址。一旦以 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CIDR&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 为目的地的流量到达节点，节点就会将流量转发到正确的 Pod。图7展示了两个节点之间的网络通信，假设网络可以将 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CIDR&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中的流量转发到正确的节点。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0342205323193916&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgvHLovL3sZSEtEia3tKWIDCS43V6PLN4kxIjdLnMugfW32fl4ZfHmwSg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1052&quot;/&gt;&lt;figcaption&gt;图7.不同节点上的Pod间通信&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上图一样和图6相同的地方开始请求，但是这次目标 Pod（绿色标注）与源 Pod（蓝色标注）位于不同的节点上。数据包首先通过 pod1 的网络设备发送，该设备与 root netns（1）中的虚拟网络设备配对，最终数据包到达 root netns 的网桥（2）上。这个时候网桥上的 ARP 会失败，因为与网桥相连的没有正确的数据包 MAC 地址。一旦失败，网桥会将数据包发送到默认路由上 - root netns 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 设备，此时就会路由离开节点，进入网络（3）。我们现在假设网络可以根据分配给节点的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CIDR&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 将数据包路由到正确的节点（4）。数据包进入目标节点的 root netns（VM2 上的 eth0），这那里它通过网桥路由到正确的虚拟设备（5）。最后，路由通过位于 pod4 的命名空间（6）中的虚拟设备 &lt;/span&gt;&lt;code&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来完成。一般来说，每个节点都知道如何将数据包传递给其内部运行的 Pod，一旦数据包到达目标节点，数据包的流动方式与同一节点上的 Pod 间通信方式一样。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们这里没有介绍如何配置网络来将 Pod IPs 的流量路由到负责这些 IP 的正确节点，这和特定的网络有关系，比如 AWS 就维护了一个 Kubernetes 容器网络插件，该插件允许在 AWS 的 VPC 环境中使用 [容器网络接口（&lt;/span&gt;&lt;code&gt;&lt;span&gt;CNI&lt;/span&gt;&lt;/code&gt;&lt;span&gt;）插件]（https://github.com/aws/amazon-vpc-cni-k8s）来进行节点到节点的网络通信。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 EC2 中，每个实例都绑定到一个弹性网络接口 (ENI)，并且所有 ENI 都连接在一个 VPC 内 —— ENI 无需额外操作即可相互访问。默认情况下，每个 EC2 实例部署一个 ENI，但你可以创建多个 ENI 并将它们部署到 EC2 实例上。Kubernetes 的 AWS CNI 插件会为节点上的每个 Pod 创建一个新的 ENI，因为 VPC 中的 ENI 已经连接到了现有 AWS 基础设施中，这使得每个 Pod 的 IP 地址可以在 VPC 内自然寻址。当 CNI 插件被部署到集群时，每个节点（EC2 实例）都会创建多个弹性网络接口，并为这些实例分配 IP 地址，从而为每个节点形成了一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CIDR&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 块。当部署 Pod 时，有一个小的二进制文件会作为 DaemonSet 部署到 Kubernetes 集群中，从节点本地的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubelet&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 进程接收任何添加 Pod 到网络的请求，这个二进制文件会从节点的可用 ENI 池中挑选一个可用的 IP 地址，并通过在 Linux 内核中连接虚拟网络设备和网桥将其分配给 Pod，和在同一节点内容的 Pod 通信一样，有了这个，Pod 的流量就可以跨集群内的节点进行通信了。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Pod 到 Service&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面我们已经介绍了如何在 Pod 和它们相关的 IP 地址之间的通信。但是 Pod 的 IP 地址并不是固定不变的，会随着应用的扩缩容、应用崩溃或节点重启而出现或消失，这些都可能导致 Pod IP 地址发生变化，Kubernetes 中可以通过 &lt;em&gt;Service&lt;/em&gt; 对象来解决这个问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Kubernetes Service 管理一组 Pod，允许你跟踪一组随时间动态变化的 Pod IP 地址，Service 作为对 Pod 的抽象，为一组 Pod 分配一个虚拟的 VIP 地址，任何发往 Service VIP 的流量都会被路由到与其关联的一组 Pod。这就允许与 Service 相关的 Pod 集可以随时变更 - 客户端只需要知道 Service VIP 即可。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;创建 Service 时候，会创建一个新的虚拟 IP（也称为 clusterIP），这集群中的任何地方，发往虚拟 IP 的流量都将负载均衡到与 Service 关联的一组 Pod。实际上，Kubernetes 会自动创建并维护一个分布式集群内的负载均衡器，将流量分配到 Service 相关联的健康 Pod 上。接下来让我们仔细看看它是如何工作的。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;netfilter 与 iptables&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了在集群中执行负载均衡，Kubernetes 会依赖于 Linux 内置的网络框架 - &lt;/span&gt;&lt;code&gt;&lt;span&gt;netfilter&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。Netfilter 是 Linux 提供的一个框架，它允许以自定义处理程序的形式实现各种与网络相关的操作，Netfilter 为数据包过滤、网络地址转换和端口转换提供了各种功能和操作，它们提供了引导数据包通过网络所需的功能，以及提供禁止数据包到达计算机网络中敏感位置的能力。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;iptables&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是一个用户空间程序，它提供了一个基于 table 的系统，用于定义使用 netfilter 框架操作和转换数据包的规则。在 Kubernetes 中，iptables 规则由 kube-proxy 控制器配置，该控制器会 watch kube-apiserver 的变更，当对 Service 或 Pod 的变化更新了 Service 的虚拟 IP 地址或 Pod 的 IP 地址时，iptables 规则会被自动更新，以便正确地将指向 Service 的流量路由到支持 Pod。iptables 规则会监听发往 Service VIP 的流量，并且在匹配时，从可用 Pod 集中选择一个随机 Pod IP 地址，并且 iptables 规则将数据包的目标 IP 地址从 Service 的 VIP 更改为所选的 Pod IP。当 Pod 启动或关闭时，iptables 规则集也会更新以反映集群的变化状态。换句话说，iptables 已经在节点上做了负载均衡，以将指向 Service VIP 的流量路由到实际的 Pod 的 IP 上。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在返回路径上，IP 地址来自目标 Pod，在这种情况下，iptables 再次重写 IP 头以将 Pod IP 替换为 Service 的 IP，以便 Pod 认为它一直只与 Service 的 IP 通信。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;IPVS&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Kubernetes 新版本已经提供了另外一个用于集群负载均衡的选项：IPVS， IPVS 也是构建在 netfilter 之上的，并作为 Linux 内核的一部分实现了传输层的负载均衡。IPVS 被合并到了 LVS（Linux 虚拟服务器）中，它在主机上运行并充当真实服务器集群前面的负载均衡器，IPVS 可以将基于 TCP 和 UDP 的服务请求定向到真实服务器，并使真实服务器的服务作为虚拟服务出现在一个 IP 地址上。这使得 IPVS 非常适合 Kubernetes 服务。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这部署 kube-proxy 时，可以指定使用 iptables 或 IPVS 来实现集群内的负载均衡。IPVS 专为负载均衡而设计，并使用更高效的数据结构（哈希表），与 iptables  相比允许更大的规模。在使用 IPVS 模式的 Service 时，会发生三件事：在 Node 节点上创建一个虚拟 IPVS 接口，将 Service 的 VIP 地址绑定到虚拟 IPVS 接口，并为每个 Service VIP 地址创建 IPVS 服务器。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Pod 到 Service 通信&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6936758893280632&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgO80nIibbUc6npiblqjuW8RAqlU6MhtBDUSRCwf4D1K81Wc9jdzwhnr8w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1012&quot;/&gt;&lt;figcaption&gt;图8. Pod 与 Service 之间通信&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当这 Pod 和 Service 之间路由一个数据包时，流量和以前开始的方式一样，数据包首先通过连接到 Pod 的网络命名空间（1）的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 离开 Pod，。然后它通过虚拟网络设备到达网桥（2）。网桥上运行的 ARP 是不知道 Service 地址的，所以它通过默认路由 &lt;/span&gt;&lt;code&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（3）将数据包传输出去。到这里会有一些不同的地方了，在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 接收之前，该数据包会被 iptables 过滤，在收到数据包后，iptables 使用 kube-proxy 在节点上安装的规则来响应 Service 或 Pod 事件，将数据包的目的地从 Service VIP 改写为特定的 Pod IP（4）。该数据包现在就要到达 pod4 了，而不是 Service 的 VIP，iptables 利用内核的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;conntrack&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 工具来记录选择的 Pod，以便将来的流量会被路由到相同的 Pod。从本质上讲，iptables 直接从节点上完成了集群内的负载均衡，然后流量流向 Pod，剩下的就和前面的 Pod 到 Pod 通信一样的了（5）。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Service 到 Pod 通信&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6936758893280632&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgtV3KndqR2yoKUjoRlicMAwVOAnRzQn1lzibNE7ndyQpNHQ3UoeF0toiag/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1012&quot;/&gt;&lt;figcaption&gt;图9.在 Service 和 Pod 之间通信&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;相应的回包的时候，收到该数据包的 Pod 将响应，将源 IP 标记为自己的 IP，将目标 IP 标记为最初发送数据包的 Pod(1)。进入节点后，数据包流经 iptables，它使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;conntrack&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 记住它之前所做的选择，并将数据包的源重写为 Service 的 VIP 而不是现在 Pod 的 IP(2)。从这里开始，数据包通过网桥流向与 Pod 的命名空间配对的虚拟网络设备 (3)，然后流向我们之前看到的 Pod 的虚拟网络设备 (4)。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;外网到 Service 通信&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;到这里我们已经了解了 Kubernetes 集群内的流量是如何路由的，但是更多的时候我们需要将服务暴露到外部去。这个时候会涉及到两个主要的问题：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将流量从 Kubernetes 服务路由到互联网上去&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将流量从互联网传到你的 Kubernetes 服务&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来我们就来讨论这些问题。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;出流量&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从节点到公共 Internet 的路由流量也是和特定的网络有关系的，这取决于你的网络如何配置来发布流量的。这里我们以 AWS VPC 为例来进行说明。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 AWS 中，Kubernetes 集群在 VPC 中运行，每个节点都分配有一个私有 IP 地址，该地址可从 Kubernetes 集群内访问。要从集群外部访问服务，你可以在 VPC 上附加一个外网网关。外网网关有两个用途：在你的 VPC 路由表中为可路由到外网的流量提供目标，以及为已分配公共 IP 地址的实例执行网络地址转换 (NAT)。NAT 转换负责将集群节点的内部 IP 地址更改为公网中可用的外部 IP 地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有了外网网关，VM 就可以自由地将流量路由到外网。不过有一个小问题，Pod 有自己的 IP 地址，与运行 Pod 的节点 IP 地址不同，并且外网网关的 NAT 转换仅适用于 VM IP 地址，因为它不知道哪些 Pod 在哪些 VM 上运行 —— 网关不支持容器。让我们看看 Kubernetes 是如何使用 iptables 来解决这个问题的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在下图中，数据包源自 Pod 的命名空间 (1)，并经过连接到根命名空间 (2) 的 veth 对。一旦进入根命名空间，数据包就会从网桥移动到默认设备，因为数据包上的 IP 与连接到网桥的任何网段都不匹配。在到达根命名空间的网络设备 (3) 之前，iptables 会破坏数据包 (3)。在这种情况下，数据包的源 IP 地址是 Pod，如果我们将源保留为 Pod，外网网关将拒绝它，因为网关 NAT 只了解连接到 VM 的 IP 地址。解决方案是&lt;strong&gt;让 iptables 执行源 NAT&lt;/strong&gt; —— 更改数据包源，使数据包看起来来自 VM 而不是 Pod。有了正确的源 IP，数据包现在可以离开 VM (4) 并到达外网网关 (5) 了。外网网关将执行另一个 NAT，将源 IP 从 VM 内部 IP 重写为公网IP。最后，数据包将到达互联网上 (6)。在返回的路上，数据包遵循相同的路径，并且任何源 IP 的修改都会被取消，这样系统的每一层都会接收到它理解的 IP 地址：节点或 VM 级别的 VM 内部，以及 Pod 内的 Pod IP命名空间。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7425925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgGaUDVlu2VesbE999GjqtA1WthWLBRF47ZDQ6XttQMqkjq9fc1YE3kg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图10.从Pod到互联网通信&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;入流量&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;让流量进入你的集群是一个非常难以解决的问题。同样这也和特定的网络环境有关系，但是一般来说入流量可以分为两种解决方案：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Service LoadBalancer&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Ingress 控制器&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;LoadBalancer&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当你创建一个 Kubernetes Service时，你可以选择指定一个 LoadBalancer 来使用它。LoadBalancer 有为你提供服务的云供应商负责创建负载均衡器，创建服务后，它将暴露负载均衡器的 IP 地址。终端用户可以直接通过该 IP 地址与你的服务进行通信。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;LoadBalancer 到 Service&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在部署了 Service 后，你使用的云提供商将会为你创建一个新的 LoadBalancer（1）。因为 LoadBalancer 不支持容器，所以一旦流量到达 LoadBalancer，它就会分布在集群的各个节点上（2）。每个节点上的 iptables 规则会将来自 LoadBalancer 的传入流量路由到正确的 Pod 上（3）。从 Pod 到客户端的响应将返回 Pod 的 IP，但客户端需要有 LoadBalancer 的 IP 地址。正如我们之前看到的，iptables 和 conntrack 被用来在返回路径上正确重写 IP 地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下图展示的就是托管 Pod 的三个节点前面的负载均衡器。传入流量（1）指向 Service 的 LoadBalancer，一旦 LoadBalancer 接收到数据包（2），它就会随机选择一个节点。我们这里的示例中，我们选择了没有运行 Pod 的节点 VM2（3）。在这里，运行在节点上的 iptables 规则将使用 kube-proxy 安装到集群中的内部负载均衡规则，将数据包转发到正确的 Pod。iptables 执行正确的 NAT 并将数据包转发到正确的 Pod（4）。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0273348519362187&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgjicHYRZia3uYzyTenTbsnsCcUaKZYt1PeIj69MYh8uNic3oziaicIZeFKmQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;878&quot;/&gt;&lt;figcaption&gt;图11.外网访问 Service&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Ingress 控制器&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在七层网络上 Ingress 在 HTTP/HTTPS 协议范围内运行，并建立在 Service 之上。启用 Ingress 的第一步是使用 Kubernetes 中的 NodePort 类型的 Service，如果你将 Service 设置成 NodePort 类型，Kubernetes master 将从你指定的范围内分配一个端口，并且每个节点都会将该端口代理到你的 Service，也就是说，任何指向节点端口的流量都将使用 iptables 规则转发到 Service。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;将节点的端口暴露在外网，可以使用一个 Ingress 对象，Ingress 是一个更高级别的 HTTP 负载均衡器，它将 HTTP 请求映射到 Kubernetes Service。根据控制器的实现方式，Ingress 的使用方式会有所不同。HTTP 负载均衡器，和四层网络负载均衡器一样，只了解节点 IP（而不是 Pod IP），因此流量路由同样利用由 kube-proxy 安装在每个节点上的 iptables 规则提供的内部负载均衡。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 AWS 环境中，ALB Ingress 控制器使用 AWS 的七层应用程序负载均衡器提供 Kubernetes 入口。下图详细介绍了此控制器创建的 AWS 组件，它还演示了 Ingress 流量从 ALB 到 Kubernetes 集群的路由。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.53198127925117&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgdr38KkXPhd9AKtGnrYhn2SxGDKy0fbjFWIrfrgzXaXCzjicEIjrWzRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;figcaption&gt;图12.Ingress 控制器&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;创建后，(1) Ingress Controller 会 watch 来自 Kubernetes APIServer 的 Ingress 事件。当它找到满足其要求的 Ingress 资源时，它会开始创建 AWS 资源。AWS 将 Application Load Balancer (ALB) (2) 用于 Ingress 资源。负载均衡器与用于将请求路由到一个或多个注册节点的 TargetGroup一起工作。(3) 在 AWS 中为 Ingress 资源描述的每个唯一 Kubernetes Service 创建 TargetGroup。(4) Listener 是一个 ALB 进程，它使用你配置的协议和端口检查连接请求。Listener 由 Ingress 控制器为你的 Ingress 资源中描述的每个端口创建。最后，为 Ingress 资源中指定的每个路径创建 TargetGroup 规则。这可以保证到特定路径的流量被路由到正确的 Kubernetes 服务上 (5)。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Ingress 到 Service&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;流经 Ingress 的数据包的生命周期与 LoadBalancer 的生命周期非常相似。主要区别在于 Ingress 知道 URL 的路径（可以根据路径将流量路由到 Service）Ingress 和节点之间的初始连接是通过节点上为每个服务暴露的端口。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;部署 Service 后，你使用的云提供商将为你创建一个新的 Ingress 负载均衡器 (1)。因为负载均衡器不支持容器，一旦流量到达负载均衡器，它就会通过为你的服务端口分布在组成集群 (2) 的整个节点中。每个节点上的 iptables 规则会将来自负载均衡器的传入流量路由到正确的 Pod (3)。Pod 到客户端的响应将返回 Pod 的 IP，但客户端需要有负载均衡器的 IP 地址。正如我们之前看到的，iptables 和 conntrack 用于在返回路径上正确重写 IP。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7768959435626103&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgB6f7ZsmsiamnMF10mxPp1NvlmMw5sHGfqAQ0MKnkYTxlMKpjkI6Gctg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1134&quot;/&gt;&lt;figcaption&gt;图13.从 Ingress 到 Service&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文介绍了 Kubernetes 网络模型以及如何实现常见网络任务。网络知识点既广泛又很深，所以我们这里不可能涵盖所有的内容，但是你可以以本文为起点，然后去深入了解你感兴趣的主题。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文链接：https://sookocheff.com/post/kubernetes/understanding-kubernetes-networking-model&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ad58db239af2134289f33aa1f6650b95</guid>
<title>java日志那些事儿-日志野史</title>
<link>https://toutiao.io/k/xfjpack</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;        今天不聊技术点儿，聊一聊技术背后那些事儿，日志作为我们日常开发中非常重要的一员，每天都会被使用无数次，java日志框架众多，但仔细梳理一下，其实也就那几个。&lt;/p&gt;&lt;p&gt;        了解一下各种日志的由来，也能有助于日志的选型，没有最好的，只有最合适。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibtXlkYgk5nlXuC8ZeRGwplqSF7VTnLicn2ib8qQuXLdyYhGNoXdxDnuD7oFYoYIzQRCsCqByIYuvvOmCFdu9d7EQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;225&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; 追溯时间&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure cid=&quot;n3&quot; mdtype=&quot;table&quot;&gt;&lt;table align=&quot;center&quot;&gt;&lt;thead&gt;&lt;tr cid=&quot;n4&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;日志&lt;/th&gt;&lt;th&gt;归属&lt;/th&gt;&lt;th&gt;出生时间&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n8&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n9&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;System.out&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n10&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;java&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n11&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;1995&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n12&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n13&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Log4J&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n14&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Apache/Ceki Gülcü&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n15&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2001&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n16&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n17&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;JUL(Java Util Logging)&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n18&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;java1.4&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n19&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2002.2&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n20&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n21&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;JCL(Jakarta Commons Logging)&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n22&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Apache&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n23&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2002.8&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n24&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n25&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Slf4j(Simple Logging Facade for Java)&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n26&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Ceki Gülcü&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n27&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2005&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n28&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n29&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Logback&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n30&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Ceki Gülcü&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n31&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2006&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n32&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n33&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Log4j2&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n34&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Apache&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n35&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2012&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;span/&gt;&lt;strong&gt; 纷争开始了&lt;/strong&gt;&lt;/p&gt;&lt;p cid=&quot;n38&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;        最早大家都用System.out或error来打印日志，但错误严重性有高有低，无法区分。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n39&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;        1996年，一个欧盟赞助的 &lt;/span&gt;&lt;span md-inline=&quot;link&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;SEMPER&lt;/span&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;项目打算记录操作API的行为，以便于追溯问题。N. Asokan、Ceki Gülcü 和 Michael Steiner 就提出了分层记录器的想法，这也就是日志级别的由来。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n40&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;        历史总是会留下某个人，然后其他人就没有然后了，哈哈。这个叫切基古尔库的哥们跟他同事一起开发了第一个日志框架Log4j，分层记录的思想是Log4j的核心。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6714975845410628&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibtXlkYgk5nlXuC8ZeRGwplqSF7VTnLicnJa7scf1b3xawB3rMbTo0icMoIg4c75dPz6Ha4c3zD7ljWaaIhvXCHEQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;207&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n40&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n41&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;        2001年，切基古尔库公开了Log4j，拉开了大战的序幕，Log4j加入Apache，切基古尔库也成为了Apache中的一员，大树下面好乘凉，Log4j迅猛发展。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n42&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;        这时的Java还没有自己的日志系统，Apache盯上了Java，建议Sun把Log4j加入到Java体系中。Sun当然拒绝了，卧榻之侧，岂容他人鼾睡，Sun早就坐不住了，在2002年2月发布了Java1.4，在util加入了自己的Logging，JUL腾空出世，想与Log4J一比高下，奈何JUL功效上稍逊三分，无法干掉Log4j，但是依托java庞大的用户群，还是吸引了一些流量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nlXuC8ZeRGwplqSF7VTnLicnIpiakJNyUgnaq4SCENUEa5QVEnwfPcsibSIicV9Wn7VFHDvmQco7IwD3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;225&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong/&gt;&lt;span&gt;        此时的Apache心急如焚，眼看着大把的流量被切走，为了捍卫自己的江湖地位，于2002年8月推出一套interface，Jakarta Commons Logging开始面世，JCL可以让使用者在Log4J和JUL之间来回切换。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3333333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nlXuC8ZeRGwplqSF7VTnLicnBUa9aVvbqpWrXXAtvvbSdP9wYQ1Np91DiaHzewedkQ1NrbialguZfD0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;        JCL面世以后，网友猜测，切基古尔库越来越难以掌控Log4j这个项目，加上Log4j使用不规范导致的一些效能问题，还有一些历史遗留问题难以推动解决，他在2005年离开了Apache，并且自立门户，随即推出了另一款Interface，也就是鼎鼎大名的Simple Logging Facade for Java，Slf4j是一套接口的规范，现在不都讲究面向接口编程嘛。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4262295081967213&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibtXlkYgk5nlXuC8ZeRGwplqSF7VTnLicngcedcnGYRubsn71XFZM25hocMloJbS0fWVFQODicaVPw0ffXahuic0ow/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;305&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p cid=&quot;n45&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;        切基古尔库先拿JCL开刀，为了让JCL的使用者方面使用这套Slf4j，他来了个狸猫换太子，开发了jcl-over-slf4j.jar，接着为了方便Log4j的使用者，把Log4j当做Slf4j的实现类，他加了一层适配器，实现了Slf4j-log4j12.jar。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n46&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;        到现在为止，一共有两套接口(JCL和Slf4j)，两套实现(Log4j和JUL)，为了一统江湖，切基古尔库又开发了log4j-over-slf4j.jar，可以用来替换掉log4j这个实现，进而改为自己的实现。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n47&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;        JUL虽比不过log4j，但是那又怎能放过，2008年的时候，他也在JUL上加了一层适配器，实现了slf4j-jdk14.jar。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.70703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nlXuC8ZeRGwplqSF7VTnLicnGuFAHTSNUiaLFKwicrMcx5e9eO15Fo7JTlZPWrasMK8RUBgmYMxAXBog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n49&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;        Slf4j只是一套接口规则，想要胜出，还是要拿出实际的东西来，切基古尔库深谙这个理儿，从2006年开始，他就着手开发一套属于Slf4j自己的实现，自己亲自开发Log4j，对于其不合理和遗留的问题他太熟悉了，第三套实现Logback也顺理成章的出世了，关键功效上比Log4j更胜一筹&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5384615384615384&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibtXlkYgk5nlXuC8ZeRGwplqSF7VTnLicnEX6ibGibTibvg8ibVaW0dNRic6hDicsYQR3LPAjiaVjYB2g0oOw1NhXtlL9Rg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;260&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n49&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n50&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;        Slf4j和Logback大行其道，Apache也不会坐以待毙，既然你想靠一个Slf4j称霸，那我也搞一个东西出来一统江湖，2012年Log4j2终于问世，但是Log4j2也算是Log4j的直接升级版，但这两的架构相差甚远。但Log4j2的分层方式又能看到Logback的影子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.38&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nlXuC8ZeRGwplqSF7VTnLicnPmUztbia8K1zbcolthLtA3kcJSUVoXdlIibnZsEhUcIAOKbkbsJqziazg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n51&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;        至此，java世界的Log之争暂时先告一段落。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt; 关于日志选型&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;        &lt;span/&gt;&lt;/strong&gt;&lt;span&gt;JCL和Slf4j是接口，log4j、log4j2、logback都是实现，&lt;span&gt;日常开发&lt;/span&gt;一般会选择接口+实现的方式来作为项目日志的集成方式，网上很多关于log4j2与logback各种性能参数的对比，大都是基于特定的版本，这也从侧面告诉我们，在实际开发过程中，要结合自己项目，在确定jdk或者spring版本的基础上，再去选择对比各日志性能的优劣。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        具体各版本的性能对比，可以参考官方文档，&lt;span&gt;Ceki Gülcü在前一段时间也更新了logback压测项目代码，感兴趣的可以参考https://github.com/ceki/logback-perf&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibtXlkYgk5nlXuC8ZeRGwplqSF7VTnLicnCicvaNS5wCz1sewibuIiasoMXTYvjV0aCxoG1QswlmyEertWnC2A5d9Ig/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;460&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Ce&lt;/span&gt;&lt;span&gt;ki Gülcü&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NzgyODc1Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nkfMR8jIdDMBaicx5IaEQEicxheyqWdKmULWRebqHutmdSyWah0OOGpClJjnichGJFqGHmhwjCrrHFUA/0?wx_fmt=png&quot; data-nickname=&quot;bugCoder&quot; data-alias=&quot;bugCoder&quot; data-signature=&quot;计算机编程自学成才，技术分享，共同进步&quot; data-from=&quot;1&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0edf6a0ca36cf8ca1a1702466649fe93</guid>
<title>非常哇塞的 SpringBoot性能优化长文！</title>
<link>https://toutiao.io/k/srppeol</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;174&quot; data-backw=&quot;365&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4767123287671233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cvQbJDZsKLp6wejHtKTRbqqQyt0wMk9K1wNtuwRqQTJAPOJ1KiaqSeSRbIJRTicVicKpDKRndBodY2DBNN20tvWwA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;365&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原创：小姐姐味道（微信公众号ID：xjjdog），欢迎分享，转载请保留出处。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SpringBoot已经成为Java届的No.1框架，每天都在蹂躏着数百万的程序员们。当服务的压力上升，对SpringBoot服务的优化就会被提上议程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文将详细讲解SpringBoot服务优化的一般思路，并附上若干篇辅助文章作为开胃菜。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文较长，最适合收藏之。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.有监控才有方向&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开始对&lt;code&gt;SpringBoot&lt;/code&gt;服务进行性能优化之前，我们需要做一些准备，把&lt;code&gt;SpringBoot&lt;/code&gt;服务的一些数据暴露出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，你的服务用到了缓存，就需要把缓存命中率这些数据进行收集；用到了数据库连接池，就需要把连接池的参数给暴露出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们这里采用的监控工具是&lt;code&gt;Prometheus&lt;/code&gt;，它是一个是时序数据库，能够存储我们的指标。&lt;code&gt;SpringBoot&lt;/code&gt;可以非常方便的接入到&lt;code&gt;Prometheus&lt;/code&gt;中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个&lt;code&gt;SpringBoot&lt;/code&gt;项目后，首先，加入&lt;code&gt;maven&lt;/code&gt;依赖。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-actuator&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;io.micrometer&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;micrometer-registry-prometheus&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;io.micrometer&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;micrometer-core&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，我们需要在&lt;code&gt;application.properties&lt;/code&gt;配置文件中，开放相关的监控接口。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;management.endpoint.metrics.enabled=true&lt;br/&gt;management.endpoints.web.exposure.include=*&lt;br/&gt;management.endpoint.prometheus.enabled=true&lt;br/&gt;management.metrics.export.prometheus.enabled=true&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动之后，我们就可以通过访问 &lt;code&gt;http://localhost:8080/actuator/prometheus&lt;/code&gt; 来获取监控数据。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.44061757719714967&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLqsdtIRyNhsicvAugcLQCLibvia3HUgicKgMLVqnqeutyTnnsp18bVibYgTJN4GSQxeQKjkOGsTppbLg4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;842&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要监控业务数据也是比较简单的。你只需要注入一个&lt;code&gt;MeterRegistry&lt;/code&gt;实例即可。下面是一段示例代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;MeterRegistry registry;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/test&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@ResponseBody&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    registry.counter(&lt;span&gt;&quot;test&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;from&quot;&lt;/span&gt;, &lt;span&gt;&quot;127.0.0.1&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;method&quot;&lt;/span&gt;, &lt;span&gt;&quot;test&quot;&lt;/span&gt;&lt;br/&gt;    ).increment();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;ok&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从监控连接中，我们可以找到刚刚添加的监控信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;test_total{from=&lt;span&gt;&quot;127.0.0.1&quot;&lt;/span&gt;,method=&lt;span&gt;&quot;test&quot;&lt;/span&gt;,} &lt;span&gt;5.0&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里简单介绍一下流行的&lt;code&gt;Prometheus&lt;/code&gt;监控体系，&lt;code&gt;Prometheus&lt;/code&gt;使用&lt;code&gt;拉&lt;/code&gt;的方式获取监控数据，这个暴露数据的过程可以交给功能更加齐全的&lt;code&gt;telegraf&lt;/code&gt;组件。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.47177848775292863&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLqsdtIRyNhsicvAugcLQCLibvDkLrIRmXsYBkFw0FPSYibx9VISCkJD43vTkwicbEhZibxG8l8vjAVzGVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;939&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图，我们通常使用&lt;code&gt;Grafana&lt;/code&gt;进行监控数据的展示，使用&lt;code&gt;AlertManager&lt;/code&gt;组件进行提前预警。这一部分的搭建工作不是我们的重点，感兴趣的同学可自行研究。下图便是一张典型的监控图，可以看到Redis的缓存命中率等情况。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.42602230483271375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLqsdtIRyNhsicvAugcLQCLibviaNBBj87DLqfr5dZWibibIibAuwurChggGbomntcVCd5cbCGo3eknMCQvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1345&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.Java生成火焰图&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;火焰图是用来分析程序运行瓶颈的工具。在纵向，表示的是调用栈的深度；横向表明的是消耗的时间。所以格子的宽度越大，越说明它可能是一个瓶颈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;火焰图也可以用来分析Java应用。可以从github上下载&lt;code&gt;async-profiler&lt;/code&gt;的压缩包 进行相关操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，我们把它解压到&lt;code&gt;/root/&lt;/code&gt;目录。然后以&lt;code&gt;javaagent&lt;/code&gt;的方式来启动Java应用。命令行如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;java -agentpath:/root/build/libasyncProfiler.so=start,svg,file=profile.svg -jar spring-petclinic-2.3.1.BUILD-SNAPSHOT.jar&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行一段时间后，停止进程，可以看到在当前目录下，生成了&lt;code&gt;profile.svg&lt;/code&gt;文件，这个文件是可以用浏览器打开的，一层层向下浏览，即可找到需要优化的目标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.Skywalking&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一个web服务来说，最缓慢的地方就在于数据库操作。所以，使用本地缓存和分布式缓存优化，能够获得最大的性能提升。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于如何定位到复杂分布式环境中的问题，我这里想要分享另外一个工具：&lt;code&gt;Skywalking&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Skywalking是使用探针技术（JavaAgent）来实现的。通过在Java的启动参数中，加入&lt;code&gt;javaagent&lt;/code&gt;的Jar包，即可将性能数据和调用链数据封装、发送到Skywalking的服务器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下载相应的安装包（如果使用ES存储，需要下载专用的安装包），配置好存储之后，即可一键启动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将agent的压缩包，解压到相应的目录。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;tar xvf skywalking-agent.tar.gz  -C /opt/&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在业务启动参数中加入agent的包。比如，原来的启动命令是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;java  -jar /opt/&lt;span&gt;test&lt;/span&gt;-service/spring-boot-demo.jar  --spring.profiles.active=dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改造后的启动命令是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;java -javaagent:/opt/skywalking-agent/skywalking-agent.jar -Dskywalking.agent.service_name=the-demo-name  -jar /opt/&lt;span&gt;test&lt;/span&gt;-service/spring-boot-demo.ja  --spring.profiles.active=dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;访问一些服务的链接，打开&lt;code&gt;Skywalking&lt;/code&gt;的UI，即可看到下图的界面。我们可以从图中找到响应比较慢QPS又比较高的的接口，进行专项优化。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.44945188794153473&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLqsdtIRyNhsicvAugcLQCLibviahhBqebjCibpUXyGJzFtaouQBoqPXLn2iaerFCSBf4M1AXrWibfYxUCcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1642&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;15723404104715&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.优化思路&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对一个普通的Web服务来说，我们来看一下，要访问到具体的数据，都要经历哪些主要的环节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图，在浏览器中输入相应的域名，需要通过DNS解析到具体的IP地址上。为了保证高可用，我们的服务一般都会部署多份，然后使用Nginx做反向代理和负载均衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nginx根据资源的特性，会承担一部分动静分离的功能。其中，动态功能部分，会进入我们的SpringBoot服务。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.565947242206235&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLqsdtIRyNhsicvAugcLQCLibvw3htKhPJeDicWHovnR7TMcV9LagaG8DFNNNURVSM62OiaVaHJQa1AtbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;834&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SpringBoot默认使用内嵌的tomcat作为Web容器，使用典型的MVC模式，最终访问到我们的数据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.HTTP优化&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们举例来看一下，哪些动作能够加快网页的获取。为了描述方便，我们仅讨论&lt;code&gt;HTTP1.1&lt;/code&gt;协议的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1.使用CDN加速文件获取&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较大的文件，尽量使用CDN（Content Delivery Network）分发。甚至是一些常用的前端脚本、样式、图片等，都可以放到CDN上。CDN通常能够加快这些文件的获取，网页加载也更加迅速。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.合理设置Cache-Control值&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;浏览器会判断HTTP头&lt;code&gt;Cache-Control&lt;/code&gt;的内容，用来决定是否使用浏览器缓存，这在管理一些静态文件的时候，非常有用。相同作用的头信息还有&lt;code&gt;Expires&lt;/code&gt;。&lt;code&gt;Cache-Control&lt;/code&gt;表示多久之后过期，&lt;code&gt;Expires&lt;/code&gt;则表示什么时候过期。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个参数可以在Nginx的配置文件中进行设置。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;location ~* ^.+\.(ico|gif|jpg|jpeg|png)$ { &lt;br/&gt;            # 缓存1年&lt;br/&gt;            add_header Cache-Control: no-cache, max-age=31536000;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3.减少单页面请求域名的数量&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;减少每个页面请求的域名数量，尽量保证在4个之内。这是因为，浏览器每次访问后端的资源，都需要先查询一次DNS，然后找到DNS对应的IP地址，再进行真正的调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DNS有多层缓存，比如浏览器会缓存一份、本地主机会缓存、ISP服务商缓存等。从DNS到IP地址的转变，通常会花费&lt;code&gt;20-120ms&lt;/code&gt;的时间。减少域名的数量，可加快资源的获取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4.开启gzip&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开启gzip，可以先把内容压缩后，浏览器再进行解压。由于减少了传输的大小，会减少带宽的使用，提高传输效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在nginx中可以很容易的开启。配置如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;gzip on;&lt;br/&gt;gzip_min_length 1k;&lt;br/&gt;gzip_buffers 4 16k;&lt;br/&gt;gzip_comp_level 6;&lt;br/&gt;gzip_http_version 1.1;&lt;br/&gt;gzip_types text/plain application/javascript text/css;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;5.对资源进行压缩&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对JavaScript和CSS，甚至是HTML进行压缩。道理类似，现在流行的前后端分离模式，一般都是对这些资源进行压缩的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;6.使用keepalive&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于连接的创建和关闭，都需要耗费资源。用户访问我们的服务后，后续也会有更多的互动，所以保持长连接可以显著减少网络交互，提高性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nginx默认开启了对客户端的keep avlide支持。你可以通过下面两个参数来调整它的行为。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;http {&lt;br/&gt;    keepalive_timeout  120s 120s;&lt;br/&gt;    keepalive_requests 10000;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nginx与后端upstream的长连接，需要手工开启，参考配置如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;location ~ /{ &lt;br/&gt;       proxy_pass http://backend;&lt;br/&gt;       proxy_http_version 1.1;&lt;br/&gt;       proxy_set_header Connection &quot;&quot;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.Tomcat优化&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomcat本身的优化，也是非常重要的一环。可以直接参考下面的文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;amp;mid=2650523823&amp;amp;idx=1&amp;amp;sn=aa5f41974950e759d373505e9b7c32f6&amp;amp;chksm=8780cf6bb0f7467d0e1b4d2d957e3633726c11f30e185d9ed354f2f6ad2ff607357f555097ef&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;搞定tomcat重要参数调优！&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.自定义Web容器&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web容器的方式，代码如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@SpringBootApplication&lt;/span&gt;(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;App&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;WebServerFactoryCustomizer&lt;/span&gt;&amp;lt;&lt;span&gt;ConfigurableServletWebServerFactory&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  SpringApplication.run(PetClinicApplication&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;args&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;customize&lt;/span&gt;&lt;span&gt;(ConfigurableServletWebServerFactory factory)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  TomcatServletWebServerFactory f = (TomcatServletWebServerFactory) factory;&lt;br/&gt;        f.setProtocol(&lt;span&gt;&quot;org.apache.coyote.http11.Http11Nio2Protocol&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  f.addConnectorCustomizers(c -&amp;gt; {&lt;br/&gt;   Http11NioProtocol protocol = (Http11NioProtocol) c.getProtocolHandler();&lt;br/&gt;   protocol.setMaxConnections(&lt;span&gt;200&lt;/span&gt;);&lt;br/&gt;   protocol.setMaxThreads(&lt;span&gt;200&lt;/span&gt;);&lt;br/&gt;   protocol.setSelectorTimeout(&lt;span&gt;3000&lt;/span&gt;);&lt;br/&gt;   protocol.setSessionTimeout(&lt;span&gt;3000&lt;/span&gt;);&lt;br/&gt;   protocol.setConnectionTimeout(&lt;span&gt;3000&lt;/span&gt;);&lt;br/&gt;  });&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意上面的代码，我们设置了它的协议为&lt;code&gt;org.apache.coyote.http11.Http11Nio2Protocol&lt;/code&gt;，意思就是开启了Nio2。这个参数在&lt;code&gt;Tomcat8.0&lt;/code&gt;之后才有，开启之后会增加一部分性能。对比如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;[root@localhost wrk2-master]&lt;span&gt;# ./wrk -t2 -c100 -d30s -R2000 http://172.16.1.57:8080/owners?lastName=&lt;/span&gt;&lt;br/&gt;Running 30s &lt;span&gt;test&lt;/span&gt; @ http://172.16.1.57:8080/owners?lastName=&lt;br/&gt;  2 threads and 100 connections&lt;br/&gt;  Thread calibration: mean lat.: 4588.131ms, rate sampling interval: 16277ms&lt;br/&gt;  Thread calibration: mean lat.: 4647.927ms, rate sampling interval: 16285ms&lt;br/&gt;  Thread Stats   Avg      Stdev     Max   +/- Stdev&lt;br/&gt;    Latency    16.49s     4.98s   27.34s    63.90%&lt;br/&gt;    Req/Sec   106.50      1.50   108.00    100.00%&lt;br/&gt;  6471 requests &lt;span&gt;in&lt;/span&gt; 30.03s, 39.31MB &lt;span&gt;read&lt;/span&gt;&lt;br/&gt;  Socket errors: connect 0, &lt;span&gt;read&lt;/span&gt; 0, write 0, timeout 60&lt;br/&gt;Requests/sec:    215.51&lt;br/&gt;Transfer/sec:      1.31MB&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nio2。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;[root@localhost wrk2-master]&lt;span&gt;# ./wrk -t2 -c100 -d30s -R2000 http://172.16.1.57:8080/owners?lastName=&lt;/span&gt;&lt;br/&gt;Running 30s &lt;span&gt;test&lt;/span&gt; @ http://172.16.1.57:8080/owners?lastName=&lt;br/&gt;  2 threads and 100 connections&lt;br/&gt;  Thread calibration: mean lat.: 4358.805ms, rate sampling interval: 15835ms&lt;br/&gt;  Thread calibration: mean lat.: 4622.087ms, rate sampling interval: 16293ms&lt;br/&gt;  Thread Stats   Avg      Stdev     Max   +/- Stdev&lt;br/&gt;    Latency    17.47s     4.98s   26.90s    57.69%&lt;br/&gt;    Req/Sec   125.50      2.50   128.00    100.00%&lt;br/&gt;  7469 requests &lt;span&gt;in&lt;/span&gt; 30.04s, 45.38MB &lt;span&gt;read&lt;/span&gt;&lt;br/&gt;  Socket errors: connect 0, &lt;span&gt;read&lt;/span&gt; 0, write 0, timeout 4&lt;br/&gt;Requests/sec:    248.64&lt;br/&gt;Transfer/sec:      1.51MB&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你甚至可以将&lt;code&gt;tomcat&lt;/code&gt;替换成&lt;code&gt;undertow&lt;/code&gt;。&lt;code&gt;undertow&lt;/code&gt;也是一个Web容器，更加轻量级一些，占用的内容更少，启动的守护进程也更少，更改方式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;exclusions&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;exclusion&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-tomcat&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;exclusion&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;exclusions&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-undertow&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.各个层次的优化方向&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Controller层&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;controller&lt;/code&gt;层用于接收前端的查询参数，然后构造查询结果。现在很多项目都采用前后端分离的架构，所以&lt;code&gt;controller&lt;/code&gt;层的方法，一般会使用&lt;code&gt;@ResponseBody&lt;/code&gt;注解，把查询的结果，解析成JSON数据返回（兼顾效率和可读性）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于&lt;code&gt;controller&lt;/code&gt;只是充当了一个类似功能组合和路由的角色，所以这部分对性能的影响就主要体现在数据集的大小上。如果结果集合非常大，JSON解析组件就要花费较多的时间进行解析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大结果集不仅会影响解析时间，还会造成内存浪费。假如结果集在解析成JSON之前，占用的内存是10MB，那么在解析过程中，有可能会使用20M或者更多的内存去做这个工作。我见过很多案例，由于返回对象的嵌套层次太深、引用了不该引用的对象（比如非常大的byte[]对象），造成了内存使用的飙升。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，对于一般的服务，保持结果集的精简，是非常有必要的，这也是DTO(data transfer object)存在的必要。如果你的项目，返回的结果结构比较复杂，对结果集进行一次转换是非常有必要的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，可以使用异步Servlet对Controller层进行优化。它的原理如下：Servlet 接收到请求之后，将请求转交给一个异步线程来执行业务处理，线程本身返回至容器，异步线程处理完业务以后，可以直接生成响应数据，或者将请求继续转发给其它 Servlet。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Service层&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;service层用于处理具体的业务，大部分功能需求都是在这里完成的。service层一般是使用单例模式（prototype），很少会保存状态，而且可以被&lt;code&gt;controller&lt;/code&gt;复用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;service层的代码组织，对代码的可读性、性能影响都比较大。我们常说的设计模式，大多数都是针对于service层来说的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里要着重提到的一点，就是分布式事务。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3979848866498741&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLqsdtIRyNhsicvAugcLQCLibv5b5ZmIDDZ0NHWfu4slZJq0uHfbUGiallmamOOTtyAZtkB7lMSTYG3AA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;794&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图，四个操作分散在三个不同的资源中。要想达到一致性，需要三个不同的资源进行统一协调。它们底层的协议，以及实现方式，都是不一样的。那就无法通过Spring提供的&lt;code&gt;Transaction&lt;/code&gt;注解来解决，需要借助外部的组件来完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多人都体验过，加入了一些保证一致性的代码，一压测，性能掉的惊掉下巴。分布式事务是性能杀手，因为它要使用额外的步骤去保证一致性，常用的方法有：两阶段提交方案、TCC、本地消息表、MQ事务消息、分布式事务中间件等。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4764309764309764&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLqsdtIRyNhsicvAugcLQCLibvOdWz4ddbwyBick7BgxdicjOeWsc3dUuNwORATN9ZpmQ7KlibVlrywlgMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;594&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图，分布式事务要在改造成本、性能、实效等方面进行综合考虑。有一个介于分布式事务和非事务之间的名词，叫做&lt;code&gt;柔性事务&lt;/code&gt;。柔性事务的理念是将业务逻辑和互斥操作，从资源层上移至业务层面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于传统事务和柔性事务，我们来简单比较一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ACID&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关系数据库, 最大的特点就是事务处理, 即满足ACID。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;原子性（Atomicity）：事务中的操作要么都做，要么都不做。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一致性（Consistency）：系统必须始终处在强一致状态下。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;隔离性（Isolation）：一个事务的执行不能被其他事务所干扰。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;持续性（Durability）：一个已提交的事务对数据库中数据的改变是永久性的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;BASE&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;BASE&lt;/code&gt;方法通过牺牲一致性和孤立性来提高可用性和系统性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;BASE&lt;/code&gt;为Basically Available, Soft-state, Eventually consistent三者的缩写，其中BASE分别代表：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;基本可用（Basically Available）：系统能够基本运行、一直提供服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;软状态（Soft-state）：系统不要求一直保持强一致状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最终一致性（Eventual consistency）：系统需要在某一时刻后达到一致性要求。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;互联网业务，推荐使用补偿事务，完成最终一致性。比如，通过一系列的定时任务，完成对数据的修复。具体可以参照下面的文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;amp;mid=2650525007&amp;amp;idx=1&amp;amp;sn=1dccfcb84f21fd9fe335a756a9c78c0f&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;常用的 分布式事务 都有哪些？我该用哪个？&lt;/a&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Dao层&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过合理的数据缓存，我们都会尽量避免请求穿透到Dao层。除非你对ORM本身提供的缓存特性特别的熟悉，否则，都推荐你使用更加通用的方式去缓存数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Dao层，主要在于对ORM框架的使用上。比如，在JPA中，如果加了一对多或者多对多的映射关系，而又没有开启懒加载，级联查询的时候就容易造成深层次的检索，造成了内存开销大、执行缓慢的后果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一些数据量比较大的业务中，多采用分库分表的方式。在这些分库分表组件中，很多简单的查询语句，都会被重新解析后分散到各个节点进行运算，最后进行结果合并。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，&lt;code&gt;select count(*) from a&lt;/code&gt;这句简单的count语句，就可能将请求路由到十几张表中去运算，最后在协调节点进行统计，执行效率是可想而知的。目前，分库分表中间件，比较有代表性的是驱动层的ShardingJdbc和代理层的MyCat，它们都有这样的问题。这些组件提供给使用者的视图是一致的，但我们在编码的时候，一定要注意这些区别。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;End&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来总结一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们简单看了一下SpringBoot常见的优化思路。我们介绍了三个新的性能分析工具。一个是监控系统Prometheus，可以看到一些具体的指标大小；一个是火焰图，可以看到具体的代码热点；一个是Skywalking，可以分析分布式环境中的调用链。在对性能有疑惑的时候，我们都会采用类似于&lt;code&gt;神农氏尝百草&lt;/code&gt;的方式，综合各种测评工具的结果进行分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SpringBoot自身的Web容器是Tomcat，那我们就可以通过对Tomcat的调优来获取性能提升。当然，对于服务上层的负载均衡Nginx，我们也提供了一系列的优化思路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们看了在经典的MVC架构下，Controller、Service、Dao的一些优化方向，并着重看了Service层的分布式事务问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有一个具体的优化示例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;amp;mid=2650524679&amp;amp;idx=1&amp;amp;sn=8881766b35e1d65a65e520f3514f0ec9&amp;amp;chksm=8780cbc3b0f742d5721f10ec8eea9823ed8a7dbec4364846706e34df44b9e4518fed11b02906&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;5秒到1秒，记一次效果“非常”显著的性能优化&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SpringBoot&lt;/code&gt;作为一个广泛应用的服务框架，在性能优化方面已经做了很多工作，选用了很多高速组件。比如，数据库连接池默认使用&lt;code&gt;hikaricp&lt;/code&gt;，Redis缓存框架默认使用&lt;code&gt;lettuce&lt;/code&gt;，本地缓存提供&lt;code&gt;caffeine&lt;/code&gt;等。对于一个普通的于数据库交互的Web服务来说，缓存是最主要的优化手。但细节决定成败，你要是想对系统做极致的优化，还需要参考下面的这篇文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;amp;mid=2650522440&amp;amp;idx=1&amp;amp;sn=e06d3848bf84ec0da769a41b2ec59482&amp;amp;chksm=8780c48cb0f74d9a9cfcc6b69f36d1f197f1d3942e9864225ed4212d2130b6f7862c427eba26&amp;amp;token=1153507763&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;卓越性能 の 军火库（非广告）&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完！&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者简介：&lt;strong&gt;小姐姐味道&lt;/strong&gt;  (xjjdog)，一个不允许程序员走弯路的公众号。聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。我的个人微信xjjdog0，欢迎添加好友，进一步交流。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e64c81ad40e2372240c2a68a28098054</guid>
<title>Go+ SSA 引擎的开发进展</title>
<link>https://toutiao.io/k/xav0prh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;Go+ SSA  ( https://github.com/goplus/gossa ) 是一个基于 SSA  实现的 Go 语言解释器，可以直接从 Go/Go+ 源码运行程序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在去年的 Go+ 公开课上我分享了 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNTAxNjc2OQ==&amp;amp;mid=2247483705&amp;amp;idx=1&amp;amp;sn=608f67722f9b79383d77e9cc56e60c18&amp;amp;chksm=9b225c97ac55d58111f3053c991cc2c070e8b0eb020d8df6d15067731f880f182b8dcaf3e4ca&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Go+ SSA 脚本引擎简介丨Go+ 公开课 · 第8期&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Go+ SSA 脚本引擎简介丨Go+ 公开课 · 第8期&lt;/a&gt;，简要介绍了 gossa 主要功能和如何使用，当时在使用上还存在一些限制，无法支持 Go 1.17 amd64 上新的基于寄存器的函数调用方式。&lt;/p&gt;&lt;p&gt;经过了几个月的开发迭代，目前 gossa 重构了部分设计实现，在平台支持和运行效率上有了很大的提高。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;完全支持 Go 1.17/Go1.18 新的基于寄存器的函数调用方式。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;对这些的平台支持与 Go1.17/Go1.18 保持一致，使用 qemu 模拟对应平台测试通过。&lt;/p&gt;&lt;p&gt;函数调用支持实际由 reflectx ( https://github.com/goplus/reflectx ) 库实现。在 reflectx 中实现了对 &lt;span&gt;ABI0&lt;/span&gt; ( 基于堆栈的调用方式）和 &lt;span&gt;ABIInternal&lt;/span&gt; （基于寄存器调用方式）的支持，ABI0 的支持我使用了 reflect/unsafe 直接计算实现，而对于 ABIInternal 的支持则是使用 asm 做了一个调用转发。 核心思想就是将对方法的调用转化为对函数（通过 reflect.MakeFunc 动态生成）的调用。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;func&lt;/span&gt; (t *T) Call(args) =&amp;gt; func(t *T, args)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 脚本运行速度有了较大的提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;gossa 之前是使用解释器执行的方式，即将生成的 ssa ir 代码按顺序解释运行，运行速度慢。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;Go&lt;/span&gt; 源码 -&amp;gt; AST -&amp;gt; SSA IR -&amp;gt; 直接解释执行&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;目前重构为将 ssa ir 序列代码预编译为 closure 闭包函数列表，之后执行闭包函数列表的方式实现，类似于 VM 的 bytecode 方式，但 gossa 这里没有 bytecode ，只有闭包列表。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;Go&lt;/span&gt; 源码 -&amp;gt; AST -&amp;gt; SSA IR -&amp;gt; closure list -&amp;gt; 执行 closure&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了测试脚本运行速度，我使用 fib(35) 函数进行测试，我使用了本机上的 python2.7，python 3.9 ，lua 5.4， go-lua，gopher-lua，yaegi，tengo 进行测试，lua 和 python 具有典型代表性，后四个则同样是由 Go 语言实现的脚本引擎，使用官方最新版本。gossa 使用最新版本 v0.3.20 。&lt;/p&gt;&lt;p&gt;fib 算法的 Go 源码表示如下，lua 和 python 版本类似。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(n &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; n &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; n&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; fib(n&lt;span class=&quot;code-snippet__number&quot;&gt;-2&lt;/span&gt;) + fib(n&lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过 time gossa run fib.go 的方式运行，统计结果如下。(本结果只展示上述 fib 算法本机测试，选择不同的算法或运行环境结果会不同）&lt;/p&gt;&lt;table cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;程序&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;运行时间&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;lua&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;0.91s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;ossa&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;2.71s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;python2&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;3.97s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;python3&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;4.86s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;tengo&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;3.95s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;lua&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;4.15s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;gopher-lua&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;5.04s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;yaegi&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;22.08s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;运行最快为 lua 0.91s，gossa 排在第 2 用时 2.71 s，用时约为 lua 的 3 倍。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下表为 gossa 开发迭代过程中，经历的不同版本运行 fib (35) 时间统计&lt;/p&gt;&lt;table cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;gossa git tag &lt;/span&gt;&lt;span&gt;版本&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;运行时间&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;gossa v0.3.9&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;1m39s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;gossa v0.3.10&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;31.91s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;gossa v0.3.11&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;31.14s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;gossa v0.3.12&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;27.33s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;gossa v0.3.13&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;13.25s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;gossa v0.3.14~v0.3.16&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;12.20s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;gossa v0.3.17&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;12.05s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;gossa v0.3.18&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;3.90s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;gossa v0.3.19&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;3.52s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;ossa&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;v0.&lt;/span&gt;&lt;span&gt;3.20&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;2.71s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;从&lt;/span&gt;&lt;span&gt;这个表格可以看到迭代优化带来的效果还是相当明显的，最新的 gossa 在运行 fib(35) 上用时大约为 lua 的 3 倍。&lt;/span&gt;&lt;span&gt;当然，&lt;/span&gt;&lt;span&gt;目前对 gossa 的优化仍在继续进行中，比如 &amp;lt;&amp;lt; 和 &amp;gt;&amp;gt; 运算符执行较慢，还没有做针对优化处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>