<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d82b3112b8fffa5bb22b7572ea30a579</guid>
<title>也许你该找个人聊聊？</title>
<link>https://toutiao.io/k/1qrbh71</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3a2fc991493678f4ac8cc32ff53d1240</guid>
<title>[推荐] 面试官问: 如何设计一个高并发系统?</title>
<link>https://toutiao.io/k/7hrrplb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h2&gt;题目描述&lt;/h2&gt;

&lt;p&gt;面试官有时在面试中会直接问你：你是如何设计一个高并发系统？&lt;/p&gt;

&lt;h2&gt;面试官心理分析（解题思维方向）&lt;/h2&gt;

&lt;p&gt;说实话，如果面试官问你这个题目，那么你必须要使出全身吃奶劲了。为啥？因为你没看到现在很多公司招聘的 JD 里都是说啥，有高并发就经验者优先。&lt;/p&gt;

&lt;p&gt;如果你确实有真才实学，在互联网公司里干过高并发系统，那你确实拿 offer 基本如探囊取物，没啥问题。面试官也绝对不会这样来问你，否则他就是蠢。&lt;/p&gt;

&lt;p&gt;假设你在某知名电商公司干过高并发系统，用户上亿，一天流量几十亿，高峰期并发量上万，甚至是十万。那么人家一定会仔细盘问你的系统架构，你们系统啥架构？怎么部署的？部署了多少台机器？缓存咋用的？MQ 咋用的？数据库咋用的？就是深挖你到底是如何扛住高并发的。&lt;/p&gt;

&lt;p&gt;因为真正干过高并发的人一定知道，脱离了业务的系统架构都是在纸上谈兵，真正在复杂业务场景而且还高并发的时候，那系统架构一定不是那么简单的，用个 redis，用 mq 就能搞定？当然不是，真实的系统架构搭配上业务之后，会比这种简单的所谓“高并发架构”要复杂很多倍。&lt;/p&gt;

&lt;p&gt;如果有面试官问你个问题说，如何设计一个高并发系统？那么不好意思，一定是因为你实际上没干过高并发系统。面试官看你简历就没啥出彩的，感觉就不咋地，所以就会问问你，如何设计一个高并发系统？其实说白了本质就是看看你有没有自己研究过，有没有一定的知识积累。&lt;/p&gt;

&lt;p&gt;最好的当然是招聘个真正干过高并发的哥儿们咯，但是这种哥儿们人数稀缺，不好招。所以可能次一点的就是招一个自己研究过的哥儿们，总比招一个啥也不会的哥儿们好吧！
所以这个时候你必须得做一把个人秀了，秀出你所有关于高并发的知识！&lt;/p&gt;

&lt;h2&gt;面试题剖析&lt;/h2&gt;

&lt;p&gt;其实所谓的高并发，如果你要理解这个问题呢，其实就得从高并发的根源出发，为啥会有高并发？为啥高并发就很牛逼？&lt;/p&gt;

&lt;p&gt;我说的浅显一点，很简单，就是因为刚开始系统都是连接数据库的，但是要知道数据库支撑到每秒并发两三千的时候，基本就快完了。所以才有说，很多公司，刚开始干的时候，技术比较 low，结果业务发展太快，有的时候系统扛不住压力就挂了。&lt;/p&gt;

&lt;p&gt;当然会挂了，凭什么不挂？你数据库如果瞬间承载每秒 5000/8000，甚至上万的并发，一定会宕机，因为比如 mysql 就压根儿扛不住这么高的并发量。&lt;/p&gt;

&lt;p&gt;所以为啥高并发牛逼？就是因为现在用互联网的人越来越多，很多 app、网站、系统承载的都是高并发请求，可能高峰期每秒并发量几千，很正常的。如果是什么双十一之类的，每秒并发几万几十万都有可能。&lt;/p&gt;

&lt;p&gt;那么如此之高的并发量，加上原本就如此之复杂的业务，咋玩儿？真正厉害的，一定是在复杂业务系统里玩儿过高并发架构的人，但是你没有，那么我给你说一下你该怎么回答这个问题：&lt;/p&gt;

&lt;p&gt;可以分为以下 6 点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;系统拆分&lt;/li&gt;
&lt;li&gt;缓存&lt;/li&gt;
&lt;li&gt;MQ&lt;/li&gt;
&lt;li&gt;分库分表&lt;/li&gt;
&lt;li&gt;读写分离&lt;/li&gt;
&lt;li&gt;ElasticSearch&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;系统拆分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将一个系统拆分为多个子系统，用 dubbo 来搞。然后每个系统连一个数据库，这样本来就一个库，现
在多个数据库，不也可以扛高并发么。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缓存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;缓存，必须得用缓存。大部分的高并发场景，都是读多写少，那你完全可以在数据库和缓存里都写一
份，然后读的时候大量走缓存不就得了。毕竟人家 redis 轻轻松松单机几万的并发。所以你可以考虑考
虑你的项目里，那些承载主要请求的读场景，怎么用缓存来抗高并发。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MQ&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MQ，必须得用 MQ。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用 redis 来承载写那肯定不行，人家是缓存，数据随时就被 LRU 了，数据格式还无比简单，没有事务支持。所以该用 mysql 还得用 mysql啊。那你咋办？用 MQ 吧，大量的写请求灌入 MQ 里，排队慢慢玩儿，后边系统消费后慢慢写，控制在 mysql 承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用MQ 来异步写，提升并发性。MQ 单机抗几万并发也是 ok 的，这个之前还特意说过。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分库分表&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高 sql 跑的性能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;读写分离&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。读流量太多的时候，还可以加更多的从库。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ElasticSearch&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Elasticsearch，简称 es。es 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用 es 来承载，还有一些全文搜索类的操作，也可以考虑用 es 来承载。&lt;/p&gt;

&lt;p&gt;上面的 6 点，基本就是高并发系统肯定要干的一些事儿，大家可以仔细结合之前讲过的知识考虑一下，到时候你可以系统的把这块阐述一下，然后每个部分要注意哪些问题，之前都讲过了，你都可以阐述阐述，表明你对这块是有点积累的。&lt;/p&gt;

&lt;h2&gt;考题变形&lt;/h2&gt;



&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;其实实际上在真正的复杂的业务系统里，做高并发要远远比上面提到的点要复杂几十倍到上百倍。你需要考虑：哪些需要分库分表，哪些不需要分库分表，单库单表跟分库分表如何 join，哪些数据要放到缓存里去，放哪些数据才可以扛住高并发的请求，你需要完成对一个复杂业务系统的分析之后，然后逐步逐步的加入高并发的系统架构的改造&lt;/p&gt;

&lt;h2&gt;号外号外&lt;/h2&gt;

&lt;p&gt;给大家整理了Java最新大厂面试题及答案，并且整理成了PDF格式方便阅读。 欢迎大家关注”浅谈架构“ 公众号 (后台私信”面试“即可获取)。另外需要大厂内推同学也可以私信我。 &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.bytearch.com/images/mianshiti.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.bytearch.com/images/wxgzh.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7dd18292d4ab37144650926260b5a841</guid>
<title>[推荐] 技术干货｜缓存一致性最佳实践</title>
<link>https://toutiao.io/k/zgmi04u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4382826&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbbFu7n3GktsBgczeVd0RHngWc5I6Wvf01FzUtDwQibTQEpYeZSM64W8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;559&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;背景 &lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;最近团队里我们在密集的讨论Redis缓存一致性相关的问题，电商核心的域如商品、营销、库存、订单等实际上在缓存的选择上各有特色，那么在这些差异的业务背后，我们有没有一些最佳实践可供参考呢？&lt;/p&gt;&lt;p&gt;本文尝试着来讨论这个问题，并给出一些建议。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在讨论之前，有两个重点我们需要达成一致：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分布式场景下无法做到强一致&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不同于CPU硬件缓存体系采用的MESI协议以及硬件的强时钟控制，分布式场景下我们无法做到缓存与底层数据库的强一致，即把缓存和数据库的数据变更做成一个原子操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;硬件工程师设计了内存屏障（Memory Barrier）的概念，提供给软件开发者不同的一致性选项在性能与一致性上进行权衡。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;就算是达到最终一致性也很难&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;分布式场景下，要做到最终一致性，就要求缓存中存储的是最新版本的数据（或者缓存为空），而且是在数据库更新后很迅速的就要达到这个一致性的状态，要做到是极其困难的。&lt;/p&gt;&lt;p&gt;我们会面临硬件、软件、通信等等组件非常多的异常情况。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5409836&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbvSxeCUz3xV2YIUErVqjzgbHHKuhWXsU0JyWT3jfkpKJPI1Z14xiatxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;976&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;CPU的缓存结构&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;缓存的一致性问题&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一般化来说，我们面临的是这样的一个问题，如下图所示，数据库的数据会有5次更新，产生6个版本，V1~V6，图中每个方框的长度代表这个版本持续的时间。&lt;/p&gt;&lt;p&gt;我们期望，在数据库中的数据变化后，缓存层需要尽快的感知到并作出反应，如下图所示，缓存层方框中的间隔代表这个时间段缓存数据不存在，V2、V3以及V5版本在缓存中不存在并不会破坏我们的最终一致性要求，只要数据库的最终版本和缓存的最终版本是相同的就可以了。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2796296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbpcFMVGBvhuLoH4m6rYIj8yhttcP7lbiaonk7s2MgEjNyQmj9zOCXE1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;缓存是如何写入的&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存写入的代码通常情况下都是和缓存使用的代码放在一起的，包含4个步骤，如下图所示：W1读取缓存，W2判断缓存是否存在，W3组装缓存数据（这通常需要向数据库进行查询），W4写入缓存。&lt;/p&gt;&lt;p&gt;每一个步骤间可能会停顿多久是没有办法控制的，尤其是W3、W4之间的停顿最为要命，它很可能让我们将旧版本的数据写入到缓存中。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;我们可能会想，W4步的写入，带上W2的假设，即使用WriteIfNotExists语义，会不会有所改善？&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3916667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTb20FjhyT48qhUfho2h4bwblJcIsFVibcSh0dgWLCqB0hicJ8EDgk8VUyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;考虑如下的情形，假设有3个缓存写入的并发执行，由于短时间数据库大量的更新，它们分别组装的是V1、V2、V3版本的数据。&lt;/p&gt;&lt;p&gt;使用WriteIfNotExists语义，其中必然有2个执行会失败，哪一个会成功根本无法保证。&lt;/p&gt;&lt;p&gt;我们无法简单的做决策，需要再次将缓存读取出来，然后判断是否我们即将写入的一样，如果一样那就很简单；如果不一样的话，我们有两种选择：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;将缓存删除，让后续别的请求来处理写入。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用缓存提供的原子操作，仅在我们的数据是较新版本时写入。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.27833&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbxFk3v9PuJ3VBXYmdBKGOcvrMXAyRjrqiaXlId1X7Q849lA9Gbon5dpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1006&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;如何感知数据库的变化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;数据库的数据发生变化后，我们如何感知到并进行有效的缓存管理呢？&lt;/p&gt;&lt;p&gt;通常情况下有如下的3种做法：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用代码执行流&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通常我们会在数据库操作完成后，执行一些缓存操作的代码。&lt;/p&gt;&lt;p&gt;这种方式最大的问题是可靠性不高，应用重启、机器意外当机等情况都会导致后续的代码无法执行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用事务消息&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;作为使用代码执行流的改进，在数据库操作完成后发出事务消息，然后在消息的消费逻辑里执行缓存的管理操作。&lt;/p&gt;&lt;p&gt;可靠性的问题就解决了，只是业务侧要为此增加事务消息的逻辑，以及运行成本。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用数据变更日志&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;数据库产品通常都支持在数据变更后产生变更日志，比如MySQL的binlog。&lt;/p&gt;&lt;p&gt;可以让中间件团队写一款产品，在接收到变更后执行缓存的管理操作，比如阿里的精卫。&lt;/p&gt;&lt;p&gt;可靠性有保证，同时还可以进行某个时间段变更日志的回放，功能就比较强大了。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;最佳实践一：数据库变更后失效缓存&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这是最常用和简单的方式，应该被作为首选的方案，整体的执行逻辑如下图所示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5731481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbuFnDYpEbhQKFJQVPGlOAZaJibTSPEQ0ag8mIn1J78yhhBfdYOlLhBibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;W4步使用最基本的put语义，这里的假设是写入较晚的请求往往也是携带的最新的数据，这在大多的情形下都是成立的。&lt;/p&gt;&lt;p&gt;D1步使用监听DB binlog的方式来删除缓存，即前述使用数据变更日志中介绍的方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;这个方案的缺点是&lt;/strong&gt;：在数据库数据存在高并发更新且缓存读取流量较大的情况下，会有小概率存在缓存中存储的是旧版本数据的情况。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通常的解法有四种：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;限制缓存有效时间&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;设定缓存的过期时间，比如15分钟。即表示我们最多接受缓存在15分钟的时间范围内是旧的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;小概率缓存重加载&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;根据流量比设定一定比例的缓存重加载，以保证大流量情况下的缓存数据的一致性。&lt;/p&gt;&lt;p&gt;比如1%的比例，这同时还可以帮助数据库得到充分的预热。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;结合业务特点&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;根据业务的特点做一些设计，比如：&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;针对营销的场景&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;在商品详情页/确认订单页的优惠计算时使用缓存，而在下单时不使用缓存。&lt;/p&gt;&lt;p&gt;这可以让极端情况发生时，不产生过大的业务损失。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;针对库存的场景&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;读取到旧版本的数据只是会在商品已售罄的情况下让多余的流量进入到下单而已，下单时的库存扣减是操作数据库的，所以不会有业务上的损失。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;两次删除&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;D1步删除缓存的操作执行两次，且中间有一定的间隔，比如30秒。&lt;/p&gt;&lt;p&gt;这两次动作的触发都是由“缓存管理组件”发起的，所以可以由它支持。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;最佳实践二：带版本写入&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;针对象商品信息缓存这种更新频率低、数据一致性要求较高且缓存读取流量很高的场景，通常会采用带版本更新的方式，整体的执行逻辑如下图如示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6055556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTblN4aNHDMTub6GiboN4tIj5MlIj1sSpEiamGf0A9Pu2VBmPRF9fjxcayA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;和“数据库变更后失效缓存”方案最大的差异在W4步和D1步，需要缓存层提供带版本写入的API，即仅当写入数据版本较新时可以写入成功，否则写入失败。&lt;/p&gt;&lt;p&gt;这同时也要求我们在数据库增加数据版本的信息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个方案的最终一致性效果比较好，仅在极端情况下（新版本写入后数据丢失了，后续旧版本的写入就会成功）存在缓存中存储的是旧版本数据的可能。&lt;/p&gt;&lt;p&gt;在D1步使用写入而不是使用删除可以极大程度的避免这个极端情况的出现，同时由于该方案适用于缓存读取流量很高的场景，还可以避免缓存被删除后W3步短时间大量请求穿透到DB。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;总结与展望&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于缓存与数据库分离的场景，在结合了业界多家公司的实践经验以及ROI权衡之后，前述的两个最佳实践是被应用的最为广泛的，尤其是最佳实践一，应该作为我们日常应用的首选。&lt;/p&gt;&lt;p&gt;同时，为了最大限度的避免每个最佳实践背后可能发生的不一致性问题，我们还需要切合业务的特点，在关键的场景上做一些保障一致性的设计（比如前述的营销在下单时使用数据库读而不是缓存读），这也显得尤为重要（毕竟如“背景”中所述，并不存在完美的技术方案）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;除了缓存与数据库分离的方案，还有两个业界已经应用的方案也值得我们借鉴：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;阿里XKV&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;简单来讲就是在数据库上部署一个Memcache的Server，它直接绕过数据库层直接访问存储引擎层（如：InnoDB），同时使用KV client来进行数据的访问。&lt;/p&gt;&lt;p&gt;它的特点是数据实际上与数据库是强一致的，性能可以比使用SQL访问数据库提升5～10倍。&lt;/p&gt;&lt;p&gt;缺点也很明显，只能通过主键或者唯一键来访问数据（这只是相对SQL来说的，大多数缓存本来也就是KV访问协议）。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;腾讯DCache&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;不用自行维护缓存与数据库两套存储，给开发人员统一的一套数据视图，由DCache在缓存更新后自行持久化数据。&lt;/p&gt;&lt;p&gt;缺点是支持的数据结构有限（ key-value，k-k-row，list，set，zset ），未来也很难支持形如数据库表一样复杂的数据结构。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f768b9882ec0974b24b5ad1ccd135cbf</guid>
<title>[推荐] 优雅整洁的 Java 代码命名技巧，风之极·净化</title>
<link>https://toutiao.io/k/abc8vou</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;&lt;span&gt;可能是最全的命名规范，建议收藏，文末抽奖福利。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.562962962962963&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/EoJib2tNvVtdsxhk6iazHH8Yfoyz95eLhOqLCsQcKbVL29Wx3PibOSxseYoKnI7zcXibn7tP2Z07yvLJBevtx4s4sw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;合格的程序员不仅仅是让代码跑起来，而是要做到代码整洁，只满足为了能让编译器通过编译，机器能跑就行而写代码的程序会算不上开发者，码农都不算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的命名能体现出代码的特征，含义或者是用途，让阅读者可以根据名称的含义快速厘清程序的脉络。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇分享如下代码命名套路来提高我们代码命名：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;勿模糊，准确达意&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;避免误导&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;做有意义的区分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;结合上下文简化名称&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用可搜索、易读的名称&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;包命名规范&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类名与方法名规范&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;混乱的代价&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我相信每个程序员都被某些人的垃圾代码恶心过，导致开发进度被严重延缓、性能差劲、bug 多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次新增和修改代码如履薄冰，我们只有对那堆腐朽的代码了然于胸才敢修改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着时间推移，团队生产力下降，所有人都抵触这个项目，对其束手无策。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新手不熟悉原来的场景和设计，不知道如何修改才符合实际意图，导致更容易出现混乱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，开发团队产生了抵触心理并造反了，再也无法忍受在这个垃圾代码基础上做开发，而管理层不愿意投入资源重新设计。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一个优秀的开发者应该时刻保持代码整洁，无关 deadline。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;为什么会写出垃圾代码呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的人可能会说，需求变化违背了最初的设计、排期太紧没法干好......&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，这是一种不专业的托词。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推进进度是产品经理他们该干的，虽然痴迷于进度，但是多数产品经理也会期望有良好的可拓展代码以便应对市场变换莫测的需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;连海誓山盟的爱情都会变，又如何做到需求不会改变呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们比他们更加重视代码质量，才能应对变化的需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;保护代码持续整洁优雅是每个优秀开发者都应该遵守的原则。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;混乱的代码只会拖慢未来的开发进度，唯一加快进度的方法：&lt;strong&gt;始终尽可能保持代码优雅整洁&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好比医生在做手术之前要先消毒，你说消毒太耗时间了，直接拿刀子整吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为专业的医生你会照做么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;作为专业的程序员，我们要了解代码变坏的风险并坚持保持代码质量。&lt;/strong&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是整洁代码&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码质量评判需要综合各种因素得到的，我们并不能从单一的维度去评判。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如代码可读性好，但是空间与时间复杂度高，这并不能算得上是好代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的代码应该具备：&lt;strong&gt;易拓展和维护、简洁（只做好一件事）、可复用性强（没有重复代码）、能快速写出单元测试。可读性强、没有副作用（做了名称以外的工作）。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5455974842767296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtdsxhk6iazHH8Yfoyz95eLhOM9Vh4F4vDIOmzZVvpYYtqNlJfnI9yRMzvSR4Hb7EGNj6wEWAqBnicZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;636&quot;/&gt;*&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;易拓展和维护&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在不破坏原来的代码设计下，可以简单快速的修改和添加代码实现功能拓展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单地说就是预留了拓展点，将新代码放在设计的可拓展点，不会因为新增一个功能而改动大量原始代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对修改关闭，对拓展开放，开闭原则。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于开发而言，我们维护旧代码的时间超过新项目新代码的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码的可维护性就变得很重要，也就是说代码分层清晰、模块划分精当，满足高内聚低耦合、抽象出合理的接口，面向接口编程就意味着有较好的可维护性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的代码，熟悉他的资深工程师会觉得很容易维护，而新人因为不熟悉代码，不懂设计模式而无法理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，易拓展具有主观性，我们需要提高基础技能才有资格说代码是否易拓展和维护。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;只做好一件事&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单一职责：每个函数、每个类、每个模块只专注于一件事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要设计大而全的类或者函数，我们需要将他们拆分成更细粒度功能更加单一的类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它不会隐藏设计者的意图，干净利落的抽象和直截了当的控制语句。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们应该让每个函数每行代码简单、逻辑清晰。这样的话，类依赖和被依赖的类也会变少，减少耦合度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，也不能拆分太细，否则就会破坏内聚性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;高手，就是用最简单的方法去解决复杂问题。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;没有重复代码&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开发过程中，我们应该尽可能抽象出「变与不变」，复用已经存在的代码，不要写重复的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如运用「封装、继承、抽象、多态」特性，代码封装成模块，隐藏变化的细节，暴露不变的接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把业务与非业务的代码逻辑分析，抽象成通用的框架、工具类等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如应用模板方法设计模式将不变的算法逻辑框架定义出来，把变化的点延迟到子类重写。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;能快速写成单元测试&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;试想下，如果一个类大而全，有一个方法依赖了十几个外部对象才能完成工作，耦合严重。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你在编写单元测试的时候，需要 mock 十几个依赖对象和数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那说明这个代码糟透了，需要合理拆分和设计。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;可读性强&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;软件设计大师 Martin Fowler 说过：「Any fool can write code that a computer can understand. Good programmers write code that humans can understand.」&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;翻译成中文就是：&quot;任何二货都会编写计算机能跑的代码。优秀的程序员能够编写人能够理解的代码。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而可读性就会涉及到编码规范、命名、注释、函数职责是否单一、长度是否精简。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;有数据显示读代码的时间与写代码的时间比例超过 10：1，并且编写当前代码的难度，取决于读周边代码的难度。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我认为可读性强是最重要的一点。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;高质量命名套路&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发过程后命名随处可见，我们给变量、方法、参数、类、包命名。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而命名的好坏会影响我们的可读性，我们不妨从命名作为切入口来写好代码。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;勿模糊，准确达意&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开发过程中，一旦发现更好的名称，就换掉旧的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个变量、方法、或者类的名称应该展示出它该有的功能。根据名字我们能知道它能做什么事情，如何使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果一个名称需要大量注释来补充避免使用者跳坑，那就是糟糕的名字。&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;变量名体现出该字段作用，比如  &lt;code&gt;LocalDate now = LocaDate.now();&lt;/code&gt;  now 标识当前时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;防止出现让人模糊无法理解，必须还要依据大量上下文才能理解的代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不要使用魔术。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;反例 1 ：使用魔数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 从数据库获取列表&lt;/span&gt;&lt;br/&gt;List&amp;lt;String&amp;gt; buyerList = dao.getList();&lt;br/&gt;buyerList.forEach(x -&amp;gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span&gt;5&lt;/span&gt;; i++) {&lt;br/&gt;  processedBuyerList.add(String.format(&lt;span&gt;&quot;%s,%s&quot;&lt;/span&gt;, i, x));&lt;br/&gt; }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你会疑问，为啥索引是从 1 开始？为啥 &amp;lt;= 5。除此之外， i 与 1 极其相似，难以区分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正确的方式应该使用实际含义的名字让人理解这么写的目的，否则维护的人将痛苦不堪。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;反例 2：使用生僻字，又臭又长&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;UltimateAssociatedSubjectRunBatchServiceImpl&lt;/code&gt;，当我们看到这样的类名，是不是不知道怎么读，也不知道如何搜索和定位，更不知道到底表达的意思是什么，可能命这个名字的人还以为准确表达，其实是“王大妈的裹脚布，又臭又长”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原本的业务含义是：执行关联主体任务相关业务类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;鉴于此，我们第一步要避免使用生僻字，可以命名为&lt;code&gt;LinkSubjectServiceImpl&lt;/code&gt; ，清晰简单的表达出关联主体的业务逻辑都在该类。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;不要误导&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽量&lt;strong&gt;不要使用不同之处较小&lt;/strong&gt;的名称，这样让他人无法一眼区分两个名称是啥意思。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：函数 &lt;code&gt;deleteIndex&lt;/code&gt; 和函数&lt;code&gt;deleteIndexEx&lt;/code&gt;，这两个函数名区别很小了，加之函数 &lt;code&gt;deleteIndexEx&lt;/code&gt;后面&lt;code&gt;Ex&lt;/code&gt;还是缩写，也不知道是什么意思，所以他人只能去看函数内容才能明白两者的区别。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;XYZStringHandler&lt;/code&gt;与 &lt;code&gt;XYZStringStorage&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;UserController&lt;/code&gt;与 &lt;code&gt;UserInfoController&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让人抓狂，他们到底是一个东西还是不同的？差别在哪？没有两年脑血栓写不出这样的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;反例 3：名不副实&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是一个生成文件并提供下载功能的接口。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;downloadExcel&lt;/span&gt;&lt;span&gt;(HttpServletResponse response)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; List&amp;lt;File&amp;gt; files = listFile();&lt;br/&gt; String fileName = System.currentTimeMillis() + &lt;span&gt;&quot;.zip&quot;&lt;/span&gt;;&lt;br/&gt; DownloadZip.downLoadFiles(files, filePath);&lt;br/&gt; DownloadZip.fileDownload(response, filePath, fileName);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们会疑惑，&lt;code&gt;downLoadFiles&lt;/code&gt; 与 &lt;code&gt;fileDownload&lt;/code&gt; 到底有啥区别？为啥要调用两次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种真的是十年脑血栓才写得出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;downLoadFiles&lt;/code&gt; 的功能是创建将 files 打包成 zip 文件，而  &lt;code&gt;fileDownload&lt;/code&gt;则是把指定的文件输出给浏览器下载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 &lt;code&gt;downLoadFiles&lt;/code&gt; 应该命名为 &lt;code&gt;createZipFile&lt;/code&gt;用于合理区分避免误人子弟。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;做有意义的区分&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;getActiveOrder();&lt;br/&gt;getActiveOrderInfo();&lt;br/&gt;getActiveOrderData();&lt;br/&gt;getActiveOrders();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面都是废话命名，别人你怎么知道到底该调用那个方法？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哪个表示订单明细？还是历史订单，还是全部订单查询，废话是另一种没有意义的区分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;名称不同，意思却无差别。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Order、OrderInfo、OrderData&lt;/code&gt;，他们名称相同 ，意思却无差别，属于&lt;strong&gt;毫无意义的废话&lt;/strong&gt;。如果缺少明确约定，变量&lt;code&gt;moneyAmount&lt;/code&gt;就与&lt;code&gt;money&lt;/code&gt;没区别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Variable&lt;/code&gt;一词永远不应当出现在变量名中。&lt;code&gt;Table&lt;/code&gt;一词永远不应当出现在表名中。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结合上下文简化名称&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Order&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; String orderNum;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; String orderCreateTime;&lt;br/&gt;  &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 &lt;code&gt;Order&lt;/code&gt;类，在该上下文中，没必要给每个成员变量重复添加 order 这个前缀单词，直接命名为 &lt;code&gt;createTime&lt;/code&gt;、&lt;code&gt;num&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为我们可以借助 &lt;code&gt;Order&lt;/code&gt; 这个上下文来获取信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Order order = &lt;span&gt;new&lt;/span&gt; Order();&lt;br/&gt;order.getCreateTime();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;名称易读、可搜索&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可读指的是不要使用一些生僻字，难以发音的单词。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可搜索是便于利用 IED 的自动补全和搜索功能，能根据我们的命名规范快速定位想要找的类或者方法等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;可读&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;名称读不出来，在讨论的时候就好像是一个沙雕。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哎，那个「treeNewBeeAxibaKula」类是什么作用？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;听到这样的名字尴尬癌都犯了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用一些生僻字，犹如「王大妈的裹脚布，又长又臭」，没有两年脑血栓写不出这样的垃圾代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;可搜索&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IED 很智能，当我们输入 「Hash」的时候，会列举出所有 Hash 相关的类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命名的时候最好符合项目命名习惯，列表数据查询大家使用 listXXX，你就不要用 queryXXX，统一命名规范，很重要。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;包命名&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;包名&lt;/strong&gt;统一使用&lt;strong&gt;小写&lt;/strong&gt;，&lt;strong&gt;点分隔符&lt;/strong&gt;之间有且仅有一个自然语义的英文单词或者多个单词自然连接到一块（如 springframework，deepspace 不需要使用任何分割）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;包名的构成可以分为以下几四部分【前缀】 【发起者名】【项目名】【模块名】。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;以下表格授权于「Java 填坑笔记」&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的前缀可以分为以下几种：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;前缀名&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;th&gt;含义&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;indi（或onem ）&lt;/td&gt;&lt;td&gt;indi.发起者名.项目名.模块名.……&lt;/td&gt;&lt;td&gt;个体项目，指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;pers&lt;/td&gt;&lt;td&gt;pers.个人名.项目名.模块名.……&lt;/td&gt;&lt;td&gt;个人项目，指个人发起，独自完成，可分享的项目，copyright主要属于个人&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;priv&lt;/td&gt;&lt;td&gt;priv.个人名.项目名.模块名.……&lt;/td&gt;&lt;td&gt;私有项目，指个人发起，独自完成，非公开的私人使用的项目，copyright属于个人。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;team&lt;/td&gt;&lt;td&gt;team.团队名.项目名.模块名.……&lt;/td&gt;&lt;td&gt;团队项目，指由团队发起，并由该团队开发的项目，copyright属于该团队所有&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;顶级域名&lt;/td&gt;&lt;td&gt;com.公司名.项目名.模块名.……&lt;/td&gt;&lt;td&gt;公司项目，copyright由项目发起的公司所有&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;类名&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;类名使用大驼峰命名形式&lt;/strong&gt;，应该使用&lt;strong&gt;名词或者名词短语&lt;/strong&gt;，比如：Customer、Account。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;避免使用 Manager、Processor 等动词。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口名除了用名词和名词短语以外，还可以使用形容词或形容词短语，如 Cloneable，Callable 等，表示实现该接口的类有某种功能或能力。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;&lt;th&gt;约束&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;抽象类&lt;/td&gt;&lt;td&gt;Abstract 或者 Base 开头&lt;/td&gt;&lt;td&gt;BaseUserService&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;枚举类&lt;/td&gt;&lt;td&gt;Enum 作为后缀&lt;/td&gt;&lt;td&gt;GenderEnum&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;工具类&lt;/td&gt;&lt;td&gt;Utils作为后缀&lt;/td&gt;&lt;td&gt;StringUtils&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;异常类&lt;/td&gt;&lt;td&gt;Exception结尾&lt;/td&gt;&lt;td&gt;RuntimeException&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;接口实现类&lt;/td&gt;&lt;td&gt;接口名+ ImpI 或者 前缀接口名 + 接口名&lt;/td&gt;&lt;td&gt;UserService + UserServiceImpl、IUserService + UserService&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;领域模型相关&lt;/td&gt;&lt;td&gt;/DO/DTO/VO/DAO&lt;/td&gt;&lt;td&gt;正例：UserDAO 反例：UserDo， UserDao&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;设计模式相关类&lt;/td&gt;&lt;td&gt;Builder，Factory等&lt;/td&gt;&lt;td&gt;当使用到设计模式时，需要使用对应的设计模式作为后缀，如ThreadFactory&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;处理特定功能的&lt;/td&gt;&lt;td&gt;Handler，Predicate, Validator&lt;/td&gt;&lt;td&gt;表示处理器，校验器，断言，这些类工厂还有配套的方法名如handle，predicate，validate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;测试类&lt;/td&gt;&lt;td&gt;Test结尾&lt;/td&gt;&lt;td&gt;UserServiceTest， 表示用来测试UserService类的&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;方法名&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法命名一般为&lt;strong&gt;动词或动词短语&lt;/strong&gt;，与参数或参数名共同组成动宾短语，即动词 + 名词。一个好的函数名一般能通过名字直接获知该函数实现什么样的功能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;布尔返回值的方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：Prefix-前缀，Suffix-后缀，Alone-单独使用&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;位置&lt;/th&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;is&lt;/td&gt;&lt;td&gt;对象是否符合期待的状态&lt;/td&gt;&lt;td&gt;isValid&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;can&lt;/td&gt;&lt;td&gt;对象&lt;strong&gt;能否执行&lt;/strong&gt;所期待的动作&lt;/td&gt;&lt;td&gt;canRemove&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;should&lt;/td&gt;&lt;td&gt;调用方执行某个命令或方法是&lt;strong&gt;好还是不好&lt;/strong&gt;,&lt;strong&gt;应不应该&lt;/strong&gt;，或者说&lt;strong&gt;推荐还是不推荐&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;shouldMigrate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;has&lt;/td&gt;&lt;td&gt;对象&lt;strong&gt;是否持有&lt;/strong&gt;所期待的数据和属性&lt;/td&gt;&lt;td&gt;hasObservers&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;needs&lt;/td&gt;&lt;td&gt;调用方&lt;strong&gt;是否需要&lt;/strong&gt;执行某个命令或方法&lt;/td&gt;&lt;td&gt;needsMigrate&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;按需执行的方法&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;位置&lt;/th&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Suffix&lt;/td&gt;&lt;td&gt;IfNeeded&lt;/td&gt;&lt;td&gt;需要的时候执行，不需要的时候什么都不做&lt;/td&gt;&lt;td&gt;drawIfNeeded&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;might&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;mightCreate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;try&lt;/td&gt;&lt;td&gt;尝试执行，失败时抛出异常或是返回errorcode&lt;/td&gt;&lt;td&gt;tryCreate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Suffix&lt;/td&gt;&lt;td&gt;OrDefault&lt;/td&gt;&lt;td&gt;尝试执行，失败时返回默认值&lt;/td&gt;&lt;td&gt;getOrDefault&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Suffix&lt;/td&gt;&lt;td&gt;OrElse&lt;/td&gt;&lt;td&gt;尝试执行、失败时返回实际参数中指定的值&lt;/td&gt;&lt;td&gt;getOrElse&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;force&lt;/td&gt;&lt;td&gt;强制尝试执行。error抛出异常或是返回值&lt;/td&gt;&lt;td&gt;forceCreate, forceStop&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;用来检查的方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;ensure&lt;/td&gt;&lt;td&gt;检查是否为期待的状态，不是则抛出异常或返回error code&lt;/td&gt;&lt;td&gt;ensureCapacity&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;validate&lt;/td&gt;&lt;td&gt;检查是否为正确的状态，不是则抛出异常或返回error code&lt;/td&gt;&lt;td&gt;validateInputs&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;异步相关方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;位置&lt;/th&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;blocking&lt;/td&gt;&lt;td&gt;线程阻塞方法&lt;/td&gt;&lt;td&gt;blockingGetUser&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Suffix&lt;/td&gt;&lt;td&gt;InBackground&lt;/td&gt;&lt;td&gt;执行在后台的线程&lt;/td&gt;&lt;td&gt;doInBackground&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Suffix&lt;/td&gt;&lt;td&gt;Async&lt;/td&gt;&lt;td&gt;异步方法&lt;/td&gt;&lt;td&gt;sendAsync&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Suffix&lt;/td&gt;&lt;td&gt;Sync&lt;/td&gt;&lt;td&gt;对应已有异步方法的同步方法&lt;/td&gt;&lt;td&gt;sendSync&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;&lt;td&gt;schedule&lt;/td&gt;&lt;td&gt;Job和Task放入队列&lt;/td&gt;&lt;td&gt;schedule, scheduleJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;&lt;td&gt;post&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;postJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;&lt;td&gt;execute&lt;/td&gt;&lt;td&gt;执行异步方法（注：我一般拿这个做同步方法名）&lt;/td&gt;&lt;td&gt;execute, executeTask&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;&lt;td&gt;start&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;start, startJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;&lt;td&gt;cancel&lt;/td&gt;&lt;td&gt;停止异步方法&lt;/td&gt;&lt;td&gt;cancel, cancelJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;&lt;td&gt;stop&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;stop, stopJob&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;回调方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;位置&lt;/th&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;on&lt;/td&gt;&lt;td&gt;事件发生时执行&lt;/td&gt;&lt;td&gt;onCompleted&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;before&lt;/td&gt;&lt;td&gt;事件发生前执行&lt;/td&gt;&lt;td&gt;beforeUpdate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;pre&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;preUpdate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;will&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;willUpdate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;after&lt;/td&gt;&lt;td&gt;事件发生后执行&lt;/td&gt;&lt;td&gt;afterUpdate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;post&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;postUpdate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;did&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;didUpdate&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prefix&lt;/td&gt;&lt;td&gt;should&lt;/td&gt;&lt;td&gt;确认事件是否可以发生时执行&lt;/td&gt;&lt;td&gt;shouldUpdate&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;操作对象生命周期的方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;initialize&lt;/td&gt;&lt;td&gt;初始化。也可作为延迟初始化使用&lt;/td&gt;&lt;td&gt;initialize&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;pause&lt;/td&gt;&lt;td&gt;暂停&lt;/td&gt;&lt;td&gt;onPause ，pause&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;stop&lt;/td&gt;&lt;td&gt;停止&lt;/td&gt;&lt;td&gt;onStop，stop&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;abandon&lt;/td&gt;&lt;td&gt;销毁的替代&lt;/td&gt;&lt;td&gt;abandon&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;destroy&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;destroy&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;dispose&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;td&gt;dispose&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.7 与集合操作相关的方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;contains&lt;/td&gt;&lt;td&gt;是否持有与指定对象相同的对象&lt;/td&gt;&lt;td&gt;contains&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;add&lt;/td&gt;&lt;td&gt;添加&lt;/td&gt;&lt;td&gt;addJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;append&lt;/td&gt;&lt;td&gt;添加&lt;/td&gt;&lt;td&gt;appendJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;insert&lt;/td&gt;&lt;td&gt;插入到下标n&lt;/td&gt;&lt;td&gt;insertJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;put&lt;/td&gt;&lt;td&gt;添加与key对应的元素&lt;/td&gt;&lt;td&gt;putJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;remove&lt;/td&gt;&lt;td&gt;移除元素&lt;/td&gt;&lt;td&gt;removeJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;enqueue&lt;/td&gt;&lt;td&gt;添加到队列的最末位&lt;/td&gt;&lt;td&gt;enqueueJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;dequeue&lt;/td&gt;&lt;td&gt;从队列中头部取出并移除&lt;/td&gt;&lt;td&gt;dequeueJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;push&lt;/td&gt;&lt;td&gt;添加到栈头&lt;/td&gt;&lt;td&gt;pushJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;pop&lt;/td&gt;&lt;td&gt;从栈头取出并移除&lt;/td&gt;&lt;td&gt;popJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;peek&lt;/td&gt;&lt;td&gt;从栈头取出但不移除&lt;/td&gt;&lt;td&gt;peekJob&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;find&lt;/td&gt;&lt;td&gt;寻找符合条件的某物&lt;/td&gt;&lt;td&gt;findById&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;与数据相关的方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;th&gt;例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;create&lt;/td&gt;&lt;td&gt;新创建&lt;/td&gt;&lt;td&gt;createAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;new&lt;/td&gt;&lt;td&gt;新创建&lt;/td&gt;&lt;td&gt;newAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;from&lt;/td&gt;&lt;td&gt;从既有的某物新建，或是从其他的数据新建&lt;/td&gt;&lt;td&gt;fromConfig&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;to&lt;/td&gt;&lt;td&gt;转换&lt;/td&gt;&lt;td&gt;toString&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;update&lt;/td&gt;&lt;td&gt;更新既有某物&lt;/td&gt;&lt;td&gt;updateAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;load&lt;/td&gt;&lt;td&gt;读取&lt;/td&gt;&lt;td&gt;loadAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;fetch&lt;/td&gt;&lt;td&gt;远程读取&lt;/td&gt;&lt;td&gt;fetchAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;delete&lt;/td&gt;&lt;td&gt;删除&lt;/td&gt;&lt;td&gt;deleteAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;remove&lt;/td&gt;&lt;td&gt;删除&lt;/td&gt;&lt;td&gt;removeAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;save&lt;/td&gt;&lt;td&gt;保存&lt;/td&gt;&lt;td&gt;saveAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;store&lt;/td&gt;&lt;td&gt;保存&lt;/td&gt;&lt;td&gt;storeAccount&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;commit&lt;/td&gt;&lt;td&gt;保存&lt;/td&gt;&lt;td&gt;commitChange&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;apply&lt;/td&gt;&lt;td&gt;保存或应用&lt;/td&gt;&lt;td&gt;applyChange&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;clear&lt;/td&gt;&lt;td&gt;清除数据或是恢复到初始状态&lt;/td&gt;&lt;td&gt;clearAll&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;reset&lt;/td&gt;&lt;td&gt;清除数据或是恢复到初始状态&lt;/td&gt;&lt;td&gt;resetAll&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;成对出现的动词&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;单词&lt;/th&gt;&lt;th&gt;意义&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;get获取&lt;/td&gt;&lt;td&gt;set 设置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;add 增加&lt;/td&gt;&lt;td&gt;remove 删除&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;create 创建&lt;/td&gt;&lt;td&gt;destory 移除&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;start 启动&lt;/td&gt;&lt;td&gt;stop 停止&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;open 打开&lt;/td&gt;&lt;td&gt;close 关闭&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;read 读取&lt;/td&gt;&lt;td&gt;write 写入&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;load 载入&lt;/td&gt;&lt;td&gt;save 保存&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;create 创建&lt;/td&gt;&lt;td&gt;destroy 销毁&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;begin 开始&lt;/td&gt;&lt;td&gt;end 结束&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;backup 备份&lt;/td&gt;&lt;td&gt;restore 恢复&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;import 导入&lt;/td&gt;&lt;td&gt;export 导出&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;split 分割&lt;/td&gt;&lt;td&gt;merge 合并&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;inject 注入&lt;/td&gt;&lt;td&gt;extract 提取&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;attach 附着&lt;/td&gt;&lt;td&gt;detach 脱离&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;bind 绑定&lt;/td&gt;&lt;td&gt;separate 分离&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;view 查看&lt;/td&gt;&lt;td&gt;browse 浏览&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;edit 编辑&lt;/td&gt;&lt;td&gt;modify 修改&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;select 选取&lt;/td&gt;&lt;td&gt;mark 标记&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;copy 复制&lt;/td&gt;&lt;td&gt;paste 粘贴&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;undo 撤销&lt;/td&gt;&lt;td&gt;redo 重做&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;insert 插入&lt;/td&gt;&lt;td&gt;delete 移除&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;add 加入&lt;/td&gt;&lt;td&gt;append 添加&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;clean 清理&lt;/td&gt;&lt;td&gt;clear 清除&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;index 索引&lt;/td&gt;&lt;td&gt;sort 排序&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;find 查找&lt;/td&gt;&lt;td&gt;search 搜索&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;increase 增加&lt;/td&gt;&lt;td&gt;decrease 减少&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;play 播放&lt;/td&gt;&lt;td&gt;pause 暂停&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;launch 启动&lt;/td&gt;&lt;td&gt;run 运行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;compile 编译&lt;/td&gt;&lt;td&gt;execute 执行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;debug 调试&lt;/td&gt;&lt;td&gt;trace 跟踪&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;observe 观察&lt;/td&gt;&lt;td&gt;listen 监听&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;build 构建&lt;/td&gt;&lt;td&gt;publish 发布&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;input 输入&lt;/td&gt;&lt;td&gt;output 输出&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;encode 编码&lt;/td&gt;&lt;td&gt;decode 解码&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;encrypt 加密&lt;/td&gt;&lt;td&gt;decrypt 解密&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;compress 压缩&lt;/td&gt;&lt;td&gt;decompress 解压缩&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;pack 打包&lt;/td&gt;&lt;td&gt;unpack 解包&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;parse 解析&lt;/td&gt;&lt;td&gt;emit 生成&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;connect 连接&lt;/td&gt;&lt;td&gt;disconnect 断开&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;send 发送&lt;/td&gt;&lt;td&gt;receive 接收&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;download 下载&lt;/td&gt;&lt;td&gt;upload 上传&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;refresh 刷新&lt;/td&gt;&lt;td&gt;synchronize 同步&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;update 更新&lt;/td&gt;&lt;td&gt;revert 复原&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;lock 锁定&lt;/td&gt;&lt;td&gt;unlock 解锁&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;check out 签出&lt;/td&gt;&lt;td&gt;check in 签入&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;submit 提交&lt;/td&gt;&lt;td&gt;commit 交付&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;push 推&lt;/td&gt;&lt;td&gt;pull 拉&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;expand 展开&lt;/td&gt;&lt;td&gt;collapse 折叠&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;begin 起始&lt;/td&gt;&lt;td&gt;end 结束&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;start 开始&lt;/td&gt;&lt;td&gt;finish 完成&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;enter 进入&lt;/td&gt;&lt;td&gt;exit 退出&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;abort 放弃&lt;/td&gt;&lt;td&gt;quit 离开&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;obsolete 废弃&lt;/td&gt;&lt;td&gt;depreciate 废旧&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;collect 收集&lt;/td&gt;&lt;td&gt;aggregate 聚集&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命名目的都是为了让代码和工程师进行对话，增强代码的可读性，可维护性。优秀的代码往往能够见名知意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家在工作中是否有遇到一些垃圾命名的代码呢？&lt;strong&gt;&lt;span&gt;欢迎留言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651508541&amp;amp;idx=1&amp;amp;sn=551a5034a7f374d8ed3da25327bccca4&amp;amp;chksm=bd25a3428a522a5458b3148a80ec26ac3b454a563034bb88694839bed796d2d3212f105b82d1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;还在用策略模式解决 if-else？Map+函数式接口方法才是YYDS！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;还在用策略模式解决 if-else？Map+函数式接口方法才是YYDS！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651503297&amp;amp;idx=2&amp;amp;sn=5f19e03d6b86789b3b28af5cee97d1e9&amp;amp;chksm=bd25d6be8a525fa8b8d16745d3454ddc4aa562571964d88eb9fd4e2cb274f8a9ae806bf0b3d5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;一个 HashMap 跟面试官扯了半个小时&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;一个 HashMap 跟面试官扯了半个小时&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651508534&amp;amp;idx=1&amp;amp;sn=dbe47cc505ca306c80db884fae973b46&amp;amp;chksm=bd25a3498a522a5fb4c338276bfd8af8699618e0e93c76aea2a11090cd7968e4ff07074a9c93&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;阿里二面：main 方法可以继承吗？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;阿里二面：main 方法可以继承吗？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>82064c038f5f36a21b78b551db4ba32c</guid>
<title>[推荐] 面试官问：设计高并发系统的时候，数据库层面该如何设计？</title>
<link>https://toutiao.io/k/p935kqr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h2&gt;题目描述&lt;/h2&gt;

&lt;p&gt;为什么要分库分表（设计高并发系统的时候，数据库层面该如何设计）？&lt;/p&gt;

&lt;p&gt;用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点 ？&lt;/p&gt;

&lt;p&gt;你们具体是如何对数据库如何进行垂直拆分或水平拆分的 ？&lt;/p&gt;

&lt;h2&gt;1.面试题分析&lt;/h2&gt;

&lt;p&gt;其实这块肯定是扯到高并发了，因为分库分表一定是为了支撑高并发、数据量大两个问题的。尤其是互联网类的公司面试，基本上都会来这么一下，分库分表如此普遍的技术问题，不问实在是不行，而如果你不知道那也实在是说不过去！&lt;/p&gt;

&lt;h2&gt;2.面试题剖析&lt;/h2&gt;

&lt;p&gt;为什么要分库分表？（设计高并发系统的时候，数据库层面该如何设计？）
说白了，分库分表是两回事儿，大家可别搞混了，可能是光分库不分表，也可能是光分表不分库，都有可能。我先给大家抛出来一个场景假如我们现在是一个小创业公司（或者是一个 BAT 公司刚兴起的一个新部门），现在注册用户就 20万，每天活跃用户就 1 万，每天单表数据量就 1000 ，然后高峰期每秒钟并发请求最多就 10 个。我的天，就这种系统，随便找一个有几年工作经验的，然后带几个刚培训出来的，随便干干都可以。结果没想到我们运气居然这么好，碰上个 CEO 带着我们走上了康庄大道，业务发展迅猛，过了几个月，注册用户数达到了 2000 万！每天活跃用户数 100 万！每天单表数据量 10 万条！高峰期每秒最大请求达到 1000 ！同时公司还顺带着融资了两轮，进账了几个亿人民币啊！公司估值达到了惊人的几亿美金！这是小独角兽的节奏！
好吧，没事，现在大家感觉压力已经有点大了，为啥呢？因为每天多 10 万条数据，一个月就多 300 万条数据，现在咱们单表已经几百万数据了，马上就破千万了。但是勉强还能撑着。高峰期请求现在是1000 ，咱们线上部署了几台机器，负载均衡搞了一下，数据库撑 1000QPS 也还凑合。但是大家现在开始感觉有点担心了，接下来咋整呢......
   再接下来几个月，我的天，CEO 太牛逼了，公司用户数已经达到 1 亿，公司继续融资几十亿人民币 啊！公司估值达到了惊人的几十亿美金，成为了国内今年最牛逼的明星创业公司！ 但是我们同时也是不幸的，因为此时每天活跃用户数上千万，每天单表新增数据多达 50 万，目前一个表总数据量都已经达到了两三千万了！扛不住啊！数据库磁盘容量不断消耗掉！高峰期并发达到惊人的5000~8000 ！你的系统肯定支撑不到现在，已经挂掉了！好吧，所以你看到这里差不多就理解分库分表是怎么回事儿了，实际上这是跟着你的公司业务发展走 的，你公司业务发展越好，用户就越多，数据量越大，请求量越大，那你单个数据库一定扛不住。&lt;/p&gt;

&lt;h3&gt;分表&lt;/h3&gt;

&lt;p&gt;比如你单表都几千万数据了，你确定你能扛住么？绝对不行，单表数据量太大，会极大影响你的 sql 执
行的性能，到了后面你的 sql 可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时
候，性能就会相对差一些了，你就得分表了。&lt;/p&gt;

&lt;p&gt;分表是啥意思？就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id
来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样
可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。&lt;/p&gt;

&lt;h3&gt;分库&lt;/h3&gt;

&lt;p&gt;分库是啥意思？就是你一个库一般我们经验而言，最多支撑到并发 2000 ，一定要扩容了，而且一个健 康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。这就是所谓的分库分表，为啥要分库分表？你明白了吧。 分库分表前 分库分表后并发支撑情况 MySQL 单机部署，扛不住高并发 MySQL从单机到多机，能承受的并发增加了多倍 磁盘使用情况 MySQL 单机磁盘容量几乎撑满 拆分为多个库，数据库服务器磁盘使用率大大降低 SQL 执行性能 单表数据量太大，SQL 越跑越慢 单表数据量减少，SQL 执行效率明显提升&lt;/p&gt;

&lt;h3&gt;用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？&lt;/h3&gt;

&lt;p&gt;这个其实就是看看你了解哪些分库分表的中间件，各个中间件的优缺点是啥？然后你用过哪些分库分表的中间件。&lt;/p&gt;

&lt;h3&gt;比较常见的包括：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Cobar
TDDL
Atlas
Sharding-jdbc
Mycat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cobar 阿里 b2b 团队开发和开源的，属于 proxy 层方案，就是介于应用服务器和数据库服务器之间。
应用程序通过 JDBC 驱动访问 Cobar 集群，Cobar 根据 SQL 和分库规则对 SQL 做分解，然后分发到
MySQL 集群不同的数据库实例上执行。早些年还可以用，但是最近几年都没更新了，基本没啥人用，
差不多算是被抛弃的状态吧。而且不支持读写分离、存储过程、跨库 join 和分页等操作。&lt;/p&gt;

&lt;p&gt;TDDL 淘宝团队开发的，属于 client 层方案。支持基本的 crud 语法和读写分离，但不支持 join、多表
查询等语法。目前使用的也不多，因为还依赖淘宝的 diamond 配置管理系统。&lt;/p&gt;

&lt;p&gt;Atlas 360 开源的，属于 proxy 层方案，以前是有一些公司在用的，但是确实有一个很大的问题就是社
区最新的维护都在 5 年前了。所以，现在用的公司基本也很少了。&lt;/p&gt;

&lt;p&gt;Sharding-jdbc 当当开源的，属于 client 层方案，是 ShardingSphere 的 client 层方案，
ShardingSphere 还提供 proxy 层的方案 Sharding-Proxy。确实之前用的还比较多一些，因为 SQL 语
法支持也比较多，没有太多限制，而且截至 2019.4，已经推出到了 4.0.0-RC1 版本，支持分库分表、读
写分离、分布式 id 生成、柔性事务（最大努力送达型事务、TCC 事务）。而且确实之前使用的公司会
比较多一些（这个在官网有登记使用的公司，可以看到从 2017 年一直到现在，是有不少公司在用
的），目前社区也还一直在开发和维护，还算是比较活跃，个人认为算是一个现在也可以选择的方案。&lt;/p&gt;

&lt;p&gt;Mycat 基于 Cobar 改造的，属于 proxy 层方案，支持的功能非常完善，而且目前应该是非常火的而且
不断流行的数据库中间件，社区很活跃，也有一些公司开始在用了。但是确实相比于 Sharding jdbc 来
说，年轻一些，经历的锤炼少一些。&lt;/p&gt;

&lt;h2&gt;3.总结&lt;/h2&gt;

&lt;p&gt;综上，现在其实建议考量的，就是 Sharding-jdbc 和 Mycat，这两个都可以去考虑使用。&lt;/p&gt;

&lt;p&gt;Sharding-jdbc 这种 client 层方案的优点在于不用部署，运维成本低，不需要代理层的二次转发请求，
性能很高，但是如果遇到升级啥的需要各个系统都重新升级版本再发布，各个系统都需要耦合
Sharding-jdbc 的依赖；&lt;/p&gt;

&lt;p&gt;Mycat 这种 proxy 层方案的缺点在于需要部署，自己运维一套中间件，运维成本高，但是好处在于对于
各个项目是透明的，如果遇到升级之类的都是自己中间件那里搞就行了。&lt;/p&gt;

&lt;p&gt;通常来说，这两个方案其实都可以选用，但是我个人建议中小型公司选用 Sharding-jdbc，client 层方
案轻便，而且维护成本低，不需要额外增派人手，而且中小型公司系统复杂度会低一些，项目也没那么
多；但是中大型公司最好还是选用 Mycat 这类 proxy 层方案，因为可能大公司系统和项目非常多，团
队很大，人员充足，那么最好是专门弄个人来研究和维护 Mycat，然后大量项目直接透明使用即可。&lt;/p&gt;

&lt;p&gt;你们具体是如何对数据库如何进行垂直拆分或水平拆分的？ 水平拆分的意思，就是把一个表的数据给
弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表
的数据加起来就是全部数据。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来扛更高
的并发，还有就是用多个库的存储容量来进行扩容。&lt;/p&gt;

&lt;p&gt;database-split-horizon&lt;/p&gt;

&lt;p&gt;垂直拆分的意思，就是把一个有很多字段的表给拆分成多个表，或者是多个库上去。每个库表的结构都
不一样，每个库表都包含部分字段。一般来说，会将较少的访问频率很高的字段放到一个表里去，然后
将较多的访问频率很低的字段放到另外一个表里去。因为数据库是有缓存的，你访问频率高的行字段越
少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。&lt;/p&gt;

&lt;p&gt;database-split-vertically&lt;/p&gt;

&lt;p&gt;这个其实挺常见的，不一定我说，大家很多同学可能自己都做过，把一个大表拆开，订单表、订单支付
表、订单商品表。&lt;/p&gt;

&lt;p&gt;还有表层面的拆分，就是分表，将一个表变成 N 个表，就是让每个表的数据量控制在一定范围内，保证
SQL 的性能。否则单表数据量越大，SQL 性能就越差。一般是 200 万行左右，不要太多，但是也得看
具体你怎么操作，也可能是 500 万，或者是 100 万。你的SQL越复杂，就最好让单表行数越少。&lt;/p&gt;

&lt;p&gt;好了，无论分库还是分表，上面说的那些数据库中间件都是可以支持的。就是基本上那些中间件可以做
到你分库分表之后，中间件可以根据你指定的某个字段值，比如说 userid，自动路由到对应的库上去，
然后再自动路由到对应的表里去。你就得考虑一下，你的项目里该如何分库分表？一般来说，垂直拆分，你可以在表层面来做，对一些字段特别多的表做一下拆分；水平拆分，你可以说是并发承载不了，或者是数据量太大，容量承载不了， 你给拆了，按什么字段来拆，你自己想好；分表，你考虑一下，你如果哪怕是拆到每个库里去，并发和容量都 ok 了，但是每个库的表还是太大了，那么你就分表，将这个表分开，保证每个表的数据量并不是很大。&lt;/p&gt;

&lt;p&gt;而且这儿还有两种分库分表的方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一种是按照 range 来分，就是每个库一段连续的数据，这个一般是按比如时间范围来的，但是这
种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了。&lt;/li&gt;
&lt;li&gt;或者是按照某个字段 hash 一下均匀分散，这个较为常用。 range 来分，好处在于说，扩容的时
候很简单，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然
而然，就会写新的库了；缺点，但是大部分的请求，都是访问最新的数据。实际生产用 range，要
看场景。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，
会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表。&lt;/p&gt;

&lt;h2&gt;温馨提示&lt;/h2&gt;

&lt;p&gt;欢迎大家关注”浅谈架构“ 公众号 获取全套最新大厂面试题及答案(后台私信”面试题“即可)。
截图如下
&lt;img src=&quot;https://img.toutiao.io/attachment/ca268c220adb4437b53985743482f8ae/w600&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>