<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>96fbff9e3abe5a32475666804647cca1</guid>
<title>InnoDB 解决幻读的方案：LBCC &amp; MVCC</title>
<link>https://toutiao.io/k/omkb9gy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;181&quot; data-backw=&quot;558&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.32344763670064874&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpOjRJj3rEmVIcZ4cxnPGXMbOToA3HQiafTrfmjfvOVQH0fLtCJwj3DkfC1GoPIRVmLY5oTemAhXibRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1079&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近要在公司内做一次技术分享，思来想去不知道该分享些什么，最后在朋友的提示下，准备分享一下&lt;code&gt;MySQL&lt;/code&gt;的&lt;code&gt;InnoDB&lt;/code&gt;引擎下的事务幻读问题与解决方案--&lt;code&gt;LBCC&lt;/code&gt;&amp;amp;&lt;code&gt;MVCC&lt;/code&gt;。经过好几天的熬夜通宵，终于把这部分的内容捋清楚了。至于为什么说是&lt;code&gt;InnoDB&lt;/code&gt;呢？因为&lt;code&gt;MyISAM&lt;/code&gt;引擎是不支持事务的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;事务&lt;/span&gt;&lt;/h2&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;概念&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个事情由n个单元组成，这n个单元在执行过程中，要么同时成功，要么同时失败，这就把n个单元放在了一个事务之中。举个简单的例子：在不考虑试题正确与否的前提下，一张试卷由多个题目构成，当你答完题交给老师的时候是将一整张试卷交给老师，而不是将每道题单独交给老师，在这里试卷就可以理解成一个事务。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;事务的特性：ACID&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;A：原子性（&lt;code&gt;Atomicity&lt;/code&gt;），原子性是指事务是一个不可分割的工作单位，事务中的操作，要么都发生，要么都不发生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;例&lt;/strong&gt;：假设你在购物车里添加了两件衣服：上衣和裤子，当你把两件衣服作为一个订单提交支付的时候，要么两件衣服一起支付成功，要么都失败，不可能存在上衣付完钱了，裤子还没付完的情况，反之亦然。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C：一致性（&lt;code&gt;Consistency&lt;/code&gt;），在一个事务中，事务前后数据的完整性必须保持一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;例&lt;/strong&gt;：假设用户A和用户B两者的钱加起来一共是200，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是200，这就是事务的一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;I：隔离性（&lt;code&gt;Isolation&lt;/code&gt;），存在于多个事务中，事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;例&lt;/strong&gt;：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;D：持久性（&lt;code&gt;Durability&lt;/code&gt;），持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;例&lt;/strong&gt;：我们在操作数据库时，事务提交或者回滚都会直接改变数据库中的值。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;事务的操作&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用事务之前，首先我们要开启事务，我们可以通过&lt;code&gt;start&lt;/code&gt;或者&lt;code&gt;begin&lt;/code&gt;命令开启事务；如果我们想提交事务可以手动执行&lt;code&gt;commit&lt;/code&gt;命令，如果我们想回滚事务，可以执行&lt;code&gt;rollback&lt;/code&gt;命令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：在&lt;code&gt;MySQL&lt;/code&gt;中事务的提交是默认开启的，可以执行&lt;code&gt;show variables like &#x27;autocommit&#x27;&lt;/code&gt;命令查看，如果是&lt;code&gt;ON&lt;/code&gt;则证明自动提交已经开启，如果为&lt;code&gt;OFF&lt;/code&gt;则需要手动提交。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;隔离性引发的并发问题&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）脏读：B事务读取到了A事务尚未提交的数据；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）不可重复读：B事务读到了A事务已经提交的数据，即B事务在A事务提交之前和提交之后读取到的数据&lt;code&gt;内容&lt;/code&gt;不一致（AB事务操作的是同一条数据）；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）幻读/虚读：B事务读到了A事务已经提交的数据，即A事务执行插入操作，B事务在A事务前后读到的数据&lt;code&gt;数量&lt;/code&gt;不一致。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;事务的隔离级别&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决以上隔离性引发的并发问题，数据库提供了事物的隔离机制。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;read uncommitted（读未提交）: 一个事务还没提交时，它做的变更就能被别的事务看到，读取尚未提交的数据，哪个问题都不能解决；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;read committed（读已提交）：一个事务提交之后，它做的变更才会被其他事务看到，读取已经提交的数据，可以解决脏读 ---- &lt;code&gt;oracle&lt;/code&gt;默认的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;repeatable read（可重复读）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的，可以解决脏读和不可重复读 ---&lt;code&gt;mysql&lt;/code&gt;默认的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;serializable（串行化）：顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。可以解决脏读、不可重复读和虚读---相当于锁表。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然&lt;code&gt;serializable&lt;/code&gt;级别可以解决所有的数据库并发问题，但是它会在读取的每一行数据上都加锁，这就可能导致大量的超时和锁竞争问题，从而导致效率下降。所以我们在实际应用中也很少使用&lt;code&gt;serializable&lt;/code&gt;，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;LBCC&amp;amp;MVCC&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;InnoDB&lt;/code&gt;默认的事务隔离级别是&lt;code&gt;repeatable read&lt;/code&gt;（后文中用简称RR），它为了解决该隔离级别下的幻读的并发问题，提出了&lt;code&gt;LBCC&lt;/code&gt;和&lt;code&gt;MVCC&lt;/code&gt;两种方案。其中&lt;code&gt;LBCC&lt;/code&gt;解决的是当前读情况下的幻读，&lt;code&gt;MVCC&lt;/code&gt;解决的是普通读（快照读）的幻读。至于什么是当前读，什么是快照读，将在下文中给出答案。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;LBCC&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;LBCC&lt;/code&gt;是&lt;code&gt;Lock-Based Concurrent Control&lt;/code&gt;的简称，意思是基于锁的并发控制。在&lt;code&gt;InnoDB&lt;/code&gt;中按锁的模式来分的话可以分为共享锁（S）、排它锁（X）和意向锁，其中意向锁又分为意向共享锁（IS）和意向排它锁（IX）（此处先不做介绍，后期会专门出篇文章讲一下&lt;code&gt;InnoDB&lt;/code&gt;和&lt;code&gt;Myisam&lt;/code&gt;引擎的锁）；如果按照锁的算法来分的话又分为记录锁（&lt;code&gt;Record Locks&lt;/code&gt;）、间隙锁（&lt;code&gt;Gap Locks&lt;/code&gt;）和临键锁（&lt;code&gt;Next-key Locks&lt;/code&gt;）。其中临键锁就可以用来解决RR下的幻读问题。那么什么是临键锁呢？继续往下看。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.47058823529411764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpMjiaoJ2Quu9UPMoKdX5z9aupQuiaGicPz8qWdq0ddjUZTWe5MmjqKL5CL9R5mLNe8X5mLhcibibqRGpKQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;816&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们将数据库中存储的每一行数据称为记录。则上图中1、5、9、11分别代表id为当前数的记录。对于键值在条件范围内但不存在的记录，叫做间隙（GAP）。则上图中的（-∞，1）、（1，5）...（11，+∞）为数据库中存在的间隙。而（-∞，1]、（1，5]...（11，+∞）我们称之为临键，即左开右闭的集合。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;记录锁（Record Locks）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对表中的行记录加锁，叫做记录锁，简称行锁。可以使用&lt;code&gt;sql&lt;/code&gt;语句&lt;code&gt;select ... for update&lt;/code&gt;来开启锁，&lt;code&gt;select&lt;/code&gt;语句必须为精准匹配（=），不能为范围匹配，且匹配列字段必须为唯一索引或者主键列。也可以通过对查询条件为主键索引或唯一索引的数据行进行&lt;code&gt;UPDATE&lt;/code&gt;操作来添加记录锁。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;记录锁存在于包括主键索引在内的唯一索引中，锁定单条索引记录。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;间隙锁（GAP Locks）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对上面说到的间隙加锁即为间隙锁。间隙锁是对范围加锁，但不包括已存在的索引项。可以使用&lt;code&gt;sql&lt;/code&gt;语句&lt;code&gt;select ... for update&lt;/code&gt;来开启锁，&lt;code&gt;select&lt;/code&gt;语句为范围查询，匹配列字段为索引项，且没有数据返回；或者&lt;code&gt;select&lt;/code&gt;语句为等值查询，匹配字段为唯一索引，也没有数据返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。以下是加锁之后，插入操作的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;select * from user where id &amp;gt; &lt;span&gt;15&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; update;&lt;br/&gt;&lt;span&gt;//插入失败，因为id20大于15，不难理解&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into user &lt;span&gt;values&lt;/span&gt;&lt;span&gt;(&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;&#x27;20&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//插入失败，原因是间隙锁锁的是记录间隙，而不是sql，也就是说`select`语句的锁范围是（11，+∞），而13在这个区间中，所以也失败。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;insert into user &lt;span&gt;values&lt;/span&gt;&lt;span&gt;(&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;&#x27;13&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;&lt;code&gt;GAP Locks&lt;/code&gt;只存在于RR隔离级别下，它锁住的是间隙内的数据。加完锁之后，间隙中无法插入其他记录，并且锁的是记录间隙，而非&lt;code&gt;sql&lt;/code&gt;语句。间隙锁之间都不存在冲突关系。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;打开间隙锁设置：&lt;/strong&gt; 以通过命令&lt;code&gt;show variables like &#x27;innodb_locks_unsafe_for_binlog&#x27;;&lt;/code&gt;来查看 &lt;code&gt;innodb_locks_unsafe_for_binlog&lt;/code&gt; 是否禁用。&lt;code&gt;innodb_locks_unsafe_for_binlog&lt;/code&gt;默认值为OFF，即启用间隙锁。因为此参数是只读模式，如果想要禁用间隙锁，需要修改 &lt;code&gt;my.cnf&lt;/code&gt;（windows是&lt;code&gt;my.ini&lt;/code&gt;） 重新启动才行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;#在 my.cnf 里面的[mysqld]添加&lt;br/&gt;[mysqld]&lt;br/&gt;innodb_locks_unsafe_for_binlog = 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;临键锁（Next-Key Locks）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们对上面的记录和间隙共同加锁时，添加的便是临键锁（左开右闭的集合加锁）。为了防止幻读，临键锁阻止特定条件的新记录的插入，因为插入时要获取插入意向锁，与已持有的临键锁冲突。可以使用&lt;code&gt;sql&lt;/code&gt;语句&lt;code&gt;select ... for update&lt;/code&gt;来开启锁，&lt;code&gt;select&lt;/code&gt;语句为范围查询，匹配列字段为索引项，且有数据返回；或者&lt;code&gt;select&lt;/code&gt;语句为等值查询，匹配列字段为索引项，不管有没有数据返回。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;插入意向锁并非意向锁，而是一种特殊的间隙锁。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果查询没有命中索引，则退化为表锁;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果等值查询唯一索引且命中唯一一条记录，则退化为行锁;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果等值查询唯一索引且没有命中记录，则退化为临近结点的间隙锁;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果等值查询非唯一索引且没有命中记录，退化为临近结点的间隙锁(包括结点也被锁定)；如果命中记录，则锁定所有命中行的临键锁，并同时锁定最大记录行下一个区间的间隙锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果范围查询唯一索引或查询非唯一索引且命中记录，则锁定所有命中行的临键锁 ，并同时锁定最大记录行下一个区间的间隙锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果范围查询索引且没有命中记录，退化为临近结点的间隙锁(包括结点也被锁定)。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;当前读&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当前读（&lt;code&gt;Locking Read&lt;/code&gt;）也称锁定读，读取当前数据的最新版本，而且读取到这个数据之后会对这个数据加锁，防止别的事务更改即通过&lt;code&gt;next-key&lt;/code&gt;锁（行锁+gap锁）来解决当前读的问题。在进行写操作的时候就需要进行“当前读”，读取数据记录的最新版本，包含以下&lt;code&gt;SQL&lt;/code&gt;类型：&lt;code&gt;select ... lock in share mode&lt;/code&gt; 、&lt;code&gt;select ... for update&lt;/code&gt;、&lt;code&gt;update&lt;/code&gt; 、&lt;code&gt;delete&lt;/code&gt; 、&lt;code&gt;insert&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;MVCC&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;LBCC&lt;/code&gt;是基于锁的并发控制，因为锁的粒度过大，会导致性能的下降，因此提出了比&lt;code&gt;LBCC&lt;/code&gt;性能更优越的方法&lt;code&gt;MVCC&lt;/code&gt;。&lt;code&gt;MVCC&lt;/code&gt;是&lt;code&gt;Multi-Version Concurremt Control&lt;/code&gt;的简称，意思是基于多版本的并发控制协议，通过版本号，避免同一数据在不同事务间的竞争，只存在于&lt;code&gt;InnoDB&lt;/code&gt;引擎下。它主要是为了提高数据库的并发读写性能，不用加锁就能让多个事务并发读写。&lt;code&gt;MVCC&lt;/code&gt;的实现依赖于：三个隐藏字段、&lt;code&gt;Undo log&lt;/code&gt;和&lt;code&gt;Read View&lt;/code&gt;，其核心思想就是：只能查找事务id小于等于当前事务ID的行；只能查找删除时间大于等于当前事务ID的行，或未删除的行。接下来让我们从源码级别来分析下&lt;code&gt;MVCC&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;隐藏列&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MySQL&lt;/code&gt;中会为每一行记录生成隐藏列，接下来就让我们了解一下这几个隐藏列吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）DB_TRX_ID：事务ID，是根据事务产生时间顺序自动递增的，是独一无二的。如果某个事务执行过程中对该记录执行了增、删、改操作，那么&lt;code&gt;InnoDB&lt;/code&gt;存储引擎就会记录下该条事务的id。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）DB_ROLL_PTR：回滚指针，本质上就是一个指向记录对应的&lt;code&gt;undo log&lt;/code&gt;的一个指针，大小为 7 个字节，&lt;code&gt;InnoDB&lt;/code&gt; 便是通过这个指针找到之前版本的数据。该行记录上所有旧版本，在&lt;code&gt;undo log&lt;/code&gt;中都通过链表的形式组织。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）DB_ROW_ID：行标识（隐藏单调自增 &lt;code&gt;ID&lt;/code&gt;），如果表没有主键，InnoDB 会自动生成一个隐藏主键，大小为 6 字节。如果数据表没有设置主键，会以它产生聚簇索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）实际还有一个删除flag隐藏字段，既记录被更新或删除并不代表真的删除，而是删除flag变了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;undo log&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每当我们要对一条记录做改动时（这里的改动可以指INSERT、DELETE、UPDATE），都需要把回滚时所需的东西记录下来, 比如:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Insert undo log ：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Delete undo log：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Update undo log：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。&lt;code&gt;InnoDB&lt;/code&gt;把这些为了回滚而记录的这些东西称之为&lt;code&gt;undo log&lt;/code&gt;。这里需要注意的一点是，由于查询操作（&lt;code&gt;SELECT&lt;/code&gt;）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的&lt;code&gt;undo log&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次对记录进行改动都会记录一条undo日志，每条undo日志也都有一个&lt;code&gt;DB_ROLL_PTR&lt;/code&gt;属性，可以将这些undo日志都连起来，串成一个链表，形成版本链。版本链的头节点就是当前记录最新的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;例&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先插入一条记录，假设该记录的事务id为80，那么此刻该条记录的示意图如下所示&lt;img data-ratio=&quot;0.27648578811369506&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpMjiaoJ2Quu9UPMoKdX5z9aucAqWFhWpAulhbUZ8ApxgvXXiagqth5n8V31TQWQtVWmL3snWm8CeC9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;774&quot;/&gt;实际上&lt;code&gt;insert undo&lt;/code&gt;只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的&lt;code&gt;Undo Log Segment&lt;/code&gt;也会被系统回收。接着继续执行sql操作&lt;img data-ratio=&quot;0.5263157894736842&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpMjiaoJ2Quu9UPMoKdX5z9auiaicYmiawosFqibNUWE05IoWWBBEiasYGgpgNlUE8NL453j7Obs6FKicmhpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;855&quot;/&gt;其版本链如下&lt;img data-ratio=&quot;0.5210946408209807&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpMjiaoJ2Quu9UPMoKdX5z9auokcsEEO64Pd89F031bpRvDenDx9qU0Oibicj8H4d1MJLbG9icibMxyXFiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;877&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;很多人以为&lt;code&gt;undo log&lt;/code&gt;用于将数据库物理的恢复到执行语句或者事务之前的样子，其实并非如此，&lt;code&gt;undo log&lt;/code&gt;是逻辑日志，只是将数据库逻辑的恢复到原来的样子。因为在多并发系统中，你把一个页中的数据物理的恢复到原来的样子，可能会影响其他的事务。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Read View&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在可重复读隔离级别下，我们可以把每一次普通的&lt;code&gt;select&lt;/code&gt;查询（不加&lt;code&gt;for update&lt;/code&gt;语句）当作一次快照读，而快照便是进行&lt;code&gt;select&lt;/code&gt;的那一刻，生成的当前数据库系统中所有未提交的事务id数组（数组里最小的&lt;code&gt;id&lt;/code&gt;为&lt;code&gt;min_id&lt;/code&gt;）和已经创建的最大事务&lt;code&gt;id&lt;/code&gt;（&lt;code&gt;max_id&lt;/code&gt;）的集合，即我们所说的一致性视图&lt;code&gt;readview&lt;/code&gt;。在进行快照读的过程中要根据一定的规则将版本链中每个版本的事务&lt;code&gt;id&lt;/code&gt;与&lt;code&gt;readview&lt;/code&gt;进行匹配查询我们需要的结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;快照读是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。快照读的实现是基于多版本并发控制，即&lt;code&gt;MVCC&lt;/code&gt;，可以认为&lt;code&gt;MVCC&lt;/code&gt;是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。&lt;code&gt;MVCC&lt;/code&gt;只在 &lt;code&gt;READ COMMITTED&lt;/code&gt; 和 &lt;code&gt;REPEATABLE READ&lt;/code&gt;两个隔离级别下工作，其他两个隔离级别不和&lt;code&gt;MVCC&lt;/code&gt;不兼容。因为&lt;code&gt;READ UNCOMMITTED&lt;/code&gt;总是读取最新的数据行，而不是符合当前事务版本的数据行，而&lt;code&gt;SERIALIZABLE&lt;/code&gt; 则会对所有读取的行都加锁。事务的快照时间点（即下文中说到的&lt;code&gt;Read View&lt;/code&gt;的生成时间）是以第一个&lt;code&gt;select&lt;/code&gt;来确认的。所以即便事务先开始，但是&lt;code&gt;select&lt;/code&gt;在后面的事务的&lt;code&gt;update&lt;/code&gt;之类的语句后进行，那么它是可以获取前面的事务的对应的数据。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;RC和RR隔离级别下的快照读和当前读：RC隔离级别下，快照读和当前读结果一样，都是读取已提交的最新；RR隔离级别下，当前读结果是其他事务已经提交的最新结果，快照读是读当前事务之前读到的结果。RR下创建快照读的时机决定了读到的版本。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于使用RC和RR隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的。核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的。为此，&lt;code&gt;InnoDB&lt;/code&gt;提出了一个&lt;code&gt;Read View&lt;/code&gt;的概念。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Read View&lt;/code&gt;就是事务进行快照读（普通&lt;code&gt;select&lt;/code&gt;查询）操作的时候生产的一致性读视图，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，它由执行查询时所有未提交的事务id数组（数组里最小的id为&lt;code&gt;min_id&lt;/code&gt;）和已经创建的最大事务id（&lt;code&gt;max_id&lt;/code&gt;）组成，查询的数据结果需要跟&lt;code&gt;read view&lt;/code&gt;做对比从而得到快照结果。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.31871345029239767&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpMjiaoJ2Quu9UPMoKdX5z9aufArozcWViaT8FVNLkxrWmEXYlpjkZdWP8hhshiaHttEmicuv87g1q0Yxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;684&quot;/&gt;&lt;figcaption&gt;快照规则&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;版本链比对规则：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果落在绿色部分（trx_id&amp;lt;min_id），表示这个版本是已经提交的事务生成的，这个数据是可见的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果落在红色部分（trx_id&amp;gt;max_id），表示这个版本是由将来启动的事务生成的，是肯定不可见的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果落在黄色部分（min_id&amp;lt;=trx_id&amp;lt;=max_id），那就包含两种情况：a.若row的trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；如果是自己的事务，则是可见的；b.若row的trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;光说不练假把式，接下来就让我们用例子来演示一下：首先我们要准备两张表，一张&lt;code&gt;test&lt;/code&gt;和一张&lt;code&gt;account&lt;/code&gt;表，然后我们以&lt;code&gt;account&lt;/code&gt;的&lt;code&gt;undo log&lt;/code&gt;来画版本链，准备数据和原始记录图如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//test表中数据&lt;/span&gt;&lt;br/&gt;id=&lt;span&gt;1&lt;/span&gt;,c1=&lt;span&gt;&#x27;11&#x27;&lt;/span&gt;;&lt;br/&gt;id=&lt;span&gt;5&lt;/span&gt;,c1=&lt;span&gt;&#x27;22&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//account表数据&lt;/span&gt;&lt;br/&gt;id=&lt;span&gt;1&lt;/span&gt;，name=‘lilei’；&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2094017094017094&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpMjiaoJ2Quu9UPMoKdX5z9aujAhYr0NvoIhBzEyOCDooRhVfXiag69pncJcL6LNhx9CIAMnZXm3LXKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;如下图，我们将按照里面的顺序执行&lt;code&gt;sql&lt;/code&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpMjiaoJ2Quu9UPMoKdX5z9auGMZUP6joPayTRDuGGaIwoqM1dIfLiaTyw1D1yknLy3A4cRmwLrv9m7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.23333333333333334&quot; data-w=&quot;1080&quot;/&gt;当我们执行到第7行的&lt;code&gt;select&lt;/code&gt;的语句时，会生成&lt;code&gt;readview[100,200],300&lt;/code&gt;,版本链如图所示：&lt;img data-ratio=&quot;0.39755766621438265&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpMjiaoJ2Quu9UPMoKdX5z9auG5mQWb3vnQ4MTO6YKYVib3MfribmFaw1Tt40gpBNl95Jbxazxx5ERDxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;737&quot;/&gt;此时我们查询到的数据为&lt;code&gt;lilei300&lt;/code&gt;。我们首先要拿最新版本的数据&lt;code&gt;trx_id=300&lt;/code&gt;来&lt;code&gt;readview&lt;/code&gt;中匹配，落在黄色区间内，一看该数据已经提交了，所以是可见的。继续往下执行，当执行到第10行的&lt;code&gt;select&lt;/code&gt;语句时，因为&lt;code&gt;trx_id=100&lt;/code&gt;并未提交，所以版本链依然为&lt;code&gt;readview[100,200],300&lt;/code&gt;，版本链如图所示：&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpMjiaoJ2Quu9UPMoKdX5z9auHqLIFKbLFmfvv9FBn9vUuTEh6zuFcibPEuFxRPKktibRUwicialJd56TRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.9365269461077844&quot; data-w=&quot;835&quot;/&gt;此时我们查询到的数据为&lt;code&gt;lilei300&lt;/code&gt;。我们按上边操作，从最新版本依次往下匹配，我们首先要拿最新版本的数据&lt;code&gt;trx_id=100&lt;/code&gt;来&lt;code&gt;readview&lt;/code&gt;中匹配，落在黄色区间内，一看该数据在未提交的数组中，且不是自己的事务，所以是不可见的；然后我们选择前一个版本的数据，结果同上；继续向上找，当找到&lt;code&gt;trx_id=300&lt;/code&gt;的数据时，会落在黄色区间，且是提交的，所以数据可见。继续往下执行，当执行到第13行的&lt;code&gt;select&lt;/code&gt;语句时，此时尽管&lt;code&gt;trx_id=100&lt;/code&gt;已经提交了，因为是&lt;code&gt;InnoDB&lt;/code&gt;的RR模式，所以&lt;code&gt;readview&lt;/code&gt;不会更改，仍为&lt;code&gt;readview[100,200],300&lt;/code&gt;,版本链如图所示：&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpMjiaoJ2Quu9UPMoKdX5z9auW2hQg6kGelEHQ2EL0icd5lcgMRCMGCA3ibVKTmOpWnVn3xSwuXIS0sNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.0862745098039215&quot; data-w=&quot;765&quot;/&gt;此时我们查询到的数据为&lt;code&gt;lilei300&lt;/code&gt;。原因同上边的步骤，不再赘述。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;当执行&lt;code&gt;update&lt;/code&gt;语句时，都是先读后写的，而这个读，是当前读，只能读当前的值，跟&lt;code&gt;readview&lt;/code&gt;查找时的快照读区分开。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚才演示的是&lt;code&gt;InnoDB&lt;/code&gt;下的RR模式，接下来我们简单说一下RC模式，上文中提到的RC模式的数据读都是读最新的即当前读，所以readview是实时生成的，执行语句如图所示：&lt;img data-ratio=&quot;0.25&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpMjiaoJ2Quu9UPMoKdX5z9audF3EichWBqWje6dD4gyCxiceNxjuibLLUCTmicic626sh06GrzFWE3icxxqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1560&quot;/&gt;当我们执行到第13行的&lt;code&gt;select&lt;/code&gt;的语句时，会生成&lt;code&gt;readview[200],300&lt;/code&gt;，版本链还和之前一样，此时我们查询到的数据为&lt;code&gt;lilei2&lt;/code&gt;。原因和上边讲的RR模式下的比对规则相同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此处我们演示的是&lt;code&gt;update&lt;/code&gt;的情况，对于删除的情况可以认为是&lt;code&gt;update&lt;/code&gt;的特殊情况，会将版本链上最新的数据复制一份，然后将&lt;code&gt;trx_id&lt;/code&gt;改成删除操作的&lt;code&gt;trx_id&lt;/code&gt;，同时在该条记录的头信息（&lt;code&gt;record header&lt;/code&gt;）里的（&lt;code&gt;deleted_flag&lt;/code&gt;）标记位上写上&lt;code&gt;true&lt;/code&gt;，来表示当前记录已经被删除，在查询时按照上边的规则查到对应的记录，如果&lt;code&gt;delete_flag&lt;/code&gt;标记位为&lt;code&gt;true&lt;/code&gt;，意味着记录已被删除，则不返回数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家应该还关心一个问题，即&lt;code&gt;undo log&lt;/code&gt;什么时候删除呢？系统会判断，没有比这个&lt;code&gt;undo log&lt;/code&gt;更早的&lt;code&gt;read view&lt;/code&gt;的时候，&lt;code&gt;undo log&lt;/code&gt;会被删除。所以这里也就是为什么我们建议你尽量不要使用长事务的原因。长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是今天的全部内容了，如果你感兴趣的话，可以关注微信公众号“阿Q说”！你也可以后台留言说出你的疑惑，阿Q将会在后期的文章中为你解答。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2f2bb6ce7e9493220aae9bdf724163b1</guid>
<title>实操：如何将 Containerd 用作 Kubernetes runtime</title>
<link>https://toutiao.io/k/o4pjxdm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;大家好，今天分享的内容将会从 Kubernetes 宣布弃用 dockershim 说起，介绍 Containerd 相关特性，分享如何将 Containerd 用作 Kubernetes 的 runtime。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Kubernetes 宣布弃用 dockershim&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;很多媒体将该事件宣称为 Kubernetes 宣布弃用 Docker，其实这是一种误导。那么应该如何正确的去看待呢？首先是了解整个事情的前因后果，得需要知道 dockershim 是什么。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;dockershim&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;dockershim 是 Kubernetes 的一个组件，主要目的是为了通过 CRI 操作 Docker。Docker在 2013 年就出现了，2014 年 Kubernetes 发布并默认使用 Docker 作为容器运行时，而 dockershim首次正式出现是在 2016 年。Docker 在创建之初并没有考虑到容器编排或者是考虑 Kubernetes，但 Kubernetes 在创建之初便采用Docker 作为它的默认容器进行时，后续代码当中包含了很多对 Docker 相关的操作逻辑。后期 Kubernetes 为了能够做解耦，兼容更多的容器进行时，将操作 Docker 相关逻辑整体独立起来组成了 dockershim。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Container Runtime Interface&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;再说 CRI（Container Runtime Interface）即容器运行时接口，该概念是由Kubernetes 提出并在 2016 年底开始应用，其主要目标是增强 Kubernetes 的可扩展性，可以不固定、不捆绑某一个容器运行时，实现可插拔式的容器进行时。比如可以使用 Docker 为容器运行时也可以使用其他的例如 rkt，并且希望通过开放 CRI 这个统一的接口来提高代码的可维护性，而不是需要支持 Docker 时就对 Docker 进行适配，需要支持另一个运行时就得对其做相关的适配。&lt;b&gt;它希望是任何一个成为 Kubernetes 的容器运行时都遵守 CRI 统一的接口与规范，实现了 CRI 就可以作为 Kubernetes 的运行时，并不需要关注具体是什么。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;为什么要弃用 dockershim&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;dockershim 的目的是为了 Kubernetes 通过 CRI 操作 Docker，所以Kubernetes 任何的功能变动或 Docker 有任何的功能特性变更，dockershim 代码必须加以改动保证能够支持变更。另外一个原因是随着容器技术的推进，容器运行时已经多种多样了，比如本次分享的主角 Containerd，还有 cri-o 以及 rkt 的容器运行时，不过这个 rkt 容器运行时的项目已经不维护了。&lt;/p&gt;&lt;p&gt;此外，原先 Kubernetes 需要去调用 dockershim 跟 Docker 做沟通，Docker 的底层运行时是 containerd，可以发现最终都是要调用 containerd，并且 containerd 自身也是可以支持 CRI 的。那为什么要先绕过一层 Docker 呢？是不是可以直接通过 CRI 跟 Containerd 进行交互呢？这也就造成了现在 Kubernetes 社区希望弃用 dockershim。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;弃用 dockershim 的影响&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;终端⽤⼾⽆任何影响。这里指的是使用来自云厂商/使用别人提供的Kubernetes 集群的终端用户，他们不需要关注集群本身的容器运行时到底是什么，因为和你交互的都是 Kubernetes 自身的 CRI，而任何一个可以作为 Kubernetes 底层容器运行时的东西都必须是兼容 CRI 接口的，上层就已经屏蔽掉这个细节了。&lt;/p&gt;&lt;p&gt;对负责维护 Kubernetes 集群的工作人员有一定影响。当升级 Kubernetes 集群版本时，需要考虑是否切换容器进行时。如果目前在用最新版本 Kubernetes V1.20，并且使用 Docker 作为容器运行时，要考虑它能否正常工作。其实是可以正常工作的，只是在启动 Kubernetes 的时候会发现一条日志，提醒你当前使用的容器运行时 Docker 已经不再被 Kubernetes 支持，因为已经准备弃用dockershim，因此会有这个提醒。&lt;/p&gt;&lt;p&gt;Kubernetes 社区计划在 2021 年将dockershim 正式移除。换个角度考虑，既然社区不想在 Kubernetes 源代码当中维护 dockershim 了，那是不是可以把 dockershim 组件给单独的拿出来呢？答案是可以的，现在 Mirantis 和 Docker 已经决定之后共同合作维护 dockershim 组件。此外，还可以通过树外的 dockershim 独立组件，继续使用 Docker 作为容器运行时，并且使用这种方式只需要做一些简单的配置，把原先使用内置的Kubernetes 自身携带的 dockershim 组件，改成使用一个独立的 dockershim 组件，本身变动很小。&lt;/p&gt;&lt;p&gt;那么 Docker 到底还能否使用呢？在我看来，毋庸置疑，Docker 仍然是现阶段容器构建和运行的最佳选择。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;快速了解 Containerd&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Containerd 是中间层的容器运行时。它构建在平台之下，作为平台下层的一个容器运行时，但又比最底层的容器运行时像 runc、gVisor 要高一点，所以被称为中间层的容器运行时。除此之外也可称作为资源管理器，可以用来管理容器的进程、镜像以及管理文件系统的快照，还有元数据和依赖的管理。既然它可以作为一个资源管理器来使用，如果想要在此之上构建一个属于自己的容器平台就会很方便。&lt;/p&gt;&lt;p&gt;Containerd 是由 Docker 公司创建，并且在 2017年捐赠给了 CNCF，2019 年 Containerd 从 CNCF 正式毕业。Containerd 项目一开始的目标是用来管理容器的进程，之后逐步变更成为一个完整的容器运行时，是 Docker 的底层容器运行时。需要说明的是，containerd 是可以抛开 Docker 与 Kubernetes 自身独立工作的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Containerd 与 CRI&lt;/b&gt;&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-383fba222e36065df48fa6f4075f04cb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1160&quot; data-rawheight=&quot;351&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-383fba222e36065df48fa6f4075f04cb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1160&quot; data-rawheight=&quot;351&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-383fba222e36065df48fa6f4075f04cb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-383fba222e36065df48fa6f4075f04cb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Containerd 在之前的版本中考虑到了 CRI，但它是将CRI 作为独立的进程存在的。在上图中看到，CRI-Containerd 其实是一个独立组件，Kubernetes 通过 CRI 接口调用 CRI-Containerd，再由这个组件去调用 containerd。在 Containerd1.1 版本之后对该特性做了重新的设计，它将 CRI 的支持通过插件化的方式来实现，Kubernetes 通过 CRI 接口调用的其实是 Containerd 当中 CNI 的插件，以此来达到通信的目的，调用链更少更短了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Containerd 的特性&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;支持 OCI 镜像规范，即前文所提到的 runc&lt;/li&gt;&lt;li&gt;支持 OCI 运行时规范。Docker 引导了 OCI 组织的成立，该组织主要有两个规范：镜像规范与运行时规范。这两个规范在 Docker 成立时把 Docker 镜像规范与底层容器运行时规范都给捐赠出来作为它的初始工作&lt;/li&gt;&lt;li&gt;支持镜像的 push/pull 作用&lt;/li&gt;&lt;li&gt;支持容器网络管理。因为可以启动和运行容器，容器启动后支持相互之间的访问，或彼此之间网络的隔离，所以需要支持容器网络的管理&lt;/li&gt;&lt;li&gt;存储支持多租户。Containerd 的相关操作有通过 namespace 来做隔离的，可以指定不同的 namespace 来实现，它默认的 namespace 叫 default，在 default 的 namespace下面下载多个镜像。但是在其他的 namespace 下看不到这些镜像，也用不到，以此来达到多租户的隔离&lt;/li&gt;&lt;li&gt;支持容器运行时和容器的生命周期管理&lt;/li&gt;&lt;li&gt;支持管理网络名称空间容器以加入现有名称空间，可以让某一个容器加入到现有的 namespace 当中&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;Containerd 的整体架构&lt;/b&gt;&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-01620547a2bd304bd58766ac35b54aac_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1329&quot; data-rawheight=&quot;801&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-01620547a2bd304bd58766ac35b54aac_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1329&quot; data-rawheight=&quot;801&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-01620547a2bd304bd58766ac35b54aac_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-01620547a2bd304bd58766ac35b54aac_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图是 Containerd 整体的架构。由下往上，Containerd支持的操作系统和架构有 Linux、Windows 以及像 ARM 的一些平台。在这些底层的操作系统之上运行的就是底层容器运行时，其中有上文提到的runc、gVisor 等。在底层容器运行时之上的是Containerd 相关的组件，比如 Containerd 的 runtime、core、API、backend、store 还有metadata 等等。构筑在 Containerd 组件之上以及跟这些组件做交互的都是 Containerd 的 client，Kubernetes 跟 Containerd 通过 CRI 做交互时，本身也作为 Containerd 的一个 client。Containerd 本身有提供了一个 CRI，叫 ctr，不过这个命令行工具并不是很好用。&lt;/p&gt;&lt;p&gt;在这些组件之上就是真正的平台，Google Cloud、Docker、IBM、阿里云、微软云还有RANCHER等等都是，这些平台目前都已经支持 containerd， 并且有些已经作为自己的默认容器运行时了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Containerd 主要功能与上手实践&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;镜像管理&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9266dbb5a186489dcfcbe8ec93478016_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;364&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-9266dbb5a186489dcfcbe8ec93478016_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;364&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-9266dbb5a186489dcfcbe8ec93478016_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-9266dbb5a186489dcfcbe8ec93478016_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;首先是上文中频繁提到的镜像管理。具体操作是需要通过一个 client 去跟 Containerd 做交互。如图中所示，这里选择了ctr 的命令行工具。ctr指定一个address 参数跟 Containerd交互，它是在后台持续运行的一个服务，需要指定它的地址。图中是通过 pull 一个 redis alpine linux 的镜像，接下来通过 image ls就可以看到已经成功 pull 下来的镜像。&lt;/p&gt;&lt;p&gt;&lt;b&gt;容器管理&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0525dd88ae4ff73adea7c73803e3b5a7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;285&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-0525dd88ae4ff73adea7c73803e3b5a7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;285&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-0525dd88ae4ff73adea7c73803e3b5a7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-0525dd88ae4ff73adea7c73803e3b5a7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;作为一个容器运行时对容器进行管理是必不可少的功能。同样的通过 -a 参数来指定 address 与Containerd 进行通信，通过 container create+镜像名称+容器名称来创建一个容器，通过 container ls 可以看到刚才创建的容器。需要注意的是，最后一列叫做 runtime，它的 runtime 叫做 io.containerd.runc.v2，表明是 v2 版本的 Containerd API。&lt;/p&gt;&lt;p&gt;在 Containerd 中通过 container create 创建出来的容器其实并不管用，还需要让其运行起来。这时通常会把它当作一个 task，对它执行 task start，就可以把刚才创建的镜像跑起来了。通过 task ls 就可以看到名叫 redis 的 Containerd，其中有一个正在运行的进程，并且展现出了进程号。&lt;/p&gt;&lt;p&gt;&lt;b&gt;命名空间&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-44b74869d98c3164fe1ae4ba4cb4dfb3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1640&quot; data-rawheight=&quot;264&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-44b74869d98c3164fe1ae4ba4cb4dfb3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1640&quot; data-rawheight=&quot;264&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-44b74869d98c3164fe1ae4ba4cb4dfb3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-44b74869d98c3164fe1ae4ba4cb4dfb3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;需要说明的是，可以通过 -n 来指定一个默认的叫做 default 的命名空间，而后通过 task ls 就看到刚才启动容器的进程，它其实是在运行中的。如果把 namespace 换一个，比如图中的 moby 就是 Docker 项目当前使用的 namespace 名称，Docker 在使用 Containerd 作为容器运行时的时候，会默认使用它。&lt;/p&gt;&lt;p&gt;继续往下看，通过 ctr -n 指定使用 moby 命名空间，-a 参数指定containerd 的地址，然后 task ls 来看看moby 项目当中到底运行着什么。可以看到有一条记录是正在运行当中的。这条记录如何和 Docker 当中的容器或任务做匹配比较呢？一个简单的办法就是通过 docker ps --no-trunc-- format 跟容器完整的 ID，然后 grep 就可以看到刚才通过 ctr 命令得到的ID 了。&lt;/p&gt;&lt;p&gt;需要注意的是，如果使用 Containerd 作为 Kubernetes 的容器运行时，那么它的 namespace 叫 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//k8s.io&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;k8s.io&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt;。到这里可能有些人已经发现，Containerd 作为 Docker 的运行时可以使用不同的命名空间，比如 moby。用作 Kubernetes 容器运行时也可以使用不同的命名空间，比如 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//k8s.io&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;k8s.io&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt;。那是否存在一种办法可以让平台当中既有 Kubernetes 又有 Docker，还有 Containerd 呢？答案是肯定的，直接将其全部装到一起，但不配置 Docker 作为容器运行时，先观察一段时间看看，这也是一种办法。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Containerd 用作 Kubernetes 的 runtime&lt;/b&gt;&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-90a04f146defb696510f05035cdec318_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;527&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-90a04f146defb696510f05035cdec318_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;527&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-90a04f146defb696510f05035cdec318_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-90a04f146defb696510f05035cdec318_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图是 Containerd 用作 Kubernetes 的 runtime 整个流程图。Kubernetes 通过 CRI 接口，调用到 CRI plugin，plugin 是Containerd 一个内置的插件，其中包含了最主要的两部分：一是 image service，包含了镜像服务相关的；二是 runtime service，即运行时的服务。如果在 containerd 当中部署了一个项目或服务，它首先会调度到某一台机器，这台机器上的 Kubernetes 就会开始工作，它会查询服务、需要哪些镜像，而后把相关的镜像让运行时给拉下来，再去启动对应的 pod 或者相关的容器。&lt;/p&gt;&lt;p&gt;其次它还会跟 CNI 做交互。CNI 即 Container Network Interface，是Kubernetes 提供的一个容器网络接口）。主要注意的是，交互过程中可能会提前创建出来 pause的 container，是一个占位的过程，这里先不对此做更深入的介绍。&lt;/p&gt;&lt;p&gt;当 Containerd 作为 Kubernetes 的容器运行时，配置相对很简单：通过 containerd config default命令可以直接查询到 Containerd 完整的默认配置，下图中可以看到主要是配置 CRI。所以在这里的配置文件当中，通过 plugins.io.containerd.grpc.vi.cri 对其进行配置，首先是 default-runtime，其次配置一个 runtime.runc。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2a76e05cba3208812ccf8255949d7632_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;402&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-2a76e05cba3208812ccf8255949d7632_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;402&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-2a76e05cba3208812ccf8255949d7632_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2a76e05cba3208812ccf8255949d7632_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里简单介绍配置 runc 需要注意的参数。比如 io.containerd.runc.v2 需要配置runtime.type；涉及配置与 runc 相关的一些配置会包含一些 CNI 的配置、目录之类的，具体的配置上图中已经展示了。总而言之如果想要提起来一个服务、一个 pod 或是 container，要注意都是需要配置的。它都会有一个 pause的镜像，即 sandbox_image，可以从中指定一个默认的镜像。当然也可以通过此处换源，加快国内环境下的拉取速度。&lt;/p&gt;&lt;p&gt;最后还有些其他的资源，如本人长期参与的一个项目 KIND（ Kubernetes in  docker）。这个项目相当于是使用docker 容器作为不同的 node，可以把这些 node 组成一个集群网络，搭建一套 Kubernetes。而这个集群使用的容器运行时就是 containerd，虽然一开始使用的是 Docker，但后期逐步都将其替换成了 containerd，类似的还有包括 K3C、K3S，效果都是差不多的。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;推荐阅读：&lt;/b&gt;&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/620/Flink%2520%25E5%259C%25A8%25E5%258F%2588%25E6%258B%258D%25E4%25BA%2591%25E6%2597%25A5%25E5%25BF%2597%25E6%2589%25B9%25E5%25A4%2584%25E7%2590%2586%25E4%25B8%25AD%25E7%259A%2584%25E5%25AE%259E%25E8%25B7%25B5.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-558a91ec35d3376bc6adc6c5f0b7f30e_180x120.jpg&quot; data-image-width=&quot;711&quot; data-image-height=&quot;378&quot; class=&quot;LinkCard old LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;Flink 在又拍云日志批处理中的实践&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic3.zhimg.com/v2-558a91ec35d3376bc6adc6c5f0b7f30e_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/609/%25E8%2581%258A%25E8%2581%258A%25E9%25A3%258E%25E5%258F%25A3%25E4%25B8%258A%25E7%259A%2584%2520eBPF.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot;LinkCard old LinkCard--noImage&quot;&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;聊聊风口上的 eBPF&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>54f8cfb4df46f072d7bd9cd62813109e</guid>
<title>接口测试结果字段太多，断言烦不胜烦，DeepDiff 帮你一键搞定</title>
<link>https://toutiao.io/k/rz5gehp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.45454545454545453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/2YHAOzjnwqwQdgqW1xwNicGzGjv1VZW9roUDAKUp1pwmDLXCXhR2enz7MggEzsljQKYNnBibJBoHlLX3icibnzTKog/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;22&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近有学员问我，想要做一个平台对比代码之间的区别，用python如何去实现；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有同学问我，接口的返回字段特别多，成千上万行，如何快速审核验证返回值全部字段？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么今天就跟大家介绍&lt;strong&gt;一个库就可以很好实现以上两个需求&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/p1ibuRQ0oDlgYF6rZ7HRPDuicFDXKbydXwOzGMM8YdyotWpqsgdTmckjFRhHq6T0VPmYAKuyJ1mS9A05iaj1qiaNHw/0?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;280&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;242.7972027972028&quot; data-ratio=&quot;0.8642857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/p1ibuRQ0oDlgYF6rZ7HRPDuicFDXKbydXwk1ibibsiaJlsSDedbuPUXVMjmXnFEYrhpvmeA2MSNpyumSr8J0aHCbylw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;280&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;102514&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;1&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;338.2734375:606.4453125&quot;&gt;deepdiff&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;70%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;30%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实满足上面需求的库有两个deepdiff和difflib，主要区别是deepdiff显示的对比效果比较简洁，但是可以设置忽略的字段，difflib显示的对比结果可以是html的，比较详细。但是由于篇幅有限，我们今天只讲deepdiff。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;deepdiff模块常用来校验两个对象是否一致，并找出其中差异之处。其中提供了三个类，DeepDiff，DeepSearch和DeepHash，官网地址：&lt;span&gt;https://deepdiff.readthedocs.io/en/latest/&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;返回值的展示样式有两种，&lt;span&gt;文本视图（原始）和树视图（新).&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;102514&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot;&gt;2&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;305.3359375:597.46875&quot;&gt;运行&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;70%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;30%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于测试人员用的比较多的就是DeepDiff，所以今天我们主要讲解这个类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DeepDiff可以对字典，可迭代项，字符串和其他对象的深层差异。它将递归地查找所有更改。可以用来校验多种类型的文件内容，如txt、json、图片等......&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;下载&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;pip install deepdiff==4.3.2&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;案例1:校验json&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;demo1.json的文件内容如下:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.9170854271356784&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p1ibuRQ0oDlgYF6rZ7HRPDuicFDXKbydXwibata3gxDQYu688yIgQMfw4DwKUibBMicWCjTquMNZqFrw3eJibdcEM98g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;796&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;demo2.json的文件内容如下:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9158163265306123&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p1ibuRQ0oDlgYF6rZ7HRPDuicFDXKbydXwzaXonRibJF5ia3dvXxNVHFhPCg8VAOYj5xE8zEZQxOHUCIuvAj3zDwuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;784&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;示例代码如下：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5373493975903615&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p1ibuRQ0oDlgYF6rZ7HRPDuicFDXKbydXw0ABAPSRnRBibr2t6SjGhSOnfZnzQKRRsuB0mKekmoJtrdiaJvPviaplwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;运行代码的结果如下：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.13734939759036144&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p1ibuRQ0oDlgYF6rZ7HRPDuicFDXKbydXwRWqw559SnNY1qpvg0xCntUt1l3ic5s7EgceLaEZAk7UiaGp25v3cEIkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当两个对象中都存在，只是值不相同时，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;输出：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;values_changed：{}&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;案例2：校验字典&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p1ibuRQ0oDlgYF6rZ7HRPDuicFDXKbydXwuOjyEGgpGtTyE8VSxicMK3nBIBGqicjY3zNVoZpt55ZvhCp4hfhps0Fg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;832&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;运行效果如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3348115299334812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p1ibuRQ0oDlgYF6rZ7HRPDuicFDXKbydXwho2vy9cvl2VcwsBhiaG9CicmGSwQVwMSW2Gy6qtbUZOmicFnviaHVvqiahA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;902&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;默认是文本视图；使用树视图请添加view=&#x27;tree&#x27;参数。demo1中有该字段，demo2中没有该字段就会出现dictionary_item_removed字段和详细信息;demo1中没有该字段，demo2中有该字段就会出现dictionary_item_added字段和详细信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;案例3：可以设置参数，忽略一些字段，这个也是DeepDiff的亮点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在实际工作断言的时候，我们不关系对象顺序或者重复项，可以在比较的时候加入 ignore_order&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5721153846153846&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p1ibuRQ0oDlgYF6rZ7HRPDuicFDXKbydXwIcyGV2459rwrMgvXMPL1T8TwHtA9wP5V2D7XBtSheGO2x4PZYoSUzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;832&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;运行结果如下:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;{}&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;备注&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;102517&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot; data-role=&quot;list&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p hm_fix=&quot;401.22265625:464.5234375&quot;&gt;&lt;span&gt;我们可以根据自己实际的项目去增加字段，比如report_repetition重复报告情况，significant_digits小数点后的显著位数，&lt;strong&gt;&lt;span&gt;ignore_string_case是否区分大小写，&lt;/span&gt;&lt;/strong&gt;字段这边就不一一列举介绍了，可以参考官网。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p hm_fix=&quot;401.22265625:464.5234375&quot;&gt;&lt;span&gt;如果实际请求结果和预期值的json数据都一致，那么会返回{}空字典，否则会返回对比结果，根据这个特点进行断言。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;项目实战：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;免费的查询手机号码信息的接口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Url地址:http://api.63code.com/tel/api.php&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参数:tel = 电话号码&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;响应值:json数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7967914438502673&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p1ibuRQ0oDlgYF6rZ7HRPDuicFDXKbydXwWJrbLkGWwPqjyxhzO423kQ4twDQ1TtaniaBoBMj6RCjLtpVQ8OGlZBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1122&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;运行结果如下:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8881239242685026&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p1ibuRQ0oDlgYF6rZ7HRPDuicFDXKbydXwIawTk2pftCMickKLbOiaBQKZApxlRbBmTkoFBLl4j8HbjBUTzkr1ERmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1162&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上述的第一个用例，由于实际的请求结果和预期值的json数据都一致，所以DeepDiff返回空字典，然后断言成功；而第二个用例我们修改预期值的tel字段值，所以，DeepDiff返回了对比后的结果，与预期值不符，断言失败。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;102514&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;03&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;324.078125:456.6484375&quot;&gt;总结&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;70%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;30%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. api 测试的时候，可以直接将全部的 json 比较，来确定是不是一样，可以少写很多代码&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 数据库数据比较的时候也是一样可以，使用 sql 查处结果之后，直接变成 json 就可以和期望的 json 对比了&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. 还可以设置一些需要忽略的字段&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小伙伴们，DeepDiff你学会了吗？有任何问题都欢迎留言哟。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-width=&quot;8%&quot;&gt;&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; data-backh=&quot;26&quot; data-backw=&quot;27&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Ljib4So7yuWiazPia6ZCuiaRGZ8r5Cd84HYEr3FqwNCZEmZUlrHXicYnR0IFSl57XXVXFOl2ibYFRvdjXJ6bm8sJXia2w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;240&quot; data-width=&quot;100%&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p1ibuRQ0oDlhZ99p6sK65JcVfpC8m92whH2WXl1DXBwb65tCQT5viaBvtsVHj1ALEicQUj3ziacb2ESnW7WIj72aWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;48&quot;/&gt;学习安排上！&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p1ibuRQ0oDlhZ99p6sK65JcVfpC8m92whH2WXl1DXBwb65tCQT5viaBvtsVHj1ALEicQUj3ziacb2ESnW7WIj72aWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;48&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-id=&quot;us-3564582&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;85615&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;em&gt;&lt;span&gt;码个问题考考你&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;LoadRunner分哪三部分&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;评论区写出你的答案！&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;不想错过就把我们&lt;/span&gt;&lt;strong&gt;设为星标&lt;/strong&gt;&lt;span&gt;吧！&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;第一步：点击顶部蓝字&lt;strong&gt;“自动化软件测试”&lt;/strong&gt;，进入公众号主页&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;第二步：点击右上角&lt;strong&gt;“···”&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三步：点击&lt;span&gt;&lt;strong&gt;“设为星标”&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-ratio=&quot;0.5868544600938967&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/p1ibuRQ0oDlgLsOcVfbG5N0ENSxh9yF24bONLDoVRCPpXNhVGWOfPeMqGEtichqytMApoevdrIAvebh3iaXD7l76A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;639&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; “在看”点一点 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;好景只有片刻🌸😊&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;strong&gt;&lt;span&gt;👇&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;👇&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;👇 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;↓做个稳定性测试，手指头都要肿了...&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5613e54557d5f3499b2e88c4c8510b26</guid>
<title>Conda 简明使用指南</title>
<link>https://toutiao.io/k/6a0hddg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content post__content clearfix&quot;&gt;
&lt;p&gt;conda 是一款包和环境管理工具。它可以适用于多种语言，比如python、R、Scala等。我们以python为例来看看conda的使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;包&lt;/strong&gt;就是我们在最开始&lt;code&gt;import xxx&lt;/code&gt;进来的东西，比如说&lt;code&gt;import torch&lt;/code&gt;、&lt;code&gt;import matplotlib&lt;/code&gt;等。在我们下载完python之后，这些包都不是自带的，需要我们去下载并使用。conda就可以理解为这些包下载的平台。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;环境管理&lt;/strong&gt;是什么呢？我们去github上下载代码，一般都会在&lt;code&gt;README.md&lt;/code&gt;中给出环境安装的指引。不同代码适配的环境是不一样的。比如一份代码用python2.7，另一份用python3.6；一份用pytorch1.3，另一份用pytorch0.3。如果每次运行之前都重新装一次环境简直太麻烦了。所以可以用到环境管理，来为不同的代码创造不同的环境。&lt;/p&gt;
&lt;h3 id=&quot;基本命令&quot;&gt;基本命令&lt;/h3&gt;
&lt;h4 id=&quot;1创建环境&quot;&gt;1）创建环境&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span&gt;# 创建一个名为 my_env_name 的环境，用python 3.7 版本&lt;/span&gt;
conda create -n my_env_name python3.7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;等待一段时间，创建完成之后会有激活环境的提示。&lt;/p&gt;
&lt;h4 id=&quot;2激活环境&quot;&gt;2）激活环境&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span&gt;# 激活 my_env_name 环境&lt;/span&gt;
conda activate my_env_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&quot;3列出所有环境&quot;&gt;3）列出所有环境&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/img/conda_p1.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;4退出激活环境&quot;&gt;4）退出激活环境&lt;/h4&gt;
&lt;h3 id=&quot;环境分享&quot;&gt;环境分享&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如果我们两个环境，只有个别包是版本不同的，其他基础包都是相同的。我们可以考虑从之前的环境克隆包，然后重新安装的新的版本。&lt;/li&gt;
&lt;li&gt;在某个环境上安装了不少东西，想它这个环境的基本信息存下来并分享，便可以导出为&lt;code&gt;yml&lt;/code&gt;文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span&gt;# 导出为 my_env_name.yml 文件&lt;/span&gt;
conda env export &amp;gt; my_env_name.yml
&lt;span&gt;# 使用 yml 导入创建的环境&lt;/span&gt;
conda env create -n new_env -f my_env_name.yml
&lt;span&gt;# 克隆新的环境&lt;/span&gt;
conda create -n new_env_2 --clone env_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查看&lt;code&gt;my_env_name.yml&lt;/code&gt;：这里包括环境的名称，找包的渠道&lt;code&gt;channel&lt;/code&gt;和已经安装的包。
&lt;img src=&quot;/img/conda_p2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装包&quot;&gt;安装包&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span&gt;# 列出所有包&lt;/span&gt;
conda list
&lt;span&gt;# 安装包&lt;/span&gt;
conda install pkg_name
&lt;span&gt;# 从指定 channel 下载&lt;/span&gt;
conda install --channel https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ pytorch
&lt;span&gt;# 用 -c 代替 --channel&lt;/span&gt;
conda install -c pytorch pytorch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果安装时发生了：在channel中找不到包的错误，可以去官网 &lt;a href=&quot;https://anaconda.org/&quot;&gt;anaconda.org&lt;/a&gt; 搜索包名，会给出下载的指令。&lt;/p&gt;
&lt;h3 id=&quot;conda-配置&quot;&gt;conda 配置&lt;/h3&gt;
&lt;p&gt;Mac 在 &lt;code&gt;~/.condarc&lt;/code&gt;下可以配置下载的源，换成国内的速度会很快。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dereen/p/anaconda_tencent_mirrors.html&quot;&gt;国内可用Anaconda 源的镜像站及换国内源方法&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b81328e68890e0dba7a33f90a2156e96</guid>
<title>学会这 10 种定时任务，我有点飘了</title>
<link>https://toutiao.io/k/811or1j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxODkzNTQ3Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uL371281oDFEpxenPicr7Kh8c9P0I97yVWw9JfljjPy5gVBLDiaIrWkzAGHGib09Kib4TQtyw8jpLicW3yoyibMY8yMA/0?wx_fmt=png&quot; data-nickname=&quot;苏三说技术&quot; data-alias=&quot;&quot; data-signature=&quot;「苏三说技术」 维护者目前就职于某知名互联网公司，从事开发、架构和部分管理工作。实战经验丰富，对jdk、spring、springboot、springcloud、mybatis等开源框架源码有一定研究，欢迎关注，和我一起交流。&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家好我是苏三，又跟大家见面了。&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近有几个读者私信给我，问我他们的业务场景，要用什么样的定时任务。确实，在不用的业务场景下要用不同的定时任务，其实我们的选择还是挺多的。我今天给大家总结10种非常实用的定时任务，总有一种是适合你的。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一. linux自带的定时任务&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;crontab&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你有没有遇到过这种场景：有时需要临时统计线上的数据，然后导出到excel表格中。这种需求有时较为复杂，光靠写sql语句是无法满足需求的，这就需要写java代码了。然后将该程序打成一个jar包，在线上环境执行，最后将生成的excel文件下载到本地。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了减小对线上环境的影响，我们一般会选择在&lt;code&gt;凌晨1-2点&lt;/code&gt;，趁用户量少的时候，执行统计程序。（其实凌晨4点左右，用户才是最少的）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于时间太晚了，我们完全没必要守在那里等执行结果，一个定时任务就能可以搞定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这种情况用哪种定时任务更合适呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是：&lt;code&gt;linux&lt;/code&gt;系统的&lt;code&gt;crontab&lt;/code&gt;。（不过也不排除有些项目没部署在linux系统中）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行&lt;code&gt;crontab -e&lt;/code&gt;，可以编辑定时器，然后加入如下命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; * * * /usr/local/java/jdk1&lt;span&gt;.8&lt;/span&gt;/bin/java -jar /data/app/tool.jar &amp;gt; /logs/tool.log &amp;amp;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就可以在&lt;code&gt;每天凌晨2点&lt;/code&gt;，定时执行&lt;code&gt;tool.jar&lt;/code&gt;程序，并且把日志输出到&lt;code&gt;tool.log&lt;/code&gt;文件中。当然你也可以把后面的执行java程序的命令写成shell脚本，更方便维护。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用这种定时任务支持方便修改定时规则，有界面可以统一管理配置的各种定时脚本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;crontab命令的基本格式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;crontab [参数] [文件名]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有指定文件名，则接收键盘上输入的命令，并将它载入到&lt;code&gt;crontab&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参数功能对照表如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;&lt;th&gt;功能&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;-u&lt;/td&gt;&lt;td&gt;指定用户&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-e&lt;/td&gt;&lt;td&gt;编辑某个用户的crontab文件内容&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-l&lt;/td&gt;&lt;td&gt;显示某个用户的crontab文件内容&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-r&lt;/td&gt;&lt;td&gt;删除某用户的crontab文件&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-i&lt;/td&gt;&lt;td&gt;删除某用户的crontab文件时需确认&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上参数，如果没有使用&lt;code&gt;-u&lt;/code&gt;指定用户，则默认使用的当前用户。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;code&gt;crontab -e&lt;/code&gt;命令编辑文件内容，具体语法如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[分] [小时] [日期] [月] [星期] 具体任务&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;分，表示多少分钟，范围：0-59&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;小时，表示多少小时，范围：0-23&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;日期，表示具体在哪一天，范围：1-31&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;月，表示多少月，范围：1-12&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;星期，表示多少周，范围：0-7，0和7都代表星期日&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一些特殊字符，比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;*&lt;/code&gt;代表如何时间，比如：&lt;code&gt;*1***&lt;/code&gt; 表示每天凌晨1点执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;/&lt;/code&gt;代表每隔多久执行一次，比如：&lt;code&gt;*/5 ****&lt;/code&gt; 表示每隔5分钟执行一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;,&lt;/code&gt;代表支持多个，比如：&lt;code&gt;10 7,9,12 ***&lt;/code&gt; 表示在每天的7、9、12点10分各执行一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-&lt;/code&gt;代表支持一个范围，比如：&lt;code&gt;10 7-9 ***&lt;/code&gt; 表示在每天的7、8、9点10分各执行一次。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，顺便说一下&lt;code&gt;crontab&lt;/code&gt;需要&lt;code&gt;crond&lt;/code&gt;服务支持，&lt;code&gt;crond&lt;/code&gt;是&lt;code&gt;linux&lt;/code&gt;下用来周期地执行某种任务的一个守护进程，在安装&lt;code&gt;linux&lt;/code&gt;操作系统后，默认会安装&lt;code&gt;crond&lt;/code&gt;服务工具，且&lt;code&gt;crond&lt;/code&gt;服务默认就是自启动的。&lt;code&gt;crond&lt;/code&gt;进程每分钟会定期检查是否有要执行的任务，如果有，则会自动执行该任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过以下命令操作相关服务：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;service crond status // 查看运行状态&lt;br/&gt;service crond start //启动服务&lt;br/&gt;service crond stop //关闭服务&lt;br/&gt;service crond restart //重启服务&lt;br/&gt;service crond reload //重新载入配置&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;使用&lt;code&gt;crontab&lt;/code&gt;的优缺点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;优点：方便修改定时规则，支持一些较复杂的定时规则，通过文件可以统一管理配好的各种定时脚本。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缺点：如果定时任务非常多，不太好找，而且必须要求操作系统是&lt;code&gt;linux&lt;/code&gt;，否则无法执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二. jdk自带的定时任务&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.Thread&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;各位亲爱的朋友，你没看错，&lt;code&gt;Thread&lt;/code&gt;类真的能做定时任务。如果你看过一些定时任务框架的源码，你最后会发现，它们的底层也会使用&lt;code&gt;Thread&lt;/code&gt;类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现这种定时任务的具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public static void init() {&lt;br/&gt;    new Thread(() -&amp;gt; {&lt;br/&gt;        while (true) {&lt;br/&gt;            try {&lt;br/&gt;                System.out.println(&quot;doSameThing&quot;);&lt;br/&gt;                Thread.sleep(1000 * 60 * 5);&lt;br/&gt;            } catch (Exception e) {&lt;br/&gt;                log.error(e);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }).start();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;Thread&lt;/code&gt;类可以做最简单的定时任务，在&lt;code&gt;run&lt;/code&gt;方法中有个&lt;code&gt;while&lt;/code&gt;的死循环（当然还有其他方式），执行我们自己的任务。有个需要特别注意的地方是，需要用&lt;code&gt;try...catch&lt;/code&gt;捕获异常，否则如果出现异常，就直接退出循环，下次将无法继续执行了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式做的定时任务，只能周期性执行，不能支持定时在某个时间点执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，该线程可以定义成&lt;code&gt;守护线程&lt;/code&gt;，在后台默默执行就好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用场景：比如项目中有时需要每隔10分钟去下载某个文件，或者每隔5分钟去读取模板文件生成静态html页面等等，一些简单的周期性任务场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;使用&lt;code&gt;Thread&lt;/code&gt;类的优缺点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;优点：这种定时任务非常简单，学习成本低，容易入手，对于那些简单的周期性任务，是个不错的选择。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缺点：不支持指定某个时间点执行任务，不支持延迟执行等操作，功能过于单一，无法应对一些较为复杂的场景。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.Timer&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Timer&lt;/code&gt;类是jdk专门提供的定时器工具，用来在后台线程计划执行指定任务，在&lt;code&gt;java.util&lt;/code&gt;包下，要跟&lt;code&gt;TimerTask&lt;/code&gt;一起配合使用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2367688022284122&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEibBqV1AmuPWCFiaVOy2NR43icQZouExqiaic4Y9NZXa2CzCiaglfFia1BcORbV1Sqy7n8Vzaf53X3DBz8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;718&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Timer&lt;/code&gt;类其实是一个任务调度器，它里面包含了一个&lt;code&gt;TimerThread&lt;/code&gt;线程，在这个线程中无限循环从&lt;code&gt;TaskQueue&lt;/code&gt;中获取&lt;code&gt;TimerTask&lt;/code&gt;（该类实现了Runnable接口），调用其&lt;code&gt;run&lt;/code&gt;方法，就能异步执行定时任务。我们需要继承&lt;code&gt;TimerTask&lt;/code&gt;类，实现它的&lt;code&gt;run&lt;/code&gt;方法，在该方法中加上自己的业务逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现这种定时任务的具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TimerTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Timer timer = &lt;span&gt;new&lt;/span&gt; Timer();&lt;br/&gt;        timer.schedule(&lt;span&gt;new&lt;/span&gt; TimerTask() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;doSomething&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        },&lt;span&gt;2000&lt;/span&gt;,&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先实例化一个&lt;code&gt;Timer&lt;/code&gt;类，然后调用它的&lt;code&gt;schedule&lt;/code&gt;方法，在该方法中实例化&lt;code&gt;TimerTask&lt;/code&gt;类，业务逻辑写在&lt;code&gt;run&lt;/code&gt;方法中。&lt;code&gt;schedule&lt;/code&gt;方法最后的两次参数分别表示：&lt;code&gt;延迟时间&lt;/code&gt; 和 &lt;code&gt;间隔时间&lt;/code&gt;，单位是毫秒。上面例子中，设置的定时任务是每隔1秒执行一次，延迟2秒执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要包含6个方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;schedule(TimerTask task, Date time)&lt;/code&gt;, 指定任务task在指定时间time执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;schedule(TimerTask task, long delay)&lt;/code&gt;, 指定任务task在指定延迟delay后执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;schedule(TimerTask task, Date firstTime,long period)&lt;/code&gt;,指定任务task在指定时间firstTime执行后，进行重复固定延迟频率peroid的执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;schedule(TimerTask task, long delay, long period)&lt;/code&gt;, 指定任务task 在指定延迟delay 后，进行重复固定延迟频率peroid的执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;scheduleAtFixedRate(TimerTask task,Date firstTime,long period)&lt;/code&gt;, 指定任务task在指定时间firstTime执行后，进行重复固定延迟频率peroid的执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;scheduleAtFixedRate(TimerTask task, long delay, long period)&lt;/code&gt;, 指定任务task 在指定延迟delay 后，进行重复固定延迟频率peroid的执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;不过使用&lt;code&gt;Timer&lt;/code&gt;实现定时任务有以下问题：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由于&lt;code&gt;Timer&lt;/code&gt;是单线程执行任务，如果其中一个任务耗时非常长，会影响其他任务的执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果&lt;code&gt;TimerTask&lt;/code&gt;抛出&lt;code&gt;RuntimeException&lt;/code&gt;，Timer会停止所有任务的运行。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;使用&lt;code&gt;Timer&lt;/code&gt;类的优缺点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;优点：非常方便实现多个周期性的定时任务，并且支持延迟执行，还支持在指定时间之后支持，功能还算强大。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缺点：如果其中一个任务耗时非常长，会影响其他任务的执行。并且如果&lt;code&gt;TimerTask&lt;/code&gt;抛出&lt;code&gt;RuntimeException&lt;/code&gt;，&lt;code&gt;Timer&lt;/code&gt;会停止所有任务的运行，所以阿里巴巴开发者规范中不建议使用它。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.ScheduledExecutorService&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ScheduledExecutorService&lt;/code&gt;是JDK1.5+版本引进的定时任务，该类位于&lt;code&gt;java.util.concurrent&lt;/code&gt;并发包下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ScheduledExecutorService&lt;/code&gt;是基于多线程的，设计的初衷是为了解决&lt;code&gt;Timer&lt;/code&gt;单线程执行，多个任务之间会互相影响的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它主要包含4个方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;schedule(Runnable command,long delay,TimeUnit unit)&lt;/code&gt;，带延迟时间的调度，只执行一次，调度之后可通过Future.get()阻塞直至任务执行完毕。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;schedule(Callable&amp;lt;V&amp;gt; callable,long delay,TimeUnit unit)&lt;/code&gt;，带延迟时间的调度，只执行一次，调度之后可通过Future.get()阻塞直至任务执行完毕，并且可以获取执行结果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;scheduleAtFixedRate&lt;/code&gt;，表示以固定频率执行的任务，如果当前任务耗时较多，超过定时周期period，则当前任务结束后会立即执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;scheduleWithFixedDelay&lt;/code&gt;，表示以固定延时执行任务，延时是相对当前任务结束为起点计算开始时间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现这种定时任务的具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ScheduleExecutorTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;        scheduledExecutorService.scheduleAtFixedRate(() -&amp;gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;doSomething&quot;&lt;/span&gt;);&lt;br/&gt;        },&lt;span&gt;1000&lt;/span&gt;,&lt;span&gt;1000&lt;/span&gt;, TimeUnit.MILLISECONDS);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用&lt;code&gt;ScheduledExecutorService&lt;/code&gt;类的&lt;code&gt;scheduleAtFixedRate&lt;/code&gt;方法实现周期性任务，每隔1秒钟执行一次，每次延迟1秒再执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种定时任务是阿里巴巴开发者规范中用来替代&lt;code&gt;Timer&lt;/code&gt;类的方案，对于多线程执行周期性任务，是个不错的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ScheduledExecutorService的优缺点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;优点：基于多线程的定时任务，多个任务之间不会相关影响，支持周期性的执行任务，并且带延迟功能。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缺点：不支持一些较复杂的定时规则。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三. spring支持的定时任务&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.spring task&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;spring task&lt;/code&gt;是&lt;code&gt;spring3&lt;/code&gt;以上版本自带的定时任务，实现定时任务的功能时，需要引入&lt;code&gt;spring-context&lt;/code&gt;包，目前它支持：&lt;code&gt;xml&lt;/code&gt; 和 &lt;code&gt;注解&lt;/code&gt; 两种方式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1. 项目实战&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于xml方式太古老了，我们以springboot项目中注解方式为例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第一步&lt;/strong&gt;，在pom.xml文件中引入&lt;code&gt;spring-context&lt;/code&gt;相关依赖。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第二步&lt;/strong&gt;，在springboot启动类上加上&lt;code&gt;@EnableScheduling&lt;/code&gt;注解。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@EnableScheduling&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@SpringBootApplication&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Application&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; SpringApplicationBuilder(Application&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;).&lt;span&gt;web&lt;/span&gt;(&lt;span&gt;WebApplicationType&lt;/span&gt;.&lt;span&gt;SERVLET&lt;/span&gt;).&lt;span&gt;run&lt;/span&gt;(&lt;span&gt;args&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第三步&lt;/strong&gt;，使用&lt;code&gt;@Scheduled&lt;/code&gt;注解定义定时规则。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SpringTaskTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Scheduled&lt;/span&gt;(cron = &lt;span&gt;&quot;${sue.spring.task.cron}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fun&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;doSomething&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第四步&lt;/strong&gt;，在&lt;code&gt;applicationContext.properties&lt;/code&gt;文件中配置参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sue.spring.task.cron=*/&lt;span&gt;10&lt;/span&gt; * * * * ?&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就能每隔10秒执行一次fun方法了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2. cron规则&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring4以上的版本中，cron表达式包含6个参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[秒] [分] [时] [日期] [月] [星期]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;还支持几个常用的特殊符号：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;*&lt;/code&gt;：表示任何时间触发任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;,&lt;/code&gt;：表示指定的时间触发任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-&lt;/code&gt;：表示一段时间内触发任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;/&lt;/code&gt;：表示从哪一个时刻开始，每隔多长时间触发一次任务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;?&lt;/code&gt;：表示用于月中的天和周中的天两个子表达式，表示不指定值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;cron表达式参数具体含义：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;秒，取值范围：0-59，支持&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;,&lt;/code&gt;、&lt;code&gt;-&lt;/code&gt;、&lt;code&gt;/&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分，取值范围：0-59，支持&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;,&lt;/code&gt;、&lt;code&gt;-&lt;/code&gt;、&lt;code&gt;/&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;时，取值范围：0-23，支持&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;,&lt;/code&gt;、&lt;code&gt;-&lt;/code&gt;、&lt;code&gt;/&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;日期，取值范围：1-31，支持&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;,&lt;/code&gt;、&lt;code&gt;-&lt;/code&gt;、&lt;code&gt;/&lt;/code&gt;。比秒多了&lt;code&gt;?&lt;/code&gt;，表示如果指定的&lt;code&gt;星期&lt;/code&gt;触发了，则配置的&lt;code&gt;日期&lt;/code&gt;变成无效。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;月，取值范围：1-12，支持&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;,&lt;/code&gt;、&lt;code&gt;-&lt;/code&gt;、&lt;code&gt;/&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;星期，取值范围：1~7，1代表星期天，6代表星期六，其他的以此类推。支持&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;,&lt;/code&gt;、&lt;code&gt;-&lt;/code&gt;、&lt;code&gt;/&lt;/code&gt;、&lt;code&gt;?&lt;/code&gt;。比秒多了&lt;code&gt;?&lt;/code&gt;，表示如果指定的&lt;code&gt;日期&lt;/code&gt;触发了，则配置的&lt;code&gt;星期&lt;/code&gt;变成无效。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;常见cron表达式使用举例：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;0 0 0 1 * ?&lt;/code&gt;  每月1号零点执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;0 0 2 * * ?&lt;/code&gt;  每天凌晨2点执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;0 0 2 * * ?&lt;/code&gt;  每天凌晨2点执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;0 0/5 11 * * ?&lt;/code&gt; 每天11点-11点55分，每隔5分钟执行一次&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;0 0 18 ? * WED&lt;/code&gt; 每周三下午6点执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring task先通过ScheduledAnnotationBeanPostProcessor类的processScheduled方法，解析和收集&lt;code&gt;Scheduled&lt;/code&gt;注解中的参数，包含：cron表达式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在ScheduledTaskRegistrar类的afterPropertiesSet方法中，默认初始化一个单线程的&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;执行任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对spring task感兴趣的小伙伴，可以加我微信找我私聊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;使用&lt;code&gt;spring task&lt;/code&gt;的优缺点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;优点：spring框架自带的定时功能，springboot做了非常好的封装，开启和定义定时任务非常容易，支持复杂的&lt;code&gt;cron&lt;/code&gt;表达式，可以满足绝大多数单机版的业务场景。单个任务时，当前次的调度完成后，再执行下一次任务调度。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缺点：默认单线程，如果前面的任务执行时间太长，对后面任务的执行有影响。不支持集群方式部署，不能做数据存储型定时任务。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.spring quartz&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;quartz&lt;/code&gt;是&lt;code&gt;OpenSymphony&lt;/code&gt;开源组织在&lt;code&gt;Job scheduling&lt;/code&gt;领域的开源项目，是由java开发的一个开源的任务日程管理系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;quartz能做什么？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;作业调度：调用各种框架的作业脚本，例如shell,hive等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;定时任务：在某一预定的时刻，执行你想要执行的任务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0945945945945945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEibBqV1AmuPWCFiaVOy2NR43JqicWsG6b8b1l5BzT2CDbxKR2tVgegE8mOM7xRJ3zKM7a36d9NX8tgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;740&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;quartz包含的主要接口如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Scheduler&lt;/code&gt; 代表调度容器，一个调度容器中可以注册多个JobDetail和Trigger。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Job&lt;/code&gt; 代表工作，即要执行的具体内容。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;JobDetail&lt;/code&gt; 代表具体的可执行的调度程序，Job是这个可执行程调度程序所要执行的内容。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;JobBuilder&lt;/code&gt; 用于定义或构建JobDetail实例。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Trigger&lt;/code&gt; 代表调度触发器，决定什么时候去调。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;TriggerBuilder&lt;/code&gt; 用于定义或构建触发器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;JobStore&lt;/code&gt; 用于存储作业和任务调度期间的状态。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1. 项目实战&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是以&lt;code&gt;springboot&lt;/code&gt;集成&lt;code&gt;quartz&lt;/code&gt;为例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第一步&lt;/strong&gt;，在pom.xml文件中引入&lt;code&gt;quartz&lt;/code&gt;相关依赖。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;spring-boot-starter-quartz&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第二步&lt;/strong&gt;，创建真正的定时任务执行类，该类继承&lt;code&gt;QuartzJobBean&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;QuartzTestJob&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;QuartzJobBean&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;executeInternal&lt;/span&gt;&lt;span&gt;(JobExecutionContext context)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; JobExecutionException &lt;/span&gt;{&lt;br/&gt;        String userName = (String) context.getJobDetail().getJobDataMap().get(&lt;span&gt;&quot;userName&quot;&lt;/span&gt;);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;userName:&quot;&lt;/span&gt; + userName);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第三步&lt;/strong&gt;，创建调度程序&lt;code&gt;JobDetail&lt;/code&gt;和调度器&lt;code&gt;Trigger&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;QuartzConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${sue.spring.quartz.cron}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String testCron;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 创建定时任务&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; JobDetail &lt;span&gt;quartzTestDetail&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        JobDetail jobDetail = JobBuilder.newJob(QuartzTestJob&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;                .&lt;span&gt;withIdentity&lt;/span&gt;(&quot;&lt;span&gt;quartzTestDetail&lt;/span&gt;&quot;, &quot;&lt;span&gt;QUARTZ_TEST&lt;/span&gt;&quot;)&lt;br/&gt;                .&lt;span&gt;usingJobData&lt;/span&gt;(&quot;&lt;span&gt;userName&lt;/span&gt;&quot;, &quot;&lt;span&gt;susan&lt;/span&gt;&quot;)&lt;br/&gt;                .&lt;span&gt;storeDurably&lt;/span&gt;()&lt;br/&gt;                .&lt;span&gt;build&lt;/span&gt;()&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; jobDetail;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 创建触发器&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Trigger &lt;span&gt;quartzTestJobTrigger&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//每隔5秒执行一次&lt;/span&gt;&lt;br/&gt;        CronScheduleBuilder cronScheduleBuilder = CronScheduleBuilder.cronSchedule(testCron);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//创建触发器&lt;/span&gt;&lt;br/&gt;        Trigger trigger = TriggerBuilder.newTrigger()&lt;br/&gt;                .forJob(quartzTestDetail())&lt;br/&gt;                .withIdentity(&lt;span&gt;&quot;quartzTestJobTrigger&quot;&lt;/span&gt;, &lt;span&gt;&quot;QUARTZ_TEST_JOB_TRIGGER&quot;&lt;/span&gt;)&lt;br/&gt;                .withSchedule(cronScheduleBuilder)&lt;br/&gt;                .build();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; trigger;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第四步&lt;/strong&gt;，在&lt;code&gt;applicationContext.properties&lt;/code&gt;文件中配置参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sue.spring.quartz.cron=*/&lt;span&gt;5&lt;/span&gt; * * * * ?&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就能每隔5秒执行一次QuartzTestJob类的executeInternal方法了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CronTrigger配置格式:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[秒] [分] [小时] [日] [月] [周] [年]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;spring quartz&lt;/code&gt;跟&lt;code&gt;spring task&lt;/code&gt;的&lt;code&gt;cron&lt;/code&gt;表达式规则基本一致，只是&lt;code&gt;spring4&lt;/code&gt;以上的版本去掉了后面的&lt;code&gt;年&lt;/code&gt;，而&lt;code&gt;quartz&lt;/code&gt;的&lt;code&gt;CronTrigger&lt;/code&gt;的&lt;code&gt;年&lt;/code&gt;是非必填的，这里我就不做过多介绍了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;使用&lt;code&gt;spring quartz&lt;/code&gt;的优缺点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;优点：默认是多线程异步执行，单个任务时，在上一个调度未完成时，下一个调度时间到时，会另起一个线程开始新的调度，多个任务之间互不影响。支持复杂的&lt;code&gt;cron&lt;/code&gt;表达式，它能被集群实例化，支持分布式部署。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缺点：相对于spring task实现定时任务成本更高，需要手动配置&lt;code&gt;QuartzJobBean&lt;/code&gt;、&lt;code&gt;JobDetail&lt;/code&gt;和&lt;code&gt;Trigger&lt;/code&gt;等。需要引入了第三方的&lt;code&gt;quartz&lt;/code&gt;包，有一定的学习成本。不支持并行调度，不支持失败处理策略和动态分片的策略等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四. 分布式定时任务&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.xxl-job&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;xxl-job&lt;/code&gt;是大众点评（许雪里）开发的一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;xxl-job&lt;/code&gt;框架对&lt;code&gt;quartz&lt;/code&gt;进行了扩展，使用&lt;code&gt;mysql&lt;/code&gt;数据库存储数据，并且内置jetty作为&lt;code&gt;RPC&lt;/code&gt;服务调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要特点如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;有界面维护定时任务和触发规则，非常容易管理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;能动态启动或停止任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持弹性扩容缩容&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持任务失败报警&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持动态分片&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持故障转移&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Rolling实时日志&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持用户和权限管理&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;管理界面：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEibBqV1AmuPWCFiaVOy2NR43RZdBebIkud6W5GhARrv5iczeIXwPzzlY47Re0pxVasKic29HATzZBy9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.475&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体架构图如下：&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEibBqV1AmuPWCFiaVOy2NR43XNjcEemSHicOC9iaibR6KRl6OYveMAg2KqlOAvN9RudobUnKtwgias8JnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.47129629629629627&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用quartz架构图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9504310344827587&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEibBqV1AmuPWCFiaVOy2NR43CmmicesvUQgCf7E6vIrczySz2rKQ6oJfI76hoYjayxA4gWCNjqTuYSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;928&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;项目实战&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;xxl-admin&lt;/code&gt;管理后台部署和mysql脚本执行等这些前期准备工作，我就不过多介绍了，有需求的朋友可以找我私聊，这些更偏向于运维的事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设前期工作已经OK了，接下来我们需要：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第一步&lt;/strong&gt;，在pom.xml文件中引入&lt;code&gt;xxl-job&lt;/code&gt;相关依赖。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;   &amp;lt;groupId&amp;gt;com.xuxueli&amp;lt;/groupId&amp;gt;&lt;br/&gt;   &amp;lt;artifactId&amp;gt;xxl-job-core&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第二步&lt;/strong&gt;，在&lt;code&gt;applicationContext.properties&lt;/code&gt;文件中配置参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;xxl.job.admin.address: http:&lt;span&gt;//localhost:8088/xxl-job-admin/&lt;/span&gt;&lt;br/&gt;xxl.job.executor.appname: xxl-job-executor-sample&lt;br/&gt;xxl.job.executor.port: &lt;span&gt;8888&lt;/span&gt;&lt;br/&gt;xxl.job.executor.logpath: /data/applogs/xxl-job/&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第三步&lt;/strong&gt;，创建HelloJobHandler类继承&lt;code&gt;IJobHandler&lt;/code&gt;类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@JobHandler(value = &lt;span&gt;&quot;helloJobHandler&quot;&lt;/span&gt;)&lt;br/&gt;@Component&lt;br/&gt;public class HelloJobHandler extends IJobHandler {&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public ReturnT&amp;lt;String&amp;gt; execute(String param) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;XXL-JOB, Hello World.&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; SUCCESS;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样定时任务就配置好了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;建议把定时任务单独部署到另外一个服务中，跟api服务分开。根据我以往的经验，job大部分情况下，会对数据做批量操作，如果操作的数据量太大，可能会对服务的内存和cpu资源造成一定的影响。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;使用&lt;code&gt;xxl-job&lt;/code&gt;的优缺点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;优点：有界面管理定时任务，支持弹性扩容缩容、动态分片、故障转移、失败报警等功能。它的功能非常强大，很多大厂在用，可以满足绝大多数业务场景。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缺点：和&lt;code&gt;quartz&lt;/code&gt;一样，通过数据库分布式锁，来控制任务不能重复执行。在任务非常多的情况下，有一些性能问题。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.elastic-job&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;elastic-job&lt;/code&gt;是当当网开发的弹性分布式任务调度系统，功能丰富强大，采用zookeeper实现分布式协调，实现任务高可用以及分片。它是专门为高并发和复杂业务场景开发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;elastic-job&lt;/code&gt;目前是&lt;code&gt;apache&lt;/code&gt;的&lt;code&gt;shardingsphere&lt;/code&gt;项目下的一个子项目，官网地址：http://shardingsphere.apache.org/elasticjob/。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;elastic-job&lt;/code&gt;在2.x之后，出了两个产品线：&lt;code&gt;Elastic-Job-Lite&lt;/code&gt;和&lt;code&gt;Elastic-Job-Cloud&lt;/code&gt;，而我们一般使用Elastic-Job-Lite就能够满足需求。Elastic-Job-Lite定位为轻量级无中心化解决方案，使用jar包的形式提供分布式任务的协调服务，外部仅依赖于Zookeeper。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要特点如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;分布式调度协调&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;弹性扩容缩容&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;失效转移&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;错过执行作业重触发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;作业分片一致性，保证同一分片在分布式环境中仅一个执行实例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自诊断并修复分布式不稳定造成的问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持并行调度&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体架构图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5951134380453752&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEibBqV1AmuPWCFiaVOy2NR435OAniabNr7SLhgVJcAOK1zvqicapv9s8JwJ72onaz2U8YbVZicMldraqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1146&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;项目实战&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第一步&lt;/strong&gt;，在pom.xml文件中引入&lt;code&gt;elastic-job&lt;/code&gt;相关依赖。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;com.dangdang&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;elastic-job-lite-core&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;com.dangdang&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;elastic-job-lite-spring&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第二步&lt;/strong&gt;，增加ZKConfig类，配置&lt;code&gt;zookeeper&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@ConditionalOnExpression&lt;/span&gt;(&lt;span&gt;&quot;&#x27;${zk.serverList}&#x27;.length() &amp;gt; 0&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ZKConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ZookeeperRegistryCenter &lt;span&gt;registry&lt;/span&gt;&lt;span&gt;(@Value(&lt;span&gt;&quot;${zk.serverList}&quot;&lt;/span&gt;)&lt;/span&gt; String serverList,&lt;br/&gt;                                             @&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;${zk.namespace}&quot;&lt;/span&gt;)&lt;/span&gt; String namespace) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ZookeeperRegistryCenter(&lt;span&gt;new&lt;/span&gt; ZookeeperConfiguration(serverList, namespace));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第三步&lt;/strong&gt;，定义一个类实现&lt;code&gt;SimpleJob&lt;/code&gt;接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestJob&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;SimpleJob&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(ShardingContext shardingContext)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;ShardingTotalCount:&quot;&lt;/span&gt;+shardingContext.getShardingTotalCount());&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;ShardingItem:&quot;&lt;/span&gt;+shardingContext.getShardingItem());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第四步&lt;/strong&gt;，增加JobConfig配置任务：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JobConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${sue.spring.elatisc.cron}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String testCron;&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${sue.spring.elatisc.itemParameters}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt;  String shardingItemParameters;&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${sue.spring.elatisc.jobParameters}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String jobParameters =;&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${sue.spring.elatisc.shardingTotalCount}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; shardingTotalCount;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ZookeeperRegistryCenter registryCenter;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; SimpleJob &lt;span&gt;testJob&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TestJob();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; JobScheduler &lt;span&gt;simpleJobScheduler&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; SimpleJob simpleJob)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; SpringJobScheduler(simpleJob, registryCenter, getConfiguration(simpleJob.getClass(),&lt;br/&gt;                cron, shardingTotalCount, shardingItemParameters, jobParameters));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; geConfiguration &lt;span&gt;getConfiguration&lt;/span&gt;&lt;span&gt;(Class&amp;lt;? extends SimpleJob&amp;gt; jobClass,String cron,&lt;span&gt;int&lt;/span&gt; shardingTotalCount,String shardingItemParameters,String jobParameters)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        JobCoreConfiguration simpleCoreConfig = JobCoreConfiguration.newBuilder(jobClass.getName(), testCron, shardingTotalCount).&lt;br/&gt;                shardingItemParameters(shardingItemParameters).jobParameter(jobParameters).build();&lt;br/&gt;        SimpleJobConfiguration simpleJobConfig = &lt;span&gt;new&lt;/span&gt; SimpleJobConfiguration(simpleCoreConfig, jobClass.getCanonicalName());&lt;br/&gt;        LiteJobConfiguration jobConfig = LiteJobConfiguration.newBuilder(simpleJobConfig).overwrite(&lt;span&gt;true&lt;/span&gt;).build();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; jobConfig;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;cron：cron表达式，定义触发规则。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;shardingTotalCount：定义作业分片总数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;shardingItemParameters：定义分配项参数，一般用分片序列号和参数用等号分隔，多个键值对用逗号分隔，分片序列号从0开始，不可大于或等于作业分片总数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jobParameters：作业自定义参数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第五步&lt;/strong&gt;，在&lt;code&gt;applicationContext.properties&lt;/code&gt;文件中配置参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;spring.application.name=elasticjobDemo&lt;br/&gt;zk.serverList=localhost:&lt;span&gt;2181&lt;/span&gt;&lt;br/&gt;zk.namespace=elasticjobDemo&lt;br/&gt;sue.spring.elatisc.cron=&lt;span&gt;0&lt;/span&gt;/&lt;span&gt;5&lt;/span&gt; * * * * ?&lt;br/&gt;sue.spring.elatisc.itemParameters=&lt;span&gt;0&lt;/span&gt;=A,&lt;span&gt;1&lt;/span&gt;=B,&lt;span&gt;2&lt;/span&gt;=C,&lt;span&gt;3&lt;/span&gt;=D&lt;br/&gt;sue.spring.elatisc.jobParameters=test&lt;br/&gt;sue.spring.elatisc.shardingTotalCount=&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样定时任务就配置好了，创建定时任务的步骤，相对于&lt;code&gt;xxl-job&lt;/code&gt;来说要繁琐一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;使用&lt;code&gt;elastic-job&lt;/code&gt;的优缺点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;优点：支持分布式调度协调，支持分片，适合高并发，和一些业务相对来说较复杂的场景。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缺点：需要依赖于zookeeper，实现定时任务相对于&lt;code&gt;xxl-job&lt;/code&gt;要复杂一些，要对分片规则非常熟悉。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.其他分布式定时任务&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. Saturn&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;Saturn是唯品会开源的一个分布式任务调度平台。取代传统的Linux Cron/Spring Batch Job的方式，做到全域统一配置，统一监控，任务高可用以及分片并发处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Saturn是在当当开源的Elastic-Job基础上，结合各方需求和我们的实践见解改良而成。使用案例：唯品会、酷狗音乐、新网银行、海融易、航美在线、量富征信等。 &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;github地址：https://github.com/vipshop/Saturn/&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. TBSchedule&lt;/span&gt;&lt;/h3&gt;&lt;p&gt; TBSchedule是阿里开发的一款分布式任务调度平台，旨在将调度作业从业务系统中分离出来，降低或者是消除和业务系统的耦合度，进行高效异步任务处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目前被广泛应用在阿里巴巴、淘宝、支付宝、京东、聚美、汽车之家、国美等很多互联网企业的流程调度系统中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;github地址：https://github.com/taobao/TBSchedule&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;老实说优秀的定时任务还是挺多的，不是说哪种定时任务牛逼我们就&lt;span&gt;一定要&lt;/span&gt;用哪种，而是要根据实际业务需求选择。每种定时任务都有优缺点，合理选择既能满足业务需求，又能避免资源浪费，才是上上策。当然在实际的业务场景，通常会多种定时任务一起&lt;span&gt;配合&lt;/span&gt;使用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;顺便说一句，欢迎亲爱的小伙伴们，找我一起聊聊：你用过哪些定时任务，遇到过哪些问题，以及如何解决问题的。如果有相关问题也可以问我。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;希望我们能够共同进步，一起成长。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>