<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>34f5d544750e794f0bc96c53e8ed9983</guid>
<title>汤楚熙：美团实时数仓架构演进与建设实践</title>
<link>https://toutiao.io/k/ctkg4cp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-backh=&quot;156&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;561&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;156&quot; data-fileid=&quot;100072321&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPjicBGnN2Sv2xfMf0eh07fxe53FSEJr7ogaf9QJMSV0iboV8bKNibavEhvl3VqpqOQVXI1r4kwgIhLjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPjdrlkyhHH3BZDV05IvhuKOic0so28M9B0cD8Hqia6HMpWBZhzfsTqP48RHZwSfonCSA3OtgJoM212A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-bottom: -10px; margin-left: -8px; max-width: 100%; width: 18px; height: 18px; border-top: 8px solid rgb(54, 65, 173); border-left: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;/&gt;&lt;/section&gt;&lt;section data-bgopacity=&quot;50%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-style=&quot;max-width: 100%; width: 543.333px; background: rgb(247, 247, 247); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;分享嘉宾：汤楚熙 美团&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;编辑整理：李瑶 DataFun&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;出品平台：DataFunTalk&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;max-width: 100%; width: 18px; height: 18px; border-bottom: 8px solid rgb(54, 65, 173); border-right: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;导读：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;大家好，我叫汤楚熙，来自美团数据平台中心的计算平台团队，当前主要工作内容是实时数仓平台的研发。&lt;/span&gt;&lt;span&gt;今天和大家分享一下实时数据在美团的典型应用场景，实时数仓建设中的挑战和解决方案，包括一些关键的设计细节。主要介绍以下几方面内容：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;建设背景&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;首先，来介绍一下美团实时数据的典型应用场景以及建设过程遇到的一些问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;实时数据在美团的典型应用场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBYFqejv3H9cOFUiaYZMMtWHlQIFU2ZNicMOHo0Ir7xFmoHEvlZPE1t8icg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;美团作为本地生活领域的头部公司，在内部孵化了许多独立业务，可以看到有大家所熟悉的美团外卖、酒店、美团优选等，这些业务通过实时数据来支撑其内部各种各样的数据应用场景，比如BI、算法、骑手调度等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBUZBnjRrm4hw0O5g2e6zS26FpavVq3eMN4N0Zu10MTTiaw18TIQl2C3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们对业务场景做了一个简单的分类：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;指标监控：比如有实时大盘，用来即时反馈业务当日运转的健康度等场景；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;实时特征：比如搜索、广告CTR预估、骑手调度等，对算法特征数据新鲜度要求较高的场景；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;事件处理：比如一些风控类、运营活动发券等事件驱动型场景；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据对账：比如&lt;/span&gt;&lt;span&gt;金融的支付业务，支付部门与业务部门各自独立，当业务部门的支付单据与支付部门不一致时，会造成资损，这时数据的实时对账就非常关键。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBltMbWY2ZMQeDxvVmvlkUbEBbmibAml51DKUby922H1AnDu1UU2Y32RA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图可以看到，截至目前，实时计算平台所支撑的实时数据处理场景的整体规模，&lt;/span&gt;&lt;span&gt;说明实时数据在美团已经影响到了业务的方方面面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQB0uzg3I8AelZ5NWuGWj9aphsyvuhaHIgLcnk6bXZibDJC4gPicLwcfyuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实时计算平台从成立以来，经历了上图中的几个关键发展阶段。&lt;/span&gt;&lt;span&gt;平台正式成立于2014年，我们引入Storm和Spark Streaming作为美团的第一代实时计算引擎，并且发布了第一版作业托管平台。接下来在2017年，平台正式引进了Flink，并开始初步探索以Flink SQL为主的实时数仓开发方式。并于2019年，正式将Flink SQL作为主要编程接口暴露给业务，将以任务为中心的开发模式，升级为以数据为中心的开发模式。当前，计算平台紧跟业界发展潮流，将工作内容都聚焦在数仓增量化生产、流批语义统一、统一实时离线数仓建模方式等几个方向上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 实时数仓建设过程中的问题及痛点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBGQLyjJ6tk2ItdkURNXZKD5wcZAQhjBxoVFhnN18Qcy6oHP8wFZQARA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在正式开始介绍数仓平台的建设实践之前，先来回顾下平台初期所遇到的问题。&lt;/span&gt;&lt;span&gt;实时数据开始建设之初，是没有离&lt;/span&gt;&lt;span&gt;线数仓那样成熟的建设方法论的，而且也没有离线数仓领域那样成熟的开发工具，所以带来了以下几点问题&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先就是高昂的开发运维成本，每次计算框架的升级，业务都需要学习一遍计算框架的API。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码本地开发，再去线上调试，本地的case难以覆盖线上的数据问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务各自的数据协议不统一，相互之间进行数据交换，沟通协作的成本也是比较高昂的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数仓的建设方式没有统一规范，导致数据的冗余和重复建设，给后期的资源治理带来了非常大的麻烦。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBvM4Pjq9dOW3mX6JKWKtEefZNS8GJ7EqUH5dulF3cZ0iaQZdhoAW2MFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上面的问题出发，我们制定了平台的建设路线。&lt;/span&gt;&lt;span&gt;主要集中在两个层面，&lt;/span&gt;&lt;span&gt;首先是降低业务的开发运维门槛，让实时数仓开发可以像离线数仓开发那样简单高效。&lt;/span&gt;&lt;span&gt;比如我们提供了标准的ETL作业模板，web集成开发环境，并且扩展了SQL的能力，使业务可以尽量以符合其认知的形式去进行代码开发。&lt;/span&gt;&lt;span&gt;还有数仓建设中业务最关心的数据质量问题，我们也提供了相应的配套工具，帮助业务以尽可能低的成本将可靠的数据交付应用方。&lt;/span&gt;&lt;span&gt;可用性在离线数仓建设过程中可能大多体现在数据是否按时就绪，那么实时数仓对数据的时延要求更高，所以可用性的保障也非常关键。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面提到的都是在开发运维效率方面我们所做的一些建设规划，在大数据领域，一个&lt;/span&gt;&lt;span&gt;底层算子性能的小小改进，都会使执行效率成倍的放大，所以我们也会花费一些精力在底层算子的优化上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;两横三纵，其中&lt;/span&gt;&lt;span&gt;两横包括&lt;/span&gt;&lt;span&gt;开发迭代效率，面向人的优化，重点在于对工作流。&lt;/span&gt;&lt;span&gt;三纵包括&lt;/span&gt;&lt;span&gt;能做（&lt;/span&gt;&lt;span&gt;看得见、摸得着的问题）、&lt;/span&gt;&lt;span&gt;做好和&lt;/span&gt;&lt;span&gt;最优化。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;平台架构设计&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;接下来开始着重介绍我们是如何解决上面所提到的问题的。&lt;/span&gt;&lt;span/&gt;&lt;span&gt;首先从整体上来介绍下平台解决上面问题的思路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQB98QiaZpChXWSFTYzbS2nRYAxb3sWicmzfxFnmsxJPXL7cEJ13kRdIibUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图是平台整体架构。&lt;/span&gt;&lt;span&gt;从下向上来看，存储、计&lt;/span&gt;&lt;span&gt;算、调度加上日志服务构成了我们的基础服务层。&lt;/span&gt;&lt;span&gt;基础服务层之上是平台对业务提供的一些中间件。&lt;/span&gt;&lt;span&gt;上层是平台抽象出的一些可自行组合的微服务集合，比如作业模板服务、&lt;/span&gt;&lt;span&gt;UDF&lt;/span&gt;&lt;span&gt;托管服务、元数据服务、指标采集监控、数据质量管理等，这些服务业务可以按自身的场景需要来在自己的业务内部自行组合，也可以直接使用平台包装好的大而全的集成开发平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQB4HY4vx39LcKJPn4eNW2DAdGw3bkicP69ve7H8xVnSs3wYNQcGaCYuwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图展示了平台基础服务中最关键的计算服务的选型过程。&lt;/span&gt;&lt;span&gt;实时数仓场景的最根本业务诉求是数据的时效性，这里的时效性通常指的是秒级的延迟，所以这里Flink和Storm胜出。&lt;/span&gt;&lt;span&gt;其次是数据的正确性，Flink是这里唯一能够保证Exectly-Once计算语义的框架，所以Flink要优于storm。&lt;/span&gt;&lt;span&gt;之后我们有做了benchmark测试，通过实验证明了，在绝大多数场景下Flink任务的吞吐要优于Storm，而且Flink还提供了更加成熟的SQL编程接口，&lt;/span&gt;&lt;span&gt;所以我们最终确认选择Flink作为实时数仓的核心计算框架。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBaWbN38PIibEQB6ubYWibEejXRlvYgXnm52IwRMXs6fyEdENhBIE4Nhpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解决了计算框架的问题，接下来我们要从上层概念入手，让熟悉离线数仓开发的同学能够更快的上手实时数仓的开发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从下向上看，我们先统一了离线和实时数仓的数据模型，无论是&lt;/span&gt;&lt;span&gt;HiveT&lt;/span&gt;&lt;span&gt;able&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;span&gt;Topic&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;span&gt;的一个域，在上层暴露给业务的都是一张&lt;/span&gt;&lt;span&gt;Table&lt;/span&gt;&lt;span&gt;，这样业务没有过多认知上的负担了，可以在不同开发场景的概念之间轻松切换。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上向下看，我们又统一了编程接口，使用SQL作为数仓开发的首选，这样实时和离线数仓的ETL逻辑甚至可以完全共用一套，对开发效率上也有显著的提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBgVSWYyNU8mM1d2LhfUIuZrlaccT4TLLngd9wOxn2r2DW1nicicdFcRvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有同学可能会问，实时和离线场景的计算语义不完全相同，实时计算场景需要包含大量跟时态相关的语法，比如window，interval等，离线场景上没有，那么怎么统一呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;的确如此，所以我们独立出一套SQL服务，短期用户也可以在SQL中加入HINT提升或者是直接提供一些参数，来告诉我们这是什么离线还是实时场景的ETL，未来我们会自动根据业务的输入、输出表的存储类型，ETL的模式，自动判断使用哪种类型的执行模式更有效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;跟社区如果对不齐怎么办：&lt;/span&gt;&lt;span&gt;先对内解问题，如果效果真的不错，可以推回社区，如果社区有更好的方案，我们可以判断是否能够&lt;/span&gt;&lt;span&gt;merge&lt;/span&gt;&lt;span&gt;进来，如果不行，说明我们的架构设计本身就是有问题的。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;平台建设实践&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 实时数仓开发解决方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBneF2W9VxhscZ6DEaWnny3PeCM8POTNvllHQ4DsiatwQjQR9ibPx586lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们对数仓平台的定位是：集需求准备、开发测试、发布和运维监控能力的一站式实时数仓生产解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面简单来介绍一下用户在平台上的工作流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在需求准备阶段，用户可以结合业务需求先来检索是否有满足需求的数据模&lt;/span&gt;&lt;span&gt;型，如果没有找到，那么可以选择从源头开始接入，或者新建模型。模型接入或创建好之后，进入&lt;/span&gt;&lt;span&gt;ETL&lt;/span&gt;&lt;span&gt;开发阶段，开发过程可能会伴随着一些简单的任务调试，这些工作也全部都可以在平台上完成。在开发完成准备上线之前，用户可以创建一条发布流水线，这块内容后面还有详细的介绍，待流水线执行通过后，就可以正式发布作业了，作业上线后，平台会自动收集作业的运行时指标，用来监控作业的运行状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBp5Mumbhu569BCsOKajL31De9oB7CLzib58sGzEV1mPOE2rqZ4yG7Inw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面介绍下，平台是如何规范业务的数仓接入流程的。&lt;/span&gt;&lt;span&gt;从上图（左）&lt;/span&gt;&lt;span&gt;大家可以看到，跟离线数仓的入仓流程相比，在没有数仓平台前，实时数仓的入参过程突出了一个乱字，而这样会带来如下问题：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数&lt;/span&gt;&lt;span&gt;据建设过程没有规范，后面接手的同学不知道从何入手。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接着上面的问题，如果后面同学按照自己的理解，重新接入一遍数据，长此以往，会造成大量的冗余数据，造成烟囱林立，资源浪费，后面还&lt;/span&gt;&lt;span&gt;需要花大量的时间治理。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数仓接入这个动作本身是没有过多业务逻辑的，是可以标准化和系统化的，这样重复机械的工作内容，会造成人力资源的浪费。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQB88KCrrpm37m535yQ9ZbicE1NMtvE8sNQYzxjJY3x4uvA47G6sfFwoQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;面对上述问题，数仓平台提供了一套完整的实时数仓接入方案。&lt;/span&gt;&lt;span&gt;明确的帮用户生成&lt;/span&gt;&lt;span&gt;ODS&lt;/span&gt;&lt;span&gt;层，这样同项目成员之间的合作，有了共同的规范和约束，不会再有因信息未对齐而造成的数据重复接入。&lt;/span&gt;&lt;span&gt;我们不光帮助用户规范了入仓的流程，还提供了一系列数据正确性、作业稳定性的保障机制，使业务同学可以将精力集中在数仓的建设上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBvIQ1OCelPys7JeKECarpg3YZcb1I47fB43V6nvUNlCNhaghCJNFfDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在规范化业务数仓接入流程的方案设计过程中，有个小小的挑战，那就是我们的数据源并不仅仅来自MySQL binlog和nginx日志，还有大量业务自行通过SDK上报的日志，这些日志的格式难以从整体上进行抽象，而且不同业务因为服务场景不同，数据的序列化方式也难以统一，所以我们抽象出一个Adapter模块，专门用来解决这个问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;P&lt;span&gt;arser&lt;/span&gt;&lt;span&gt;用来适配业务自定义消息格式，&lt;/span&gt;&lt;span&gt;Formatter&lt;/span&gt;&lt;span&gt;将用来监控作业稳定性和数据正确性的元数据信息融入到消息中，最后按照业务场景的实际诉求，允许业务根据自身场景定义序列化方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBiaBtOvNsHeZA481jLn7UzEsm5sJLNGcXJuhtFHKPNNPFAMHtYXT9e0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面介绍了平台在数据入仓阶段如何提升开发效率。&lt;/span&gt;&lt;span&gt;接下来介绍如何帮助业务更低门槛的进行实时数据的开发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;平台上线之初是基于&lt;/span&gt;&lt;span&gt;Flink1.&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;实现的模板任务，在当时来看，他们的能力并不成熟，一些在离线场景比如&lt;/span&gt;&lt;span&gt;SparkSQL&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;HiveSQL&lt;/span&gt;&lt;span&gt;都支持的语法，在&lt;/span&gt;&lt;span&gt;Flink&lt;/span&gt;&lt;span&gt;上支持的并不好。&lt;/span&gt;&lt;span&gt;所以我们决定先由平台自行根据业务需求对语法进行扩展。&lt;/span&gt;&lt;span&gt;比如t&lt;/span&gt;&lt;span&gt;able&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;UDF&lt;/span&gt;&lt;span&gt;的声明，还有insert into&lt;/span&gt;&lt;span&gt;等语法的支持。&lt;/span&gt;&lt;span&gt;当然这并不是全部。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBGsYT3LRI7PkSXdGoVsj4AeRa91oHTc0V8qpFbNBLuc90cwHEgbCLVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们不仅仅在&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;语法层面进行了改进，&lt;/span&gt;&lt;span&gt;还对作业模板进行了增强。像&lt;/span&gt;&lt;span&gt;watermark&lt;/span&gt;&lt;span&gt;提取对业务时间格式有一些要求，&lt;/span&gt;&lt;span&gt;这种业务场景强相关的逻辑并不适合直接写死在我们的模板程序代码中。&lt;/span&gt;&lt;span&gt;所以我们在作业模板中加入了几个切面，可以由业务自行上传代码来扩充这部分能力。&lt;/span&gt;&lt;span&gt;比如我们会在&lt;/span&gt;&lt;span&gt;Source&lt;/span&gt;&lt;span&gt;注册之后，提供一个切面，引入用户代码，进行日期格式转换，再执行&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;官方虽然已经提供了计算列，我们也调研了相关能力，但是我们认为除非有一个数量级的开发效率优化效果，否则我们没必要一定&lt;/span&gt;&lt;span&gt;follow&lt;/span&gt;&lt;span&gt;官方的语法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBwOuETjKDeaBYib0If5Bvy6iczgCk8omeU2uQ0I2eZEBg9BmQhw0DrDWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经&lt;/span&gt;&lt;span&gt;过对模板的升级改造，可以看到平台能够支持的&lt;/span&gt;&lt;span&gt;ETL&lt;/span&gt;&lt;span&gt;模式已经非常丰富了，后面我们也会继续迭代，目标是可以覆盖&lt;/span&gt;&lt;span&gt;95%&lt;/span&gt;&lt;span&gt;以上的实时&lt;/span&gt;&lt;span&gt;ETL&lt;/span&gt;&lt;span&gt;场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBjNMjAURAQpcYyrQWNcxj1tlLQ4Tr6Fke0icTMnlQPb9ymZqNh6nTBjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;UDF是一种扩展SQL表意能力的重要功能，在没有平台的时候，用户UDF都是散布在各自的代码仓库中的，这样一些较通用的UDF，不能被其他业务直接使用，业务在代码中执行一些有安全风险的行为，平台也无法有效管控。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以我们建设了一套&lt;/span&gt;&lt;span&gt;UDF&lt;/span&gt;&lt;span&gt;托管服务，帮助业务集中托管&lt;/span&gt;&lt;span&gt;UDF&lt;/span&gt;&lt;span&gt;代码，可以编译打包时，进行提前检查、并暴露安全风险，而且通用&lt;/span&gt;&lt;span&gt;UDF&lt;/span&gt;&lt;span&gt;可以在业务之间共享，也能够帮助业务提升开发效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBAIZ160SJIQjjicC9Eibs6zlYoQlMWveRaiaz6VRM6M8LcSBpoaewAFPicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面的内容，主要是如何解决开发效率的问题，下&lt;/span&gt;&lt;span&gt;部分内容的重点是，如何保证业务的数据质量。&lt;/span&gt;&lt;span&gt;可能在场的各位同学，有后台开发的相关经验，大家可能都了解&lt;/span&gt;&lt;span&gt;Devops&lt;/span&gt;&lt;span&gt;方法论的核心目标，是保证迭代效率和工程质量。&lt;/span&gt;&lt;span&gt;实时数据开发其实与后台服务开发过程有相似的地方，作业发布后，数据就会立即生效，&lt;/span&gt;&lt;span&gt;并作用于线上，所以我们也需要一套流程，来保证我们每次实时任务发布的数据质量不用影响到我们的数据服务质量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们设计了一套数仓发布的&lt;/span&gt;&lt;span&gt;Pipeline&lt;/span&gt;&lt;span&gt;，在每次任务迭代上线过程都会执行一次&lt;/span&gt;&lt;span&gt;Pipeline&lt;/span&gt;&lt;span&gt;过程，&lt;/span&gt;&lt;span&gt;TestCase&lt;/span&gt;&lt;span&gt;就类似于单测用例，理论上所有&lt;/span&gt;&lt;span&gt;TestCase&lt;/span&gt;&lt;span&gt;都通过才可以发布作业。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Pipeline服务是通过一个异步任务调度框架来实现的，每个Worker内会启动一个Flink的MiniCluster进程，执行后会将结果存入DB并在前端打印执行结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBfz5pZlAyAB3MsjTdZicicjQjzSQQHQ1cibIGd7RANicq2INkicwb7DDVn0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于数据质量，业务还有一项非常关心的事项，也就是数据的时延。时延一方面可以说明业务交付的数据是否符合应用方的预期，另一方面也方便业务自己去排查问题，确定作业的性能瓶颈点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Flink&lt;/span&gt;&lt;span&gt;官方提供了一个用来计算延迟情况的机制，&lt;/span&gt;&lt;span&gt;Latency Marker&lt;/span&gt;&lt;span&gt;，这个东西近似于&lt;/span&gt;&lt;span&gt;Watermark&lt;/span&gt;&lt;span&gt;，是一类与业务数据无关的，由框架周期性产生的消息，我们要做的是根据业务的流量和业务延迟时间精度的要求，控制这类消息的发送频率和发送量，&lt;/span&gt;&lt;span&gt;并支持跨任务传递&lt;/span&gt;&lt;span&gt;Marker&lt;/span&gt;&lt;span&gt;。因为平台收口了数仓接入层，所以这也使我们获取到真正的端到端延迟成为可能，&lt;/span&gt;&lt;span&gt;我们会通过&lt;/span&gt;&lt;span&gt;emitter&lt;/span&gt;&lt;span&gt;向下游发送特殊的消息协议，并且下游任务的&lt;/span&gt;&lt;span&gt;Reciver&lt;/span&gt;&lt;span&gt;会对这类消息做特殊判断，在发送和接受数据时都会将指标上报到&lt;/span&gt;&lt;span&gt;Raptor&lt;/span&gt;&lt;span&gt;，即美团内部的一个业务指标监控，并最终提供给业务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBOPQP4lGiaWIM7etaHsiaicaznYjOKRLdS2ic0otEEsuPbcCwlwVIWgucNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面我们分别介绍了平台是如何提升开发效率和保证业务的数据质量的，主要解决的是数仓开发者的问&lt;/span&gt;&lt;span&gt;题。&lt;/span&gt;&lt;span&gt;平台还有一类用户是数仓架构师，他们不仅仅要参与数仓的建设，还需要对数仓的建设情况做整体性把控。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以前大家都是通过wiki的形式来进行数仓的规范和约束。数仓平台提出了一个项目空间的概念，每个项目空间都可以由架构师定义符合自身业务场景的一些约束项，比如架构师可以定义数仓的主题、分层规范，表、字段的命名规则，同项目空间下的实体都必须遵守负责人做定义的规范。&lt;/span&gt;&lt;span&gt;这样可以在开发之前就保证数仓的建设质量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 算子性能优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面来分享下我们在flink算子层面所做的一些优化工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBsib9hIGK6FWianKfdhLpibIlYTf7KhcQ1tSzj3XYNHZQak2CeDh8SFdXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先实时数仓有很大一部分计算场景是用来做扩维的，也就是流表关联。流数据来自kafka，表数据通常是借助redis、hbase等分布式kv存储，当流量小的时候，每一条流数据都请求一次外存，发起一次网络io，也没有多大影响。但是像基础流量等业务，每天几百上千亿条消息，都去单独请求外存，压力可想而知。所以平台为用户准备了本地缓存机制，通过一个多级缓存的架构，来缓解超大流量下外存访问的IO的压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBAY2Z54cKqOjGDQmSRcJibxVA85Sia23apphkRaaicoWzxb2JKm7MXicDEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数仓&lt;/span&gt;&lt;span&gt;ETL&lt;/span&gt;&lt;span&gt;会包含大量聚合、关联和排序等逻辑，在有界数据处理的时候，我们对算子行为能够做出较准确的判断。&lt;/span&gt;&lt;span&gt;但是在无界数据处理的情况下，像关联、聚合等逻辑为了保证数据的正确性，会在更新一条记录的同时产生一条回撤消息，用来修复下游已经受到影响的数据，所以实际向下游传递的消息量可能会翻倍。而当涉及到多层算子嵌套，比如聚合嵌套关联，那么消息量还会继续膨胀。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决这个问题，我们研究了框架的源码，并分析了业务数据的特征，发现实际上大多数情况消息在极短的时间内会被频繁更新多次，这也就意味着我们可以将多次请求合并成一次请求，来减少状态更新的次数，从而减少向下游发送的消息量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBeuh9E26WdjtRQqPLxgP1qeGTt6ibpxydfeSKXwWBuMG3icf1hiaHCeMhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图是一个&lt;/span&gt;&lt;span&gt;Join&lt;/span&gt;&lt;span&gt;算子的&lt;/span&gt;&lt;span&gt;优化案例，在分析了原理后，&lt;/span&gt;&lt;span&gt;我们认为可以分三个阶段来对算子进行优化：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先在输入阶段，可以对输入的消息做预处理，如果发现同key数据紧跟一条回撤事件，我们这两条消息可以同时消除，而保留最新的一条消息；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接下来在计算阶段，因为双流关联需要缓存左右流各自的状态，这样我们可以将短时间同&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;对状态的访问，合并成一次，减少状态访问次数；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最后在事件下发阶段，可以判断消息之间的关系，重复记录直接可被直接消除。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 建设成果展示&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBs4diaNcHdWBcSlVorf9jOzzlan7QcgVMmRw7RfBORhIIbjEtLsz8a4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先是我们的Web IDE，左面是菜单栏，可以用来管理项目空间，右面是一个web编辑器，用来开发ETL脚本，编辑器下还提供了控制台，用来查看调试日志和对比调试结果，还有语法错误提示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBeOmVm0x2IXh98nicBibbv3c0pIHD9TOq3orVL2Sqe6YOhFx721SRwDXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图是我们的逻辑模型管理模块，在此我们可以编辑自己的模型信息，查看血缘，资源占用量，数仓相关的业务属性等元数据，来辅助业务更好地进行数仓建模。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBROVS5khzLInia3S8YkT6bMIdxoovquk1HU6a0LC8CXVwMt51FicLajcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后展示的是运维中心，所有的作业运行状况，运行指标，操作日志都可以通过这个平台来管理。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;未来计划&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBFrJatQcJlib3YQDHc9FSSns7LL5NqPxqXibKYaPtb0gUmkUac2oHJkwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从前面的分享大家可能会看出，平台前期的大部分精力都集中在解决业务实时数仓建设流程方面的问题上。&lt;/span&gt;&lt;span&gt;随着数仓平台在业务上的逐渐推广，以及业务的深度使用，问题更多的出现在框架的&lt;/span&gt;&lt;span&gt;runtime&lt;/span&gt;&lt;span&gt;层面，比如超大作业的调度成功率和时长问题，&lt;/span&gt;&lt;span&gt;超大数据量作业的状态访问性能问题。&lt;/span&gt;&lt;span&gt;希望通过流批一套语义、一套执行层、一套存储，来彻底解决开发运维的成本问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，&lt;/span&gt;&lt;span&gt;随着实时数据扩展至一些ToC业务场景，这些应用有着非常高的可用性要求，所以在这个方向上我们也要继续攻关下去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后就是终极问题，资源和性能比的问题，也就是在确定性的条件下，用最少的资源做最多的事情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBDafUPSRtF5CoibhFle6iaIj2b4EhZZia3Gc4rOKcxicyRN54tibkSo21gYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是我们平台当前在建设的一个重点项目——数仓增量化生产，为达成真正的流批一体做一些前置性的技术储备和路径探索。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;今天的分享就到这里，谢谢大家。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;在文末分享、点赞、在看，给个3连击呗~&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分享嘉宾：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;289&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPjdrlkyhHH3BZDV05IvhuKOLmiagvjMPlliaqSQNYsx5T6c3b9RgSj29egrVabhnl5n6Av9MqAGUhibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;电子书下载&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;389&quot; data-backw=&quot;578&quot; data-fileid=&quot;100072355&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6733909702209414&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPjicBGnN2Sv2xfMf0eh07fxem4LZeMGOo8FKqdlPdbTWZtXDDHYfNS78E3QkgUh68DMRia11ayJcyOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1041&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;《大数据典藏版合集》&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;电子书目录如上，感兴趣的小伙伴，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;欢迎识别二维码&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，添加小助手微信，回复&lt;/span&gt;&lt;strong&gt;&lt;span&gt;『大数据典藏版合集』&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，即可下载。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;146&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;145&quot; data-fileid=&quot;100072351&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9927007299270073&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;274&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lAStFsJ0Pm0T9eZG6MS4grBiaJAPvOxCotLBIwWiceTLXicvMa6pq5s7ZmCgDFrQQnlWEvhAG1iaKkicXymMicpeVWFA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关于我们：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;DataFun：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;专注于大数据、人工智能技术应用的分享与交流。发起于2017年，在北京、上海、深圳、杭州等城市举办超过100+线下和100+线上沙龙、论坛及峰会，已邀请近1000位专家和学者参与分享。其公众号 DataFunTalk 累计生产原创文章500+，百万+阅读，12万+精准粉丝。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU1NTMyOTI4Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgiaIKm4YqA09u83TvzKbfsabjfX1TLzaXLAK9MWmC4qI6cuTBJnxygZLZPU49O8g6j8QI9264NMqQ/0?wx_fmt=png&quot; data-nickname=&quot;DataFunTalk&quot; data-alias=&quot;datafuntalk&quot; data-signature=&quot;专注于大数据、人工智能技术应用的分享与交流。致力于成就百万数据科学家。定期组织技术分享直播，并整理大数据、推荐/搜索算法、广告算法、NLP 自然语言处理算法、智能风控、自动驾驶、机器学习/深度学习等技术应用文章。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;🧐&lt;strong&gt;分享、点赞、在看&lt;/strong&gt;，给个&lt;strong&gt;3连击&lt;/strong&gt;呗！&lt;strong&gt;👇&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>26130370a415c0b19e3a55c1ad8f5936</guid>
<title>『每周译Go』Golang 在大规模流处理场景下的最小化内存使用</title>
<link>https://toutiao.io/k/1asw7xf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为公司平台团队的一员，我接触了很多文件处理的场景，比如管理一个通用文件上传中心服务，处理邮件附件，处理和导出大文件。在过去，这项工作要容易得多，因为我们可以完全支配整个服务器。我们可以写入一个文件让它持久化在服务器磁盘上，尽管这个作业所需的资源是非常多的。而现在，你的代码库是在更小的处理单元上发布的，比如 pods 。它的资源是虚拟分配的，并且在许多情况下是有限的，所以你需要知道如何有效地使用它们。实现优雅的处理和解决 OOM 退出问题也许对于那些已经熟悉自由地使用内存的人来说是一个大麻烦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我看来，&lt;code&gt;Reader&lt;/code&gt; 和 &lt;code&gt;Writer&lt;/code&gt; 是 Golang 最重要的部分。它给 goroutine 和并发处理提供了重要支持，是 Go 编程模型精简且具有良好性能的关键。因此，为了更进一步掌握 Go 编程语言，你应该能够优雅地操作 go buffers 和 goroutines。在本文中，我将讨论在文件上传到云存储引擎之前，处理从卫星客户端的文件流到中央文件上传器时遇到的问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Multipart 文件转发&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.4595436&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbCyXP3z23wev93ayibMU82aoibhxSxYyhTMesew1jdNn8iaDN7icQt1HJJZ22hvydSYfdRfQ6wbEcEPVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Golang，如果你搜索任何类似 &lt;code&gt;reader&lt;/code&gt; 操作，你应该得到过下面这些内容：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;r := strings.NewReader(&lt;span&gt;&quot;Go is a general-purpose language designed with systems &lt;br/&gt;programming in mind.&quot;&lt;/span&gt;)&lt;br/&gt;b, err := ioutil.ReadAll(r)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;   log.Fatal(err)&lt;br/&gt;}&lt;br/&gt;// Playing with your loaded bytes&lt;br/&gt;fmt.Printf(&lt;span&gt;&quot;%s&quot;&lt;/span&gt;, b)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在你的代码中看到这样的东西是很常见的，因为在互联网上的许多实践都使用了这种方法。自从我第一次使用 &lt;code&gt;Reader&lt;/code&gt;，我也确实习惯了这样用。但是，如果你过度使用它，可能会对内存使用造成很大的损耗，这将极大地影响你可以处理的数据量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;典型场景当你读取的数据是已经预定义好格式的，这意味着在你读取它之后，还必须将它传递给另一个数据处理器再返回你的工作。你可能会使用的一种选择是 &lt;code&gt;io.Copy&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;r := strings.NewReader(&lt;span&gt;&quot;some io.Reader stream to be read\n&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; _, err := io.Copy(os.Stdout, r); err != nil {&lt;br/&gt;  log.Fatal(err)&lt;br/&gt;}&lt;br/&gt;// The data have been copied from Reader r to Stdout&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Copy&lt;/code&gt; 是一种非常方便的操作，因为在将数据写入另一个文本进程之前，我们不需要读取数据。然而要小心的是这可能会导致你落入一个不想踏入的陷阱。官方文件中写道:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从 src 复制副本到 dst，直到在 src 上到达 EOF 或发生错误。它返回复制的字节数和复制时遇到的第一个错误(如果有的话)。— Go 官方文档&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在文件离线处理时，你可以打开一个带缓冲的 &lt;code&gt;writer&lt;/code&gt; 然后完全复制 &lt;code&gt;reader&lt;/code&gt; 中内容，并且不用担心任何其他影响。然而，&lt;code&gt;Copy&lt;/code&gt; 操作将持续地将数据复制到 &lt;code&gt;Writer&lt;/code&gt;，直到 &lt;code&gt;Reader&lt;/code&gt; 读完数据。但这是一个无法控制的过程，如果你处理 &lt;code&gt;writer&lt;/code&gt; 中数据的速度不能与复制操作一样快，那么它将很快耗尽你的缓冲区资源。此外，选择丢弃或者撤销缓冲区分配也是一件很难考虑的事情。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;buf := new(bytes.Buffer)&lt;br/&gt;writer := multipart.NewWriter(buf)&lt;br/&gt;defer writer.Close()&lt;br/&gt;part, err := writer.CreateFormFile(&lt;span&gt;&quot;file&quot;&lt;/span&gt;, &lt;span&gt;&quot;textFile.txt&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;}&lt;br/&gt;file, err := os.Open(name)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;}&lt;br/&gt;defer file.Close()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; _, err = io.Copy(part, file); err != nil {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;}&lt;br/&gt;http.Post(url, writer.FormDataContentType(), buf)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里 &lt;code&gt;io.Pipe&lt;/code&gt; 就出现来解决这类问题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;r, w := io.Pipe()&lt;br/&gt;go &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;   fmt.Fprint(w, &lt;span&gt;&quot;some io.Reader stream to be read\n&quot;&lt;/span&gt;)&lt;br/&gt;   w.Close()&lt;br/&gt;}()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; _, err := io.Copy(os.Stdout, r); err != nil {&lt;br/&gt;   log.Fatal(err)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Pipe&lt;/code&gt; 提供一对 &lt;code&gt;writer&lt;/code&gt; 和 &lt;code&gt;reader&lt;/code&gt;，并且读写操作都是同步的。利用内部缓冲机制，直到之前写入的数据被完全消耗掉才能写到一个新的 &lt;code&gt;writer&lt;/code&gt; 数据快。这样你就可以完全控制如何读取和写入数据。现在，数据吞吐量取决于处理器读取文本的方式，以及 &lt;code&gt;writer&lt;/code&gt; 更新数据的速度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我用它来做我的微服务文件转发器，实际工作效果非常好。能够以最小的内存使用量来复制和传输数据。有着 &lt;code&gt;Pipe&lt;/code&gt; 提供的写阻塞功能 ，&lt;code&gt;Pipe&lt;/code&gt; 和 &lt;code&gt;Copy&lt;/code&gt; 就形成了一个完美的组合。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;r, w := io.Pipe()&lt;br/&gt;m := multipart.NewWriter(w)&lt;br/&gt;go &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;   defer w.Close()&lt;br/&gt;   defer m.Close()&lt;br/&gt;   part, err := m.CreateFormFile(&lt;span&gt;&quot;file&quot;&lt;/span&gt;, &lt;span&gt;&quot;textFile.txt&quot;&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   file, err := os.Open(name)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   defer file.Close()&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; _, err = io.Copy(part, file); err != nil {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;}()&lt;br/&gt;http.Post(url, m.FormDataContentType(), r)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在文件到达文件上传服务的最终目的地之前，这实际上就是我们的文件在各个服务之间传输的方式。文件流可以通过 &lt;code&gt;os.Open()&lt;/code&gt; 在本地加载，也可以通过 &lt;code&gt;multipart reader&lt;/code&gt; 从其他请求中加载。&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;预取和补偿文件流&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.4595436&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbCyXP3z23wev93ayibMU82aoibhxSxYyhTMesew1jdNn8iaDN7icQt1HJJZ22hvydSYfdRfQ6wbEcEPVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们的中央文件上传服务中，我们使用云引擎进行存储，它的 API 接受一个提供文件原始数据的 &lt;code&gt;reader&lt;/code&gt;。除此之外，我们还需要识别上传的内容类型，以确定是否将其删除，还是将其分类到可用的 bucket 中。但是，读取操作是不可逆的，我们必须找到一种方法，为类型检测器读取最小长度的嗅探字节，同时也需要为后一个过程保留原始数据流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个可行的解决方案是使用 &lt;code&gt;io.TeeReader&lt;/code&gt;，它会将从 reader 读取的数据写入另一个 &lt;code&gt;writer&lt;/code&gt; 中。&lt;code&gt;TeeReader&lt;/code&gt; 最常见的用例是将一个流克隆成一个新的流，在保持流不被破坏的情况下为 &lt;code&gt;reader&lt;/code&gt; 提供服务。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;var r io.Reader = strings.NewReader(&lt;span&gt;&quot;some io.Reader stream to be read\n&quot;&lt;/span&gt;)&lt;br/&gt;var buf = bytes.NewBufferString(&lt;span&gt;&quot;&quot;&lt;/span&gt;)&lt;br/&gt;r = io.TeeReader(r, buf)&lt;br/&gt;// Everything &lt;span&gt;read&lt;/span&gt; from r will be copied to buf.&lt;br/&gt;_, _ = io.ReadAtLeast(r, mimeType, 512)&lt;br/&gt;// Continue to copy the stream to write it to buf, to use buf &lt;span&gt;in&lt;/span&gt; the following operation&lt;br/&gt;io.Copy(io.Discard, r)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但问题是，如果在将其传递给 GCP 文件处理程序之前同步运行它，它最终还是会将所有数据复制到准备好的缓冲区。一个可行的方法是再次使用 &lt;code&gt;Pipe&lt;/code&gt; 来操作它，达到无本地缓存效果。但另一个问题是，&lt;code&gt;TeeReader&lt;/code&gt; 要求在完成读取过程之前必须完成写入过程，而 &lt;code&gt;Pipe&lt;/code&gt;则相反。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以最后我们设计了一个定制化的预取 &lt;code&gt;reader&lt;/code&gt;，专门用来处理这种情况。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package services&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;   &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; prefetchReader struct {&lt;br/&gt;   reader   io.Reader&lt;br/&gt;   prefetch []byte&lt;br/&gt;   size     int&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func newPrefetchReader(reader io.Reader, prefetch []byte) *prefetchReader {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &amp;amp;prefetchReader{&lt;br/&gt;      reader:   reader,&lt;br/&gt;      prefetch: prefetch,&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (r *prefetchReader) Read(p []byte) (n int, err error) {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; len(p) == 0 {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; 0, fmt.Errorf(&lt;span&gt;&quot;empty buffer&quot;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;   defer &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;      r.size += n&lt;br/&gt;   }()&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; len(r.prefetch) &amp;gt; 0 {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; len(p) &amp;gt;= len(r.prefetch) {&lt;br/&gt;         copy(p, r.prefetch)&lt;br/&gt;         n := len(r.prefetch)&lt;br/&gt;         r.prefetch = nil&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; n, nil&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;         copy(p, r.prefetch[:len(p)])&lt;br/&gt;         r.prefetch = r.prefetch[len(p):]&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; len(p), nil&lt;br/&gt;      }&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; r.reader.Read(p)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用这个 &lt;code&gt;reader&lt;/code&gt;，你可以预取一些嗅探字节以进行处理，然后使用补偿字节创建一个新的嵌套 &lt;code&gt;reader&lt;/code&gt; 用于后面的操作。&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4595436&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbCyXP3z23wev93ayibMU82aoibhxSxYyhTMesew1jdNn8iaDN7icQt1HJJZ22hvydSYfdRfQ6wbEcEPVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是我在工作中遇到的问题。操作这些 &lt;code&gt;readers&lt;/code&gt; 和 &lt;code&gt;writers&lt;/code&gt; 是非常麻烦的，但还是非常值得一试，因为这其中包含了很多乐趣。我希望你能学习到一种处理与它们相关的各种问题的方法，并能有一个更好的 Go 使用体验。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>49b88dce795696cbfa44fb0b7013a6fb</guid>
<title>宣布Kubernetes策略管理白皮书</title>
<link>https://toutiao.io/k/m17h97v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;285&quot; data-backw=&quot;540&quot; data-ratio=&quot;0.5277777777777778&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJykl78gSWLQ2BgZksNPibndNocPwMVzKNtDfsfv3SOwcYJM1Ypwib7uPlyXjMLMCnxwYxkBHhgvFJNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;540&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：Jim Bugwadia&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CNCF Kubernetes 安全 SIG 和策略工作组（WG）刚刚发布了&lt;span&gt;Kubernetes 策略管理白皮书&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;，以帮助社区了解使用策略管理 Kubernetes 配置的最佳实践。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该白皮书旨在提供一个清晰的理解为什么 Kubernetes 策略管理对 Kubernetes 集群和工作负载的安全和自动化是重要的。它还描述了 Kubernetes 策略可以帮助解决哪些问题，以及如何实现 Kubernetes 策略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“策略可以简化开发人员、操作人员、安全工程师和合规官员对 Kubernetes 配置和安全控制的管理。在云原生环境中，除了应用运行时安全外，在连续交付流水线和准入控制中执行策略有助于将安全性向左转移，加强软件供应链安全。本白皮书代表了社区的努力，在阐明 Kubernetes 集群操作、安全、持续遵从性和管理策略的作用方面迈出了重要的一步。”CNCF Kubernetes 策略工作组 Aradhna Chetal 说。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该白皮书介绍了跨云原生生命周期的基于策略的操作的新指导，并讨论了 Kubernetes 策略管理的参考架构，提供了所需的每个组件的描述。该白皮书还讨论了策略如何映射到其他安全领域，如威胁建模、保证和遵从性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kubernetes 安全 SIG 安全专注于提高 Kubernetes 项目跨所有组件的安全性。如果你对参与安全 SIG 感兴趣，请查看&lt;span&gt;宪章&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;以获得更多信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kubernetes 工作组的组织是为了解决跨 SIG 的特定主题。&lt;span&gt;Kubernetes 策略工作组&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;专注于 Kubernetes 的策略实现、架构和最佳实践。如果你对推进 Kubernetes 策略管理感兴趣，请加入&lt;span&gt;即将召开的会议&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;或在&lt;span&gt;Slack 频道&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;上向小组发送消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kubernetes 策略管理文白皮书可以在&lt;span&gt;GitHub&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;上找到。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Kubernetes 策略管理白皮书: &lt;em&gt;https://github.com/kubernetes/sig-security/blob/main/sig-security-docs/papers/policy/CNCF_Kubernetes_Policy_Management_WhitePaper_v1.pdf&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;宪章: &lt;em&gt;https://github.com/kubernetes/community/blob/master/sig-security/charter.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Kubernetes 策略工作组: &lt;em&gt;https://github.com/kubernetes/community/tree/master/wg-policy&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;即将召开的会议: &lt;em&gt;https://github.com/kubernetes/community/tree/master/wg-policy#meetings&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;Slack 频道: &lt;em&gt;https://kubernetes.slack.com/messages/wg-policy&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;GitHub: &lt;em&gt;https://github.com/kubernetes/sig-security/tree/main/sig-security-docs/papers/policy&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击【阅读原文】阅读网站原文。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;161&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;161&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJyjIvCTT9MHACYHrhxPr4WTsLl4cia1yECXm3kibDvzgdhicxAibuG9mokxesEs2e3wxL9sj1ApfdOKCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CNCF概况（幻灯片）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;161&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;161&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJxyapkOjiazruKNQ7DZ6t8TSh0QSYM4DlI86xnXiayciayIgBUaG8q8lFZ3FsibPJiaeCqAahrKicB220aA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;301&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扫描二维码联系我们！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;CNCF (Cloud Native Computing Foundation)成立于2015年12月，隶属于Linux  Foundation，是非营利性组织。 &lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;&lt;strong&gt;&lt;em&gt;CNCF&lt;/em&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;（&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&lt;strong&gt;&lt;em&gt;云原生计算基金会&lt;/em&gt;&lt;/strong&gt;）致力于培育和维护一个厂商中立的开源生态系统，来推广云原生技术。我们通过将最前沿的模式民主化，让这些创新为大众所用。请长按以下二维码进行关注。&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJyq2qDvc7MWGZxI4RSwuQcDYF9lD2fuOvw9rvdXWTxODu56IibWa0R8mibibhqExqurr6168Wjf2VstQ/640?wx_fmt=png&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;165&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;165&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GpkQxibjhkJxKPX3Ywf6bvZic6ibE8EzomstVhFq0ua8p8KI8PdVve5Q6YwRzHYQ4j63hKakYPcbqAdDoRHrgcFLg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>01294f40a65a3a3fd1c3bf514dd45dba</guid>
<title>如何为 Node.js 的 require 函数添加钩子？</title>
<link>https://toutiao.io/k/ek9h644</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境。早期的 Node.js 采用的是 CommonJS 模块规范，从 Node v13.2.0 版本开始正式支持 ES Modules 特性。直到 v15.3.0 版本 ES Modules 特性才稳定下来并与 NPM 生态相兼容。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.425&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3epBBUPEBgGEiaFCSsoCiaicYmVP3cZALeIKK0ZJiatiabC4ibDxibibFpLiaWafyyaDtqgLzV6Sj0JszFX5Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（图片来源：https://nodejs.org/api/esm.html）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文将介绍 Node.js 中 &lt;code&gt;require&lt;/code&gt; 函数的工作流程、如何让 Node.js 直接执行 ts 文件及如何正确地劫持 Node.js 的 &lt;code&gt;require&lt;/code&gt; 函数，从而实现钩子的功能。接下来，我们先来介绍 &lt;code&gt;require&lt;/code&gt; 函数。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;require 函数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Node.js 应用由模块组成，每个文件就是一个模块。对于 CommonJS 模块规范来说，我们通过 &lt;code&gt;require&lt;/code&gt; 函数来导入模块。那么当我们使用 &lt;code&gt;require&lt;/code&gt; 函数来导入模块的时候，该函数内部发生了什么？这里我们通过调用堆栈来了解一下 &lt;code&gt;require&lt;/code&gt; 的过程：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.42109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3epBBUPEBgGEiaFCSsoCiaicYDVeVGge17icGmXMGYlGkcMQ4kWK0fkiaMxVcSVrDIsSdelscEKDgutzg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由上图可知，在使用 &lt;code&gt;require&lt;/code&gt; 导入模块时，会调用 &lt;code&gt;Module&lt;/code&gt; 对象的 &lt;code&gt;load&lt;/code&gt; 方法来加载模块，该方法的实现如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// lib/internal/modules/cjs/loader.js&lt;/span&gt;&lt;br/&gt;Module.prototype.load = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;filename&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.filename = filename;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.paths = Module._nodeModulePaths(path.dirname(filename));&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; extension = findLongestRegisteredExtension(filename);&lt;br/&gt;&lt;br/&gt;  Module._extensions[extension](&lt;span&gt;this&lt;/span&gt;, filename);&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.loaded = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：本文所引用 Node.js 源码所对应的版本是 &lt;strong&gt;v16.13.1&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上代码中，重要的两个步骤是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;步骤一：根据文件名找出扩展名；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;步骤二：通过解析后的扩展名，在 &lt;code&gt;Module._extensions&lt;/code&gt; 对象中查找匹配的加载器。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;在 Node.js 中内置了 3 种不同的加载器，用于加载 &lt;/span&gt;&lt;code&gt;node&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;json&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;js&lt;/code&gt;&lt;span&gt; 文件。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;strong&gt;node 文件加载器&lt;/strong&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// lib/internal/modules/cjs/loader.js&lt;/span&gt;&lt;br/&gt;Module._extensions[&lt;span&gt;&#x27;.node&#x27;&lt;/span&gt;] = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;module, filename&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; process.dlopen(&lt;span&gt;module&lt;/span&gt;, path.toNamespacedPath(filename));&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;json 文件加载器&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// lib/internal/modules/cjs/loader.js&lt;/span&gt;&lt;br/&gt;Module._extensions[&lt;span&gt;&#x27;.json&#x27;&lt;/span&gt;] = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;module, filename&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;const&lt;/span&gt; content = fs.readFileSync(filename, &lt;span&gt;&#x27;utf8&#x27;&lt;/span&gt;);&lt;br/&gt; &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;module&lt;/span&gt;.exports = JSONParse(stripBOM(content));&lt;br/&gt; } &lt;span&gt;catch&lt;/span&gt; (err) {&lt;br/&gt;   err.message = filename + &lt;span&gt;&#x27;: &#x27;&lt;/span&gt; + err.message;&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; err;&lt;br/&gt; }&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;js 文件加载器&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// lib/internal/modules/cjs/loader.js&lt;/span&gt;&lt;br/&gt;Module._extensions[&lt;span&gt;&#x27;.js&#x27;&lt;/span&gt;] = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;module, filename&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// If already analyzed the source, then it will be cached.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; cached = cjsParseCache.get(&lt;span&gt;module&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; content;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (cached?.source) {&lt;br/&gt;    content = cached.source;&lt;br/&gt;    cached.source = &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    content = fs.readFileSync(filename, &lt;span&gt;&#x27;utf8&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;module&lt;/span&gt;._compile(content, filename);&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来分析比较重要的 &lt;strong&gt;js 文件加载器&lt;/strong&gt;。通过观察以上代码，我们可知 &lt;code&gt;js&lt;/code&gt; 加载器的核心处理流程，也可以分为两个步骤：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;步骤一：使用 &lt;code&gt;fs.readFileSync&lt;/code&gt; 方法加载 &lt;code&gt;js&lt;/code&gt; 文件的内容；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;步骤二：使用 &lt;code&gt;module._compile&lt;/code&gt; 方法编译已加载的 &lt;code&gt;js&lt;/code&gt; 代码。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;那么了解以上的知识之后，对我们有什么用处呢？&lt;/span&gt;&lt;span&gt;其实在了解 &lt;/span&gt;&lt;code&gt;require&lt;/code&gt;&lt;span&gt; 函数的工作流程之后，我们就可以扩展 Node.js 的加载器。&lt;/span&gt;&lt;span&gt;比如让 Node.js 能够运行 &lt;/span&gt;&lt;code&gt;ts&lt;/code&gt;&lt;span&gt; 文件。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// register.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; fs = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;fs&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; Module = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;module&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { transformSync } = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;esbuild&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;Module._extensions[&lt;span&gt;&quot;.ts&quot;&lt;/span&gt;] = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;module, filename&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; content = fs.readFileSync(filename, &lt;span&gt;&quot;utf8&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { code } = transformSync(content, {&lt;br/&gt;    &lt;span&gt;sourcefile&lt;/span&gt;: filename,&lt;br/&gt;    &lt;span&gt;sourcemap&lt;/span&gt;: &lt;span&gt;&quot;both&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;loader&lt;/span&gt;: &lt;span&gt;&quot;ts&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;format&lt;/span&gt;: &lt;span&gt;&quot;cjs&quot;&lt;/span&gt;,&lt;br/&gt;  });&lt;br/&gt;  &lt;span&gt;module&lt;/span&gt;._compile(code, filename);&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上代码中，我们引入了内置的 &lt;code&gt;module&lt;/code&gt; 模块，然后利用该模块的 &lt;code&gt;_extensions&lt;/code&gt; 对象来注册我们的自定义 ts 加载器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，加载器的本质就是一个函数，在该函数内部我们利用 esbuild 模块提供的 &lt;code&gt;transformSync&lt;/code&gt; API 来实现 &lt;strong&gt;ts -&amp;gt; js&lt;/strong&gt; 代码的转换。当完成代码转换之后，会调用 &lt;code&gt;module._compile&lt;/code&gt; 方法对代码进行编译操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里相信有的小伙伴，也想到了 Webpack 中对应的 loader，想深入学习的话，可以阅读 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;amp;mid=2247494307&amp;amp;idx=1&amp;amp;sn=cdeb4085693db5f1c314a0eb3b9e3485&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;多图详解，一次性搞懂Webpack Loader&lt;/a&gt; 这篇文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;篇幅有限，具体的编译过程，我们就不展开介绍了。下面我们来看一下如何让自定义的 ts 加载器生效。要让 Node.js 能够执行 ts 代码，我们就需要在执行 ts 代码前，先完成自定义 ts 加载器的注册操作。庆幸的是，Node.js 为我们提供了模块的预加载机制：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt; $&lt;/span&gt;&lt;span&gt; node --&lt;span&gt;help&lt;/span&gt; | grep preload&lt;/span&gt;&lt;br/&gt;   -r, --require=... module to preload (option can be repeated)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即利用 &lt;code&gt;-r, --require&lt;/code&gt; 命令行配置项，我们就可以预加载指定的模块。了解完相关知识之后，我们来测试一下自定义 ts 加载器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先创建一个 &lt;code&gt;index.ts&lt;/code&gt; 文件并输入以下内容：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// index.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; add = &lt;span&gt;(&lt;span&gt;a: &lt;span&gt;number&lt;/span&gt;, b: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; a + b;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;add(a, b) = &quot;&lt;/span&gt;, add(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在命令行输入以下命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; node -r ./register.js index.ts&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当以上命令成功运行之后，控制台会输出以下内容：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;add(a, b) =  8&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显我们自定义的 ts 文件加载器生效了，这种扩展机制还是值得我们学习的。另外，需要注意的是在 &lt;code&gt;load&lt;/code&gt; 方法中，&lt;code&gt;findLongestRegisteredExtension&lt;/code&gt; 函数会判断文件的扩展名是否已经注册在 &lt;code&gt;Module._extensions&lt;/code&gt; 对象中，若未注册的话，默认会返回 &lt;code&gt;.js&lt;/code&gt; 字符串。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// lib/internal/modules/cjs/loader.js&lt;/span&gt;&lt;br/&gt;Module.prototype.load = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;filename&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.filename = filename;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.paths = Module._nodeModulePaths(path.dirname(filename));&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; extension = findLongestRegisteredExtension(filename);&lt;br/&gt;&lt;br/&gt;  Module._extensions[extension](&lt;span&gt;this&lt;/span&gt;, filename);&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.loaded = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就意味着只要文件中包含有效的 &lt;code&gt;js&lt;/code&gt; 代码，&lt;code&gt;require&lt;/code&gt; 函数就能正常加载它。比如下面的 &lt;strong&gt;a.txt&lt;/strong&gt; 文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;module&lt;/span&gt;.exports = &lt;span&gt;&quot;hello world&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里相信你已经了解 &lt;code&gt;require&lt;/code&gt; 函数是如何加载模块及如何自定义 Node.js 文件加载器。那么让 Node.js 支持加载 &lt;code&gt;ts&lt;/code&gt;、&lt;code&gt;png&lt;/code&gt; 或 &lt;code&gt;css&lt;/code&gt; 等其它类型的文件，有更优雅、更简单的方案么？答案是有的，我们可以使用 pirates 这个第三方库。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;pirates 是什么&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pirates 这个库让我们可以正确地劫持 Node.js 的 &lt;code&gt;require&lt;/code&gt; 函数。利用这个库，我们就可以很容易扩展 Node.js 加载器的功能。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;pirates 的用法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以使用 npm 来安装 pirates：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install --save pirates&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在成功安装 pirates 这个库之后，就可以利用该模块导出提供的 &lt;code&gt;addHook&lt;/code&gt; 函数来添加钩子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// register.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; addHook = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;pirates&quot;&lt;/span&gt;).addHook;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; revert = addHook(&lt;br/&gt;  &lt;span&gt;(&lt;span&gt;code, filename&lt;/span&gt;) =&amp;gt;&lt;/span&gt; code.replace(&lt;span&gt;&quot;@@foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;console.log(&#x27;foo&#x27;);&quot;&lt;/span&gt;),&lt;br/&gt;  { &lt;span&gt;exts&lt;/span&gt;: [&lt;span&gt;&quot;.js&quot;&lt;/span&gt;] }&lt;br/&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是调用 &lt;code&gt;addHook&lt;/code&gt; 之后会返回一个 &lt;code&gt;revert&lt;/code&gt; 函数，用于取消对 &lt;code&gt;require&lt;/code&gt; 函数的劫持操作。下面我们来验证一下 pirates 这个库是否能正常工作，首先新建一个 &lt;code&gt;index.js&lt;/code&gt; 文件并输入以下内容：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// index.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;@@foo&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在命令行输入以下命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; node -r ./register.js index.js&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当以上命令成功运行之后，控制台会输出以下内容：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;console.log(&#x27;foo&#x27;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;观察以上结果可知，我们通过 &lt;code&gt;addHook&lt;/code&gt; 函数添加的钩子生效了。是不是觉得挺神奇的，接下来我们来分析一下 pirates 的工作原理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;pirates 是如何工作的&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pirates 底层是利用 Node.js 内置 &lt;code&gt;module&lt;/code&gt; 模块提供的扩展机制来实现 &lt;code&gt;Hook&lt;/code&gt; 功能。前面我们已经介绍过了，当使用 &lt;code&gt;require&lt;/code&gt; 函数来加载模块时，Node.js 会根据文件的后缀名来匹配对应的加载器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实 pirates 的源码并不会复杂，我们来重点分析 &lt;code&gt;addHook&lt;/code&gt; 函数的核心处理逻辑：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// src/index.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;addHook&lt;/span&gt;(&lt;span&gt;hook, opts = {}&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; reverted = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; loaders = []; &lt;span&gt;// 存放新的loader&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; oldLoaders = []; &lt;span&gt;// 存放旧的loader&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; exts;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; originalJSLoader = Module._extensions[&lt;span&gt;&#x27;.js&#x27;&lt;/span&gt;]; &lt;span&gt;// 原始的JS Loader &lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; matcher = opts.matcher || &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; ignoreNodeModules = opts.ignoreNodeModules !== &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  exts = opts.extensions || opts.exts || opts.extension || opts.ext &lt;br/&gt;    || [&lt;span&gt;&#x27;.js&#x27;&lt;/span&gt;];&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Array&lt;/span&gt;.isArray(exts)) {&lt;br/&gt;    exts = [exts];&lt;br/&gt;  }&lt;br/&gt;  exts.forEach((ext) { &lt;br/&gt;    &lt;span&gt;// ... &lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了提高执行效率，&lt;code&gt;addHook&lt;/code&gt; 函数提供了 &lt;code&gt;matcher&lt;/code&gt; 和 &lt;code&gt;ignoreNodeModules&lt;/code&gt; 配置项来实现文件过滤操作。在获取到 &lt;code&gt;exts&lt;/code&gt; 扩展名列表之后，就会使用新的加载器来替换已有的加载器。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;exts.forEach(&lt;span&gt;(&lt;span&gt;ext&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; ext !== &lt;span&gt;&#x27;string&#x27;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;TypeError&lt;/span&gt;(&lt;span&gt;`Invalid Extension: &lt;span&gt;${ext}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 获取已注册的loader，若未找到，则默认使用JS Loader&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; oldLoader = Module._extensions[ext] || originalJSLoader;&lt;br/&gt;    oldLoaders[ext] = Module._extensions[ext];&lt;br/&gt;&lt;br/&gt;    loaders[ext] = Module._extensions[ext] = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;newLoader&lt;/span&gt;(&lt;span&gt;&lt;br/&gt;   mod, filename&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;let&lt;/span&gt; compile;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!reverted) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (shouldCompile(filename, exts, matcher, ignoreNodeModules)) {&lt;br/&gt;          compile = mod._compile;&lt;br/&gt;          mod._compile = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;_compile&lt;/span&gt;(&lt;span&gt;code&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;// 这里需要恢复成原来的_compile函数，否则会出现死循环&lt;/span&gt;&lt;br/&gt;            mod._compile = compile;&lt;br/&gt;            &lt;span&gt;// 在编译前先执行用户自定义的hook函数&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;const&lt;/span&gt; newCode = hook(code, filename);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; newCode !== &lt;span&gt;&#x27;string&#x27;&lt;/span&gt;) {&lt;br/&gt;              &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(HOOK_RETURNED_NOTHING_ERROR_MESSAGE);&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; mod._compile(newCode, filename);&lt;br/&gt;          };&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;&lt;br/&gt;      oldLoader(mod, filename);&lt;br/&gt;    };&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;观察以上代码可知，在 &lt;code&gt;addHook&lt;/code&gt; 函数内部是通过替换 &lt;code&gt;mod._compile&lt;/code&gt; 方法来实现钩子的功能。即在调用原始的 &lt;code&gt;mod._compile&lt;/code&gt; 方法进行编译前，会先调用 &lt;code&gt;hook(code, filename)&lt;/code&gt; 函数来执行用户自定义的 &lt;code&gt;hook&lt;/code&gt; 函数，从而对代码进行处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的，至此本文的主要内容都介绍完了，在实际工作中，如果你想让 Node.js 直接执行 ts 文件，可以利用 ts-node 或 esbuild-register 这两个库。其中 esbuild-register 这个库内部就是使用了 pirates 提供的 Hook 机制来实现对应的功能。&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5cde11ab631a2d7fb8767c4cd5c98eae</guid>
<title>卷起来了！DeepMind发布媲美普通程序员的AlphaCode，同日OpenAI神经数学证明器拿下奥数题</title>
<link>https://toutiao.io/k/dccden1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; data-style=&quot;white-space: normal; max-width: 100%; letter-spacing: 0.544px; text-size-adjust: auto; background-color: rgb(255, 255, 255); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__0&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-id=&quot;85660&quot; data-custom=&quot;rgb(117, 117, 118)&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-id=&quot;85660&quot; data-custom=&quot;rgb(117, 117, 118)&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-top: 2em; padding-top: 0.5em; padding-bottom: 0.5em; max-width: 100%; border-style: solid none; text-decoration: inherit; border-top-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-top-width: 1px; border-bottom-width: 1px; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__1&quot;&gt;&lt;section&gt;&lt;span&gt;机器之心报道&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;编辑：张倩、蛋酱&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;136&quot; data-source-title=&quot;&quot;&gt;&lt;p&gt;世界本来已经很卷，有了 AI 加入之后，卷上加卷……&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;太卷了！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在国内欢度春节之时，DeepMind 与 OpenAI 两个知名 AI 研究机构分别发布重要研究成果：DeepMind 发布了基于 Transformer 模型的 AlphaCode，可以编写与人类相媲美的计算机程序；同时，OpenAI 开发的神经定理证明器成功解出了两道国际奥数题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.334375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicngldHpdpkWmEIEHVLaBxiaqAX3hQ5hc9vdgoBLLoKQuicUPP9AQkwsWO7PMxDKIFoEmgH92kXe4Eg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有没有觉得 AI 攻克的这两个领域很熟悉？没错，就在 2021 年，OpenAI 发布了 AI 代码补全工具 &lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;amp;mid=2650819923&amp;amp;idx=1&amp;amp;sn=45764d880cb7ce30a403d40290fd0387&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;GitHub Copilot&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;GitHub Copilot&lt;/a&gt; ，并公布了背后的技术 CodeX。同样，在去年下半年，DeepMind 也公布了他们&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;amp;mid=2650832264&amp;amp;idx=3&amp;amp;sn=7821ba21dcd0ff804998534cbdbf8287&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;解决数学难题的 AI 研究成果&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;解决数学难题的 AI 研究成果&lt;/a&gt;，并登上了 Nature。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;虽然两家研究机构的新成果为 AI 解决老问题提供了新思路，但也不得不让网友感叹，AI 领域太卷了！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8427128427128427&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicngldHpdpkWmEIEHVLaBxia1suCPRNYeCyh3Y1250DUJaySbOCmItqiaAmnc2R9iaqanChIccu8VuhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;693&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;来源：网友微博截图&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;击败 46% 参赛者的 AlphaCode&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在最近的一篇论文中，DeepMind 的研究者介绍了 AlphaCode。AlphaCode 使用基于 Transformer 的语言模型实现大规模的代码生成，并且将其编写为程序。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.39765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicngldHpdpkWmEIEHVLaBxiaxQcDtDcdY7t6FnD3KZ4CcKjja9rj5hZt5wBBn2cH5iaibW207WgWqFpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;论文连接：https://storage.googleapis.com/deepmind-media/AlphaCode/competition_level_code_generation_with_alphacode.pdf&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;研究者将 AlphaCode 放在 Codeforces 挑战中进行了测试，Codeforces 是一个具有竞争力的编程平台，它类似于国际象棋中使用的 Elo 评级系统，每周分享编程挑战和问题排名。不同于编程人员在打造商业应用程序时可能面临的任务，Codeforces 的挑战更加独立，需要对计算机科学中的算法和理论概念有更广泛的了解，一般是结合逻辑、数学和编码专业知识的非常专业的难题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;AlphaCode 针对 Codeforces 网站上 5000 名用户解决的 10 项挑战进行了测试，总体排名位于前 54.3%，也就是说它击败了 46% 的参赛者 。DeepMind 估计，AlphaCode 系统的 Codeforces Elo 为 1238，使其过去六个月内在该网站上竞争的用户中排名前 28%。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6604651162790698&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicngldHpdpkWmEIEHVLaBxiaFUBHzKazTwYa7UHfcSjBdjeAZehqwoTPKa2Oic5ppKMSGIZr6QVicg9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;860&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;举个例子，在测试 AlphaCode 的一项挑战中，试题要求参赛者找到一种方法，使用一组有限的输入将一个随机、重复的 s 和 t 字母字符串转换为另一个相同字母的字符串。例如，竞争对手不能只输入新字母，而必须使用「backspace」命令删除原始字符串中的几个字母。对于 AlphaCode 来说，这只是中等难度的挑战：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.5171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicngldHpdpkWmEIEHVLaBxiaYpzsA9whJIkYnkjPnNjcP8hHEYfyIviapUEz1ttHythnS83B8LibbfUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中十个挑战以与人类完全相同的格式输入 AlphaCode。然后，AlphaCode 生成大量可能的答案，并通过运行代码和检查输出来筛选这些答案，就像人类竞争对手一样。AlphaCode 论文的联合负责人 Yujia Li 和 David Choi 表示：「整个过程是自动的，无需人工选择最佳样本。」&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;要想在 Codeforces 的挑战中脱颖而出，原本不是一件容易的事。AlphaCode 项目开展于两年多前，随着大规模 Transformer 模型的进步与大规模采样、滤波技术的结合，DeepMind 的研究者已经在 AI 能够解决的问题数量上取得了重大进展。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.16640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicngldHpdpkWmEIEHVLaBxiawkBRfm6yfQqTM61iaXNnVQzEQjR7cxYODNTmRR8qmKhlnor2CEpx7cw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;受到疫情的影响，项目的大部分工作都是在家完成的。&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;研究者在选定的公共 GitHub 代码上预训练该模型，并在相对较小的竞赛编程数据集上对其进行微调。在评估期间，研究者为每个问题创建了大量的 C++ 和 Python 程序，且数量级比以前的工作要大。然后对这些解决方案进行筛选、聚类和重新排序，将这些解决方案分配到一个由 10 个候选程序组成的小集合中，并提交给外部评估。这个自动化系统取代了竞争对手的调试、编译、通过测试和最终提交的反复试验过程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicngldHpdpkWmEIEHVLaBxialbWb315wN8ibhM3ibmKSL3ic8P09JAbicibDia6TFvurDPph9s1VWastH6lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;总体来说，AlphaCode 的排名在竞争对手中大致相当于中位数。虽然远远没能赢得比赛，但这个结果代表了人工智能解决问题能力的实质性飞跃。这一进步证明了深度学习模型在需要批判性思维的任务中的潜力。DeepMind 指出，AlphaCode 目前的技能组合目前仅适用于竞赛性质的编程领域，但它的能力为创建未来工具打开了新的大门，这些工具使编程变得更加容易，并且有朝一日完全自动化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;许多其他公司正在开发类似的应用程序。对于终端的用户来说，这些系统就像 Gmail 的 Smart Compose 功能一样工作，提供一些关于你正在编写的任何内容的建议。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;近年来，AI 编程系统的开发取得了很大进展，但这些系统还远未准备好接管人类程序员的工作。他们生成的代码通常有问题，而且由于系统通常是在公共代码库上进行训练的，所以有时会复制受版权保护的材料。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在一项关于 GitHub Copilot AI 编程工具的研究中，研究人员发现其输出的代码约有 40% 包含安全漏洞。安全分析师甚至建议，不良行为者可以故意编写代码并与隐藏的后门（backdoor）在线共享代码，然后这些代码可能被用来训练 AI 程序，将这些错误插入到未来的程序中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;像这样的挑战意味着 AI 编程系统可能会慢慢融入程序员的工作中——换句话说，他们要进行学徒训练，从助理开始做起，在被信任能够自主执行工作之前，AI 给出的建议都要受到怀疑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.66015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicngldHpdpkWmEIEHVLaBxiaKF31Ghht0uzeicdNEUJcamPictck3UeooU7f7STIoqdmN4v2w41nRXnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;目前，DeepMind 已在 GitHub 上发布了竞赛级编程问题和解决方案的数据集，其中也包括广泛的测试的数据，以确保通过这些测试的程序是正确的，这是目前数据集所缺乏的一个关键特性。DeepMind 希望这个基准能够推动在解决问题和代码生成方面的进一步创新。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;GitHub 项目地址：https://github.com/deepmind/code_contests&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;挑战奥数题的神经定理证明器&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在学科竞赛领域，国际数学奥林匹克竞赛（IMO）是非常有名的一个，我们熟悉的很多数学大神（如韦东奕）都在这一竞赛中取得了骄人的成绩。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2021 年，这项比赛迎来了一个微小的变化：微软研发多年的数学 AI——Lean 也加入了竞争，和人类选手一决高下。据悉，Lean 是微软研究院在 2013 年推出的计算机定理证明器：数学家可以把数学公式转换成代码，再输入到 Lean 中，让程序来验证定理是否正确。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于 Lean 剑指金牌，研究人员一直在对其进行不停的打磨，其中也包括被微软收购了的 OpenAI。刚刚，OpenAI 发文表示，他们已经为 Lean 创建了一个神经定理证明器，用于解决各种具有挑战性的高中奥林匹克问题，包括两个改编自 IMO 的问题和来自 AMC12、AIME 竞赛的若干问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;该证明器使用一个语言模型来寻找形式化命题（formal statement）的证明。每次发现一个新的证明，研究者就把它作为新的训练数据，这改善了神经网络，使它能够在迭代中找到越来越难的命题的解决方案。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;该证明器在 miniF2F 基准测试中实现了 SOTA（41.2% vs 29.3%）水平，miniF2F 包含一组具有挑战性的高中奥林匹克问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;研究者将他们的方法称为 statement curriculum learning，该方法包括手动收集的一组不同难度级别的命题（无需证明），其中最难的命题类似于目标基准。最初，他们的神经证明器很弱，只能证明其中的几个。因此，他们迭代地搜索新的证明，并在新发现的证明上重新训练他们的神经网络。经过 8 次迭代，他们的证明器在 miniF2F 上取得了出色的成绩。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;形式化数学（formal mathematics）是一个令人兴奋的研究领域，因为：1）它很丰富，可以让你证明需要推理、创造力和洞察力的任意定理；2）它与游戏相似，也有一种自动化的方法来确定一个证明是否成立（即由形式系统验证）。如下图中的例子所示，证明一个形式化的命题需要生成一系列的证明步骤，每个证明步骤都包含对策略（ tactic）的调用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;形式化系统接受的 artifact 是低级的（就像汇编代码），人类很难产生。策略是从更高层次的指令生成这种 artifact 的搜索过程，以辅助形式化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这些策略以数学术语作为参数，每次策略调用都会将当前要证明的命题转换为更容易证明的命题，直到没有任何东西需要证明。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9008567931456548&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicngldHpdpkWmEIEHVLaBxiaHx0cfVfhPbib1tOIZRPG3RWrCtIhLtPfyic050kXnSFlqzTJicxgzQPgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;817&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;研究者观察到，生成策略参数所需的原始数学术语的能力出现在了他们的训练过程中，这是离开神经语言模型所无法完成的。下面的证明就是它的一个例子：证明步骤「use n + 1」（完全由模型生成）提出使用「n + 1」作为解决方案，剩下的形式证明依赖于「ring _ exp」策略来验证它确实有效。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7375455650060754&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicngldHpdpkWmEIEHVLaBxiafmj6QI7Pkr5XicOVrjF1SMeluMuFWr3RocNAzFOHtkMYPMeru9l0BOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;823&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;研究者还观察到，他们的模型和搜索过程能够产生链接多个重要推理步骤的证明。在下面的证明中，模型首先使用了引出存在性命题（existential statement） (∃ (x : ℝ), f x ≠ a * x + b) 的换质换位律（contraposition）。然后，它使用 use (0 : ℝ) 为它生成一个 witness，并通过利用 norm _ num 策略来完成证明。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9891304347826086&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicngldHpdpkWmEIEHVLaBxiacSBuMcfiadw5I9afz3IePjuAVuYCChiaTeFtCqpcUfKlhzZeWFLrbu0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;该模型经过 statement curriculum learning 的训练，能够解决培训教材以及 AMC12 和 AIME 中的各种问题，以及改编自 IMO 的两个问题。下面是三个有关的例子。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8299643281807372&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicngldHpdpkWmEIEHVLaBxiaccG8pW5nfClJA5ibEApvibOicunD7MkS9ThvSlp3ZC9hu6YZEDzf9eZEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;841&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8697225572979493&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicngldHpdpkWmEIEHVLaBxia7iceyYqJoFvbpqLUNNBNhcfnAGXrbCZHCtc3ld023ibY2rROoPufYDzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;829&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.0913770913770913&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicngldHpdpkWmEIEHVLaBxiaHxxLNRB5CtkggzGDZSWcCgZZxITvLkFue6bFqnyXR6Q8dqTCIaictgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;777&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;形式数学涉及两个主要的挑战，使得单纯的强化学习应用不太可能成功：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. 无限的动作空间：形式数学不仅有超大的搜索空间（比如像围棋），还有无限的动作空间。在搜索证明的每个步骤，模型的选择范围不是一组行为良好的有限动作，而是一组复杂且无限的策略，涉及必须生成的外生数学术语（例如，生成用作 witness 的数学命题)。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 缺乏自博弈（self-play）：与两人游戏相反，证明器不是与对手对抗，而是与一系列需要证明的命题对抗。当面对一个过于困难的命题时，没有明显的重构可以让证明器首先生成更容易处理的中间语句。这种不对称性阻止了在双人游戏中获得成功的自博弈算法的简单应用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在这项工作中，研究者通过从一个语言模型中采样动作来解决无限动作空间问题。语言模型能够生成策略调用以及通常需要作为参数的原始数学术语。对于自博弈的缺乏，他们观察到，自博弈在两人游戏中的关键作用是提供一个无监督的课程（curriculum）。因此，他们建议用一套不同难度的辅助问题命题（不需要证明）来代替这种无监督的课程。他们的实验结果表明，当这些辅助问题的难度变化足够大时，他们的训练程序就能够解决一系列越来越难的问题，最终推广到他们所关心的问题集。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;虽然这些结果非常令人兴奋，因为它们证明了深度学习模型在与形式系统交互时能够进行重要的数学推理，但在竞赛中，该证明器离最佳学生表现还差得很远。研究者表示，他们希望自己的工作将推动这一领域的研究，特别是针对 IMO 的研究，并希望他们提出的 statement curriculum learning 方法能够加快自动推理的研究进展。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;小结&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;两家机构最新的研究成果已经介绍完毕，网上已经零零散散地出现了关于效果的评价：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5180102915951973&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicngldHpdpkWmEIEHVLaBxiaGf6qsAebgcHtBODAfxTmxtyoUIVbBanyT4M2KREa5kJBZ04ufv3JvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;583&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如有 AI 研究科学家发系列长推表示，AlphaCode 达到人类水平还需要几年时间，它在 codeforce 上的排名是有限制的，如许多参与者是高中生或大学生；还有就是 AlphaCode 生成的绝大多数程序都是错误的，正是使用示例测试进行过滤才使得 AlphaCode 实际解决了某些问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;也有研究人员表示，这像是 AlphaStar 大力出奇迹的结果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9563758389261745&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicngldHpdpkWmEIEHVLaBxiaGy78PY3SAIjwYiaNMIOCwGr4Z9AdmKSbpfBgia0pX9hxTP01Epnbd2iag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;596&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;国内的 AI 从业者们可以趁假期研究下这两项研究，发表自己的看法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;参考链接：https://openai.com/blog/formal-math/?continueFlag=6cc759bbfb87d518f6d6948bcf276707&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://deepmind.com/blog/article/Competitive-programming-with-AlphaCode?continueFlag=b34ed7683541bab09a68d7ab1d608057&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.9140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9wks2iaceibuKpWOMEKSCOzczdfltrYpBzf9GWEbaZM1TkGvibLj6munq71o1JoGBVUtGyjBLOrKHwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;© THE END &lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;转载请联系本公众号获得授权&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;投稿或寻求报道：content@jiqizhixin.com&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>