<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f8028b4fcba6fdffdceecadd411cf538</guid>
<title>欢迎加入读者圈子，一起交流！</title>
<link>https://toutiao.io/k/92wl596</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎加入读者圈子，一起交流！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;圈子剧透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、600+圈子成员，以中高级程序员为主，更有架构师、CTO坐镇交流；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、1000+优质主题，数十G独家资料，每日分享，精挑细选；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、全年52期专属邮件周报，让你轻松掌握业界资讯、技术干货，提升认知水平；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、全年52本好书共读，让你花最少的时间，获取更好的知识；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如行动，赶快加入吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>66b33ecf05d37a61e5f20addc8186d98</guid>
<title>Facebook 是怎么保证缓存一致性的</title>
<link>https://toutiao.io/k/6agqjku</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;缓存有助于减少延迟，提高重读工作负载的可扩展性，并且节省成本。实际上缓存是无处不在的，它也在你的手机和你的浏览器中运行。例如，CDN和DNS本质上是地理复制的缓存。正是由于许多缓存在幕后工作，你现在才能阅读这篇文章。&lt;br/&gt;&lt;br/&gt;Phil Karlton有句名言：&quot;计算机科学中只有两个难题：缓存失效和命名&quot;。如果你曾经处理过的无效缓存，那么你很有可能遇到过缓存不一致这个恼人的问题。&lt;br/&gt;&lt;br/&gt;在Meta，我们运营着世界上最大的高速缓存，包括TAO和Memcache。多年来，我们将TAO的缓存一致性提高了一个档次，从99.9999%（六个九）提高到99.99999999%（十个九）。&lt;br/&gt;&lt;br/&gt;当涉及到缓存无效时，我们相信我们现在有一个有效的解决方案来弥补理论和实践之间的差距。这篇博文中的原则和方法广泛适用于大多数（如果不是所有）的缓存服务。无论你是在Redis中缓存Postgres数据，还是将分散数据具像化，都是如此。&lt;br/&gt;&lt;br/&gt;我们希望能帮助减少工程师必须处理的缓存失效问题，并帮助增强缓存的一致性。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;定义缓存失效和缓存一致性&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据定义，缓存并不是你数据的真实来源（例如，数据库）。缓存失效描述的是当真实源中的数据发生变化时，主动将陈旧的缓存条目失效的过程。如果缓存失效处理不当，就会在缓存中无限期地保留一个不一致的值。&lt;br/&gt;&lt;br/&gt;缓存失效涉及到一个必须由缓存自身以外的程序来执行的动作。一些程序（例如，客户端或公共/子系统）需要告诉缓存其中数据发生了变化。仅仅依靠TTL来保持有效性的缓存，不在本文讨论范围之内。在这篇文章的其余部分，我们将假设存在缓存失效操作。&lt;br/&gt;&lt;br/&gt;为什么这个看似简单的过程在计算机科学中被认为是个困难的问题？下面是个简单的例子，说明如何引入缓存不一致的问题。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.31171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8XkvNnTiapOM64gt2kf0PavSjTt9IV1XGQdrp2DZvv8w8438vHX6ncpxfFiaUPPhCfpCz1bGWq8ibCkbCDZrEmkCw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;缓存首先尝试从数据库中填充x。但是在 &quot;x=42 &quot;到达缓存主机之前，有人将x设置为43。缓存失效事件 &quot;x=43 &quot;首先到达缓存主机，将x设置为43。&quot;x=42 &quot;到达了缓存，将x设置为42。现在数据库中&quot;x=43 &quot;，而缓存中 &quot;x=42 &quot;。&lt;br/&gt;&lt;br/&gt;有很多方法来解决这个问题，其中之一就是维护版本字段。这样我们就可解决冲突，因为旧的数据不应该覆盖新的数据。但是，如果缓存条目 &quot;x=43 @version=2 &quot;在 &quot;x=42 &quot;到达之前就失效了呢？在这种情况下，缓存数据依然是错误的。&lt;br/&gt;&lt;br/&gt;缓存失效的挑战不仅来自于失效协议的复杂性，还来自于监控缓存一致性和如何确定缓存不一致的原因。设计一个一致的缓存与操作一个一致的缓存有很大不同，就像设计Paxos协议与构建在生产中实际运行的Paxos一样，都有很大区别。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;我们为什么要关心缓存的一致性&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们必须解决复杂的缓存失效问题吗？在某些情况下，缓存的不一致性几乎和数据库数据丢失一样严重。从用户的角度来看，它甚至和数据丢失没有区别。&lt;br/&gt;&lt;br/&gt;让我们来看看另一个关于缓存不一致如何导致脑裂的例子。Meta公司使用消息将其从用户在主存储数据的映射到TAO中。它经常进行移动，以保证用户可以就近访问。每次你向某人发送消息时，系统都会查询TAO，以找到消息的存储位置。许多年前，当TAO的一致性较差时，一些TAO副本在重新移动后会出现不一致的数据，如下例所示。&lt;br/&gt;&lt;br/&gt;想象一下，在将Alice的主消息存储从区域2切换到区域1后，Bob和Mary，都向Alice发送了消息。当Bob向Alice发送消息时，系统查询了靠近Bob居住地的区域的TAO副本，并将消息发送到区域1。当Mary向Alice发送消息时，系统查询了靠近Mary居住地的地区的TAO副本，命中了不一致的TAO副本，并将消息发送到了地区2。Bob和Mary将他们的消息发送到不同的区域，而两个区域都没有爱丽丝消息的完整副本。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8XkvNnTiapOM64gt2kf0PavSjTt9IV1XGFby1YSiaQLicGw7hicBgWayK94ib3IDcmlCiaiaf8CpZa0iaofhJqRkAvuAng/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;缓存失效模型&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.41796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8XkvNnTiapOM64gt2kf0PavSjTt9IV1XGlibAehZ9pdBswAO62iasibyKB7m5VloG9UmgI0XIrTlSG65Cia1jjJ2nOQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;了解缓存失效的困难之处尤其具有挑战性。让我们从一个简单的模型开始。缓存的核心是一个有状态的服务，它将数据存储在一个可寻址的存储介质中。分布式系统本质上是一种状态机。如果每个状态转换都能正确执行，我们就会有一个按预期工作的分布式系统。否则，系统就会问题。所以，关键的问题是：对于有状态的服务，什么在改数据？&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.490625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8XkvNnTiapOM64gt2kf0PavSjTt9IV1XGEd1TLOhQ8mut0TtV0P5JduWia3j2ubjMrUVV45hk9tnrOM1oclJHRSA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;静态缓存有一个非常简单的缓存模型（例如，简化的CDN接近这个模型）。数据是不可改变的。没有缓存主动失效。对于数据库来说，数据只有在写入（或复制）时才会发生变化。我们通常对数据库的每一个状态变化都有日志。每当发生异常时，日志可以帮助我们了解发生了什么，缩小问题的范围，并找出问题所在。构建容错的分布式数据库（这已经很困难了），有其独特的挑战。这些只是简化的模型。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.57734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8XkvNnTiapOM64gt2kf0PavSjTt9IV1XGcaAsHsRUyV7pdnwxlTLXhWsicDrFics3r1iaGzOTBiciafiaUuYKII07DdTw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;对于像TAO和Memcache这样的动态缓存，数据在读取（缓存填充）和写入（缓存失效）的路径上都会发生变化。这种组合使得多竞态条件成为可能，而缓存失效则是一个困难的问题。缓存中的数据是不持久的，这意味着有时候对解决冲突很重要的版本信息会被清除出去。结合所有这些特点，动态缓存产生的竞态条件超出了我们的想象。&lt;br/&gt;&lt;br/&gt;而且，记录和跟踪每一个缓存状态的变化几乎是不现实的。缓存经常被引入来扩展重读的工作负载。这意味着大部分的缓存状态变化都来自缓存填充路径。以TAO为例。它每天提供超过四亿次的查询。即使缓存命中率达到99%，我们每天也要进行超过10万亿次的缓存填充。记录和追踪所有的缓存状态变化会使一个重读的缓存工作负载变成一个极重写的日志系统工作负载。调试一个分布式系统已经带来了巨大的挑战。调试一个没有缓存状态变化的日志或追踪的分布式系统，基本是不可能的。&lt;br/&gt;&lt;br/&gt;尽管有这些挑战，我们还是提高了TAO的缓存一致性，这些年来从99.9999提高到99.99999999。在文章的其余部分，我们将解释我们是如何做到的，并强调一些未来的工作。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;针对一致性的可观察性&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决缓存失效和缓存一致性问题，第一步涉及测量。我们要测量高速缓存的一致性，并在高速缓存中出现不一致的条目时发出警报。测量不能包含任何假阳性。人类的大脑可以很容易地调出噪音。如果存在任何误报，人们很快就会学会忽略它，而这个测量也变得毫无用处。我们还需要测量是精确的，因为我们谈论的是测量超过10个九的一致性。如果一个修正已经落地，我们要保证我们可以定量地测量它带来的改进。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8XkvNnTiapOM64gt2kf0PavSjTt9IV1XGzPzGkS6aPLAr5iaJ8ILQKjFPZDKicrCpFIlOyYY1ibd3ooMKwkl5kGvCA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;为了解决测量问题，我们建立了一个名为Polaris的服务。对于一个有状态的服务中的任何异常，只有当客户能够以这种或那种方式观察到它，它才是一个异常。否则，它就根本不重要。基于这一原则，Polaris 专注于测量违反客户可观察不变量的情况。&lt;br/&gt;&lt;br/&gt;在高层次上，Polaris作为客户端与有状态的服务进行交互，并且不假设了解服务内部。这使得它是通用的。Meta有几十个服务使用Polaris。&quot;缓存最终应该与数据库一致 &quot;是Polaris监控的一个典型的客户端可观察到的不变因素，特别是在异步缓存失效的情况下。在这种情况下，Polaris假装是一个缓存服务器并接收缓存失效事件。例如，如果Polaris收到一个无效事件，说 &quot;x=4 @version 4&quot;，它就会作为客户查询所有的缓存副本，以验证是否有任何违反该不变性的情况发生。如果一个缓存副本返回 &quot;x=3 @version 3&quot;，Polaris将其标记为不一致，并重新等待样本，以便以后针对同一目标缓存主机进行检查。Polaris在某些时间尺度上报告不一致，例如一分钟、五分钟或十分钟。如果这个样本在一分钟后仍然显示为不一致，Polaris就将其报告为相应时间尺度的不一致。&lt;br/&gt;&lt;br/&gt;这种多时间尺度的设计不仅允许Polaris在内部存在多个队列，以有效地实现回退和重试，而且对于防止产生误报也是至关重要的。&lt;br/&gt;&lt;br/&gt;我们来看看一个更有趣的例子。假设Polaris收到一个 &quot;x=4 @version 4 &quot;的无效信息。但是当它查询一个缓存副本时，得到的答复是x不存在。目前还不清楚Polaris是否应该将此作为一个不一致的标记。有可能x在版本3的时候是不存在的，版本4的写入是对key的最新写入，而这种情况确实是缓存不一致。也有可能是第5个版本的操作删除了x，也许Polaris只是看到了失效事件中的数据更新的视图。&lt;br/&gt;&lt;br/&gt;为了区分这两种情况，我们需要绕过缓存，检查数据库中的内容。绕过缓存的查询是非常密集的运算。它们也会使数据库面临风险，因为保护数据库和扩展重读工作负载是缓存最常见的用例之一。因此，我们不能绕过缓存发送太多的查询。Polaris通过延迟执行计算密集型操作来解决这个问题，直到不一致的样本跨越报告时间尺度（如一分钟或五分钟）。真正的缓存不一致和对同一key的竞争写操作是很少的。因此，在它跨越下一个时间尺度边界之前才进行一致性检查有助于消除执行大部分数据库查询。&lt;br/&gt;&lt;br/&gt;我们还在Polaris发给缓存服务器的查询中加入了一个特殊的标志。因此，Polaris会知道目标缓存服务器是否已经看到并处理了缓存失效事件。这一点信息使Polaris能够区分瞬时的缓存不一致（通常由复制/验证滞后引起）和 &quot;永久 &quot;的缓存不一致(旧版本还无限期地存在于缓存中)。&lt;br/&gt;&lt;br/&gt;Polaris也提供观测指标，如&quot;N个9的缓存写入在M分钟内是一致的&quot;。在文章的开头，我们提到，通过一项改进，我们将TAO的缓存一致性从99.9999%提高到99.99999999%。Polaris提供了5分钟时间尺度的指标。换句话说，99.99999999%的缓存写入在5分钟内是一致的。在TAO中5分钟内，100亿次缓存写入中不到1次会出现不一致。&lt;br/&gt;&lt;br/&gt;我们将Polaris部署为一个单独的服务，这样它就可以独立于生产服务及其工作负载进行扩展。如果我们想测量到更多的数据，我们可以只增加Polaris的吞吐量或在更长的时间窗口上执行聚合。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;一致性追踪&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在大多数图中，我们用一个简单的盒子来表示缓存。在现实中，省略了许多依赖关系和数据流之后，看起来可能像这样。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.54296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8XkvNnTiapOM64gt2kf0PavSjTt9IV1XGZR1icQS64ia0wxibbWiciaR6lTYGUEib5Eibk0FibuV0maZao6LtkrtfYBh9gg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;缓存可以在不同的时间点从不同的上游填充，这些上游可以是在同一region内或跨region。升级、分片移动、故障恢复、网络分区和硬件故障都有可能触发导致缓存不一致的问题。&lt;br/&gt;&lt;br/&gt;然而，正如前面提到的，记录和追踪每一个缓存数据的变化是不切实际的。但是，如果我们只在缓存不一致的地方和时候（或者缓存失效可能被错误地处理）记录和跟踪缓存的突变，会怎么样呢？在这个庞大而复杂的分布式系统中，任何组件的缺陷都可能导致缓存不一致，是否有可能找到一个引入大部分（如果不是全部）缓存不一致的地方？&lt;br/&gt;&lt;br/&gt;我们的任务变成了寻找一个简单的解决方案来帮助我们管理这种复杂性。我们想从单个缓存服务器的角度来评估整个缓存一致性问题。最后，不一致的问题必须在一个缓存服务器上出现。从它的角度来看，它只关心几个方面。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;它是否收到了失效信息？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;它是否正确地处理了这个失效信息？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;之后缓存是否变得不一致了？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.490625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8XkvNnTiapOM64gt2kf0PavSjTt9IV1XGUK3epnxUB56eia3iad3AQQkNLuYNwjyCSRmZCDhGs3szgAOaeMQnZFpQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;这就是我们在文章开头解释的那个例子，现在用一个时空图来说明。如果我们把注意力集中在底部的缓存时间轴上，我们可以看到在客户端写完之后，有一个窗口，在这个窗口中，失效和缓存填充都在竞争更新缓存。一段时间后，缓存将处于静止状态。在这种状态下，缓存的填充仍然会大量发生，但从一致性的角度来看，由于没有写入，它已经沦为一个静态的缓存，所以它的意义不大。&lt;br/&gt;&lt;br/&gt;我们建立了一个有状态的库，记录和跟踪这个小的紫色窗口中的缓存突变，在这个窗口中，所有相关的复杂交互都会引发导致缓存不一致的问题。它涵盖了缓存的过期，甚至没有日志也能告诉我们是否无效事件从未到达。它被嵌入到几个主要的缓存服务中，并贯穿于整个失效管道。它缓冲了最近修改的数据索引，用于确定后续的缓存状态变化是否应该被记录下来。它还支持代码追踪，所以我们会知道每个被追踪查询的确切代码路径。&lt;br/&gt;&lt;br/&gt;这种方法帮助我们发现并修复了许多缺陷。它为诊断缓存的不一致提供了一个系统性的、更可扩展的方法。事实证明，它非常有效。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;我们今年发现并修复的一个线上错误&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.37265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8XkvNnTiapOM64gt2kf0PavSjTt9IV1XGWnLgMaXCTQ3dWGVicQwlLn1or4JYic0F60bTj09JIPTGbJFWWsk9CTJg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;在一个系统中，我们对每条数据进行了版本排序和冲突解决。在这种情况下，我们在缓存中观察到 &quot;metadata=0 @version4&quot;，而数据库中包含 &quot;metadata=1 @version4&quot;。缓存无限期地保持不一致。这种状态应该是不可能的。你会如何处理这个问题？如果我们能得到导致最终不一致状态的每一个步骤的完整时间线，那该有多好？&lt;br/&gt;&lt;br/&gt;一致性追踪正好提供了我们需要的时间线。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.37734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8XkvNnTiapOM64gt2kf0PavSjTt9IV1XGzmib3ZFBUHvypxA685prqEEEIYjYSxTtia8wUJicCT3vvticxiapDmiagTbg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;在系统中，一个非常罕见的操作以事务方式更新了底层数据库的两个表—元数据表和版本表。&lt;br/&gt;&lt;br/&gt;根据一致性追踪，我们知道发生了以下情况。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;缓存试图添加版本数据和元数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在第一轮中，缓存首先填充了旧的元数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接下来，一个写事务以原子方式更新了元数据表和版本表。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在第二轮中，缓存写入了新的版本数据。这里，缓存填充操作与数据库事务交错进行。因为竞态窗口很小，所以这种情况很少发生。你可能会想，&quot;这就是bug。&quot;。但是实际上到目前为止，一切都按预期进行，因为缓存失效应该可以把缓存恢复一致。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;稍后，在尝试将缓存项更新为新元数据和新版本时，出现了缓存无效。这几乎总是有效的，但这次没有。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;缓存失效在缓存主机上遇到了一个罕见的瞬时错误，这触发了错误处理代码。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;错误处理程序将该条目删除。伪代码看起来是这样的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;drop_cache(key, version);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果条目的版本低于指定的版本，则将其放入缓存。但是，不一致的缓存项包含最新版本。所以这段代码什么也没做，将过时的元数据无限期地留在缓存中。这就是bug。我们在这里把这个例子简化了很多。实际的bug甚至更加复杂，涉及到数据库复制和跨区域通信。只有当以上所有的步骤都发生，并且以这个顺序具体发生时，这个bug才会被触发。不一致的情况很少出现。该错误隐藏在交互操作和瞬时错误背后的错误处理代码中。&lt;br/&gt;&lt;br/&gt;许多年前，如果有人对代码和服务了如指掌并且他们足够幸运的话，要花几周时间才能找到这种错误的根本原因。在这种情况下，Polaris发现了异常情况，并立即发出警报。通过一致性追踪的信息，值班工程师花了不到30分钟就可以找到这个错误。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;未来的缓存一致性工作&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们已经分享了我们如何用一种通用的、系统的、可扩展的方法来增强我们的缓存一致性。展望未来，我们想让我们所有缓存的一致性在物理上尽可能地接近100%。分散的二级指数的一致性带来了一个有趣的挑战。我们也在测量并有目的地改善读取时的缓存一致性。最后，我们正在为分布式系统建立高水平的一致性API，想想针对分布式系统的C++的std::memory_order。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原文链接：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://engineering.fb.com/2022/06/08/core-data/cache-invalidation/?continueFlag=5d7598b8068e4850d16d3bc686805488&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考阅读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;本文由高可用架构翻译。技术原创及架构实践文章，欢迎通过公众号菜单「联系我们」进行投稿。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;活动预告&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;↓&lt;span&gt;↓&lt;span&gt;↓&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6133333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOPZD13CEzFeLiaWJl9icbazMdaAf95oSdj7OXva3ZaE5DLOmiaT1zG0LYiaB0Eqns9X3Z2uuLFatq6YaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;GIAC 全球互联网架构大会 2022 将于 7 月 22 - 23 日在深圳举行，本届 GIAC 议题共设置有 24 个专题，覆盖各类架构热点领域，每个主题由业内知名架构师、技术负责人等专家担任出品人，负责议题选取和质量把控。本次大会包括基础架构（由bilibili技术委员会主席毛剑担任出品人）和高并发&amp;amp;高可用（由菜鸟架构委员会主席钟勇担任出品人）等专题，将有更多本文相关内容演讲，点击阅读原文查看 GIAC 详细日程。&lt;/span&gt;&lt;/p&gt;&lt;p data-morpho-type=&quot;paragraph&quot; data-slate-node=&quot;element&quot;&gt;&lt;/p&gt;&lt;p data-morpho-type=&quot;paragraph&quot; data-slate-node=&quot;element&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;点击【&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;阅读原文&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;】，了解更多活动信息。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f3245593491d5a22af72c050fdb6c186</guid>
<title>高并发下如何防重？</title>
<link>https://toutiao.io/k/m1fi6au</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最近测试给我提了一个 bug，说我之前提供的一个批量复制商品的接口，产生了重复的商品数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;追查原因之后发现，这个事情没想象中简单，可以说一波多折。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1. 需求&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;产品有个需求：&lt;strong&gt;用户选择一些品牌，点击确定按钮之后，系统需要基于一份默认品牌的商品数据，复制出一批新的商品&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;拿到这个需求时觉得太简单了，三下五除二就搞定。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我提供了一个复制商品的基础接口，给商城系统调用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当时的流程图如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2962382445141066&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74v073cEphxgnuialQdxJ1APTqGmxga34icfB9dD7VVPPq7rjYbYF7Pdyqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1276&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果每次复制的商品数量不多，使用同步接口调用的方案问题也不大。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2. 性能优化&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但由于每次需要复制的商品数量比较多，可能有几千。&lt;/span&gt;&lt;span&gt;如果每次都是用同步接口的方式复制商品，可能会有性能问题。&lt;/span&gt;&lt;span&gt;因此，后来我把复制商品的逻辑改成使用 MQ &lt;/span&gt;&lt;span&gt;异步处理。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;改造之后的流程图：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25058823529411767&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vGmIG2UQ0ACq9ibuIG9mV02Bjdjtw4ibmE06BJucicvkBTaAgibNuEeLdsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1700&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;复制商品的结果还需要通知商城系统：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4166666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vfCDzNOsHJ1a6TElFvSNKEEA8B7320Rhm2hje3tib4B8cdGUzMHK94KQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1128&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个方案看起来，挺不错的。&lt;/span&gt;&lt;span&gt;但后来出现问题了。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;3. 出问题了&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;测试给我们提了一个 bug，说我之前提供的一个批量复制商品的接口，产生了重复的商品数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;经过追查之后发现，商城系统为了性能考虑，也改成异步了。&lt;/span&gt;&lt;span&gt;他们没有在接口中直接调用基础系统的复制商品接口，而是在 &lt;/span&gt;&lt;span&gt;job &lt;/span&gt;&lt;span&gt;中调用的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;站在他们的视角流程图是这样的&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28144458281444584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vibicaial4QeBQweXfssQVwcqaMnTPY52iaBOGzRd6GuajlLDmicAsHKq0Pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1606&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;用户调用商城的接口，他们会往请求记录表中写入一条数据，然后在另外一个 job 中，异步调用基础系统的接口去复制商品。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但&lt;strong&gt;实际情况&lt;/strong&gt;是这样的：商城系统内部出现了 bug，在请求记录表中，同一条请求产生了重复的数据。这样导致的结果是，在 job 中调用基础系统复制商品接口时，发&lt;strong&gt;送了重复的请求&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;刚好，基础系统现在是使用 RocketMQ 异步处理的。由于商城的 job 一次会取一批数据（比如 20 条记录），在极短的时间内（其实就是在一个 for 循环中）多次调用接口，可能存在相同的请求参数连续调用复制商品接口情况。于是，出现了并发插入重复数据的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;为什么会出现这个问题呢？&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;4. 多线程消费&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;RocketMQ 的消费者，为了性能考虑，默认是用多线程并发消费的，最大支持 64 个线程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@RocketMQMessageListener&lt;/span&gt;(topic = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;${com.susan.topic:PRODUCT_TOPIC}&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        consumerGroup = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;${com.susan.group:PRODUCT_TOPIC_GROUP}&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MessageReceiver&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;RocketMQListener&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__title&quot;&gt;MessageExt&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;onMessage&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(MessageExt message)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        String message = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; String(message.getBody(), StandardCharsets.UTF_8);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        doSamething(message);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;也就是说，如果在极短的时间内，连续发送重复的消息，就会被不同的线程消费。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;即使在代码中有这样的判断：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Product oldProduct = query(hashCode);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(oldProduct == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    productMapper.insert(product);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在插入数据之前，先判断该数据是否已经存在，只有不存在才会插入。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但由于在并发情况下，不同的线程都判断商品数据不存在，于是同时进行了插入操作，所以就产生了重复数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.432601880877743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vqwIZ9vSeRvxOrn1vhCYibVaGM9Zz9z9sTlu9LrDFUoCROAiaMN4k81Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;638&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;5. 顺序消费&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了解决上述并发消费重复消息的问题，我们从两方面着手：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;商城系统修复产生重复记录的 bug；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基础系统将消息改成单线程顺序消费。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我仔细思考了一下，如果只靠商城系统修复 bug，以后很难避免不出现类似的重复商品问题。比如，如果用户在极短的时间内点击创建商品按钮多次，或者商城系统主动发起重试。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，基础系统还需进一步处理。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实 RocketMQ 本身是支持顺序消费的，需要消息的生产者和消费者一起改。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;生产者改为：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;rocketMQTemplate.asyncSendOrderly(topic, message, hashKey, &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; SendCallback() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;onSuccess&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(SendResult sendResult)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      log.info(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;sendMessage success&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;onException&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Throwable e)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      log.error(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;sendMessage failed!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;重点是要调用 rocketMQTemplate 对象的 asyncSendOrderly 方法，发送顺序消息。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;消费者改为：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@RocketMQMessageListener&lt;/span&gt;(topic = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;${com.susan.topic:PRODUCT_TOPIC}&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        consumeMode = ConsumeMode.ORDERLY,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        consumerGroup = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;${com.susan.group:PRODUCT_TOPIC_GROUP}&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MessageReceiver&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;RocketMQListener&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__title&quot;&gt;MessageExt&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;onMessage&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(MessageExt message)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        String message = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; String(message.getBody(), StandardCharsets.UTF_8);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        doSamething(message);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接收消息的重点是 RocketMQMessageListener 注解中的 consumeMode 参数，要设置成 ConsumeMode.ORDERLY，这样就能顺序消费消息了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;修改后关键流程图如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.2842105263157895&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vmDcibWsNfwwiag30A8LHM0UIjibtV9tDYv9HFmL6xQuDxNe5MFfxC7kjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;两边都修改之后，复制商品这一块就没有再出现重复商品的问题了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;But，修完 bug 之后，我又思考了良久。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;复制商品只是创建商品的其中一个入口，如果有其他入口，跟复制商品功能同时创建新商品呢？&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;不也会出现重复商品问题？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;虽说，这种概率非常非常小。&lt;/span&gt;&lt;span&gt;但如果一旦出现重复商品问题，后续涉及到要合并商品的数据，非常麻烦。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;经过这一次的教训，一定要防微杜渐。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不管是用户，还是自己的内部系统，从不同的入口创建商品，都需要解决重复商品创建问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么，如何解决这个问题呢？&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;6. 唯一索引&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;解决重复商品数据问题，最快成本最低最有效的办法是：给表建唯一索引。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;想法是好的，但我们这边有个规范就是：业务表必须都是逻辑删除。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而我们都知道，要删除表的某条记录的话，如果用 delete 语句操作的话。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; product &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种 delete 操作是物理删除，即该记录被删除之后，后续通过 SQL 语句基本查不出来。（不过通过其他技术手段可以找回，那是后话了）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;还有另外一种是逻辑删除，主要是通过 update 语句操作的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;update&lt;/span&gt; product &lt;span class=&quot;code-snippet__keyword&quot;&gt;set&lt;/span&gt; delete_status=&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;,edit_time=&lt;span class=&quot;code-snippet__keyword&quot;&gt;now&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;逻辑删除需要在表中额外增加一个删除状态字段，用于记录数据是否被删除。在所有的业务查询的地方，都需要过滤掉已经删除的数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过这种方式删除数据之后，数据任然还在表中，只是从逻辑上过滤了删除状态的数据而已。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实对于&lt;strong&gt;这种逻辑删除的表，是没法加唯一索引的&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设之前给商品表中的 name 和 model 加了唯一索引，如果用户把某条记录删除了， delete_status 设置成 1 了。后来，该用户发现不对，又重新添加了一模一样的商品。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由于唯一索引的存在，该用户第二次添加商品会失败，即使该商品已经被删除了，也没法再添加了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个问题显然有点严重。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有人可能会说：把 name、model 和 delete_status 三个字段同时做成唯一索引不就行了？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答：这样做确实可以解决用户逻辑删除了某个商品，后来又重新添加相同的商品时，添加不了的问题。但如果第二次添加的商品，又被删除了。该用户第三次添加相同的商品，不也出现问题了？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由此可见，如果表中有逻辑删除功能，是不方便创建唯一索引的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;7. 分布式锁&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来，你想到的第二种解决数据重复问题的办法可能是：加分布式锁。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;目前最常用的性能最高的分布式锁，可能是 Redis 分布式锁了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用 &lt;span&gt;Redis &lt;/span&gt;分布式锁的伪代码如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  String result = jedis.&lt;span class=&quot;code-snippet__keyword&quot;&gt;set&lt;/span&gt;(lockKey, requestId, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;PX&quot;&lt;/span&gt;, expireTime);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;OK&quot;&lt;/span&gt;.equals(result)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      doSamething();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    unlock(lockKey,requestId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不过需要在 finally 代码块中释放锁。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中 lockKey 是由商品表中的 name 和 model 组合而成的，requestId 是每次请求的唯一标识，以便于它每次都能正确得释放锁。还需要设置一个过期时间 expireTime，防止释放锁失败，锁一直存在，导致后面的请求没法获取锁。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果只是单个商品，或者少量的商品需要复制添加，则加分布式锁没啥问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主要流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.8079470198675496&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vGcexEIvtOkk5Jfh2JwW8cvMKIibvp3JvHQdQoia82efOcepStGicuTNcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;604&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以在复制添加商品之前，先尝试加锁。如果加锁成功，则在查询商品是否存在，如果不存在，则添加商品。此外，在该流程中如果加锁失败，或者查询商品时不存在，则直接返回。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;加分布式锁的目的是：保证查询商品和添加商品的两个操作是原子性的操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但现在的问题是，我们这次需要复制添加的商品数量很多，如果每添加一个商品都要加分布式锁的话，会非常影响性能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;显然对于批量接口，加 Redis 分布式锁，不是一个理想的方案。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;8. 统一 MQ 异步处理&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前面我们已经聊过，在批量复制商品的接口，我们是通过 RocketMQ 的顺序消息，单线程异步复制添加商品的，可以暂时解决商品重复的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但那只改了一个添加商品的入口，还有其他添加商品的入口。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;能不能把添加商品的底层逻辑统一一下，最终都调用同一段代码。然后通过 RocketMQ 的顺序消息，单线程异步添加商品。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主要流程如下图所示&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6787762906309751&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vp4QahsQibEx0YLVVX1xLYMzETZOdC0LNJP9VwkNo5MxANC3moic6ZZ2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样确实能够解决重复商品的问题。&lt;/span&gt;&lt;span&gt;但同时也&lt;/span&gt;&lt;span&gt;带来了另外两个问题：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;现在所有的添加商品功能都改成异步了，之前同步添加商品的接口如何返回数据呢？这就需要修改前端交互，否则会影响用户体验；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;之前不同的添加商品入口，是多线程添加商品的，现在改成只能由一个线程添加商品，这样修改的结果导致添加商品的整体效率降低了。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由此，综合考虑了一下各方面因素，这个方案最终被否定了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;9. insert on duplicate key update&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实，在 MySQL 中存在这样的语法，即 insert on duplicate key update。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在添加数据时，&lt;/span&gt;&lt;span&gt;&lt;span&gt;MySQL&lt;/span&gt; 发现数据不存在，则直接 insert。&lt;/span&gt;&lt;span&gt;如果发现数据已经存在了，则做 update 操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不过要求表中存在唯一索引或 PRIMARY KEY。这样当这两个值相同时，才会触发更新操作，否则是插入。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在的问题是 PRIMARY KEY 是商品表的主键，是根据雪花算法提前生成的，不可能产生重复的数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但由于商品表有逻辑删除功能，导致唯一索引在商品表中创建不了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由此，insert on duplicate key update 这套方案，暂时也没法用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此外，insert on duplicate key update 在&lt;strong&gt;高并发的情况下，可能会产生死锁问题&lt;/strong&gt;，需要特别注意一下。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;10. insert ignore&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 &lt;span&gt;MySQL &lt;/span&gt;中还存在这样的语法，即 insert ... ignore。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 insert 语句执行的过程中：&lt;span&gt;MySQL &lt;/span&gt;发现如果数据重复了，就忽略，否则就会插入。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它主要是用来忽略，插入重复数据产生的 Duplicate entry &#x27;XXX&#x27; for key &#x27;XXXX&#x27; 异常的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不过也要求表中存在唯一索引或 PRIMARY KEY。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但由于商品表有逻辑删除功能，导致唯一索引在商品表中创建不了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由此可见，这个方案也不行。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;温馨的提醒一下，使用 insert ... ignore 也有可能会导致死锁。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;11. 防重表&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;之前聊过，因为有逻辑删除功能，给商品表加唯一索引，行不通。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;后面又说了加分布式锁，或者通过 MQ 单线程异步添加商品，影响创建商品的性能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么，如何解决问题呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们能否换一种思路，加一张防重表，在防重表中增加商品表的 name 和 model 字段作为唯一索引。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;`product_unique`&lt;/span&gt; (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;20&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;id&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`name`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;130&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;名称&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`model`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;255&lt;/span&gt;)  &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;规格&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`user_id`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;20&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;创建用户id&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`user_name`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;30&lt;/span&gt;)  &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;创建用户名称&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`create_date`&lt;/span&gt; datetime(&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;创建时间&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  PRIMARY &lt;span class=&quot;code-snippet__keyword&quot;&gt;KEY&lt;/span&gt; (&lt;span class=&quot;code-snippet__string&quot;&gt;`id`&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;UNIQUE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;`ux_name_model`&lt;/span&gt; (&lt;span class=&quot;code-snippet__string&quot;&gt;`name`&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;`model`&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;ENGINE&lt;/span&gt;=&lt;span class=&quot;code-snippet__keyword&quot;&gt;InnoDB&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;CHARSET&lt;/span&gt;=utf8mb4 &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;商品防重表&#x27;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中表中的id可以用商品表的 id，表中的 name 和 model 就是商品表的 name 和 model，不过在这张防重表中增加了这两个字段的唯一索引。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;视野一下子被打开了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在添加商品数据之前，先添加防重表。如果添加成功，则说明可以正常添加商品，如果添加失败，则说明有重复数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;防重表添加失败，后续的业务处理，要根据实际业务需求而定。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果业务上允许添加一批商品时，发现有重复的，直接抛异常，则可以提示用户：“系统检测到重复的商品，请刷新页面重试&lt;span&gt;”&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  transactionTemplate.execute((status) -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      productUniqueMapper.batchInsert(productUniqueList);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      productMapper.batchInsert(productList);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Boolean&lt;/span&gt;.TRUE;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt;(DuplicateKeyException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; BusinessException(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;系统检测到重复的商品，请刷新页面重试&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在批量插入数据时，如果出现了重复数据，捕获 DuplicateKeyException 异常，转换成 BusinessException 这样运行时的业务异常。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;还有一种业务场景，要求即使出现了重复的商品，也不抛异常，让业务流程也能够正常走下去。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  transactionTemplate.execute((status) -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      productUniqueMapper.insert(productUnique);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      productMapper.insert(product);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Boolean&lt;/span&gt;.TRUE;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt;(DuplicateKeyException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   product = productMapper.query(product);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在插入数据时，如果出现了重复数据，则捕获 DuplicateKeyException，在 catch 代码块中再查询一次商品数据，将数据库已有的商品直接返回。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果调用了同步添加商品的接口，这里&lt;strong&gt;非常关键的一点&lt;/strong&gt;，是要返回已有数据的 id，业务系统做后续操作，要拿这个 id 操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然在执行 execute 之前，还是需要先查一下商品数据是否存在，如果已经存在，则直接返回已有数据，如果不存在，才执行 execute 方法。这一步千万不能少。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Product oldProduct = productMapper.query(product);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(Objects.nonNull(oldProduct)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; oldProduct;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  transactionTemplate.execute((status) -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      productUniqueMapper.insert(productUnique);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      productMapper.insert(product);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Boolean&lt;/span&gt;.TRUE;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt;(DuplicateKeyException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   product = productMapper.query(product);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; product;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;千万注意：防重表和添加商品的操作必须要在同一个事务中，否则会出问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;顺便说一下，还需要对商品的删除功能做特殊处理一下，在逻辑删除商品表的同时，要物理删除防重表。用商品表 id 作为查询条件即可。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;说实话，解决重复数据问题的方案挺多的，没有最好的方案，只有最适合业务场景的，最优的方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651513304&amp;amp;idx=1&amp;amp;sn=230e9d2c35b0c8a2e7c79d7a7436a854&amp;amp;chksm=bd258da78a5204b192f6804d04dc337d8670e055191b3aa54ae7d2bbb94be6f2456e8dc6953c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;优雅地处理重复请求（并发请求）&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;优雅地处理重复请求（并发请求）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651510835&amp;amp;idx=1&amp;amp;sn=4210d78b8ca703b7017fa4aac211cdab&amp;amp;chksm=bd25b44c8a523d5a08ca3ae408b684129946c306f0eb27049e53d2cf64e2c3c666dc01b58f58&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Spring Cloud Stream整合Rabbit之重复投递&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Spring Cloud Stream整合Rabbit之重复投递&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651489365&amp;amp;idx=1&amp;amp;sn=d1a8bd439fbee22d7be047839e11ee77&amp;amp;chksm=bd25e82a8a52613c203e62cb1e6cd58c367add5f6999ac90799ad1b1bbb0ac0eb417dd7af81b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;消息队列面试连环问：如何保证消息不丢失？处理重复消息？消息有序性？消息堆积处理？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;消息队列面试连环问：如何保证消息不丢失？处理重复消息？消息有序性？消息堆积处理？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fc28a115e21d45b51c9845072a45de6b</guid>
<title>Python机器学习：适合新手的8个项目</title>
<link>https://toutiao.io/k/dns1z81</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;再多的理论也不能代替动手实践。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;教科书和课程会让你误以为精通，因为材料就在你面前。但当你尝试去应用它时，可能会发现它比看起来更难。而「项目」可帮助你快速提高应用的 ML 技能，同时让你有机会探索有趣的主题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此外，你可以将项目添加到你的投资组合中，从而更轻松地找到工作，找到很酷的职业机会，甚至协商更高的薪水。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在这篇文章中，我们将&lt;span&gt;&lt;strong&gt;为初学者介绍 8 个有趣的机器学习项目。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;你&lt;/span&gt;可以在一个周末完成其中的任何一个，或者如果你很喜欢它们，可以将它扩展为更长的项目。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;1、机器学习角斗士&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们亲切地称其为「机器学习角斗士」，但它并不新鲜。这是围绕机器学习建立 实用 直觉的最快方法之一。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目标是&lt;strong&gt;采用开箱即用&lt;/strong&gt;的模型并将其应用于不同的数据集。这个项目很棒有 3 个主要原因：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先，你将建立模型与问题拟合的直觉。哪些模型对缺失数据具有鲁棒性？哪些模型可以很好地处理分类特征？是的，你可以翻阅教科书来寻找答案，但是通过实际操作您会学得更好。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其次，这个项目将教你快速制作原型的宝贵技能。在现实世界中，如果不简单地尝试它们，通常很难知道哪种模型表现最好。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后，本练习可以帮助你掌握模型构建的&lt;strong&gt;工作流程&lt;/strong&gt;。例如，你将开始练习……&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;导入数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;清理数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;将其拆分为训练/测试或交叉验证集&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;预处理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;转型&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;特征工程&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为你将使用开箱即用的模型，你将有机会专注于磨练这些关键步骤。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;查看 sklearn (Python) 或 caret (R) 文档页面以获取说明。你应该练习&lt;strong&gt;回归、 分类和聚类算法。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;教程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• Python: sklearn&lt;/strong&gt;  – sklearn包 的官方教程&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 使用 Scikit-Learn 预测葡萄酒质量&lt;/strong&gt;——训练机器学习模型的分步教程&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• R: caret&lt;/strong&gt;  – 由 caret 包的作者提供的网络研讨会&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• UCI 机器学习存储库&lt;/strong&gt; ——350 多个可搜索的数据集，涵盖几乎所有主题。您一定会找到您感兴趣的数据集。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• Kaggle 数据集&lt;/strong&gt;——Kaggle 社区上传的 100 多个数据集。这里有一些非常有趣的数据集，包括 PokemonGo 产卵地点和圣地亚哥的墨西哥卷饼。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• data.gov&lt;/strong&gt; ——美国政府发布的开放数据集。如果您对社会科学感兴趣，可以去看看。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、玩钱球&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在《点球成金》一书中 ，奥克兰 A 队通过分析球员球探彻底改变了棒球运动。他们建立了一支有竞争力的球队，而只花费了洋基队等大型市场球队支付薪水的 1/3。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先，如果你还没有读过这本书，你应该去看看。这是我们的最爱之一！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;幸运的是，体育界有大量数据可供使用。球队、比赛、比分和球员的数据都可以在线跟踪和免费获取。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于初学者来说，有很多有趣的机器学习项目。例如，您可以尝试……&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 体育博彩……&lt;/strong&gt;根据每场新比赛前的可用数据预测盒子得分。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 人才球探……&lt;/strong&gt; 使用大学统计数据来预测哪些球员将拥有最好的职业生涯。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 综合管理...... &lt;/strong&gt;根据他们的优势创建球员集群，以建立一个全面的团队。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;体育也是练习&lt;strong&gt;数据可视化&lt;/strong&gt;和&lt;strong&gt;探索性分析&lt;/strong&gt;的绝佳领域。你可以使用这些技能来帮助您决定要在分析中包含哪些类型的数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 体育统计数据库 &lt;/strong&gt;——体育统计和历史数据，涵盖了许多职业运动和一些大学运动。干净的界面使网页抓取更容易。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• Sports Reference &lt;/strong&gt; – 另一个体育统计数据库。界面更杂乱，但可以将单个表格导出为 CSV 文件。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• cricsheet.org &lt;/strong&gt;– 国际和 IPL 板球比赛的逐球数据。提供 IPL 和 T20 国际比赛的 CSV 文件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、预测股票价格&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于任何对金融感兴趣的数据科学家来说，股票市场就像是糖果乐园。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先，您有多种类型的数据可供选择。您可以找到价格、基本面、全球宏观经济指标、波动率指数等……不胜枚举。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其次，数据可能非常精细。您可以轻松获取每家公司按天（甚至按分钟）的时间序列数据，从而让您创造性地思考交易策略。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后，金融市场通常具有较短的反馈周期。因此，您可以快速验证您对新数据的预测。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;你可以尝试的一些适合初学者的机器学习项目示例包括……&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 量化价值投资……&lt;/strong&gt; 根据公司季度报告的基本面指标预测 6 个月的价格走势。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 预测…… &lt;/strong&gt;在隐含波动率和实际波动率之间的差值上构建时间序列模型，甚至是循环神经网络。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 统计套利…… &lt;/strong&gt;根据价格走势和其他因素找到相似的股票，并寻找价格出现分歧的时期。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;明显的免责声明：&lt;/span&gt;建立交易模型来练习机器学习很简单。让他们盈利是极其困难的。这里没有任何财务建议，我们不建议交易真钱。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;教程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• Python: sklearn for Investing – 将机器学习应用于投资的 YouTube 视频系列。&lt;/p&gt;&lt;p&gt;• R: Quantitative Trading with R – 使用 R 进行量化金融的详细课堂笔记。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• Quandl  – 提供免费（和优质）金融和经济数据的数据市场。例如，您可以批量下载3000 多家美国公司的日终股票价格 或美联储的经济数据。&lt;/p&gt;&lt;p&gt;• Quantopian – 量化金融社区，为开发交易算法提供免费平台。包括数据集。&lt;/p&gt;&lt;p&gt;• US Fundamentals Archive – 5000 多家美国公司的 5 年基本面数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;4、&lt;/strong&gt;&lt;strong&gt;教神经网络阅读笔迹&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;神经网络和深度学习是现代人工智能的两个成功案例。它们在图像识别、自动文本生成甚至自动驾驶汽车方面取得了重大进展。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;要涉足这个令人兴奋的领域，您应该从可管理的数据集开始。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;MNIST手写数字分类挑战赛&lt;/strong&gt;是经典的切入点。图像数据通常比「平面」关系数据更难处理。MNIST 数据对初学者很友好，并且小到可以放在一台计算机上。&lt;/p&gt;&lt;p&gt;手写识别会挑战你，但它不需要高计算能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先，我们建议使用下面教程中的第一章。它将教你如何从头开始构建神经网络，以高精度解决 MNIST 挑战。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;教程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• 神经网络和深度学习（在线书籍） ——第 1 章介绍了如何在 Python 中从头开始编写神经网络，以对来自 MNIST 的数字进行分类。作者还对神经网络背后的直觉给出了很好的解释。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• MNIST  – MNIST 是美国国家标准与技术研究院收集的两个数据集的修改子集。它包含 70,000 个带标签的手写数字图像。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;5、调查安然&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;安然丑闻和倒闭是历史上最大的 企业崩溃之一。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2000 年，安然是美国最大的能源公司之一。然后，在因欺诈而被揭露后，它在一年内螺旋式下降到破产。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;幸运的是，我们拥有安然电子邮件数据库。它包含 150 名前安然员工（主要是高级管理人员）之间的 50 万封电子邮件。它也是唯一一个真实电子邮件的大型公共数据库，这使得它更有价值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;事实上，数据科学家多年来一直在使用这个数据集进行教育和研究。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;您可以尝试的初学者机器学习项目示例包括……&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 异常检测…... &lt;/strong&gt;按小时绘制和接收电子邮件的分布图，并尝试检测导致公共丑闻的异常行为。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 社交网络分析…… &lt;/strong&gt;在员工之间建立网络图模型以找到关键影响者。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 自然语言处理……&lt;/strong&gt;结合电子邮件元数据分析正文消息，以根据电子邮件的目的对电子邮件进行分类。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 安然电子邮件数据集 &lt;/strong&gt;——这是由 CMU 托管的安然电子邮件存档。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 安然数据描述 (PDF)&lt;/strong&gt; – 对安然电子邮件数据的探索性分析，可以帮助您获得基础。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;6、从头开始编写 ML 算法&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从头开始编写机器学习算法是一种出色的学习工具，主要有两个原因。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先，没有更好的方法来建立对他们机制的真正理解。您将被迫考虑每一步，这将导致真正的掌握。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其次，您将学习如何将数学指令转换为工作代码。在从学术研究中调整算法时，您将需要这项技能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们建议选择不太复杂的算法。即使是最简单的算法，您也需要做出许多微妙的决定。在您熟悉构建简单算法后，尝试扩展它们以获得更多功能。例如，尝试通过添加正则化参数将普通&lt;strong&gt;逻辑回归&lt;/strong&gt;算法扩展为&lt;strong&gt;套索/岭回归。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后，这是每个初学者都应该知道的提示：不要气馁，因为您的算法不如现有软件包中的算法快或花哨。这些软件包是多年发展的成果！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;教程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• Python：从零开始的逻辑回归&lt;/p&gt;&lt;p&gt;• Python：从零开始的 k-最近邻&lt;/p&gt;&lt;p&gt;• R：从零开始的逻辑回归&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;7、&lt;/span&gt;&lt;/span&gt;挖掘社交媒体情绪&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于用户生成的内容数量庞大，社交媒体几乎已成为「大数据」的代名词。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;挖掘这些丰富的数据可以证明以前所未有的方式来掌握观点、趋势和公众情绪。Facebook、Twitter、YouTube、微信、WhatsApp、Reddit……这个名单还在继续。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此外，每一代人在社交媒体上花费的时间都比他们的前辈多。这意味着社交媒体数据将与营销、品牌和整个业务更加相关。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;虽然有许多流行的社交媒体平台，&lt;strong&gt;但Twitter 是练习机器学习的经典切入点。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用 Twitter 数据，您可以获得数据（推文内容）和元数据（位置、主题标签、用户、转发推文等）的有趣混合，为分析开辟了几乎无穷无尽的路径。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;教程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• Python：挖掘 Twitter 数据——如何对 Twitter 数据进行情绪分析&lt;/p&gt;&lt;p&gt;• R：使用机器学习进行情感分析——简短而甜蜜的情感分析教程&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• Twitter API  – twitter API 是流数据的经典来源。您可以跟踪推文、主题标签等。&lt;/p&gt;&lt;p&gt;• StockTwits API  – StockTwits 就像交易者和投资者的推特。 您可以通过使用时间戳和股票代码将其连接到时间序列数据集来以许多有趣的方式扩展此数据集 。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8、改善医疗保健&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于机器学习，另一个正在经历快速变化的行业是全球健康和医疗保健。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在大多数国家，成为一名医生需要多年的教育。这是一个要求高、工作时间长、风险高、进入门槛更高的领域。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因此，最近在机器学习的帮助下减轻医生的工作量并提高医疗保健系统的整体效率做出了重大努力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;用例包括：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 预防性护理…… &lt;/strong&gt;预测个人和社区层面的疾病爆发。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 诊断护理...... &lt;/strong&gt;自动对图像数据进行分类，例如扫描、X 射线等。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 保险……&lt;/strong&gt;根据公开的风险因素调整保险费。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;随着医院继续对患者记录进行现代化改造，并且随着我们收集更细化的健康数据，数据科学家将有大量唾手可得的机会来发挥作用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;教程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• R：为疾病预测构建有意义的机器学习模型&lt;/p&gt;&lt;p&gt;• 医疗保健中的机器学习——微软研究院的精彩演讲&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• 大型健康数据集——大型健康相关数据集的集合&lt;/p&gt;&lt;p&gt;• data.gov/health – 美国政府提供的与健康和医疗保健相关的数据集。&lt;/p&gt;&lt;p&gt;• 健康营养和人口统计——世界银行提供的全球健康、营养和人口统计数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d9d0a10fbce11680889ca2168343f78a</guid>
<title>面试高频 | 你追我赶的Flink双流join</title>
<link>https://toutiao.io/k/tz2n70b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4098073555166375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lvcHBkdwcibxsLUqZf3cNKzvbdicSm45NJyZhYnV0fR1g3RaktaT7RXricW0KibJoiamMNIcoj4dSzgOr9gkFpOe7qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是老兵。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天和大家聊聊Flink双流Join问题。这是一个高频面试点，也是工作中常遇到的一种真实场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何保证Flink双流Join&lt;code&gt;准确性&lt;/code&gt;和&lt;code&gt;及时性&lt;/code&gt;、除了&lt;code&gt;窗口join&lt;/code&gt;还存在哪些实现方式、究竟如何回答才能完全打动面试官呢。。你将在文中找到答案。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24856961220597584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lvcHBkdwcibxsLUqZf3cNKzvbdicSm45NJIYmk5l7lkJiczEghURmMLGT7ia4r2e3SEned8g7V5f4ic5kBJCK8Y4Uug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1573&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1 引子&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;1.1 数据库SQL中的JOIN&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看看数据库SQL中的JOIN操作。如下所示的订单查询SQL，通过将订单表的&lt;code&gt;id&lt;/code&gt;和订单详情表&lt;code&gt;order_id&lt;/code&gt;关联，获取所有订单下的商品信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;br/&gt;   a.id &lt;span&gt;as&lt;/span&gt; &lt;span&gt;&#x27;订单id&#x27;&lt;/span&gt;,&lt;br/&gt;   a.order_date &lt;span&gt;as&lt;/span&gt; &lt;span&gt;&#x27;下单时间&#x27;&lt;/span&gt;,&lt;br/&gt;   a.order_amount &lt;span&gt;as&lt;/span&gt; &lt;span&gt;&#x27;订单金额&#x27;&lt;/span&gt;,&lt;br/&gt;   b.order_detail_id &lt;span&gt;as&lt;/span&gt; &lt;span&gt;&#x27;订单详情id&#x27;&lt;/span&gt;,&lt;br/&gt;   b.goods_name &lt;span&gt;as&lt;/span&gt; &lt;span&gt;&#x27;商品名称&#x27;&lt;/span&gt;,&lt;br/&gt;   b.goods_price &lt;span&gt;as&lt;/span&gt; &lt;span&gt;&#x27;商品价格&#x27;&lt;/span&gt;,&lt;br/&gt;   b.order_id &lt;span&gt;as&lt;/span&gt; &lt;span&gt;&#x27;订单id&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; &lt;br/&gt;   dwd_order_info_pfd a&lt;br/&gt;&lt;span&gt;right&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; &lt;br/&gt;   dwd_order_detail_pfd b&lt;br/&gt;&lt;span&gt;on&lt;/span&gt; a.id = b.order_id&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一段很简单的SQL代码，就不详细展开叙述了。此处主要引出SQL中的JOIN类型，这里用到的是 &lt;code&gt;right join&lt;/code&gt; , 即右连接。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;left join&lt;/code&gt;:  保留左表全部数据和右表关联数据，右表非关联数据置NULL&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;right join&lt;/code&gt;: 保留右表全部数据和左表关联数据，左表非关联数据置NULL&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;inner join&lt;/code&gt;: 保留左表关联数据和右边关联数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;cross join&lt;/code&gt;: 保留左表和右表数据笛卡尔积&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基于关联键值逐行关联匹配，过滤表数据并生成最终结果，提供给下游数据分析使用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就此打住，关于数据库SQL中的JOIN原理不再多赘述，感兴趣的话大家可自行研究，下面我们将目光转移到大数据领域看看吧。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/lvcHBkdwcibxsLUqZf3cNKzvbdicSm45NJMTcNo1zeebOBfJhlvfxDdg6cJIBwrgOCpjxGOGKpkzdZxOf1v3xskA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;250&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;1.2 离线场景下的JOIN&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设存在这样一个场景:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;已知Mysql数据库中订单表和订单明细表，且满足一对多的关系，统计T-1天所有订单的商品分布详情。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;聪明的大家肯定已经给出了答案，没错~就是上面的SQL:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; a.*, b.*&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; &lt;br/&gt;   dwd_order_info_pfd a&lt;br/&gt;&lt;span&gt;right&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; &lt;br/&gt;   dwd_order_detail_pfd b&lt;br/&gt;&lt;span&gt;on&lt;/span&gt; a.id = b.order_id&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在修改下条件：已知订单表和订单明细表均为&lt;code&gt;亿级别&lt;/code&gt;数据，求相同场景下的分析结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;咋办？此时关系型数据库貌似不大合适了~开始放大招：使用&lt;code&gt;大数据计算引擎&lt;/code&gt;来解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考虑到T-1统计场景对时效性要求很低，可以使用Hive SQL来处理，底层跑Mapreduce任务。如果想提高运行速度，换成Flink或Spark计算引擎，使用内存计算。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22186495176848875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lvcHBkdwcibxsLUqZf3cNKzvbdicSm45NJyfvRKS2etYBqxrBzttKwfw1Xob1SE8evuBsa2CqWZELvhWeZkmxIdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;933&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于查询SQL和上面一样，并将其封装成一个定时调度任务, 等系统调度运行。如果结果不正确的话，由于数据源和数据&lt;code&gt;静态&lt;/code&gt;不变，大不了重跑，看起来感觉&lt;code&gt;皆大欢喜&lt;/code&gt;~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可是好景不长，产品冤家此时又给了你一个无法拒绝的需求：&lt;code&gt;我要实时统计！！&lt;/code&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2 实时场景下的JOIN&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是上面的场景，此时数据源换成了&lt;code&gt;实时&lt;/code&gt;订单流和&lt;code&gt;实时&lt;/code&gt;订单明细流，比如&lt;code&gt;Kafka&lt;/code&gt;的两个topic，要求实时统计每分钟内所有订单下的商品分布详情。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42733188720173537&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lvcHBkdwcibxsLUqZf3cNKzvbdicSm45NJRAJgWjYHBAicEiaMOs0kH5bjJyZEZN0mKnke42Kjmn4Tl7Kct2msz15g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;461&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在情况貌似变得复杂了起来,简单分析下:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据源。实时数据流，和静态流不同，数据是实时流入的且动态变化，需要计算程序支持实时处理机制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关联性。前面提到&lt;code&gt;静态&lt;/code&gt;数据执行多次join操作，左表和右表能关联的数据是很恒定的；而&lt;code&gt;实时数据流&lt;/code&gt;(左右表)如果进入时机不一致，原本可以关联的数据会关联不上或者发生错误。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;延迟性。实时统计，提供分钟甚至秒级别响应结果。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于流数据join的特殊性，在满足&lt;code&gt;实时处理机制&lt;/code&gt;、&lt;code&gt;低延迟&lt;/code&gt;、&lt;code&gt;强关联性&lt;/code&gt;的前提下，看来需要制定完善的数据方案，才能实现真正的流数据JOIN。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.1 方案思路&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道订单数据和订单明细数据是一对多的关系，即一条订单数据对应着多条商品明细数据，毕竟买一件商品也是那么多邮费，不如打包团购。。而一条明细数据仅对应一条订单数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，双流join策略可以考虑如下思路:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当数据流为订单数据时。无条件保留，无论当前是否关联到明细数据，均留作后续join使用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当数据流为明细数据时。在关联到其订单数据后，就可以say goodbye了，否则暂时保留等待下一次与订单数据的邂逅。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;完成所有处于同一时段内的订单数据和订单明细数据join, 清空存储状态&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0601604278074865&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lvcHBkdwcibxsLUqZf3cNKzvbdicSm45NJpLu6lsiccpGvNo71dG7XkUCnF91yR0rFsHyOtmLvIvepoF1VSdZYmyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;748&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;实际生产场景中，需要考虑更多的复杂情况，包括JOIN过程的数据丢失等异常情况的处理，此处仅示意。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，看起来我们已经有了一个马马虎虎的实时流JOIN方案雏形。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;貌似可以准备动手大干一场了~ 别着急，有人已经帮我们偷偷的实现了：&lt;code&gt;Apache Flink&lt;/code&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3 Flink的双流JOIN&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Apache Flink 是一个框架和分布式处理引擎，用于对无界和有界数据流进行有状态计算。Flink 被设计在所有常见的集群环境中运行，以内存执行速度和任意规模来执行计算。&lt;br/&gt;&lt;strong&gt;——来自Flink官网定义&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.278125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lvcHBkdwcibxsLUqZf3cNKzvbdicSm45NJOtw9tBHGSqwaabOd2ngjIibDJNbQaoYSIEfPRgNUV6sbloHMrBsNUug/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们只需要知道Flink是一个实时计算引擎就行了，主要关注其如何实现双流JOIN。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.1 内部运行机制&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;内存计算&lt;/code&gt;：Flink任务优先在内存中计算，内存不够时保存到访问高效的磁盘上，提供&lt;code&gt;秒级&lt;/code&gt;延迟响应。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;状态强一致性&lt;/code&gt;：Flink使用一致性快照保存状态，并定期检查本地状态到持久存储来保证状态一致性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;分布式执行&lt;/code&gt;：Flink应用程序可以划分为无数个并行任务在集群中执行，几乎无限量使用CPU、主内存、磁盘和网络IO。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;内置高级编程模型&lt;/code&gt;：Flink编程模型抽象为SQL、Table、DataStream|DataSet API、Process四层，并封装成丰富功能的算子，其中就包含&lt;code&gt;JOIN类型&lt;/code&gt;的算子。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22629310344827586&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lvcHBkdwcibxsLUqZf3cNKzvbdicSm45NJ6DvpT6d9qTXIULGtCLXAibCMxMib2feUNSialAZqqI2gob1A8tTKyp32g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2784&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仔细看看，我们前面章节讨论的实时流JOIN方案的前提是否都满足了呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;实时处理机制&lt;/code&gt;: Flink天生即实时计算引擎&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;低延迟&lt;/code&gt;: Flink内存计算秒级延迟&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;强关联性&lt;/code&gt;: Flink状态一致性和join类算子&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不由感叹, 这个Flink果然强啊~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;保持好奇心，我们去瞅瞅Flink双流join的真正奥义！！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.2 JOIN实现机制&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Flink双流JOIN主要分为两大类。一类是基于原生State的Connect算子操作，另一类是基于窗口的JOIN操作。其中基于窗口的JOIN可细分为&lt;code&gt;window join&lt;/code&gt;和&lt;code&gt;interval join&lt;/code&gt;两种。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实现原理：底层原理依赖Flink的&lt;code&gt;State状态存储&lt;/code&gt;，通过将数据存储到State中进行关联join, 最终输出结果。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46277372262773725&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lvcHBkdwcibxsLUqZf3cNKzvbdicSm45NJKLr8oBXkB86UB6a1xtE6PjLMRnV0Gn17Wia8386CUUWT8GEXa4iaCrog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;685&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;恍然大悟, Flink原来是通过State状态来缓存等待join的实时流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里给大家抛出一个问题：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;用redis存储可不可以，state存储相比redis存储的区别？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;更多细节欢迎大家一起探讨，添加个人微信: &lt;/span&gt;&lt;code&gt;&lt;span&gt;youlong525&lt;/span&gt;&lt;/code&gt;&lt;span&gt;拉您进群，还有免费Flink PDF领取~&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到正题，这几种方式到底是如何实现双流JOIN的？我们接着往下看。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意: 后面内容将多以&lt;code&gt;文字&lt;/code&gt; + &lt;code&gt;代码&lt;/code&gt;的形式呈现，避免枯燥，我放了一堆原创示意图~&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4 基于Window Join的双流JOIN实现机制&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顾名思义，此类方式利用Flink的&lt;code&gt;窗口机制&lt;/code&gt;实现双流join。通俗理解，将两条实时流中元素分配到同一个时间窗口内完成Join。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;底层原理: 两条实时流数据缓存在&lt;code&gt;Window State&lt;/code&gt;中，当窗口触发计算时，执行join操作。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4977645305514158&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lvcHBkdwcibxsLUqZf3cNKzvbdicSm45NJnSwCMrIO82pibLr7ZjmZnQXiaPDn9J2zYibrISfApEXTWXW1pHVQp1pIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;671&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.1 join算子&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看看Window join实现方式之一的join算子。这里涉及到Flink中的窗口(window)概念，因此Window Join按照窗口类型区分的话某种程度来说可以细分出3种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Tumbling Window Join (滚动窗口)&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4551526717557252&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lvcHBkdwcibxsLUqZf3cNKzvbdicSm45NJDibOHUJljGzyjia4hOBAdPLtXgXiaYFx4rcvKWvMyEYX9dVkGY3iay3eeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1048&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Sliding Window Join (滑动窗口)&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47973609802073514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lvcHBkdwcibxsLUqZf3cNKzvbdicSm45NJ3O1vaKuNMJVBClIV7hPEoqlTFUibDSfEzub27hXS2J8CnvuxKbyYFTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1061&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Session Widnow Join(会话窗口)&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47449470644850816&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lvcHBkdwcibxsLUqZf3cNKzvbdicSm45NJsFBn7UGkZpE12Z8MeSaQKsnWIbQRBDicsgD1fyx8Zichibh7zAKIdf4UA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1039&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两条流数据按照关联主键在（滚动、滑动、会话）窗口内进行&lt;code&gt;inner join&lt;/code&gt;, 底层基于State存储，并支持处理时间和事件时间两种时间特征，看下源码:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6403033586132177&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lvcHBkdwcibxsLUqZf3cNKzvbdicSm45NJNbAwQibIPqO5LTxS9pwUTeQictsERVcbxlAzNL3MmLlnThqHX2Jdy2eg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;923&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;源码核心总结：windows窗口 + state存储 + 双层for循环执行join()&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在让我们把时间轴往回拉一点点，在&lt;code&gt;实时场景JOIN&lt;/code&gt;那里我们收到了这样的需求：统计每分钟内所有订单下的商品明细分布。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OK, 使用join算子小试牛刀一下。我们定义60秒的滚动窗口，将订单流和订单明细流通过order_id关联，得到如下的程序：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;val&lt;/span&gt; env = ...&lt;br/&gt;&lt;span&gt;// kafka 订单流&lt;/span&gt;&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; orderStream = ... &lt;br/&gt;&lt;span&gt;// kafka 订单明细流&lt;/span&gt;&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; orderDetailStream = ...&lt;br/&gt;    &lt;br/&gt;orderStream.join(orderDetailStream)&lt;br/&gt;    .where(r =&amp;gt; r._1)  &lt;span&gt;//订单id&lt;/span&gt;&lt;br/&gt;    .equalTo(r =&amp;gt; r._2) &lt;span&gt;//订单id&lt;/span&gt;&lt;br/&gt;    .window(&lt;span&gt;TumblingProcessTimeWindows&lt;/span&gt;.of(&lt;br/&gt;          &lt;span&gt;Time&lt;/span&gt;.seconds(&lt;span&gt;60&lt;/span&gt;)))&lt;br/&gt;    .apply {(r1, r2) =&amp;gt; r1 + &lt;span&gt;&quot; : &quot;&lt;/span&gt; + r2}&lt;br/&gt;    .print()&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个代码其实很简单，概要总结下:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;定义两条输入实时流A、B&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;A流调用join(b流)算子&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关联关系定义: where为A流关联键，equalTo为B流关联键，都是订单id&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;定义window窗口(60s间隔)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;apply方法定义逻辑输出&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样只要程序稳定运行，就能够持续不断的计算每分钟内订单分布详情，貌似解决问题了奥~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是别高兴太早，别忘了此时的join类型是&lt;code&gt;inner join&lt;/code&gt;。复习一下知识：inner join指的是仅保留两条流关联上的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样双流中没关联上的数据岂不是都丢掉了？别担心，Flink还提供了另一个window join操作: &lt;code&gt;coGroup&lt;/code&gt;算子。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.2 coGroup算子&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;coGroup算子也是基于window窗口机制，不过coGroup算子比Join算子更加灵活，可以按照用户指定的逻辑匹配左流或右流数据并输出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换句话说，我们通过自己指定双流的输出来达到left join和right join的目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在来看看在相同场景下coGroup算子是如何实现left join:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;#这里看看java的写法&lt;br/&gt;orderDetailStream&lt;br/&gt;  .coGroup(orderStream)&lt;br/&gt;  .where(r -&amp;gt; r.getOrderId())&lt;br/&gt;  .equalTo(r -&amp;gt; r.getOrderId())&lt;br/&gt;  .window(TumblingProcessingTimeWindows.of(Time.seconds(&lt;span&gt;60&lt;/span&gt;)))&lt;br/&gt;  .apply(&lt;span&gt;new&lt;/span&gt; CoGroupFunction&amp;lt;OrderDetail, Order, Tuple2&amp;lt;String, Long&amp;gt;&amp;gt;() {&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;coGroup&lt;/span&gt;&lt;span&gt;(Iterable&amp;lt;OrderDetail&amp;gt; orderDetailRecords, Iterable&amp;lt;Order&amp;gt; orderRecords, Collector&amp;lt;Tuple2&amp;lt;String, Long&amp;gt;&amp;gt; collector)&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; (OrderDetail orderDetaill : orderDetailRecords) {&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (Order orderRecord : orderRecords) {&lt;br/&gt;          &lt;span&gt;// 右流中有对应的记录&lt;/span&gt;&lt;br/&gt;          collector.collect(&lt;span&gt;new&lt;/span&gt; Tuple2&amp;lt;&amp;gt;(orderDetailRecords.getGoods_name(), orderDetailRecords.getGoods_price()));&lt;br/&gt;          flag = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!flag) {&lt;br/&gt;          &lt;span&gt;// 右流中没有对应的记录&lt;/span&gt;&lt;br/&gt;          collector.collect(&lt;span&gt;new&lt;/span&gt; Tuple2&amp;lt;&amp;gt;(orderDetailRecords.getGoods_name(), &lt;span&gt;null&lt;/span&gt;));&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  })&lt;br/&gt;  .print();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要说明几点:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;join算子替换为coGroup算子&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;两条流依然需要在一个window中且定义好关联条件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;apply方法中自定义判断，此处对右值进行判断：如果有值则进行连接输出,否则右边置为NULL。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以这么说，现在我们已经彻底搞定了窗口双流JOIN。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要你给我提供具体的窗口大小，我就能通过join或coGroup算子鼓捣出各种花样join，而且使用起来特别简单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是假如此时我们亲爱的产品又提出了一个小小条件：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;大促高峰期，商品数据某时段会写入不及时，时间可能比订单早也可能比订单晚，同样计算每分钟内的订单商品分布详情，没问题吧~&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然有问题：两条流如果步调不一致，还用窗口来控制能join的上才怪了~ 很容易等不到join流窗口就自动关闭了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还好，我知道Flink提供了&lt;code&gt;Interval join&lt;/code&gt;机制。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5 基于Interval Join的双流JOIN实现机制&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Interval Join根据右流相对左流偏移的时间区间(&lt;code&gt;interval&lt;/code&gt;)作为关联窗口，在偏移区间窗口中完成join操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有点不好理解，我画个图看下:&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4450063211125158&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lvcHBkdwcibxsLUqZf3cNKzvbdicSm45NJtZ8ef05J9n7ib6jCfrmmibfib2dtMcO1akzoOU65Vibh0sTON8FHVNo5JQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;791&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;stream2.time ∈ (stream1.time +low, stream1.time +high)&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;满足数据流stream2在数据流stream1的 &lt;code&gt;interval&lt;/code&gt;(low, high)偏移区间内关联join。interval越大，关联上的数据就越多，超出interval的数据不再关联。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实现原理：interval join也是利用Flink的state存储数据，不过此时存在state失效机制&lt;code&gt;ttl&lt;/code&gt;，触发数据清理操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里再引出一个问题:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;state的ttl机制需要怎么设置？不合理的ttl设置会不会撑爆内存？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我会在后面的文章中深入讲解下State的ttl机制，欢迎大家一起探讨~&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面简单看下interval join的代码实现过程:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;val&lt;/span&gt; env = ...&lt;br/&gt;&lt;span&gt;// kafka 订单流&lt;/span&gt;&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; orderStream = ... &lt;br/&gt;&lt;span&gt;// kafka 订单明细流&lt;/span&gt;&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; orderDetailStream = ...&lt;br/&gt;    &lt;br/&gt;orderStream.keyBy(_&lt;span&gt;.1&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;// 调用intervalJoin关联&lt;/span&gt;&lt;br/&gt;    .intervalJoin(orderDetailStream._2)&lt;br/&gt;    &lt;span&gt;// 设定时间上限和下限&lt;/span&gt;&lt;br/&gt;    .between(&lt;span&gt;Time&lt;/span&gt;.milliseconds(&lt;span&gt;-30&lt;/span&gt;), &lt;span&gt;Time&lt;/span&gt;.milliseconds(&lt;span&gt;30&lt;/span&gt;))  &lt;br/&gt;    .process(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;ProcessWindowFunction&lt;/span&gt;())&lt;br/&gt;    &lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ProcessWindowFunction&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ProcessJoinFunction&lt;/span&gt;...&lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;override&lt;/span&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;processElement&lt;/span&gt;&lt;/span&gt;(...) {&lt;br/&gt;      collector.collect((r1, r2) =&amp;gt; r1 + &lt;span&gt;&quot; : &quot;&lt;/span&gt; + r2)&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;订单流在流入程序后，等候(low,high)时间间隔内的订单明细流数据进行join, 否则继续处理下一个流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从代码中我们发现，interval join需要在两个&lt;code&gt;KeyedStream&lt;/code&gt;之上操作，即keyBy()，并在between()方法中指定偏移区间的上下界。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是interval join实现的也是&lt;code&gt;inner join&lt;/code&gt;，且目前只支持事件时间。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6  基于Connect的双流JOIN实现机制&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面在使用Window join或者Interval Join来实现双流join的时候，我发现了其中的共性：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;无论哪种实现方式，Flink内部都将join过程&lt;code&gt;透明化&lt;/code&gt;，在算子中封装了所有的实现细节。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是什么？是编程语言中的&lt;code&gt;抽象&lt;/code&gt;概念~ 隐藏底层细节,对外暴露统一API, 大幅&lt;code&gt;简化&lt;/code&gt;程序编码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可是这样会引来一个问题：如果程序报错或者数据异常，如何快速进行调优排查，直接看源码吗？不大现实。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里介绍基于&lt;code&gt;Connect算子&lt;/code&gt;实现的双流JOIN方法，我们可自己控制双流JOIN处理逻辑，同时保持过程时效性和准确性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;6.1 Connect算子原理&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对两个DataStream执行connect操作，将其转化为ConnectedStreams, 生成的Streams可以调用不同方法在两个实时流上执行，且双流之间可以共享状态。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7454268292682927&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lvcHBkdwcibxsLUqZf3cNKzvbdicSm45NJR4pkOqBLMQypncwrsvVKskPkTz61uMUJ8gGZL2cz20icbe0QjQtHSoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;656&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图上我们可以看到，两个数据流被connect之后，只是被放在了同一个流中，内部依然保持各自的数据和形式，两个流相互独立。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;[DataStream1, DataStream2] -&amp;gt; ConnectedStreams[1,2]&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，我们可以在Connect算子底层的ConnectedStreams基础上编写代码，自行实现双流JOIN的逻辑处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;6.2 技术实现&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.调用connect算子,根据orderid进行分组，并使用process算子分别对两条流进行处理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;orderStream.connect(orderDetailStream)&lt;br/&gt;  .keyBy(&lt;span&gt;&quot;orderId&quot;&lt;/span&gt;, &lt;span&gt;&quot;orderId&quot;&lt;/span&gt;)&lt;br/&gt;  .process(&lt;span&gt;new&lt;/span&gt; orderProcessFunc());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.process方法内部进行状态编程, 初始化订单、订单明细和定时器的ValueState状态。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; ValueState&amp;lt;OrderEvent&amp;gt; orderState;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; ValueState&amp;lt;TxEvent&amp;gt; orderDetailState;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; ValueState&amp;lt;Long&amp;gt; timeState;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 初始化状态Value&lt;/span&gt;&lt;br/&gt;orderState = getRuntimeContext().getState(&lt;br/&gt; &lt;span&gt;new&lt;/span&gt; ValueStateDescriptor&amp;lt;Order&amp;gt;&lt;br/&gt; (&lt;span&gt;&quot;order-state&quot;&lt;/span&gt;,Order&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;····&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3.为每个进入的数据流保存state状态并创建定时器。在时间窗口内另一个流到达时进行join并输出，完成后删除定时器。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;processElement1&lt;/span&gt;&lt;span&gt;(Order value, Context ctx, Collector&amp;lt;Tuple2&amp;lt;Order, OrderDetail&amp;gt;&amp;gt; out)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (orderDetailState.value() == &lt;span&gt;null&lt;/span&gt;){&lt;br/&gt;    &lt;span&gt;//明细数据未到，先把订单数据放入状态&lt;/span&gt;&lt;br/&gt;     orderState.update(value);&lt;br/&gt;    &lt;span&gt;//建立定时器，60秒后触发&lt;/span&gt;&lt;br/&gt;     Long ts = (value.getEventTime()+6&lt;span&gt;0&lt;/span&gt;)*&lt;span&gt;1000L&lt;/span&gt;;&lt;br/&gt;     ctx.timerService().registerEventTimeTimer(&lt;br/&gt;       ts);&lt;br/&gt;     timeState.update(ts);&lt;br/&gt;  }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//明细数据已到，直接输出到主流&lt;/span&gt;&lt;br/&gt;     out.collect(&lt;span&gt;new&lt;/span&gt; Tuple2&amp;lt;&amp;gt;(value,orderDetailS&lt;br/&gt;       tate.value()));&lt;br/&gt;    &lt;span&gt;//删除定时器&lt;/span&gt;&lt;br/&gt;     ctx.timerService().deleteEventTimeTimer&lt;br/&gt;      (timeState.value());&lt;br/&gt;     &lt;span&gt;//清空状态，注意清空的是订单明细状态&lt;/span&gt;&lt;br/&gt;      orderDetailState.clear();&lt;br/&gt;      timeState.clear();&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;...&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;processElement2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4.未及时到达的数据流触发定时器输出到侧输出流，左流先到而右流未到，则输出左流，反之输出右连流。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onTimer&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; timestamp, OnTimerContext ctx, Collector&amp;lt;Tuple2&amp;lt;Order, OrderDetail&amp;gt;&amp;gt; out)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 实现左连接&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (orderState.value() != &lt;span&gt;null&lt;/span&gt;){&lt;br/&gt;       ctx.output(&lt;span&gt;new&lt;/span&gt; OutputTag&amp;lt;String&amp;gt;(&lt;span&gt;&quot;left-jo &lt;br/&gt;       in&quot;&lt;/span&gt;) {}, &lt;br/&gt;       orderState.value().getOrderId());&lt;br/&gt;   &lt;span&gt;// 实现右连接&lt;/span&gt;&lt;br/&gt;   }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;      ctx.output(&lt;span&gt;new&lt;/span&gt; OutputTag&amp;lt;String&amp;gt;(&lt;span&gt;&quot;right-jo &lt;br/&gt;       in&quot;&lt;/span&gt;) {}, &lt;br/&gt;       orderDetailState.value().getOrderId());&lt;br/&gt;   }&lt;br/&gt;   orderState.clear();&lt;br/&gt;   orderDetailState.clear();&lt;br/&gt;   timeState.clear();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体思想：基于数据时间实现订单数据及订单明细数据的关联，超时或者缺失则由侧输出流输出。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在&lt;code&gt;connect&lt;/code&gt;中针对订单流和订单明细流，先创建定时器并保存&lt;code&gt;state&lt;/code&gt;状态，处于窗口内就进行&lt;code&gt;join&lt;/code&gt;, 否则进入侧输出流。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7  双流JOIN的优化与总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为什么我的双流join时间到了却不触发，一直没有输出&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;检查一下&lt;code&gt;watermark&lt;/code&gt;的设置是否合理，&lt;code&gt;数据时间&lt;/code&gt;是否远远大于watermark和窗口时间，导致窗口数据经常为空&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;state数据保存多久，会内存爆炸吗&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;state自带有&lt;code&gt;ttl机制&lt;/code&gt;，可以设置ttl过期策略，触发Flink清理过期state数据。建议程序中的&lt;code&gt;state数据结构&lt;/code&gt;用完后手动clear掉。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我的双流join倾斜怎么办&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;join倾斜三板斧: 过滤异常key、拆分表减少数据、打散key分布。当然可以的话我建议加内存！加内存！加内存！！&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;想实现多流join怎么办&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;目前无法一次实现，可以考虑先union然后再二次处理；或者先进行connnect操作再进行join操作，仅建议~&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;5&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;join过程延迟、没关联上的数据会丢失吗&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这个一般来说不会，join过程可以使用侧输出流存储延迟流；如果出现节点网络等异常，Flink checkpoint也可以保证数据不丢失。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;某日&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官: Flink双流join了解吗? 简单说说其实现原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某君: Flink双流JOIN是。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文完。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>