<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>8c6a7dc9fe92b91729747f658936e0ed</guid>
<title>React v17.0 正式发布</title>
<link>https://toutiao.io/k/ifbjl75</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;不好意思，我又来了，继两篇 React 17 RC 版本后，React 17 迎来了正式版本，正式版本较之前改动不大，但意味着可以正式投入生产了，喜大普奔。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天，我们宣布 React 17 正式发布！在此之前，我们在 React 17 RC 的博文中已经介绍了 React 17 发布的意义以及包含的变化。此文是针对那篇文章的简单总结，如果你已阅读过那篇博文，此文可略过。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;无新特性&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;React v17 的发布非比寻常，因为它没有增加任何面向开发者的新特性。但是，&lt;strong&gt;这个版本会使得 React 自身的升级变得更加容易&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得特别说明的是，React v17 作为后续版本的 ”基石“，它让不同版本的 React 相互嵌套变得更加容易。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，还会使 React 更容易嵌入到由其他技术构建的应用中。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;渐进式升级&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;React v17 开启了 React 渐进式升级的新篇章。&lt;/strong&gt;当你从 React 15 升级至 16 时（或者，从 16 升级到 17），你通常会一次性升级整个应用程序，这对大部分应用来说十分有效。但是，如果代码库编写于几年前，并且没有及时的维护升级，这会使得升级成本越来越高。并且，在 React 17 之前，如果在同一个页面上使用不同的 React 版本（可以这么做，但是有风险），会导致事件问题的出现，会有一些未知的风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们正在修复 React v17 中的许多问题。这意味着，&lt;strong&gt;当 React 18 或未来版本来临时，你将有更多选择&lt;/strong&gt;。首选，当然还是一次性升级整个应用；但你还有个可选方案，渐进式升级你的应用。举个例子，你可能将大部分功能升级至 React v18，但保留部分懒加载的对话框或子路由在 React v17。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这并&lt;strong&gt;不意味着&lt;/strong&gt;你必须进行渐进式升级。&lt;strong&gt;对于大多数应用来说，一次性升级仍是更好的选择&lt;/strong&gt;。加载两个版本的 React，仍然不是理想方案 —— 即使其中一个版本是按需加载的。但对于那些长期未维护的大型应用来说，这意义非凡，React v17 开始让这些应用不会被轻易淘汰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们准备了示例仓库，此示例演示了如何在必要时懒加载旧版本的 React。此示例由 Create React App 构建，使用其他工具也可以实现同样的效果。欢迎使用其他工具的小伙伴通过 PR 的形式提供 Demo。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意&lt;/p&gt;&lt;p&gt;我们&lt;strong&gt;将其他特性&lt;/strong&gt;推迟到了 React v17 之后。这个版本的目标就是实现渐进式升级。如果升级到 17 很困难，那就违背了此版本的目的。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;事件委托的变更&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了实现渐进式升级，我们需要对 React 的事件系统进行修改。React 17 是一个重要版本，因为这个版本的可能存在破坏性更改。关于版本的更多信息，请查阅版本的 FAQ，以了解我们对版本稳定性的承诺。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;React v17 中，React 不会再将事件处理添加到 &lt;code&gt;document&lt;/code&gt; 上，而是将事件处理添加到渲染 React 树的根 DOM 容器中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; rootNode = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;root&#x27;&lt;/span&gt;);&lt;br/&gt;ReactDOM.render(&lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;App&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;, rootNode);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 React 16 及之前版本中，React 会对大多数事件进行 &lt;code&gt;document.addEventListener()&lt;/code&gt; 操作。React v17 开始会通过调用 &lt;code&gt;rootNode.addEventListener()&lt;/code&gt; 来代替。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7738095238095238&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/INNfEriciaG5fLMOxHKzawH1tJaiabypcfaVIZALWBa4hwwuaJGp2dsddtiatAaeBFuLN1SPHh3gT2kLibFDYyMlqaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;840&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;此图展示了 React 17 如何将事件连接到根节点而非 document&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经核实，多年来在 issue 追踪器 上报告的许多问题都已被新特性解决，其中大多与将 React 与非 React 代码集成有关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你在升级时遇到了这方面的问题，可以看看这个常见的解决方案。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其他破坏性更改&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;React v17 的 RC 博文描述了关于 React v17 中其他的破坏性更改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在升级 Facebook 项目代码中 10w+ 组件的过程中，只修改了不到 20 个组件，所以**我们猜测大多数应用在升级 v17 时，不会有太大的问题。**如果你遇到任何问题，请告诉我们。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;全新的 JSX 转换&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;React v17 支持了全新的 JSX 转换。我们还针对 React 16.14.0，React 15.7.0 和 0.14.0 版本做了兼容。请注意，此功能完全可选，并非必须使用。之前的 JSX 转换将会继续维护，并且没有停止支持它的计划。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;React Native&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;React Native 会有一个单独的发布计划。目前，我们预计对 React v17 的支持会在 React Native 0.65 中落地，但具体版本可能会有出入。你可以在 React Native 社区的发布 issue tracker 上参与讨论。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;安装&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 npm 安装 React v17：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;npm install react@17.0.0 react-dom@17.0.0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 yarn 安装 React v17：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;yarn add react@17.0.0 react-dom@17.0.0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还提供了由 UMD 构建的 CDN 版本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;crossorigin&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;&quot;https://unpkg.com/react@17.0.0/umd/react.production.min.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;crossorigin&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;&quot;https://unpkg.com/react-dom@17.0.0/umd/react-dom.production.min.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请参阅文档中的详细安装说明。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;变更日志&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;React&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为全新的 JSX 转换器添加 &lt;code&gt;react/jsx-runtime&lt;/code&gt; 和 &lt;code&gt;react/jsx-dev-runtime&lt;/code&gt;。（@lunaruan 提交于 #18299）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据原生框架构建组件调用栈。（@sebmarkbage 提交于 #18561）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以在 context 中设置 &lt;code&gt;displayName&lt;/code&gt; 以改善调用栈信息。（@eps1lon 提交于 #18224）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;防止 &lt;code&gt;&#x27;use strict&#x27;&lt;/code&gt; 从 UMD 的 bundles 中泄露。（@koba04 提交于 #19614）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;停止使用 &lt;code&gt;fb.me&lt;/code&gt; 进行重定向。（@cylim 提交于 #19598）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;React DOM&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将事件委托从 &lt;code&gt;document&lt;/code&gt; 切换为 root。（@trueadm 提交于 #18195 及其他）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在运行下一个副作用前，请清理所有副作用。（@bvaughn 提交于 #17947）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异步运行 &lt;code&gt;useEffect&lt;/code&gt; 清理函数。（@bvaughn 提交于 #17925）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用浏览器的 &lt;code&gt;focusin&lt;/code&gt; 和 &lt;code&gt;focusout&lt;/code&gt; 替换 &lt;code&gt;onFocus&lt;/code&gt; 和 &lt;code&gt;onBlur&lt;/code&gt; 的底层实现。（@trueadm 提交于 #19186）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将所有 &lt;code&gt;Capture&lt;/code&gt; 事件都使用浏览器的捕获阶段实现。（@trueadm 提交于 #19221）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;禁止在 &lt;code&gt;onScroll&lt;/code&gt; 事件时冒泡。（@gaearon 提交于 #19464)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 &lt;code&gt;forwardRef&lt;/code&gt; 或 &lt;code&gt;memo&lt;/code&gt; 组件的返回值为 &lt;code&gt;undefined&lt;/code&gt;，则抛出异常。（@gaearon 提交于 #19550）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;移除事件池。（@trueadm 提交于 #18969）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;移除 React Native Web 不需要的内部组件。（@necolas 提交于 #18483)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当挂载 root 时，附加所有已知的事件监听器。（@gaearon 提交于 #19659）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 Dev 模式下，禁用第二次渲染过程中的 &lt;code&gt;console&lt;/code&gt;。（@sebmarkbage 提交于 #18547）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;弃用为记录且具有误导性的 &lt;code&gt;ReactTestUtils.SimulateNative&lt;/code&gt; API。（@gaearon 提交于 #13407)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重命名内部使用的私有字段（@gaearon 提交于 #18377）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不在开发环境调用 User Timing API。（@gaearon 提交于 #18417）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在严格模式下重复渲染期间禁用 console。（@sebmarkbage 提交于 #18547）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在严格模式下，二次渲染组件也不使用 Hook。（@eps1lon 提交于 #18430）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;允许在生命周期函数中调用 &lt;code&gt;ReactDOM.flushSync&lt;/code&gt;（但会发出警告）。（@sebmarkbage 提交于 #18759）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 &lt;code&gt;code&lt;/code&gt; 属性添加到键盘事件对象中。（@bl00mber 提交于 #18287）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为 &lt;code&gt;video&lt;/code&gt; 元素添加 &lt;code&gt;disableRemotePlayback&lt;/code&gt; 属性。（@tombrowndev 提交于 #18619）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为 &lt;code&gt;input&lt;/code&gt; 元素添加 &lt;code&gt;enterKeyHint&lt;/code&gt; 属性。（@eps1lon 提交于 #18634）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当没有给 &lt;code&gt;&amp;lt;Context.Provider&amp;gt;&lt;/code&gt; 提供任何值时，会发出警告。（@charlie1404 提交于 #19054）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 &lt;code&gt;forwardRef&lt;/code&gt; 或 &lt;code&gt;memo&lt;/code&gt; 组件的返回值为 &lt;code&gt;undefined&lt;/code&gt;，则抛出警告。（@bvaughn 提交于 #19550）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为无效更新改进错误信息。（@JoviDeCroock 提交于 #18316）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从调用栈信息中忽略 forwardRef 和 memo。（@sebmarkbage 提交于 #18559）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在受控输入与非受控输入间切换时，改善错误消息。（@vcarl 提交于 #17070）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;保持 &lt;code&gt;onTouchStart&lt;/code&gt;、&lt;code&gt;onTouchMove&lt;/code&gt; 和 &lt;code&gt;onWheel&lt;/code&gt; 默认为 passive。（@gaearon 提交于 #19654）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复在 development 模式下 iframe 关闭时，&lt;code&gt;setState&lt;/code&gt; 挂起的问题。（@gaearon 提交于 #19220）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;defaultProps&lt;/code&gt; 修复拉架子组件在渲染时的问题。（@jddxf 提交于 #18539）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复当 &lt;code&gt;dangerouslySetInnerHTML&lt;/code&gt; 为 &lt;code&gt;undefined&lt;/code&gt; 时，误报警告的问题。（@eps1lon 提交于 #18676）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用非标准的 &lt;code&gt;require&lt;/code&gt; 实现来修复 Test Utils。（@just-boris 提交于 #18632）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复 &lt;code&gt;onBeforeInput&lt;/code&gt; 报告错误的 &lt;code&gt;event.type&lt;/code&gt;。（@eps1lon 提交于 #19561）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复 Firefox 中 &lt;code&gt;event.relatedTarget&lt;/code&gt; 输出为 &lt;code&gt;undefined&lt;/code&gt; 的问题。（@claytercek 提交于 #19607）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复 IE11 中 &quot;unspecified error&quot; 的问题。（@hemakshis 提交于 #19664）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复 shadow root 中的渲染问题。（@Jack-Works 提交于 #15894）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用事件捕获修复 &lt;code&gt;movementX/Y&lt;/code&gt; polyfill 的问题。（@gaearon 提交于 #19672）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用委托处理 &lt;code&gt;onSubmit&lt;/code&gt; 和 &lt;code&gt;onReset&lt;/code&gt; 事件。（@gaearon 提交于 #19333）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提高内存使用率。（@trueadm 提交于 #18970）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;React DOM Server&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用服务端渲染的 &lt;code&gt;useCallback&lt;/code&gt; 与 &lt;code&gt;useMemo&lt;/code&gt; 一致。（@alexmckenley提交于 #18783）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复函数组件抛出异常时状态泄露的问题。（@pmaccart 提交于 #19212）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;React Test Renderer&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;改善 &lt;code&gt;findByType&lt;/code&gt; 错误信息。（@henryqdineen 提交于 #17439）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Concurrent Mode（实验阶段）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;改进启发式更新算法。（@acdlite 提交于 #18796）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在实现性 API 前添加 &lt;code&gt;unstable_&lt;/code&gt; 前缀。(@acdlite 提交于 #18825)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;移除 &lt;code&gt;unstable_discreteUpdates&lt;/code&gt; 和 &lt;code&gt;unstable_flushDiscreteUpdates&lt;/code&gt;。（@trueadm 提交于 #18825）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;移除了 &lt;code&gt;timeoutMs&lt;/code&gt; 参数。（@acdlite 提交于 #19703）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;禁用 &lt;code&gt;&amp;lt;div hidden /&amp;gt;&lt;/code&gt; 预渲染，以支持未来的 API。（@acdlite 提交于 #18917）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为 Suspense 添加了 &lt;code&gt;unstable_expectedLoadTime&lt;/code&gt;，用于 CPU-bound 树。（@acdlite 提交于 #19936）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;添加了一个实现性的 &lt;code&gt;unstable_useOpaqueIdentifier&lt;/code&gt; Hook。（@lunaruan 提交于 #17322）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;添加了一个实验性的 &lt;code&gt;unstable_startTransition&lt;/code&gt; API. (@rickhanlonii 提交于 #19696)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在测试渲染器中使用 &lt;code&gt;act&lt;/code&gt; 后，不再刷新 Suspense 的 fallback。（@acdlite 提交于 #18596）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将全局渲染的 timeout 用于 CPU Suspense。（@sebmarkbage 提交于 #19643）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;挂载前，清除现有根目录的内容。（@bvaughn 提交于 #18730）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复带有错误边界的 bug。（@acdlite 提交于 #18265）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复了导致挂起树更新丢失的 bug。（@acdlite 提交于 #18384 以及 #18457）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复导致渲染阶段更新丢失的 bug。（@acdlite 提交于 #18537）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复 SuspenseList 的 bug。（@sebmarkbage 提交于 #18412）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复导致 Suspense fallback 过早显示的 bug。（@acdlite 提交于 #18411）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复 SuspenseList 中使用 class 组件异常的 bug。（@sebmarkbage 提交于 #18448）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复输入内容可能被更新被丢弃的 bug。（@jddxf 提交于 #18515 以及 @acdlite 提交于 #18535）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复暂挂 Suspense fallback 后卡住的错误。（@acdlite 提交于 #18663）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 hydrate 中，不要切断 SuspenseList 的尾部。（@sebmarkbage 提交于 #18854）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复 &lt;code&gt;useMutableSource&lt;/code&gt; 中的 bug，此 bug 可能在 &lt;code&gt;getSnapshot&lt;/code&gt; 更改时出现。（@bvaughn 提交于 #18297）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复 &lt;code&gt;useMutableSource&lt;/code&gt; 令人恶心的 bug。（@bvaughn 提交于 #18912）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果外部渲染且提交之前调用 &lt;code&gt;setState&lt;/code&gt;，会发出警告。（@sebmarkbage 提交于 #18838）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>843632b534ca79d6c33758d6b6484653</guid>
<title>[推荐] 怎么排查 CPU 飙升</title>
<link>https://toutiao.io/k/rq3wyhs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1&gt;&lt;span&gt;怎么排查CPU飙升&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;线上有些系统，本来跑的好好的，突然有一天就会出现报警，CPU使用率飙升，然后重启之后就好了。例如，多线程操作一个线程不安全的list往往就会出现这种现象。那么怎么定位到具体的代码范围呢？今天笔者就教大家一个小技巧&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;span&gt;代码准备&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;这次，笔者准备了一个demo代码，大致线程模型是这样的:&lt;img data-ratio=&quot;0.44745222929936307&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7ICuYI5fFbIIaXAlQFQ9tVtn0k5kS3CUIY0mEMwqGaAI4CUEyl68pEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1256&quot;/&gt;&lt;/p&gt;&lt;p&gt;代码下所示:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;public class CpuHighExample {&lt;br/&gt;&lt;br/&gt;    public static void &lt;span&gt;&lt;span&gt;cpuHigh&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        final List&amp;lt;String&amp;gt; list = new LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        Thread thread1 = new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            @Override&lt;br/&gt;            public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;                int count = 1;&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;                    // 构造thread1为消耗很高cpu的线程&lt;br/&gt;                    count = count + 1;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        thread1.setName(&lt;span&gt;&quot;thread1&quot;&lt;/span&gt;);&lt;br/&gt;        Thread thread2 = new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            @Override&lt;br/&gt;            public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;                    try {&lt;br/&gt;                        // 构造thread2为消耗很低cpu的线程&lt;br/&gt;                        Thread.sleep(1000);&lt;br/&gt;                    } catch (InterruptedException e) {&lt;br/&gt;                        e.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        thread2.setName(&lt;span&gt;&quot;thread2&quot;&lt;/span&gt;);&lt;br/&gt;        thread1.start();&lt;br/&gt;        thread2.start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span/&gt;&lt;span&gt;案例运行&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;这个案例一运行，就听见笔者的电脑风扇起飞了，呼呼作响。直接top一下&lt;img data-ratio=&quot;0.27223230490018147&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7FtpGMeoqxWeUe09Hiaupmk6AB12ux7T8RUsiclic762iaQV8zU1u3789rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1102&quot;/&gt;&lt;/p&gt;&lt;p&gt;果然是java进程，占用最高，CPU 100%了(占用了一个核),而其PID是2717，正是我们跑的例子。那么下一步，我们就需要定位到底是那一个线程在耗CPU&lt;/p&gt;&lt;pre&gt;&lt;code&gt;top -H&lt;br/&gt;Threads toggle&lt;br/&gt;            Starts top with the last remembered ’H’ state reversed.  When this&lt;br/&gt;            toggle  is  On,  all individual threads will be displayed.  Other-&lt;br/&gt;            wise, top displays a summation of all threads &lt;span&gt;in&lt;/span&gt; a process.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如man文档所描述,top -H可以打印出线程信息，我们就top -H一下。&lt;img data-ratio=&quot;0.3611111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7gVWF29FYqvsdgCp0SxRbAHsuYlcGib6Ow25t2iaqoZqSaoKFSNEuIQUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;图中可以看到，占用最高的线程PID是2727,同时线程名是thread1。&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;span&gt;继续jstack&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;我们知道jstack可以dump出jvm所有线程运行的快照，然后我们就可以通过刚才获取的PID去定位到jstack那个进程。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 注意，这边用top出来的进程号2717,而不是top -H出来的2727&lt;br/&gt;jstack 2717 &amp;gt; 1.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于jstack打印出的线程号是以16进制的形式表现的，所以我们对2727的线程号做一次转换,得到aa7。&lt;br/&gt;&lt;img data-ratio=&quot;0.3513203214695752&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7Z1MYNZ7AngNmNOmfdOia7SGcP0W6zPLy29iaibDJjZTX1tp2qTJRibCf1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1742&quot;/&gt;&lt;/p&gt;&lt;p&gt;然后我们在1.txt中搜索2727,这里用的是less然后进去后搜索，而不是用grep。因为这样比较直观的能看出之前和之后的信息。less下&lt;img data-ratio=&quot;0.06093189964157706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7k1icZP2z0uBTfeOhUUcV1YGL8dRA0XFNNqUaWTy4WrqN8dJJOK9Q2tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1116&quot;/&gt;&lt;img data-ratio=&quot;0.27797202797202797&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7qGiaETjUfibeysR1DjicW6Hu1ib8Gbicy0IBD090xFA9eHoLjsd2OFM2UuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1144&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们找到aa7后，就直接能发现代码一直跑在CpuHighExample.java第19行上面。&lt;img data-ratio=&quot;0.35304990757855825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7icibozct5NMOfl5X1b5Q9pEYfEF1VCKJfstRQLEEr3m4sum5ntxdeozg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1082&quot;/&gt;&lt;/p&gt;&lt;p&gt;当然了，我们需要多jstack几次，如果每次jstack出来都刚好在这段代码左右，那么基本可以证明，是这段代码导致CPU飙升了。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;CPU突然飙升这个问题，我们很容易通过top -H和jstack找到对应的代码范围，这无疑极大的缩小了我们的定位范围。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.359781121751026&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7x75CliawsSwbWnz6VZu2PrSTxAfA1Bl6MN5VdbWG06xzJzllCqZWPBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1462&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8a1133ac7a7a479ab4f433875ac1a95c</guid>
<title>[推荐] 工具 | 一个轻量级业务中台开发框架</title>
<link>https://toutiao.io/k/6qs3yvv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>753832b670f73e24ae288346501aeff3</guid>
<title>[推荐] 建设微服务 API 网关的一些实践</title>
<link>https://toutiao.io/k/4li9ai2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-body post-body--article vditor-reset&quot;&gt;
                    &lt;p&gt;随着这些年微服务的流行，API网关已经成为微服务架构中不可或缺的一环。一方面它承担着服务对外的唯一门户，一方面它提取了许多应用的共性功能。&lt;/p&gt;
&lt;h2 id=&quot;toc_h2_0&quot;&gt;整体架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2020-10-07-082018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们的Api网关目前的架构如上所示，可以看到Api网关处于一个什么位置，往上承接所有的南北流量，往下会分发流量到微服务应用或者BFF聚合应用，在BFF规范化之前我们仍然将其视为一个普通微服务应用。&lt;/p&gt;
&lt;p&gt;目前Api网关实现的功能包括请求分发、条件路由、Api管理、限流隔离、熔断降级、安全策略、监控报警以及调用链追踪等。&lt;br/&gt;
&lt;img src=&quot;https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2020-10-09-074430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们的Api网关基于RxNetty开发，整个流程是异步响应式的，可以达到较高的单机并发。基于少造轮子的理念，Api网关的大部分功能都是结合现有平台实现。包括请求分发、条件路由基于微服务框架，限流隔离、熔断降级基于稳定性平台，监控报警基于监控平台等，安全策略基于大数据分析平台等。注册中心与配置中心则分别负责服务注册核心信息与第三方配置信息的下发。&lt;/p&gt;
&lt;h2 id=&quot;toc_h2_1&quot;&gt;请求分发&lt;/h2&gt;
&lt;p&gt;请求的分发路由应该是一个网关最基本的功能，在绝大多数基于nginx开发的网关上，这部分功能通常基于动态更新代理的upstream。而在我们的实现中，认为网关是一个只订阅不注册的微服务而已，区别是微服务应用发起rpc调用指定了调用服务，而网关接收请求分发只有url信息。这可以通过简单的改造来复用已有微服务框架的服务发现功能。&lt;/p&gt;
&lt;p&gt;经过一系列url规范化行动后，我们的url目前不同的应用都会采取不同的前缀，同时这个前缀信息会随着应用注册到注册中心。这样网关进行服务发现时会给不同的url前缀以及微服务应用构建不同的namespace对象，在进行请求匹配时候只需根据url前缀选取到对应的namespace即可匹配到对应微服务应用，后续就是现有微服务框架sdk的功能：路由、负载均衡直至完成整个调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2020-10-08-075648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里还涉及到另一个问题，网关选择服务发现的应用是哪些？即我需要拉取哪些应用信息以构建namespace?我们这里对服务发现对象进行了管理，用户可在管控平台上控制微服务应用在网关层的上下线，这会通过我们的配置中心推送到网关并进行一次热更新，刷新内存缓存，这样就做到了请求分发服务的动态增减。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2020-10-08-090717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_h2_2&quot;&gt;条件路由&lt;/h2&gt;
&lt;p&gt;条件路由意味着可以对具有特定内容(或者一定流量比例)的请求进行筛选并分发到特定实例组上，是实现灰度发布、蓝绿发布、ABTest等功能的基础。&lt;/p&gt;
&lt;p&gt;同样的，在基于nginx开发的网关中，一般是维护多套upstream列表，然后通过某种策略将不同请求代理到不同upstream。&lt;/p&gt;
&lt;p&gt;在我们的实现中，条件路由依然是复用现有的微服务框架，避免重复造轮子。每个应用都可以根据一些规则创建一些分组，分组中有若干实例。在网关进行服务发现初始化时会给每个应用创建Invoker代理对象，Invoker内会根据不同的分组创建不同的Space空间，请求调用时会对这些Space空间进行规则匹配，从而决定是否路由到特定分组上。整个过程都是微服务框架完成的，没有额外的开发工作。&lt;/p&gt;
&lt;p&gt;目前我们支持按照特定内容或者流量比例两种方式进行请求来源规则的匹配，特定内容包括http请求的header、attribute等等。我们目前的实例分组主要是根据&quot;版本&quot;这个标来区分的，所以分配规则主要是支持&quot;版本&quot;维度，未来考虑支持到k8s的pod label。&lt;/p&gt;
&lt;h2 id=&quot;toc_h2_3&quot;&gt;Api管理&lt;/h2&gt;
&lt;p&gt;Api网关为什么前面要有Api几个字，我觉得其中一个很重要的原因就是具有Api管理功能。当我们的大部分应用还是裸连网关，而不是经过BFF聚合时，我们有必要对每个api接口都进行管理，以区分哪些是微服务间内部调用，哪些是暴露给前端/客户端调用。&lt;/p&gt;
&lt;p&gt;实现上和之前的应用上下线类似，额外依赖了DB存储，用户在管控平台进行api发布等操作会先存储在DB中，随后通过配置中心pub/sub通知到网关。我们在namespace匹配前加入了一层filter以过滤删除/未上线的api，所以热更新该filter对象即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2020-10-08-095004.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户体验方面我们也做了一些工作，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从微服务管控平台直接同步新增的api接口到网关管控平台，而无需手动添加。此外也支持多种格式的文件导入。(我们的微服务注册模型会包括api信息等元数据)&lt;/li&gt;
&lt;li&gt;各个环境之间通过流转功能发布api，而无需重复添加&lt;/li&gt;
&lt;li&gt;对各个状态的筛选展示&lt;/li&gt;
&lt;li&gt;与devops平台配合，在应用发布流转时同步提醒进行api管理的发布流转。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2020-10-09-032340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_h2_4&quot;&gt;限流隔离/熔断降级&lt;/h2&gt;
&lt;p&gt;Api网关作为南北流量的唯一入口，一般具有较高并发度，以及流量复杂性。所以对入口流量进行整治管理是很有必要的。&lt;/p&gt;
&lt;p&gt;我们的限流隔离/熔断降级均基于稳定性平台与配置中心实现，稳定性平台是我们基于Sentinel二次开发的。整个结构如下图所示：&lt;br/&gt;
&lt;img src=&quot;https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2020-10-09-074122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;稳定性相关的功能主要包括限流隔离以及熔断降级。限流隔离主要是作用在流入方向服务端测的流量控制，其中限流主要是控制qps，隔离主要是控制并发数。熔断降级则是作用在流出方向客户端测的流量控制，可以配置在一定错误率情况下进行熔断，并配合降级数据快速返回。&lt;/p&gt;
&lt;p&gt;以上规则均可以通过稳定性平台配置，然后由配置中心分发到api网关，再进行热更新刷新内存缓存。每次请求时sentinel sdk都会帮我们做好数据统计并判断是否符合规则，同时被限流隔离、熔断降级的流量都会通过相关sdk(基于prometheus)暴露metrics数据给监控平台，以便我们随时观察到流量控制水平。&lt;/p&gt;
&lt;h2 id=&quot;toc_h2_5&quot;&gt;安全策略&lt;/h2&gt;
&lt;p&gt;时常我们会遇见一些异常流量，典型的就是恶意爬虫，所以完善一些基础的安全策略是必要的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2020-10-09-081340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整个安全策略的结构如上所示。用户可以在网关管控平台手动进行规则配置，经由配置中心下发到api网关的securityControl进行热更新。在请求来临时由securityControl判断是否符合规则，被封禁的流量同样暴露metrics数据给监控平台供我们随时查看。&lt;/p&gt;
&lt;p&gt;此外，手动配置封禁规则在某些场景可能比较低效。我们同时还会将网关日志实时采集至大数据分析平台，经分析后如果判断某个ip或者用户存在异常情况，会自动配置安全策略规则至网关管控平台，同时触发一个报警提醒业务owner。&lt;/p&gt;
&lt;p&gt;在安全策略目标方面，我们目前支持包括根据客户端IP、用户ID、其余http header/attribute等。策略行为方面目前支持快速失败以及验证码，后者用户会在前端被跳转到一个人机验证码的页面。&lt;/p&gt;
&lt;h2 id=&quot;toc_h2_6&quot;&gt;监控报警/调用链追踪&lt;/h2&gt;
&lt;p&gt;与其他微服务应用一样，我们的api网关也有完善的监控报警、调用链追踪、日志查询等功能。这里监控主要指的是查询metrics信息，调用链主要指查询tracing信息，日志顾名思义就是logging，三者是监控领域很典型的信息了：&lt;br/&gt;
&lt;img src=&quot;https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2020-10-09-084657.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;
报警这块除了针对metrics信息/错误日志的报警，还可以支持主机层面的报警。&lt;/p&gt;
&lt;p&gt;得益于监控平台以及调用链埋点sdk，api网关几乎不需要改造成本即可接入。整体结构如下所示，api网关内嵌了metrics sdk暴露metrics信息到endpoint供监控中心拉取，tracing sdk负责埋点打印tracing日志，tracing日志和业务日志均会通过日志采集器输入监控中心处理。在监控平台上，用户可以查询调用链、监控、日志信息，api网关发生的主机异常或者业务异常也会报警给owner。&lt;br/&gt;
&lt;img src=&quot;https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2020-10-09-122040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里值得一提的是，当网关调用后端微服务应用发生异常时，例如超时、连接池耗尽等，这些错误发生在客户端即api网关，所以触发的报警只会报给api网关的owner。但是api网关仅仅作为一个转发服务，其超时很大程度是因为后端微服务rt过高，所以报警应该同时报给后端微服务owner，为此我们开发了双端告警，一份告警会同时发送给客户端和服务端双方。&lt;/p&gt;
&lt;h2 id=&quot;toc_h2_7&quot;&gt;一些总结&lt;/h2&gt;
&lt;p&gt;当然api网关还有许多没有展开说的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们还支持websocket协议，本次没有详细说&lt;/li&gt;
&lt;li&gt;在多云部署环境下，网关承载了一个多云流量调度服务的角色。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以及未来可以优化的地方&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先是我们的高并发能力并未怎么经过实际验证，由于tob商业模式公司没有太多高并发的场景。&lt;/li&gt;
&lt;li&gt;考虑引入规则引擎来应付各种下发的规则，包括安全策略、稳定性、路由规则等。&lt;/li&gt;
&lt;li&gt;安全策略考虑会支持更多一些，例如IP网段，及支持各种逻辑与或非&lt;/li&gt;
&lt;/ul&gt;
                        
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7e3ffd47bd2dad2394c63ba25380d314</guid>
<title>[推荐] 理解完这些基本上能解决面试中 MySQL 的事务问题</title>
<link>https://toutiao.io/k/szxq5t8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1 cid=&quot;n0&quot; mdtype=&quot;heading&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;欢迎关注公众号【&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;Ccww技术博客&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;】，原创技术文章第一时间推出&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/h1&gt;&lt;hr/&gt;&lt;blockquote cid=&quot;n4&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n1135&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;越努力，越幸运，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1136&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;本文已收藏在GitHub中JavaCommunity, 里面有面试分享、源码分析系列文章，欢迎收藏，点赞&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1139&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;https://github.com/Ccww-lx/JavaCommunity&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 cid=&quot;n1134&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n1126&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在面试中，基本上都会问到关于数据库的事务问题，如果啥都不会或者只回答到表面的上知识点的话，那面试基本上是没戏了，为了能顺利通过面试，那MySql的事务问题就需要了解，所以就根据网上的资料总结一版Mysql事务的知识点，巩固一下事务的知识。&lt;/span&gt;&lt;/p&gt;&lt;h2 cid=&quot;n1128&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;事务&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n1130&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;事务是指逻辑上的一组操作，要么都执行，要么都不执行,&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n5&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;事务的特性（ACID）&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n6&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n8&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;原子性(&lt;code&gt;Atomicity&lt;/code&gt;)：事务是不可分割的工作单元，要么都成功，要么都失败， 如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n10&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;一致性(&lt;code&gt;Consistency&lt;/code&gt;)：事务不能破坏数据的完整性和业务的一致性 。例如在银行转账时，不管事务成功还是失败，双方钱的总额不变&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n12&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;隔离性(&lt;code&gt;Isolation&lt;/code&gt;)：一个事务所操作的数据在提交之前，对其他事务的可见性设定（一般是不可见）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n14&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;持久性(&lt;code&gt;Durability&lt;/code&gt;)：事务提交之后，所做的修改就会永久保存，不会因为系统故障导致数据丢失&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n15&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;严格来说，只有同时满足数据库的事务ACID特性才能算一个完整的事务，但现实中实现能够真正满足的完整的事务特性少之又少，但是在实现中也必须尽量达到事务要求的特性。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n592&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;那么事务ACID特性具体怎么实现的呢？我们来分析看看，首先先看看事务的特性。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h2 cid=&quot;n418&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;原子性(&lt;/span&gt;&lt;code&gt;&lt;span&gt;Atomicity&lt;/span&gt;&lt;/code&gt;&lt;span&gt;)&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n419&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;首先我们来看看事务的原子性特性，看看其如何实现的？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n581&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;原子性(&lt;code&gt;Atomicity&lt;/code&gt;)：事务是不可分割的工作单元，要么都成功，要么都失败， 如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n428&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;原子性(&lt;code&gt;Atomicity&lt;/code&gt;)的实现离不开 MySQL的事务日志 &lt;code&gt;undo log&lt;/code&gt;日志类型，当事务需要回滚的时候需要将数据库状态回滚到事务开始前，即需要撤销所有已经成功执行的sql语句。那么&lt;code&gt;undo log&lt;/code&gt;起了关键性作用：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n432&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;当事务对数据库进行修改时，InnoDB会生成对应的&lt;code&gt;undo log&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;；如果事务执行失败或调用了&lt;code&gt;rollback&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;，导致事务需要回滚，便可以利用&lt;code&gt;undo log&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;中的信息将数据回滚到修改之前的样子。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n420&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;那么&lt;code&gt;undo log&lt;/code&gt;是什么呢？每个数据变更操作是怎么被记录下来的呢？&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n434&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;undo log（ 回滚日志 ）&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n421&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;undo log&lt;/code&gt; (回滚日志)：是采用&lt;strong&gt;段(&lt;code&gt;segment&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;)&lt;/strong&gt;的方式来记录的，每个&lt;code&gt;undo&lt;/code&gt;操作在记录的时候占用一个&lt;strong&gt;&lt;code&gt;undo log segment&lt;/code&gt;&lt;/strong&gt;。为什么会在数据更改操作的时候，记录了相对应的&lt;code&gt;undo log&lt;/code&gt;呢？其目的在于：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n523&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其中，&lt;code&gt;undo log&lt;/code&gt;分为：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n455&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;数据更改的&lt;code&gt;undo log&lt;/code&gt;怎么记录的呢？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n462&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; 因为&lt;code&gt;insert&lt;/code&gt;操作的记录，只对事务本身可见，对其他事务不可见。故该&lt;code&gt;undo log&lt;/code&gt;可以在事务提交后直接删除，不需要进行&lt;code&gt;purge&lt;/code&gt;操作，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n536&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; 而&lt;code&gt;Delete&lt;/code&gt;操作在事务中实际上并不是真正的删除掉数据行，而是一种Delete Mark操作，在记录上标识&lt;code&gt;Delete_Bit&lt;/code&gt;，而不删除记录。是一种&quot;假删除&quot;,只是做了个标记，真正的删除工作需要后台&lt;code&gt;purge&lt;/code&gt;线程去完成。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n546&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;update&lt;/code&gt;分为两种情况：&lt;code&gt;update&lt;/code&gt;的列是否是主键列。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n532&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;与&lt;code&gt;insert undo log&lt;/code&gt;不同的，&lt;code&gt;update undo log&lt;/code&gt;日志，当事务提交的时候，innodb不会立即删除&lt;code&gt;undo log&lt;/code&gt;， 会将该事务对应的&lt;code&gt;undo log&lt;/code&gt;放入到删除列表中，未来通过&lt;code&gt;purge&lt;/code&gt;线程来删除。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n542&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;因为后续还可能会用到&lt;code&gt;undo log&lt;/code&gt;，如隔离级别为&lt;code&gt;repeatable read&lt;/code&gt;时，事务读取的都是开启事务时的最新提交行版本，只要该事务不结束，该行版本就不能删除（即&lt;code&gt;undo log&lt;/code&gt;不能删除）,且&lt;code&gt;undo log&lt;/code&gt;分配的页可重用减少存储空间和提升性能。 &lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n488&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n563&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Note：purge线程两个主要作用是：清理undo页和清除page里面带有Delete_Bit标识的数据行。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p cid=&quot;n588&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n590&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;接着我们来看看事务的隔离性，看看事务有哪些隔离级别，而且事务并发中会产生什么问题。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h2 cid=&quot;n570&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;隔离性(&lt;/span&gt;&lt;code&gt;&lt;span&gt;Isolation&lt;/span&gt;&lt;/code&gt;&lt;span&gt;)&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n584&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;隔离性(&lt;code&gt;Isolation&lt;/code&gt;)，是指事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰 ，一个事务所操作的数据在提交之前，对其他事务的可见性设定(一般是不可见)。&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n624&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;事务隔离级别&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n896&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;而且数据库为了在并发下有效保证读取数据正确性，数据库提供了&lt;span&gt;四种事务隔离级别&lt;/span&gt;&amp;gt;，分别为：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n614&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n616&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;读未提交(&lt;strong&gt;脏读&lt;/strong&gt;)：允许读取尚未提交的数据，允许脏读&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n618&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;读已提交（ &lt;strong&gt;不可重复读&lt;/strong&gt; ）：允许读取事务已经提交的数据&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n620&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;可重复读（ &lt;strong&gt;幻读&lt;/strong&gt; ）：在同一个事务内的查询结果都是和事务开始时刻查询一致的（ InnoDB默认级别 ）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n622&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;串行化：所有事务逐个依次执行， 每次读都需要获得表级共享锁，读写相互都会阻塞&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n572&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其中，&lt;span&gt;不同的隔离级别可能会存在在不同并发问题&lt;/span&gt;，主要并发问题包括：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n780&quot; mdtype=&quot;list&quot; data-mark=&quot;+&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n782&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;数据丢失：&lt;/strong&gt; 两个或多个事务操作相同数据，基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n786&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;脏读：&lt;/strong&gt;读到了其他事务还未提交的数据，事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n787&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.38437978560490044&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFmmXvxnaQq5p8dQSTj5K8EMicF2c6WyBkFbQfOSzcbq6jk8YJGFcOh46g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;653&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n789&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;不可重复读（重点是修改）：&lt;/strong&gt;在一个事务中，先后进行两次相同的读取，由于另一个事务修改了数据，导致前后两次结果的不一致，事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n790&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.35222052067381315&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFm6tdicD2HjhvRXibhXCtTn6rH5cLPuicuexv7oH3wYibnBrovbvo4JHxvkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;653&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n792&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;幻读（重点是新增、删除）：&lt;/strong&gt; 在一个事务中，先后进行两次相同的读取（一般是范围查询），由于另一个事务新增或删除了数据，导致前后两次结果不一致&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n793&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3592085235920852&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFm4d2C0AiaquwswcPdYyLxc9hTiamoyVbgdozoCSmNBmj2dvbykQyrZkdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;657&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote cid=&quot;n916&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n921&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;不可重复读和幻读的区别？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n922&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n924&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;使用锁机制来实现这两种隔离级别，在可重复读中，相同sql第一次读取到数据后就将这些数据加锁，其它事务无法更新操作这些数据来实现可重复读了隔离。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n926&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;但这种处理方式却无法锁住insert的数据，因此会出现当事务A先前读取了数据，事务B再&lt;code&gt;insert&lt;/code&gt;数据提交，结果发现事务A就会发现莫名其妙多了些数据，这就是幻读，不能通过行锁来避免 。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p cid=&quot;n914&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;了解了并发问题后，来看看不同的隔离级别可能会存在在不同并发问题：&lt;/span&gt;&lt;/p&gt;&lt;figure cid=&quot;n868&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n869&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span&gt;事务隔离级别&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;脏读&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;不可重复读&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;幻读&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n874&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;读未提交&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n879&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;不可重复读&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n884&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;可重复读&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n889&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;串行化&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p cid=&quot;n70&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;为了实现事务隔离，延伸出了数据库锁。其中，&lt;span&gt;&lt;strong&gt;innodb事务的隔离级别是由锁机制和MVCC（多版本并发控制）来实现的&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n71&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;那我们来先看看锁的原理，怎么使用锁来实现事务隔离的呢？&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n73&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;锁机制&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n971&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;锁机制的基本工作原理，事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n74&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;MySQL主要分成三种类型（级别）的锁机制：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n75&quot; mdtype=&quot;list&quot; data-mark=&quot;+&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n77&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;表级锁：最大颗粒度的锁机制，锁定资源争用的概率也会最高 ，并发度最低 ，但开销小，加锁快，不会出现死锁，&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n79&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;行级锁：最大颗粒度的锁机制很小， 发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能 ，但 开销大，加锁慢；会出现死锁 ，&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n81&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;页级锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n82&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;而且不同的存储引擎支持不同的的锁机制，主要分析一下InnoDB锁。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n83&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;InnoDB锁&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n84&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; InnoDB实现了以下两种类型的行锁&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n90&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;对于&lt;code&gt;UPDATE&lt;/code&gt;,&lt;code&gt;DELETE&lt;/code&gt;,&lt;code&gt;INSERT&lt;/code&gt;操作， InnoDB会自动给涉及及数据集加排他锁（Ｘ）；对于普通SELECT语句，InnoDB不会加任何锁,&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n91&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;而且因为InnoDB引擎允许行锁和表锁共存，实现多粒度锁机制，使用意向锁实现表锁机制，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n97&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;意向锁(IS、IX)是InnoDB数据操作之前自动加的，不需要用户干预。它的意义在于：当事务想去进行锁表时，可以先判断意向锁是否存在，存在时则可快速返回该表不能启用表锁，否则就需要等待，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n98&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其中，四种锁的兼容性如下&lt;/span&gt;&lt;/p&gt;&lt;figure cid=&quot;n99&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n100&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span&gt;当前锁模式/是否兼容/请求锁模式&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;X&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;IX&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;S&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;IS&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n106&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;X&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n112&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;IX&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n118&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;S&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n124&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;IS&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p cid=&quot;n130&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;如果一个事务请求的锁模式与当前的锁兼容，InnoDB就请求的锁授予该事务；反之，如果两者两者不兼容，该事务就要等待锁释放。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n131&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;InnoDB行锁&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n132&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;InnoDB的行锁是通过给索引上的&lt;strong&gt;索引项加锁&lt;/strong&gt;来实现的。&lt;strong&gt;只有通过索引检索数据，才能使用行锁，否则将使用表锁（锁住索引的所有记录）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n133&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;innodb的行锁，默认是由&lt;strong&gt;&lt;code&gt;临键锁(next-key)&lt;/code&gt;&lt;/strong&gt;算法实现的，可以防止幻读。根据索引，划分为一个个&lt;strong&gt;左开右闭&lt;/strong&gt;的区间。当进行范围查询的时候，若命中索引且能够检索到数据，则锁住记录所在的区间和它的下一个区间,&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n134&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其实，&lt;strong&gt;临键锁(Next-Key)&lt;/strong&gt;=&lt;strong&gt;记录锁(Record Locks)&lt;/strong&gt;+&lt;strong&gt;间隙锁(Gap Locks)&lt;/strong&gt;，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n140&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;具体的使用体现在哪里呢？如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.46060606060606063&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFmIvTG2Z905QUWVJgL5KYvySqTVgJf3licqul9aCZgbMvlFthtOpTYVww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;660&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n145&quot; mdtype=&quot;list&quot; data-mark=&quot;+&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n147&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当记录不存在（不论是等值查询，还是范围查询）时，next-key将退化成&lt;strong&gt;Gap Lock（间隙锁）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n148&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5150602409638554&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFmWpbMHJ8rEpFJyCiaa9vZGXPUsvricjWr0KxzQzHPyickY8zibqNLb6OemQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;664&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n150&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当条件是精准匹配（即为等值查询时）且记录存在时，并且是唯一索引，&lt;strong&gt;临键锁(Next-Key)&lt;/strong&gt;退化成&lt;strong&gt;Record Lock（记录锁）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n151&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4180790960451977&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFmsdCoFtlnGsncibWh7DLGCDy9lsEjbJsgKISMUpKVkcauW4Fuibd54L0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;708&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n153&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当条件是精准匹配（即为等值查询时）且记录存在，但不是唯一索引时，&lt;strong&gt;临键锁(Next-Key)&lt;/strong&gt;会有精准值的数据会增加&lt;strong&gt;Record Lock（记录锁）&lt;/strong&gt;和精准值前后的区间的数据会增加&lt;strong&gt;Gap Lock（间隙锁)&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n154&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4880597014925373&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFmz0VibbGWM6LPXzu6v2WfxfX41Xuo26h2StJrzu0GMpjtSojga6nbSVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 cid=&quot;n961&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;如何使用锁解决并发问题&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n962&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;利用锁解决脏读、不可重复读、幻读&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n960&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;&lt;code&gt;Multiversion concurrency control&lt;/code&gt; (&lt;code&gt;MVCC&lt;/code&gt; 多版本并发控制)&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n165&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;InnoDB&lt;/code&gt;的&lt;code&gt;MVCC&lt;/code&gt;是通过在每行记录后面保存两个隐藏的列来实现的，&lt;strong&gt;一个保存了行的事务ID（事务ID就会递增 ）&lt;/strong&gt;，&lt;strong&gt;一个保存了行的回滚段的指针&lt;/strong&gt; 。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n398&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.21217391304347827&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFmR7uEiaSiaIwwML2kqPjwfcejNLV9I5qJrznHCtAhl7n3l6NiaDuMNCgGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;575&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n400&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;每开始一个新的事务，都会自动递增产 生一个新的事务id。事务开始时刻的会把事务id放到当前事务影响的行事务id中，而&lt;code&gt;DB_ROLL_PTR&lt;/code&gt;表示指向该行回滚段的指针，该行记录上所有版本数据，在undo中都通过链表形式组织，该值实际指向undo中该行的历史记录链表，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n166&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span&gt;在并发访问数据库时，对正在事务中的数据做MVCC多版本的管理，以避免写操作阻塞读操作，并且会通过比较版本解决幻读&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n167&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;而且MVCC只在&lt;code&gt;REPEATABLE READ&lt;/code&gt;和&lt;code&gt;READ COMMITIED&lt;/code&gt;两个隔离级别下才会工作，&lt;strong&gt;其中，MVCC实现实质就是保存数据在某个时间点的&lt;span&gt;快照&lt;/span&gt;来实现的。&lt;/strong&gt; 那哪些操作是快照读？&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n168&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;快照读和当前读&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n169&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;快照读&lt;/strong&gt;，innodb快照读，数据的读取将由 cache(原本数据) + undo(事务修改前的数据) 两部分组成&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n173&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;当前读&lt;/strong&gt;，SQL读取的数据是最新版本。通过锁机制来保证读取的数据无法通过其他事务进行修改&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n186&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;那么在RR隔离级别下，MVCC具体是如何操作的。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n187&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;RR隔离级别下，MVCC具体操作&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n188&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;SELECT操作&lt;/strong&gt;，InnoDB遵循以后两个规则执行：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n189&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n191&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span&gt;InnoDB只查找版本早于当前事务版本的数据行（即行的事务编号小于或等于当前事务的事务编号）&lt;/span&gt;，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的记录。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n193&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span&gt;行的删除版本要么未定义,读取到事务开始之前状态的版本&lt;/span&gt;&amp;gt;,这可以确保事务读取到的行，在事务开始之前未被删除.只有同时满足的两者的记录，才能返回作为查询结果.&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n194&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;INSERT&lt;/strong&gt;：&lt;span&gt;InnoDB为新插入的每一行保存当前事务编号作为行版本号&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n195&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;DELETE&lt;/strong&gt;：&lt;span&gt;InnoDB为删除的每一行保存当前事务编号作为行删除标识&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n196&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;UPDATE&lt;/strong&gt;：&lt;span&gt;InnoDB为插入一行新记录，保存当前事务编号作为行版本号，同时保存当前事务编号到原来的行作为行删除标识&lt;/span&gt;&amp;gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n197&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。&lt;span md-inline=&quot;tab&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n198&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;分析完了原子性和隔离性，我们继续看看事务的持久性。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n980&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h2 cid=&quot;n931&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;持久性(&lt;/span&gt;&lt;code&gt;&lt;span&gt;Durability&lt;/span&gt;&lt;/code&gt;&lt;span&gt;)&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n940&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;持久性(&lt;code&gt;Durability&lt;/code&gt;)：事务提交之后，所做的修改就会永久保存，不会因为系统故障导致数据丢失，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n983&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;而且其实现的关键在于&lt;code&gt;redo log&lt;/code&gt;， 在执行SQL时会保存已执行的SQL语句到一个指定的Log文件，当执行&lt;code&gt;recovery&lt;/code&gt;时重新执行&lt;code&gt;redo log&lt;/code&gt;记录的SQL操作。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n991&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;那么&lt;code&gt;redo log&lt;/code&gt;如何实现的呢？&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n993&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n995&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当向数据库写入数据时，执行过程会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏），这整一过程称为redo log。redo log 分为：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1019&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Buffer Pool的使用可以大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据在内存还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1016&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;为了确保事务的持久性，在当事务提交时，会调用&lt;code&gt;fsync&lt;/code&gt;接口对&lt;code&gt;redo log&lt;/code&gt;进行刷盘, （即&lt;code&gt;redo log buffer&lt;/code&gt;写日志到磁盘的&lt;code&gt;redo log file&lt;/code&gt;中 ）,刷新频率由 &lt;code&gt;innodb_flush_log_at_trx_commit&lt;/code&gt;变量来控制的：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1043&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;redo log有更加详细的解读，后续有时间再补上，到现在为止，已经将事务三个特性都理解了，那事务一致性呢？&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h2 cid=&quot;n1049&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;一致性(&lt;/span&gt;&lt;code&gt;&lt;span&gt;Consistency&lt;/span&gt;&lt;/code&gt;&lt;span&gt;)&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n989&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;一致性(&lt;code&gt;Consistency&lt;/code&gt;)：事务不能破坏数据的完整性和业务的一致性 ：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1065&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;那是如何保证数据一致性的？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1067&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其实数据一致性是通过事务的原子性、持久性和隔离性来保证的&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n1072&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1074&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;原子性：语句要么全执行，要么全不执行，是事务最核心的特性，事务本身就是以原子性来定义的；实现主要基于undo log&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1076&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;持久性：保证事务提交后不会因为宕机等原因导致数据丢失；实现主要基于redo log&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1078&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;隔离性：保证事务执行尽可能不受其他事务影响；InnoDB默认的隔离级别是RR，RR的实现主要基于锁机制（包含next-key lock）、MVCC（包括数据的隐藏列、基于undo log的版本链、ReadView）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 cid=&quot;n4927&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n932&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其中要同时满足ACID特性，这样的事务少之又少。实际中很多例子都只是满足一些特性，比如：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n4931&quot; mdtype=&quot;list&quot; data-mark=&quot;+&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n4934&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;MySQL的NDB Cluster事务不满足持久性和隔离性；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n4935&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;InnoDB默认事务隔离级别是可重复读，不满足隔离性；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n4941&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Oracle默认的事务隔离级别为READ COMMITTED，不满足隔离性&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n4929&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;所以我们只能使用这个四个维度的特性去衡量事务的操作。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n934&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n7947&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n7949&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;谢谢各位点赞，没点赞的点个赞支持支持&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n7949&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;最后，微信搜《Ccww技术博客》观看更多文章，也欢迎关注一波。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgfBz2Ve78FylxcGWmXaueSuqPguurBCWEkeY1ibeLl1wlxUyibdesc4YeuiaJJjSt6HTiab2iaHyXyyicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.36857142857142855&quot; data-w=&quot;350&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>