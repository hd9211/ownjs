<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f2acaf33a28050099821a8fe9f60491d</guid>
<title>工具 | 滴滴开源的，高性能高可用的跨端开发框架</title>
<link>https://toutiao.io/k/afb7a01</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1529&quot; data-ratio=&quot;1.9226666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicDGyUHukUCpLTzqjcCnRkd4oyd0Aic0FOFZHqN8r3NcLbpJLxxI1PmbDUBux9j8O3OUL1nV0D22Dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;「码农周刊 VIP 会员」推出 37 周啦！感谢亲们的大力支持！第 037 期「码农周刊 VIP 会员专属邮件周报」已发送完毕，请注意查收。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;告诉大家一个好消息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：已有数位上市公司 CTO 低调订阅了我们的「码农周刊 VIP 会员专属邮件周报」，感谢肯定！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;255&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;255&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ7PeUupLzwuuAibicnrRNxKcfCY7fIva78efKsUzANlCCAeuSQEGkGm34rKkzNRpzy6IiaiaHmBNA6DcA/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;「码农周刊 VIP 会员」是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;简介版&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;码农周刊 VIP 会员 = 全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;详细版&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击「阅读原文」即可查看详细介绍&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊 VIP 新年特惠&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;原价 365 元/年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;，现价仅需 108 元！&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;全年 52 期「VIP 会员专属邮件周报」&lt;br/&gt;只限 VIP 会员加入的交流圈子&lt;br/&gt;大厂「内推机会」&lt;br/&gt;N 多福利，你值得拥有！&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;CTO 们邀请你加入码农周刊 VIP，升职加薪不再难！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;31&quot; data-cropselx2=&quot;291&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;350&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav9LRTqibic3sUoh5tv76OXCpNTWbZ0gCYsFDShjwfRVvM157WDel2cr2dy5ghjxDCCwRc2Mu8bgehnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f7ae09870e2cca455ac661252dc73218</guid>
<title>抓包神器 Wireshark，帮你快速定位线上网络故障（五）</title>
<link>https://toutiao.io/k/oxyi4m9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section&gt;&lt;section data-mpa-template-id=&quot;1544239&quot; data-mpa-category=&quot;收藏&quot;&gt;&lt;section data-mpa-template-id=&quot;1495&quot; data-mpa-category=&quot;title&quot;&gt;&lt;section label=&quot;Copyright © 2017 playhudong All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;1&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt; 引子 &lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;em&gt;&lt;em/&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Wireshark 就像网络世界的显微镜，我们可以在它的帮助下了解网络中发生的一切。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上次分享借助 Wireshark 对 QQ 音乐进行抓取 HTTPS 包，并谈了谈如何脱掉 HTTPS 的加密外壳？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本次简单谈谈 HTTPS 协议的握手过程，希望大家能够稍作了解，以备不时之需。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template-id=&quot;1544239&quot; data-mpa-category=&quot;收藏&quot;&gt;&lt;section data-mpa-template-id=&quot;1495&quot; data-mpa-category=&quot;title&quot;&gt;&lt;section label=&quot;Copyright © 2017 playhudong All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;2&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt; HTTPS 协议握手一览 &lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;本次依然基于 Wireshark 对 QQ 音乐抓取 HTTPS 包为例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;137&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.23652048885693747&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/waH0DGXhQWOSuN9RZlrnT86FvLmib11kKyvghqxCISnB8cZ9wcCcDQTXjdCHNJldoxiaib6qSibPwpItJ8MYWNibBaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2782&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过上图，HTTPS 握手是建立在 TCP 基础上的，首先进行 TCP 的三次握手（&lt;/span&gt;&lt;span&gt;之前分享过，感兴趣的可以扒拉一下历史推文回味一下&lt;/span&gt;&lt;span&gt;），然后再进行建立 TLS 连接，下面重点谈谈 TLS 握手过程（&lt;/span&gt;&lt;span&gt;HTTPS = HTTP + TLS/SSL&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以借助 Wireshark 提供的「Statistics|Flow Graph」功能，进行展示出 HTTPS 协议握手的流程图，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;140&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.24141749723145073&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/waH0DGXhQWOSuN9RZlrnT86FvLmib11kKhpAdjA8fpJDKHiaNseFR6uecZpiaCORtcSpxvIJ2b1diarLJY9ldwBib7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1806&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们还可以借助 Wireshark 提供的「显示过滤器」功能来筛选出重点关注的 TLS 握手数据包，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;83&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.14350797266514806&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/waH0DGXhQWN4yO80IqcOYwFEYPRU1YDWMf9b1KZjzRVb835fPJiaVxibXCO8nRjLiaKFIAQzSBJtUtS47vhrB2hkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2634&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过上面两张截图，能够梳理出 HTTPS 协议握手的几个重要步骤。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;步骤一：客户端向服务器端发送一个 Client Hello&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;步骤二：服务器端向客户端返回一个 Server Hello&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;步骤三：服务器端向客户端返回一个 Certificate&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;步骤四：服务器端向客户端返回 Server Key Exchange,Server Hello Done&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;步骤五：客户端向服务器端发送 Client Key Exchange,&lt;span class=&quot;code-snippet__keyword&quot;&gt;Change&lt;/span&gt; Cipher Spec,Encrypted Handshake Message&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;步骤六：服务器端向客户端返回 &lt;span class=&quot;code-snippet__keyword&quot;&gt;New&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;Session&lt;/span&gt; Ticket,&lt;span class=&quot;code-snippet__keyword&quot;&gt;Change&lt;/span&gt; Cipher Spec,Encrypted Handshake Message&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-mpa-template-id=&quot;1544239&quot; data-mpa-category=&quot;收藏&quot;&gt;&lt;section data-mpa-template-id=&quot;1495&quot; data-mpa-category=&quot;title&quot;&gt;&lt;section label=&quot;Copyright © 2017 playhudong All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;3&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt; HTTPS 协议握手剖析 &lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;HTTPS 握手的过程，借助 Wireshark 能够看的很清晰，接下来采取剥洋葱的方式，一层一层去分析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤一：Client Hello&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;405&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7015329125338142&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/waH0DGXhQWOSuN9RZlrnT86FvLmib11kKJpHZa0R3TTNGibustgOvsGlBLvtNkwk0PsQw6xp5QbjM3gBxnSibrH0w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2218&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过 Wireshark 抓包分析，如上图所示，Clinet Hello 阶段主要是客户端告诉服务端客户端所支持的 TLS 协议的版本号、客户端支持的加密套件、客户端支持的压缩方法以及客户端生成的一个随机数等相关信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤二：Server Hello&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;327&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5653742110009017&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/waH0DGXhQWOSuN9RZlrnT86FvLmib11kKm8Onb2Q8pH2ibpKbwEQ6dxagVu5tZ5qOxu1faGjWaVjph5BuNAFotkQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2218&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过抓包分析，如上图所示，主要是服务端根据客户端传递的支持的相关信息，确定使用的 SSL/TLS 协议版本；确定使用哪种加密套件及压缩方法等；产生一个随机数 Random。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤三：Certificate&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;286&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.49550286181520853&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/waH0DGXhQWOSuN9RZlrnT86FvLmib11kKXWjtPY5UiaAiaw0ZA5wu9Jib8oj7eNFo1182GVrXKUdofPkUYHVquSgZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2446&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此步主要是服务端向客户端发送证书。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤四：Server Key Exchange,Server Hello Done&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;319&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5520918785890074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/waH0DGXhQWOSuN9RZlrnT86FvLmib11kK1MZfZbFgFRnNibgcZKicYhPGDlplulk00oDXRKz5pSHForKsbSQvqiaYg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2438&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Server Key E&lt;/span&gt;&lt;span&gt;xchange：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;span&gt;此消息是服务端向客户端发送密钥交换算法相关参数和数据的，&lt;/span&gt;&lt;span&gt;常用的密钥交换算法有 RSA、DH、ECDH 等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Server Hello Done：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;服务端告诉客户端消息发送完毕。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤五：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;286&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.49465899753492193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/waH0DGXhQWOSuN9RZlrnT86FvLmib11kKgEk4bmBYfHia9f7V0lX87RtKBaws3SZdc629Nu4YGFS4h7eotCc5SbQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2434&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Client Key Exchange：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;此消息用来交换秘钥参数，生成一个pre-master key，然后将这个 Key 传给服务器端，服务端会结合自己的私钥解密出 Key，得到第三个随机数，进而可以生成一个通信密钥。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Change Cipher Spec：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;此消息是告诉服务器端后期的通信都会使用协商出来的这个密钥进行加密。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Encrypted Handshake Message&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：客户端将前面的握手消息生成摘要，然后用协商好的秘钥进行加密，若服务端接收后能解出来，说明前面协商出来的秘钥是一致的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤六：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;286&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.49426229508196723&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/waH0DGXhQWOSuN9RZlrnT86FvLmib11kKwfNk0kml7opeDHk5otPevFuXRrsM1q7vUFZicxjKdFmIWM4I5iaicFM8A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2440&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;New Session Ticket：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;包含了一个加密通信所需要的信息，这些数据采用一个只有服务器知道的密钥进行加密。目标是消除服务器需要维护每个客户端的会话状态缓存的要求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Change Cipher Spec：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;此消息是告诉客户端后期的通信都会使用协商出来的密钥进行加密通信。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Encrypted Handshake Message：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;服务端将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。&lt;/span&gt;&lt;span&gt;客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;到这里 TLS 握手就完成啦，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;接着就是数据传输了。&lt;/span&gt;&lt;span&gt;HTTPS 数据传输如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;258&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.44635544635544633&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/waH0DGXhQWOSuN9RZlrnT86FvLmib11kKa1tSibC2ry1Irp35XeyibCpodkJzu5QRhejAGJIea50ZzvmDtEKVpR3g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2442&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template-id=&quot;1544239&quot; data-mpa-category=&quot;收藏&quot;&gt;&lt;section data-mpa-template-id=&quot;1495&quot; data-mpa-category=&quot;title&quot;&gt;&lt;section label=&quot;Copyright © 2017 playhudong All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;4&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt; 写在最后 &lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;纸上得来终觉浅，绝知此事要躬行，有些传到不到的地方，还需要结合 Wireshark 抓包自行分析一番。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本次 Wireshark 分享就写到这里，为了能够让分享不出现纰漏，查阅了很多文档、书籍以及官方资料，归纳汇总一下给老铁，希望对老铁能有所帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;资料分享：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;120&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;&lt;span&gt;经典例子：https://gitlab.com/wireshark/wireshark/-/wikis/SampleCaptures&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;官方文档：https://www.wireshark.org/docs/wsug_html_chunked/&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;119&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;参考书籍：&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;42&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;&lt;span&gt;《从实践中学习Wireshark数据分析》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;《Wireshark网络分析就是这么简单》&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;一起聊技术、谈业务、喷架构，少走弯路，不踩大坑。&lt;/strong&gt;&lt;span&gt;会持续输出精彩分享，敬请期待！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;211&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3649122807017544&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1710&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/waH0DGXhQWOwkpyEoA1IiakYviaHIX4GnoUHGE4kNCqHqAM54WmxryEd76E7Uf1xibO18pftGiafQqI8ibxqMHG34xA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;历史推文（欢迎转发&amp;amp;点赞&amp;amp;在看）：&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;amp;mid=2247486160&amp;amp;idx=1&amp;amp;sn=5af3be7c0fc582b3e8b839dfaf1f849d&amp;amp;chksm=fc0041ddcb77c8cba0b47c96516746037761f502cf919c486d926f96bb2fc2001d7f0977255b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;抓包神器 Wireshark，帮你快速定位线上网络故障（1）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;amp;mid=2247486177&amp;amp;idx=1&amp;amp;sn=d9ec9b3abc9dc2f1336ee855476f3e47&amp;amp;chksm=fc0041eccb77c8facbe7adaca5804a891f8928c55b92d74b82784f33aecfd8c37a6ba8289b25&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;抓包神器 Wireshark，帮你快速定位线上网络故障（2）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;amp;mid=2247486192&amp;amp;idx=1&amp;amp;sn=aa7aa0fdc2a87b0a72003a0313c421a2&amp;amp;chksm=fc0041fdcb77c8ebdffc493a505dbd211d25104743e21b85029039cde5eb240fbcda36079b08&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;抓包神器 Wireshark，帮你快速定位线上网络故障（3）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;amp;mid=2247486209&amp;amp;idx=1&amp;amp;sn=ffc4867ec97f3ee45b0db1353fdc084e&amp;amp;chksm=fc00400ccb77c91a595b7b312dcca0bcda866299e44b963e4e32bfcdc850e65d9f9ce1ab7829&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;抓包神器 Wireshark，帮你快速定位线上网络故障（4）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;amp;mid=2247486097&amp;amp;idx=1&amp;amp;sn=bf9499abc93a31689161ffd030b108fa&amp;amp;chksm=fc00419ccb77c88a19f98965437f3a2bccd021af27416038681e32bbaabf1d06c20edb855f73&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;真实|技术人员该如何接手一个复杂的系统？吐血推荐这几招&lt;/a&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2d89cbc99b4f6d5d0056e55bfaba90bc</guid>
<title>数据全景洞察概念简介</title>
<link>https://toutiao.io/k/0t26f76</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1&gt;&lt;span&gt;一、全景洞察简介&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、行业背景&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;智能数字时代，数据不论形态、格式和类型，已经迅速成为企业最有战略意义的资产；数据资产已经成为了可以形成业务洞察及优势的战略资源，数据的体量、多样性和复杂性也正以指数级增长。就像其他重要的企业资产，数据需要适当的管理和治理水平,以确保它的潜在价值得到认识和发挥作用。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、基础概念&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;DMP数据管理平台是DataManagementPlatform简称，是把分散的多方数据进行整合纳入统一的技术平台，并对这些数据进行标准化建模和细致分析，让用户可以把这些细分结果推向现有的互动营销环境里的平台。核心作用如下：可以对统一对数据快速查询、圈选符合条件的人群，生成特定场景对数据分析报告；可以基于此结果帮助客户快进入到市场周期中，并且可以对数据对洞察分析，对市场预测并作出反应，可以提升企业各方面的竞争优势，降低信息获取、运营、人力等各项成本。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、核心因素&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;围绕实体-关系-标签这三个元素进行建模，从业务的角度出发对数据进行组织管理，以概念模型的形态透出，形成数据的画像报告，让人人都能看得懂。业务数据长期运营形成以标签为中心的智能数据体系，激活数据资产，实现数据资产的变现。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4、产生作用&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;精准营销投放：针对产品进行人群透视，挖掘潜在客，熟悉潜客偏好；产品研发：分析目标人群的行为特征，找到相关品类及产品特征，给新品带来数据参考；市场分析：掌握竞争趋势和差异，对于制定市场计划提供指引。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、核心概念&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、标签工厂&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;标签管理是一件非常复杂的事情，数据基于准确的标签才会发挥出最大的价值。这里涉及到标签模型、更新&lt;/span&gt;迭代&lt;span&gt;、标签资源、标签云、私有标签池等各种功能管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、智能引擎&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这个模块就是核心的业务模块，针对客户需求提供各种公共的或者定制化的营销流程，例如：主动式营销，触发式营销，周期性营销，特定时间营销等各种业务规则的引擎封装，还需要根据效果不断的优化改进。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、画像报告&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;基于对数据的整理分析，以及在实际业务中的使用场景和效果，形成通用的或者定制的画像分析，例如：标签画像、人群画像、行业画像、营销画像等等。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4、应用工厂&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;基于DMP系统数据，提供开放的API能力，数据分析能力、标签查询、标签补齐、分析报告等各种综合业务。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;5、数据安全&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;对系统数据处理建立安全保护机制，保护计算机硬件、软件和数据不因偶然和人为的突发原因造成破坏、更改和泄露。最简单直白的解释和做法就是数据加密，保证数据不直白的在各种环境中流转。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、建设过程&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、数据积累&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;形成数据治理意识，专注多个数据的产生渠道，汇总数据进而管理，例如Web端，APP端等数据源头，包括用户属性信息，行为信息等，形成流动的数据链条，管理结构化和非结构化数据，搭建数据基础仓库等。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、分析能力&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;数据的价值体现在对数据对分析报告上，通过对海量数据分析来获得各类业务画像，进而对企业对营销产生价值。对数据状态有实时精准的更新，提供高效的数据生命周期管理，给业务评估或运营带来有价值的参考。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、数据资产&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;企业数据不断积累，发展成为的企业资产，强调战略性业务成长、成本、风险与合规。数据意识，分析驱动，建立数据使用对综合能力。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3783359497645212&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCjMheLZtcM2iaVMBOpIUKR4CDRCG9FLT5K6NmGXvG7exrW0TSuDjnTKJQ5PDq8j8Y7PHDd17Z3gicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>66ba7554904aeb2d2a16b8ba3b02f8e6</guid>
<title>Kubernetes 存储原理解析</title>
<link>https://toutiao.io/k/mhbru1t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.39791666666666664&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YuFI2AsdNDW6wxUgkibfZJvpM5u0TgdZ5URv9doG9MiblqqqC19IbK5XVdcfXjxQ3IpEia3bqJMNhujQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面的章节中我们介绍了在 Kubernetes 中的持久化存储的使用，了解了 PV、PVC 以及 StorageClass 的使用方法，从本地存储到 Ceph 共享存储都有学习，到这里我们其实已经可以完成应用各种场景的数据持久化了，但是难免在实际的使用过程中会遇到各种各样的问题，要解决这些问题最好的方式就是来了解下 Kubernetes 中存储的实现原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kubernetes 默认情况下就提供了主流的存储卷接入方案，我们可以执行命令 &lt;code&gt;kubectl explain pod.spec.volumes&lt;/code&gt; 查看到支持的各种存储卷，另外也提供了插件机制，允许其他类型的存储服务接入到 Kubernetes 系统中来，在 Kubernetes 中就对应 &lt;code&gt;In-Tree&lt;/code&gt; 和 &lt;code&gt;Out-Of-Tree&lt;/code&gt; 两种方式，&lt;code&gt;In-Tree&lt;/code&gt; 就是在 Kubernetes 源码内部实现的，和 Kubernetes 一起发布、管理的，但是更新迭代慢、灵活性比较差，&lt;code&gt;Out-Of-Tree&lt;/code&gt; 是独立于 Kubernetes 的，目前主要有 &lt;code&gt;CSI&lt;/code&gt; 和 &lt;code&gt;FlexVolume&lt;/code&gt; 两种机制，开发者可以根据自己的存储类型实现不同的存储插件接入到 Kubernetes 中去，其中 &lt;code&gt;CSI&lt;/code&gt; 是现在也是以后主流的方式，所以当然我们的重点也会是 &lt;code&gt;CSI&lt;/code&gt; 的使用介绍。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;NFS&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们这里为了演示方便，先使用相对简单的 NFS 这种存储资源，接下来我们在节点 &lt;code&gt;10.151.30.11&lt;/code&gt; 上来安装 NFS 服务，数据目录：&lt;code&gt;/data/k8s/&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关闭防火墙&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl stop firewalld.service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl &lt;span&gt;disable&lt;/span&gt; firewalld.service&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装配置 nfs&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; yum -y install nfs-utils rpcbind&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;共享目录设置权限：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; mkdir -p /data/k8s/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; chmod 755 /data/k8s/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置 nfs，nfs 的默认配置文件在 &lt;code&gt;/etc/exports&lt;/code&gt; 文件下，在该文件中添加下面的配置信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; vi /etc/exports&lt;/span&gt;&lt;br/&gt;/data/k8s  *(rw,sync,no_root_squash)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置说明：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;/data/k8s：是共享的数据目录&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;*：表示任何人都有权限连接，当然也可以是一个网段，一个 IP，也可以是域名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;rw：读写的权限&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sync：表示文件同时写入硬盘和内存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;no_root_squash：当登录 NFS 主机使用共享目录的使用者是 root 时，其权限将被转换成为匿名使用者，通常它的 UID 与 GID，都会变成 nobody 身份&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然 nfs 的配置还有很多，感兴趣的同学可以在网上去查找一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动服务 nfs 需要向 rpc 注册，rpc 一旦重启了，注册的文件都会丢失，向他注册的服务都需要重启
注意启动顺序，先启动 rpcbind&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl start rpcbind.service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl &lt;span&gt;enable&lt;/span&gt; rpcbind&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl status rpcbind&lt;/span&gt;&lt;br/&gt;● rpcbind.service - RPC bind service&lt;br/&gt;   Loaded: loaded (/usr/lib/systemd/system/rpcbind.service; disabled; vendor preset: enabled)&lt;br/&gt;   Active: active (running) since Tue 2018-07-10 20:57:29 CST; 1min 54s ago&lt;br/&gt;  Process: 17696 ExecStart=/sbin/rpcbind -w $RPCBIND_ARGS (code=exited, status=0/SUCCESS)&lt;br/&gt; Main PID: 17697 (rpcbind)&lt;br/&gt;    Tasks: 1&lt;br/&gt;   Memory: 1.1M&lt;br/&gt;   CGroup: /system.slice/rpcbind.service&lt;br/&gt;           └─17697 /sbin/rpcbind -w&lt;br/&gt;&lt;br/&gt;Jul 10 20:57:29 master systemd[1]: Starting RPC bind service...&lt;br/&gt;Jul 10 20:57:29 master systemd[1]: Started RPC bind service.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到上面的 Started 证明启动成功了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后启动 nfs 服务：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl start nfs.service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl &lt;span&gt;enable&lt;/span&gt; nfs&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl status nfs&lt;/span&gt;&lt;br/&gt;● nfs-server.service - NFS server and services&lt;br/&gt;   Loaded: loaded (/usr/lib/systemd/system/nfs-server.service; enabled; vendor preset: disabled)&lt;br/&gt;  Drop-In: /run/systemd/generator/nfs-server.service.d&lt;br/&gt;           └─order-with-mounts.conf&lt;br/&gt;   Active: active (exited) since Tue 2018-07-10 21:35:37 CST; 14s ago&lt;br/&gt; Main PID: 32067 (code=exited, status=0/SUCCESS)&lt;br/&gt;   CGroup: /system.slice/nfs-server.service&lt;br/&gt;&lt;br/&gt;Jul 10 21:35:37 master systemd[1]: Starting NFS server and services...&lt;br/&gt;Jul 10 21:35:37 master systemd[1]: Started NFS server and services.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样看到 Started 则证明 NFS Server 启动成功了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外我们还可以通过下面的命令确认下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; rpcinfo -p|grep nfs&lt;/span&gt;&lt;br/&gt;    100003    3   tcp   2049  nfs&lt;br/&gt;    100003    4   tcp   2049  nfs&lt;br/&gt;    100227    3   tcp   2049  nfs_acl&lt;br/&gt;    100003    3   udp   2049  nfs&lt;br/&gt;    100003    4   udp   2049  nfs&lt;br/&gt;    100227    3   udp   2049  nfs_acl&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看具体目录挂载权限：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; cat /var/lib/nfs/etab&lt;/span&gt;&lt;br/&gt;/data/k8s    *(rw,sync,wdelay,hide,nocrossmnt,secure,no_root_squash,no_all_squash,no_subtree_check,secure_locks,acl,no_pnfs,anonuid=65534,anongid=65534,sec=sys,secure,no_root_squash,no_all_squash)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里我们就把 nfs server 给安装成功了，然后就是前往节点安装 nfs 的客户端来验证，安装 nfs 当前也需要先关闭防火墙：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl stop firewalld.service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl &lt;span&gt;disable&lt;/span&gt; firewalld.service&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后安装 nfs&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; yum -y install nfs-utils rpcbind&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装完成后，和上面的方法一样，先启动 rpc、然后启动 nfs：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl start rpcbind.service &lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl &lt;span&gt;enable&lt;/span&gt; rpcbind.service &lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl start nfs.service    &lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; systemctl &lt;span&gt;enable&lt;/span&gt; nfs.service&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;挂载数据目录 客户端启动完成后，我们在客户端来挂载下 nfs 测试下，首先检查下 nfs 是否有共享目录：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; showmount -e 10.151.30.11&lt;/span&gt;&lt;br/&gt;Export list for 10.151.30.11:&lt;br/&gt;/data/k8s *&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们在客户端上新建目录：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; mkdir -p /root/course/kubeadm/data&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将 nfs 共享目录挂载到上面的目录：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; mount -t nfs 10.151.30.11:/data/k8s /root/course/kubeadm/data&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;挂载成功后，在客户端上面的目录中新建一个文件，然后我们观察下 nfs 服务端的共享目录下面是否也会出现该文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; touch /root/course/kubeadm/data/test.txt&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在 nfs 服务端查看：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; ls -ls /data/k8s/&lt;/span&gt;&lt;br/&gt;total 4&lt;br/&gt;4 -rw-r--r--. 1 root root 4 Jul 10 21:50 test.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果上面出现了 test.txt 的文件，那么证明我们的 nfs 挂载成功了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;存储架构&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们了解到了 PV、PVC、StorgeClass 的使用，但是他们是如何和我们的 Pod 关联起来使用的呢？这就需要从 Volume 的处理流程和原理说起了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下所示，我们创建了一个 nfs 类型的 PV 资源对象：（volume.yaml）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;PersistentVolume&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;nfs-pv&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;storageClassName:&lt;/span&gt; &lt;span&gt;manual&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;capacity:&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;storage:&lt;/span&gt; &lt;span&gt;1Gi&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;accessModes:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;ReadWriteOnce&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;persistentVolumeReclaimPolicy:&lt;/span&gt; &lt;span&gt;Retain&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;nfs:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;path:&lt;/span&gt; &lt;span&gt;/data/k8s&lt;/span&gt;  &lt;span&gt;# 指定nfs的挂载点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;server:&lt;/span&gt; &lt;span&gt;10.151&lt;/span&gt;&lt;span&gt;.30&lt;/span&gt;&lt;span&gt;.11&lt;/span&gt;  &lt;span&gt;# 指定nfs服务地址&lt;/span&gt;&lt;br/&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;PersistentVolumeClaim&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;nfs-pvc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;storageClassName:&lt;/span&gt; &lt;span&gt;manual&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;accessModes:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;ReadWriteOnce&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;resources:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;requests:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;storage:&lt;/span&gt; &lt;span&gt;1Gi&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道用户真正使用的是 PVC，而要使用 PVC 的前提就是必须要先和某个符合条件的 PV 进行一一绑定，比如存储容器、访问模式，以及 PV 和 PVC 的 storageClassName 字段必须一样，这样才能够进行绑定，当 PVC 和 PV 绑定成功后就可以直接使用这个 PVC 对象了：(pod.yaml)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Pod&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;test-volumes&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;volumes:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;nfs&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;persistentVolumeClaim:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;claimName:&lt;/span&gt; &lt;span&gt;nfs-pvc&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;containers:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;web&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;nginx&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;web&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;containerPort:&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;volumeMounts:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;nfs&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;subPath:&lt;/span&gt; &lt;span&gt;test-volumes&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;mountPath:&lt;/span&gt; &lt;span&gt;&quot;/usr/share/nginx/html&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接创建上面的资源对象即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; kubectl apply -f volume.yaml&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; kubectl apply -f pod.yaml&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们只是在 volumes 中指定了我们上面创建的 PVC 对象，当这个 Pod 被创建之后， kubelet 就会把这个 PVC 对应的这个 NFS 类型的 Volume（PV）挂载到这个 Pod 容器中的目录中去。前面我们也提到了这样的话对于普通用户来说完全就不用关心后面的具体存储在 NFS 还是 Ceph 或者其他了，只需要直接使用 PVC 就可以了，因为真正的存储是需要很多相关的专业知识的，这样就完全职责分离解耦了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;普通用户直接使用 PVC 没有问题，但是也会出现一个问题，那就是当普通用户创建一个 PVC 对象的时候，这个时候系统里面并没有合适的 PV 来和它进行绑定，因为 PV 大多数情况下是管理员给我们创建的，这个时候启动 Pod 肯定就会失败了，如果现在管理员如果去创建一个对应的 PV 的话，PVC 和 PV 当然就可以绑定了，然后 Pod 也会自动的启动成功，这是因为在 Kubernetes 中有一个专门处理持久化存储的控制器 Volume Controller，这个控制器下面有很多个控制循环，其中一个就是用于 PV 和 PVC 绑定的 PersistentVolumeController。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PersistentVolumeController 会不断地循环去查看每一个 PVC，是不是已经处于 Bound（已绑定）状态。如果不是，那它就会遍历所有的、可用的 PV，并尝试将其与未绑定的 PVC 进行绑定，这样，Kubernetes 就可以保证用户提交的每一个 PVC，只要有合适的 PV 出现，它就能够很快进入绑定状态。而所谓将一个 PV 与 PVC 进行&lt;code&gt;“绑定”&lt;/code&gt;，其实就是将这个 PV 对象的名字，填在了 PVC 对象的 &lt;code&gt;spec.volumeName&lt;/code&gt; 字段上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PV 和 PVC 绑定上了，那么又是如何将容器里面的数据进行持久化的呢，前面我们学习过 Docker 的 Volume 挂载，其实就是&lt;span&gt;将一个宿主机上的目录和一个容器里的目录绑定挂载在了一起&lt;/span&gt;，具有持久化功能当然就是指的宿主机上面的这个目录了，当容器被删除或者在其他节点上重建出来以后，这个目录里面的内容依然存在，所以一般情况下实现持久化是需要一个远程存储的，比如 NFS、Ceph 或者云厂商提供的磁盘等等。所以接下来需要做的就是持久化宿主机目录这个过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 Pod 被调度到一个节点上后，节点上的 kubelet 组件就会为这个 Pod 创建它的 Volume 目录，默认情况下 kubelet 为 Volume 创建的目录在 kubelet 工作目录下面：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/var/lib/kubelet/pods/&amp;lt;Pod的ID&amp;gt;/volumes/kubernetes.io~&amp;lt;Volume类型&amp;gt;/&amp;lt;Volume名字&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如上面我们创建的 Pod 对应的 Volume 目录完整路径为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/var/lib/kubelet/pods/d4fcdb11-baf7-43d9-8d7d-3ede24118e08/volumes/kubernetes.io~nfs/nfs-pv&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;要获取 Pod 的唯一标识 uid，可通过命令 &lt;code&gt;kubectl get pod pod名 -o jsonpath={.metadata.uid}&lt;/code&gt; 获取。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后就需要根据我们的 Volume 类型来决定需要做什么操作了，比如上节课我们用的 Ceph RBD，那么 kubelet 就需要先将 Ceph 提供的 RBD 挂载到 Pod 所在的宿主机上面，这个阶段在 Kubernetes 中被称为 Attach 阶段。Attach 阶段完成后，为了能够使用这个块设备，kubelet 还要进行第二个操作，即：格式化这个块设备，然后将它挂载到宿主机指定的挂载点上。这个挂载点，也就是上面我们提到的 Volume 的宿主机的目录。将块设备格式化并挂载到 Volume 宿主机目录的操作，在 Kubernetes 中被称为 Mount 阶段。上节课我们使用 Ceph RBD 持久化的 Wordpress 的 MySQL 数据，我们可以查看对应的 Volume 信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; kubectl get pods -o wide -l app=wordpress&lt;/span&gt;&lt;br/&gt;NAME                              READY   STATUS    RESTARTS   AGE   IP             NODE         NOMINATED NODE   READINESS GATES&lt;br/&gt;wordpress-5b886cf59b-dv2zt        1/1     Running   0          20d   10.244.1.158   ydzs-node1   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;&lt;br/&gt;wordpress-mysql-b9ddd6d4c-pjhbt   1/1     Running   0          20d   10.244.4.70    ydzs-node4   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到 MySQL 运行在 node4 节点上，然后可以在该节点上查看 Volume 信息，Pod 对应的 uid 可以通过如下命令获取：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; kubectl get pod wordpress-mysql-b9ddd6d4c-pjhbt -o jsonpath={.metadata.uid}&lt;/span&gt;&lt;br/&gt;3f84af87-9f58-4c69-9e38-5ef234498133&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; ls /var/lib/kubelet/pods/3f84af87-9f58-4c69-9e38-5ef234498133/volumes/kubernetes.io~csi/pvc-c8861c23-c03d-47aa-96f6-73c4d4093109/&lt;/span&gt;&lt;br/&gt;mount  vol_data.json&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后通过如下命令可以查看 Volume 的持久化信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; findmnt /var/lib/kubelet/pods/3f84af87-9f58-4c69-9e38-5ef234498133/volumes/kubernetes.io~csi/pvc-c8861c23-c03d-47aa-96f6-73c4d4093109/mount&lt;/span&gt;&lt;br/&gt;TARGET                                                                                            SOURCE    FSTYPE OPTIONS&lt;br/&gt;/var/lib/kubelet/pods/3f84af87-9f58-4c69-9e38-5ef234498133/volumes/kubernetes.io~csi/pvc-c8861c23-c03d-47aa-96f6-73c4d4093109/mount    /dev/rbd0 ext4   rw,relatime,&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到这里的 Volume 是挂载到 &lt;code&gt;/dev/rbd0&lt;/code&gt; 这个设备上面的，通过 &lt;code&gt;df&lt;/code&gt; 命令也是可以看到的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; df -h |grep dev&lt;/span&gt;&lt;br/&gt;devtmpfs        3.9G     0  3.9G   0% /dev&lt;br/&gt;tmpfs           3.9G     0  3.9G   0% /dev/shm&lt;br/&gt;/dev/vda3        18G  4.7G   13G  27% /&lt;br/&gt;/dev/vda1       497M  158M  340M  32% /boot&lt;br/&gt;/dev/vdb1       197G   24G  164G  13% /data&lt;br/&gt;/dev/rbd0        20G  160M   20G   1% /var/lib/kubelet/pods/3f84af87-9f58-4c69-9e38-5ef234498133/volumes/kubernetes.io~csi/pvc-c8861c23-c03d-47aa-96f6-73c4d4093109/mount&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们就经过了 &lt;code&gt;Attach&lt;/code&gt; 和 &lt;code&gt;Mount&lt;/code&gt; 两个阶段完成了 Volume 的持久化。但是对于上面我们使用的 NFS 就更加简单了， 因为 NFS 存储并没有一个设备需要挂载到宿主机上面，所以这个时候 kubelet 就会直接进入第二个 &lt;code&gt;Mount&lt;/code&gt; 阶段，相当于直接在宿主机上面执行如下的命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; mount -t nfs 10.151.30.11:/data/k8s /var/lib/kubelet/pods/d4fcdb11-baf7-43d9-8d7d-3ede24118e08/volumes/kubernetes.io~nfs/nfs-pv&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样可以在测试的 Pod 所在节点查看 Volume 的挂载信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; findmnt /var/lib/kubelet/pods/d4fcdb11-baf7-43d9-8d7d-3ede24118e08/volumes/kubernetes.io~nfs/nfs-pv&lt;/span&gt;&lt;br/&gt;TARGET                                                                               SOURCE                 FSTYPE OPTIONS&lt;br/&gt;/var/lib/kubelet/pods/d4fcdb11-baf7-43d9-8d7d-3ede24118e08/volumes/kubernetes.io~nfs/nfs-pv&lt;br/&gt;                                                                                     10.151.30.11:/data/k8s nfs4   rw,relatime,&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到这个 Volume 被挂载到了 NFS（10.151.30.11:/data/k8s）下面，以后我们在这个目录里写入的所有文件，都会被保存在远程 NFS 服务器上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样在经过了上面的两个阶段过后，我们就得到了一个持久化的宿主机上面的 Volume 目录了，接下来 kubelet 只需要把这个 Volume 目录挂载到容器中对应的目录即可，这样就可以为 Pod 里的容器挂载这个持久化的 Volume 了，这一步其实也就相当于执行了如下所示的命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; docker run -v /var/lib/kubelet/pods/&amp;lt;Pod的ID&amp;gt;/volumes/kubernetes.io~&amp;lt;Volume类型&amp;gt;/&amp;lt;Volume名字&amp;gt;:/&amp;lt;容器内的目标目录&amp;gt; 我的镜像 ...&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个存储的架构可以用下图来说明：&lt;img data-ratio=&quot;0.35714285714285715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YuFI2AsdNDW6wxUgkibfZJvpprxD07bvQDGMsXgCT50nYBMCTJOntXN7r4UL3FL3oa3zabSq6Xa1Bw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1260&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;PV Controller：负责 PV/PVC 的绑定，并根据需求进行数据卷的 Provision/Delete 操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AD Controller：负责存储设备的 Attach/Detach 操作，将设备挂载到目标节点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Volume Manager：管理卷的 Mount/Unmount 操作、卷设备的格式化等操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Volume Plugin：扩展各种存储类型的卷管理能力，实现第三方存储的各种操作能力和 Kubernetes 存储系统结合&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们上面使用的 NFS 就属于 In-Tree 这种方式，而上节课使用的 Ceph RBD 就是 Out-Of-Tree 的方式，而且是使用的是 CSI 插件。下面我们再来了解下 &lt;code&gt;FlexVolume&lt;/code&gt; 和 &lt;code&gt;CSI&lt;/code&gt; 两种插件方式。&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1610278363109&quot; data-category_id_list=&quot;1|11|16|17|22|24|26|27|28|29|3|31|32|35|36|37|39|41|42|43|45|46|47|48|49|5|50|51|52|53|54|55|6|7|8&quot; data-id=&quot;1610278363109&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;FlexVolume&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FlexVolume 提供了一种扩展 Kubernetes 存储插件的方式，用户可以自定义自己的存储插件。要使用 FlexVolume 需要在每个节点上安装存储插件二进制文件，该二进制需要实现 FlexVolume 的相关接口，默认存储插件的存放路径为&lt;code&gt;/usr/libexec/kubernetes/kubelet-plugins/volume/exec/&amp;lt;vendor~driver&amp;gt;/&amp;lt;driver&amp;gt;&lt;/code&gt;，&lt;code&gt;VolumePlugins&lt;/code&gt; 组件会不断 watch 这个目录来实现插件的添加、删除等功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 &lt;code&gt;vendor~driver&lt;/code&gt; 的名字需要和 Pod 中&lt;code&gt;flexVolume.driver&lt;/code&gt; 的字段名字匹配，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/usr/libexec/kubernetes/kubelet-plugins/volume/&lt;span&gt;exec&lt;/span&gt;/foo~cifs/cifs&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应的 Pod 中的 &lt;code&gt;flexVolume.driver&lt;/code&gt; 属性为：&lt;code&gt;foo/cifs&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们实现自定义存储插件的时候，需要实现 FlexVolume 的部分接口，因为要看实际需求，并不一定所有接口都需要实现。比如对于类似于 NFS 这样的存储就没必要实现 &lt;code&gt;attach/detach&lt;/code&gt; 这些接口了，因为不需要，只需要实现 &lt;code&gt;init/mount/umount&lt;/code&gt; 3个接口即可。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;init: &lt;code&gt;&amp;lt;driver executable&amp;gt; init&lt;/code&gt; - kubelet/kube-controller-manager 初始化存储插件时调用，插件需要返回是否需要要 attach 和 detach 操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;attach: &lt;code&gt;&amp;lt;driver executable&amp;gt; attach &amp;lt;json options&amp;gt; &amp;lt;node name&amp;gt;&lt;/code&gt; - 将存储卷挂载到 Node 节点上&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;detach: &lt;code&gt;&amp;lt;driver executable&amp;gt; detach &amp;lt;mount device&amp;gt; &amp;lt;node name&amp;gt;&lt;/code&gt; - 将存储卷从 Node 上卸载&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;waitforattach: &lt;code&gt;&amp;lt;driver executable&amp;gt; waitforattach &amp;lt;mount device&amp;gt; &amp;lt;json options&amp;gt;&lt;/code&gt; - 等待 attach 操作成功（超时时间为 10 分钟）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;isattached: &lt;code&gt;&amp;lt;driver executable&amp;gt; isattached &amp;lt;json options&amp;gt; &amp;lt;node name&amp;gt;&lt;/code&gt; - 检查存储卷是否已经挂载&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mountdevice: &lt;code&gt;&amp;lt;driver executable&amp;gt; mountdevice &amp;lt;mount dir&amp;gt; &amp;lt;mount device&amp;gt; &amp;lt;json options&amp;gt;&lt;/code&gt; - 将设备挂载到指定目录中以便后续 bind mount 使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;unmountdevice: &lt;code&gt;&amp;lt;driver executable&amp;gt; unmountdevice &amp;lt;mount device&amp;gt;&lt;/code&gt; - 将设备取消挂载&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mount: &lt;code&gt;&amp;lt;driver executable&amp;gt; mount &amp;lt;mount dir&amp;gt; &amp;lt;json options&amp;gt;&lt;/code&gt; - 将存储卷挂载到指定目录中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;unmount: &lt;code&gt;&amp;lt;driver executable&amp;gt; unmount &amp;lt;mount dir&amp;gt;&lt;/code&gt; - 将存储卷取消挂载&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现上面的这些接口需要返回如下所示的 JSON 格式的数据：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;    &lt;span&gt;&quot;status&quot;&lt;/span&gt;: &lt;span&gt;&quot;&amp;lt;Success/Failure/Not supported&amp;gt;&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;message&quot;&lt;/span&gt;: &lt;span&gt;&quot;&amp;lt;Reason for success/failure&amp;gt;&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;device&quot;&lt;/span&gt;: &lt;span&gt;&quot;&amp;lt;Path to the device attached. This field is valid only for attach &amp;amp; waitforattach call-outs&amp;gt;&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;volumeName&quot;&lt;/span&gt;: &lt;span&gt;&quot;&amp;lt;Cluster wide unique name of the volume. Valid only for getvolumename call-out&amp;gt;&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;attached&quot;&lt;/span&gt;: &amp;lt;True/False (Return &lt;span&gt;true&lt;/span&gt; if volume is attached on the node. Valid only for isattached call-out)&amp;gt;&lt;br/&gt;    &lt;span&gt;&quot;capabilities&quot;&lt;/span&gt;: &amp;lt;Only included as part of the Init response&amp;gt;&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;&quot;attach&quot;&lt;/span&gt;: &amp;lt;True/False (Return &lt;span&gt;true&lt;/span&gt; if the driver implements attach and detach)&amp;gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们来实现一个 NFS 的 FlexVolume 插件，最简单的方式就是写一个脚本，然后实现 init、mount、unmount 3个命令即可，然后按照上面的 JSON 格式返回数据，最后把这个脚本放在节点的 FlexVolume 插件目录下面即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面就是官方给出的一个 NFS 的 FlexVolume 插件示例，可以从 https://github.com/kubernetes/examples/blob/master/staging/volumes/flexvolume/nfs 获取脚本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/bin/bash&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;  - 在使用插件之前需要先安装 jq。&lt;/span&gt;&lt;br/&gt;usage() {&lt;br/&gt; err &quot;Invalid usage. Usage: &quot;&lt;br/&gt; err &quot;\t$0 init&quot;&lt;br/&gt; err &quot;\t$0 mount &amp;lt;mount dir&amp;gt; &amp;lt;json params&amp;gt;&quot;&lt;br/&gt; err &quot;\t$0 unmount &amp;lt;mount dir&amp;gt;&quot;&lt;br/&gt; exit 1&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;err() {&lt;br/&gt; echo -ne $* 1&amp;gt;&amp;amp;2&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;log() {&lt;br/&gt; echo -ne $* &amp;gt;&amp;amp;1&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;ismounted() {&lt;br/&gt; MOUNT=`findmnt -n ${MNTPATH} 2&amp;gt;/dev/null | cut -d&#x27; &#x27; -f1`&lt;br/&gt; if [ &quot;${MOUNT}&quot; == &quot;${MNTPATH}&quot; ]; then&lt;br/&gt;  echo &quot;1&quot;&lt;br/&gt; else&lt;br/&gt;  echo &quot;0&quot;&lt;br/&gt; fi&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;domount() {&lt;br/&gt; MNTPATH=$1&lt;br/&gt;&lt;br/&gt; NFS_SERVER=$(echo $2 | jq -r &#x27;.server&#x27;)&lt;br/&gt; SHARE=$(echo $2 | jq -r &#x27;.share&#x27;)&lt;br/&gt;&lt;br/&gt; if [ $(ismounted) -eq 1 ] ; then&lt;br/&gt;  log &#x27;{&quot;status&quot;: &quot;Success&quot;}&#x27;&lt;br/&gt;  exit 0&lt;br/&gt; fi&lt;br/&gt;&lt;br/&gt; mkdir -p ${MNTPATH} &amp;amp;&amp;gt; /dev/null&lt;br/&gt;&lt;br/&gt; mount -t nfs ${NFS_SERVER}:/${SHARE} ${MNTPATH} &amp;amp;&amp;gt; /dev/null&lt;br/&gt; if [ $? -ne 0 ]; then&lt;br/&gt;  err &quot;{ \&quot;status\&quot;: \&quot;Failure\&quot;, \&quot;message\&quot;: \&quot;Failed to mount ${NFS_SERVER}:${SHARE} at ${MNTPATH}\&quot;}&quot;&lt;br/&gt;  exit 1&lt;br/&gt; fi&lt;br/&gt; log &#x27;{&quot;status&quot;: &quot;Success&quot;}&#x27;&lt;br/&gt; exit 0&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;unmount() {&lt;br/&gt; MNTPATH=$1&lt;br/&gt; if [ $(ismounted) -eq 0 ] ; then&lt;br/&gt;  log &#x27;{&quot;status&quot;: &quot;Success&quot;}&#x27;&lt;br/&gt;  exit 0&lt;br/&gt; fi&lt;br/&gt;&lt;br/&gt; umount ${MNTPATH} &amp;amp;&amp;gt; /dev/null&lt;br/&gt; if [ $? -ne 0 ]; then&lt;br/&gt;  err &quot;{ \&quot;status\&quot;: \&quot;Failed\&quot;, \&quot;message\&quot;: \&quot;Failed to unmount volume at ${MNTPATH}\&quot;}&quot;&lt;br/&gt;  exit 1&lt;br/&gt; fi&lt;br/&gt;&lt;br/&gt; log &#x27;{&quot;status&quot;: &quot;Success&quot;}&#x27;&lt;br/&gt; exit 0&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;op=$1&lt;br/&gt;&lt;br/&gt;if ! command -v jq &amp;gt;/dev/null 2&amp;gt;&amp;amp;1; then&lt;br/&gt; err &quot;{ \&quot;status\&quot;: \&quot;Failure\&quot;, \&quot;message\&quot;: \&quot;&#x27;jq&#x27; binary not found. Please install jq package before using this driver\&quot;}&quot;&lt;br/&gt; exit 1&lt;br/&gt;fi&lt;br/&gt;&lt;br/&gt;if [ &quot;$op&quot; = &quot;init&quot; ]; then&lt;br/&gt; log &#x27;{&quot;status&quot;: &quot;Success&quot;, &quot;capabilities&quot;: {&quot;attach&quot;: false}}&#x27;&lt;br/&gt; exit 0&lt;br/&gt;fi&lt;br/&gt;&lt;br/&gt;if [ $# -lt 2 ]; then&lt;br/&gt; usage&lt;br/&gt;fi&lt;br/&gt;&lt;br/&gt;shift&lt;br/&gt;&lt;br/&gt;case &quot;$op&quot; in&lt;br/&gt; mount)&lt;br/&gt;  domount $*&lt;br/&gt;  ;;&lt;br/&gt; unmount)&lt;br/&gt;  unmount $*&lt;br/&gt;  ;;&lt;br/&gt; *)&lt;br/&gt;  log &#x27;{&quot;status&quot;: &quot;Not supported&quot;}&#x27;&lt;br/&gt;  exit 0&lt;br/&gt;esac&lt;br/&gt;&lt;br/&gt;exit 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将上面脚本命名成 nfs，放置到 node1 节点对应的插件下面：&lt;code&gt;/usr/libexec/kubernetes/kubelet-plugins/volume/exec/ydzs~nfs/nfs&lt;/code&gt;，并设置权限为 700：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; chmod 700 /usr/libexec/kubernetes/kubelet-plugins/volume/&lt;span&gt;exec&lt;/span&gt;/ydzs~nfs/nfs&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 安装 jq 工具&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; yum -y install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; yum install jq -y&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候我们部署一个应用到 node1 节点上，并用 &lt;code&gt;flexVolume&lt;/code&gt; 来持久化容器中的数据（当然也可以通过定义 flexvolume 类型的 PV、PVC 来使用），如下所示：(test-flexvolume.yaml)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Pod&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;test-flexvolume&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;nodeSelector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;kubernetes.io/hostname:&lt;/span&gt; &lt;span&gt;ydzs-node1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;volumes:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;flexVolume:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;driver:&lt;/span&gt; &lt;span&gt;&quot;ydzs/nfs&quot;&lt;/span&gt;  &lt;span&gt;# 定义插件类型，根据这个参数在对应的目录下面找到插件的可执行文件&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;fsType:&lt;/span&gt; &lt;span&gt;&quot;nfs&quot;&lt;/span&gt;  &lt;span&gt;# 定义存储卷文件系统类型&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;options:&lt;/span&gt;  &lt;span&gt;# 定义所有与存储相关的一些具体参数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;server:&lt;/span&gt; &lt;span&gt;&quot;10.151.30.11&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;share:&lt;/span&gt; &lt;span&gt;&quot;data/k8s&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;containers:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;web&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;nginx&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;containerPort:&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;volumeMounts:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;subPath:&lt;/span&gt; &lt;span&gt;testflexvolume&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;mountPath:&lt;/span&gt; &lt;span&gt;/usr/share/nginx/html&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 &lt;code&gt;flexVolume.driver&lt;/code&gt; 就是插件目录 &lt;code&gt;ydzs~nfs&lt;/code&gt; 对应的 &lt;code&gt;ydzs/nfs&lt;/code&gt; 名称，&lt;code&gt;flexVolume.options&lt;/code&gt; 中根据上面的 nfs 脚本可以得知里面配置的是 NFS 的 Server 地址和挂载目录路径，直接创建上面的资源对象：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; kubectl apply -f &lt;span&gt;test&lt;/span&gt;-flexvolume.yaml&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; kubectl get pods &lt;/span&gt;&lt;br/&gt;NAME                                      READY   STATUS    RESTARTS   AGE&lt;br/&gt;test-flexvolume                           1/1     Running   0          13h&lt;br/&gt;......&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; kubectl &lt;span&gt;exec&lt;/span&gt; -it &lt;span&gt;test&lt;/span&gt;-flexvolume mount |grep &lt;span&gt;test&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;10.151.30.11:/data/k8s/testflexvolume on /usr/share/nginx/html type nfs4 (rw,relatime,vers=4.1,rsize=524288,wsize=524288,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=10.151.30.22,local_lock=none,addr=10.151.30.11)&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; mount |grep &lt;span&gt;test&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;10.151.30.11:/data/k8s on /var/lib/kubelet/pods/a376832a-7638-4faf-b1a0-404956e8e60a/volumes/ydzs~nfs/test type nfs4 (rw,relatime,vers=4.1,rsize=524288,wsize=524288,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=10.151.30.22,local_lock=none,addr=10.151.30.11)&lt;br/&gt;10.151.30.11:/data/k8s/testflexvolume on /var/lib/kubelet/pods/a376832a-7638-4faf-b1a0-404956e8e60a/volume-subpaths/test/web/0 type nfs4 (rw,relatime,vers=4.1,rsize=524288,wsize=524288,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=10.151.30.22,local_lock=none,addr=10.151.30.11)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样我们可以查看到 Pod 的本地持久化目录是被 mount 到了 NFS 上面，证明上面我们的 FlexVolume 插件是正常的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;当我们要去真正的 mount NFS 的时候，就是通过 kubelet 调用 VolumePlugin，然后直接执行命令&lt;code&gt;/usr/libexec/kubernetes/kubelet-plugins/volume/exec/ydzs~nfs/nfs mount &amp;lt;mount dir&amp;gt; &amp;lt;json param&amp;gt;&lt;/code&gt; 来完成的，就相当于平时我们在宿主机上面手动挂载 NFS 的方式一样的，所以存储插件 nfs 是一个可执行的二进制文件或者 shell 脚本都是可以的。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CSI&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然已经有了 FlexVolume 插件了，为什么还需要 CSI 插件呢？上面我们使用 FlexVolume 插件的时候可以看出 FlexVolume 插件实际上相当于就是一个普通的 shell 命令，类似于平时我们在 Linux 下面执行的 &lt;code&gt;ls&lt;/code&gt; 命令一样，只是返回的信息是 JSON 格式的数据，并不是我们通常认为的一个常驻内存的进程，而 CSI 是一个更加完善、编码更加方便友好的一种存储插件扩展方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CSI 是由来自 Kubernetes、Mesos、 Cloud Foundry 等社区成员联合制定的一个行业标准接口规范，旨在将任意存储系统暴露给容器化应用程序。CSI 规范定义了存储提供商实现 CSI 兼容插件的最小操作集合和部署建议，CSI 规范的主要焦点是声明插件必须实现的接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Kubernetes 上整合 CSI 插件的整体架构如下图所示：&lt;img data-ratio=&quot;0.5627777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YuFI2AsdNDW6wxUgkibfZJvpI8qM9rZSm3ucpjzibP9H8D8DJGhlvccUAJpWgpY7iayUVRTiczSltWb5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kubernetes CSI 存储体系主要由两部分组成：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Kubernetes 外部组件：包含 Driver registrar、External provisioner、External attacher 三部分，这三个组件是从 Kubernetes 原本的 in-tree 存储体系中剥离出来的存储管理功能，实际上是 Kubernetes 中的一种外部 controller ，它们 watch kubernetes 的 API 资源对象，根据 watch 到的状态来调用下面提到的第二部分的 CSI 插件来实现存储的管理和操作。这部分是 Kubernetes 团队维护的，插件开发者完全不必关心其实现细节。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Driver registra：用于将插件注册到 kubelet 的 sidecar 容器，并将驱动程序自定义的 NodeId 添加到节点的 Annotations 上，通过与 CSI 上面的 Identity 服务进行通信调用 CSI 的 GetNodeId 方法来完成该操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;External provisioner：用于 watch Kubernetes 的 PVC 对象并调用 CSI 的 CreateVolume 和 DeleteVolume 操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;External attacher：用于 Attach/Detach 阶段，通过 watch Kubernetes 的 VolumeAttachment 对象并调用 CSI 的 ControllerPublish 和 ControllerUnpublish 操作来完成对应的 Volume 的 Attach/Detach。而 Volume 的 Mount/Unmount 阶段并不属于外部组件，当真正需要执行 Mount 操作的时候，kubelet 会去直接调用下面的 CSI Node 服务来完成 Volume 的 Mount/UnMount 操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CSI 存储插件: 这部分正是开发者需要实现的 CSI 插件部分，都是通过 gRPC 实现的服务，一般会用一个二进制文件对外提供服务，主要包含三部分：CSI Identity、CSI Controller、CSI Node。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CSI Identity — 主要用于负责对外暴露这个插件本身的信息，确保插件的健康状态。&lt;pre&gt;&lt;span/&gt;&lt;code&gt;service Identity {&lt;br/&gt;    &lt;span&gt;// 返回插件的名称和版本&lt;/span&gt;&lt;br/&gt;    rpc GetPluginInfo(GetPluginInfoRequest)&lt;br/&gt;        returns (GetPluginInfoResponse) {}&lt;br/&gt;    &lt;span&gt;// 返回这个插件的包含的功能，比如非块存储类型的 CSI 插件不需要实现 Attach 功能，GetPluginCapabilities 就可以在返回中标注这个 CSI 插件不包含 Attach 功能&lt;/span&gt;&lt;br/&gt;    rpc GetPluginCapabilities(GetPluginCapabilitiesRequest)&lt;br/&gt;        returns (GetPluginCapabilitiesResponse) {}&lt;br/&gt;    &lt;span&gt;// 插件插件是否正在运行&lt;/span&gt;&lt;br/&gt;    rpc Probe (ProbeRequest)&lt;br/&gt;        returns (ProbeResponse) {}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CSI Controller - 主要实现 Volume 管理流程当中的 Provision 和 Attach 阶段，Provision 阶段是指创建和删除 Volume 的流程，而 Attach 阶段是指把存储卷附着在某个节点或脱离某个节点的流程，另外只有块存储类型的 CSI 插件才需要  Attach 功能。&lt;pre&gt;&lt;span/&gt;&lt;code&gt;service Controller {&lt;br/&gt;    &lt;span&gt;// 创建存储卷，包括云端存储介质以及PV对象&lt;/span&gt;&lt;br/&gt;    rpc CreateVolume (CreateVolumeRequest)&lt;br/&gt;        returns (CreateVolumeResponse) {}&lt;br/&gt;        &lt;br/&gt;    &lt;span&gt;//  删除存储卷&lt;/span&gt;&lt;br/&gt;    rpc DeleteVolume (DeleteVolumeRequest)&lt;br/&gt;        returns (DeleteVolumeResponse) {}&lt;br/&gt;        &lt;br/&gt;    &lt;span&gt;// 挂载存储卷，将存储介质挂载到目标节点&lt;/span&gt;&lt;br/&gt;    rpc ControllerPublishVolume (ControllerPublishVolumeRequest)&lt;br/&gt;        returns (ControllerPublishVolumeResponse) {}&lt;br/&gt;        &lt;br/&gt;    &lt;span&gt;// 卸载存储卷&lt;/span&gt;&lt;br/&gt;    rpc ControllerUnpublishVolume (ControllerUnpublishVolumeRequest)&lt;br/&gt;        returns (ControllerUnpublishVolumeResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 例如：是否可以同时用于多个节点的读/写&lt;/span&gt;&lt;br/&gt;    rpc ValidateVolumeCapabilities (ValidateVolumeCapabilitiesRequest)&lt;br/&gt;        returns (ValidateVolumeCapabilitiesResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 返回所有可用的 volumes&lt;/span&gt;&lt;br/&gt;    rpc ListVolumes (ListVolumesRequest)&lt;br/&gt;        returns (ListVolumesResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 可用存储池的总容量&lt;/span&gt;&lt;br/&gt;    rpc GetCapacity (GetCapacityRequest)&lt;br/&gt;        returns (GetCapacityResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 例如. 插件可能未实现 GetCapacity、Snapshotting&lt;/span&gt;&lt;br/&gt;    rpc ControllerGetCapabilities (ControllerGetCapabilitiesRequest)&lt;br/&gt;        returns (ControllerGetCapabilitiesResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 创建快照&lt;/span&gt;&lt;br/&gt;    rpc CreateSnapshot (CreateSnapshotRequest)&lt;br/&gt;        returns (CreateSnapshotResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 删除指定的快照&lt;/span&gt;&lt;br/&gt;    rpc DeleteSnapshot (DeleteSnapshotRequest)&lt;br/&gt;        returns (DeleteSnapshotResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取所有的快照&lt;/span&gt;&lt;br/&gt;    rpc ListSnapshots (ListSnapshotsRequest)&lt;br/&gt;        returns (ListSnapshotsResponse) {}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CSI Node — 负责控制 Kubernetes 节点上的 Volume 操作。其中 Volume 的挂载被分成了 NodeStageVolume 和 NodePublishVolume 两个阶段。NodeStageVolume 接口主要是针对块存储类型的 CSI 插件而提供的，块设备在 &quot;Attach&quot; 阶段被附着在 Node 上后，需要挂载至 Pod 对应目录上，但因为块设备在 linux 上只能 mount 一次，而在 kubernetes volume 的使用场景中，一个 volume 可能被挂载进同一个 Node 上的多个 Pod 实例中，所以这里提供了 NodeStageVolume 这个接口，使用这个接口把块设备格式化后先挂载至 Node 上的一个临时全局目录，然后再调用 NodePublishVolume 使用 linux 中的 &lt;code&gt;bind mount&lt;/code&gt; 技术把这个全局目录挂载进 Pod 中对应的目录上。&lt;pre&gt;&lt;span/&gt;&lt;code&gt;service Node {&lt;br/&gt;    &lt;span&gt;// 在节点上初始化存储卷（格式化），并执行挂载到Global目录&lt;/span&gt;&lt;br/&gt;    rpc NodeStageVolume (NodeStageVolumeRequest)&lt;br/&gt;        returns (NodeStageVolumeResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// umount 存储卷在节点上的 Global 目录&lt;/span&gt;&lt;br/&gt;    rpc NodeUnstageVolume (NodeUnstageVolumeRequest)&lt;br/&gt;        returns (NodeUnstageVolumeResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 在节点上将存储卷的 Global 目录挂载到 Pod 的实际挂载目录&lt;/span&gt;&lt;br/&gt;    rpc NodePublishVolume (NodePublishVolumeRequest)&lt;br/&gt;        returns (NodePublishVolumeResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// unmount 存储卷在节点上的 Pod 挂载目录&lt;/span&gt;&lt;br/&gt;    rpc NodeUnpublishVolume (NodeUnpublishVolumeRequest)&lt;br/&gt;        returns (NodeUnpublishVolumeResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取节点上Volume挂载文件系统统计信息（总空间、可用空间等）&lt;/span&gt;&lt;br/&gt;    rpc NodeGetVolumeStats (NodeGetVolumeStatsRequest)&lt;br/&gt;        returns (NodeGetVolumeStatsResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取节点的唯一 ID&lt;/span&gt;&lt;br/&gt;    rpc NodeGetId (NodeGetIdRequest)&lt;br/&gt;        returns (NodeGetIdResponse) {&lt;br/&gt;        option deprecated = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 返回节点插件的能力&lt;/span&gt;&lt;br/&gt;    rpc NodeGetCapabilities (NodeGetCapabilitiesRequest)&lt;br/&gt;        returns (NodeGetCapabilitiesResponse) {}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取节点的一些信息&lt;/span&gt;&lt;br/&gt;    rpc NodeGetInfo (NodeGetInfoRequest)&lt;br/&gt;        returns (NodeGetInfoResponse) {}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需要实现上面的接口就可以实现一个 CSI 插件了。虽然 Kubernetes 并未规定 CSI 插件的打包安装，但是提供了以下建议来简化我们在 Kubernetes 上容器化 CSI Volume 驱动程序的部署方案，具体的方案介绍可以查看 CSI 规范介绍文档 https://github.com/kubernetes/community&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YuFI2AsdNDW6wxUgkibfZJvpiaeF9GU8FVkm5icBtlsB0lALQITI7RLlRQxTCDice0DRYbYI0UKib5WQAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;figcaption&gt;container storage interface deploy&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照上图的推荐方案，CSI Controller 部分以 StatefulSet 或者 Deployment 方式部署，CSI Node 部分以 DaemonSet 方式部署。因为这两部分实现在同一个 CSI 插件程序中，因此只需要把这个 CSI 插件与 External Components 以容器方式部署在同一个 Pod中，把这个 CSI 插件与 Driver registrar 以容器方式部署在 DaemonSet 的 Pod 中，即可完成 CSI 的部署。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们使用的 Rook 部署的 Ceph 集群就是实现了 CSI 插件的:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; kubectl get pods -n rook-ceph |grep plugin&lt;/span&gt;&lt;br/&gt;csi-cephfsplugin-2s9d5                                 3/3     Running     0          21d&lt;br/&gt;csi-cephfsplugin-fgp4v                                 3/3     Running     0          17d&lt;br/&gt;csi-cephfsplugin-fv5nx                                 3/3     Running     0          21d&lt;br/&gt;csi-cephfsplugin-mn8q4                                 3/3     Running     0          17d&lt;br/&gt;csi-cephfsplugin-nf6h8                                 3/3     Running     0          21d&lt;br/&gt;csi-cephfsplugin-provisioner-56c8b7ddf4-68h6d          4/4     Running     0          21d&lt;br/&gt;csi-cephfsplugin-provisioner-56c8b7ddf4-rq4t6          4/4     Running     0          21d&lt;br/&gt;csi-cephfsplugin-xwnl4                                 3/3     Running     0          21d&lt;br/&gt;csi-rbdplugin-7r88w                                    3/3     Running     0          21d&lt;br/&gt;csi-rbdplugin-95g5j                                    3/3     Running     0          21d&lt;br/&gt;csi-rbdplugin-bnzpr                                    3/3     Running     0          21d&lt;br/&gt;csi-rbdplugin-dvftb                                    3/3     Running     0          21d&lt;br/&gt;csi-rbdplugin-jzmj2                                    3/3     Running     0          17d&lt;br/&gt;csi-rbdplugin-provisioner-6ff4dd4b94-bvtss             5/5     Running     0          21d&lt;br/&gt;csi-rbdplugin-provisioner-6ff4dd4b94-lfn68             5/5     Running     0          21d&lt;br/&gt;csi-rbdplugin-trxb4                                    3/3     Running     0          17d&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里其实是实现了 RBD 和 CephFS 两种 CSI，用 DaemonSet 在每个节点上运行了一个包含 &lt;code&gt;Driver registra&lt;/code&gt; 容器的 Pod，当然和节点相关的操作比如 Mount/Unmount 也是在这个 Pod 里面执行的，其他的比如 Provision、Attach 都是在另外的 &lt;code&gt;csi-rbdplugin-provisioner-xxx&lt;/code&gt; Pod 中执行的。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b9c2bd55dd2a7451f72380936bade2b6</guid>
<title>PHP 扩展开发中引用计数与 GC</title>
<link>https://toutiao.io/k/adcltdr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;&amp;#10;                col-lg-8 col-lg-offset-2&amp;#10;                col-md-10 col-md-offset-1&amp;#10;                post-container&quot;&gt;

&lt;h2 id=&quot;0x01&quot;&gt;0x01&lt;/h2&gt;

&lt;p&gt;php扩展的开发现在有不少新的方式比如用zephir。是一种用类似php的语法写php扩展。当然主要的还是用纯C写扩展。在开发php扩展中，由于资料还是比较缺少的，走了不少弯路。
以此来做个记录总结。&lt;/p&gt;

&lt;p&gt;我在开发nmid-php-ext扩展时，先查阅了些php扩展开发文档，目前比较好的可能就是盘古大叔的文档&lt;a href=&quot;https://github.com/pangudashu/php7-internal&quot;&gt;https://github.com/pangudashu/php7-internal&lt;/a&gt;，当然还有惠新宸的博客文章等。
还有就是查看了一些比较经典的php扩展源码，我看的有gearman，swoole1.8，swoole4.4.13。这其中也是有不少坑的地方，尤其是老版本的扩展代码基本上不适用与现在的php。我现在用的都是php7.1以上的版本。
但是可以借鉴一些思想了，我这里思想上大部分是借鉴了gearman的思想，写法上是借鉴了不少swoole4.4.13的写法。&lt;/p&gt;

&lt;p&gt;在写扩展的时候，尤其需要注意的地方可能就是这个引用计数和GC的问题。这个东西虽然占用的代码很少，但是在出现问题时非常的坑爹。因为在一些情况下有时没有问题，但是如果php使用多了话，就会出现php的段错误异常等。
nmid-php-ext扩展遇到的主要问题就是php用户态空间变量或着方法传递到C层调用时候，会出现一些问题。用户空间会传递一个回调函数给C层的doCallBack函数，实际回调函数被调用的地方是C层，但是该回调本身是由用户空间
申请的，由Z_PARAM_FUNC_EX接收的php用户函数，并交由php内核GC管理的。如果扩展函数内不做任何处理操作，那么当切换到用户空间时php内核会判断该变量需要回收，然后扩展函数就会空指针异常等。
当扩展函数内php变量或着函数的生命周期使用结束后，任然需要考虑到php的GC问题。并不是在扩展函数中使用free的。free可以使用在C层自己创建的内存空间。而php的需要调用内核的引用计数接口等。
进行变量的回收以及交由php内核GC管理。这里主要看以下代码。&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c1&quot;&gt;#ifndef GC_ADDREF&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#define GC_ADDREF(ref) ++GC_REFCOUNT(ref)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#define GC_DELREF(ref) --GC_REFCOUNT(ref)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#endif&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;#ifndef ZEND_CLOSURE_OBJECT&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#define ZEND_CLOSURE_OBJECT(op_array) \&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zend_object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;op_array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zend_object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#endif&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;n_zend_fci_cache_persist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zend_fcall_info_cache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fci_cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fci_cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;GC_ADDREF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fci_cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fci_cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;function_handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;op_array&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fn_flags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ZEND_ACC_CLOSURE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;GC_ADDREF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ZEND_CLOSURE_OBJECT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fci_cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;function_handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;nf&quot;&gt;PHP_METHOD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;workerext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fnamel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Worker&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
        &lt;span class=&quot;n&quot;&gt;zend_fcall_info&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fci&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;empty_fcall_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;zend_fcall_info_cache&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fci_cache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;empty_fcall_info_cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;nf&quot;&gt;ZEND_PARSE_PARAMETERS_START&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;Z_PARAM_STRING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fnamel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;Z_PARAM_FUNC_EX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fci_cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;ZEND_PARSE_PARAMETERS_END_EX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;RETURN_FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fci&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;n_zend_fci_cache_persist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fci_cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//这里调用增加引用计数，而且这里的回调函数是闭包&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        
        &lt;span class=&quot;mf&quot;&gt;.............&lt;/span&gt;    
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;0x02&quot;&gt;0x02&lt;/h2&gt;
&lt;p&gt;最后总结：用户空间申请的变量或者函数传递给扩展内函数使用，如果在返回给用户空间后还要使用的话，就需要引用计数+1，因为在返回给用户空间的时候本身用户空间GC会判断该变量或者
函数是否有继续引用，否则就要引用计数-1，用户空间回收该变量或函数。如果扩展内函数（C层的函数）仍然访问该已经注销的变量或者用户态函数，就会导致段错误或异常。在开发php扩展的时候
需要将这些变量的引用与GC做好才能使得扩展安全可靠。当然我本人对扩展还有很多需要学习的地方，目前对php的ZTS线程安全版的扩展开发还有些问题，nmid-php-ext目前也支持NTS非线程安全版php,
这也需要后期解决。&lt;/p&gt;


                &lt;hr/&gt;

                


                
                
                
                
                
                &lt;p id=&quot;gitalk-container&quot;/&gt;
                
                
                
                
                
                

                

            &lt;/div&gt;  

    
        
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>