<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>884628e91e4519772281b9da99eda1f2</guid>
<title>优质网站同好者周刊（第 61 期）- 倾城之链 - 悠然宜想亭</title>
<link>https://toutiao.io/k/y74arhr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;Post-body&quot;&gt;
                    &lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界。此周刊，将汇聚过去一周&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;倾城&lt;/a&gt;所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见&lt;a href=&quot;https://nicelinks.site/about?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;关于倾城&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：本周刊&lt;strong&gt;每周五&lt;/strong&gt;生成，首发于个人微信公众号&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5MDIwMzM2Mg==&amp;amp;action=getalbum&amp;amp;album_id=1530765143352082433&amp;amp;scene=173&amp;amp;from_msgid=2650641087&amp;amp;from_itemidx=1&amp;amp;count=3#wechat_redirect&quot; rel=&quot; nofollow ugc&quot;&gt;晚晴幽草轩&lt;/a&gt;、博客&lt;a href=&quot;https://www.jeffjade.com&quot; rel=&quot; nofollow ugc&quot;&gt;晚晴幽草轩&lt;/a&gt;，以及&lt;a href=&quot;https://forum.lovejade.cn/&quot; rel=&quot; nofollow ugc&quot;&gt;悠然宜想亭&lt;/a&gt;社区；此一键生成脚本基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot; rel=&quot; nofollow ugc&quot;&gt;Deno&lt;/a&gt; 编写，并在 Github 开源：&lt;a href=&quot;https://github.com/nicejade/nicelinks-weekly&quot; rel=&quot; nofollow ugc&quot;&gt;nicejade/nicelinks-weekly&lt;/a&gt;。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%AD%A6%E4%B9%A0&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;学习&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%BC%96%E7%A8%8B&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;编程&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BC%80%E5%8F%91%E8%80%85&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;开发者&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：roadmap, developer roadmaps, developer roadmap, frontend developer, frontend developer roadmap, frontend, frontend roadmap, backend, backend developer, backend developer roadmap, devops, devops roadmap, fullstack developer roadmap, guide to becoming a developer, sre roadmap, sre, operations roadmap, qa roadmap, android roadmap, android developer roadmap&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;Community driven roadmaps, articles, guides, quizzes, tips and resources for developers to learn from, identify their career paths, know what they don`t know, find out the knowledge gaps, learn and improve.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/roadmap.sh.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - Developer Roadmaps&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://roadmap.sh/&quot; rel=&quot; nofollow ugc&quot;&gt;Roadmap.sh&lt;/a&gt; 是一个包含社区策划的路线图、学习计划、路径和资源的地方，供新兴开发人员使用（网站基于 &lt;a href=&quot;https://nicelinks.site/post/61c928af5be6454b4e3d5146&quot; rel=&quot; nofollow ugc&quot;&gt;Next.js&lt;/a&gt; 构建）。它最初是一组图表，用于指导 对下一步应该学习什么感到困惑的开发人员，但仅此还不够，因此我将其扩展到网站，以吸引更多贡献者。&lt;/p&gt;

&lt;p&gt;Roadmap.sh 涉猎内容非常丰富，诸如：FrontEnd、BackEnd、DevOps、&lt;a href=&quot;https://nicelinks.site/post/5b1294b5e93ed2618cfac134&quot; rel=&quot; nofollow ugc&quot;&gt;React&lt;/a&gt;、Android、Python、Go、Java、DBA 等；作者将主题所涉及的相关内容，及其关系，绘制于一张图内，形成指南，从而为开发者带来参考。除了路线图外，该网站还提供有些技术（工具）相关的文章、视频相关分享。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://roadmap.sh/&quot; rel=&quot; nofollow ugc&quot;&gt;Roadmap.sh&lt;/a&gt; 是一个开源项目，截止 2022 年 4 月份，其 Star 数接近 20 万，每月有数十万开发人员访问。您如果对其感兴趣，可订阅更新（支持免费、也支持更新付费内容）。如果你想更多充分了解它，请参见 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://roadmap.sh/about&quot; rel=&quot; nofollow ugc&quot;&gt;About Roadmap.sh&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/6258222ff3a35106466b7702&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - Developer Roadmaps&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%AD%A6%E4%B9%A0&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;学习&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%BC%96%E7%A8%8B&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;编程&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%A4%BE%E5%8C%BA&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;社区&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：freecodecamp, 编程, 前端, 后端, 程序员, python, javascript, git, aws, json, html, css, bootstrap, react, vue, 网站, web, 开发, 课程&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;freeCodeCamp 是一个免费学习编程的开发者社区，涵盖 Python、HTML、CSS、React、Vue、BootStrap、JSON 教程等，还有活跃的技术论坛和丰富的社区活动，在你学习编程和找工作时为你提供建议和帮助。&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/chinese.freecodecamp.org.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - 免费学习编程 - Python、JavaScript、Java、Git 等&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://chinese.freecodecamp.org/&quot; rel=&quot; nofollow ugc&quot;&gt;freeCodeCamp.org&lt;/a&gt;，是一个&lt;strong&gt;免费学习编程的&lt;/strong&gt;开发者社区，涵盖 Python、HTML、CSS、React、Vue、BootStrap、JSON 教程等，还有活跃的技术论坛和丰富的社区活动，在你学习编程和找工作时为你提供建议和帮助。其官网介绍道：自 2014 年以来，已有超过 40,000 名学员，入职科技公司。&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://chinese.freecodecamp.org/&quot; rel=&quot; nofollow ugc&quot;&gt;freeCodeCamp.org&lt;/a&gt; 的使命是：帮助人们免费学习编程。我们通过创建成千上万的视频、文章和交互式编程课程——所有内容向公众免费开放——来实现这一目标。学员在世界各地自发成立数千个 freeCodeCamp 学习小组。所有给 freeCodeCamp 的捐款都将用于我们的教育项目，购买服务器和其他服务，以及聘用员工。&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;在 freeCodeCamp.org，您可以获得以下免费认证：响应式网页设计、JavaScript 算法和数据结构、前端开发库、数据可视化、后端开发和 APIs、Python 和科学计算、Python 和数据分析、Python 和机器学习、信息安全、关系数据库、质量保证等等。&lt;/p&gt;

&lt;p&gt;先前因为检索 &lt;a href=&quot;https://nicelinks.site/post/5b1294b5e93ed2618cfac134&quot; rel=&quot; nofollow ugc&quot;&gt;React&lt;/a&gt; 开发建议，再一次接触到 freeCodeCamp 这个网站，进一步浏览，发现非常多值得阅览的优质文章；深入了解后发现，这是一个&lt;strong&gt;免费学习编程的&lt;/strong&gt;开发者社区，其涉猎内容之广，令人惊叹；相信，无论您是编程初学者，或是已经有丰富编程经验，在这里，都会收获很多；当然，您也可以在 freeCodeCamp 分享自己的学识与经验，从而惠及更多人。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/6256c645f3a35106466b7700&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - 免费学习编程 - Python、JavaScript、Java、Git 等&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;命令行&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%BD%AF%E4%BB%B6&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;软件&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%A8%8B%E5%BA%8F%E5%91%98&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;程序员&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;Curl is used in command lines or scripts to transfer data. curl is also used in cars, television sets, routers, printers, audio equipment, mobile phones, tablets, settop boxes, media players and is the Internet transfer engine for thousands of software applications in over ten billion installations.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/curl.se.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - curl | command line tool and library for transferring data with URLs&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://curl.se/&quot; rel=&quot; nofollow ugc&quot;&gt;Curl&lt;/a&gt; 非常有用的命令行工具库，用于通过 URL 传输数据（是一款免费开源软件）。它的名字就是客户端（client）的 URL 工具的意思（&lt;strong&gt;command line tool and library&lt;/strong&gt; for transferring data with URLs）。它的功能非常强大，命令行参数多达几十种。如能熟练使用，可以在很多应用场景下，发挥巨大的价值。比如，Curl 还用于汽车、电视机、路由器、打印机、音频设备、移动电话、平板电脑、机顶盒、媒体播放器，并且是安装量超过 100 亿的数千个软件应用程序的 Internet 传输引擎。&lt;/p&gt;

&lt;p&gt;Curl 功能非常强大，支持 DICT、FILE、FTP、FTPS、GOPHER、GOPHERS、HTTP、HTTPS、IMAP、IMAPS、LDAP、LDAPS、MQTT、POP3、POP3S、RTMP、RTMPS、RTSP、SCP、SFTP、SMB、SMBS、SMTP、SMTPS、TELNET 和 TFTP。curl 支持 SSL 证书、HTTP POST、HTTP PUT、FTP 上传、基于 HTTP 表单的上传、代理、HTTP/2、HTTP/3、cookie、用户+密码身份验证（Basic、Plain、Digest、CRAM-MD5、SCRAM-SHA、 NTLM、Negotiate 和 Kerberos）、文件传输恢复、代理隧道等格式。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://curl.se/&quot; rel=&quot; nofollow ugc&quot;&gt;Curl&lt;/a&gt; 是一款免费开源软件，截止 2021 年 2 月，最近稳定版本是 &lt;strong&gt;7.75.0&lt;/strong&gt;；无论是 Windows、Mac 还是 Linux 系统，Curl 都已默认安装，因此您可以直接使用。全球几乎每个使用 Internet 的人每天都在使用 Curl。无论您是否从事编程相关工作，相信知晓 Curl 之妙用，将会在很多场景，给你带来效率提升；如果您对这款工具软件感兴趣，可参见文章：&lt;a href=&quot;https://quickapp.lovejade.cn/magic-tools-series-curl/&quot; rel=&quot; nofollow ugc&quot;&gt;堪称神器的命令行工具系列之 curl&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62556c92f3a35106466b76fe&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - curl | command line tool and library for transferring data with URLs&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%AE%98%E7%BD%91&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;官网&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%BE%8E%E9%A3%9F&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;美食&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;海底捞成立于 1994 年，是一家以经营川味火锅为主的连锁品牌，创始人为张勇。&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.haidilao.com.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - 海底捞&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.haidilao.com/&quot; rel=&quot; nofollow ugc&quot;&gt;海底捞&lt;/a&gt;，是一家以经营川味火锅为主的连锁品牌，成立于 1994 年，它以经营川味火锅为主、融汇各地火锅特色为一体，是大型跨省直营餐饮品牌火锅店，全称是：四川海底捞餐饮股份有限公司 。在北京、上海、郑州、西安、南京、天津、杭州，简阳等城市开有连锁门店。该品牌自创立以来，始终奉行“&lt;strong&gt;服务至上，顾客至上&lt;/strong&gt;”的理念，以贴心，周到，优质的服务，赢得了纷至沓来的顾客和社会的广泛赞誉。&lt;/p&gt;

&lt;p&gt;2018 年 5 月 17 日，海底捞在港交所递交上市申请。 2018 年 9 月 3 日，海底捞通过港交所上市聆讯，上半年营收 73.42 亿同比增 54.4%。 2018 年 9 月 27 日，海底捞在港交所上市。 2021 年 11 月 5 日，海底捞公告：决定在 2021 年 12 月 31 日逐步关停 300 家左右客流量相对较低、及经营业绩不如预期的海底捞门店。这几年，在商业上的发展，因各种原因，海底捞似乎不及预期。&lt;/p&gt;

&lt;p&gt;晚上有跟朋友到附近（深圳福田）「海底捞」用餐，其环境尚可（虽然占地颇广，座位宽松，但食客蛮多，有些吵闹），食材新鲜，味道颇好，服务极佳，甚得我心；如不是疫情反复突袭，倒是可以常常光顾。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/6252e4fef3a35106466b76fc&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - 海底捞&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%BA%94%E7%94%A8&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;应用&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Chrome&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;Chrome&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E6%89%A9%E5%B1%95&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;扩展&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;Textomap: Create interactive maps in one click,&lt;br/&gt;
from any text you&#x27;re reading or writing about.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.textomap.com.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - Textomap&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.textomap.com/&quot; rel=&quot; nofollow ugc&quot;&gt;Textomap&lt;/a&gt;，是一个网络应用程序和 Chrome 扩展程序，使用户能够立即（几秒中）从包含位置的任何文本生成地图。用户可以将地图添加到他们的阅读体验中，并使用 Chrome 扩展程序在同一浏览器选项卡中可视化文本。它具有以下特征：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;使用简单，只需在文本框，粘贴您的文本（带有地点内容），它即可开始工作；&lt;/li&gt;
&lt;li&gt;支持多种语言，比如：中文、英文等；而且生成的地图，也跟所输入的本文语言相符；&lt;/li&gt;
&lt;li&gt;无需离开页面，即可为您的阅读体验添加地图；&lt;/li&gt;
&lt;li&gt;使用 Chrome 扩展程序，可&lt;strong&gt;一键可视化&lt;/strong&gt;同一浏览器选项卡中的任何文本；&lt;/li&gt;
&lt;li&gt;支持添加多个来源，收集和比较内容，识别模式和趋势，轻松更新和&lt;strong&gt;编辑&lt;/strong&gt;；&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;目前，&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.textomap.com/&quot; rel=&quot; nofollow ugc&quot;&gt;Textomap&lt;/a&gt; 尚处于公测版本；地图为我们提供重要信息，可让我们更清楚地了解情况。无论是当前新闻、下一个度假目的地，还是有关人物和地点的文章，地图都能为您提供更好的背景和概览。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62529693f3a35106466b76fa&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - Textomap&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/AI&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;AI&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%9B%BE%E7%89%87&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;图片&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%BD%AC%E6%8D%A2&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;转换&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;Image to Cartoon is an online AI cartoonizer that converts your face to cartoon style. Create cartoon avatar and emoji yourself.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/imagetocartoon.com.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - Image to Cartoon | Cartoonize and emoji yourself&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://imagetocartoon.com/&quot; rel=&quot; nofollow ugc&quot;&gt;Cartoonize&lt;/a&gt;，一款在线将&lt;strong&gt;图片&lt;/strong&gt;转&lt;strong&gt;卡通&lt;/strong&gt;的网站，堪称：免费在线最佳 AI 漫画家；Cartoonize 可以将您的脸部照片变成具有 40 多种不同卡通效果的卡通。由人工智能（AI）技术提供支持，它可能是您应用令人难以置信的背景的最佳卡通头像制作者。体验了下，总结出 Cartoonize 具有以下几个特点：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;不仅可以将人脸照片转换为卡通，还可以自己转换表情符号；&lt;/li&gt;
&lt;li&gt;Cartoonize，支持免费使用，每周限制为 9 张；&lt;/li&gt;
&lt;li&gt;免费版本效果有限，您想要下载更具特色的版本，需要帮作者买杯咖啡来解锁；&lt;/li&gt;
&lt;li&gt;使用非常简单，上传照片，等待出结果，选择喜欢的效果，下载即可；&lt;/li&gt;
&lt;li&gt;除了网站外，Cartoonize 还支持 iOS、Android 版本应用；&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;有体验 Cartoonize 的 Web 和 iOS 版本，所转换出卡通效果，还可以。Cartoonize 依靠广告和增值服务获得利益，所以在应用程序上，你会看到广告。如果您有兴趣，将自己的头像卡通化，那么 Cartoonize 是一个挺不错的选择。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/6252908db7bf120669dbd40f&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - Image to Cartoon | Cartoonize and emoji yourself&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对倾城之链感兴趣的朋友，可通过 Web，小程序，快应用等渠道进行访问(后续将支持更多，如 VsCode 插件，Chrome 扩展等)。您有任何问题，欢迎随时向我们反馈（您可以通过官网反馈渠道，或添加如下客服微信），🤲 。&lt;/p&gt;

&lt;p&gt;&amp;lt;div align=&quot;center&quot;&amp;gt;&amp;lt;img src=&quot;&lt;a href=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&quot; rel=&quot; nofollow ugc&quot;&gt;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&lt;/a&gt;&quot; style=&quot;width: 200px;min-width: 200px;&quot; alt=&quot;倾城之链 - 客服微信&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/p&gt;

&lt;h2&gt;本期文末寄语&lt;/h2&gt;

&lt;p&gt;宠辱若惊，贵大患若身。何谓宠辱若惊？&lt;strong&gt;宠为下，得之若惊，失之若惊，是谓宠辱若惊&lt;/strong&gt;。何谓贵大患若身？吾所以有大患者，为吾有身，及吾无身，吾有何患？故贵以身为天下，若可寄天下；爱以身为天下，若可托天下。── 春秋末期人 · 老子李耳《道德经》第十三章&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界；在这里，你可以轻松发现、学习、分享更多有用或有趣的事物。&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/250/h/250/interlace/1/ignore-error/1&quot; title=&quot;&quot; alt=&quot;小程序码 - 倾城之链&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;您可能感兴趣的文章&lt;/h3&gt;



                &lt;/div&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6c30ff0697987b0e8f5ee99f72d48bf5</guid>
<title>阿里技术副总裁贾扬清回应深夜逃离上海去美国；微信灰测腾讯数字人民币钱包小程序；美团被曝发生两年内最大一波裁员｜开发者头条</title>
<link>https://toutiao.io/k/sfq7jrm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;我爱程序员&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;developerWorks&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;我们的产品：《码农周刊》 http://manong.io/ 、《开发者头条》 http://toutiao.io/&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4ef55cf79afd95780d8e23147e3cbb31</guid>
<title>基于 js 实现一个小型编译器</title>
<link>https://toutiao.io/k/h02g7il</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;blockquote data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;本文内容基于 https://github.com/jamiebuilds/the-super-tiny-compiler 仓库源码进行学习&lt;/p&gt;&lt;/blockquote&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIxNjgwMDIzMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/udZl15qqib0OiahcrjrJncW0GOiclg6Jic6IQHYeIGzfXSbZicLUeUxNyQVmPSelMxQxTSu8wAibsyXjy9U3pVfic7FGA/0?wx_fmt=png&quot; data-nickname=&quot;全栈前端精选&quot; data-alias=&quot;Just_FED&quot; data-signature=&quot;内容为王，精选为则。从前端到全栈，定期分享前端、客户端、Node、面试、职场感悟等相关高质量文章。小白的大神养成记，你我共勉！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;最近在研究一些构建侧的东西，在翻 babel 官网的时候看到了这样一段话:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;For an awesome tutorial on compilers, check out the-super-tiny-compiler, which also explains how Babel itself works on a high level.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;出于学习的心态，去翻了一下这个仓库源码，以下是笔者的一些学习的记录，希望看完之后能对你理解 babel 的工作原理有一些帮助~&lt;/p&gt;&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;the-super-tiny-compiler&lt;/code&gt;是一个代码行数只有不到 200 行的超级小型的 compiler，但通过这个 compiler 能学习到最基础的 compile 原理，包括 babel 也是基于这样的原理来进行开发的。&lt;br/&gt;仓库本身的例子是将一组 lisp 风格的函数语法编译成了 C 风格的函数语法，举例子来说:&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;LISP 风格&lt;/th&gt;&lt;th&gt;C 风格&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;2+2&lt;/td&gt;&lt;td&gt;(add 2 2)&lt;/td&gt;&lt;td&gt;add(2,2)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4-2&lt;/td&gt;&lt;td&gt;(subtract 4 2)&lt;/td&gt;&lt;td&gt;substract(4, 2)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2 + (4 - 2)&lt;/td&gt;&lt;td&gt;(add 2 (substract 4 2))&lt;/td&gt;&lt;td&gt;add(2, (substract(4, 2)))&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;这就大概是这次 compiler 需要完成的事情，可能看上去语法不是很完整，但是也能够演示现代编译器的主要部分思想了。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;大多数的 Compilers 都会把编译过程分成三个主要的过程: parse、transform 以及 code generate：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;parse 主要是将源码转换成一种更抽象的代码表达&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;transform 则是将上面抽象的表达进行任意 compiler 想进行的操作&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;code generate 将 transform 处理之后的代码生成一种新的代码&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;Parse&lt;/h2&gt;&lt;p&gt;parse 主要分为两个步骤: 词法分析以及语法分析。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;词法分析将源码根据表达切分一个个的 tokens，tokens 是一组用来描述单独语法的对象，可以是 numbers、labels、punctuation、operators 等&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;语法分析则是将词法分析生成的 tokens 进行重新编排得到一个叫做抽象语法&lt;/span&gt;树&lt;span&gt;(AST)的结构，AST 是一种易于使用且能展示完整信息的嵌套树状结构。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;例如前面提到的 &lt;code&gt;add 2 (subtract 4 2)&lt;/code&gt;表达式被词法分析处理之后生成的 tokens 大概是:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[&lt;br/&gt;  { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;paren&#x27;&lt;/span&gt;,  &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;(&#x27;&lt;/span&gt;        },&lt;br/&gt;  { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;,   &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;add&#x27;&lt;/span&gt;      },&lt;br/&gt;  { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;number&#x27;&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;2&#x27;&lt;/span&gt;        },&lt;br/&gt;  { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;paren&#x27;&lt;/span&gt;,  &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;(&#x27;&lt;/span&gt;        },&lt;br/&gt;  { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;,   &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;subtract&#x27;&lt;/span&gt; },&lt;br/&gt;  { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;number&#x27;&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;4&#x27;&lt;/span&gt;        },&lt;br/&gt;  { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;number&#x27;&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;2&#x27;&lt;/span&gt;        },&lt;br/&gt;  { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;paren&#x27;&lt;/span&gt;,  &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;)&#x27;&lt;/span&gt;        },&lt;br/&gt;  { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;paren&#x27;&lt;/span&gt;,  &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;)&#x27;&lt;/span&gt;        }&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;语法分析处理出来的 AST 结构为:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Program&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;body&lt;/span&gt;: [&lt;br/&gt;      {&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;add&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;params&lt;/span&gt;: [&lt;br/&gt;          {&lt;br/&gt;          &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;2&#x27;&lt;/span&gt;,&lt;br/&gt;          },&lt;br/&gt;         {&lt;br/&gt;           &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;,&lt;br/&gt;           &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;subtract&#x27;&lt;/span&gt;,&lt;br/&gt;           &lt;span&gt;params&lt;/span&gt;: [&lt;br/&gt;            {&lt;br/&gt;              &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;              &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;4&#x27;&lt;/span&gt;,&lt;br/&gt;            }, &lt;br/&gt;            {&lt;br/&gt;              &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;              &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;2&#x27;&lt;/span&gt;,&lt;br/&gt;            }&lt;br/&gt;           ]&lt;br/&gt;         }]&lt;br/&gt;      }]&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Transform&lt;/h2&gt;&lt;p&gt;transform 主要就是拿到 parse 得到的抽象语法树，并基于此做出一些修改。tranform 这个过程既可以基于当前语言的风格去修改 ast 也可以使用一种新的语言风格。&lt;br/&gt;下面基于前面的 ast 结构来展示 transform 这个过程的工作流程。&lt;br/&gt;可以看到，ast 里面的元素看起来都很相似，这些元素组成了 ast 的子结点，这些子结点的数据结构类型描述了代码中的一个单独的部分(例如变量、声明语句，表达式等等)。&lt;br/&gt;例如上面提到的类型是 &lt;code&gt;NumberLiteral&lt;/code&gt;的节点:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;2&#x27;&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者更复杂一点的子节点类型:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;substract&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;params&lt;/span&gt;: [...nested nodes here ...],&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 transfrom 这个过程中，我们可以通过增/删/改来操作抽象语法树结点，或者可以直接基于当前的抽象语法树创建一个新的出来。&lt;br/&gt;既然这里我们的目标是将输入的代码转换成一种新的语言风格的代码(Lisp -&amp;gt; C)，所以这里会创建一个针对新语言的全新 AST 出来。&lt;br/&gt;因此这里我们需要明确一下修改 AST 的操作:&lt;/p&gt;&lt;h3&gt;Traversal(遍历)&lt;/h3&gt;&lt;p&gt;为了能处理所有的结点，我们可以用深度优先搜索对其进行遍历:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Program&#x27;&lt;/span&gt;,&lt;br/&gt;  body: [{&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;,&lt;br/&gt;    name: &lt;span&gt;&#x27;add&#x27;&lt;/span&gt;,&lt;br/&gt;    params: [{&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;      value: &lt;span&gt;&#x27;2&#x27;&lt;/span&gt;&lt;br/&gt;    }, {&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;,&lt;br/&gt;      name: &lt;span&gt;&#x27;subtract&#x27;&lt;/span&gt;,&lt;br/&gt;      params: [{&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;        value: &lt;span&gt;&#x27;4&#x27;&lt;/span&gt;&lt;br/&gt;      }, {&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;        value: &lt;span&gt;&#x27;2&#x27;&lt;/span&gt;&lt;br/&gt;      }]&lt;br/&gt;    }]&lt;br/&gt;  }]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;遍历流程是这样的:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Program - 从 AST 的顶结点开始&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;CallExpression (add) - Program 的第一个子元素&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;NumberLiteral (2) - CallExpression (add) 的第一个子元素&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;CallExpression (subtract) - CallExpression (add) 的第二个子元素&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;NumberLiteral (4) - CallExpression (subtract) 的第一个子元素&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;NumberLiteral (2) - CallExpression (subtract) 的第二个子元素&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果直接在 ast 内部操作而不是产生一个新的 ast，可能就需要介绍所有的种类的抽象。但目前来看，访问所有结点的方法已经足够了。&lt;br/&gt;访问(visiting) 这个词代表一种在对象结构内对元素进行操作的模式。&lt;/p&gt;&lt;h3&gt;Visitors(访问)&lt;/h3&gt;&lt;p&gt;这里我们可以创建一个 visitor 对象，这个对象包括一些方法用于接收不同的结点。&lt;br/&gt;例如:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; visitor = {&lt;br/&gt;  &lt;span&gt;&lt;span&gt;NumberLiteral&lt;/span&gt;(&lt;span/&gt;)&lt;/span&gt; {},&lt;br/&gt;  &lt;span&gt;&lt;span&gt;CallExpression&lt;/span&gt;(&lt;span/&gt;)&lt;/span&gt; {}&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此当我们遍历 ast 的时候，如果匹配到了对应 type 的结点，可以调用 visitor 中的方法来处理。&lt;/p&gt;&lt;h2&gt;Code generate&lt;/h2&gt;&lt;p&gt;Compiler 的最后一个阶段就是 generate, 这个阶段做的事情可能会和 transformation 重叠，但是代码生成最主要的部分还是根据 AST 来输出代码。&lt;br/&gt;Generate 有几种不同的工作方式，有些 Compilers 会重用之前生成的 token，有些则会创建独立的代码表示，以便于线性输出代码，但接下来我们还是着重于使用之前生成好的 AST。&lt;br/&gt;我们的生成器需要知道如何打印 AST 中的所有类型结点，然后递归调用自身，知道所有的代码都被打印到一个很长的字符串中。&lt;/p&gt;&lt;h2&gt;代码实现&lt;/h2&gt;&lt;p&gt;以上就是 Compiler 所有的部分了，但并不是所有的 Compiler 都是这样，不同的 compiler 目的不同，所以也可能需要不同的步骤。&lt;br/&gt;接下来就开始代码的编写:&lt;/p&gt;&lt;h3&gt;词法分析器(tokenizer)&lt;/h3&gt;&lt;p&gt;按照前面的理论分析，我们一步先进行 parser 这个阶段里面的词法分析器(tokenizer)。&lt;br/&gt;这个函数接收一个字符串，然后将其分割成由 token 组成的数组:&lt;br/&gt;ex:&lt;br/&gt;&lt;code&gt;(add 2 (substract 4 2))&lt;/code&gt; =&amp;gt;&lt;code&gt;[{ type: &#x27;paren&#x27;, value: &#x27;(&#x27;}, ...]&lt;/code&gt;&lt;/p&gt;&lt;p&gt;因此可以编写这样的一个函数:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; tokenizer = &lt;span&gt;(&lt;span&gt;input&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; tokens = [];&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; current = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (current &amp;lt; input.length) {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; char = input[current];&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (char === &lt;span&gt;&#x27;(&#x27;&lt;/span&gt;) {&lt;br/&gt;      tokens.push({&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;paren&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;(&#x27;&lt;/span&gt;,&lt;br/&gt;      })&lt;br/&gt;&lt;br/&gt;      current++;&lt;br/&gt;      &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (char === &lt;span&gt;&#x27;)&#x27;&lt;/span&gt;) {&lt;br/&gt;      tokens.push({&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;paren&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;)&#x27;&lt;/span&gt;,&lt;br/&gt;      })&lt;br/&gt;      current ++;&lt;br/&gt;      &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 空格目前不需要处理&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;/\s/&lt;/span&gt;.test(char)) {&lt;br/&gt;      current++;&lt;br/&gt;      &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 处理数字&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;/[0-9]/&lt;/span&gt;.test(char)) {&lt;br/&gt;      &lt;span&gt;let&lt;/span&gt; value = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;// 一直遍历直到遇到非数字的字符&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;/[0-9]/&lt;/span&gt;.test(char)) {&lt;br/&gt;        value += char;&lt;br/&gt;        char = input[++current];&lt;br/&gt;      }&lt;br/&gt;      tokens.push({&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;number&#x27;&lt;/span&gt;,&lt;br/&gt;        value,&lt;br/&gt;      })&lt;br/&gt;      &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 处理字符串&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;/[a-z]/i&lt;/span&gt;.test(char)) {&lt;br/&gt;      &lt;span&gt;let&lt;/span&gt; value = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;/[a-z]/i&lt;/span&gt;.test(char)) {&lt;br/&gt;        value += char;&lt;br/&gt;        char = input[++current];&lt;br/&gt;      }&lt;br/&gt;      tokens.push({&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;,&lt;br/&gt;        value,&lt;br/&gt;      });&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 如果存在匹配不上的 token 就抛错&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;`Unknown token: &lt;span&gt;${char}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; tokens;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;语法分析器(parser)&lt;/h3&gt;&lt;p&gt;词法分析器接收语法分析得到的 token 数组，然后将其转换成 AST 结构。&lt;br/&gt;例如:&lt;br/&gt;&lt;code&gt;[{ type: &#x27;paren&#x27;, value: &#x27;(&#x27; }, ...]&lt;/code&gt; =&amp;gt; &lt;code&gt;{ type: &#x27;Program&#x27;, body: [...] }&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; parser = &lt;span&gt;(&lt;span&gt;tokens&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; current = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; walk = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; token = tokens[current];&lt;br/&gt;    &lt;span&gt;// 如果是 number 类型的结点，返回一个新的 ast 节点即可&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (token.type === &lt;span&gt;&#x27;number&#x27;&lt;/span&gt;) {&lt;br/&gt;      current++;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;value&lt;/span&gt;: token.value,&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 接下来检查 CallExpression 类型，先从左圆括号开始&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;br/&gt;      token.type === &lt;span&gt;&#x27;paren&#x27;&lt;/span&gt; &amp;amp;&amp;amp;&lt;br/&gt;      token.value === &lt;span&gt;&#x27;(&#x27;&lt;/span&gt;&lt;br/&gt;    ) {&lt;br/&gt;      &lt;span&gt;// 跳过左圆括号&lt;/span&gt;&lt;br/&gt;      token = tokens[++current];&lt;br/&gt;      &lt;span&gt;// 首先会创建一个 CallExpression 的根节点，然后 name 设置成当前的 token.value&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// 因为左圆括号后的 token 一定是函数名称&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; node = {&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;name&lt;/span&gt;: token.value,&lt;br/&gt;        &lt;span&gt;params&lt;/span&gt;: [],&lt;br/&gt;      };&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 这里再跳一次函数名称&lt;/span&gt;&lt;br/&gt;      token = tokens[++current];&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 通过循环遍历接下来的每个 token，直到遇到右圆括号&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// 这些 token 会成为 `CallExpression` 的  `params`&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 以 lisp 风格的代码来说: (add 2 (substract 4 2))&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;/**&lt;br/&gt;       * token 中会有很多圆括号&lt;br/&gt;       * [&lt;br/&gt;          { type: &#x27;paren&#x27;,  value: &#x27;(&#x27;        },&lt;br/&gt;          { type: &#x27;name&#x27;,   value: &#x27;add&#x27;      },&lt;br/&gt;          { type: &#x27;number&#x27;, value: &#x27;2&#x27;        },&lt;br/&gt;          { type: &#x27;paren&#x27;,  value: &#x27;(&#x27;        },&lt;br/&gt;          { type: &#x27;name&#x27;,   value: &#x27;subtract&#x27; },&lt;br/&gt;          { type: &#x27;number&#x27;, value: &#x27;4&#x27;        },&lt;br/&gt;          { type: &#x27;number&#x27;, value: &#x27;2&#x27;        },&lt;br/&gt;          { type: &#x27;paren&#x27;,  value: &#x27;)&#x27;        }, &amp;lt;&amp;lt;&amp;lt; 右圆括号&lt;br/&gt;          { type: &#x27;paren&#x27;,  value: &#x27;)&#x27;        }  &amp;lt;&amp;lt;&amp;lt; 右圆括号&lt;br/&gt;        ]&lt;br/&gt;        遇到嵌套的 CallExpressions 的时候，会通过 walk 函数来处理&lt;br/&gt;       *&lt;br/&gt;       */&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;while&lt;/span&gt; (&lt;br/&gt;        token.type !== &lt;span&gt;&#x27;paren&#x27;&lt;/span&gt; ||&lt;br/&gt;        (token.value !== &lt;span&gt;&#x27;)&#x27;&lt;/span&gt; &amp;amp;&amp;amp; token.type === &lt;span&gt;&#x27;paren&#x27;&lt;/span&gt;)&lt;br/&gt;      ) {&lt;br/&gt;        node.params.push(walk());&lt;br/&gt;        token = tokens[current];&lt;br/&gt;      }&lt;br/&gt;      current++;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; node;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;`Unknown token type: &lt;span&gt;${token.&lt;span&gt;type&lt;/span&gt;}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; ast = {&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Program&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;body&lt;/span&gt;: [],&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * 使用递归函数将结点处理进 ast.body 中&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (current &amp;lt; tokens.length) {&lt;br/&gt;    ast.body.push(walk());&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ast;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;遍历器(visitors)&lt;/h3&gt;&lt;p&gt;通过语法分析得到 ast 之后，接下来需要一个遍历器 (visitors) 去遍历结点。然后当遇到某个类型的结点的时候，可以调用 visitors 中对应的类型处理函数:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;traverse(ast, {&lt;br/&gt;  &lt;span&gt;&lt;span&gt;Program&lt;/span&gt;(&lt;span&gt;node, parent&lt;/span&gt;)&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;CallExpression&lt;/span&gt;(&lt;span&gt;node, parent&lt;/span&gt;)&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;NumberLiteral&lt;/span&gt;(&lt;span&gt;node, parent&lt;/span&gt;)&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此我们的代码可以这样写:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; traverser = &lt;span&gt;(&lt;span&gt;ast, visitor&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 用于对数组中的每个元素都调用 traverseNode 函数&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; traverseArray = &lt;span&gt;(&lt;span&gt;array, parent&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    array.forEach(&lt;span&gt;(&lt;span&gt;child&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      traverseNode(child, parent);&lt;br/&gt;    });&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 函数接收一个 node 以及其父结点作为参数&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 这个结点会被传入到 visitor 中相应的处理函数那里&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; traverseNode = &lt;span&gt;(&lt;span&gt;node, parent&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; method = visitor[node.type];&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (method) {&lt;br/&gt;      method(node, parent);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 对不同的结点分开处理&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; (node.type) {&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&#x27;Program&#x27;&lt;/span&gt;:&lt;br/&gt;        traverseArray(node.body, node);&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;:&lt;br/&gt;        traverseArray(node.params, node);&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        &lt;br/&gt;      &lt;span&gt;// 这种情况下就没有子节点了，直接 break 出去&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;      &lt;br/&gt;      &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;`Unknown node type: &lt;span&gt;${node.&lt;span&gt;type&lt;/span&gt;}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  traverseNode(ast, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;转换器(transformer)&lt;/h3&gt;&lt;p&gt;转换器配合上面的遍历器来一起使用，它接收之前构建好的 ast，然后将其和 visitor 一起传入遍历器中，从而得到一个全新的 AST 出来。&lt;br/&gt;原始的 AST 结构为(&lt;code&gt;add 2 (subtract 4 2)&lt;/code&gt;):&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Program&#x27;&lt;/span&gt;,&lt;br/&gt;  body: [{&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;,&lt;br/&gt;    name: &lt;span&gt;&#x27;add&#x27;&lt;/span&gt;,&lt;br/&gt;    params: [{&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;      value: &lt;span&gt;&#x27;2&#x27;&lt;/span&gt;&lt;br/&gt;    }, {&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;,&lt;br/&gt;      name: &lt;span&gt;&#x27;subtract&#x27;&lt;/span&gt;,&lt;br/&gt;      params: [{&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;        value: &lt;span&gt;&#x27;4&#x27;&lt;/span&gt;&lt;br/&gt;      }, {&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;        value: &lt;span&gt;&#x27;2&#x27;&lt;/span&gt;&lt;br/&gt;      }]&lt;br/&gt;    }]&lt;br/&gt;  }]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;转换之后生成的 AST 结构为(&lt;code&gt;add(2, subtract(4, 2))&lt;/code&gt;):&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Program&#x27;&lt;/span&gt;,&lt;br/&gt;  body: [{&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;ExpressionStatement&#x27;&lt;/span&gt;,&lt;br/&gt;    expression: {&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;,&lt;br/&gt;      callee: {&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Identifier&#x27;&lt;/span&gt;,&lt;br/&gt;        name: &lt;span&gt;&#x27;add&#x27;&lt;/span&gt;,&lt;br/&gt;      },&lt;br/&gt;      arguments: [{&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;        value: &lt;span&gt;&#x27;2&#x27;&lt;/span&gt;,&lt;br/&gt;      }, {&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;,&lt;br/&gt;        callee: {&lt;br/&gt;          &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Identifier&#x27;&lt;/span&gt;,&lt;br/&gt;          name: &lt;span&gt;&#x27;subtract&#x27;&lt;/span&gt;,&lt;br/&gt;        },&lt;br/&gt;        arguments: [{&lt;br/&gt;          &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;          value: &lt;span&gt;&#x27;4&#x27;&lt;/span&gt;,&lt;br/&gt;        }, {&lt;br/&gt;          &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;          value: &lt;span&gt;&#x27;2&#x27;&lt;/span&gt;,&lt;br/&gt;        }]&lt;br/&gt;      }]&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来我们可以这样编写对应的转换器代码:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; transformer = &lt;span&gt;(&lt;span&gt;ast&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; newAst = {&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Program&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;body&lt;/span&gt;: [],&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  ast._context = newAst.body;&lt;br/&gt;&lt;br/&gt;  traverser(ast, {&lt;br/&gt;    &lt;span&gt;// 处理 NumberLiteral 类型&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;NumberLiteral&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;node, parent&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      parent._context.push({&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;value&lt;/span&gt;: node.value,&lt;br/&gt;      });&lt;br/&gt;    },&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 处理 CallExpression 类型&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;CallExpression&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;node, parent&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 初始化一个 CallExpression 的新节点&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// 里面放个嵌套的 Identifier 节点&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; expression = {&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;callee&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Identifier&#x27;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;name&lt;/span&gt;: node.name&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;arguments&lt;/span&gt;: [],&lt;br/&gt;      };&lt;br/&gt;&lt;br/&gt;      node._context = expression.arguments;&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 看看父节点是不是 CallExpression&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (parent.type !== &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;) {&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 如果不是的话，就将 CallExpression 节点包在一个叫 `ExpressionStatement` 的语句节点里&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 这么做是因为 top level 的 CallExpression 在 JavaScript 中也可以被当成是声明语句&lt;/span&gt;&lt;br/&gt;        expression = {&lt;br/&gt;          &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;ExpressionStatement&#x27;&lt;/span&gt;,&lt;br/&gt;          expression,&lt;br/&gt;        };&lt;br/&gt;      }&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 最后我们把 CallExpression 放入父结点的 context 中&lt;/span&gt;&lt;br/&gt;      parent._context.push(expression);&lt;br/&gt;    }&lt;br/&gt;  });&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; newAst;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;代码生成器(code generator)&lt;/h3&gt;&lt;p&gt;代码生成器同样是个递归函数，最后会将 AST 中的每个结点打印到一个大的字符串中:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; codeGenerator = &lt;span&gt;(&lt;span&gt;node&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;switch&lt;/span&gt; (node.type) {&lt;br/&gt;    &lt;span&gt;// 如果是 Program，则会遍历 &#x27;body&#x27; 属性中的每个结点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 并且对这些结点进行递归 codeGenerator,再把结果打印进新的一行里面&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&#x27;Program&#x27;&lt;/span&gt;:&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; node.body.map(codeGenerator).join(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 对于 ExpressionStatement 对 expression 属性进行递归调用，并加个分号&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&#x27;ExpressionStatement&#x27;&lt;/span&gt;:&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;`&lt;span&gt;${codeGenerator(node.expression)}&lt;/span&gt;;`&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 对于 CallExpression 对 callee 属性进行递归调用，接着加上(括号&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 然后对 arguments 属性进行递归调用，并加上)括号&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;:&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;`&lt;span&gt;${codeGenerator(node.callee)}&lt;/span&gt;(&lt;span&gt;${node.&lt;span&gt;arguments&lt;/span&gt;.map(codeGenerator).join(&lt;span&gt;&#x27;, &#x27;&lt;/span&gt;)}&lt;/span&gt;)`&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 对于 Identifier,直接返回 name&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&#x27;Identifier&#x27;&lt;/span&gt;:&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; node.name;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 对于 NumberLiteral,直接返回 value&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;:&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; node.value;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;      &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;`Unknown node type: &lt;span&gt;${node.&lt;span&gt;type&lt;/span&gt;}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;编译器(Compiler)&lt;/h3&gt;&lt;p&gt;到这一步，基本上所有的流程就已经完成了，我们可以创建一个 compiler 函数，通过调用上面的函数就可以完成整个 compiler 的工作了:&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;input =&amp;gt; tokenizer =&amp;gt; tokens&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;tokens =&amp;gt; parser =&amp;gt; ast&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;ast =&amp;gt; transformer =&amp;gt; newAst&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;newAst =&amp;gt; generator =&amp;gt; output&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;代码只需要以下简单几步即可:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; compiler = &lt;span&gt;(&lt;span&gt;input&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; tokens = tokenizer(input);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; ast = parser(tokens);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; newAst = transformer(ast);&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; codeGenerator(newAst);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以输入前面的几组测试例子，能保证得到的结果是正确的。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;至此一个 tiny-compiler 就被造出来了，babel 的编译流程也是基于此来完成，因为 babel 本身是个 source to source 的 compiler，整个流程也是分为 parser -&amp;gt; transform -&amp;gt; code generate 这三个步骤完成，具体可以参考 https://babeljs.io/docs/en/#babel-is-a-javascript-compiler&lt;/p&gt;&lt;p&gt;希望本文能帮助读者理解相关编译工具的编译流程。&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a9e072b8e76c3ac3ad19e54cececf799</guid>
<title>短视频内容理解与生成技术在美团的创新实践</title>
<link>https://toutiao.io/k/hu3rp7y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;美团技术团队&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;meituantech&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;10000+工程师，如何支撑中国领先的生活服务电子商务平台？数亿消费者、数百万商户、2000多个行业、几千亿交易额背后是哪些技术在支撑？这里是美团、大众点评、美团外卖、美团配送、美团优选等技术团队的对外窗口。&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a57a90e6700ee01df6bdf652e51094b5</guid>
<title>冷启动算法系列-云音乐歌曲冷启动初探</title>
<link>https://toutiao.io/k/4sxo9kq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article&gt;&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;一、冷启动问题介绍&lt;/h1&gt;&lt;h2&gt;1 什么是冷启动&lt;/h2&gt;&lt;p&gt;在推荐系统中，存在着成千上万的用户，也存在着成千上万的物品，推荐系统的本质任务是为用户推荐其感兴趣的物品。在这里面，用户和物品都是不断更新的，如何给新用户推荐其感兴趣的物品，如何把新物品推荐给对其感兴趣的用户，就是推荐系统的冷启动问题。&lt;br/&gt;所以，推荐系统的冷启动问题，主要包括用户冷启动、物品冷启动两大类。&lt;/p&gt;&lt;h2&gt;2 冷启动的重要性&lt;/h2&gt;&lt;p&gt;用户的流动、不确定性是客观存在的事实，物品的上架、更新、下架也是客观存在的事实，在当今信息过载的时代，用户的不确定性表现的更加明显，如何给这些不确定性的用户推荐好的物品，是推荐系统的主要职能之一。既然用户和物品都是不断产生的，在互联网上是一种常态，那么冷启动问题就会伴随产品的整个生命周期。&lt;/p&gt;&lt;p&gt;互联网上的每个产品都在关注MAU、DAU，在这个流量为王的时代，一个产品能否存活、能否很好的存活，用户起了至关重要的作用。新用户对产品是否满意，能否留存，直接关系到一个产品的用户增长和收益增长。在商业领域，顾客就是上帝，在互联网上，这句话依然适用，并把这句话表现的淋漓尽致。&lt;/p&gt;&lt;p&gt;另外，一个产品能否对其物品推陈出新，是吸引用户的关键所在，从某种意义上来讲，物品的好坏直接决定了一个产品的好坏。&lt;/p&gt;&lt;p&gt;所以，如何解决好新用户、新物品问题，即冷启动问题，对于推荐系统来说非常重要。&lt;/p&gt;&lt;h2&gt;3 冷启动的方法&lt;/h2&gt;&lt;p&gt;根据用户和物品的不同特点，将采取不同的冷启动方法，接下来分别阐述。&lt;/p&gt;&lt;h3&gt;3.1 用户冷启动&lt;/h3&gt;&lt;p&gt;&lt;span&gt;非个性化推荐&lt;/span&gt;&lt;/p&gt;&lt;p&gt;热门推荐是一个不错的方法，虽然没有个性化，但是很多人都有从众心理，根据二八原则，把热门物品推荐给新用户，能否满足80%用户的需求。比如热门电影、热门歌曲、热门短视频的推荐。&lt;/p&gt;&lt;p&gt;&lt;span&gt;利用注册信息推荐&lt;/span&gt;&lt;/p&gt;&lt;p&gt;现在很多app均要求用户注册之后才能使用，所以可以根据这些注册信息进行个性化推荐，比如婚恋网站，可以给男士推荐美女，为美女推荐帅哥等。&lt;/p&gt;&lt;p&gt;另外还可以根据注册的年龄、地域、职业、学历、收入等信息形成人物画像，然后根据这些人物画像进行个性化推荐。&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据兴趣点进行推荐&lt;/span&gt;&lt;/p&gt;&lt;p&gt;现在有些app要求用户在使用之前选择自己的兴趣点，以便推荐系统能够很好进行的推荐，比如新闻类app要求用户选择感兴趣的标签，游戏类app要求用户选择感兴趣的游戏种类，音乐类app要求用户选择感兴趣的曲风等等。&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于少量行为进行推荐&lt;/span&gt;&lt;/p&gt;&lt;p&gt;有些用户活跃度比较低，行为也比较少，但是可以根据这些少有的用户行为进行个性化推荐，比如用户看过某个短视频，则可以根据这个看过的短视频进行推荐。&lt;/p&gt;&lt;p&gt;&lt;span&gt;采用试探的方法进行推荐&lt;/span&gt;&lt;/p&gt;&lt;p&gt;探测利用的方法是推荐系统常用的方法之一。首先随机给用户推荐几个物品，然后根据用户的反馈获取用户的兴趣。这种方法主要适用于较少消耗用户时间的app上，可以快速的定位用户的兴趣，比如新闻类，短视频类app。&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据兴趣迁移策略进行推荐&lt;/span&gt;&lt;/p&gt;&lt;p&gt;有些公司有比较成熟的app，或者一个app上有多类推荐，则可以借助其他的用户兴趣进行迁移推荐，比如有些app即推荐音乐，也推荐短视频，则可以根据用户对音乐的兴趣点推荐相关的短视频。&lt;/p&gt;&lt;h3&gt;3.2 物品冷启动&lt;/h3&gt;&lt;p&gt;&lt;span&gt;基于side information进行推荐&lt;/span&gt;&lt;/p&gt;&lt;p&gt;物品天然具有某些属性信息，比如商品的商家、分类、价格等，再比如音乐的语种、风格、曲风、乐器等，推荐系统则可以根据这些基本信息推荐给相应感兴趣的用户。&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于少量行为进行推荐&lt;/span&gt;&lt;/p&gt;&lt;p&gt;有些物品具有少量的行为信息，则可以根据这些少量的行为信息进行个性化推荐，比如某个用户完整播放了某个短视频，则可以把这个短视频推荐给相似的用户。&lt;/p&gt;&lt;p&gt;&lt;span&gt;采用试探的方法进行推荐&lt;/span&gt;&lt;/p&gt;&lt;p&gt;探测利用的方法同样也适用于物品的冷启动，首先把一个冷启动的物品随机分发给一批用户，根据用户的反馈推荐给相应感兴趣的用户。&lt;/p&gt;&lt;h2&gt;4 冷启动方法的评价指标&lt;/h2&gt;&lt;p&gt;评价一个冷启动方法的好坏，主要考虑以下三点：&lt;/p&gt;&lt;p&gt;&lt;span&gt;覆盖度&lt;/span&gt;&lt;/p&gt;&lt;p&gt;第一个需要考虑的评价指标是覆盖度，覆盖度的大小直接决定了线上效果的好坏，如果覆盖度过低，线上覆盖范围内的效果再好，整体的效果也会大打折扣。对于前面叙述的方法，基于side information的物品冷启动方法和非个性化的用户冷启动方法覆盖度均很高，几乎可以覆盖100%。而基于少量行为的用户冷启动方法和根据兴趣迁移的用户冷启动方法要求就相对严苛一点，其覆盖度就没那么高了。&lt;/p&gt;&lt;p&gt;&lt;span&gt;准确度&lt;/span&gt;&lt;/p&gt;&lt;p&gt;第二个需要考虑的评价指标是准确度，比如根据兴趣迁移的用户冷启动方法因为有较多的用户信息，其推荐的准确度就相对很高，而如基于side information的方法，虽然覆盖度很高，但其准确度就不那么高了。&lt;/p&gt;&lt;p&gt;&lt;span&gt;可解释&lt;/span&gt;&lt;/p&gt;&lt;p&gt;推荐系统中的推荐可解释性，无论对于用户还是对于推荐系统来说都非常重要，现在很多推荐系统也越来越重视推荐的可解释性。同样，对于冷启动问题，好的可解释性，也有利于提升推荐的准确度。比如根据兴趣点进行的用户冷启动方法，就可以很好的为用户解释推荐的物品。&lt;/p&gt;&lt;p&gt;从上述几个评价指标来看，没有一个方法占据所有的优点，所以实践中的推荐系统，也是多种冷启动方法并存，以达到多种方法优点互补的效果。&lt;/p&gt;&lt;p&gt;上述我们简要介绍了冷启动问题的定义，解决两类冷启动问题的一般方法，以及评价冷启动方法的好坏标准。接下来将介绍在在音乐推荐系统中，我们对于解决歌曲冷启动问题的实践方案。&lt;/p&gt;&lt;h1&gt;二、云音乐歌曲冷启动实践&lt;/h1&gt;&lt;h2&gt;1 业务背景&lt;/h2&gt;&lt;p&gt;目前入驻网易云音乐的独立音乐人超40万，独立音乐人每天有大量优秀的新作品发布，如何快速精准的将这些优秀的新作品分发到目标听众的播放列表中，完成歌曲的冷启动进而进入歌曲成长体系是网易云音乐的推荐系统要解决的一个重要问题。&lt;/p&gt;&lt;p&gt;冷启动歌曲由于其特殊性，很难直接套用针对非冷启动歌曲建立的推荐模型，因此需要针对冷启动歌曲建立一套有效的歌曲推荐模型。&lt;/p&gt;&lt;h2&gt;2 歌曲冷启动面临的问题&lt;/h2&gt;&lt;h3&gt;2.1 歌曲特征缺失&lt;/h3&gt;&lt;p&gt;冷启动歌曲面临的根本难题是缺少用户对歌曲的历史交互数据，从而导致特征和样本的缺失。&lt;/p&gt;&lt;p&gt;&lt;span&gt;缺少歌曲统计特征&lt;/span&gt;&lt;/p&gt;&lt;p&gt;包括歌曲的各类行为，如播放，下载，收藏，分享等行为的次数和转化率特征，这类特征通常是歌曲召回和排序模型中重要组成部分，冷启动歌曲由于不包含这些特征无法直接使用现有模型。&lt;/p&gt;&lt;p&gt;&lt;span&gt;缺少样本来训练冷启动歌曲的embedding向量&lt;/span&gt;&lt;/p&gt;&lt;p&gt;推荐系统中召回和排序模型中的歌曲embedding通常是端到端训练得到的，而冷启动歌曲不存在于词表内，无法直接得到对应的歌曲embedding表示。&lt;/p&gt;&lt;h3&gt;2.2 业务可解释性&lt;/h3&gt;&lt;p&gt;歌曲冷启动系统的终极目标还是服务于业务，除了完成将冷启动歌曲成功分发出去这一目标外，还希望冷启动的过程尽量具备可解释性。一个具有可解释性的冷启动系统，将更好的帮助业务去解答诸如什么样的歌曲更容易冷启动成功这类问题，从而为后续冷启动歌曲提供成功经验。&lt;/p&gt;&lt;h2&gt;3 解决方案&lt;/h2&gt;&lt;p&gt;解决歌曲冷启动的核心思想还是尽量增加可用数据，应用最广泛的方法是利用side information的冷启动方法，这类方法通常实现简单且，对数据特征的要求低，同时具有良好的业务可解释性。&lt;/p&gt;&lt;p&gt;下面将从冷启动歌曲召回和冷启动歌曲的排序两个角度分别介绍基于内容标签的冷启动方案。&lt;/p&gt;&lt;h3&gt;3.1 冷启动召回&lt;/h3&gt;&lt;p&gt;由于无法收集到冷启动歌曲的用户交互行为记录，通常无法对冷启动歌曲使用常规的i2i或向量进行召回，但可以退而求其次，利用冷启动歌曲的内容标签进行召回，召回的过程如下图&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQjR4l9SHkvH2HcfHbsgWjibBcBicxib46NpibQLbHHQ3AmduU2NmiaVmTMS6yLqX0AwEjpAPOZSHSN5y9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; title=&quot;&quot; data-ratio=&quot;0.48633879781420764&quot; data-w=&quot;732&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;第一步，召回部分将冷启动歌曲对应的内容标签做预处理归一化，包括仅保留主曲风，小语种归一，专辑艺人和演唱艺人统一等。&lt;/p&gt;&lt;p&gt;第二步，冷启动的歌曲按照内容标签进行归类，每一类内部按照带时间衰减的转化率给予召回候选分，候选分的计算方式为：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQjR4l9SHkvH2HcfHbsgWjibBRf4C6tZOtibs6XyKKv67pBvQowiaGulNVl9kYnu8v5Hso17YO3OjFrFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; title=&quot;&quot; data-ratio=&quot;0.1628242074927954&quot; data-w=&quot;694&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;由三个部分组成&lt;/p&gt;&lt;p&gt;第1部分：时间衰减因子，days表示冷启动天数，T表示半衰期，这部分整体表示的意思是越是近期的新歌曲分数越高。&lt;/p&gt;&lt;p&gt;第2部分：平滑的标签转化率，具体的计算方式为&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQjR4l9SHkvH2HcfHbsgWjibB37GRNEnt7zQoUvSib8BEZYTicnnqv9VptP2Lia6H4I7sK2omEb8TE2abw/640?wx_fmt=png&quot; data-type=&quot;png&quot; title=&quot;&quot; data-ratio=&quot;0.27906976744186046&quot; data-w=&quot;172&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;like7d和play7d分别表示最近7天歌曲在平台内的收藏人数和播放人数，k用于调节初始转化率。这部分表示使用冷启动歌曲的标签维度的转化率表示冷启动歌曲转化率。&lt;/p&gt;&lt;p&gt;第3部分：冷启动歌曲本身的平滑转化率，整体计算过程达到的效果是：1）使用平滑转化率作为召回候选分；2）冷启动初期无冷启动歌曲转化数据，则使用冷启动歌曲对应的内容标签转化率代替；3）随着冷启动分发时间推进，歌曲内容标签转化率作用减少，逐渐被实际歌曲的转化效果代替。&lt;/p&gt;&lt;h3&gt;3.2 冷启动排序&lt;/h3&gt;&lt;p&gt;与召回部分类似，排序时无法直接使用冷启动歌曲的特征，但可以退化为使用冷启动歌曲的标签特征，借用非冷启动歌曲推荐排序模型训练的曲风，语种和艺人的统计特征以及embedding向量来表示冷启动歌曲的缺失特征。&lt;/p&gt;&lt;p&gt;排序部分模型结构如下图&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQjR4l9SHkvH2HcfHbsgWjibB9om0y5dwqzfCa8A24WXELPLibQU2W37BJYUxBPtFP9CZSQWSJVZ4RAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; title=&quot;&quot; data-ratio=&quot;0.680327868852459&quot; data-w=&quot;732&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;包含歌曲侧和用户侧特征构建，以及用户和冷启动歌曲的排序模型。&lt;/p&gt;&lt;p&gt;&lt;span&gt;歌曲侧&lt;/span&gt;&lt;/p&gt;&lt;p&gt;将针对非冷启动歌曲训练的排序模型中的曲风，语种和艺人对应的embedding向量以及歌曲标签对应的统计特征导出。然后根据冷启动歌曲的曲风、语种和艺人标签分别查询embedding和统计特征。&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户侧&lt;/span&gt;&lt;/p&gt;&lt;p&gt;计算用户对非冷启动歌曲曲风、语种和艺人维度的偏好序列，查询embedding并做pooling后将用户的标签偏好表示为对应的偏好向量。&lt;/p&gt;&lt;p&gt;排序模型：该部分对用户曲风，语种和艺人三个维度的向量进行内积计算匹配分，然后加上歌曲标签维度统计特征以及用户维度属性特征输入逻辑回归模型预测用户是否。模型的训练时在用户对非冷启动歌曲的交互样本上进行，训练完成后得到每个的权重输出。&lt;/p&gt;&lt;p&gt;&lt;span&gt;线上预测&lt;/span&gt;&lt;/p&gt;&lt;p&gt;由于用户侧偏好向量、用户属性特征和冷启动歌曲侧标签转化率和歌曲标签向量均可以在离线完成，线上预测时只需要根据歌曲标签查询embedding，然后分别与用户偏好标签进行匹配，最后分别乘以逻辑回归模型中每个维度权重输入sigmoid即可得到用户对冷启动歌曲的排序分。线上预测时计算量少，预测速度快。&lt;/p&gt;&lt;p&gt;最后，得到用户对候选的冷启动歌曲的打分后，取top歌曲插入现有歌曲推荐系统的分发流量中，完成对冷启动歌曲的分发。&lt;/p&gt;&lt;h2&gt;4 业务效果&lt;/h2&gt;&lt;p&gt;衡量冷启动歌曲是否成功分发出去最直接的指标即是冷启动歌曲的曝光覆盖率，即有过歌曲曝光的用户中有多少用户曾曝光过冷启动歌曲。但由于冷启动歌曲不一定全是高质量，给用户推荐了质量不高的歌曲可能影响用户播放体验，因此不能无限制的分发冷启动歌曲。一个好的歌曲冷启动系统应该是对现有歌曲推荐系统无影响或影响尽量小的基础上，让更多的冷启动歌曲被分发出去。&lt;/p&gt;&lt;p&gt;下图对比了线上实验情况，加入冷启动推荐的召回和排序作为实验组，无冷启动推荐作为基准组的实验效果。实验期间在不影响现有歌曲推荐系统用户体验指标前提下，加入歌曲冷启动系统的实验组相比基准组的冷启动歌曲曝光覆盖率取得了相对增加40%以上明显提升。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7189542483660131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQjR4l9SHkvH2HcfHbsgWjibBQhgST4vErUgRfg3q5Dxu3bHyoEldkXuobf0qibrjwmSOfmWU8eF8Licg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;459&quot; title=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;5 小结&lt;/h2&gt;&lt;p&gt;本部分介绍了基于标签的歌曲冷启动推荐方法，该方法简单有效，是目前网易云音乐歌曲推荐系统中重要的组成部分，是构建健康的音乐分发生态系统的重要基石，为众多冷启动新歌的成长提供了第一步的助力。&lt;/p&gt;&lt;p&gt;在本系列的后续内容中，我们将继续分享云音乐在冷启动这一经典问题上的更多解决方法和实践经验，敬请期待。&lt;/p&gt;&lt;blockquote&gt;本文发布自网易云音乐技术团队，文章未经授权禁止任何形式的转载。我们常年招收各类技术岗位，如果你准备换工作，又恰好喜欢云音乐，那就加入我们 staff.musicrecruit@service.ne...&lt;/blockquote&gt;&lt;/article&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>