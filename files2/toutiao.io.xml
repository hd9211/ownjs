<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>9c03d3839044e1943bb937ed4509e556</guid>
<title>浅谈数仓、数仓模型分层</title>
<link>https://toutiao.io/k/151twp1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content post-body&quot;&gt;&lt;p&gt;数据分层是数仓模型设计中十分重要的环节，优秀的分层设计能够让整个数据体系更易理解和使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.studytime.xin/article/20210312000046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;数仓分层意义&quot;&gt;&lt;a href=&quot;#数仓分层意义&quot; class=&quot;headerlink&quot; title=&quot;数仓分层意义&quot;/&gt;数仓分层意义&lt;/h3&gt;&lt;p&gt;  数仓分层目的是使用空间换时间，通过大量预处理，提升用户数据加工效率等，故而存在大量数据冗余。如果不分层，源业务系统的业务规则发生变化将会影响整个数据清洗过程，工作量巨大。&lt;/p&gt;
&lt;p&gt;  通过数据分层管理可以简化数据清洗的过程，因为把原来一步的工作分到了多个步骤去完成，相当于把一个复杂的工作拆成了多个简单的工作，把一个大的黑盒变成了一个白盒，每一层的处理逻辑都相对简单和容易理解，这样我们比较容易保证每一个步骤的正确性，当数据发生错误的时候，往往我们只需要局部调整某个步骤即可。&lt;/p&gt;
&lt;p&gt;综上所述数据分层将可以给我们带来如下的好处：&lt;br/&gt;1、清晰数据结构：每一个数据分层都有它的作用域和职责，在使用表的时候能更方便地定位和理解&lt;br/&gt;2、减少重复开发：规范数据分层，开发一些通用的中间层数据，能够减少极大的重复计算&lt;br/&gt;3、统一数据口径：通过数据分层，提供统一的数据出口，统一对外输出的数据口径&lt;br/&gt;4、复杂问题简单化：将一个复杂的任务分解成多个步骤来完成，每一层解决特定的问题&lt;/p&gt;
&lt;h3 id=&quot;通用可行的数仓分层设计方案&quot;&gt;&lt;a href=&quot;#通用可行的数仓分层设计方案&quot; class=&quot;headerlink&quot; title=&quot;通用可行的数仓分层设计方案&quot;/&gt;通用可行的数仓分层设计方案&lt;/h3&gt;&lt;p&gt;为了满足前面提到数据分层带来的好处，建议将数据模型分为三层：基础数据层（ ODS、STG ）、公共维度模型层（CDM或EDW）和数据应用层（ADS）。如下图所示。简单来讲，我们可以理解为：基础数据层存放的是接入的原始数据，DW层是存放我们要重点设计的数据仓库中间层数据，数据应用层是面向业务定制的应用数据。&lt;/p&gt;
&lt;h3 id=&quot;基础数据层&quot;&gt;&lt;a href=&quot;#基础数据层&quot; class=&quot;headerlink&quot; title=&quot;基础数据层&quot;/&gt;基础数据层&lt;/h3&gt;&lt;p&gt;包含 STG（数据缓冲层）与 ODS（原始数据层）两层，这两层数据结构与业务数据几乎一致。&lt;/p&gt;
&lt;h4 id=&quot;STG-数据准备区或数据缓冲区&quot;&gt;&lt;a href=&quot;#STG-数据准备区或数据缓冲区&quot; class=&quot;headerlink&quot; title=&quot;STG 数据准备区或数据缓冲区&quot;/&gt;STG 数据准备区或数据缓冲区&lt;/h4&gt;&lt;p&gt;定位是缓存来自 DB 抽取、消息、日志解析落地的临时数据，结构与业务系统保持一致；负责对垃圾数据、不规范数据进行清洗转换；该层除为ODS 层服务外，不提供服务，也就是不能被其他更上层次调用。&lt;/p&gt;
&lt;h4 id=&quot;ODS原始数据层或操作数据层&quot;&gt;&lt;a href=&quot;#ODS原始数据层或操作数据层&quot; class=&quot;headerlink&quot; title=&quot;ODS原始数据层或操作数据层&quot;/&gt;ODS原始数据层或操作数据层&lt;/h4&gt;&lt;p&gt;操作数据层定位于业务明细数据保留区，负责保留数据接入时点后历史变更数据，数据原则上全量保留。可以在此层对增量数据或者拉链表数据进行合并。&lt;/p&gt;
&lt;h3 id=&quot;公共维度模型层CDM（Common-Data-Model）或者-企业级数据仓库EDW-（Enterprise-Data-Warehouse）&quot;&gt;&lt;a href=&quot;#公共维度模型层CDM（Common-Data-Model）或者-企业级数据仓库EDW-（Enterprise-Data-Warehouse）&quot; class=&quot;headerlink&quot; title=&quot;公共维度模型层CDM（Common Data Model）或者 企业级数据仓库EDW （Enterprise Data Warehouse）&quot;/&gt;公共维度模型层CDM（Common Data Model）或者 企业级数据仓库EDW （Enterprise Data Warehouse）&lt;/h3&gt;&lt;p&gt;公共维度模型层主要用于存放明细事实数据、维表数据及公共指标汇总数据，其中明细事实数据、维表数据一般根据ODS层数据加工生成；公共指标汇总数据一般根据维表数据和明细事实数据加工生成。本层采用维度模型作为建模方法的理论基础，更多的是通过采用一些维度退化手段，将维度退化至事实表中，减少维表和事实表的关联，提高数据易用性。&lt;/p&gt;
&lt;h4 id=&quot;明细数据层：DWD（Data-Warehouse-Detail）&quot;&gt;&lt;a href=&quot;#明细数据层：DWD（Data-Warehouse-Detail）&quot; class=&quot;headerlink&quot; title=&quot;明细数据层：DWD（Data Warehouse Detail）&quot;/&gt;明细数据层：DWD（Data Warehouse Detail）&lt;/h4&gt;&lt;p&gt;该层一般保持和ODS层一样的数据粒度，并且提供一定的数据质量保证。同时，为了提高数据明细层的易用性，该层会采用一些维度退化手法，将维度退化至事实表中，减少事实表和维表的关联。同时在此层会采用明细宽表，复用关联计算，极少数据扫描。举例：订单主表以及订单明细表，可以以订单明细表作为最小粒度，连表整合订单表数据，生成dwd层订单事实表。&lt;/p&gt;
&lt;h4 id=&quot;数据汇总层：DWS（Data-WareHouse-Summary）&quot;&gt;&lt;a href=&quot;#数据汇总层：DWS（Data-WareHouse-Summary）&quot; class=&quot;headerlink&quot; title=&quot;数据汇总层：DWS（Data WareHouse Summary）&quot;/&gt;数据汇总层：DWS（Data WareHouse Summary）&lt;/h4&gt;&lt;p&gt;该层会在DWD层的数据基础上，对数据做轻度的聚合操作，生成一系列的中间表，提升公共指标的复用性，减少重复加工。直观来讲，就是对通用的核心维度进行聚合操作，算出相应的统计指标。&lt;/p&gt;
&lt;h3 id=&quot;公共维度模型层CDM主要作用&quot;&gt;&lt;a href=&quot;#公共维度模型层CDM主要作用&quot; class=&quot;headerlink&quot; title=&quot;公共维度模型层CDM主要作用&quot;/&gt;公共维度模型层CDM主要作用&lt;/h3&gt;&lt;p&gt;1、组合相关和相识数据，采用明细宽表，复用关联计算，减少数据扫描&lt;br/&gt;2、公共指标统一加工，为上层数据产品应用，服务提供公共指标，建立逻辑汇总宽表&lt;br/&gt;3、建立一致性维度，一致性的数据分析维度，降低数据计算口径，解决算法不同意的风险&lt;/p&gt;
&lt;h3 id=&quot;应⽤层-ADS（Application-Data-Mart-应⽤数据集市）&quot;&gt;&lt;a href=&quot;#应⽤层-ADS（Application-Data-Mart-应⽤数据集市）&quot; class=&quot;headerlink&quot; title=&quot;应⽤层 ADS（Application Data Mart-应⽤数据集市）&quot;/&gt;应⽤层 ADS（Application Data Mart-应⽤数据集市）&lt;/h3&gt;&lt;p&gt;数据应用层，也叫DM(数据集市)或APP层等，面试实际的数据需求，可以直接给业务人员使用，以DWD或者DWS层的数据为基础，组成各种统计报表。除此之外还有一些直接的表现形式，例如主题大宽度表集市，以及横表转纵表等。&lt;/p&gt;
&lt;h4 id=&quot;宽表&quot;&gt;&lt;a href=&quot;#宽表&quot; class=&quot;headerlink&quot; title=&quot;宽表&quot;/&gt;宽表&lt;/h4&gt;&lt;p&gt;宽表这块我的理解是，基于维度模型的扩展，采用退化维度的方式，将不同维度的度量放入数据表的不同列中，同时将于主分析维度相关的指标进行整合，更利于理解，以及较好的查询性能。&lt;/p&gt;
&lt;p&gt;宽表物理设计结构：&lt;br/&gt;1、基本属性&lt;br/&gt;2、日行为汇总指标&lt;br/&gt;3、周期行为汇总指标&lt;br/&gt;4、历史累计属性和指标&lt;/p&gt;
&lt;h3 id=&quot;思考和总结一下&quot;&gt;&lt;a href=&quot;#思考和总结一下&quot; class=&quot;headerlink&quot; title=&quot;思考和总结一下&quot;/&gt;思考和总结一下&lt;/h3&gt;&lt;p&gt;从数据应用理解上来讲，目的是希望越上层次，对使用者约友好。比如ADS层，基本是完全为应用来设计的，很易懂，DWS层的话，相对来讲就会有一点点理解成本，然后DWD层就比较难理解了，因为它的维度可能会比较多，而且一个需求可能要多张表经过很复杂的计算才能完成。&lt;/p&gt;
&lt;p&gt;从能力范围来讲，我们希望80%需求由20%的表来支持。直接点讲，就是大部分（80%以上）的需求，都用DWS的表来支持就行，DWS支持不了的，就用DWD的表来支持，这些都支持不了的极少一部分数据需要从原始日志中后去。&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0d9ae6a3be783c208a9b70b2a093a046</guid>
<title>[译] 新老手必备的 34 种 JavaScript 简写优化技术</title>
<link>https://toutiao.io/k/jdslwhk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原文：https://javascript.plainenglish.io/34-javascript-optimization-techniques-to-know-in-2021-d561afdf73c3&lt;br/&gt;作者：Atit&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发者的生活总是在学习新的东西，跟上变化不应该比现在更难，我的动机是介绍所有JavaScript的最佳实践，比如简写功能，作为一个前端开发者，我们必须知道，让我们的生活在2021年变得更轻松。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可能做了很长时间的JavaScript开发，但有时你可能没有更新最新的特性，这些特性可以解决你的问题，而不需要做或编写一些额外的代码。这些技术可以帮助您编写干净和优化的JavaScript代码。此外，这些主题可以帮助你为2021年的JavaScript面试做准备。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.如果有多个条件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以在数组中存储多个值，并且可以使用数组 &lt;code&gt;include&lt;/code&gt; 方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (x === &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt; || x === &lt;span&gt;&#x27;def&#x27;&lt;/span&gt; || x === &lt;span&gt;&#x27;ghi&#x27;&lt;/span&gt; || x ===&lt;span&gt;&#x27;jkl&#x27;&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;//logic&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; ([&lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;def&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;ghi&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;jkl&#x27;&lt;/span&gt;].includes(x)) {&lt;br/&gt;  &lt;span&gt;//logic&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.如果为真…否则简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这对于我们有 &lt;code&gt;if-else&lt;/code&gt; 条件，里面不包含更大的逻辑时，是一个较大的捷径。我们可以简单的使用三元运算符来实现这个简写。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test: boolean;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (x &amp;gt; &lt;span&gt;100&lt;/span&gt;) {&lt;br/&gt;  test = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  test = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test = (x &amp;gt; &lt;span&gt;10&lt;/span&gt;) ? &lt;span&gt;true&lt;/span&gt; : &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//or we can use directly&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test = x &amp;gt; &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(test);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们有嵌套条件时，我们可以采用这种方式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; x = &lt;span&gt;300&lt;/span&gt;,&lt;br/&gt;test2 = (x &amp;gt; &lt;span&gt;100&lt;/span&gt;) ? &lt;span&gt;&#x27;greater 100&#x27;&lt;/span&gt; : (x &amp;lt; &lt;span&gt;50&lt;/span&gt;) ? &lt;span&gt;&#x27;less 50&#x27;&lt;/span&gt; : &lt;span&gt;&#x27;between 50 and 100&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(test2); &lt;span&gt;// &quot;greater than 100&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.声明变量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们要声明两个具有共同值或共同类型的变量时，可以使用此简写形式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1, test2 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.Null, Undefined，空检查&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们创建新的变量时，有时我们想检查我们引用的变量的值是否为空或undefined。JavaScript确实有一个非常好的简写工具来实现这些功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test1 !== &lt;span&gt;null&lt;/span&gt; || test1 !== &lt;span&gt;undefined&lt;/span&gt; || test1 !== &lt;span&gt;&#x27;&#x27;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; test2 = test1;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = test1 || &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.null值检查和分配默认值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;    test2 = test1 || &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;null check&quot;&lt;/span&gt;, test2); &lt;span&gt;// output will be &quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.undefined值检查和分配默认值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;    test2 = test1 || &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;undefined check&quot;&lt;/span&gt;, test2); &lt;span&gt;// output will be &quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常值检查&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;&#x27;test&#x27;&lt;/span&gt;,&lt;br/&gt;    test2 = test1 || &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(test2); &lt;span&gt;// output: &#x27;test&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.将值分配给多个变量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们处理多个变量并希望将不同的值分配给不同的变量时，此简写技术非常有用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1, test2, test3;&lt;br/&gt;test1 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;test2 = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;test3 = &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; [test1, test2, test3] = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.赋值运算符简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在编程中处理很多算术运算符，这是将运算符分配给JavaScript变量的有用技术之一。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;test1 = test1 + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;test2 = test2 - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;test3 = test3 * &lt;span&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;test1++;&lt;br/&gt;test2--;&lt;br/&gt;test3 *= &lt;span&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.如果存在简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是我们大家都在使用的常用简写之一，但仍然值得一提。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test1 === &lt;span&gt;true&lt;/span&gt;) or &lt;span&gt;if&lt;/span&gt; (test1 !== &lt;span&gt;&quot;&quot;&lt;/span&gt;) or &lt;span&gt;if&lt;/span&gt; (test1 !== &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand //it will check empty string,null and undefined too&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test1)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：如果test1有任何值，它将在if循环后进入逻辑，该运算符主要用于 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 的检查。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.多个条件的AND（&amp;amp;&amp;amp;）运算符&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果仅在变量为 &lt;code&gt;true&lt;/code&gt; 的情况下才调用函数，则可以使用 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 运算符。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test1) {&lt;br/&gt; callMethod(); &lt;br/&gt;} &lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;test1 &amp;amp;&amp;amp; callMethod();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.foreach循环简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是迭代的常用简写技术之一。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; testData.length; i++)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; testData) or  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i &lt;span&gt;of&lt;/span&gt; testData)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个变量的数组&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;testData&lt;/span&gt;(&lt;span&gt;element, index, array&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;test[&#x27;&lt;/span&gt; + index + &lt;span&gt;&#x27;] = &#x27;&lt;/span&gt; + element);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;[&lt;span&gt;11&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;].forEach(testData);&lt;br/&gt;&lt;span&gt;// logs: test[0] = 11, test[1] = 24, test[2] = 32&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12.return中比较&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以在return语句中使用比较。它将避免我们的5行代码，并将它们减少到1行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;checkReturn&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!(test === &lt;span&gt;undefined&lt;/span&gt;)) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; test;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; callMe(&lt;span&gt;&#x27;test&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; data = checkReturn();&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(data); &lt;span&gt;//output test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;callMe&lt;/span&gt;(&lt;span&gt;val&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(val);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;checkReturn&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; test || callMe(&lt;span&gt;&#x27;test&#x27;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.箭头函数&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;a, b&lt;/span&gt;) &lt;/span&gt;{ &lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; a + b; &lt;br/&gt;} &lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; add = &lt;span&gt;(&lt;span&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; a + b;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多示例。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;callMe&lt;/span&gt;(&lt;span&gt;name&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;Hello&#x27;&lt;/span&gt;, name);&lt;br/&gt;}&lt;br/&gt;callMe = &lt;span&gt;&lt;span&gt;name&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;Hello&#x27;&lt;/span&gt;, name);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14.短函数调用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用三元运算符来实现这些功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;test1&#x27;&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;test2&#x27;&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; test3 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test3 == &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;  test1();&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  test2();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;(test3 === &lt;span&gt;1&lt;/span&gt;? test1:test2)();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;15. Switch简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以将条件保存在键值对象中，并可以根据条件使用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;switch&lt;/span&gt; (data) {&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;:&lt;br/&gt;    test1();&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;:&lt;br/&gt;    test2();&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;:&lt;br/&gt;    test();&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// And so on...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; data = {&lt;br/&gt;  &lt;span&gt;1&lt;/span&gt;: test1,&lt;br/&gt;  &lt;span&gt;2&lt;/span&gt;: test2,&lt;br/&gt;  &lt;span&gt;3&lt;/span&gt;: test&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;data[something] &amp;amp;&amp;amp; data[something]();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;16.隐式返回简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用箭头函数，我们可以直接返回值，而不必编写return语句。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;calculate&lt;/span&gt;(&lt;span&gt;diameter&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;.PI * diameter&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;calculate = &lt;span&gt;&lt;span&gt;diameter&lt;/span&gt; =&amp;gt;&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;Math&lt;/span&gt;.PI * diameter;&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;17.小数基数指数&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10000&lt;/span&gt;; i++) { ... }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1e4&lt;/span&gt;; i++) {&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;18.默认参数值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;test1, test2&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (test1 === &lt;span&gt;undefined&lt;/span&gt;)&lt;br/&gt;    test1 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (test2 === &lt;span&gt;undefined&lt;/span&gt;)&lt;br/&gt;    test2 = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; test1 + test2;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;add = &lt;span&gt;(&lt;span&gt;test1 = &lt;span&gt;1&lt;/span&gt;, test2 = &lt;span&gt;2&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; (test1 + test2);&lt;br/&gt;add() &lt;span&gt;//output: 3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;19.扩展运算符简写&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// joining arrays using concat&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; data = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test = [&lt;span&gt;4&lt;/span&gt; ,&lt;span&gt;5&lt;/span&gt; , &lt;span&gt;6&lt;/span&gt;].concat(data);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// joining arrays&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; data = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test = [&lt;span&gt;4&lt;/span&gt; ,&lt;span&gt;5&lt;/span&gt; , &lt;span&gt;6&lt;/span&gt;, ...data];&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(test); &lt;span&gt;// [ 4, 5, 6, 1, 2, 3]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于克隆，我们也可以使用扩展运算符。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// cloning arrays&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test1 = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test2 = test1.slice()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// cloning arrays&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test1 = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test2 = [...test1];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;20.模板文字&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您厌倦了在单个字符串中使用 &lt;code&gt;+&lt;/code&gt; 来连接多个变量，那么这种简写可以消除您的头痛。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; welcome = &lt;span&gt;&#x27;Hi &#x27;&lt;/span&gt; + test1 + &lt;span&gt;&#x27; &#x27;&lt;/span&gt; + test2 + &lt;span&gt;&#x27;.&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; welcome = &lt;span&gt;`Hi &lt;span&gt;${test1}&lt;/span&gt; &lt;span&gt;${test2}&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;21.多行字符串简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们在代码中处理多行字符串时，可以使用以下功能：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; data = &lt;span&gt;&#x27;abc abc abc abc abc abc\n\t&#x27;&lt;/span&gt;&lt;br/&gt;    + &lt;span&gt;&#x27;test test,test test test test\n\t&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; data = &lt;span&gt;`abc abc abc abc abc abc&lt;br/&gt;         test test,test test test test`&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;22.对象属性分配&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;&#x27;a&#x27;&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = &lt;span&gt;&#x27;b&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; obj = {&lt;span&gt;test1&lt;/span&gt;: test1, &lt;span&gt;test2&lt;/span&gt;: test2}; &lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; obj = {test1, test2};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;23.将字符串转换成数字&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;parseInt&lt;/span&gt;(&lt;span&gt;&#x27;123&#x27;&lt;/span&gt;); &lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = &lt;span&gt;parseFloat&lt;/span&gt;(&lt;span&gt;&#x27;12.3&#x27;&lt;/span&gt;); &lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1 = +&lt;span&gt;&#x27;123&#x27;&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = +&lt;span&gt;&#x27;12.3&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;24.用解构简写&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test1 = &lt;span&gt;this&lt;/span&gt;.data.test1;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test2 = &lt;span&gt;this&lt;/span&gt;.data.test2;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test2 = &lt;span&gt;this&lt;/span&gt;.data.test3;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { test1, test2, test3 } = &lt;span&gt;this&lt;/span&gt;.data;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;25.用Array.find简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们确实有一个对象数组并且我们想要根据对象属性查找特定对象时，find方法确实很有用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; data = [&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;test2&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;cde&#x27;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;fgh&#x27;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;]&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;findtest1&lt;/span&gt;(&lt;span&gt;name&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; data.length; ++i) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (data[i].type === &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt; &amp;amp;&amp;amp; data[i].name === name) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; data[i];&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand&lt;/span&gt;&lt;br/&gt;filteredData = data.find(&lt;span&gt;&lt;span&gt;data&lt;/span&gt; =&amp;gt;&lt;/span&gt; data.type === &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt; &amp;amp;&amp;amp; data.name === &lt;span&gt;&#x27;fgh&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(filteredData); &lt;span&gt;// { type: &#x27;test1&#x27;, name: &#x27;fgh&#x27; }&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;26.查找条件简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们有代码来检查类型，根据类型需要调用不同的方法，我们可以选择使用多个else ifs或者switch，但是如果我们有比这更好的简写方法呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (type === &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt;) {&lt;br/&gt;  test1();&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type === &lt;span&gt;&#x27;test2&#x27;&lt;/span&gt;) {&lt;br/&gt;  test2();&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type === &lt;span&gt;&#x27;test3&#x27;&lt;/span&gt;) {&lt;br/&gt;  test3();&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type === &lt;span&gt;&#x27;test4&#x27;&lt;/span&gt;) {&lt;br/&gt;  test4();&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;&#x27;Invalid value &#x27;&lt;/span&gt; + type);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; types = {&lt;br/&gt;  &lt;span&gt;test1&lt;/span&gt;: test1,&lt;br/&gt;  &lt;span&gt;test2&lt;/span&gt;: test2,&lt;br/&gt;  &lt;span&gt;test3&lt;/span&gt;: test3,&lt;br/&gt;  &lt;span&gt;test4&lt;/span&gt;: test4&lt;br/&gt;};&lt;br/&gt; &lt;br/&gt;&lt;span&gt;var&lt;/span&gt; func = types[type];&lt;br/&gt;(!func) &amp;amp;&amp;amp; &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;&#x27;Invalid value &#x27;&lt;/span&gt; + type); func();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;27.按位索引简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们遍历数组以查找特定值时，我们确实使用 &lt;code&gt;indexOf()&lt;/code&gt; 方法，如果找到更好的方法该怎么办？让我们看看这个例子。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(arr.indexOf(item) &amp;gt; &lt;span&gt;-1&lt;/span&gt;) { &lt;span&gt;// item found &lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(arr.indexOf(item) === &lt;span&gt;-1&lt;/span&gt;) { &lt;span&gt;// item not found&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(~arr.indexOf(item)) { &lt;span&gt;// item found&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(!~arr.indexOf(item)) { &lt;span&gt;// item not found&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按位（&lt;code&gt;〜&lt;/code&gt;）运算符将返回除-1以外的任何值的真实值。否定它就像做 &lt;code&gt;~~&lt;/code&gt; 一样简单。另外，我们也可以使用 &lt;code&gt;include()&lt;/code&gt; 函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (arr.includes(item)) { &lt;br/&gt;&lt;span&gt;// true if the item found&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;28.Object.entries()&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此函数有助于将对象转换为对象数组。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; data = { &lt;span&gt;test1&lt;/span&gt;: &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;, &lt;span&gt;test2&lt;/span&gt;: &lt;span&gt;&#x27;cde&#x27;&lt;/span&gt;, &lt;span&gt;test3&lt;/span&gt;: &lt;span&gt;&#x27;efg&#x27;&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; arr = &lt;span&gt;Object&lt;/span&gt;.entries(data);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(arr);&lt;br/&gt;&lt;span&gt;/** Output:&lt;br/&gt;[ [ &#x27;test1&#x27;, &#x27;abc&#x27; ],&lt;br/&gt;  [ &#x27;test2&#x27;, &#x27;cde&#x27; ],&lt;br/&gt;  [ &#x27;test3&#x27;, &#x27;efg&#x27; ]&lt;br/&gt;]&lt;br/&gt;**/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;29.Object.values()&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是ES8中引入的一项新功能，该功能执行与 &lt;code&gt;Object.entries()&lt;/code&gt; 类似的功能，但没有关键部分：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; data = { &lt;span&gt;test1&lt;/span&gt;: &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;, &lt;span&gt;test2&lt;/span&gt;: &lt;span&gt;&#x27;cde&#x27;&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; arr = &lt;span&gt;Object&lt;/span&gt;.values(data);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(arr);&lt;br/&gt;&lt;span&gt;/** Output:&lt;br/&gt;[ &#x27;abc&#x27;, &#x27;cde&#x27;]&lt;br/&gt;**/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;30.双按位简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双重NOT按位运算符方法仅适用于32位整数）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Math&lt;/span&gt;.floor(&lt;span&gt;1.9&lt;/span&gt;) === &lt;span&gt;1&lt;/span&gt; &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;~~&lt;span&gt;1.9&lt;/span&gt; === &lt;span&gt;1&lt;/span&gt; &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;31.重复一个字符串多次&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要一次又一次地重复相同的字符，我们可以使用for循环并将它们添加到同一循环中，但是如果我们有一个简写方法呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i ++) { &lt;br/&gt;  test += &lt;span&gt;&#x27;test &#x27;&lt;/span&gt;; &lt;br/&gt;} &lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(str); &lt;span&gt;// test test test test test &lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&#x27;test &#x27;&lt;/span&gt;.repeat(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;32.在数组中查找最大值和最小值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; arr = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]; &lt;br/&gt;&lt;span&gt;Math&lt;/span&gt;.max(…arr); &lt;span&gt;// 3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Math&lt;/span&gt;.min(…arr); &lt;span&gt;// 1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;33.从字符串中获取字符&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; str = &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;str.charAt(&lt;span&gt;2&lt;/span&gt;); &lt;span&gt;// c&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;Note: If we know the index &lt;span&gt;of&lt;/span&gt; the array then we can directly use index insted &lt;span&gt;of&lt;/span&gt; character.If we are not sure about index it can &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;undefined&lt;/span&gt;&lt;br/&gt;str[&lt;span&gt;2&lt;/span&gt;]; &lt;span&gt;// c&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;34.数学指数幂函数的简写&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Math&lt;/span&gt;.pow(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;); &lt;span&gt;// 8&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;**&lt;span&gt;3&lt;/span&gt; &lt;span&gt;// 8&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e9c6e5993f13c953bc9d741fed3c08ec</guid>
<title>史上超强拷贝仓：GitHub 热点速览 v.21.11</title>
<link>https://toutiao.io/k/8ku8lte</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.3328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNNoMXlqibETY6839Etw3X7CRw88W5VXbJr8T0DQFVjRGaEa1YClm5qKkkYz68aGSTva9VZuCw6zugQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：HelloGitHub-小鱼干&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Clone-Wars 是真的强，能细数 70+ 知名应用网站的源码，即便你不看代码，也可以了解下各大网站的所用技术栈。同样很强的是用 OpenCV 实现的图片转 csv 文件的 image2csv。而作为开源的认证和授权服务器的 authelia 也很强，和反向代理们搭档，拦截不可靠的 Query 查询，保证数据安全。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下内容摘录自微博@HelloGitHub 的 GitHub Trending 及 Hacker News 热帖（简称 HN 热帖），选项标准：&lt;code&gt;新发布&lt;/code&gt; | &lt;code&gt;实用&lt;/code&gt; | &lt;code&gt;有趣&lt;/code&gt;，根据项目 release 时间分类，发布时间不超过 14 day 的项目会标注 &lt;code&gt;New&lt;/code&gt;，无该标志则说明项目 release 超过半月。由于本文篇幅有限，还有部分项目未能在本文展示，望周知 🌝&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNoMXlqibETY6839Etw3X7CR1qO6BrLhwogFmy9Aia31TtJVRIKMdTKauzpK4zKOHFX6NIwicurVAfOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.4124087591240876&quot; data-w=&quot;822&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1. 本周特推&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开始本周的特推之前，如果你有什么想要的 GitHub 项目，记得留言呀~你的留言超重要 (≧▽≦)&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 图片转 csv 文件：image2csv&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：500+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;New&lt;/code&gt; image2csv 是一个提取图片中的数据信息生成 csv 文件的小工具。它用 OpenCV 做图片处理，Tesseract 识别图片中数据。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/artperrin/image2csv&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNoMXlqibETY6839Etw3X7CRWP3ku0s3IYvkABkKqibicUV6C8HP0IYstHic9OfPrRFXLspEcOFMEzWnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 史上最强拷贝仓：Clone-Wars&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：3,300+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;New&lt;/code&gt; Clone-Wars 收录了 70+ 国内外知名网站的 Clone 版，诸如 Airbnb、Amazon、Instagram、Netflix、Tiktok、Spotify 等等，并注明了各个网站使用了什么技术栈，可以说是一个十分优秀的技术学习项目了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/GorvGoyl/Clone-Wars&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNoMXlqibETY6839Etw3X7CROODEkVxp1iaWevic1N4NfcDWtl34K75O4LRRghm3zaCT3syBIHbxIZqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.525&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;2. GitHub Trending 周榜&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 单点登录守卫：authelia&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：1,850+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Authelia 是一个开源的认证和授权服务器，通过 Web Portal 为应用程序提供双重认证和单点登录（SSO）。作为反向代理 (如 Nginx、Traefik 或 HAProxy) 的好搭档，Authelia 让它反向代理们知道 Query 是否应该通过，而未经身份验证的用户将被重定向到 Authelia 登录界面。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/authelia/authelia&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNoMXlqibETY6839Etw3X7CRtLkvpBntEzMQsSVJgNR6BeK41ojNqqRx2lYE4aLxNFztUL5ZGZicHTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.46131805157593125&quot; data-w=&quot;698&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 Flutter 聊天应用：Chat-Messaging-App-Light-and-Dark-Theme&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：650+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;New&lt;/code&gt; Chat-Messaging-App-Light-and-Dark-Theme 是一个用 Flutter 开发的聊天应用，支持 Dark 和 Light 模式的无缝切换。通过这个项目，你可以学到如何制作一个支持文字、语音、视频的聊天应用。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/abuanwar072/Chat-Messaging-App-Light-and-Dark-Theme&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNoMXlqibETY6839Etw3X7CR457EdMHVscecjxYp3sId3W2jchusnNSXmZPBLdJCAYfEIBicUk5mGjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5625&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 敏感信息扫描工具：apkleaks&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：650+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;apkleaks 是个 APK 文件敏感信息扫描工具，它会扫描 APK 来获取 URI、端点和 secret。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/dwisiswant0/apkleaks&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNoMXlqibETY6839Etw3X7CRS6TECPFUg4e8zdlIEHF9DN6hqLBFxr4e2vPrPnKqVKuZjw1GwnNylw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5861111111111111&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 新型 shell：nushell&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：950+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nushell 是一个新型的 shell，由 Rust 编写而成。相比传统 shell，它提供了更全面的信息，且它内置了一组命令。如果一个命令是未知的，该命令将退出 shell 并执行它 (在 Windows 上使用 cmd，或在 Linux 和 macOS 上使用 bash)，正确地传递 &lt;code&gt;stdin&lt;/code&gt;、&lt;code&gt;stdout&lt;/code&gt; 和 &lt;code&gt;stderr&lt;/code&gt;，以便 git 工作流 / vim 可以正常运行。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/nushell/nushell&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7130434782608696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNoMXlqibETY6839Etw3X7CR6WEg6bTDddrSGC27m2CrXDeUlX3WuOx1OXlzw7nw1noeoOenBYB8Sw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1610&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 深度学习资料：d2l-zh&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：1,250+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;d2l-zh 是《动手学深度学习》教程，读者可从中了解概念、背景知识和代码，而项目作者也在资料中阐述剖析问题所需的批判性思维、解决问题所需的数学知识，以及实现解决方案所需的工程技能。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/d2l-ai/d2l-zh&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xBgIbW1vdNNoMXlqibETY6839Etw3X7CROTzsvXFETmNrxGevB0zM7YpDCpch84vUWeSdAWSTQAlpkwA64qgryg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-ratio=&quot;0.7666666666666667&quot; data-w=&quot;600&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;3. 往期回顾&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，记得你在本文留言区留下你想看的主题 Repo（限公众号），例如：量化交易，AI 换头等等。👀 和之前的送书活动类似，留言点赞 Top5 的小伙伴(&lt;span&gt;棒&lt;/span&gt;），小鱼干会努力去找 Repo 的^^&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上为 2021 年第 11 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 HelloGitHub issue 区和我们分享下哟 🌝&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub001 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;&lt;/blockquote&gt;&lt;span&gt;- END -&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA5MzYyNzQ0MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOqkqThUJBICyFBlvLvTyOCgBpibwWotSxGExfnOYFfPiaL9yn3GMUOCEVYN2RNslGCdQwgZy6ticdyA/0?wx_fmt=png&quot; data-nickname=&quot;HelloGitHub&quot; data-alias=&quot;GitHub520&quot; data-signature=&quot;分享 GitHub 上有趣、入门级的开源项目。&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;👆「点击关注」&lt;/span&gt;&lt;/strong&gt;更多惊喜等待你！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cb9173e91ccb4fc2a699159b40e7dba1</guid>
<title>2021 技术展望 | 弱网下的极限实时视频通信</title>
<link>https://toutiao.io/k/rmj15hr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-id=&quot;97593&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.2173913043478262&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEciagUfdyeF7fl6ukCHoDGhVhBh7lXTUQjb9RB9yUXdaI7w6QTR2qEapYicGVn4elicdQI3yB1ricQhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;23&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;线上会议、在线教育、电商直播等多个场景的兴起，也使得实时互动技术从幕后走到台前，得到了更多人的关注。编解码、网络传输、计算机视觉等 RTE 相关的一系列技术也正焕发出更强的生命力。2021 年，在深度学习、5G 等技术的加持下，RTE 会进一步催生哪些可能？&lt;br/&gt;&lt;br/&gt;声网Agora 开发者社区联合 InfoQ 共同策划，邀请了声网Agora 开发者社区中的多位技术专家，从视频传输、计算机视觉、编解码标准发展、WebRTC、机器学习、音频技术等角度，共同撰写「2021 实时互动技术展望系列」，一窥技术新趋势。&lt;strong&gt;&lt;span&gt;本文作者，南京大学陈浩、马展、刘浩杰。本系列内容由声网 Agora 开发者社区 与 InfoQ 联合策划，并由 InfoQ 审校，&lt;strong&gt;&lt;span&gt;首发于 InfoQ&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;实时视频通信已然成为当前互联网应用的亮点。特别在这疫情期间，全球都在“被隔离”，无法开展线下活动，更加迫切的需要以实时视频通信为技术支撑的各种虚拟线上交流。在可见的数年内，稳定高质量的互联网实时视频通信是各行各业的迫切需求，协同复工复产，帮助经济恢复；当用户习惯逐渐养成，实时视频通信又将成为生产生活的基本配置。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;从应用的角度看，用户对服务的需求和网络基础设施永远是一对不可调和的矛盾。以实时视频通信为例，我们永远无法保证网络的全时稳定，弱网环境长期存在，特别在很多关乎到生活、生产乃至生命的关键时刻，通信网络往往受到极大的物理条件限制，如海事作业、应急救灾、高并发场景等。因此我们更加需要探索新理论新方法来有效的分析、精准的建模、准确的预判，以期实现弱网极限环境下（如极低带宽 &amp;lt;50kbps, 极不稳定网络抖动，极大时延等）的高质量实时视频通信。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span data-name=&quot;user&quot; data-type=&quot;color&quot;&gt;过去的 5 年，我们南京大学电子学院团队在实时视频通信下做了一系列的探索工作，搭建了以互联网云游戏/云 VR 为应用的实时视频通信平台（&lt;/span&gt;&lt;span&gt;https://www.anygame.info/&lt;/span&gt;&lt;span data-name=&quot;user&quot; data-type=&quot;color&quot;&gt;），嵌入人工智能（AI）方法驱动自适应网络带宽调节和端到端用户体验优化。目前，该平台依然每天支持数百上千名用户实时操作，也帮助我们持续优化和更新，覆盖更多的应用场景。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;近期乃至未来，我们认为实时视频通信的核心问题还未得到解决，特别是弱网下的高质量保证，而这些 corner case 往往是服务水平的直观体现。面对弱网的各种限制，我们提出极限实时视频通信：&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;第一次尝试实现全链路 AI 控制（包括编码和传输）&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;从 AlphaGo 开始，强化学习在任务决策方面展现了非凡的能力；三年前，我们提出基于强化学习的网络流控，自适应侦测调节带宽反馈给发送方优化视频压缩；这样的过程虽然带来了可见的效果，但是并没有真的解决网络流控和视频压缩流控的核心矛盾；网络流控的难点在于异构性，视频压缩的流控难点是内容多样性。近期，我们将强化学习的决策机制同时涵盖编码和传输，全链路 AI 控制（状态采集，决策预判），实现更加精准的带宽控制；&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;基于 IP 的分组交换网络在视频传输网络中占据主导地位，使得端到端网络的吞吐量、延迟等状态具有很高的时变性，并且在不同的用户之间由于网络资源竞争使得这些网络状态随时间动态波动。另一方面，由于实时视频通信要求的苛刻时延和视频内容复杂度差异，难以实现良好的码率控制。这使得难以通过对网路和内容建模生成统一、固定规则的码率自适应算法。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;受人类行为决策思想启发，我们引入强化学习理论和工具，综合考虑视频编码与网络传输端到端流程，提出了基于强化学习的全链路网络流控，其系统框图如图 1 所示。智能体首先观察以往实时视频通信会话的经验，即从视频编码器和接收端收集的编码状态、网络和播放状态，使用神经网络挖掘编码和传输过程中视频内容和网络的潜在特征，并做出编码参数设置的决策。视频应用程序的发送端基于该决策编码和传输视频，在接收端进行解码播放后，产生新的状态，同时向智能体反馈当前决策的奖励。基于此奖励信号，智能体以最大化累积奖励为目标不断更新神经网络参数。最终，我们仅通过观察和学习编码、网络和播放的原始状态，对视频编码参数进行自适应调整，有效对抗网络波动的同时，有效提升用户体验质量（Quality of Experience, QoE）。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5206270627062707&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YO07vjlZVBH5JImU3vtHm7ZwzplH6qPP3z7TwDYR1d02C5TjOdL9OLRfdc5rOc8hEfAsORcicokwdwvVOcp3TpA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1212&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-align-center=&quot;&quot; data-type=&quot;paragraph&quot;&gt;&lt;em&gt;&lt;span&gt;图 1 基于强化学习的全链路网络流控示意图&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;为评估基于强化学习的全链路网络流控的性能，我们选取当前先进的谷歌拥塞控制（Google Congestion Control，GCC）和瓶颈带宽与往返时延（Bottleneck Bandwidth and Round-trip time，BBR）算法进行了对比实验，结果如图 2 所示。可以看出，相对于 GCC 和 BBR 算法，我们可以提升分别 3.6%和 27.9%的归一化平均 QoE 分数。其中，我们以所有测试样本取得 QoE 的最小值与最大值进行归一化处理。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.631578947368421&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBH5JImU3vtHm7ZwzplH6qPPtoMJDmR8uD6pz3VUa0TJTWBJZudFdHITDy3plZ3SZ3ZsWss7Vx4fVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;456&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-align-center=&quot;&quot; data-type=&quot;paragraph&quot;&gt;&lt;em&gt;&lt;span&gt;图 2 基于强化学习的全链路网络流控性能评估&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p data-align-center=&quot;&quot; data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;引入网络多模态感知进行在线建模和推理&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;用户很难预判网络的好坏。网络的异构性让这个问题变得极为艰难。从医疗大样本数据分析推理得到启发，我们引入网络多模态感知，梳理网络的不同规则，应用在线建模逐步完善，覆盖各种网络情况。针对不同的网络情况应用对应的网络模型实现大幅性能提升；&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;对于实时视频通信场景，用于承载视频流的接入网络除了时变特性以外，还往往具备高度的异构性，如蜂窝链路（3G/4G/5G）、WiFi 无线链路、光纤链路等形态，这些接入网络具有不同的带宽、延迟和缓冲容量。此外，用户使用网络的环境也复杂多样，包括静止、步行、乘汽车、乘高铁等使用环境，使得带宽、延迟等网络特性动态改变，网络波动频繁。单一学习模型的性能往往难以覆盖如此复杂、异构的网络环境。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;为此，我们引入了网络多模态感知进行在线建模和推理，其系统框图如图 3 所示。发送端经过视频获取、视频编码和视频流化等处理后将视频流发送到网络上，接收端接收视频数据进行解码和播放等操作，并收集网络状况和视频播放情况相关数据。为减小码率决策时延，我们将网路模态感知、码率自适应和在线建模与推理模块部署在接收端。首先，通过分析和挖掘历史网络状态特征，识别当前网络模态，初步感知整体网络质量情况。之后，使用基于强化学习理论的多模态码率自适应，依据网络模态动态切换码率自适应模型，从而针对不同网络状况精细化生成不同的码率自适应决策算法。在实际新网络环境下，基于多模态码率自适应模型应用在线建模和推理，进一步面向当前环境更新和优化模型和算法，解决新环境下模型性能退化问题。一次码率决策完成后，接收到通知和指导发送端的视频编码和视频流化模块对编码码率和发送码率进行调整，以抵抗动态网络波动。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3649407361197754&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YO07vjlZVBH5JImU3vtHm7ZwzplH6qPPvKoibibzzXeicwXibk9W0I3Cl7jD7uw8e3wjtkotRaf6Lb7J3QDGniaKzaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1603&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-align-center=&quot;&quot; data-type=&quot;paragraph&quot;&gt;&lt;em&gt;&lt;span&gt;图 3 网络多模态感知进行在线建模和推理系统框图&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;鉴于图 2 中 BBR 性能差于 GCC，我们选取 GCC 算法作为评估网络多模态感知进行在线建模和推理性能的对比对象，结果如图 4 所示。对比于 GCC 算法，多模态码率自适应模型可以提升 9.1%归一化平均 QoE。其中，我们以测试样本取得 QoE 的最小值与最大值进行归一化处理。在线建模与推理方法相对于 GCC 算法，能够提升约 15.1%归一化平均 QoE，并且在训练时也达到相对稳定和可接受的码率自适应性能。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6541019955654102&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBH5JImU3vtHm7ZwzplH6qPP3qouFuXJcH0jIFMRycoVJTGzXxPH5j7VPicSr5GV7cwHjiajDhPmqhjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;451&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-align-center=&quot;&quot; data-type=&quot;paragraph&quot;&gt;&lt;em&gt;&lt;span&gt;图 4 网络多模态感知进行在线建模和推理性能评估&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;强化网络主动决策&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;在网络状态变差的时候，视频传输总会丢包；目前策略是 FEC 或者重传。无论哪一种方式都让网络更拥塞。从另外一个角度看，视频内容具备很强时空一致性（Spatiotemporal Coherency)；因此，与其进行保护，不如直接有选择的丢弃，后期利用时空一致性进行补偿。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;为此，我们引入了智能时空预测补偿模块，通过联合多帧视频时空相关一致性来在解码端直接重建丢弃的视频帧，其系统框图如图 5 所示。接收端经过视频解码得到一系列时空相关的视频解码帧，这些视频帧在编码端编码过程中已通过有选择的丢弃，来确保已存在的视频解码帧有很强的时空一致性来对丢弃帧进行恢复。智能时空预测补偿模型能根据输入的解码视频帧构造一个非线性的二阶预测模型，该模型利用了物理概念对运动进行二阶建模，结合非线性的神经网络模型更好地预测丢失视频帧。模型可基于接收到的视频解码帧，有选择地采用直接法和引导法，对不同运动特性和场景的视频进行分区域多重运动补偿，重建丢失的视频帧。此外，为了获得极高的视觉流畅度，我们在重建过程中引入了时空一致性的约束，使得重建的视频序列得到极高的视频时空流畅度，基本上在视觉感知不变的情况下，通过主动丢包可以大幅降低网络压力，保证流畅服务。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.33605600933488916&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBH5JImU3vtHm7ZwzplH6qPPFynVVpibNtgueYAQicZof1wXQQGgW6UyfvyPWbVDQibFiaBQhzabRdhTUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;857&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-align-center=&quot;&quot; data-type=&quot;paragraph&quot;&gt;&lt;em&gt;&lt;span&gt;图 5 智能时空预测补偿模块&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;通过上述三个方面的创新，我们实现了 50kbps 下的高质量视频实时通信。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;作者介绍：&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span data-name=&quot;user&quot; data-type=&quot;color&quot;&gt;马展，教授，南京大学, &lt;/span&gt;&lt;span&gt;mazhan@nju.edu.cn&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span data-name=&quot;user&quot; data-type=&quot;color&quot;&gt;刘浩杰，博士生，南京大学, &lt;/span&gt;&lt;span&gt;haojie@smail.nju.edu.cn&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span data-name=&quot;user&quot; data-type=&quot;color&quot;&gt;陈浩，副研究员，南京大学, &lt;/span&gt;&lt;span&gt;chenhao1210@nju.edu.cn&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87704&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-bcless=&quot;darken&quot; data-bclessp=&quot;20%&quot; data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span data-brushtype=&quot;text&quot;&gt;本系列相关阅读&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span hm_fix=&quot;313:362&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwNzA1OTA2OQ==&amp;amp;mid=2657215253&amp;amp;idx=1&amp;amp;sn=9ec7f2da59954dfd040e97c8264c8248&amp;amp;chksm=8c8d6207bbfaeb110ff8a12cdf4ffc3be6be22cf9bb6c622803263326094ba4e2e0057a4f581&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2021 技术展望 | 走向未来的实时生成技术&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;2021 技术展望 | 走向未来的实时生成技术&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3037037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YO07vjlZVBEHqOZjJmEPvV8JHfEDRRkq4aQIgGKpLLGE7KUcBVJVMhkRibEKbYLzKkOYzMbia7B90GEslXrkCYUg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d21b2f83732666a0db740c5d3a252b81</guid>
<title>[译] 在 .NET Core 中构建 REST API</title>
<link>https://toutiao.io/k/zplzay4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote&gt;&lt;p&gt;翻译自 Camilo Reyes 2020年8月26日的文章 《Build a REST API in .NET Core》 &lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;REST API 可以使用简单的动词（如 POST、PUT、PATCH 等）将大型解决方案背后的复杂性隐藏起来。在本文中，Camilo Reyes 解释了如何在 .NET Core 中创建 REST API。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;扩展大型复杂解决方案的一种方法是将它们分解为 REST 微服务。微服务开启了 API 背后的业务逻辑的可测试性和可重用性。因为 REST API 可以被多个客户端重用，使得组织可以共享软件模块。客户端或许是移动端、网页端，甚至单页应用中的静态资源端，它们可以调用任意多的 API。&lt;/p&gt;&lt;p&gt;在本文中，我将向您展示在 .NET Core 中构建 REST API 的全过程。我将用现实工作中的需求来解释这个过程，比如版本控制、搜索、日志记录等等。REST 通常与诸如 &lt;code&gt;POST&lt;/code&gt;、&lt;code&gt;PUT&lt;/code&gt; 或 &lt;code&gt;PATCH&lt;/code&gt; 的动词一起使用，因此我打算将它们全部覆盖。我希望您看到的是，使用现有工具交付价值的一个好的有效的方式。&lt;/p&gt;&lt;h2&gt;入门介绍&lt;/h2&gt;&lt;p&gt;本文假定您已掌握了 ASP.NET、C# 和 REST API，因此我不会涉及任何基础知识。我建议在学习本文时使用最新的 .NET Core 版本&lt;sup&gt;[2]&lt;/sup&gt;。如果您想从工作代码开始学习，可以从 GitHub 下载&lt;sup&gt;[3]&lt;/sup&gt;示例代码。&lt;/p&gt;&lt;p&gt;你可以先新建一个文件夹，比如 &lt;em&gt;BuildRestApiNetCore&lt;/em&gt;，然后在 shell 中打开它：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dotnet new sln&lt;br/&gt;dotnet new webapi --no-https&lt;br/&gt;dotnet sln add .&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该项目基于禁用了 HTTPS 的 Web API 模板，以简化本地开发。双击解决方案文件会在 Visual Studio 中打开它（如果已安装）。为了支持 .NET Core 3.1，请确保安装了 2019 版的 IDE。&lt;/p&gt;&lt;p&gt;由于 API 在客户端和数据库之间建立了一层分离，因此准备数据是一个很好的开始。为了简化数据访问，Entity Framework 提供了一个内存中的替代方案，这样我就可以只关注 API 本身。&lt;/p&gt;&lt;p&gt;通过 NuGet 获取内存数据库提供程序：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dotnet add package Microsoft.EntityFrameworkCore.InMemory&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后，创建以下数据模型。我将其放在 Models 文件夹中，以表示此命名空间存放原始数据。若要使用数据标注，请在 using 语句中添加 &lt;code&gt;System.ComponentModel.DataAnnotations&lt;/code&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Product&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    [&lt;span&gt;Key&lt;/span&gt;]&lt;br/&gt;    [&lt;span&gt;Required&lt;/span&gt;]&lt;br/&gt;    [&lt;span&gt;Display(Name = &quot;productNumber&quot;)&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ProductNumber { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;    [&lt;span&gt;Required&lt;/span&gt;]&lt;br/&gt;    [&lt;span&gt;Display(Name = &quot;name&quot;)&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;    [&lt;span&gt;Required&lt;/span&gt;]&lt;br/&gt;    [&lt;span&gt;Range(10, 90)&lt;/span&gt;]&lt;br/&gt;    [&lt;span&gt;Display(Name = &quot;price&quot;)&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;? Price { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;    [&lt;span&gt;Required&lt;/span&gt;]&lt;br/&gt;    [&lt;span&gt;Display(Name = &quot;department&quot;)&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Department { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在实际的解决方案中，这可能要根据团队的需要将其放在单独的项目中。请注意分配给该模型的属性，例如 &lt;code&gt;Required&lt;/code&gt;、&lt;code&gt;Display&lt;/code&gt; 和 &lt;code&gt;Range&lt;/code&gt;，这些是 ASP.NET 中的数据标注，用于在模型绑定时验证 &lt;code&gt;Product&lt;/code&gt;。因为我使用的是内存数据库，所以 Entity Framework 需要一个唯一的 &lt;em&gt;Key&lt;/em&gt;。这些属性指定了验证规则，例如：价格区间或者该属性是否是必须的。&lt;/p&gt;&lt;p&gt;从业务的视角来看，这是一个包含产品编号、名称和价格的电子商务站点。每个产品还指定了一个部门，以便按部门进行搜索。&lt;/p&gt;&lt;p&gt;接下来，在 Models 命名空间中设置 Entity Framework &lt;code&gt;DbContext&lt;/code&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;ProductContext&lt;/span&gt; : &lt;span&gt;DbContext&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;ProductContext&lt;/span&gt;(DbContextOptions&amp;lt;ProductContext&amp;gt; options) : &lt;span&gt;base&lt;/span&gt;(options)&lt;br/&gt;    {&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Product&amp;gt; Products { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该数据库上下文被依赖注入到控制器中，用于查询或更新数据。要在 ASP.NET Core 中启用依赖注入，请打开 &lt;code&gt;Startup&lt;/code&gt; 类并将其添加到 &lt;code&gt;ConfigureServices&lt;/code&gt; 中：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;services.AddDbContext&amp;lt;ProductContext&amp;gt;(opt =&amp;gt; opt.UseInMemoryDatabase(&lt;span&gt;&quot;Products&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这行代码完成了内存数据库。请确保在两个类的 using 语句中添加 &lt;code&gt;Microsoft.EntityFrameworkCore&lt;/code&gt;。一个空白的后端是无趣的，因此我们来填充一些种子数据。&lt;/p&gt;&lt;p&gt;创建下面的扩展方法以帮助迭代生成种子数据，可以将它放在 &lt;em&gt;Extensions&lt;/em&gt; 命名空间或文件夹中：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;EnumerableExtensions&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;IEnumerable&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;span&gt;Times&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;(&lt;span&gt;this&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count, Func&amp;lt;&lt;span&gt;int&lt;/span&gt;, T&amp;gt; func)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 1; i &amp;lt;= count; i++) &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; func.Invoke(i);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 &lt;em&gt;Models&lt;/em&gt; 命名空间下添加一个静态类以初始化种子数据：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;ProductSeed&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;InitData&lt;/span&gt;(ProductContext context)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; rnd = &lt;span&gt;new&lt;/span&gt; Random();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; adjectives = &lt;span&gt;new&lt;/span&gt;[] { &lt;span&gt;&quot;Small&quot;&lt;/span&gt;, &lt;span&gt;&quot;Ergonomic&quot;&lt;/span&gt;, &lt;span&gt;&quot;Rustic&quot;&lt;/span&gt;, &lt;span&gt;&quot;Smart&quot;&lt;/span&gt;, &lt;span&gt;&quot;Sleek&quot;&lt;/span&gt; };&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; materials = &lt;span&gt;new&lt;/span&gt;[] { &lt;span&gt;&quot;Steel&quot;&lt;/span&gt;, &lt;span&gt;&quot;Wooden&quot;&lt;/span&gt;, &lt;span&gt;&quot;Concrete&quot;&lt;/span&gt;, &lt;span&gt;&quot;Plastic&quot;&lt;/span&gt;, &lt;span&gt;&quot;Granite&quot;&lt;/span&gt;, &lt;span&gt;&quot;Rubber&quot;&lt;/span&gt; };&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; names = &lt;span&gt;new&lt;/span&gt;[] { &lt;span&gt;&quot;Chair&quot;&lt;/span&gt;, &lt;span&gt;&quot;Car&quot;&lt;/span&gt;, &lt;span&gt;&quot;Computer&quot;&lt;/span&gt;, &lt;span&gt;&quot;Pants&quot;&lt;/span&gt;, &lt;span&gt;&quot;Shoes&quot;&lt;/span&gt; };&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; departments = &lt;span&gt;new&lt;/span&gt;[] { &lt;span&gt;&quot;Books&quot;&lt;/span&gt;, &lt;span&gt;&quot;Movies&quot;&lt;/span&gt;, &lt;span&gt;&quot;Music&quot;&lt;/span&gt;, &lt;span&gt;&quot;Games&quot;&lt;/span&gt;, &lt;span&gt;&quot;Electronics&quot;&lt;/span&gt; };&lt;br/&gt;&lt;br/&gt;        context.Products.AddRange(900.Times(x =&amp;gt;&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;var&lt;/span&gt; adjective = adjectives[rnd.Next(0, 5)];&lt;br/&gt;            &lt;span&gt;var&lt;/span&gt; material = materials[rnd.Next(0, 5)];&lt;br/&gt;            &lt;span&gt;var&lt;/span&gt; name = names[rnd.Next(0, 5)];&lt;br/&gt;            &lt;span&gt;var&lt;/span&gt; department = departments[rnd.Next(0, 5)];&lt;br/&gt;            &lt;span&gt;var&lt;/span&gt; productId = &lt;span&gt;$&quot;{x,-3:000}&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Product&lt;br/&gt;            {&lt;br/&gt;                ProductNumber = &lt;span&gt;$&quot;{department.First()}{name.First()}{productId}&quot;&lt;/span&gt;,&lt;br/&gt;                Name = &lt;span&gt;$&quot;{adjective} {material} {name}&quot;&lt;/span&gt;,&lt;br/&gt;                Price = (&lt;span&gt;double&lt;/span&gt;)rnd.Next(1000, 9000) / 100,&lt;br/&gt;                Department = department&lt;br/&gt;            };&lt;br/&gt;        }));&lt;br/&gt;&lt;br/&gt;        context.SaveChanges();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码循环遍历一个 900 条数据的列表以生成大量的产品，这些产品的部门、价格和名称都是随机捡选的。每个产品都有一个“巧妙”的 key 作为主键，该主键由部门、名称和产品 Id 组合而成。&lt;/p&gt;&lt;p&gt;有了这些种子数据，您就可以得到诸如在 Electronics 部门带有标价的名为 “Smart Wooden Pants” 的产品了。&lt;/p&gt;&lt;p&gt;作为开始构建 Endpoints&lt;sup&gt;[4]&lt;/sup&gt;的第一步，设置 API 版本是一个好主意。这使得客户端应用可以随时升级 API 功能，而无需紧密耦合。&lt;/p&gt;&lt;p&gt;API 版本控制来自一个 NuGet 包：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dotnet add package Microsoft.AspNetCore.Mvc.Versioning&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;回到 &lt;code&gt;Startup&lt;/code&gt; 类，并将其添加到 &lt;code&gt;ConfigureServices&lt;/code&gt; 中：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;services.AddApiVersioning(opt =&amp;gt; opt.ReportApiVersions = &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我选择在 API 响应中包含可用的版本号，以便客户端知道何时有升级可用。我推荐使用 语义化的版本控制 &lt;sup&gt;[5]&lt;/sup&gt;来传达 API 中的重大更改。让客户端知道每次升级都修改了什么，这样有助于每个客户端保持最新的功能。&lt;/p&gt;&lt;h2&gt;REST API 中的搜索 Endpoint&lt;/h2&gt;&lt;p&gt;要构建一个 Endpoint，请在 &lt;em&gt;Controllers&lt;/em&gt; 文件夹中转到 ASP.NET 中的 Controller。&lt;/p&gt;&lt;p&gt;使用下面的代码创建一个 &lt;code&gt;ProductsController&lt;/code&gt;，请确保在 using 语句中添加 &lt;code&gt;Microsoft.AspNetCore.Mvc&lt;/code&gt; 命名空间：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[&lt;span&gt;ApiController&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;ApiVersion(&quot;1.0&quot;)&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;Route(&quot;v{version:apiVersion}/[controller]&quot;)&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;Produces(&quot;application/json&quot;)&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;ProductsController&lt;/span&gt; : &lt;span&gt;ControllerBase&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; ProductContext _context;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;ProductsController&lt;/span&gt;(ProductContext context)&lt;br/&gt;    {&lt;br/&gt;        _context = context;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (_context.Products.Any()) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        ProductSeed.InitData(context);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;请注意，当数据库中没有任何产品时，将运行 &lt;code&gt;InitData&lt;/code&gt; 初始化种子数据。我设置了一个带有版本控制的 &lt;code&gt;Route&lt;/code&gt;，版本号通过 &lt;code&gt;ApiVersion&lt;/code&gt; 设置。通过依赖注入将数据上下文 &lt;code&gt;ProductContext&lt;/code&gt; 注入到构造函数中。在该 Controller 中，第一个 Endpoint 是返回一个产品列表的 &lt;em&gt;GET&lt;/em&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[&lt;span&gt;HttpGet&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;Route(&quot;&quot;)&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;ProducesResponseType(StatusCodes.Status200OK)&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;IQueryable&amp;lt;Product&amp;gt;&amp;gt; GetProducts()&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; result = _context.Products &lt;span&gt;as&lt;/span&gt; IQueryable&amp;lt;Product&amp;gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Ok(result.OrderBy(p =&amp;gt; p.ProductNumber));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;请确保在 using 语句中添加 &lt;code&gt;Microsoft.AspNetCore.Http&lt;/code&gt;，以设置响应类型中的状态码。&lt;/p&gt;&lt;p&gt;我选择按照产品编号排序产品，以便更简单地显示结果。在生产系统中，可以检查这种排序是否与聚集索引相匹配，以便减轻数据库的运行压力。经常检查执行计划和统计 IO，以确认有良好的性能。&lt;/p&gt;&lt;p&gt;此项目已经可以进行测试了！在命令行中运行以下命令：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dotnet watch run&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 curl 测试该 Endpoint：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;curl -i -X GET &lt;span&gt;&quot;http://localhost:5000/v1/products&quot;&lt;/span&gt; -H &lt;span&gt;&quot;accept: application/json&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我在两个独立的控制台窗口中运行上面这两条命令。一个以监视模式运行项目，当我更改代码文件时，会自动重新生成并刷新；另一个是我保持 curl 结果的地方。您可以使用 Postman，但是伴随 Windows 10 而来的 curl 也可以完成该工作。&lt;/p&gt;&lt;p&gt;结果如下：&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;430&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7445109780439122&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pAdPOatCTkPibticVogIc2mRYsrdDF77O2esoxRm931osmaiblFELZNWvFhy9JzWG3YGUS0NkiaXvX3WW5Cy63tL6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1002&quot;/&gt;&lt;/p&gt;&lt;p&gt;该请求返回数据库中的所有产品，但它不可扩展。随着产品列表的增加，客户端将受到未过滤数据的猛烈冲击，从而给 SQL 和网络流量带来更大的压力。&lt;/p&gt;&lt;p&gt;更好的方法是在一个模型中引入 &lt;code&gt;limit&lt;/code&gt; 和 &lt;code&gt;offset&lt;/code&gt; 请求参数：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;ProductRequest&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    [&lt;span&gt;FromQuery(Name = &quot;limit&quot;)&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Limit { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = 15;&lt;br/&gt;&lt;br/&gt;    [&lt;span&gt;FromQuery(Name = &quot;offset&quot;)&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Offset { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将此请求参数关联到 &lt;strong&gt;GetProducts&lt;/strong&gt; Endpoint：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;IQueryable&amp;lt;Product&amp;gt;&amp;gt; GetProducts([FromQuery] ProductRequest request)&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; result = _context.Products &lt;span&gt;as&lt;/span&gt; IQueryable&amp;lt;Product&amp;gt;;&lt;br/&gt;&lt;br/&gt;    Response.Headers[&lt;span&gt;&quot;x-total-count&quot;&lt;/span&gt;] = result.Count().ToString();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Ok(result&lt;br/&gt;        .OrderBy(p =&amp;gt; p.ProductNumber)&lt;br/&gt;        .Skip(request.Offset)&lt;br/&gt;        .Take(request.Limit));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;请注意我设置了一个值为 &lt;code&gt;Count&lt;/code&gt; 的 HTTP header &lt;code&gt;x-total-count&lt;/code&gt;，用于帮助想要分页浏览整个结果集的客户端。如果未指定请求参数，则该 API 默认返回前 15 条数据。&lt;/p&gt;&lt;p&gt;接下来，添加一个搜索参数，按部门筛选产品：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;IQueryable&amp;lt;Product&amp;gt;&amp;gt; GetProducts([FromQuery] &lt;br/&gt;             &lt;span&gt;string&lt;/span&gt; department, [FromQuery] ProductRequest request)&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(department))&lt;br/&gt;    {&lt;br/&gt;        result = result.Where(p =&amp;gt; p.Department.StartsWith(department, &lt;br/&gt;                        StringComparison.InvariantCultureIgnoreCase));&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// ..&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以通过修改 Query，让搜索进入条件块内。请注意我用了 &lt;code&gt;StartsWith&lt;/code&gt; 和 &lt;code&gt;InvariantCultureIgnoreCase&lt;/code&gt; 来简化产品过滤，在实际的 SQL 中，可以使用 &lt;code&gt;LIKE&lt;/code&gt; 运算符，还可以通过排序规则设置不区分大小写。&lt;/p&gt;&lt;p&gt;要测试分页和此新过滤器，请使用 curl 执行以下命令：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;curl -i -X GET &lt;span&gt;&quot;http://localhost:5000/v1/products?offset=15&amp;amp;department=electronics&quot;&lt;/span&gt; -H &lt;span&gt;&quot;accept: application/json&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;检查确定包含总数和受支持版本号的 HTTP 头：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK&lt;br/&gt;Date: Thu, 28 Jan 2021 11:19:09 GMT&lt;br/&gt;Content-Type: application/json; charset=utf-8&lt;br/&gt;Server: Kestrel&lt;br/&gt;Transfer-Encoding: chunked&lt;br/&gt;x-total-count: 155&lt;br/&gt;api-supported-versions: 1.0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;日志记录和 API 文档&lt;/h2&gt;&lt;p&gt;当 API 成形后，如何向其他开发人员传达 Endpoints 呢？对于团队来说，在不破坏开放代码的情况下了解 API 公开的内容是有好处的。Swagger 是这里的首选工具，它能通过反射，自动生成可用的文档。&lt;/p&gt;&lt;p&gt;如果我告诉您，Swagger 所需的一切都已经在此 API 中设置过了呢？来吧，再看一眼：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[&lt;span&gt;Produces(&quot;application/json&quot;)&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;ProducesResponseType(StatusCodes.Status200OK)&lt;/span&gt;]&lt;br/&gt;ActionResult&amp;lt;IQueryable&amp;lt;Product&amp;gt;&amp;gt; GetProducts([FromQuery] &lt;br/&gt;               &lt;span&gt;string&lt;/span&gt; department, [FromQuery] ProductRequest request)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ASP.NET 属性对于 Endpoints 的自文档化非常有用。Swagger 通过反射，从控制器方法中获得返回类型，进而推断响应该是什么样子，并获得每个控制器方法的请求参数。因为它收集了工作代码中的所有内容，所以可以生成“活文档”，从而减少了故障的发生。&lt;/p&gt;&lt;p&gt;通过 NuGet 获取缺少的依赖项：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dotnet add package Swashbuckle.AspNetCore&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并在 &lt;code&gt;ConfigureServices&lt;/code&gt; 中将其关联进来：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;services.AddSwaggerGen(c =&amp;gt; c.SwaggerDoc(&lt;span&gt;&quot;v1&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; OpenApiInfo&lt;br/&gt;{&lt;br/&gt;    Title = &lt;span&gt;&quot;Products&quot;&lt;/span&gt;,&lt;br/&gt;    Description = &lt;span&gt;&quot;The ultimate e-commerce store for all your needs&quot;&lt;/span&gt;,&lt;br/&gt;    Version = &lt;span&gt;&quot;v1&quot;&lt;/span&gt;&lt;br/&gt;}));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后，在 &lt;code&gt;Configure&lt;/code&gt; 中启用它：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;app.UseSwagger();&lt;br/&gt;app.UseSwaggerUI(opt =&amp;gt; opt.SwaggerEndpoint(&lt;span&gt;&quot;/swagger/v1/swagger.json&quot;&lt;/span&gt;, &lt;span&gt;&quot;Products v1&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意 &lt;code&gt;OpenApiInfo&lt;/code&gt; 来自 &lt;code&gt;Microsoft.OpenApi.Models&lt;/code&gt; 命名空间。&lt;/p&gt;&lt;p&gt;此时，在浏览器中导航到 &lt;em&gt;http://localhost:5000/swagger&lt;/em&gt; 就可以查看 swagger 文档了。&lt;/p&gt;&lt;p&gt;页面大概如下显示：&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;351&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6067354698533406&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pAdPOatCTkPibticVogIc2mRYsrdDF77O25F0jCN4Da9JEZHQENxl4Csl5Y2gWrtk4od93l8icTHdtlCRcy8Ko7ew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1841&quot;/&gt;&lt;/p&gt;&lt;p&gt;在 swagger 文档中，您可以轻松浏览 API 并通过这个工具向 API 发起请求，您所在组织的其他开发人员会因此受益而轻松愉快，他们甚至可能会请您喝杯咖啡。&lt;/p&gt;&lt;p&gt;展开 GET &lt;code&gt;/Products&lt;/code&gt; 查看从控制器方法中提取的 C# 数据类型：&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;414&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7154929577464789&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pAdPOatCTkPibticVogIc2mRYsrdDF77O2X2h0kdWhZxSZtjEoCGiav9vr0rn0B7fsja69FwTBIdEIn7waFgFD1Aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1420&quot;/&gt;&lt;/p&gt;&lt;p&gt;下一站是日志记录。我将使用 &lt;code&gt;NLog&lt;/code&gt; 在后端存储日志，使得 API 能够保存日志以供进一步分析。在实际环境中，日志对于故障排除非常有用；另外，它们还可以帮助收集遥测数据，以帮助了解 API 在未知状态下的使用情况。&lt;/p&gt;&lt;p&gt;要设置日志记录器，需要完成做以下操作：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;一个 NuGet 包&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一个 &lt;em&gt;nlog.config&lt;/em&gt; 设置文件&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;修改 &lt;code&gt;Program&lt;/code&gt; 类&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;微调 &lt;em&gt;appsettings.json&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;安装 NuGet 包：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dotnet add package NLog.Web.AspNetCore&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;设置的 &lt;em&gt;nlog.config&lt;/em&gt; 文件可以如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;nlog &lt;span&gt;xmlns&lt;/span&gt;=&lt;span&gt;&quot;http://www.nlog-project.org/schemas/NLog.xsd&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;xmlns:xsi&lt;/span&gt;=&lt;span&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;throwExceptions&lt;/span&gt;=&lt;span&gt;&quot;false&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;throwConfigExceptions&lt;/span&gt;=&lt;span&gt;&quot;false&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;autoReload&lt;/span&gt;=&lt;span&gt;&quot;true&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;internalLogLevel&lt;/span&gt;=&lt;span&gt;&quot;Warn&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;internalLogFile&lt;/span&gt;=&lt;br/&gt;           &lt;span&gt;&quot;C:\temp\BuildRestApiNetCore\RestApi-internal-nlog.txt&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;br/&gt;  &lt;span&gt;&amp;lt;extensions&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;add &lt;span&gt;assembly&lt;/span&gt;=&lt;span&gt;&quot;NLog.Web.AspNetCore&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/extensions&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;br/&gt;  &lt;span&gt;&amp;lt;targets &lt;span&gt;async&lt;/span&gt;=&lt;span&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;target &lt;span&gt;xsi:type&lt;/span&gt;=&lt;span&gt;&quot;File&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;ownFile-web&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;fileName&lt;/span&gt;=&lt;br/&gt;              &lt;span&gt;&quot;C:\temp\BuildRestApiNetCore\RestApi-${shortdate}.log&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;br/&gt;      &lt;span&gt;&amp;lt;layout &lt;span&gt;xsi:type&lt;/span&gt;=&lt;span&gt;&quot;JsonLayout&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;attribute &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Timestamp&quot;&lt;/span&gt; &lt;span&gt;layout&lt;/span&gt;=&lt;span&gt;&quot;${longdate}&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;attribute &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Level&quot;&lt;/span&gt; &lt;span&gt;layout&lt;/span&gt;=&lt;span&gt;&quot;${uppercase:${level}}&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;attribute &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Logger&quot;&lt;/span&gt; &lt;span&gt;layout&lt;/span&gt;=&lt;span&gt;&quot;${logger}&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;attribute &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Action&quot;&lt;/span&gt; &lt;span&gt;layout&lt;/span&gt;=&lt;span&gt;&quot;${aspnet-mvc-action}&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;attribute &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Message&quot;&lt;/span&gt; &lt;span&gt;layout&lt;/span&gt;=&lt;span&gt;&quot;${message}&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;attribute &lt;br/&gt;           &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Exception&quot;&lt;/span&gt; &lt;span&gt;layout&lt;/span&gt;=&lt;span&gt;&quot;${exception:format=tostring}&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;/layout&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/target&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/targets&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;br/&gt;  &lt;span&gt;&amp;lt;rules&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;logger &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Microsoft.*&quot;&lt;/span&gt; &lt;span&gt;maxlevel&lt;/span&gt;=&lt;span&gt;&quot;Info&quot;&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;=&lt;span&gt;&quot;true&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt; &lt;br/&gt;                &lt;br/&gt;    &lt;span&gt;&amp;lt;logger &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;*&quot;&lt;/span&gt; &lt;span&gt;minlevel&lt;/span&gt;=&lt;span&gt;&quot;Info&quot;&lt;/span&gt; &lt;span&gt;writeTo&lt;/span&gt;=&lt;span&gt;&quot;ownFile-web&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/rules&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/nlog&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;请注意 &lt;code&gt;Layout&lt;/code&gt;，因为它设置了日志文件的类型，这里将其设置为 &lt;code&gt;JsonLayout&lt;/code&gt;。当在不同的分析工具中使用日志文件时，JSON 格式具有最大的灵活性。为了让冗余降到最小，记录器规则不记录来自 &lt;em&gt;Microsoft.&lt;/em&gt;* 的错误。另外，因为将 &lt;code&gt;throwExceptions&lt;/code&gt; 设置为了 false，API 中未处理的异常会被记录，但不会被重新抛出。这里的用法可能是多变的，但通常最好是在 logger 中处理所有未处理的异常。&lt;/p&gt;&lt;p&gt;在 &lt;code&gt;Program&lt;/code&gt; 类中，启用 &lt;code&gt;NLog&lt;/code&gt;，记得添加 &lt;code&gt;using NLog.Web&lt;/code&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Host.CreateDefaultBuilder(args)&lt;br/&gt;  .ConfigureWebHostDefaults(webBuilder =&amp;gt;&lt;br/&gt;  {&lt;br/&gt;    webBuilder.UseStartup&amp;lt;Startup&amp;gt;();&lt;br/&gt;  })&lt;br/&gt;  .UseNLog();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后，在 &lt;em&gt;appsettings.json&lt;/em&gt; 中进行以下微调来配置日志记录：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&quot;Logging&quot;&lt;/span&gt;: {&lt;br/&gt;  &lt;span&gt;&quot;LogLevel&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;Default&quot;&lt;/span&gt;: &lt;span&gt;&quot;Information&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;Microsoft&quot;&lt;/span&gt;: &lt;span&gt;&quot;None&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;Microsoft.AspNetCore&quot;&lt;/span&gt;: &lt;span&gt;&quot;Error&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;Microsoft.Hosting.Lifetime&quot;&lt;/span&gt;: &lt;span&gt;&quot;Information&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的基本思想是减少与此 API 无关的日志条目的数量。您可以随意调整这些设置，以便恰当地记录 API 所需要的日志内容。&lt;/p&gt;&lt;p&gt;是时候言归正传了，在 &lt;code&gt;Controller&lt;/code&gt; 类中，添加 &lt;code&gt;using Microsoft.Extensions.Logging&lt;/code&gt; 并注入一个普通的旧式 ASP.NET logger：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; ILogger&amp;lt;ProductsController&amp;gt; _logger;&lt;br/&gt; &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ProductsController&lt;/span&gt;(ProductContext context, &lt;br/&gt;            ILogger&amp;lt;ProductsController&amp;gt; logger)&lt;br/&gt;{&lt;br/&gt;  _logger = logger;&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假设，现在您的团队决定要抓取客户端请求获取 100 条或更多条记录的频率相关的遥测数据。&lt;/p&gt;&lt;p&gt;将下面的代码放入 &lt;code&gt;GetProducts&lt;/code&gt; 中：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (request.Limit &amp;gt;= 100)&lt;br/&gt;  _logger.LogInformation(&lt;span&gt;&quot;Requesting more than 100 products.&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;请确保有一个已存在的临时文件夹来核查日志，例如：&lt;code&gt;C:\temp\BuildRestApiNetCore\&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;一条日志记录看起来可能是这样的：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;Timestamp&quot;&lt;/span&gt;: &lt;span&gt;&quot;2020-07-12 10:30:30.8960&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;Level&quot;&lt;/span&gt;: &lt;span&gt;&quot;INFO&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;Logger&quot;&lt;/span&gt;: &lt;span&gt;&quot;BuildRestApiNetCore.Controllers.ProductsController&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;Action&quot;&lt;/span&gt;: &lt;span&gt;&quot;GetProducts&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;Message&quot;&lt;/span&gt;: &lt;span&gt;&quot;Requesting more than 100 products.&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;带动词的 REST Endpoints&lt;/h2&gt;&lt;p&gt;深吸一口气，然后畅快地呼出。该 API 差不多可以投入生产环境了，而且只用了很少的代码。现在，我将快速转向 &lt;code&gt;POST&lt;/code&gt;、&lt;code&gt;PUT&lt;/code&gt;、&lt;code&gt;PATCH&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 等 REST 特性的介绍。&lt;/p&gt;&lt;p&gt;&lt;code&gt;POST&lt;/code&gt; Endpoint 接收带有新产品的 body，并将其添加到列表当中。此方法是非幂等的，因为它在调用时会创建新的资源。&lt;/p&gt;&lt;p&gt;将下面的代码放入 &lt;code&gt;ProductsController&lt;/code&gt; 中：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[&lt;span&gt;HttpPost&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;ProducesResponseType(StatusCodes.Status201Created)&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;ProducesResponseType(StatusCodes.Status400BadRequest)&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;Product&amp;gt; &lt;span&gt;PostProduct&lt;/span&gt;([FromBody] Product product)&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;    _context.Products.Add(product);&lt;br/&gt;    _context.SaveChanges();&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; CreatedResult(&lt;span&gt;$&quot;/products/{product.ProductNumber.ToLower()}&quot;&lt;/span&gt;, product);&lt;br/&gt;  }&lt;br/&gt;  catch (Exception e)&lt;br/&gt;  {&lt;br/&gt;    _logger.LogWarning(e, &lt;span&gt;&quot;Unable to POST product.&quot;&lt;/span&gt;);&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; ValidationProblem(e.Message);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ASP.NET 通过 &lt;code&gt;ValidationProblem&lt;/code&gt; 自动处理异常。该验证将返回一条符合 RFC 7807 规范&lt;sup&gt;[6]&lt;/sup&gt;的响应，并带有一条消息。在实际的系统中，我建议确保不要暴露任何关于 API 的内部信息。将异常信息放在此处有助于客户端对代码进行故障排除，但安全性也很重要。我在这里选择包含错误信息主要是为了演示目的。此处还会将异常记录为警告，以避免记录大量的错误。当异常太多时，监控工具可能会呼叫值班人员。最佳实践是仅在可能需要人工干预的灾难性故障期间记录错误。&lt;/p&gt;&lt;p&gt;使用 swagger 工具，curl 命令为：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;curl -i -X POST http://localhost:5000/v1/products&lt;br/&gt;  -H &lt;span&gt;&quot;accept: application/json&quot;&lt;/span&gt;&lt;br/&gt;  -H &lt;span&gt;&quot;Content-Type: application/json&quot;&lt;/span&gt;&lt;br/&gt;  -d &lt;span&gt;&quot;{\&quot;productNumber\&quot;:\&quot;string\&quot;,\&quot;name\&quot;:\&quot;string\&quot;,\&quot;price\&quot;:10,\&quot;department\&quot;:\&quot;string\&quot;}&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当请求有问题时，API 会如下响应：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;errors&quot;&lt;/span&gt;: {},&lt;br/&gt;  &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;https://tools.ietf.org/html/rfc7231#section-6.5.1&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;title&quot;&lt;/span&gt;:&lt;span&gt;&quot;One or more validation errors occurred.&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;status&quot;&lt;/span&gt;: 400,&lt;br/&gt;  &lt;span&gt;&quot;detail&quot;&lt;/span&gt;: &lt;span&gt;&quot;An item with the same key has already been added. Key: string&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;traceId&quot;&lt;/span&gt;:&lt;span&gt;&quot;|c445a403-43564e0626f9af50.&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;400 (Bad Request)&lt;/em&gt; 响应表示请求中的用户错误。因为无法信任用户发送有效数据，所以 API 会记录一个警告。&lt;/p&gt;&lt;p&gt;请注意，如果成功，&lt;code&gt;POST&lt;/code&gt; 将返回带有 &lt;em&gt;Location&lt;/em&gt; 的 201：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;HTTP/1.1 201 Created&lt;br/&gt;Date: Mon, 13 Jul 2020 22:52:46 GMT&lt;br/&gt;Content-Type: application/json; charset=utf-8&lt;br/&gt;Server: Kestrel&lt;br/&gt;Content-Length: 76&lt;br/&gt;Location: /products/bc916&lt;br/&gt;api-supported-versions: 1.0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这将引导客户端转向新资源。此处，转向 &lt;code&gt;GET&lt;/code&gt; Endpoint 是个好主意：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[&lt;span&gt;HttpGet&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;Route(&quot;{productNumber}&quot;)&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;ProducesResponseType(StatusCodes.Status200OK)&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;ProducesResponseType(StatusCodes.Status404NotFound)&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;Product&amp;gt; &lt;span&gt;GetProductByProductNumber&lt;/span&gt;([FromRoute] &lt;br/&gt;            &lt;span&gt;string&lt;/span&gt; productNumber)&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; productDb = _context.Products&lt;br/&gt;    .FirstOrDefault(p =&amp;gt; p.ProductNumber.Equals(productNumber, &lt;br/&gt;              StringComparison.InvariantCultureIgnoreCase));&lt;br/&gt; &lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (productDb == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; NotFound();&lt;br/&gt; &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; Ok(productDb);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;404 响应表示该资源在 API 中尚不存在，但可能会在将来的某个时候变得可用。&lt;/p&gt;&lt;p&gt;&lt;code&gt;PUT&lt;/code&gt; 是类似的：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[&lt;span&gt;HttpPut&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;ProducesResponseType(StatusCodes.Status200OK)&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;ProducesResponseType(StatusCodes.Status404NotFound)&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;ProducesResponseType(StatusCodes.Status400BadRequest)&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;Product&amp;gt; &lt;span&gt;PutProduct&lt;/span&gt;([FromBody] Product product)&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; productDb = _context.Products&lt;br/&gt;      .FirstOrDefault(p =&amp;gt; p.ProductNumber.Equals(product.ProductNumber, &lt;br/&gt;           StringComparison.InvariantCultureIgnoreCase));&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (productDb == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; NotFound();&lt;br/&gt; &lt;br/&gt;    productDb.Name = product.Name;&lt;br/&gt;    productDb.Price = product.Price;&lt;br/&gt;    productDb.Department = product.Department;&lt;br/&gt;    _context.SaveChanges();&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Ok(product);&lt;br/&gt;  }&lt;br/&gt;  catch (Exception e)&lt;br/&gt;  {&lt;br/&gt;    _logger.LogWarning(e, &lt;span&gt;&quot;Unable to PUT product.&quot;&lt;/span&gt;);&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; ValidationProblem(e.Message);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 REST 设计中，&lt;code&gt;PUT&lt;/code&gt; 允许对整个资源进行更新。它是幂等的，因为多次相同的请求不会改变资源的数量。&lt;/p&gt;&lt;p&gt;就像 &lt;em&gt;GET 404&lt;/em&gt; 响应一样，表示该资源不可用于更新，但这可能在稍后发生改变。另外，ASP.NET 提供现成的模型绑定验证。接下来，尝试一下使用错误的数据更新现有资源。&lt;/p&gt;&lt;p&gt;下面的 JSON 是您可能看到的 &lt;em&gt;Bad Request&lt;/em&gt; 的响应：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;errors&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;Price&quot;&lt;/span&gt;: [&lt;span&gt;&quot;The price field is required.&quot;&lt;/span&gt;]&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;https://tools.ietf.org/html/rfc7231#section-6.5.1&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;title&quot;&lt;/span&gt;: &lt;span&gt;&quot;One or more validation errors occurred.&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;status&quot;&lt;/span&gt;: 400,&lt;br/&gt;  &lt;span&gt;&quot;traceId&quot;&lt;/span&gt;: &lt;span&gt;&quot;|c445a409-43564e0626f9af50.&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;PATCH&lt;/code&gt; 是所有动词中最复杂的，因为它通过 JSON Patch 文档&lt;sup&gt;[7]&lt;/sup&gt;仅更新资源的一部分。&lt;/p&gt;&lt;p&gt;庆幸的是 .NET Core 提供了一个 NuGet 包：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dotnet add package Microsoft.AspNetCore.Mvc.NewtonsoftJson&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后，在 &lt;code&gt;ConfigureServices&lt;/code&gt; 中启用它：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;services.AddControllers().AddNewtonsoftJson();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面是 &lt;code&gt;PATCH&lt;/code&gt; Endpoint，记得添加 &lt;code&gt;using Microsoft.AspNetCore.JsonPatch&lt;/code&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[&lt;span&gt;HttpPatch&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;Route(&quot;{productNumber}&quot;)&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;ProducesResponseType(StatusCodes.Status200OK)&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;ProducesResponseType(StatusCodes.Status404NotFound)&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;ProducesResponseType(StatusCodes.Status400BadRequest)&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;Product&amp;gt; &lt;span&gt;PatchProduct&lt;/span&gt;([FromRoute] &lt;br/&gt;      &lt;span&gt;string&lt;/span&gt; productNumber, [FromBody] JsonPatchDocument&amp;lt;Product&amp;gt; patch)&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; productDb = _context.Products&lt;br/&gt;      .FirstOrDefault(p =&amp;gt; p.ProductNumber.Equals(productNumber, &lt;br/&gt;           StringComparison.InvariantCultureIgnoreCase));&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (productDb == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; NotFound();&lt;br/&gt; &lt;br/&gt;    patch.ApplyTo(productDb, ModelState);&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!ModelState.IsValid || !TryValidateModel(productDb)) &lt;br/&gt;             &lt;span&gt;return&lt;/span&gt; ValidationProblem(ModelState);&lt;br/&gt; &lt;br/&gt;    _context.SaveChanges();&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Ok(productDb);&lt;br/&gt;  }&lt;br/&gt;  catch (Exception e)&lt;br/&gt;  {&lt;br/&gt;    _logger.LogWarning(e, &lt;span&gt;&quot;Unable to PATCH product.&quot;&lt;/span&gt;);&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; ValidationProblem(e.Message);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我希望您看到一种含有不同状态码响应类型的模式开始浮现。&lt;em&gt;200 OK&lt;/em&gt; 表示成功，&lt;em&gt;400 Bad Request&lt;/em&gt; 表示用户错误。当 patch 被应用后，将会在 &lt;code&gt;ModelState&lt;/code&gt; 中追加所有的验证错误。仔细看一下进行模型绑定的 &lt;code&gt;JsonPatchDocument&lt;/code&gt; 和 应用更改的 &lt;code&gt;ApplyTo&lt;/code&gt;。这就是将 JSON Patch 文档应用到数据库中现有产品的方式。像所有其它 Endpoints 一样，异常会被记录并包含在响应中。与其它动词一样，&lt;em&gt;404 (Not Found)&lt;/em&gt; 响应表示相同的情形。响应状态码的一致性有助于客户端处理所有可能的场景。&lt;/p&gt;&lt;p&gt;一个 JSON patch 请求的 body 大概如下所示：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[{&lt;br/&gt;  &lt;span&gt;&quot;op&quot;&lt;/span&gt;: &lt;span&gt;&quot;replace&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;path&quot;&lt;/span&gt;: &lt;span&gt;&quot;price&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;value&quot;&lt;/span&gt;: 13.67&lt;br/&gt;}]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;模型绑定验证规则依然适用于 patch 操作，以保持数据的完整性。请注意，patch 操作被包装在一个数组中，因此它支持任意的操作列表。&lt;/p&gt;&lt;p&gt;下图是 curl 中请求 &lt;code&gt;PATCH&lt;/code&gt; 的结果：&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;352&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6087824351297405&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pAdPOatCTkPibticVogIc2mRYsrdDF77O2DAngJbjbHezwPm7mYuNic2OH3boibOJsxqtN7yKPBV0sWkzM7TnRtnhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1002&quot;/&gt;&lt;/p&gt;&lt;p&gt;最后一站，&lt;code&gt;DELETE&lt;/code&gt; 方法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[&lt;span&gt;HttpDelete&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;Route(&quot;{productNumber}&quot;)&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;ProducesResponseType(StatusCodes.Status200OK)&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;ProducesResponseType(StatusCodes.Status404NotFound)&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;Product&amp;gt; &lt;span&gt;DeleteProduct&lt;/span&gt;([FromRoute] &lt;br/&gt;        &lt;span&gt;string&lt;/span&gt; productNumber)&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; productDb = _context.Products&lt;br/&gt;    .FirstOrDefault(p =&amp;gt; p.ProductNumber.Equals(productNumber, &lt;br/&gt;           StringComparison.InvariantCultureIgnoreCase));&lt;br/&gt; &lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (productDb == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; NotFound();&lt;br/&gt; &lt;br/&gt;  _context.Products.Remove(productDb);&lt;br/&gt;  _context.SaveChanges();&lt;br/&gt; &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; NoContent();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它的状态码响应是 &lt;em&gt;No Content&lt;/em&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;HTTP/1.1 204 No Content&lt;br/&gt;Date: Tue, 14 Jul 2020 22:59:20 GMT&lt;br/&gt;Server: Kestrel&lt;br/&gt;api-supported-versions: 1.0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此状态向客户端发出信号，表示资源不再可用，因为响应主体为空。如果需要异步后台进程来清理数据，则响应也可以为 &lt;em&gt;204 (Accepted)&lt;/em&gt;。在实际系统中，有时最好使用软删除，以允许在审核期间进行回滚。删除数据时，请确保遵守 GPDR 或适用于该数据的任一策略。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;.NET Core 在您的工具袋中添加许多有用的特性，从而让使用 REST API 变得更加轻松，将诸如文档、验证、日志记录和 &lt;code&gt;PATCH&lt;/code&gt; 请求等复杂的用例变得更易于实现。&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;&lt;p&gt;相关链接：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;https://www.red-gate.com/simple-talk/dotnet/c-programming/build-a-rest-api-in-net-core/ Build a REST API in .NET Core ↩︎&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://dotnet.microsoft.com/download/dotnet-core Download .NET Core ↩︎&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://github.com/beautifulcoder/BuildRestApiNetCore 示例代码 ↩︎&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://rapidapi.com/blog/api-glossary/endpoint/ API Endpoints ↩︎&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://semver.org/ Semantic Versioning ↩︎&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://tools.ietf.org/html/rfc7807 RFC 7807 规范 ↩︎&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://tools.ietf.org/html/rfc6902 JSON Patch 文档 ↩︎&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;作者 ：Camilo Reyes  &lt;/span&gt;&lt;br/&gt;&lt;span&gt;译者 ：技术译民  &lt;/span&gt;&lt;br/&gt;&lt;span&gt;出品 ：技术译站（&lt;/span&gt;&lt;span&gt;https://ITTranslator.cn/&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36527777777777776&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pAdPOatCTkORBU446XynU3AOBP3V90kibDwiciaSfR3W3iajhvibQgCRxG0IoHdxEtAfGAVeh1Z0CxsRAjDoicjw7Rmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>