<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f6e6a1246e5c5e4faa29c3845a2093e9</guid>
<title>TiDB，面向未来的数据库到底是什么？</title>
<link>https://toutiao.io/k/8t9ns8j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1 data-mpa-powered-by=&quot;yiban.io&quot;&gt;背景&lt;/h1&gt;&lt;p&gt;tidb这个技术名词很多同学或多或少都曾经耳闻过，但是很多同学觉得他是分布式数据库，自己的业务是使用mysql，基本使用不上这个技术，可能不会去了解他。最近业务上有个需求使用到了tidb，于是学习了一下基本原理，会发现这些原理其实不仅仅局限于分布式数据库这一块，很多技术都是通用的，所以在这里写一下分享一下学习tidb的一些心得。&lt;/p&gt;&lt;p&gt;先说说为什么选择tidb吧，一般来说在咱们的业务中都是使用的mysql,但是单机数据库容量和并发性能都有限，对于一些大容量或者高并发的场景我们会选择sharding-jdbc去做，使用sharding-jdbc的确解决了问题但是增加了开发难度，我需要对我的每一个表都设置分表key，并且每个查询都得带入这个key的值，这样就增加了查询限制，如果不带key的值就得所有库表都得查询一次才行，效率极低，所以我们又异构了一份数据到es来满足其他条件。怎么解决这个问题呢？正好公司最近内部在推tidb，我看了下tidb基本兼容mysql，存储无限扩展，开发成本比较低，性能整体也不错，所以决定使用了tidb。 &lt;img data-ratio=&quot;1.8029925187032418&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/WLIGprPy3z49NQbPFF8GricNQSNMiaCd4OmicAE8Cjbw7rrLCD42bZib4rT9X2hib8fq4ibiaickubFiavy1TlyBia29JeJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;401&quot;/&gt;&lt;/p&gt;&lt;h2&gt;数据库发展历史&lt;/h2&gt;&lt;h3&gt;关系型单机数据库&lt;/h3&gt;&lt;p&gt;关系型数据库的开始是以1970年Edgar F.Codd 提出了关系模型。在数据库发展早期阶段，出现了很多优秀的商业数据库产品，如Oracle/DB2。在1990年之后，出现了开源数据库MySQL和PostgreSQL。这些数据库不断地提升单机实例性能，再加上遵循摩尔定律的硬件提升速度，往往能够很好地支撑业务发展。&lt;/p&gt;&lt;h3&gt;分布式数据库&lt;/h3&gt;&lt;p&gt;随着摩尔定律的失效，单体数据库的发展很难应对更高级别的挑战，所以就出现了分布式数据库，分布式数据库拥有应对海量并发，海量存储的能力所以能应对更难的挑战。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;nosql:HBase是其中的典型代表。HBase是Hadoop生态中的重要产品，Google BigTable的开源实现，当然还有我们熟悉的redis，nosql有一些自己的特殊使用场景，所以有一些自己的弊端，BigTable不支持跨行事务，用java开发性能也跟不上，redis的话用内存存储，无法保证事务。并且nosql已经是不靠关系模型了。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;sharding: 我们依然可以通过单机数据库完成我们分布式数据库的功能，我们通过某个组件实现对sql进行分发到不同分片的功能，比如比较出名开源的有sharing-jdbc，mycat，阿里云上商业的有drds。sharing的话对于运维来说比较困难，如果需要扩容需要不断的进行手动迁移数据，还需要自己指定某一个分片key。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;newsql:在newsql中可以保证acid的事务，也维持了关系模型，并且还支持sql。比较出名的有goole的F1和Spanner，阿里的OceanBase,pingCap的tidb。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;学前提问&lt;/h3&gt;&lt;p&gt;在我们学习某个知识的时候，一般都是会带着一些问题去学习，有目的的学习会让你更快的上手，对于tidb或者分布式数据库，我在使用的时候会有这些疑问：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;如何保证无限扩展？因为平时使用的大多都是sharding-jdbc那种有个sharding-key的技术，这种其实无限扩展是比较麻烦的，所以我最开始就对tidb如何保证无限扩展发出了疑问？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如何保证id唯一，分布式数据库往往会进行分片，在单机数据库中的自增id就不成立，tidb是如何保证的呢？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如何保证事务？前面我们说过newsql是需要支持acid的事务的，那么我们的tidb是如何保证的呢？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过索引是如何查询数据的呢？单机数据库使用了索引加速查询，tidb又是如何做到用索引加速查询的呢？&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;tidb&lt;/h1&gt;&lt;h2&gt;架构&lt;/h2&gt;&lt;p&gt;再回答我们上面的那些问题之前，先看一看tidb的整体架构是什么？ &lt;img data-ratio=&quot;0.5227097767513472&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/WLIGprPy3z49NQbPFF8GricNQSNMiaCd4O3WZqJ4H3KOHn7WtRcQ8CibzaL37yI63jPhFzgIvfqkqc7iae3TzpW90Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1299&quot;/&gt;&lt;/p&gt;&lt;p&gt;tidb其实是典型的计算分离的架构，对计算分离架构不熟悉的可以看看我之前的文章:&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA5Mjg2MDQ5NQ==&amp;amp;mid=2452509559&amp;amp;idx=1&amp;amp;sn=59d9c7d3d8e990fe144cab8cbb65ced0&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;聊聊计算与分离&lt;/a&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;TiDB Server：计算层，对外暴露协议的连接端口，负责管理客户端的连接，主要做的就是执行SQL解析以及优化，生成分布式执行计划，由于这里是计算层是没有状态的，所以是可以无限扩展。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;PD Server:PD是整个集群的大脑，负责存储每个 TiKV 节点实时的数据分布情况和集群的整体拓扑结构，提供 TiDB Dashboard 管控界面，需要保持高可用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;TiKV: k-v存储引擎，在tikv内部，存储数据的基本单位是Region。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Tiflash：这个是用于列式的存储引擎&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;TSpark: 这是tidb对spark进行支持，所以tidb他是一个HTAP的数据库。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;如何无限扩展？&lt;/h2&gt;&lt;p&gt;我们首先来到我们的第一个问题，Tidb如何做到无限扩展？&lt;/p&gt;&lt;p&gt;首先我们来看看计算层: tidb-server，我们刚才说过在计算层中，是无状态的，所以就可以进行无限扩展，如果你的场景并发度很高或者数据库连接很多，可以考虑多扩展tidb-server。&lt;/p&gt;&lt;p&gt;然后我们来看看存储层，有一类数据云数据库通常也会被误认为是分布式数据库，也就是aws的auroradb和阿里云的polardb，这两个数据库也是采用的计算与存储分离的架构，在计算层也可以无限扩展，但是在存储层他们使用的是一份数据，这个也就是shared-storage架构，这两个数据库依靠这大容量磁盘，来支撑更高容量的数据。&lt;/p&gt;&lt;p&gt;在tidb中是shared-nothing架构，存储层也是分离的： &lt;img data-ratio=&quot;0.6649076517150396&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/WLIGprPy3z49NQbPFF8GricNQSNMiaCd4OUDWW0WofXIkHa9JyWeyGPI5UPlGy158iaPNRuTtyATICBZtE7o0DfhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2274&quot;/&gt;&lt;/p&gt;&lt;p&gt;在每个tikv上会划分出多个Region,这个也就是我们的基本存储单位,大家见这个图是不是发现这个架构似曾相识呢？&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.502&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/WLIGprPy3z49NQbPFF8GricNQSNMiaCd4O0cf85kaBxHz5siakH2ZDvMtzoMXmkHibvLJFjsVBvLrGVjjIukT9DibIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;从上面看，region就对应这kafka下的partition，partition在kafka中的作用也是用来将topic的压力打散到不同broker上，同样的在tidb的region上也是一样的,我们通过region为最小单位进行存储。&lt;/p&gt;&lt;p&gt;再详细介绍region之前先说一下存储引擎为什么叫tikv呢？原因就是这个存储引擎就是保存的就是一个key-value，你可以理解成java里面的hashmap，在tikv中没有选择自己研发如何将这个map数据去落地，而是通过一个非常优秀的kv存储引擎——rocksdb去进行磁盘落地。RocksDB是Facebook开源的一个KV高性能单机数据库，很多公司基于rocksdb做了很多优秀的存储产品，后面也会详细的写一篇介绍rocksdb的文章。&lt;/p&gt;&lt;p&gt;rocksdb是一个单机的存储引擎那么我们是需要保证数据在分布式环境下是不丢失的，在kafka中有其他partition的副本会不断的拉取leader副本，并且通过一个ISR的机制去维护。在tikv中，直接使用的raft协议去做数据复制，每个数据变更都会落地为一条 Raft 日志，通过 Raft 的日志复制功能，将数据安全可靠地同步到复制组的每一个节点中。不过在实际写入中，根据 Raft 的协议，只需要同步复制到多数节点，即可安全地认为数据写入成功。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7329545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/WLIGprPy3z49NQbPFF8GricNQSNMiaCd4OGycLE6UUZZFOI0898enGmhSa9BMrJoK0M2hRlkibW4EvkujLFx5fV9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;352&quot;/&gt;&lt;/p&gt;&lt;p&gt;可以发现其实这里是写的raft,通过raft接口再写的rocksdb。&lt;/p&gt;&lt;p&gt;我们这里回到region，region还有一个partition不一样的点在于，partition一般不会自动去扩容，在业务开发中他往往是一个恒定得值，而region不一样，region的大小默认是96MB，再实际得业务中，我们的region的个数会随着我们数据量而变多，当然如果我们的数据量变小，他也会自动合并。&lt;/p&gt;&lt;p&gt;如何确定某个数据是在哪个region上呢？一般来说有hash(key)和range(key)的方案，在tikv中选择的是rangekey，因为对于region分裂是比较方便的，每一个region其实就是一个[StartKey，EndKey) 的表示：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.905511811023622&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/WLIGprPy3z49NQbPFF8GricNQSNMiaCd4O8RXtZY3PR0eiaCqlCbAfS7TjrqMPs7CeTUetJficXoIEQFVoePrMjlYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;254&quot;/&gt;&lt;/p&gt;&lt;p&gt;出现region的分裂的时候，只需要新增一个region，将老region的数据拿出一部分到新region， 譬如 [a, b) -&amp;gt; [a, ab) + [ab, b)，如果是hash来做的话，他会将所有region的数据都会重新hash，所以在tikv中选的是range(key)的方式，合并也是一样。&lt;/p&gt;&lt;p&gt;所以对于tidb来说无论是存储层还是计算层，我们都可以无限扩展。&lt;/p&gt;&lt;h2&gt;如何保证id唯一&lt;/h2&gt;&lt;p&gt;在mysql中我们可以对于主键直接设置 &lt;code&gt;&lt;span&gt;AUTO_INCREMENT&lt;/span&gt;&lt;/code&gt;来达到自增列的效果，mysql是怎么做到自增的呢？&lt;/p&gt;&lt;p&gt;在单机中这些都好做，但是在分布式数据库中，我们就没法保证id的唯一了，我之前有写过相关的文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA5Mjg2MDQ5NQ==&amp;amp;mid=2452509243&amp;amp;idx=1&amp;amp;sn=5064dd7935c1b6e617b24244414aee44&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;如果再有人问你分布式ID，这篇文章丢给他&lt;/a&gt;。我们在使用sharding-jdbc的时候就是使用的文章介绍的leaf这个ID生成中间件，来完成ID生成。&lt;/p&gt;&lt;p&gt;在Tidb中同样支持 &lt;code&gt;&lt;span&gt;AUTO_INCREMENT&lt;/span&gt;&lt;/code&gt;,实现的原理和leaf中的号段模式一样，不能保证严格递增，只能保证趋势递增，具体原理是：，对于每一个自增列，都使用一个全局可见的键值对用于记录当前已分配的最大 ID。由于分布式环境下的节点通信存在一定开销，为了避免写请求放大的问题，每个 TiDB 节点在分配 ID 时，都申请一段 ID 作为缓存，用完之后再去取下一段，而不是每次分配都向存储节点申请。&lt;/p&gt;&lt;p&gt;tidb还支持 &lt;code&gt;&lt;span&gt;AUTO_RANDOM&lt;/span&gt;&lt;/code&gt;,可以用于解决大批量写数据入 TiDB 时因含有整型自增主键列的表而产生的热点问题。因为region是有序的如果一段时间大量有序的数据产生有可能会在同一个region上，所以我们可以使用AUTO_RANDOM来将我们的主键数据打散。&lt;/p&gt;&lt;h2&gt;如何保证事务&lt;/h2&gt;&lt;p&gt;这里我们先回顾一下事务的四大特性ACID，我们来想想在mysql的innodb中这个是怎么做的呢？&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;A:原子性，指一个事务中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节，原子性在mysql中我们是依赖redolog和undolog共同完成&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;C:一致性，指在事务开始之前和结束以后，数据库的完整性没有被破坏。一致性是依靠其他几个特性来保证的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;I:隔离性，指数据库允许多个并发事务同时对其数据进行读写和修改的能力。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，主要用于处理并发场景。mysql隔离性依靠的是锁和mvcc，在mysql里面锁的种类很丰富，mysql支持多种隔离性。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;D:持久性，事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失，持久性是依靠redolog和mysql的刷盘机制。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在tidb中ACID是什么做到的呢？&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;A:通过 Primary Key 所在 Region 的原子性来保证分布式事务的原子。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;C:TiDB 在写入数据之前，会校验数据的一致性，校验通过才会写入内存并返回成功。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;I:也是通过锁和mvcc来完成隔离性，但是在tidb只支持RR(可重复读)级别，RC隔离级别在4.0之后乐观模式下也能支持。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;D:事务一旦提交成功，数据全部持久化存储到 TiKV，并且还有多副本机制，如果发生宕机数据也不会丢失。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在mysql中的事务模型都是悲观事务模型，而在tidb中事务模型提供了乐观和悲观两种，怎么去理解悲观和乐观两种模型呢：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;悲观模型：其实和名字一样，只要在事务执行的时候认为每一条被你修改的数据都很大概率被其他事务修改(悲观的看法)。在mysql里面，如果你在事务中你对某一行修改是会给你加上行锁的，如果此时有其他事务想对这个数据进行修改，那么其他事务会被阻塞等待住。可以简单理解成边执行边检测冲突。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;乐观模型：我们认为我们修改的数据很大概率不会和其他事务产生冲突，所以不需要边执行边进行冲突检测，而是最后提交的时候进行冲突检测。如果冲突比较少这样就可以获得较高的性能。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在tidb中是如何实现这两种模式的呢？因为我们是分布式数据库，两阶段提交一般是分布式事务的通用解决方案，之前我写过很多分布式事务相关的文章大家可以自行查阅一下。&lt;/p&gt;&lt;h3&gt;乐观模式&lt;/h3&gt;&lt;p&gt;tidb同样使用两阶段提交来保证分布式事务的原子性，分为 Prewrite 和 Commit 两个阶段：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Prewrite：对事务修改的每个 Key 检测冲突并写入 lock 防止其他事务修改。对于每个事务，TiDB 会从涉及到改动的所有 Key 中选中一个作为当前事务的 Primary Key，事务提交或回滚都需要先修改 Primary Key，以它的提交与否作为整个事务执行结果的标识。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Commit：Prewrite 全部成功后，先同步提交 Primary Key，成功后事务提交成功，其他 Secondary Keys 会异步提交。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5413127413127413&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/WLIGprPy3z49NQbPFF8GricNQSNMiaCd4OzGaybicv0iaMhaAvL1BJGsDGJkibbaBRYklBSOxz4fuqfqjaiactQeWopg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1295&quot;/&gt;&lt;/p&gt;&lt;p&gt;整个事务步骤如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Step 1: 客户端开启事务，类似我们在mysql里面的 &lt;code&gt;&lt;span&gt;begin&lt;/span&gt;&lt;span&gt;trasaction&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Step 2: TiDB 向 PD 获取全局时间，可以知道这个事务的全局顺序，用于后续mvcc的处理&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Step 3: 发起DML，比如update xxx; 这个时候不会有冲突检测，只会在tidb内存中进行保存;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Step 4: 提交事务，类似我们在mysql里面的commit，这个时候tidb会在commit阶段完成两阶段提交，先进行prewrite 各种加锁检测之后如果没有问题再进行commit。这里举个例子:&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;begin&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;//step1&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;insert &lt;/span&gt;&lt;span&gt;into&lt;/span&gt;&lt;span&gt; xx&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;// step3&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;update xx&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;// step3&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;update xx&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;// step3&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;commit&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;// step4&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;在上面的例子中如果是悲观模式step3的时候就会进行加锁检测了，乐观模式下所有的工作都放在了commit中，所以会出现commit出现异常的状态，所以我们使用乐观模式需要更好的处理commit阶段的异常行为，这和我们一般的编程不一样。但是如果数据的竞争不是太激烈的话是可以使用乐观模式来提升性能的。&lt;/p&gt;&lt;h3&gt;悲观模式&lt;/h3&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.49433573635427397&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/WLIGprPy3z49NQbPFF8GricNQSNMiaCd4OgHeoO4TicQVDwVCrCCvLnXBIBgCEtOIyX060D2kmk6MA4OdicvibdmPHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;971&quot;/&gt;悲观模式把lock进行了提前，每个 DML 都会加悲观锁，锁写到 TiKV 里，同样会通过 raft 同步，在加悲观锁时检查各种约束，如 Write Conflict、key 唯一性约束等。&lt;/p&gt;&lt;p&gt;悲观事务下能保证我们的commit成功，这种模式比较符合我们的编程模式，所以tidb默认的模式也是悲观模式。&lt;/p&gt;&lt;h2&gt;如何做的索引查询&lt;/h2&gt;&lt;p&gt;为什么我会想到这个索引查询这个问题呢？当时是在看到了rocksdb是tidb的底层存储介质之后，我想到了在innodb中我们的索引是B+树，如果tidb的索引是b+树的话，那么rocksdb应该怎么去构造呢？&lt;/p&gt;&lt;p&gt;事实上在tidb中的索引也是使用的k-v形式去做的，我们先看看对于每一行的数据是怎么存储的：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;为了保证同一个表的数据放在一起，方便查找，TiDB 会为每个表分配一个表 ID，用 TableID 表示。表 ID 是一个整数，在整个集群内唯一。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;TiDB 会为表中每行数据分配一个行 ID，用 RowID 表示。行 ID 也是一个整数，在表内唯一。对于行 ID，TiDB 做了一个小优化，如果某个表有整数型的主键，TiDB 会使用主键的值当做这一行数据的行 ID。每行数据按照如下规则编码成 (Key, Value) 键值对：&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;   tablePrefix&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;TableID&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;_recordPrefixSep&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;RowID&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;col1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; col2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; col3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; col4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;假定我们的tablePrefix是常量字符t,recordPrefixSep是常量字符r，我们的tableId是1,rowID在这里是我们的主键假定是100,如果有一个用户表的数据，如下：&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;   t1_r100&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;zhangsan&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;如果我们的主键为整数的情况下，那么上面也可以看作是我们的主键索引，如果我们的主键不为整型或者说在唯一索引的情况下，规则编码如下：&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;   tablePrefix&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;tableID&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;_indexPrefixSep&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;indexID&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;_indexedColumnsValue&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;RowID&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;indexId是tidb为每个索引分配的ID，所以上面那个情况下一个indexedColumnsValue只能对应一条数据满足唯一性，如果是非唯一索引，我们可以有：&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;   tablePrefix&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;tableID&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;_indexPrefixSep&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;indexID&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;_indexedColumnsValue_rowId&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;这样一个indexedColumnsValue就可以有多行数据，所以其实我们region中的数据的索引并不会和region的数据再一起，而是有自己的region分片，同样的我们查询数据的时候需要依靠我们的tidb-server分析出来我们应该用什么样的索引，先根据索引数据查询出来rowId再根据rowId查询出来我们对应的数据。&lt;/p&gt;&lt;h1&gt;总结&lt;/h1&gt;&lt;p&gt;不管是tidb还是分布式数据库，要学习的知识还有非常的多，上面只是对tidb做了一些粗解的分析，如果大家要学习可以看看下面的一些资料：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;pingcap文档: https://docs.pingcap.com, ping cap的文档是我见过做得算是比较顶级的文档了，他可以说不叫做文档，其实是一个文章知识库，我的文章很多图和内容都是借鉴而来。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;极客时间《分布式数据库》：极客时间有一个课叫分布式数据库，不会局限于讲tidb，主要讲解的是分布式数据库的各种知识，并且会列举市场上的分布式数据库做对比。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;《数据库系统内幕》：豆瓣评分8.5，这本书讲解了很多数据库理论基本知识，不论上分布式数据库还是单机数据库都会使用到，稍微有一点难懂，但是还是会有不少收获。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;如果大家觉得这篇文章对你有帮助，你的关注和转发是对我最大的支持，O(∩_∩)O:&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/WLIGprPy3z49NQbPFF8GricNQSNMiaCd4ORITgwSuRh3TMQsiak8C1YibrmeMLRPlsjq1KTG7CW1D4qToT36PuSqMA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9d9139ea392ecda77719094c31e9f665</guid>
<title>资料 | LeetCode 刷题攻略</title>
<link>https://toutiao.io/k/ugxa54e</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fa7d152c1b317dd4110ad2ab5f7ccfb3</guid>
<title>13 张图，深入理解 Synchronized</title>
<link>https://toutiao.io/k/hah7rj1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java并发编程系列第二篇&lt;code&gt;Synchronized&lt;/code&gt;，文章风格依然是图文并茂，通俗易懂，本文带读者们由浅入深理解&lt;code&gt;Synchronized&lt;/code&gt;，让读者们也能与面试官疯狂对线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在并发编程中&lt;code&gt;Synchronized&lt;/code&gt;一直都是元老级的角色，&lt;code&gt;Jdk 1.6&lt;/code&gt;以前大家都称呼它为重量级锁，相对于&lt;code&gt;J U C&lt;/code&gt;包提供的&lt;code&gt;Lock&lt;/code&gt;，它会显得笨重，不过随着&lt;code&gt;Jdk 1.6&lt;/code&gt;对&lt;code&gt;Synchronized&lt;/code&gt;进行各种优化后，&lt;code&gt;Synchronized&lt;/code&gt;性能已经非常快了。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;内容大纲&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8167456556082149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxIuzKibicFib7R7RribANpXiaicXeMP832XK8wCGLklQ15MfFbDFgtBXJ3IJyvUeG4ezBD79tWCHzTaSbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;633&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Synchronized使用方式&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Synchronized&lt;/code&gt;是&lt;code&gt;Java&lt;/code&gt;提供的&lt;strong&gt;同步关键字&lt;/strong&gt;，在多线程场景下，对共享资源代码段进行读写操作（&lt;strong&gt;必须包含写操作，光读不会有线程安全问题，因为读操作天然具备线程安全特性&lt;/strong&gt;），可能会出现线程安全问题，我们可以使用&lt;code&gt;Synchronized&lt;/code&gt;锁定共享资源代码段，达到&lt;strong&gt;互斥&lt;/strong&gt;（&lt;code&gt;mutualexclusion&lt;/code&gt;）效果，保证线程安全。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;共享资源代码段又称为&lt;strong&gt;临界区&lt;/strong&gt;（&lt;code&gt;critical section&lt;/code&gt;），保证&lt;strong&gt;临界区互斥&lt;/strong&gt;，是指执行&lt;strong&gt;临界区&lt;/strong&gt;（&lt;code&gt;critical section&lt;/code&gt;）的只能有一个线程执行，其他线程阻塞等待，达到排队效果。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.629500580720093&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxIuzKibicFib7R7RribANpXiaicXdUlxHuRjRrCl9I0seDdiaea2Poy3VxRBgebgyy2FdhNGwWudE9s7MVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;861&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Synchronized&lt;/code&gt;的食用方式有三种&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;修饰普通函数，监视器锁（&lt;code&gt;monitor&lt;/code&gt;）便是对象实例（&lt;code&gt;this&lt;/code&gt;）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;修饰静态静态函数，视器锁（&lt;code&gt;monitor&lt;/code&gt;）便是对象的&lt;code&gt;Class&lt;/code&gt;实例（每个对象只有一个&lt;code&gt;Class&lt;/code&gt;实例）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;修饰代码块，监视器锁（&lt;code&gt;monitor&lt;/code&gt;）是指定对象实例&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;普通函数&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;普通函数使用&lt;code&gt;Synchronized&lt;/code&gt;的方式很简单，在&lt;strong&gt;访问权限修饰符&lt;/strong&gt;与&lt;strong&gt;函数返回类型&lt;/strong&gt;间加上&lt;code&gt;Synchronized&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6834862385321101&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxIuzKibicFib7R7RribANpXiaicX7aG4b675XsxvumWLMySbP4Rx6PaSmctUBu6ryK6EqgsficymAEQ3zrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;654&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多线程场景下，&lt;code&gt;thread&lt;/code&gt;与&lt;code&gt;threadTwo&lt;/code&gt;两个线程执行&lt;code&gt;incr&lt;/code&gt;函数，&lt;code&gt;incr&lt;/code&gt;函数作为&lt;strong&gt;共享资源代码段&lt;/strong&gt;被多线程&lt;strong&gt;读写操作&lt;/strong&gt;，我们将它称为&lt;strong&gt;临界区&lt;/strong&gt;，为了保证&lt;strong&gt;临界区互斥&lt;/strong&gt;，使用&lt;code&gt;Synchronized&lt;/code&gt;修饰&lt;code&gt;incr&lt;/code&gt;函数即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SyncTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 自增方法&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;incr&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//临界区代码--start&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10000&lt;/span&gt;; i++) {&lt;br/&gt;            j++;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//临界区代码--end&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getJ&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; j;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SyncMain&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        SyncTest syncTest = &lt;span&gt;new&lt;/span&gt; SyncTest();&lt;br/&gt;        Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; syncTest.incr());&lt;br/&gt;        Thread threadTwo = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; syncTest.incr());&lt;br/&gt;        thread.start();&lt;br/&gt;        threadTwo.start();&lt;br/&gt;        thread.join();&lt;br/&gt;        threadTwo.join();&lt;br/&gt;        &lt;span&gt;//最终打印结果是20000，如果不使用synchronized修饰，就会导致线程安全问题，输出不确定结果&lt;/span&gt;&lt;br/&gt;        System.out.println(syncTest.getJ());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码十分简单，&lt;code&gt;incr&lt;/code&gt;函数被&lt;code&gt;synchronized&lt;/code&gt;修饰，函数逻辑是对&lt;code&gt;j&lt;/code&gt;进行&lt;code&gt;10000&lt;/code&gt;次累加，两个线程执行&lt;code&gt;incr&lt;/code&gt;函数，最后输出&lt;code&gt;j&lt;/code&gt;结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;被&lt;code&gt;synchronized&lt;/code&gt;修饰函数我们简称&lt;strong&gt;同步函数&lt;/strong&gt;，线程执行称&lt;strong&gt;同步函数&lt;/strong&gt;前，需要先获取监视器锁，简称锁，获取锁成功才能执行&lt;strong&gt;同步函数&lt;/strong&gt;，&lt;strong&gt;同步函数&lt;/strong&gt;执行完后，&lt;strong&gt;线程会释放锁并通知唤醒其他线程获取锁&lt;/strong&gt;，获取锁失败「&lt;strong&gt;则阻塞并等待通知唤醒该线程重新获取锁&lt;/strong&gt;」，&lt;strong&gt;同步函数&lt;/strong&gt;会以&lt;code&gt;this&lt;/code&gt;作为锁，即当前对象，以上面的代码段为例就是&lt;code&gt;syncTest&lt;/code&gt;对象。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.293897882938979&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxIuzKibicFib7R7RribANpXiaicXPW9aSuWSx27XN6Zd1b3licc3k6atb5P34p0xBYpkADoPDzzywUgSTmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;803&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;线程&lt;code&gt;thread&lt;/code&gt;执行&lt;code&gt;syncTest.incr()&lt;/code&gt;前&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;线程&lt;code&gt;thread&lt;/code&gt;获取锁成功&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;线程&lt;code&gt;threadTwo&lt;/code&gt;执行&lt;code&gt;syncTest.incr()&lt;/code&gt;前&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;线程&lt;code&gt;threadTwo&lt;/code&gt;获取锁失败&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;线程&lt;code&gt;threadTwo&lt;/code&gt;阻塞并等待唤醒&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;线程&lt;code&gt;thread&lt;/code&gt;执行完&lt;code&gt;syncTest.incr()&lt;/code&gt;，&lt;code&gt;j&lt;/code&gt;累积到&lt;code&gt;10000&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;线程&lt;code&gt;thread&lt;/code&gt;释放锁，通知唤醒&lt;code&gt;threadTwo&lt;/code&gt;线程获取锁&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;线程&lt;code&gt;threadTwo&lt;/code&gt;获取锁成功&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;线程&lt;code&gt;threadTwo&lt;/code&gt;执行完&lt;code&gt;syncTest.incr()&lt;/code&gt;，&lt;code&gt;j&lt;/code&gt;累积到&lt;code&gt;20000&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;线程&lt;code&gt;threadTwo&lt;/code&gt;释放锁&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;静态函数&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;静态函数顾名思义，就是静态的函数，它使用&lt;code&gt;Synchronized&lt;/code&gt;的方式与普通函数一致，唯一的区别是锁的对象不再是&lt;code&gt;this&lt;/code&gt;，而是&lt;code&gt;Class&lt;/code&gt;对象。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28288169200264374&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxIuzKibicFib7R7RribANpXiaicXr9N7HQD3GwXnMp9V5RTg0omQYhxfNhSgzKiayFDR2La81YayrPGF2Lw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1513&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多线程执行&lt;code&gt;Synchronized&lt;/code&gt;修饰静态函数代码段如下。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SyncTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 自增方法&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;incr&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//临界区代码--start&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10000&lt;/span&gt;; i++) {&lt;br/&gt;            j++;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//临界区代码--end&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getJ&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; j;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SyncMain&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; SyncTest.incr());&lt;br/&gt;        Thread threadTwo = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; SyncTest.incr());&lt;br/&gt;        thread.start();&lt;br/&gt;        threadTwo.start();&lt;br/&gt;        thread.join();&lt;br/&gt;        threadTwo.join();&lt;br/&gt;        &lt;span&gt;//最终打印结果是20000，如果不使用synchronized修饰，就会导致线程安全问题，输出不确定结果&lt;/span&gt;&lt;br/&gt;        System.out.println(SyncTest.getJ());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Java&lt;/code&gt;的静态资源可以直接通过类名调用，静态资源不属于任何实例对象，它只属于&lt;code&gt;Class&lt;/code&gt;对象，每个&lt;code&gt;Class&lt;/code&gt;在&lt;code&gt;J V M&lt;/code&gt;中只有唯一的一个&lt;code&gt;Class&lt;/code&gt;对象，所以同步静态函数会以&lt;code&gt;Class&lt;/code&gt;对象作为锁，后续获取锁、释放锁流程都一致。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;代码块&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面介绍的普通函数与静态函数粒度都比较大，以整个函数为范围锁定，现在想把范围缩小、灵活配置，就需要使用&lt;strong&gt;代码块&lt;/strong&gt;了，使用&lt;code&gt;{}&lt;/code&gt;符号定义范围给&lt;code&gt;Synchronized&lt;/code&gt;修饰。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.11479385610347616&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxIuzKibicFib7R7RribANpXiaicXcjl4HglN3Cd9r05lrptTVU7wJrmWnHkbGBjBUoWKKZL4TfrZ0bNJcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1237&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面代码中定义了&lt;code&gt;syncDbData&lt;/code&gt;函数，&lt;code&gt;syncDbData&lt;/code&gt;是一个伪同步数据的函数，耗时&lt;code&gt;2&lt;/code&gt;秒，并且逻辑不涉及&lt;strong&gt;共享资源读写操作&lt;/strong&gt;（&lt;strong&gt;非临界区&lt;/strong&gt;），另外还有两个函数&lt;code&gt;incr&lt;/code&gt;与&lt;code&gt;incrTwo&lt;/code&gt;，都是在自增逻辑前执行了&lt;code&gt;syncDbData&lt;/code&gt;函数，只是使用&lt;code&gt;Synchronized&lt;/code&gt;的姿势不同，一个是修饰在函数上，另一个是修饰在代码块上。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SyncTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 同步库数据，比较耗时，代码资源不涉及共享资源读写操作。&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;syncDbData&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;db数据开始同步------------&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//同步时间需要2秒&lt;/span&gt;&lt;br/&gt;            Thread.sleep(&lt;span&gt;2000&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;db数据开始同步完成------------&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//自增方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;incr&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//start--临界区代码&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//同步库数据&lt;/span&gt;&lt;br/&gt;        syncDbData();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10000&lt;/span&gt;; i++) {&lt;br/&gt;            j++;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//end--临界区代码&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//自增方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;incrTwo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//同步库数据&lt;/span&gt;&lt;br/&gt;        syncDbData();&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//start--临界区代码&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10000&lt;/span&gt;; i++) {&lt;br/&gt;                j++;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//end--临界区代码&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getJ&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; j;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SyncMain&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//incr同步方法执行&lt;/span&gt;&lt;br/&gt;        SyncTest syncTest = &lt;span&gt;new&lt;/span&gt; SyncTest();&lt;br/&gt;        Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; syncTest.incr());&lt;br/&gt;        Thread threadTwo = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; syncTest.incr());&lt;br/&gt;        thread.start();&lt;br/&gt;        threadTwo.start();&lt;br/&gt;        thread.join();&lt;br/&gt;        threadTwo.join();&lt;br/&gt;        &lt;span&gt;//最终打印结果是20000&lt;/span&gt;&lt;br/&gt;        System.out.println(syncTest.getJ());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//incrTwo同步块执行&lt;/span&gt;&lt;br/&gt;        thread = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; syncTest.incrTwo());&lt;br/&gt;        threadTwo = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; syncTest.incrTwo());&lt;br/&gt;        thread.start();&lt;br/&gt;        threadTwo.start();&lt;br/&gt;        thread.join();&lt;br/&gt;        threadTwo.join();&lt;br/&gt;        &lt;span&gt;//最终打印结果是40000&lt;/span&gt;&lt;br/&gt;        System.out.println(syncTest.getJ());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看看&lt;code&gt;incr&lt;/code&gt;同步方法执行，流程和前面没区别，只是&lt;code&gt;Synchronized&lt;/code&gt;锁定的范围太大，把&lt;code&gt;syncDbData()&lt;/code&gt;也纳入&lt;strong&gt;临界区&lt;/strong&gt;中，多线程场景执行，会有性能上的浪费，因为&lt;code&gt;syncDbData()&lt;/code&gt;完全可以让多线程&lt;strong&gt;并行&lt;/strong&gt;或&lt;strong&gt;并发&lt;/strong&gt;执行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1422680412371133&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxIuzKibicFib7R7RribANpXiaicX8wnxYfmvcZTYb3P4GicRynCnibJLyyaQubPciaW4XhIhKQ4GSujNibc7IQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;970&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过代码块的方式，来缩小范围，定义正确的&lt;strong&gt;临界区&lt;/strong&gt;，提升性能，目光转到&lt;code&gt;incrTwo&lt;/code&gt;同步块执行，&lt;code&gt;incrTwo&lt;/code&gt;函数使用修饰代码块的方式同步，只对自增代码段进行锁定。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0217391304347827&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxIuzKibicFib7R7RribANpXiaicXfLgicnpez5FdR3ibWGufx2ictvPKezGwVYlIyaN3ftNMia2GWAZ1iafuqgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;966&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码块同步方式除了灵活控制范围外，还能做线程间的协同工作，因为&lt;code&gt;Synchronized ()&lt;/code&gt;括号中能接收任何对象作为锁，所以可以通过&lt;code&gt;Object&lt;/code&gt;的&lt;code&gt;wait、notify、notifyAll&lt;/code&gt;等函数，做多线程间的通信协同（本文不对线程通信协同做展开，主角是&lt;code&gt;Synchronized&lt;/code&gt;，而且也不推荐去用这些方法，因为&lt;code&gt;LockSupport&lt;/code&gt;工具类会是更好的选择）。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;wait：当前线程暂停，释放锁&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;notify：释放锁，唤醒调用了wait的线程（如果有多个随机唤醒一个）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;notifyAll：释放锁，唤醒调用了wait的所有线程&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Synchronized原理&lt;/h1&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SyncTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 同步库数据，比较耗时，代码资源不涉及共享资源读写操作。&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;syncDbData&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;db数据开始同步------------&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//同步时间需要2秒&lt;/span&gt;&lt;br/&gt;            Thread.sleep(&lt;span&gt;2000&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;db数据开始同步完成------------&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//自增方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;incr&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//start--临界区代码&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//同步库数据&lt;/span&gt;&lt;br/&gt;        syncDbData();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10000&lt;/span&gt;; i++) {&lt;br/&gt;            j++;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//end--临界区代码&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//自增方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;incrTwo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//同步库数据&lt;/span&gt;&lt;br/&gt;        syncDbData();&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//start--临界区代码&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10000&lt;/span&gt;; i++) {&lt;br/&gt;                j++;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//end--临界区代码&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getJ&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; j;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了探究&lt;code&gt;Synchronized&lt;/code&gt;原理，我们对上面的代码进行反编译，输出反编译后结果，看看底层是如何实现的（&lt;strong&gt;环境Java 11、win 10系统&lt;/strong&gt;）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  只截取了incr与incrTwo函数内容&lt;br/&gt;        &lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;incr&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    Code:&lt;br/&gt;       &lt;span&gt;0&lt;/span&gt;: aload_0                                         &lt;br/&gt;       &lt;span&gt;1&lt;/span&gt;: invokevirtual #&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;// Method syncDbData:()V &lt;/span&gt;&lt;br/&gt;       &lt;span&gt;4&lt;/span&gt;: iconst_0                          &lt;br/&gt;       &lt;span&gt;5&lt;/span&gt;: istore_1                          &lt;br/&gt;       &lt;span&gt;6&lt;/span&gt;: iload_1                                     &lt;br/&gt;       &lt;span&gt;7&lt;/span&gt;: sipush        &lt;span&gt;10000&lt;/span&gt;               &lt;br/&gt;      &lt;span&gt;10&lt;/span&gt;: if_icmpge     &lt;span&gt;27&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;13&lt;/span&gt;: getstatic     #&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;// Field j:I&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;16&lt;/span&gt;: iconst_1&lt;br/&gt;      &lt;span&gt;17&lt;/span&gt;: iadd&lt;br/&gt;      &lt;span&gt;18&lt;/span&gt;: putstatic     #&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;// Field j:I&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;21&lt;/span&gt;: iinc          &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;24&lt;/span&gt;: goto          &lt;span&gt;6&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;27&lt;/span&gt;: &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;incrTwo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;    &lt;br/&gt;    Code:&lt;br/&gt;       &lt;span&gt;0&lt;/span&gt;: aload_0&lt;br/&gt;       &lt;span&gt;1&lt;/span&gt;: invokevirtual #&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;// Method syncDbData:()V&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;4&lt;/span&gt;: aload_0&lt;br/&gt;       &lt;span&gt;5&lt;/span&gt;: dup&lt;br/&gt;       &lt;span&gt;6&lt;/span&gt;: astore_1&lt;br/&gt;       &lt;span&gt;7&lt;/span&gt;: monitorenter                     &lt;span&gt;//获取锁&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;8&lt;/span&gt;: iconst_0&lt;br/&gt;       &lt;span&gt;9&lt;/span&gt;: istore_2&lt;br/&gt;      &lt;span&gt;10&lt;/span&gt;: iload_2&lt;br/&gt;      &lt;span&gt;11&lt;/span&gt;: sipush        &lt;span&gt;10000&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;14&lt;/span&gt;: if_icmpge     &lt;span&gt;31&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;17&lt;/span&gt;: getstatic     #&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;// Field j:I&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;20&lt;/span&gt;: iconst_1&lt;br/&gt;      &lt;span&gt;21&lt;/span&gt;: iadd&lt;br/&gt;      &lt;span&gt;22&lt;/span&gt;: putstatic     #&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;// Field j:I&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;25&lt;/span&gt;: iinc          &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;28&lt;/span&gt;: goto          &lt;span&gt;10&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;31&lt;/span&gt;: aload_1&lt;br/&gt;      &lt;span&gt;32&lt;/span&gt;: monitorexit                      &lt;span&gt;//正常退出释放锁 &lt;/span&gt;&lt;br/&gt;      &lt;span&gt;33&lt;/span&gt;: goto          &lt;span&gt;41&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;36&lt;/span&gt;: astore_3&lt;br/&gt;      &lt;span&gt;37&lt;/span&gt;: aload_1&lt;br/&gt;      &lt;span&gt;38&lt;/span&gt;: monitorexit                      &lt;span&gt;//异步退出释放锁    &lt;/span&gt;&lt;br/&gt;      &lt;span&gt;39&lt;/span&gt;: aload_3&lt;br/&gt;      &lt;span&gt;40&lt;/span&gt;: athrow&lt;br/&gt;      &lt;span&gt;41&lt;/span&gt;: &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ps:对上面指令感兴趣的读者，可以百度或google一下“JVM 虚拟机字节码指令表”&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看&lt;code&gt;incrTwo&lt;/code&gt;函数，&lt;code&gt;incrTwo&lt;/code&gt;是代码块方式同步，在反编译后的结果中，我们发现存在&lt;code&gt;monitorenter&lt;/code&gt;与&lt;code&gt;monitorexit&lt;/code&gt;指令（&lt;strong&gt;获取锁、释放锁&lt;/strong&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;monitorenter&lt;/code&gt;指令插入到同步代码块的开始位置，&lt;code&gt;monitorexit&lt;/code&gt;指令插入到同步代码块的结束位置，&lt;code&gt;J V M&lt;/code&gt;需要保证每一个 &lt;code&gt;monitorenter&lt;/code&gt;都有&lt;code&gt;monitorexit&lt;/code&gt;与之对应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;任何对象&lt;/strong&gt;都有一个监视器锁（&lt;code&gt;monitor&lt;/code&gt;）关联，线程执行&lt;code&gt;monitorenter&lt;/code&gt;指令时尝试获取&lt;code&gt;monitor&lt;/code&gt;的所有权。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;如果&lt;code&gt;monitor&lt;/code&gt;的进入数为&lt;code&gt;0&lt;/code&gt;，则该线程进入&lt;code&gt;monitor&lt;/code&gt;，然后将进入数设置为&lt;code&gt;1&lt;/code&gt;，该线程为&lt;code&gt;monitor&lt;/code&gt;的所有者&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;如果线程已经占有该&lt;code&gt;monitor&lt;/code&gt;，重新进入，则&lt;code&gt;monitor&lt;/code&gt;的进入数加&lt;code&gt;1&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;线程执行&lt;code&gt;monitorexit&lt;/code&gt;，&lt;code&gt;monitor&lt;/code&gt;的进入数-1，执行过多少次&lt;code&gt;monitorenter&lt;/code&gt;，最终要执行对应次数的&lt;code&gt;monitorexit&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;如果其他线程已经占用&lt;code&gt;monitor&lt;/code&gt;，则该线程进入阻塞状态，直到&lt;code&gt;monitor&lt;/code&gt;的进入数为0，再重新尝试获取&lt;code&gt;monitor&lt;/code&gt;的所有权&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回过头看&lt;code&gt;incr&lt;/code&gt;函数，&lt;code&gt;incr&lt;/code&gt;是普通函数方式同步，虽然在反编译后的结果中没有看到&lt;code&gt;monitorenter&lt;/code&gt;与&lt;code&gt;monitorexit&lt;/code&gt;指令，但是实际执行的流程与&lt;code&gt;incrTwo&lt;/code&gt;函数一样，通过&lt;code&gt;monitor&lt;/code&gt;来执行，只不过它是一种隐式的方式来实现，最后放一张流程图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.43629032258064515&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxIuzKibicFib7R7RribANpXiaicXOLFFIYVWlsk6gicbtCXFCM3IBfDeUmmH0Hh0NxLqBSToHSibRNic3Y2YA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Synchronized优化&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Jdk 1.5&lt;/code&gt;以后对&lt;code&gt;Synchronized&lt;/code&gt;关键字做了各种的优化，经过优化后&lt;code&gt;Synchronized&lt;/code&gt;已经变得原来越快了，这也是为什么官方建议使用&lt;code&gt;Synchronized&lt;/code&gt;的原因，具体的优化点如下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;锁粗化&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;互斥的临界区&lt;/strong&gt;范围应该尽可能小，这样做的目的是为了使同步的操作数量尽可能缩小，缩短阻塞时间，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是加锁解锁也需要消耗资源，如果存在一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，&lt;strong&gt;锁粗化&lt;/strong&gt;就是将「&lt;strong&gt;多个连续的加锁、解锁操作连接在一起&lt;/strong&gt;」，扩展成一个范围更大的锁，避免频繁的加锁解锁操作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3676190476190476&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxIuzKibicFib7R7RribANpXiaicXvJU9BnEbxCGEF4BMPn8gUueg7mjnMGt7kIQRLIKmLibPW45JTWNErVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1050&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;J V M&lt;/code&gt;会检测到一连串的操作都对同一个对象加锁（&lt;code&gt;for&lt;/code&gt;循环&lt;code&gt;10000&lt;/code&gt;次执行&lt;code&gt;j++&lt;/code&gt;，没有锁粗化就要进行&lt;code&gt;10000&lt;/code&gt;次加锁/解锁），此时&lt;code&gt;J V M&lt;/code&gt;就会将加锁的范围粗化到这一连串操作的外部（比如&lt;code&gt;for&lt;/code&gt;循环体外），使得这一连串操作只需要加一次锁即可。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;锁消除&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Java&lt;/code&gt;虚拟机在&lt;code&gt;JIT&lt;/code&gt;编译时(&lt;strong&gt;可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译&lt;/strong&gt;)，通过对运行上下文的扫描，经过逃逸分析（&lt;strong&gt;对象在函数中被使用，也可能被外部函数所引用，称为函数逃逸&lt;/strong&gt;），去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的时间消耗。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34523809523809523&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxIuzKibicFib7R7RribANpXiaicXs0JMNDHPiaOX1ymLVibg1wtm7TibXIZjKQchjtbQXF4DpEwBtXkGxQsVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1008&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码中使用&lt;code&gt;Object&lt;/code&gt;作为锁，但是&lt;code&gt;Object&lt;/code&gt;对象的生命周期只在&lt;code&gt;incrFour()&lt;/code&gt;函数中，并不会被其他线程所访问到，所以在&lt;code&gt;J I T&lt;/code&gt;编译阶段就会被优化掉（&lt;strong&gt;此处的&lt;code&gt;Object&lt;/code&gt;属于没有逃逸的对象&lt;/strong&gt;）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;锁升级&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Java&lt;/code&gt;中每个对象都拥有对象头，对象头由&lt;code&gt;Mark World&lt;/code&gt; 、指向类的指针、以及数组长度三部分组成，本文，我们只需要关心&lt;code&gt;Mark World&lt;/code&gt; 即可，&lt;code&gt;Mark World&lt;/code&gt;  记录了对象的&lt;code&gt;HashCode&lt;/code&gt;、分代年龄和锁标志位信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Mark World简化结构&lt;/strong&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;锁状态&lt;/th&gt;&lt;th&gt;存储内容&lt;/th&gt;&lt;th&gt;锁标记&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;无锁&lt;/td&gt;&lt;td&gt;对象的hashCode、对象分代年龄、是否是偏向锁（0）&lt;/td&gt;&lt;td&gt;01&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;偏向锁&lt;/td&gt;&lt;td&gt;偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）&lt;/td&gt;&lt;td&gt;01&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;轻量级锁&lt;/td&gt;&lt;td&gt;指向栈中锁记录的指针&lt;/td&gt;&lt;td&gt;00&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;重量级锁&lt;/td&gt;&lt;td&gt;指向互斥量（重量级锁）的指针&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读者们只需知道，锁的升级变化，体现在锁对象的对象头&lt;code&gt;Mark World&lt;/code&gt;部分，也就是说&lt;code&gt;Mark World&lt;/code&gt;的内容会随着锁升级而改变。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Java1.5&lt;/code&gt;以后为了减少获取锁和释放锁带来的性能消耗，引入了&lt;strong&gt;偏向锁&lt;/strong&gt;和&lt;strong&gt;轻量级锁&lt;/strong&gt;，&lt;code&gt;Synchronized&lt;/code&gt;的升级顺序是 「&lt;strong&gt;无锁--&amp;gt;偏向锁--&amp;gt;轻量级锁--&amp;gt;重量级锁，只会升级不会降级&lt;/strong&gt;」&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;偏向锁&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁，其目标就是在只有一个线程执行同步代码块时，降低获取锁带来的消耗，提高性能（&lt;strong&gt;可以通过J V M参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态&lt;/strong&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程执行同步代码或方法前，线程只需要判断对象头的&lt;code&gt;Mark Word&lt;/code&gt;中线程&lt;code&gt;ID&lt;/code&gt;与当前线程&lt;code&gt;ID&lt;/code&gt;是否一致，如果一致直接执行同步代码或方法，具体流程如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7794216543375925&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxIuzKibicFib7R7RribANpXiaicXh8Nz2u883WaEwP6pZ2luBuCX1R65raB3wzEicJe5VMPic6kqmpdr1zTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1487&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;无锁状态，存储内容「是否为偏向锁（&lt;code&gt;0&lt;/code&gt;）」，锁标识位&lt;code&gt;01&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;CAS&lt;/code&gt;设置当前线程ID到&lt;code&gt;Mark Word&lt;/code&gt;存储内容中&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;strong&gt;是否为偏向锁&lt;/strong&gt;&lt;code&gt;0&lt;/code&gt; =&amp;gt; 是否为偏向锁&lt;code&gt;1&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;执行同步代码或方法&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;偏向锁状态，存储内容「是否为偏向锁（&lt;code&gt;1&lt;/code&gt;）、线程ID」，锁标识位&lt;code&gt;01&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;对比线程&lt;code&gt;ID&lt;/code&gt;是否一致，如果一致执行同步代码或方法，否则进入下面的流程&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;如果不一致，&lt;code&gt;CAS&lt;/code&gt;将&lt;code&gt;Mark Word&lt;/code&gt;的线程&lt;code&gt;ID&lt;/code&gt;设置为当前线程&lt;code&gt;ID&lt;/code&gt;，设置成功，执行同步代码或方法，否则进入下面的流程&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;CAS&lt;/code&gt;设置失败，证明存在多线程竞争情况，触发撤销偏向锁，当到达全局安全点，偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后在安全点的位置恢复继续往下执行。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;轻量级锁&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;轻量级锁考虑的是竞争锁对象的线程不多，持有锁时间也不长的场景。因为阻塞线程需要&lt;code&gt;C P U&lt;/code&gt;从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失，所以干脆不阻塞这个线程，让它自旋一段时间等待锁释放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当前线程持有的锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。轻量级锁的获取主要有两种情况：① 当关闭偏向锁功能时；② 多个线程竞争偏向锁导致偏向锁升级为轻量级锁。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8660049627791563&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxIuzKibicFib7R7RribANpXiaicXTzkRPDbexpAtsibiaHAV1OhcLAyJzGhpI1ZicUaGDqVPO6YYxudfeCBicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1209&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;无锁状态，存储内容「是否为偏向锁（&lt;code&gt;0&lt;/code&gt;）」，锁标识位&lt;code&gt;01&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;关闭偏向锁功能时&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;CAS&lt;/code&gt;设置当前线程栈中锁记录的指针到&lt;code&gt;Mark Word&lt;/code&gt;存储内容&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;锁标识位设置为&lt;code&gt;00&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;执行同步代码或方法&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;释放锁时，还原来&lt;code&gt;Mark Word&lt;/code&gt;内容&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;轻量级锁状态，存储内容「线程栈中锁记录的指针」，锁标识位&lt;code&gt;00&lt;/code&gt;（存储内容的线程是指&quot;持有轻量级锁的线程&quot;）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;CAS&lt;/code&gt;设置当前线程栈中锁记录的指针到&lt;code&gt;Mark Word&lt;/code&gt;存储内容，设置成功获取轻量级锁，执行同步块代码或方法，否则执行下面的逻辑&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;设置失败，证明多线程存在一定竞争，线程自旋上一步的操作，自旋一定次数后还是失败，轻量级锁升级为重量级锁&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;Mark Word&lt;/code&gt;存储内容替换成重量级锁指针，锁标记位&lt;code&gt;10&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重量级锁&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;轻量级锁膨胀之后，就升级为重量级锁，重量级锁是依赖操作系统的&lt;code&gt;MutexLock&lt;/code&gt;（&lt;strong&gt;互斥锁&lt;/strong&gt;）来实现的，需要从用户态转到内核态，这个成本非常高，这就是为什么&lt;code&gt;Java1.6&lt;/code&gt;之前&lt;code&gt;Synchronized&lt;/code&gt;效率低的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;升级为重量级锁时，锁标志位的状态值变为&lt;code&gt;10&lt;/code&gt;，此时&lt;code&gt;Mark Word&lt;/code&gt;中存储内容的是重量级锁的指针，等待锁的线程都会进入阻塞状态，下面是简化版的锁升级过程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.27525057825751736&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxIuzKibicFib7R7RribANpXiaicXZVW5QYTqJdNQ1zefwXrcBkuppfz5ce22tlbdMTU5KBezSyOZJlkOvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1297&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;历史好文推荐&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关于我&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是阿星，一个热爱技术的Java程序猿，公众号  &lt;strong&gt;&lt;span&gt;「程序猿阿星」&lt;/span&gt;&lt;/strong&gt; 里将会定期分享操作系统、计算机网络、Java、分布式、数据库等精品原创文章，2021，与您在 Be Better 的路上共同成长！。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5763888888888888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/23OQmC1ia8nxIuzKibicFib7R7RribANpXiaicXuGXnlYL9XPXjUd8u6eWsiblO5aUYgUgtpeHFKYnxafcAaJZQqJE3DLw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;288&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常感谢各位小哥哥小姐姐们能看到这里，原创不易，文章有帮助可以关注、点个赞、分享与评论，都是支持（莫要白嫖）！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;愿你我都能奔赴在各自想去的路上，我们下篇文章见&lt;/p&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1adec15db9ebc7ae6cc61a202c83d37a</guid>
<title>ELK 日志实时分析实战</title>
<link>https://toutiao.io/k/5tt5kol</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;0、问题来源&lt;/span&gt;&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6314814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9bYomlNsZvwicIhGYKWyIpvickmvbYuMwysXQa8c6QCCH4sZAh8O7CdLCuEbNja9WkPsKLjSeia9m9bw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、日志实时分析是 Elasticsearch 三大核心业务场景之一&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2453358208955224&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9bYomlNsZvwicIhGYKWyIpvicKzicApCDj0Dghe3csqhFXoibX6IllgsB2tzsEkxGej2m85XiaMRfiacoQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1072&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDY1MTA3OQ==&amp;amp;mid=2247486663&amp;amp;idx=1&amp;amp;sn=b69c95d53d4cb89a22bc91759dcfde34&amp;amp;chksm=eaa824efdddfadf9a607414bbcb08de86dd95a44b7c95170d45206c07bd7f310f3009f4c0d5c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Elasticsearch架构选型指南——不止是搜索引擎，还有......&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Elasticsearch架构选型指南——不止是搜索引擎，还有......&lt;/a&gt;曾强调：Elasticsearch 三大核心业务场景：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;搜索服务场景。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;日志实时分析场景。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;商业智能 BI 场景。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、少啰嗦，先看东西&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1 日志数据准备&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;以 Python 日志作为数据源，开搞。&lt;/p&gt;&lt;p&gt;在 Python 中，日志记录可以分为 5 种不同级别：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Info — 指定信息性消息，在粗粒度级别突出显示应用程序的进度。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Debug — 指定对调试应用程序最有用的细粒度信息事件。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Warning — 指定警告/告警事件。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Error  — 指定已出错，但仍允许应用程序继续运行的事件。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Critical — 指定可能导致应用程序中止的非常严重的错误事件。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;日志随机生成 Python 3.X 脚本如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import logging&lt;br/&gt;import random&lt;br/&gt;&lt;br/&gt;logging.basicConfig(filename=&lt;span&gt;&quot;logFile.txt&quot;&lt;/span&gt;,&lt;br/&gt;                    filemode=&lt;span&gt;&#x27;a&#x27;&lt;/span&gt;,&lt;br/&gt;                    format=&lt;span&gt;&#x27;%(asctime)s %(levelname)s-%(message)s&#x27;&lt;/span&gt;,&lt;br/&gt;                    datefmt=&lt;span&gt;&#x27;%Y-%m-%d %H:%M:%S&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(0,30):&lt;br/&gt;    x=random.randint(0,2)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(x==0):&lt;br/&gt;        logging.warning(&lt;span&gt;&#x27;Log Message&#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;elif&lt;/span&gt;(x==1):&lt;br/&gt;        logging.critical(&lt;span&gt;&#x27;Log Message&#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;        logging.error(&lt;span&gt;&#x27;Log Message&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成日志文件 logFile.txt 部分内容如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;2021-07-10 21:57:29 ERROR-Log Message&lt;br/&gt;2021-07-10 21:57:29 ERROR-Log Message&lt;br/&gt;2021-07-10 21:57:29 CRITICAL-Log Message&lt;br/&gt;2021-07-10 21:57:29 WARNING-Log Message&lt;br/&gt;2021-07-10 21:57:29 CRITICAL-Log Message&lt;br/&gt;2021-07-10 21:57:29 ERROR-Log Message&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2 Logstash 数据处理&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;本文 Logstash、Elasticsearch、Kibana 版本均为：7.12.0。&lt;/p&gt;&lt;p&gt;Logstash 三段论核心：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Input：输入&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;filter：处理（最最核心）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Output：输出&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;结合本文日志场景：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;input{&lt;br/&gt; file{&lt;br/&gt; path =&amp;gt; &lt;span&gt;&quot;/home/elasticsearch/logstash-7.12.0/config/logFile.txt&quot;&lt;/span&gt;&lt;br/&gt; start_position =&amp;gt; &lt;span&gt;&quot;beginning&quot;&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;filter&lt;br/&gt;{&lt;br/&gt; grok{&lt;br/&gt; match =&amp;gt; {&lt;span&gt;&quot;message&quot;&lt;/span&gt; =&amp;gt; &lt;span&gt;&quot;%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:log-level}-%{GREEDYDATA:message}&quot;&lt;/span&gt;}&lt;br/&gt; }&lt;br/&gt;    date {&lt;br/&gt;    match =&amp;gt; [&lt;span&gt;&quot;timestamp&quot;&lt;/span&gt;, &lt;span&gt;&quot;ISO8601&quot;&lt;/span&gt;]&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;output{&lt;br/&gt; elasticsearch{&lt;br/&gt; hosts =&amp;gt; [&lt;span&gt;&quot;172.21.0.14:19022&quot;&lt;/span&gt;]&lt;br/&gt; index =&amp;gt; &lt;span&gt;&quot;my_log_index&quot;&lt;/span&gt;}&lt;br/&gt;stdout{codec =&amp;gt; rubydebug}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;input、output 基本结合字段含义都能看懂。&lt;/p&gt;&lt;p&gt;就中间部分的 grok、date 处理感觉有点云里雾里，我们下一小节拆解讲解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.3 数据同步到 Elasticsearch&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Logstash 中的 output 环节已经设置输出的索引名称：my_log_index。&lt;/p&gt;&lt;p&gt;同步执行只需要在 logstash 路径下执行如下命令即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;./bin/logstash -f ./config/logs.conf&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行成功截图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3554817275747508&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9bYomlNsZvwicIhGYKWyIpviccenqicCN5AdBml2Bzg3UQPZVibCIUibMicPYy043xEibDuSRgCMNIngO3eg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1806&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;导入 Elasticsearch 数据如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3794498381877023&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9bYomlNsZvwicIhGYKWyIpvicqsGtQYzyRcDJ0Q4s2o2tLF2KvQGb2y8pRLktVKHkjNCfPp0l1QWQvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1236&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;{&lt;br/&gt;        &lt;span&gt;&quot;_index&quot;&lt;/span&gt; : &lt;span&gt;&quot;my_log_index&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;_type&quot;&lt;/span&gt; : &lt;span&gt;&quot;_doc&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;_id&quot;&lt;/span&gt; : &lt;span&gt;&quot;FQ_QkHoBnDDRiRgWByxG&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;_score&quot;&lt;/span&gt; : 1.0,&lt;br/&gt;        &lt;span&gt;&quot;_source&quot;&lt;/span&gt; : {&lt;br/&gt;          &lt;span&gt;&quot;path&quot;&lt;/span&gt; : &lt;span&gt;&quot;/home/elasticsearch/logstash-7.12.0/config/logFile.txt&quot;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;&quot;timestamp&quot;&lt;/span&gt; : &lt;span&gt;&quot;2021-07-10 21:57:29&quot;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;&quot;@version&quot;&lt;/span&gt; : &lt;span&gt;&quot;1&quot;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;&quot;tags&quot;&lt;/span&gt; : [&lt;br/&gt;            &lt;span&gt;&quot;_dateparsefailure&quot;&lt;/span&gt;&lt;br/&gt;          ],&lt;br/&gt;          &lt;span&gt;&quot;host&quot;&lt;/span&gt; : &lt;span&gt;&quot;VM-0-14-centos&quot;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;&quot;message&quot;&lt;/span&gt; : [&lt;br/&gt;            &lt;span&gt;&quot;2021-07-10 21:57:29 ERROR-Log Message&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;Log Message&quot;&lt;/span&gt;&lt;br/&gt;          ],&lt;br/&gt;          &lt;span&gt;&quot;@timestamp&quot;&lt;/span&gt; : &lt;span&gt;&quot;2021-07-10T14:26:29.448Z&quot;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;&quot;log-level&quot;&lt;/span&gt; : &lt;span&gt;&quot;ERROR&quot;&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;      },&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.4 Kibana 可视化分析&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Kibana 可视化分析就是基于日期维度的数据源做分析。&lt;/p&gt;&lt;p&gt;核心步骤如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4340118187787262&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9bYomlNsZvwicIhGYKWyIpvicMXZfUq3NaAqj8egQnicy3pmxHicmkdwd9IOnWGygiaicibRbK1nqwrpXxQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1523&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23774765380604795&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9bYomlNsZvwicIhGYKWyIpvic540cuAGr7NHgulEaZn17ZYY2b00ucUNylKiaXVmtziaVVoLzewC9GD9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1918&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上三个环节都“中规中矩”、几乎没有坑，不再拆解解读，有问题可以留言讨论。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、filter 环节核心原理解读&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;filter 中间处理环节用到了两个核心插件：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;3.19672131147541&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9bYomlNsZvwicIhGYKWyIpvicIpDLibTEnXHyibbkL8UHBLZFoxicgZcVHTol2WqJTdaRvPK12NLDZBFkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;244&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 插件一：date 插件&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.1 date 插件定义&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;date 插件也可以称为：日期过滤器。&lt;/p&gt;&lt;p&gt;用途：用于解析字段中的日期，然后使用该日期或时间戳作为事件的日志记录时间戳。&lt;/p&gt;&lt;p&gt;如下代码代表将：timestamp 字段转换成 ISO8601 数据类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; date {&lt;br/&gt;    match =&amp;gt; [&lt;span&gt;&quot;timestamp&quot;&lt;/span&gt;, &lt;span&gt;&quot;ISO8601&quot;&lt;/span&gt;]&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.2 date 插件适用场景&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;日期或时间戳类型转换。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.3 date 插件核心参数解读&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;ISO8601 的本质含义：将日期字段解析为 “2011-04-19T03:44:01.103Z“ 类型。&lt;/p&gt;&lt;p&gt;还有其他类型，诸如：UNIX、UNIX_MS、TAI64N 等。&lt;/p&gt;&lt;p&gt;详细解释参考官方文档：&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.elastic.co/guide/en/logstash/current/plugins-filters-date.html&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 插件二：grok 插件&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.1 grok 插件定义&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;将非结构化日志数据解析为结构化和可查询的日志。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.2 grok 插件适用场景&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;适合 syslog 日志、apache 日志和其他网络服务器日志、mysql 日志，以及通常为人类而非计算机使用编写的任何日志格式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.3 grok 插件附带的 120 + 匹配模式&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;第一次看 filter 处理环节，不理解：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;%{TIMESTAMP_ISO8601:timestamp}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类似语法的含义。&lt;/p&gt;&lt;p&gt;实际上：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;TIMESTAMP_ISO8601 就是匹配模式；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;timestamp 解析后存储 TIMESTAMP_ISO8601 格式数据的变量，且该变量会作为 elasticsearch Mapping 中的一个字段。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;匹配模式的本质其实是：正则表达式。&lt;/p&gt;&lt;p&gt;120 + 匹配模式对应的官方文档：&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://github.com/logstash-plugins/logstash-patterns-core/tree/master/patterns&lt;/span&gt;&lt;/p&gt;&lt;p&gt;本文用到的匹配模式对应的正则表达式如下：&lt;/p&gt;&lt;p&gt;字段说明：&lt;/p&gt;&lt;p&gt;第一列：匹配类型名称。&lt;/p&gt;&lt;p&gt;第二列：匹配的正则表达式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;TIMESTAMP_ISO8601  %{YEAR}-%{MONTHNUM}-%{MONTHDAY}[T ]%{HOUR}:?%{MINUTE}(?::?%{SECOND})?%{ISO8601_TIMEZONE}?&lt;br/&gt;&lt;br/&gt;LOGLEVEL ([Aa]lert|ALERT|[Tt]race|TRACE|[Dd]ebug|DEBUG|[Nn]otice|NOTICE|[Ii]nfo?(?:rmation)?|INFO?(?:RMATION)?|[Ww]arn?(?:ing)?|WARN?(?:ING)?|[Ee]rr?(?:or)?|ERR?(?:OR)?|[Cc]rit?(?:ical)?|CRIT?(?:ICAL)?|[Ff]atal|FATAL|[Ss]evere|SEVERE|EMERG(?:ENCY)?|[Ee]merg(?:ency)?)&lt;br/&gt;&lt;br/&gt;GREEDYDATA .*&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码面前，了无秘密。&lt;/p&gt;&lt;p&gt;所以，再回头看 filter 语法会很通透。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.4 grok 插件测试工具&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;为了更方便我们的提前测试，官方也提供了匹配工具，&lt;/p&gt;&lt;p&gt;工具一：一个网站 http://grokdebug.herokuapp.com/。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6639260020554985&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9bYomlNsZvwicIhGYKWyIpvic4JvMPMubDR3LrXf973BSXYqVeNJLczqRajUZojtc1PgQqmyXOknMUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;973&quot;/&gt;&lt;/figure&gt;&lt;p&gt;工具二：kibana 自带 Grok Debugger 工具。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9323308270676691&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9bYomlNsZvwicIhGYKWyIpvicfs74HS4CCuO528NN82lS8icB5Q2YKo6icekqXmxOcdZibiaEqicKerR1I9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;665&quot;/&gt;&lt;/figure&gt;&lt;p&gt;显然，Kibana 自带 Grok Debugger 更为清爽。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、小结&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;日志实时分析是 ELK 组件的核心业务场景之一，而核心中的核心是 Logstash 中间处理 filter 环节。&lt;/p&gt;&lt;p&gt;掌握了 filter 环节，就掌握了 ELK 实时日志分析的精髓。&lt;/p&gt;&lt;p&gt;欢迎大家留言讨论自己的 ELK 实战遇到的问题。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://www.elastic.co/guide/en/logstash/current/filter-plugins.html&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://medium.com/free-code-camp/how-to-use-elasticsearch-logstash-and-kibana-to-visualise-logs-in-python-in-realtime-acaab281c9de&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>27ddc9140fc1efddb2f5c4e7849217b8</guid>
<title>今天不聊技术，来聊聊 “同理心”</title>
<link>https://toutiao.io/k/wnwqpcj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>