<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f1a565a5213d786b131dcdcd0af16b64</guid>
<title>加密技术的未来：从服务端密码存储到用户数据加密方案</title>
<link>https://toutiao.io/k/lq6l2fa</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;经作者授权转载，&lt;a href=&quot;https://markdowner.net/article/158265681589440512&quot;&gt;原文链接&lt;/a&gt;，作者：&lt;a href=&quot;https://markdowner.net/u/129319864136368128&quot;&gt;Roronoa Zoro&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文主要讲常见场景的数据加密方案，以及对未来加密技术的展望，先看几条新闻：&lt;/p&gt;

&lt;p&gt;Facebook 明文存储用户密码：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Hundreds of millions of Facebook users had their account passwords stored in plain text and searchable by thousands of Facebook employees — in some cases going back to 2012, KrebsOnSecurity has learned. Facebook says an ongoing investigation has so far found no indication that employees have abused access to this data.&lt;/p&gt;

&lt;p&gt;早在 2012 年，Facebook 明文存储数亿用户的账户密码，成千上万的 Facebook 的员工可以随意进行搜索......&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;https://krebsonsecurity.com/tag/plaintext-passwords/&quot;&gt;Facebook Stored Hundreds of Millions of User Passwords in Plain Text for Years&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;CSDN 600万用户账号密码泄露：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;北京时间12月21日晚间消息，中国开发者技术在线社区CSDN今晚发表声明，就“600万用户账号密码泄露”一事公开道歉，承认部分用户账号面临风险，将临时关闭用户登录，并要求“2009年4月以前注册的帐号，且2010年9月之后没有修改过密码”的用户立即修改密码。&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;https://tech.qq.com/a/20111221/000485.htm&quot;&gt;CSDN详解600万用户密码泄露始末：暂关闭登录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;为什么不能明文存储密码&lt;/h2&gt;

&lt;p&gt;很多新手程序员都是这样存储密码的：&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;username&lt;/th&gt;
&lt;th&gt;phone&lt;/th&gt;
&lt;th&gt;password&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;小明&lt;/td&gt;
&lt;td&gt;18888888888&lt;/td&gt;
&lt;td&gt;asd123456&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;大明&lt;/td&gt;
&lt;td&gt;17777777777&lt;/td&gt;
&lt;td&gt;123abc!@#&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;为什么这样做是不安全的？&lt;/p&gt;

&lt;p&gt;首先，如果遇到数据泄露事件，明文密码直接将用户隐私暴露在空中，任何人可以登陆暴露密码的账号，随意更改。其次，即使不会泄露，内部员工也可以轻易访问用户的明文密码，当公司上了规模，你无法保证公司内部没有坏人，他们是否会搜索某些用户的密码，侵犯用户隐私。所以明文存储密码是绝对不安全的。&lt;/p&gt;

&lt;p&gt;即使你用了这样的密码：ppnn13%dkstFeb.1st（娉娉袅袅十三余，豆蔻梢头二月初），明文存储，安全性也是木有的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;再复杂的密码， 也敌不过CSDN的明文&lt;/p&gt;

&lt;p&gt;来自知乎用户：&lt;a href=&quot;https://www.zhihu.com/people/softwaring&quot;&gt;Right Here&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;题外话：&lt;a href=&quot;https://www.zhihu.com/question/21460228&quot;&gt;历史上最有名的电脑密码是什么？&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;密码&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;FLZX3000cY4yhx9day&lt;/td&gt;
&lt;td&gt;飞流直下三千尺，疑似银河下九天&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hanshansi.location()!∈[gusucity]&lt;/td&gt;
&lt;td&gt;姑苏城外寒山寺&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hold?fish:palm&lt;/td&gt;
&lt;td&gt;鱼和熊掌不可兼得&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tree_0f0=sprintf(&quot;2_Bird_ff0/a&quot;)&lt;/td&gt;
&lt;td&gt;两个黄鹂鸣翠柳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;csbt34.ydhl12s&lt;/td&gt;
&lt;td&gt;池上碧苔三四点，叶底黄鹂一两声&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;for_\$n(@ RenSheng)_\$n+=&quot;die&quot;&lt;/td&gt;
&lt;td&gt;人生自古谁无死&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;while(1)Ape1Cry&amp;amp;&amp;amp;Ape2Cry&lt;/td&gt;
&lt;td&gt;两岸猿声啼不住&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;doWhile(1){LeavesFly();YangtzeRiverFlows()};&lt;/td&gt;
&lt;td&gt;无边落木萧萧下，不尽长江滚滚来&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dig?F*ckDang5&lt;/td&gt;
&lt;td&gt;锄禾日当午&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h2&gt;如何存储 &amp;amp; 检查密码&lt;/h2&gt;

&lt;p&gt;既然密码不能明文存储，那怎么存储才是安全的？我如何检查用户输入的密码是正确的？&lt;/p&gt;

&lt;p&gt;存储相关信息用于校验是必须的，有没有一种机制能够只保存密码的部分信息，也能用于密码校验？这样即使数据库泄露，攻击者也无法通过这些信息反推用户的密码，进而保护用户账号安全。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8&quot;&gt;哈希函数&lt;/a&gt;（hash function）可以解决这个问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://content.markdowner.net/pub/3e6Wnp-038oQV9&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;哈希函数是单向不可逆的，从上图很好理解，经过 hash 函数都会被丢弃一部分信息，就如同这个算法：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;算法：存储用户名时丢弃用户姓氏然后随机打乱顺序，输入赵日天，输出天日。&lt;/p&gt;

&lt;p&gt;即使知道这个算法和天日这个数据，也无法推断出赵日天这个名字，因为部分信息丢失了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;$$
h = hash(p)
$$&lt;/p&gt;

&lt;p&gt;h 为最终存储到数据库的值，p 为用户原始密码，在用户登陆时，输入密码 p1，我们通过计算 $h_1 = hash(p_1)$，判断 h1 是否与数据库中的记录 h 相同，确定用户输入的密码是否正确。&lt;/p&gt;

&lt;p&gt;所有哈希函数都有一个性质：如果两个 h 值是不一致的，那么输入 p 值也不一样（单向散列函数），但另一方面输入和输出并非一一对应的关系，比如存在不同的 h 值，使得经过 hash 函数计算后的 p 值是一样的。&lt;/p&gt;

&lt;h2&gt;哈希函数就安全了吗？&lt;/h2&gt;

&lt;p&gt;没有，由于上述哈希函数的性质，如果两个用户都用了123456abc，这样的密码，那么数据库存储的 h 值都是一样的，而且不同密码可能计算出来的 h 值是一样的（碰撞攻击），那么攻击者就可以根据 hash 函数，暴力计算所有可能性，做成一张表格，这样拿到 h 值的时候就可以推断出密码是 123456abc 了。这种做法叫&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E5%BD%A9%E8%99%B9%E8%A1%A8#:%7E:text=%E5%BD%A9%E8%99%B9%E8%A1%A8%E6%98%AF%E4%B8%80%E4%B8%AA%E7%94%A8,%E5%A6%82%E4%BF%A1%E7%94%A8%E5%8D%A1%E3%80%81%E6%95%B0%E5%AD%97%E7%AD%89%EF%BC%89%E3%80%82&quot;&gt;彩虹表&lt;/a&gt;攻击。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://content.markdowner.net/pub/aOzpRP-zAzv85w&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;比如以前常用的哈希函数 &lt;a href=&quot;https://zh.wikipedia.org/wiki/MD5&quot;&gt;MD5&lt;/a&gt;，由于计算力逐步增强，现在已经是不安全的了：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;MD5 1996年后被证实存在弱点，可以被加以破解，对于需要高度安全性的资料，专家一般建议改用其他算法，如SHA-2。2004年，证实MD5算法无法防止碰撞攻击，因此不适用于安全性认证，如SSL公开密钥认证或是数字签名等用途&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;安全加固：加盐&lt;/h2&gt;

&lt;p&gt;对付彩虹表可以用 Sated Hash 的方式，比如对于每个用户密码存储时都记录一个随机的 salt 值（盐值），用这个盐值和密码 p，计算出 h 值：&lt;/p&gt;

&lt;p&gt;$$
h = hash(salt, p)
$$&lt;/p&gt;

&lt;p&gt;数据库同样存储了 salt 值和 h 值，这样攻击者想获取一个用户的密码，就得建立一个对应的彩虹表，增大攻击者的成本。&lt;/p&gt;

&lt;p&gt;但即使这样，使用 SHA-2 再加盐也不是安全的，因为计算力逐年提升，攻击成本下降，有财力的攻击集团还是能够建立这些彩虹表，进而窃取用户密码。&lt;/p&gt;

&lt;h2&gt;安全加固：提高计算强度&lt;/h2&gt;

&lt;p&gt;加盐的方式只是多了独立的彩虹表，如果我们可以利用硬件控制每次 hash 计算的时间比如1秒，且无论用什么机器，什么高性能的CPU计算，每次都要1秒的时间，攻击者要计算这个彩虹表，1000万个组合就得115天（hash 空间远远超过 1000万），那这种方式就很难破解了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://content.markdowner.net/pub/Pyz9VX-E6nrb6&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Bcrypt&quot;&gt;bcrypt&lt;/a&gt; 是一个由Niels Provos以及David Mazières根据Blowfish加密算法所设计的密码散列函数，于1999年在USENIX中展示[1]。实现中bcrypt会使用一个加盐的流程以防御彩虹表攻击，同时bcrypt还是适应性函数，它可以借由增加迭代之次数来抵御日益增进的电脑运算能力透过暴力法破解。&lt;/p&gt;

&lt;p&gt;除了对您的数据进行加密，默认情况下，bcrypt在删除数据之前将使用随机数据三次覆盖原始输入文件，以阻挠可能会获得您的计算机数据的人恢复数据的尝试。如果您不想使用此功能，可设置禁用此功能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;除了 bcrypt 这种调整计算强度，抵御日益增长的CPU 计算力带来攻击风险的算法，scrypt 算法还利用了内存空间，每次计算都要占用一定内容，不过 bcrypt 算法由于有成熟的实现，实际使用较多，spring boot security 的密码加密就用的这个算法。&lt;/p&gt;

&lt;p&gt;比如某个密码经过 bcrypt 加密后变成这样：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;\$2a\$07\$woshiyigesaltzhi\$\$\$\$\$.lrU488y7E1Xw.JA4uizIu.PBSSe7t4y&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2a 表示 bcrypt 算法的版本，07代表迭代次数，次数越高，每次计算所需的时间越长，后面的woshiyigesaltzhi$$$$$ 代表加密用的 salt 值，数据库可以直接存储这个字段，比如：&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;phone&lt;/th&gt;
&lt;th&gt;pwd_hash&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;小明&lt;/td&gt;
&lt;td&gt;1234&lt;/td&gt;
&lt;td&gt;\$2a\$07\$woshiyigesaltzhi\$\$\$\$\$.lrU488y7E1Xw.JA4uizIu.PBSSe7t4y&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;这种也是本文推荐的密码存储方式，hash + salt + 计算强度，可以较好保护用户密码安全，由于登陆不是频繁的操作，每次登陆时用户等待 1 秒也没有太大关系。&lt;/p&gt;

&lt;h2&gt;用户数据密码加密方案：双重 hash&lt;/h2&gt;

&lt;p&gt;密码信息可以 hash，达到不可逆的目的，但是一些用户数据是可逆的，而且要求加密，怎么办？比如用户在线文档，通过用户自定义的密码加解密。&lt;/p&gt;

&lt;p&gt;很容易想到的就是 &lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES256&lt;/a&gt; 之类的对称加密技术：&lt;/p&gt;

&lt;p&gt;$$
e = AES256(salt, text)
$$&lt;/p&gt;

&lt;p&gt;通过拿用户的密码作为 salt 值加解密文档，服务端存储用户密码。&lt;/p&gt;

&lt;p&gt;还是前面的问题，明文存储密码是不安全的行为，这里可以用双重 hash 的方法保证一定的安全性（这里的双重 hash 不是连续计算两次 hash 的意思）：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现方案&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;用户密码存储仍然采用前面提到的方案，可以用 bcrypt 算法，这里记存储的值为 h1，当用户请求加密数据时，提供了加密密码，我们通过 h1 检验用户密码的正确性，同时用用户的密码计算出另一个 hash 值，记为 h2，h2 的计算方式与 h1 不同，只是简单的 hash，不能加盐，这时我们使用 h2 加解密用户文档：&lt;/p&gt;

&lt;p&gt;$$
e = AES256(h2, text)
$$&lt;/p&gt;

&lt;p&gt;记住，h2 的值是不能存储的（不能保存于数据库中），用于加解密数据。由于 h2 的值用完就丢掉。h2 的 hash 函数可以是私有的，进一步保障安全性。&lt;/p&gt;

&lt;p&gt;为什么需要 h2 这个参数？首先用户密码长度不一致，像 AES 之类的对称加密算法需要有一个固定长度的加密参数，其次经过 hash 之后能够进一步保障数据安全性，如果数据库泄露，攻击者即使知道用户密码，不知道私有 hash 函数也无法进行解密。&lt;/p&gt;

&lt;h2&gt;其他用户数据的加密&lt;/h2&gt;

&lt;p&gt;上述提到的加密方案是用户密码控制的，数据安全性非常高（只有用户知道密码，且密码丢失后数据不可恢复），但是这种做法很多场景不适合，比如常规的用户数据：手机号、社交账号、地址、姓名，高频访问的数据不适合用密码加密，效率太低，那如何保护用户这类数据的安全性呢？&lt;/p&gt;

&lt;p&gt;理解这个问题，需要知道用户数据是怎样传输的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://content.markdowner.net/pub/bWxAQB-0GogEm2&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;用户在客户端软件上产生数据（比如浏览器上），经过 https 加密传输到后端服务器，有服务端软件处理（比如 java），之后经过调用数据库接口通过数据库软件（比如 mysql）存储到存储设备中（比如硬盘）。&lt;/p&gt;

&lt;p&gt;有 4 个阶段可以进行数据加密，加密的过程越靠近用户越安全（客户端加密后面说）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;服务端软件加密：数据到达服务端后立马加密存储（内存中执行），比如 java 执行 AES256&lt;/li&gt;
&lt;li&gt;数据库软件加密：调用数据库API实现数据库加密，比如 mysql 的 AES 加密&lt;/li&gt;
&lt;li&gt;存储端落盘加密：使用硬件加密技术进行加密存储，比如云服务商提供的云盘加密功能&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;加密方式&lt;/th&gt;
&lt;th&gt;防止内部泄露&lt;/th&gt;
&lt;th&gt;防止数据库泄露&lt;/th&gt;
&lt;th&gt;防止物理机丢失泄露&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;服务端软件加密&lt;/td&gt;
&lt;td&gt;√（大部分场景）&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据库软件加密&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;存储端落盘加密&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;前两者加密方式都可以保证即使是数据库管理员也无法查看用户数据，最后一种通常意义不大，但一些国家、地区的法律要求，或者用户要求有硬盘加密措施，仍然需要使用。数据库软件加密仍然存在内部泄露的风险，比如 mysql 的 binlog，即使你使用了 AES256，数据同步时密钥也会存储在 binlog 中，存在泄露的途径。&lt;/p&gt;

&lt;p&gt;如果相关用户数据没有搜索的需求（只有常规读写需求），可以使用服务端加密或者数据库加密的手段保护用户数据。但如果相关数据需要支持搜索功能，这个问题就很棘手了。&lt;/p&gt;

&lt;h2&gt;可搜索加密技术&lt;/h2&gt;

&lt;p&gt;这篇论文 &lt;a href=&quot;https://ieeexplore.ieee.org/document/848445&quot;&gt;Practical techniques for searches on encrypted data&lt;/a&gt; 发表于 2000 年，开创了一个新的研究方向 &lt;a href=&quot;https://en.wikipedia.org/wiki/Searchable_symmetric_encryption&quot;&gt;Searchable Encryption&lt;/a&gt;，提出了第一个实用的可搜索加密方案 SWP，实现思路大概是：通过加密每个单词，然后将一个 hash 值嵌入密文中，服务器通过提取改 hash 值，检查密文中是否有类似的特殊格式，确认是否匹配搜索。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://content.markdowner.net/pub/4XN9vD-z80xbvg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上文想法很理想，但是落地时会有很多困难，比如必须使用固定大小的单词，但搜索系统最重要的就是其分词引擎，如何对多种语言进行良好的分词直接决定了搜索的效果，不少搜索系统任然采用如下结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://content.markdowner.net/pub/qbBn8O-a446qO1&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;将 mysql 的数据单向同步到 elasticsearch 中，完成相关搜索功能的支持。20 多年过去了，今天，可搜索加密技术依然无法落地使用，甚至可以这么说，如果软件商提供了搜索功能，该数据存储的时候就是没有加密的（硬盘加密对软件层不可见），已加密的数据是无法支持搜索功能的。&lt;/p&gt;

&lt;h2&gt;阴谋实现的前提&lt;/h2&gt;

&lt;p&gt;假如我是一个坏人，要实现某个阴谋，很重要的前提就是操作足够简单，知道的人足够少，当复杂度太大或者需要的人很多的时候就不可能实现这个阴谋。&lt;/p&gt;

&lt;p&gt;知道这一点我们可以很轻松地判断：“美国登月是假的”，这个阴谋猜想是错的。因为登月工程涉及的人很多、工程复杂，无法实现这个阴谋。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这个结论是下文内容的基础。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;一些软件声明的安全说的是什么？&lt;/h2&gt;

&lt;p&gt;上述提到的可搜索加密技术无法落地，一些软件厂商（包括一些大厂）提供了搜索功能，仍然声称他们对用户数据进行了加密，很安全，他们到底在说什么？&lt;/p&gt;

&lt;p&gt;第一，他们可能说的是硬盘加密，而不是软件层的加密（只能防御硬盘盗窃风险，不能防御数据泄露风险、内部风险）；第二，他们可能说的是传输过程的加密，比如 https 或私有通讯加密协议；第三，他们可能有完善内部管理流程，控制内外部风险。&lt;/p&gt;

&lt;p&gt;利用上面阴谋论的前提，只要增加一些流程，公开透明出来，提高使坏的成本，在技术不可实现的情况下，也能保障用户数据的安全，比如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据库操作日志审查：由其他人审核 DBA 数据库操作是否合规，是否偷偷查看某用户数据等&lt;/li&gt;
&lt;li&gt;多重密码：由多人掌握密码，只有统一输入密码才能解密数据，提高操作复杂度，如多人审核&lt;/li&gt;
&lt;li&gt;公开透明的流程：涉密操作流程记录，比如某某由于开发测试原因，需解密数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;拥有完善的流程也能让用户放心存储隐私数据。&lt;/p&gt;

&lt;h2&gt;加密技术的未来：不用加密&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://content.markdowner.net/pub/bWxAQB-0GogEm2&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;前面没有提到的客户端加密放这里说。加密点越靠近用户，就越安全，如果用户发出来的数据就是经过加密的（非 https 类传输加密），并且自行控制密码，这样服务提供商也无需进一步做加密处理了，标题提到的不用加密指的就是这个，服务商不用再花费大量精力、成本在数据安全上面，将数据所有权交给用户。&lt;/p&gt;

&lt;p&gt;上面客户端加密所需的一个技术就是：&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86&quot;&gt;全同态加密&lt;/a&gt;，这是密码学领域的一个重要课题，在 2009 年 9 月，IBM 的博士克雷格·金特里发表了一篇论文：&lt;a href=&quot;https://www.cs.cmu.edu/%7Eodonnell/hits09/gentry-homomorphic-encryption.pdf&quot;&gt;Fully Homomorphic Encryption Using Ideal Lattices&lt;/a&gt;，提出了一个可行方法，自此解决了密码学的一大难题。全同态加密可以简单理解如下：&lt;/p&gt;

&lt;p&gt;$$
f(data) = DE(\ f(\ E(data)\ ))
$$&lt;/p&gt;

&lt;p&gt;其中 f 是任意操作函数，E 是加密函数，DE 是解密函数，也就是说对密文的任意计算操作等同于对明文做同样的操作。&lt;/p&gt;

&lt;p&gt;这就很牛逼了！！！！！！！！！！！比如我手上有一些财务数据，需要第三方机构进行统计分析，但是我又不想直接给他们数据，他们告诉我可以提供全同态加密服务，那么我可以在给他们数据之前将数据加密一遍，他们给我统计计算后的结果，我解密相关结果即可，真实的数据只有我看得到。&lt;/p&gt;

&lt;p&gt;全同态加密的这些特性能够很好解决数据安全，信任的问题，克雷格·金特里给出了一个实现，之后很多密码学者也给出其他实现方法，但目前的角度来说该技术还不成熟，比如一个密钥就得 100 MB 大小，对于当下网络环境来说无法实际使用。&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;没有绝对的安全，只有相对的安全。期待全同态加密技术在商用领域取得突破性进展。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>425cd80fde4b41a4625c13a067ce405d</guid>
<title>如何优雅的让 3 个线程打印 ABC</title>
<link>https://toutiao.io/k/j2jmmcf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;戳蓝字「TopCoder&lt;/span&gt;&lt;span&gt;」关注我们哦！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;383&quot; data-backw=&quot;575&quot; data-croporisrc=&quot;https://mp.weixin.qq.com/cgi-bin/photogalleryproxy?action=proxy&amp;amp;url=https%3A%2F%2Fpixabay.com%2Fget%2Fgc0a1ba950ed6ebdcd2e4dbccb7ae8ca0ca167841a1af3b858d40c7363c7586317c571f2b23b8aeff7a9ec5e51cfa4f57719bc7d1d872ff91e0dc708682514d6e_1280.jpg%3Fpermalink&amp;amp;supplier=4&amp;amp;from_public_pic=1&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;80.13913043478261&quot; data-cropy2=&quot;796.9391304347827&quot; data-ratio=&quot;0.56015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jOD3PUUxTibMaJCZDvsBobLRNj8RjfDiblEAVuPzrXiaSNCXgV3vDT157mx5t2ZDywDlBQnTcBbl7AeyooSSWmOAA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;让3个线程依次打印ABC，是一个常见的问题，这是阿里和华为都有考过的面试题。比如题目描述如下：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;编写一个程序，开启三个线程，这三个线程按照顺序依次打印ABC，每个字母打印10次后结束，最后结果如 ABCABCABC… 依次递推&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这是一道经典的多线程编程面试题，首先吐槽一下，这道题的需求很是奇葩，先开启多线程，然后再串行打印 ABC，这不是吃饱了撑的吗？不过既然是道面试题，就不管这些了，其目的在于考察多线程编程基础。&lt;/p&gt;&lt;p&gt;这个题目肯定是要启动3个线程的，那怎么让这3个线程“协作”按顺序打印A、B、C呢？从大的方面来讲，这种&lt;strong&gt;“协作”&lt;/strong&gt;可分为以下两种：&lt;/p&gt;&lt;h3&gt;&lt;span&gt;竞争型打印&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;多个线程竞争型打印，优势是代码简单易懂，劣势是线程争抢是CPU调度进行的，可能该某个线程打印时结果该线程迟迟未被CPU调度，结果其他线程被CPU调度到但是由于不能执行打印操作而继续争抢，造成CPU性能浪费。示例代码如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@AllArgsConstructor&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DemoTask&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 这里将lock对象换成 Lock(ReentrantLock) 进行lock/unlock也是可以的&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object lock = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX = &lt;span&gt;30&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; current = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; index;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (current &amp;lt; MAX) {&lt;br/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (lock) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; ((current &amp;lt; MAX) &amp;amp;&amp;amp; (current % &lt;span&gt;3&lt;/span&gt; == index)) {&lt;br/&gt;                    System.out.println((&lt;span&gt;char&lt;/span&gt;) (&lt;span&gt;&#x27;A&#x27;&lt;/span&gt; + current % &lt;span&gt;3&lt;/span&gt;));&lt;br/&gt;                    current++;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;Thread&amp;gt; threadList = Arrays.asList(&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; DemoTask(&lt;span&gt;0&lt;/span&gt;)),&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; DemoTask(&lt;span&gt;1&lt;/span&gt;)),&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; DemoTask(&lt;span&gt;2&lt;/span&gt;))&lt;br/&gt;        );&lt;br/&gt;&lt;br/&gt;        threadList.forEach(Thread::start);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;协同型打印&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;多个线程协同型打印，优势是各个线程使用“通知”机制进行协同分工，理论上执行效率较高，不过要使用对应的“通知”机制。关于如何“通知”，第一种是可使用Java对象的 &lt;code&gt;wait/notify&lt;/code&gt; 或者&lt;code&gt;Conditon&lt;/code&gt;对象的&lt;code&gt;await/signal&lt;/code&gt;，第二种是以事件或者提交任务的方式（比如通过提交“待打印数字”这个任务给下一个线程）。&lt;/p&gt;&lt;p&gt;第一种方式网上对应的示例代码很多，就不在赘述。下面以第二种方式进行代码分析，打印完成之后，将待打印的数据塞给下一个线程，这样下一个线程就可以打印了，代码如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ThreadTask t1 = &lt;span&gt;new&lt;/span&gt; ThreadTask();&lt;br/&gt;    ThreadTask t2 = &lt;span&gt;new&lt;/span&gt; ThreadTask();&lt;br/&gt;    ThreadTask t3 = &lt;span&gt;new&lt;/span&gt; ThreadTask();&lt;br/&gt;&lt;br/&gt;    t1.next = t2;&lt;br/&gt;    t2.next = t3;&lt;br/&gt;    t3.next = t1;&lt;br/&gt;&lt;br/&gt;    t1.start();&lt;br/&gt;    t2.start();&lt;br/&gt;    t3.start();&lt;br/&gt;&lt;br/&gt;    t1.queue.add(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadTask&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Integer END = &lt;span&gt;30&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Getter&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; BlockingQueue&amp;lt;Integer&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ThreadTask next;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@SneakyThrows&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            Integer take = queue.take();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (take &amp;gt;= END) {&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            System.out.println((&lt;span&gt;char&lt;/span&gt;) (&lt;span&gt;&#x27;A&#x27;&lt;/span&gt; + take % &lt;span&gt;3&lt;/span&gt;));&lt;br/&gt;            next.queue.put(take + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (next.isAlive()) {&lt;br/&gt;            next.queue.put(END);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码中使用&lt;code&gt;BlockingQueue&lt;/code&gt;队列，避免了 &lt;code&gt;wait/notify&lt;/code&gt; 或者&lt;code&gt; await/signal&lt;/code&gt;，也能达到通知机制。注意，Java的阻塞队列是一个支持阻塞插入和移除方法的队列，阻塞队列常用于生产者和消费者场景，生产者是向队列中添加元素的线程，消费者是从队列中获取数据的线程。&lt;/p&gt;&lt;p&gt;阻塞队列主要包括两部分内容：&lt;strong&gt;一个是存放数据的容器，另一个就是线程的管理（阻塞/唤醒），前者可以基于Array或者LinkedList数据结构，后者借助于Lock/Condition来实现&lt;/strong&gt;，也就是使用通知模式来实现的，具体可查看Lock/Condition资料。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-style-type=&quot;2&quot; data-tools=&quot;新媒体排版&quot; data-id=&quot;8633&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt; 推荐阅读 &lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>27480a8d6ea9006bb1d0938d01c4ceb6</guid>
<title>权限体系设计：网易有数 BI 功能品鉴</title>
<link>https://toutiao.io/k/nvr0l12</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;span&gt;权限体系是所有BI产品都会涉及的一个重要组成部分，目的是对不同的人访问资源&lt;/span&gt;&lt;span&gt;进行权限控制，避免因权限控制缺失或操作不当引发的风险，如隐私数据泄露等问题。&lt;/span&gt;&lt;span&gt;有数BI权限体系设计的初衷，希望它&lt;span&gt;既&lt;/span&gt;能满足实际业务中的复杂场景，又能简洁易用，今天我们将详细介绍有数BI的权限体系！&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86318&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:511&quot;&gt;角色模型&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;对于权限管理，最简单的办法就是给每个用户配不同的权限，&lt;/span&gt;&lt;span&gt;但这样的设计在用户较多时维护起来就显得非常力不从心。&lt;/span&gt;&lt;span&gt;于是很多人想到在用户和权限之间增加一个角色，也就是迄今为止最为普及的权限设计模型，即RBAC（Role Based Access Control，基于角色的权限访问控制）权限模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOXsRSvSfhZ8KdbqjPvyYqybDHvXbxdpk5SIicicmbj1hicMaApN5BWEY8avTdtDp3icQianRoTPViboqNug/0?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;699&quot; data-cropy1=&quot;59.25778546712803&quot; data-cropy2=&quot;312.0103806228374&quot; data-ratio=&quot;0.36194563662374823&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOXsRSvSfhZ8KdbqjPvyYqyb0KeLQu0JM2ia0wkz5yK5GVNfs2K7srPibN1LeQKUhgkHEq0mhqXLkg1w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;699&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;RBAC模型认为权限授权实际上是Who、What、How的问题。&lt;/span&gt;&lt;span&gt;在RBAC模型中，Who、What、How构成了访问权限三元组，也就是“Who（权限的拥用者或主体）对What（权限针对的对象或资源）进行How（具体的权限）的操作”。&lt;/span&gt;&lt;span&gt;换句话讲，在RBAC模型中，是通过控制“Who对What进行How的操作”来实现让不同的用户/用户组对不同的资源拥有不同的操作/数据权限的目的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们的权限体系即是依据RBAC模型思想所设计的，相关概念包括权限，角色和用户。角色与权限绑定，即项目中用户的权限与其被赋予的角色相关。一个用户可以拥有多个角色，一个角色也可以被添加给多个用户，每个角色可以被赋予多个权限。以下图所示的结构为例，用户1只拥有角色1的权限，即对资源1进行操作1；而由于用户3拥有3个角色全部的权限，因此该用户可以对资源1和资源2分别进行操作1和操作2。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9583333333333334&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOXsRSvSfhZ8KdbqjPvyYqybeib9BeDiaCfyfiaPmp3iadiaVH4jXke77pXKq1QwGKv7Fj06xNTU4keJevQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在，有数BI的权限&lt;span&gt;体系&lt;/span&gt;已经拥有了基础的RBAC模型思想，但还远远不够。通过市场分析，我们发现企业在使用权限&lt;span&gt;体系&lt;/span&gt;的过程中，大多绕不开三大难题：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;组织规模达到一定程度后，需要管理的资源数量庞大，同时对权限要求又很高时，需设置非常细粒度的权限，导致整个权限&lt;span&gt;体系&lt;/span&gt;显得十分零散和无序，产生大量的维护成本；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;而为了保证数据安全，这样的权限&lt;span&gt;体系&lt;/span&gt;往往是由权限最高的少数管理员来配置组织内部全体成员的权限，给管理员带来巨大的工作量；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;同时，在设置针对个人的不同数据权限时，其复杂程度更是呈几何增长，且当人员变更时，针对每个数据集需要重新配置行级权限，造成大量的权限重复配置操作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么为了解决这些难题，有数BI的权限&lt;span&gt;体系&lt;/span&gt;是如何设计的呢？接下来，本文将围绕这些难题，给出我们的解决方案！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86318&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:511&quot;&gt;资源权限&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.基于角色，统一管理&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不同于市面上其他的BI产品，有数BI中资源权限的设置和赋予完全通过角色来实现，这样的设计可以帮助用户基于角色来实现权限的统一管理，极大降低企业设置权限&lt;span&gt;体系&lt;/span&gt;的复杂程度。例如，企业内各人员的资源权限往往是根据企业组织架构来对应设置的，当组织人员变动时，在权限&lt;span&gt;体系&lt;/span&gt;中只需将该用户所拥有的角色变更为对应组织架构角色，就能一键实现资源权限的变更。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;317&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.54765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOXsRSvSfhZ8KdbqjPvyYqybUKm3NPzV2EcgN7RpgwkLHklBznSN10ia5rLUaUku6J7qH90X9Jricseg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过对资源权限和数据权限的组合设置，简单勾选即可创建角色，并将对应成员添加到该角色下面，轻松搭建灵活、简洁的权限&lt;span&gt;体系&lt;/span&gt;！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;317&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.54765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOXsRSvSfhZ8KdbqjPvyYqybERP18a1E5AWLHBF3xHpK7QIlduriaMo7Ju5m2tHqvoicFWF76OQk366w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.分级授权，灵活应用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现实场景中，当企业发展到一定程度时，往往拥有多层组织架构，而在传统的RBAC模型中，往往都只能由一个权限最高的用户（一般为管理员）来创建所有角色，对所有用户进行权限的授予，进行权限&lt;span&gt;体系&lt;/span&gt;的维护工作，这样导致管理员工作量过大。同时，企业里不同的业务线，或者不同的业务部门都有数据分析需求，如果无法将不同业务线或部门资源分隔开，将对资源的整理和权限配置带来巨大挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于上述情况，有数BI提供了“项目+二级管理员”的多项目结合分级授权体系。首先，企业可以为不同的业务部门建立不同的项目，通过“项目列表”在不同的项目前切换，项目管理员拥有该项目内所有资源的所有权限。其次，通过二级管理员的设置来实现二级授权，项目管理员可以将部分资源的授予权限赋予该二级管理员，由二级管理员来管理对应的资源。多租户结合分级授权体系可以帮助用户创建非常丰富立体的权限分配体系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体来看，有数BI将角色分成三类：系统角色、一级角色和二级角色。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;系统角色包括：项目管理员、二级管理员、编辑者、阅览者，系统角色无法编辑、修改和删除。编辑者可以查看或编辑所有的资源；阅览者仅可以查看所有资源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7741935483870968&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOXsRSvSfhZ8KdbqjPvyYqyb936mIqyiaWu1mBXmeaWCRgEB0iafOa9zlHvRtDH4F6wyIgw2iaue3H3IQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;868&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一级角色和二级角色由项目管理员和二级管理员创建，一级角色可以拥有编辑权限，二级角色只能拥有阅览权限。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86318&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:511&quot;&gt;数据权限&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.行列权限，精准定位&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据安全对于企业的重要性不言而喻。数据权限解决的便是用户能看到多少数据量和什么数据的问题。现实场景中，企业往往有大量业务数据和权限需求，在设置数据权限时，如何实现数据权限的精准定位，是有数BI在设计数据权限时所考虑的重要方面。因此，有数BI提供行和列级别的数据权限控制粒度，通过对同一张表进行行权限和列权限的配置，就可以精准实现数据权限的高效配置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设这样一个场景：小王的公司在“东北、华北、华东、华南”四个大区都有销售人员，他希望不同大区的销售访问同一张报告时候，都只能看到自己所属大区的数据，在有数BI中，用“数据行级权限”可以实现这样的需求：我们可以创建4个“数据行级权限”，每个“数据行级权限”只能访问一个大区的数据，然后给不同大区的销售人员分配对应的“数据行级权限”。如东北大区的销售人员只能看到“东北”地区的数据，我们可以建立一个“数据行级权限”，然后设置数据访问权限，只允许该角色成员访问“东北”地区的数据，然后将该“数据行级权限”赋予东北大区的销售人员即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;316&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOXsRSvSfhZ8KdbqjPvyYqybmq9gxzwLibbfiaoIdPxZ4HGK6GeAXibrdH8B1aE8hiahA38ib8ic9D8cd9fA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.属性对应，动态匹配&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用上述方法时，当我们存在多少个大区，我们就需要创建对应数量的“数据行级权限”。当组织人员规模达到一定程度后，管理复杂度往往呈几何增长，这样的设置方式必然需要大量的时间成本和人力成本来维护。同时，考虑到组织内不同人员所能拥有的数据权限往往与TA所在的部门、岗位或地区有一定的映射关系，那么，能否提供一种简便的设置路径，能够直接对不同部门的用户匹配不同的行级权限呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于此，我们在数据权限的创建页提供了固定值和属性值的配置选项，当选择属性值时，就可以通过设置属性值与对应字段的匹配，例如将“属性值-地区”与字段“地区匹配”，就能让不同地区的成员只能看到对应地区的数据，从而极大提高行级授权的管理效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 首先，企业域管理-人员信息-属性列表-设置一个属性值“地区”，在对应用户后输入东北或其他地区。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;317&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.54765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOXsRSvSfhZ8KdbqjPvyYqybzuRwR9TD143v0wLkLibD5FyTQbsZQRhFNJBGkjrHvgH9EVeMdMdGuSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 创建一个“数据行级权限”，选择要设置权限的数据连接，设置方式选择“动态值”，选择要设置权限的表跟字段，选择要匹配的用户属性，在本例中，即将“地区”字段匹配“地区”属性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOXsRSvSfhZ8KdbqjPvyYqybdLD9L5caarzsLPl0yqw8MkfVreZRicwGibUwSdLVROjBZbMHmwF7QfZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. 保存后，将该“数据行级权限”分配给所有用户，则每个用户访问报告时会根据该用户所在大区来筛选数据，只能看到自己大区的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;317&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.54765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOXsRSvSfhZ8KdbqjPvyYqyb95HX1p7eMdy10howjO3bPNsyn1icAcCrFHN5tHPBwJeibYGniarTa7cnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（未设置数据权限）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.54765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOXsRSvSfhZ8KdbqjPvyYqybtM8uvBtYoOJh9AJp3HSNAlQuVUHKA44HEU5doic2DtribaF2z54mEBfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（设置了数据权限）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86318&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:511&quot;&gt;结语&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;为了应对更多复杂各异的组织架构和管理体系，我们仍然在不停地探索之中。&lt;/span&gt;&lt;span&gt;具体来说，目前的分级授权体系仅支持对资源的分级授权，还无法做到对数据权限的&lt;/span&gt;&lt;span&gt;分级授权，我们正在积极寻找更完美的解决办法，在保持用户低使用成本和高数据安全的同时，实现更高的灵活性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;这里剧透一下，有数BI更高效、更简洁的权限&lt;span&gt;体系&lt;/span&gt;不久将会和大家见面，敬请期待！&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIwNTUxNTI1Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOV4Bfic2e5zqTMCl0XxmMuVq1XpDOBrbXicVB4KmrEXglsWcnMREoQXfX24sscdvQIR74ic3SiciaLoMFA/0?wx_fmt=png&quot; data-nickname=&quot;网易有数&quot; data-alias=&quot;Youdata_Netease&quot; data-signature=&quot;网易有数致力于帮助用户快速在业务场景中应用大数据，助力业务发展和产业升级，让数据更高效地驱动生产力。网易有数旗下包含有数BI，大数据平台，标签画像、CDP、AI机器学习平台等子产品&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/sYBGQlzfEOXECeWKgyIia3c7bom7Ir4rh4qI4XdxuRW4lyHudFyglytmLrOM4yYOWs3XNqqj0XlXTEw8icZ2Eb1Q/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;317:401&quot;&gt;分享，点赞，在看，安排一下？&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5a74641caea84680fcbcbf174e019c0b</guid>
<title>面试官常问的垃圾回收器，这次全搞懂</title>
<link>https://toutiao.io/k/7aczn5o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;本文已被Github仓库收录 https://github.com/silently9527/JavaCore&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前几天写了一篇《JVM性能调优实战：让你的IntelliJ Idea纵享丝滑》，其中有对GC垃圾回收器的选择尝试，本篇我们就来详细的看看JVM中常见的垃圾回收器有哪些以及每个垃圾回收器的特点，这也是面试的时候经常被问的内容&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JVM堆内存概览&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在聊垃圾回收器之前，我们先来看看JVM堆内存的区域划分是怎么样的，看下图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6014897579143389&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG99ka1icre2BiblNnPUq9gT24eepVu2F42L4T1Dw0X0g1BhyJv429kd2icicGohYbFdp67sOB90N6JcMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;537&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;因为虚拟机使用的垃圾回收算法是分代收集算法，所以堆内存被分为了新生代和老年代&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新生代使用的垃圾回收算法是复制算法，所以新生代又被分为了 Eden 和Survivor；空间大小比例默认为8:2&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Survivor又被分为了S0、S1，这两个的空间大小比例为1:1&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;内存分配以及垃圾回收&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对象优先在Eden区进行分配，如果Eden区满了之后会触发一次Minor GC&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Minor GC之后从Eden存活下来的对象将会被移动到S0区域，当S0内存满了之后又会被触发一次Minor GC，S0区存活下来的对象会被移动到S1区，S0区空闲；S1满了之后在Minor GC，存活下来的再次移动到S0区，S1区空闲，这样反反复复GC，每GC一次，对象的年龄就涨一岁，默认达到15岁之后就会进入老年代，对于晋身到老年代的年龄阈值可以通过参数 &lt;code&gt;-XX:MaxTenuringThreshold&lt;/code&gt;设置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在Minor GC之后需要的发送晋身到老年代的对象没有空间安置，那么就会触发Full GC (这步非绝对，视垃圾回收器决定)&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;Minor GC和Full GC的区别：Minor GC是指发生在新生代的垃圾收集行为，由于对象优先在Eden区分配，并且很多对象都是朝生夕死，所以触发的频率相对较高；由于采用的复制算法，所以一般回收速度非常快。Full GC是指发生在老年代的垃圾收集行为，Full GC的速度一般会比Minor GC慢10倍以上；所以不能让JVM频繁的发生Full GC&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了能够更好的适应不同程序的内存情况，JVM也不一定要求必须达到年龄15岁才能晋身到老年代，如果在Survivor区中相同年龄的所有对象大小总和大于Survivor区空间的一半，年龄大于或者等于这个年龄的对象将会直接进入到老年代&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Full GC触发条件&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;代码中调用&lt;code&gt;System.gc()&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老年代空间不足/满了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;持久区空间不足/满了&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;注意：大对象会直接在老年代分配内存，可以通过参数&lt;code&gt;-XX:PretenureSizeThreshold&lt;/code&gt;控制对象的大小，通常遇到的大对象是很长的字符串或者数组，如果分配了一大群大对象只是临时使用，生命很短暂，那么就会频繁的发生Full GC，但是此时的新生代的空间还有空闲；写代码的时候，这种情况应该避免，特别是在创建数组的时候要当心&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「空间担保」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在新生代发生Minor GC的时候，JVM会先检查老年代中可分配的连续空间是否大于新生代所有对象的总和，如果大于，那么本次Minor GC就可以安全的执行；如果不大于，那么JVM会先去检查参数&lt;code&gt;HandlePromotionFailure&lt;/code&gt;设置值是否允许空间担保失败，如果允许，JVM会继续检查老年代可分配的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，尽管这次Minor GC是有风险的，JVM也会尝试一次Minor GC；如果不允许担保失败，那么JVM直接进行Full GC&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然担保有可能会失败，导致饶一圈才能进行GC，但是还是建议把这个参数打开，可以避免JVM频繁的Full GC&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;垃圾回收器概览&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5329949238578681&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG99ka1icre2BiblNnPUq9gT24RYvGjKfmUFaiaePn6p1vcODtj7tmylHIORA6ZHe9rhCMzjVu8VAvkaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;591&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图可以看出：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;新生代可以使用的垃圾回收器：Serial、ParNew、Parallel Scavenge&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老年代可以适用的垃圾回收器：CMS、Serial Old、Parallel Old&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;G1回收器适用于新生代和老年代&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;相互之间有连线的表示可以配合使用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;CMS和Serial Old同为老年代回收器，为何相互会有连线呢？&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG99ka1icre2BiblNnPUq9gT24d2b0IWj0E09ekurvzPLOdXCMfsibk2TAhYpE1mG1T6iaIyjvNVWqU72w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;255&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Serial收集器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是个单线程收集器，发展历史最悠久的收集器，当它在进行垃圾收集工作的时候，其他线程都必须暂停直到垃圾收集结束（Stop The World）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然Serial收集器存在Stop The World的问题，但是在并行能力较弱的单CPU环境下往往表现优于其他收集器；因为它简单而高效，没有多余的线程交互开销；Serial对于运行在Client模式下的虚拟机来说是个很好的选择&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;-XX:+UseSerialGC&lt;/code&gt;参数可以设置新生代使用这个Serial收集器&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ParNew收集器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ParNew收集器是Serial收集器的多线程版本；除了使用了多线程进行垃圾收集以外，其他的都和Serial一致；它默认开始的线程数与CPU的核数相同，可以通过参数&lt;code&gt;-XX:ParallelGCThreads&lt;/code&gt;来设置线程数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的图可以看出，能够与CMS配合使用的收集器，除了Serial以外，就只剩下ParNew，所以ParNew通常是运行在Server模式下的首选新生代垃圾收集器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;-XX:+UseParNewGC&lt;/code&gt;参数可以设置新生代使用这个并行回收器&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Parallel Scavenge收集器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Scavenge收集器依然是个采用复制算法的多线程新生代收集器，它与其他的收集器的不同之处在于它主要关心的是吞吐量，而其他的收集器关注的是尽可能的减少用户线程的等待时间（缩短Stop The World的时间）。吞吐量=用户线程执行时间/(用户线程执行时间+垃圾收集时间)，虚拟机总共运行100分钟，其中垃圾收集花费时间1分钟，那么吞吐量就是 99%&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「停顿时间越短适合需要和用户进行交互的程序，良好的响应能够提升用户的体验。而高效的吞吐量可以充分的利用CPU时间，尽快的完成计算任务，所以Parallel Scavenge收集器适用于后台计算型任务程序。」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;-XX:MaxGCPauseMillis&lt;/code&gt;可以控制垃圾收集的最大暂停时间，需要注意不要以为把这个时间设置的很小就可以减少垃圾收集暂用的时间，这可能会导致发生频繁的GC，反而降低了吞吐量&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;-XX:GCTimeRatio&lt;/code&gt;设置吞吐量大小，参数是取值范围0-100的整数，也就是垃圾收集占用的时间，默认是99，那么垃圾收集占用的最大时间 1%&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;-XX:+UseAdaptiveSizePolicy&lt;/code&gt; 如果打开这个参数，就不需要用户手动的控制新生代大小，晋升老年代年龄等参数，JVM会开启GC自适应调节策略&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Serial Old收集器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Serial Old收集器也是个单线程收集器，适用于老年代，使用的是标记-整理算法，可以配合Serial收集器在Client模式下使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它可以作为CMS收集器的后备预案，如果CMS出现Concurrent Mode Failure，则SerialOld将作为后备收集器。（后面CMS详细说明）&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Parallel Old收集器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Old收集器可以配合Parallel Scavenge收集器一起使用达到“吞吐量优先”，它主要是针对老年代的收集器，使用的是标记-整理算法。在注重吞吐量的任务中可以优先考虑使用这个组合&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;-XX:+UseParallelOldGc&lt;/code&gt;设置老年代使用该回收器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;XX:+ParallelGCThreads&lt;/code&gt;设置垃圾收集时的线程数量。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CMS收集器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CMS收集器是一种以获取最短回收停顿时间为目标的收集器，在互联网网站、B/S架构的中常用的收集器就是CMS，因为系统停顿的时间最短，给用户带来较好的体验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;-XX:+UseConcMarkSweepGC&lt;/code&gt;设置老年代使用该回收器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;-XX:ConcGCThreads&lt;/code&gt;设置并发线程数量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CMS采用的是标记-清除算法，主要分为了4个步骤：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始化标记和重新标记这两个步骤依然会发生Stop The World，初始化标记只是标记GC Root能够直接关联到的对象，速度较快，并发标记能够和用户线程并发执行；重新标记是为了修正在并发标记的过程中用户线程产生的垃圾，这个时间比初始化标记稍长，比并发标记短很多。整个过程请看下图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3314366998577525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG99ka1icre2BiblNnPUq9gT24KRuM9B5x2hEpLCZvwFHZiceWAxj2xHaibxEQzxG87hjO0P6ibHEBVGcqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;703&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「优点」&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CMS是一款优秀的收集器，它的主要优点：并发收集、低停顿，因此CMS收集器也被称为并发低停顿收集器（Concurrent Low Pause Collector）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「缺点」&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个时（比如2个），CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;无法处理浮动垃圾。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就被称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，回收阀值可以通过参数&lt;code&gt;-XX:CMSInitiatingoccupancyFraction&lt;/code&gt;来设置；如果回收阀值设置的太大，在CMS运行期间如果分配大的对象找不到足够的空间就会出现“Concurrent Mode Failure”失败，这时候会临时启动SerialOld GC来重新进行老年代的收集，这样的话停顿的时间就会加长。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;标记-清除算法导致的空间碎片 CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象。为了解决这个问题CMS提供了一个参数&lt;code&gt;-XX:+UseCMSCompactAtFullCollecion&lt;/code&gt;，如果启用，在Full GC的时候开启内存碎片整理合并过程，由于内存碎片整理的过程无法并行执行，所以停顿的时间会加长。考虑到每次FullGC都要进行内存碎片合并不是很合适，所以CMS又提供了另一个参数&lt;code&gt;-XX:CMSFullGCsBeforeCompaction&lt;/code&gt;来控制执行多少次不带碎片整理的FullGC之后，来一次带碎片整理GC&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;G1收集器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1是一款面向服务端应用的垃圾回收器。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;并行与并发：与CMS类似，充分里用多核CPU的优势，G1仍然可以不暂停用户线程执行垃圾收集工作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分代收集：分代的概念依然在G1保留，当时它不需要和其他垃圾收集器配合使用，可以独立管理整个堆内存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;空间的整合：G1整体上采用的是标记-整理算法，从局部（Region）采用的是复制算法，这两种算法都意味着G1不需要进行内存碎片整理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可预测的停顿：能够让用户指定在时间片段内，消耗在垃圾收集的时间不超过多长时间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Region&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然在G1中依然保留了新生代和老年代的概念，但是采用的是一种完全不同的方式来组织堆内存，它把整个堆内存分割成了很多大小相同的区域（Region），并且新生代和老年代在物理上也不是连续的内存区域，请看下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3883333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG99ka1icre2BiblNnPUq9gT24cgaAVMOf1JWIiaiaNpwicea90KmQ3sywHiaNnyicl0QquoyywqrlMectKsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个Region被标记了E、S、O和H，其中H是以往算法中没有的，它代表Humongous，这表示这些Region存储的是巨型对象，当新建对象大小超过Region大小一半时，直接在新的一个或多个连续Region中分配，并标记为H。Region区域的内存大小可以通过&lt;code&gt;-XX:G1HeapRegionSize&lt;/code&gt;参数指定，大小区间只能是2的幂次方，如：1M、2M、4M、8M&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;G1的GC模式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;新生代GC：与其他新生代收集器类似，对象优先在eden region分配，如果eden region内存不足就会触发新生代的GC，把存活的对象安置在survivor region，或者晋升到old region&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;混合GC：当越来越多的对象晋升到了old region，当老年代的内存使用率达到某个阈值就会触发混合GC，可以通过参数&lt;code&gt;-XX:InitiatingHeapOccupancyPercent&lt;/code&gt;设置阈值百分比，此参数与CMS中&lt;code&gt;-XX:CMSInitiatingoccupancyFraction&lt;/code&gt;的功能类似；混合GC会回收新生代和&lt;strong&gt;「部分老年代内存」&lt;/strong&gt;，注意是部分老年代而不是全部老年代；G1会跟踪每个Region中的垃圾回收价值，在用户指定的垃圾收集时间内优先回收价值最大的region&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Full GC：如果对象内存分配速度过快，混合GC还未回收完成，导致老年代被填满，就会触发一次full gc，G1的full gc算法就是单线程执行的serial old gc，此过程与CMS类似，会导致异常长时间的暂停时间，尽可能的避免full gc.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;写到最后（点关注，不迷路）&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文中或许会存在或多或少的不足、错误之处，有建议或者意见也非常欢迎大家在评论交流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，请朋友们&lt;strong&gt;「不要白嫖我哟」&lt;/strong&gt;，希望朋友们可以&lt;strong&gt;「点赞」&lt;/strong&gt;，因为这些就是我分享的全部动力来源🙏&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8764044943820225&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ggRgNal7zG99ka1icre2BiblNnPUq9gT24qV5GzhtC3trlvOoZcoziatw7nssiaSU22QrTxdyFW73GC41ttg9ndegg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;267&quot;/&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/figure&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2e7871aa00c0c7545543a99d833f6de9</guid>
<title>数仓已死？数据湖当立</title>
<link>https://toutiao.io/k/tpejrbn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIwNjM0MTc0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/7VHriaQOsnjnicZ3bhN7MiagiakU9nmdqQ7W5XpwOG1UnOTHiahCaDQJlNuGCTtTzKauXN0CJIKibdKrZaAQLN602aDA/0?wx_fmt=png&quot; data-nickname=&quot;大数据架构师&quot; data-alias=&quot;bigdata_arch&quot; data-signature=&quot;历任多家公司大数据总监、大数据架构师，专注于数字化转型领域。公众号分享大量干货，包括数字化转型方案、数字化转型案例、数字化转型方向，以及大数据技术细节、大数据架构设计、大数据架构方案、数据仓库、数据分析技巧。有数字化转型和大数据架构社群&quot;/&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;前两天，&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;我详细剖析了一下这两天脉脉上很火的数据建模帖子。指出来帖子里百度小哥“只见宽表不见建模&lt;span&gt;”的核心原因是整个数据圈的核心逻辑变了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;然后就引起了建模群里一帮人在疯狂吐槽。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.30456852791878175&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7VHriaQOsnjkpFgHko6JxQGWLOIIKKeG0lEblOSMVwYUUT4X1ZgPwH9ickH7ric4KEic3F2DrN0Hjz3LTibQuODkGtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;394&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.22278481012658227&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7VHriaQOsnjkpFgHko6JxQGWLOIIKKeG0oibCcrlcNkG2nXPIZSVbjBJibdGZwkFkSLeEHDhFTNN7vq8usxeX5AZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;395&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也有大厂的数仓大佬高屋建瓴，指点江山，侃侃而谈。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2631578947368421&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7VHriaQOsnjkpFgHko6JxQGWLOIIKKeG0M7s8qqnQ34x5GvfYia9ADm7LTviccQb3wp10YeHCWibupRnGZgdLBK5Dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为啥吐槽？因为我们知道，这再也不是以前数据至上、工程为先的俄罗斯方块游戏了，而是客户至上、业务为先的神庙逃亡游戏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是绝大多数企业的数据仓库工程师，究竟还是沦落到拉宽表的境地。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大清都亡了，你上哪找辫子去啊？&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;玩法变了&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;早些年&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;业务变化还没那么频繁，战略是一年定一次，KPI 政策是一年发布一次。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们有充足的时间去规划、业务建模、领域建模、逻辑建模、物理建模、验证模型。如同那时候的爱情，车马慢，一生只够爱一人。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/7VHriaQOsnjkpFgHko6JxQGWLOIIKKeG0UVpBjO70xGHxjpj536Sk9gdMRprd53HPRG0fDj5ADticjBthkQXbufQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那时候行业的玩&lt;/span&gt;&lt;span&gt;法基本一致，所以也有了 FSLDM 这种经典数据模型可以套用。&lt;/span&gt;&lt;span&gt;一个模型搞定一个行业有没有？&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是现在，谁家的玩法跟别人一毛一样？没有！就算是短视频界的两个直接竞争对手--抖音和快手，都是那么迥然不同的逻辑：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个偏向算法推荐，一个偏向社交关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更不用说现在火热的社区团购，都在抢占市场，业务模式每天都在变。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我自己都不敢相信，我会建设一个能够支持 KPI 政策一个月一调整的 KPI 数仓+核算体系！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;玩法真的变了！这世道变了！&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;建模变了&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;在这种边开飞机边换发动机的时代，传统数仓规规矩矩建设的逻辑就不好使了，开始朝着非常诡异的方向发展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;一个方向&lt;/strong&gt;&lt;/span&gt;，是规模大、技术强、业务趋于稳定的企业，如阿里、美团的固有业务，他们开始尝试一种全新的建模理念。&lt;/p&gt;&lt;p&gt;他们的主题域划分根本不遵循老一套的“中性、通用”，而是“&lt;strong&gt;&lt;span&gt;个性、专用&lt;/span&gt;&lt;/strong&gt;”。所以他们采用的是按业务流程划分主题域，因为这样才能更方便的支撑上面的业务指标体系。这样弄，上哪提炼一个通用的模型去啊？&lt;/p&gt;&lt;p&gt;在建模的时候，传统建模，DWD 层必须是范式建模，而且一般不对外提供服务。如果各部门需要明细数据，则各自建立 DM 解决。&lt;/p&gt;&lt;p&gt;&lt;span&gt;而现在这些大厂的建模方式，则是尽可能压缩范式建模的范围，扩大维度建模的深度。以结构化指标体系开道，用维度模型向下不断穿透，直到 DWD 层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;是的，DWD 层也是维度建模。所有 ID 统一、代码转换、数据打平的事情放在哪里做？ETL 里做。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;哦，不！应该改叫 ELT 了。先 Load ，再 T&lt;/span&gt;&lt;span&gt;ransformation 。因为超大量的数据输入，我们必须首先解决数据吞吐量的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;另一个方向&lt;/span&gt;&lt;/strong&gt;，是那些创业公司或者大公司的新业务。这类场景的特点是业务一直在变，产品功能也在变，业务数据库也在变。&lt;/p&gt;&lt;p&gt;在这种场景中传统数据仓库建设的逻辑完全失效。因为根本不可能有人能在这么短的时间内，设计出一个能适应 &lt;span&gt;2 周一次的迭代速度的数据仓库模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;所以他们选择了简单粗暴的拉宽表！&lt;/p&gt;&lt;p&gt;这就是脉脉上百度小哥疯狂吐槽的根本原因。不是不去建模，而是根本&lt;strong&gt;&lt;span&gt;没时间、没条件给你建模&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;数仓已死？&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;那种业务趋于稳定的大厂毕竟是少数，更多的情况是创业公司、业务不断试错、调整的小厂。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在业务 1 个月变一次方向、产品 2 周迭代一次、业务数据库不断更新还没人告诉你的地狱模式下，基本上宣告了数据仓库的死亡！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这就像是在玩游戏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以前是玩俄罗斯方块，我们得精心设计好，每一块砖都要放在合理的地方，垒的整整齐齐，等待那一根棍子的到来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;而现在，是在玩神庙逃亡，操作方式同样都是上下左右，但是你根本没办法想合理、结构、布局，稍微迟疑一些，就被怪兽咬到屁股了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;而对于那些业务日趋稳定的大厂，数据仓库同样也有巨大的困扰。就像新能源汽车车主总有里程焦虑一样，几乎所有的离线数仓工程师都害怕任务失败。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;任务失败就意味着报表出不来，就意味着运营的白眼和扣绩效。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;另外，我们的增量入库方案，由于数据迟到、业务逻辑复杂等各种原因，慢慢的变得越来越复杂。以至于一些小公司干脆直接每天全量，这导致数据延迟更加严重。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;貌似一切正常的离线数仓 T+1 延迟，成为压死数仓的最后一根稻草。因为业务部门已经不能满足于看昨天的数据了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“我们并没有做错什么,但不知为什么,我们输了”，诺基亚 CEO 的声音仿佛萦绕耳边。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么？你说 Lambda 架构可以满足？是，这样是能&lt;/span&gt;&lt;span&gt;&lt;span&gt;出数，但是你拿实时和离线两个结果对比一下试试看？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你现在告诉我，拿什么拯救已然过了&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;互联网淘汰年龄&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的数据仓库？&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;数据湖当立&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;当互联网 HR 对着年龄超限的数据仓库拿出辞退信的时候，另一个 HR 给一个 09 年才出生的小娃娃发出了 Offer 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;它就是&lt;strong&gt;&lt;span&gt;数据湖&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它爹是 Pentaho 的 CTO James Dixon。James 创造它的时候，也没想到这家伙能变得这么牛掰。他当初只是想把磁带上存储的所有数据统统倒进一个地方，方便任意探索。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而现在的数据湖，已经成长为一个巨无霸！凭借着基于快照的设计方式、满足快照隔离、优秀的原子性、新元数据等巧妙设计，数据湖拥有了支持批流一体、完美增量入库、入库即可计算等特性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这些特性意味着什么？&lt;/p&gt;&lt;p&gt;对于 ETL 工程师来说，意味着数据湖没有 T+1 ！太令人兴奋了！&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是更兴奋的是大数据架构师，数据湖不仅意味着什么数据都往里扔，更意味着一种&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;新架构的诞生&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个万能的架构，能够满足算法工程师随意淘换原始数据的架构，能够满足大数据工程师随时拉一张准实时宽表出来的架构，能够满足准实时数据增量接入和即时分析的架构，能够让大数据工程师不用早起看任务是否失败的架构。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;架构变了&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;Kappa 架构中，最无奈的其实是 Kafka ，生把一个 MQ 整成了数据库。这也直接导致了 Kappa 架构无法存储海量数据的弊端。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.2696817420435511&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7VHriaQOsnjkpFgHko6JxQGWLOIIKKeG0gyvGdGPj0HjqIhMibibiciayfda642LrUmC7OHfU0xzWNG9UpBHBRzKufA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;597&quot;/&gt;&lt;/p&gt;&lt;p&gt;但是这个弊端，&lt;span&gt;数据湖可以解决啊。&lt;/span&gt;把 Kafka 改成数据湖之后，问题解决了。 &lt;span&gt;Kafka 也终于歇了口气，可以卸下莫名其妙得到的“数据库”头衔。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.25675675675675674&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7VHriaQOsnjkpFgHko6JxQGWLOIIKKeG0KpGAmOCibP45UBVZy1OEkQv2U6iarxQ4pLnaicSIDgiavdTrUZsyaotEJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;592&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;而传统数仓的“数据孤岛问题，在数据湖面前，瞬间荡然无存。因为数据湖本来就是大杂烩，什么都往里装呀！&lt;/p&gt;&lt;p&gt;而且现在已经有各种组件与数据湖产品进行对接了。数据湖真的变成了一个湖！&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9693877551020408&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7VHriaQOsnjkpFgHko6JxQGWLOIIKKeG0H8xwfXjQCiaolMGlrO8d8KDyKKQfSFiauXj2IssUUwmCfMicOqdfZMiavg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;392&quot;/&gt;&lt;/p&gt;&lt;p&gt;这个架构简直了！&lt;/p&gt;&lt;p&gt;你可以用数据处理组件，从湖里抽数出来，抽完直接做成宽表扔给运营。&lt;/p&gt;&lt;p&gt;也可以写一个 DAG ，数据规整、打通之后扔其他数据库里。&lt;/p&gt;&lt;p&gt;&lt;span&gt;对数据非常了解的人，可以利用查询组件，直接到数据湖里查数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;算法工程师同样可以直接对接数据湖，从湖里捞原始数据投喂给算法，训练模型。&lt;/p&gt;&lt;p&gt;最关键的一点，OLAP 引擎也能直接对接数据湖！&lt;/p&gt;&lt;p&gt;这个就厉害了！换句话说，咱可以依据这个构建一个超级无敌的 OLAP 体系，准实时、不用复杂的分层建设、不用担心任务跑不完、业务要啥可以快速给出去！&lt;/p&gt;&lt;h3&gt;&lt;span&gt;市场变了&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;你说，这个东东&lt;/span&gt;&lt;span&gt;是不是很牛？&lt;/span&gt;&lt;span&gt;对你来说是不是很有价值？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;是的，不仅对你有价值，对资本市场也很有价值。美国有个公司叫Snowflake，好家伙，直接估值过 1000 亿美金！！！PS 远超其他各大独角兽。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5502555366269165&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7VHriaQOsnjkpFgHko6JxQGWLOIIKKeG0u2ZvHOb8sVGANqXCfwibkmIxTqSZ9hpRJaUZdUhynDsIY7PW27wiaDbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;587&quot;/&gt;&lt;/p&gt;&lt;p&gt;除了 Snowflake 之外，数据湖的老选手亚马逊 AWS 也是一路狂奔，早就有了自己的 OLAP 产品 AWS Athena ，跟自己的数据湖双剑合并，推出了“湖仓一体”的概念。&lt;/p&gt;&lt;p&gt;当然，这里面肯定也少不了中国队的身影，首当其冲的就是阿里系了。阿里的 OSS 大家应该都挺熟悉的，这个存储便宜的要死。&lt;/p&gt;&lt;p&gt;但是你可能不知道，阿里基于 OSS 的存储还整了一个云原生数据湖体系，其中不仅包括了数据湖，还有基于数据湖的 OLAP 产品 DLA ！&lt;/p&gt;&lt;p&gt;当然啊，这个价钱嘛，嘿嘿，你懂的。&lt;/p&gt;&lt;p&gt;其他选择也有哈。目前开源的数据湖有江湖人称“数据湖三剑客”的 Delta Lake、IceBerg 和 Hudi。&lt;/p&gt;&lt;p&gt;上面的 OLAP、查询引擎可以用 Kylin、Presto，Spark SQL、Impala等。&lt;/p&gt;&lt;p&gt;这里着重强调一下 Kylin 哈，不仅是因为这是中国团队开源的产品，更重要的是这玩意我们大数据工程师熟啊~~~&lt;/p&gt;&lt;p&gt;而且，就算你不是大数据工程师，是传统数仓工程师，学习起来也不要太简单了！因为这玩意你可以理解为大数据环境下的 Cube。这不就是我们天天在干的活儿么？&lt;/p&gt;&lt;p&gt;当然，Kylin现在已经不局限于传统的Cube，基本上已经把Cube当成Index和存储了。之前分享过，Kylin现在已经支持明细查询和实时查询的功能。&lt;/p&gt;&lt;p&gt;为了帮大家探路，我厚着脸皮找到了 Kylin 创始团队的史少锋大佬，要来了几份&lt;strong&gt;&lt;span&gt;半公开的资料&lt;/span&gt;&lt;/strong&gt;。大家自己收着就行哈。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.34454638124362896&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7VHriaQOsnjkpFgHko6JxQGWLOIIKKeG0ibKuD9tibeZNpIkCwkB2IaHRaI6A3iavVNvhT0icapnhzIdpqZmqfSiaFdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;981&quot;/&gt;&lt;/p&gt;&lt;p&gt;云上数据湖 + Kylin 的这个产品叫 Kyligence Cloud，从上图可以看到它的位置，就在湖之上，可视化之下。因为是直接从湖里取数建 Cube，然后直接展示。这省了多少事儿啊！&lt;/p&gt;&lt;p&gt;有哥们问了，那构建 Cube 不得要时间么？咋说呢，第一次建 Cube，的确要一些时间。但是之后就不需要那么长时间了，因为数据可以增量加载。&lt;/p&gt;&lt;p&gt;因为数据湖的特性，它可以告诉 Kylin 在从上次消费后，有哪些 Partition 发生了修改。这样 Kylin 只要刷新特定的 Partition 就可以了。而且数据湖可以只拉取变化的数据，使得增量修改 Cube 变得可行。如果有查询不能被 Cube 满足，那么直接下压查询数据湖也是支持的，只是性能上会降级到普通水平。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5230769230769231&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7VHriaQOsnjkpFgHko6JxQGWLOIIKKeG0aeXl9ppiaeyrQZvWyQOxib70Iam9JnCq8f5qlR1ItHENaxAqfA7ZQusQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;715&quot;/&gt;&lt;/p&gt;&lt;p&gt;这样，整个数据流，从产生到展示，基本上能控制在半个小时以内。啥？你还嫌慢？&lt;/p&gt;&lt;p&gt;嗯，的确，跟 ClickHouse 比起来，的确是慢一些，我也不是过来跟你掰扯那个工具好，谁的并发量高、速度快。&lt;/p&gt;&lt;p&gt;但是，哥们，咱说句良心话，你真的想成为一个&lt;span&gt;&lt;strong&gt;&lt;span&gt;整天“拉宽表”的 SQL Boy&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; 吗？我之前也写过一篇 ClickHouse 的文章，那个快则快矣，但是小心反噬啊。&lt;/p&gt;&lt;p&gt;我们知道，OLAP 其实基本分为三个发展方向：MOLAP、ROLAP 和 HOLAP 。Kylin 是 MOLAP，ClikcHouse 是 ROLAP，这两个产品，犹如倚天屠龙。ClickHouse就是那倚天，追求极致的快，Kylin就是那屠龙，厚重而沉稳。&lt;/p&gt;&lt;p&gt;如果倚天屠龙能合二为一，各自取长补短，那简直无敌了！期待Kylin和ClickHouse团队的合作，推出更牛的产品，让我们的工作更轻松一些。&lt;/p&gt;&lt;p&gt;不过现在么，单纯的 ClickHouse 只能算是辟邪。辟邪虽好，必先自宫啊。ClickHouse 用的多了，那咱练就的一手建模技巧，恐怕就要废了！&lt;/p&gt;&lt;p&gt;你问问那些吐槽天天拉宽表的哥们，就知道其实哥们很悲观。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;结语&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;唉，你以为我在耸人听闻，却不知已然是事实。数仓人的前路该往哪个方向？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.25210084033613445&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7VHriaQOsnjkpFgHko6JxQGWLOIIKKeG0fnOZhhGLiaPreZViaYBibicKnkyvCrMeZicc3ic7hDTzo25gpFPbpFichAqZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;357&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是群里兄弟私信我的问题。说实话，这个问题我不知道怎么回答。时代在变迁，技术在进步，跟不上就必然会淘汰。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;前几天我在跑步机上看了《百鸟朝凤》，人们喜欢西洋乐队更甚于传统的唢呐。最后焦师傅赌气吐血吹唢呐，宛若凤凰绝唱的时候，我心都碎了。&lt;/p&gt;&lt;p&gt;我是个老数仓人。05 年实习的时候就在做建仓建模的事情，真心觉得这是个手艺活儿。所以不管怎地，我都得找来 Kylin 的资料，分享给大家。相比起其他工具，Kylin 还是更亲近我们数仓人一些的。&lt;/p&gt;&lt;p&gt;感兴趣的可以戳【原文】直接去试用一下，反正又不要钱，领导问起来也好解释，研究新技术么。好歹给自己简历上多写一句话啊。&lt;/p&gt;&lt;p&gt;唉，数仓不知道死没死，但是数据湖已经来了。&lt;span&gt;大家努力吧，&lt;/span&gt;加油！&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;扩展阅读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;：【6份数据湖资料+4份Kylin内部解决方案、案例】，公众号“大数据架构师”后台回复“&lt;span&gt;数据湖&lt;/span&gt;”，转发即可下载。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8537037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7VHriaQOsnjkpFgHko6JxQGWLOIIKKeG0FJRw2IkEAKhPWOLJ6bCxKMGS9or0z2GmpcszINpXvP6onjWkLibLjLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;540&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;感谢阅读，本次分享的内容就结束了。&lt;/span&gt;&lt;span&gt;本公众号目前保持日更3000字，为你提供优秀的数据领域的分享。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;欢迎大家加我微信好友，尽个点赞之交，有需要的可以拉你进数据建模交流群，2021更上一层楼!&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7VHriaQOsnjmmS3OUhvJrCiaQV0XT5WZfReHcJIJ2TofQ6icUJGp984icw45ic0dpRdsLic0LYqKsJX0HGRqWuQsvEEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwNjM0MTc0Ng==&amp;amp;mid=2247484404&amp;amp;idx=1&amp;amp;sn=49956f21673dae3ab10b52dbc8376b4b&amp;amp;chksm=972250e9a055d9ff556bbedd7e0f68918a4b1b1235e9f0fb09b426deb6699ea9eface10a72cd&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;从数据库一口气说到数据中台&lt;/a&gt;！&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwNjM0MTc0Ng==&amp;amp;mid=2247485382&amp;amp;idx=1&amp;amp;sn=c0a95f8033cfe992ee4da346703df1c3&amp;amp;chksm=972254dba055ddcd8950fad23698eb8164e2a3f7ab61f04395454e813c4e39dfbb7810cb895d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;传统数据仓库转型最佳目标：Kylin！&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwNjM0MTc0Ng==&amp;amp;mid=2247484917&amp;amp;idx=1&amp;amp;sn=c757c8874f716b3d1164683ee2679ea5&amp;amp;chksm=972256e8a055dffefa87e00721381ab5c0d350b41e886c0c35bf4d530b80d9f318695f1a0596&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;传统数仓和大数据数仓的区别是什么？&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwNjM0MTc0Ng==&amp;amp;mid=2247486961&amp;amp;idx=1&amp;amp;sn=c9ef8a069ddede6863772292d5a866f8&amp;amp;chksm=97225eeca055d7fa3791247b7c66744ab93c6b97b8b3f7c5f28f43fbef6ec5610067b81d4585&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;阿里的《大数据之路》吹牛了？&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;更多精彩：&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>