<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2701f876cab9e67826818234d4f16e4e</guid>
<title>工具 | 一款功能强大，开源免费的 H5 可视化页面配置解决方案</title>
<link>https://toutiao.io/k/6phg7i3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c9d56d90f4c623633fed7fb1c4ffa119</guid>
<title>MyBatis 面试题源码分析前言：MyBatis 架构以及核心内容</title>
<link>https://toutiao.io/k/gai949t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1 cid=&quot;n0&quot; mdtype=&quot;heading&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;欢迎关注公众号【&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;Ccww技术博客&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;】，原创技术文章第一时间推出&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/h1&gt;&lt;hr/&gt;&lt;h3 cid=&quot;n3&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p cid=&quot;n4&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;MyBatis&lt;/code&gt;不管在是平时的使用还是在面试中都必须掌握一个知识点，&lt;code&gt;MyBatis&lt;/code&gt; 是支持自定义 SQL、存储过程和高级映射的类持久框架，跟数据库打交道的一个开源持久化框架&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n5&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;我们来看看&lt;code&gt;MyBatis&lt;/code&gt;架构：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n6&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6463620981387479&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/EvicK4z5ZDrj639hjfDI2Y8jnKNYRXvdicD4BJyYVGAcWUxTx8sSibe4oJFb1v4MU9kDDibh75DY4fBkExN8YUNmlw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1182&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n7&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;MyBatis&lt;/code&gt;的整体架构分为三层：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n8&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n10&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;基础支持层&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n12&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;核心处理层&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n14&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;接口层&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n15&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;我们这边主要讲解一下核心处理层组件&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n16&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;核心处理层&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n17&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在核心处理层中，实现了 &lt;code&gt;MyBatis&lt;/code&gt;的核心处理流程：&lt;code&gt;MyBatis&lt;/code&gt;的&lt;strong&gt;初始化&lt;/strong&gt;以及完成一次&lt;strong&gt;数据库操作&lt;/strong&gt;的涉及的全部流程 ,主要模块分为：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n18&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n20&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;配置解析&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n22&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;SQL 解析与参数映射&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n24&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;SQL 执行与结果集映射&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n26&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;插件&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 cid=&quot;n27&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;配置解析&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n28&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;配置解析对应模块: &lt;code&gt;builder&lt;/code&gt; 和 &lt;code&gt;mapping&lt;/code&gt; ，主要组件为:&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n29&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n31&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;XMLConfigBuilder&lt;/code&gt;: 解析&lt;code&gt;mybatis-config.xml&lt;/code&gt; 配置文件&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n33&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;XMLMapperBuilder&lt;/code&gt;:解析映射配置文件&lt;code&gt;Mapper.xml&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n35&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;XMLStatementBuilder&lt;/code&gt;:主要负责解析 Statement 配置，即 &lt;code&gt;&amp;lt;select /&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;insert /&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;update /&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;delete /&amp;gt;&lt;/code&gt; 标签&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n37&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;MapperAnnotationBuilder&lt;/code&gt;:负责解析 Mapper 接口上的注解&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n38&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在 Mybatis 初始化过程中，会加载 &lt;code&gt;mybatis-config.xml&lt;/code&gt; 配置文件、加载映射配置文件以及 Mapper 接口中的注解&lt;code&gt;@Mapper&lt;/code&gt;信息,&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n39&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;经&lt;code&gt;XML解析properties配置ConfigBuilder::parse&lt;/code&gt;解析的配置信息会形成相应的对象并保存到 &lt;code&gt;Configration&lt;/code&gt; 对象中。之后，根据基于&lt;code&gt;Configration&lt;/code&gt; 创建SqlSessionFactory 对象,待 &lt;code&gt;Mybatis&lt;/code&gt; 初始化完成后，可以通过 &lt;code&gt;SqlSessionFactory&lt;/code&gt; 创建 &lt;code&gt;SqlSession&lt;/code&gt; 对象并开始数据库操作。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n40&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;Configuration&lt;/code&gt;: MyBatis 所有的配置信息都维持在 Configuration 对象之中。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n41&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;SQL 解析与参数映射&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n42&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;SQL 解析模块：&lt;code&gt;scripting&lt;/code&gt; ，&lt;code&gt;XMLLanguageDriver,XMLScriptBuilder&lt;/code&gt;实现了动态 SQL 语句，其提供了多种动态 SQL语句对应的节点。比如：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n43&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n45&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;&amp;lt;where&amp;gt;&lt;/code&gt; 节点、&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n47&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; 节点、&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n49&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;&amp;lt;foreach&amp;gt;&lt;/code&gt; 节点等 。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n50&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;通过这些节点的组合使用， 几乎可以编写出所有满足需要的 SQL。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n51&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;先解析映射文件中定义的动态 SQL 节点，然后可以根据用户传入的参数，将已解析的SQL 语句中的占位符，绑定用户传入的实参，形成数据库能执行的SQL 语句&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n53&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;SQL 执行与结果集映射&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n54&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;SQL 执行与结果集映射对应的模块：&lt;code&gt;executor&lt;/code&gt;（执行器） 和 &lt;code&gt;cursor&lt;/code&gt;（结果游标） 模块等。提供操作接口到数据处理后返回的一系列操作，主要模块有：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n55&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n57&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;SqlSession&lt;/code&gt;：MyBatis 核心 API，主要用来执行命令，获取映射，管理事务。接收开发人员提供 &lt;code&gt;Statement Id&lt;/code&gt; 和参数，并返回操作结果。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n59&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;Executor&lt;/code&gt; ：执行器，是 &lt;code&gt;MyBatis&lt;/code&gt; 调度的核心，负责 SQL 语句的生成以及查询缓存（一级/二级缓存）的维护，它会将数据库相关操作委托给 &lt;code&gt;StatementHandler&lt;/code&gt;完成。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n61&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;StatementHandler&lt;/code&gt; : 封装了&lt;code&gt;JDBC Statement&lt;/code&gt; 操作，负责对 &lt;code&gt;JDBC Statement&lt;/code&gt; 的操作，如设置参数、将Statement 结果集转换成 List 集合。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n63&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;ParameterHandler&lt;/code&gt; : 负责对用户传递的参数转换成 &lt;code&gt;JDBC Statement&lt;/code&gt; 所需要的参数。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n65&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;ResultSetHandler&lt;/code&gt; : 负责将 JDBC 返回的 &lt;code&gt;ResultSet&lt;/code&gt; 结果集对象转换成 List 类型的集合。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n67&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;TypeHandler&lt;/code&gt; : 用于 Java 类型和 JDBC 类型之间的转换。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n69&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;MappedStatement&lt;/code&gt; : 动态 SQL 的封装&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n71&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;SqlSource&lt;/code&gt; : 表示从 XML 文件或注释读取的映射语句的内容，它创建将从用户接收的输入参数传递给数据库的 SQL。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n72&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.784471218206158&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/EvicK4z5ZDrj639hjfDI2Y8jnKNYRXvdicgcGC2N3po6rTgFjBWa3gOicveKEia9sI9cibqIia09I4adTL4SichADg7WQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1494&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n73&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;插件层&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n74&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;插件层对应 模块：&lt;code&gt;plugin&lt;/code&gt; 模块主要拦截器实现&lt;code&gt;Interceptor&lt;/code&gt;的，用户可以通过自定义插件来改变 &lt;code&gt;Mybatis&lt;/code&gt; 的默认行为。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n75&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;虽然Mybatis 自身的功能非常强大，但并不能完美符合所有的应用场景，因此 &lt;code&gt;MyBatis&lt;/code&gt; 提供了插件接口，我们可以通过添加用户自定义插件的方式对 &lt;code&gt;MyBatis&lt;/code&gt; 进行扩展，例如，我们可以拦截 SQL 语句并对其进行重写。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n76&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;但MyBatis只允许使用插件来拦截的这些方法调用：&lt;strong&gt;&lt;code&gt;Executor&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;、&lt;code&gt;ParameterHandler&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;、&lt;code&gt;ResultSetHandler&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;、&lt;code&gt;StatementHandler&lt;/code&gt;&lt;/strong&gt; 接口&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n77&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n78&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;由于用户自定义插件会影响 MyBatis 的核心行为，因此在使用自定义插件之前，开发人员需要了解 MyBatis 内部的原理，这样才能编写出安全、高效的插件。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n79&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;接口层&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n80&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;接口层对应 &lt;code&gt;session&lt;/code&gt; 模块，其主要包括:&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n86&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;基础支持层&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n87&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;基础支持层，包含整个&lt;code&gt;MyBatis&lt;/code&gt; 的基础模块，这些模块为核心处理层的功能提供了良好的支撑。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n88&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;反射模块&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n89&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;反射模块对应：&lt;code&gt;reflection&lt;/code&gt; 模块，Mybatis 中的反射模块，对 Java 反射进行了很好的封装，提供了简易的 API，方便上层调用，并且对反射操作进行了一系列的优化，例如缓存了类的元数据，提高了反射操作的性能&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n90&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;类型模块&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n91&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;类型转换模块对应：&lt;code&gt;type&lt;/code&gt; 模块，&lt;code&gt;MyBatis&lt;/code&gt; 为简化配置文件提供了&lt;strong&gt;别名机制&lt;/strong&gt;，该机制是类型转换模块的主要功能之一。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n92&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;类型转换模块的另一个功能是&lt;strong&gt;实现 JDBC 类型与 Java 类型之间&lt;/strong&gt;的转换，该功能在为 SQL 语句绑定实参以及映射查询结果集时都会涉及：&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n98&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;日志模块&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n99&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;日志模块对应：&lt;code&gt;logging&lt;/code&gt; 包，MyBatis 作为一个设计优良的框架，除了提供详细的日志输出信息，还要能够集成多种日志框架，其日志模块的一个主要功能就是&lt;strong&gt;集成第三方日志框架&lt;/strong&gt;，方便开发人员和测试人员快速定位 Bug 代码&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n100&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;资源加载模块&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n101&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;对应 &lt;code&gt;io&lt;/code&gt; 包，资源加载模块，主要是对类加载器进行封装，确定类加载器的使用顺序，并提供了加载类文件以及其他资源文件的功能 。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n102&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;解析器模块&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n103&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;解析器模块对应：&lt;code&gt;parsing&lt;/code&gt; 包，解析器模块，主要提供了两个功能:&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n109&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;数据源模块&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n110&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;数据源模块对应：&lt;code&gt;datasource&lt;/code&gt; 包，&lt;code&gt;MyBatis&lt;/code&gt; 自身提供了相应的数据源实现，当然 MyBatis 也提供了与第三方数据源集成的接口，这些功能都位于数据源模块之中。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n111&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;数据源是实际开发中常用的组件之一。现在开源的数据源都提供了比较丰富的功能，例如，连接池功能、检测连接状态等，选择性能优秀的数据源组件对于提升 ORM 框架乃至整个应用的性能都是非常重要的。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n112&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;事务模块&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n113&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;事务模块对应：&lt;code&gt;transaction&lt;/code&gt; 包，MyBatis 对数据库中的事务进行了抽象，其自身提供了&lt;strong&gt;相应的事务接口和简单实现&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n114&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在很多场景中，&lt;code&gt;MyBatis&lt;/code&gt; 会与 &lt;code&gt;Spring&lt;/code&gt; 框架集成，并由 &lt;strong&gt;Spring 框架管理事务&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n115&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;缓存模块&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n116&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;缓存模块对应：&lt;code&gt;cache&lt;/code&gt; 包，&lt;code&gt;MyBatis&lt;/code&gt; 中提供了&lt;strong&gt;一级缓存和二级缓存&lt;/strong&gt;，其都是依赖于基础支持层中的缓存模块实现的。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n117&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;而且在优化系统性能时，优化数据库性能是一个比较可行的，而增加缓存则是优化数据库时最有效的手段之一，正确、合理地使用缓存可以将一部分数据库请求拦截在缓存这一层。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n118&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这里需要注意的是，由于MyBatis 自带的缓存与MyBatis以及整个应用是运行在同一个 JVM 中的，共享同一块堆内存。如果这两级缓存中的数据量较大， 则可能影响系统中其他功能的运行，所以当需要缓存大量数据时，优先考虑使用 Redis、Memcache 等缓存产品&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n119&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Binding 模块&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n120&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;对应 &lt;code&gt;binding&lt;/code&gt; 包，MyBatis 通过 &lt;code&gt;Binding&lt;/code&gt; 模块，将用户自定义的 &lt;code&gt;Mapper&lt;/code&gt; 接口与映射配置文件联系起来，系统可以通过调用自定义 Mapper 接口中的方法执行相应的 SQL 语句完成数据库操作，并且会在运行期间进行校验映射文件是否出现语法拼写错误，可以尽早避免这种错误，提供程序的可用性。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n121&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n122&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;值得注意的是，开发人员无须编写自定义 &lt;code&gt;Mapper&lt;/code&gt; 接口的实现，MyBatis 会自动为其创建动态代理对象。在有些场景中，自定义 &lt;code&gt;Mapper&lt;/code&gt; 接口可以完全代替映射配置文件，但有的映射规则和 SQL 语句的定义还是写在映射配置文件中比较方便，例如动态 SQL 语句的定义。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 cid=&quot;n123&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;注解模块&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n124&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;对应 &lt;code&gt;annotations&lt;/code&gt; 包，&lt;code&gt;MyBatis&lt;/code&gt; 提供了&lt;strong&gt;注解&lt;/strong&gt;的方式，使得我们方便的在 &lt;code&gt;Mapper&lt;/code&gt; 接口上编写简单的数据库 SQL 操作代码，而无需像之前一样，必须编写 SQL 在 XML 格式的 Mapper 文件中。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n125&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;异常模块&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n126&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;对应 &lt;code&gt;exceptions&lt;/code&gt; 包。定义了 MyBatis 专有的&lt;code&gt;PersistenceException&lt;/code&gt;和 &lt;code&gt;TooManyResultsException&lt;/code&gt; 异常。&lt;/span&gt;&lt;/p&gt;&lt;h2 cid=&quot;n127&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n128&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;经过以上模块大概了解&lt;code&gt;Mybatis&lt;/code&gt;后，这样可以更好为我们后续研读&lt;code&gt;MyBatis&lt;/code&gt;源码有着很大帮助，后续将研读一下SQL 执行的流程，提供Mybatis自动化能力。在最后我们在来看看模块的架构图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7072243346007605&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrj639hjfDI2Y8jnKNYRXvdiceV57g4Mrn3Pib0ia8hNBIIKoqAfSJiasQBuaQWia3LxD1uIpwrKN3Ff0Eg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;789&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n158&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p cid=&quot;n158&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;各位看官还可以吗？喜欢的话，动动手指点个再看💗呗！！谢谢支持！&lt;span md-inline=&quot;linebreak&quot;&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n158&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;欢迎扫码关注，原创技术文章第一时间推出&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36857142857142855&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;350&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgfBz2Ve78FylxcGWmXaueSuqPguurBCWEkeY1ibeLl1wlxUyibdesc4YeuiaJJjSt6HTiab2iaHyXyyicA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>09387f60e24ddd6c6b1dd11b149e99ea</guid>
<title>如何产出规范、安全、高质量的代码？</title>
<link>https://toutiao.io/k/rd2k0cu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot; itemprop=&quot;articleBody&quot;&gt;&amp;#13;
&lt;blockquote&gt;
&lt;p&gt;对于一个软件开发团队，可以通过哪些代码质量指标和扫描方法让团队产出规范、安全、高质量的代码？让开发团队运行的安全、透明、可靠？本文总结了其中一些实践和工具，包含常见代码质量扫描工具、代码质量指标、第三方依赖管理、安全运维等几个方面，主要适用于 Java/JavaScript 技术栈的 web 项目，希望对于想要规范化自己的项目的 Tech Lead 有所帮助。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于一个软件开发团队，可以通过哪些代码质量指标和扫描方法让团队产出规范、安全、高质量的代码？让开发团队运行的安全、透明、可靠？&lt;/p&gt;
&lt;p&gt;本文总结了其中一些实践和工具，包含常见代码质量扫描工具、代码质量指标、第三方依赖管理、安全运维等几个方面，主要适用于 Java/JavaScript 技术栈的 web 项目，希望对于想要规范化自己的项目的 Tech Lead 有所帮助。&lt;/p&gt;
&lt;h3&gt;代码扫描和常见质量指标&lt;/h3&gt;
&lt;p&gt;“祸患常积于忽微”，往往一些奇怪的 bug 都是一些不规范的小问题造成的。德国飞机涡轮机的发明者帕布斯·海恩提出的一个在航空界关于飞行安全的法则，法则指出: 每一起严重事故的背后，必然有 29 次轻微事故和 300 起未遂先兆以及 1000 起事故隐患。应用于软件开发中，如果项目中代码混乱不堪，必然会在某个时候最终爆发大量的问题。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/1-security-high-quality-code.jpg&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/1-security-high-quality-code-768x383.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里整理了一些常见的扫描工具和代码质量指标，可以在搭建项目基础设施时引入，用于自动化的检查代码中潜在的问题，达到控制代码产出质量的目的。&lt;/p&gt;
&lt;h4&gt;扫描工具&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;checkstyle&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;checkstyle 是常用于 java 项目的扫描工具，检查源代码是否与代码规范相符，检查项目主要包括：Javadoc 注释、imports、过长的类和方法、空格、重复文件、圈复杂度等，默认使用 sun 的代码规则，也可以配置自定义的代码规则，例如阿里就发布了相应的检查规则。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;findbugs&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过 Bug Patterns 的概念，寻找代码中可能出现的 bug，检查项目主要包括：不良编程习惯导致的问题、性能问题、安全问题、线程问题等。例如，应使用 equals 判断相等，而不是 “ =” 操作符、流需要关闭、线程资源需要释放等问题。findbugs 的模式库对编程经验也有较好的提升作用。还可以导入和编写自己的 Bug Patterns 完善检查机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;simian&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;simian 是一个用于检查重复和相似代码的工具，它的重复检查类似于论文查重，会提示一定的相似度。可以单独运行，也可以作为 checkstyle 插件来使用，相对来来说比较小众。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pmd&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;pmd 是一款跨语言的通用静态扫描工具，具备一部分 checkstyle、findbugs 的功能，不再赘述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ESlint/TSlint&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前端界的 checkstyle , TSlint 设计用来做 TypeScript 类型检查，ESlint 作为代码风格检查工具。不过现在 ESlint 也提供了TypeScript 类型检查功能，基本上 ESlint 能整合这两个功能。由于性能问题， TypeScript 也采用了 ESLint 作为 TSlint替代的检查工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SonarQube&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SonarQube 是一款用于代码质量管理的开源工具，它主要用于管理源代码的质量。 SonarQube 和上面的工具不太一样，SonarQube 设计目的是提供一个平台，通过插件的方式提供对各个语言进行支持，也可以和 checkstyle、pmd、simian 等工具进行集成。SonarQube 一般需要单独部署成一个服务，提供数据库，可以记录扫描结果等信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;npm audit&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;npm audit 是 npm 6 之后的版本 自带的一个前端安全扫描工具，可以扫描 npm 依赖中的潜在的漏洞威胁。这些引入的漏洞可能威胁用户开发的机，另外也可能被带入 bundle 文件发布到线上，带来安全问题。目前 npm audit 会在 npm install 完成后自动执行，需要留意安全威胁报告。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Fortify SCA&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Fortify SCA(Source Code Analyzer) 是一款非常优秀的代码安全扫描工具，用于分析代码中潜在的安全问题。通过调用语言的编译器或者解释器把代码（Java、C、C++等源代码）转换成一种中间媒体文件 NST（Normal Syntax Trcc），然后通过模式匹配相关的方式抓取存在于漏洞库中的漏洞。例如，上传的文件没有做检查等 XSS 攻击。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OWASP  Dependency-Track&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开放式 Web 应用程序安全项目（OWASP）是一个非营利组织，提供了很多安全标准、数据库、社区和培训。其中一个工具就是 OWASP  Dependency-Track，可以对第三方依赖包中的知名漏洞进行检查，扫描结果受到漏洞数据库的更新影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;archunit 架构规范检查&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面的检查是代码层面，archunit 可以用于代码架构检查，可以定义规则检查每个包中的实现是否符合规范。例如，controller 包中的类不能实现 service 的接口，repository 下的类必须实现 Repository 接口。通过 archunit 可以减少 codereview 的工作量，避免项目的结构被破坏。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/2-security-high-quality-code.jpg&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/2-security-high-quality-code-768x439.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;统计工具&lt;/h4&gt;
&lt;p&gt;sloccount、sourcemointor 这两个工具可以用于统计代码数量，包括行数、文件数、注释等。除了在项目中扫描 bug 之外，配置代码统计工具可以对项目有一个整体的认知。&lt;br/&gt;
其他的扫描工具还很多，例如 coverity、codemars、binscope、synk、appscan、retire.js 等工具，不再一一列举。&lt;/p&gt;
&lt;h4&gt;最佳搭配&lt;/h4&gt;
&lt;p&gt;这几款工具之间的功能有所重叠，在实际工作中，我们可以根据上面推荐的关注的点，重点清除这些问题。这些扫描工具全部用上除了会带来团队压力和维护成本之外，代码质量不会随着引入的插件增多。除开有质量团队的大厂提供这些扫描平台外，敏捷团队往往不会太大，团队持续关注一个精简的扫描组合更好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java 后端&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;checkstyle&lt;/strong&gt; Java 代码风格守护，Java 项目至少应该配置一个默认的 checkstyle 规则。至少让项目干净，没有无用、重复的代码，以及超大的类和方法。建议做到每次提交代码前检查。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;findbugs&lt;/strong&gt; 常见不规范的代码检查，一些空指针、equals 检查非常有用，而且 IDE  的插件也很好用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;前端&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;eslint&lt;/strong&gt; 守护 JavaScript 代码风格，eslint 搭配一个 .editorconfig ，可以方便的让编辑器保持同 eslint 一致的代码风格。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;npm audit&lt;/strong&gt; 项目中第三方包的威胁扫描，npm 自带无需额外安装，npm 6 以后自运行，需要关注并修复报出的安全问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;安全&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;fortify&lt;/strong&gt; 扫描代码中的漏洞，用它检查出来的大部分安全问题都是注入攻击、XSS 等攻击，这些问题明显可以在开发过程中避免。可以作为 Jenkins 插件配置，和单元测试作为同一阶段运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;OWASP 插件&lt;/strong&gt;  用来扫描第三方依赖漏洞，因为项目中的依赖不会像源代码一样频繁变化，推荐使用 Jekins 插件，定期执行即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为什么不用 SonarQube 呢，SonarQube 是一个非常优秀的代码质量开放平台，需要单独的配置安装，需要花费额外的时间维护，对于小团队来说成本较高，如果有专门的质量团队可以考虑维护一套。&lt;/p&gt;
&lt;h4&gt;常用代码质量指标参考&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;编译告警数，大部分程序员基本上忽略 warning，但是编译器出现了告警是一种不好的体现，意味着软件可能工作，但是存在不好的实践，而这种不确定性，会带来不确定的 bug 最终让人一头雾水。编译过程中的告警，尽量消除掉，编译告警的值推荐消除到 0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均函数代码行数，过大的函数会导致阅读困难，而且往往过大的函数职责不够单一，一般将一个方法代码行数控制到 30 - 50 行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均文件代码行，和平均函数代码行一样，过长的文件一样难以维护，一般一个文件10多个方法，因此文件的代码行数一般控制到 300 - 500 行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;冗余代码，有时候我们代码中可能存在未使用的方法、变量等代码，这让维护者一头雾水，通常需要清零。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总文件重复率，出现重复文件的次数。除了编写单元测试的情况下，业务代码不应该出现重复代码，推荐值为 0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总代码重复度，代码的重复度检查，限于扫描工具的识别模式，需要有一定的容忍度，推荐值在 5% - 10%&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均函数圈复杂度，圈复杂度用来衡量一个模块判定结构的复杂程度。如果一个方法内部有大量的 if 语句嵌套，意味着这个方法的实现质量低下，且程序复杂度高不利于维护，推荐值小于 5%。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全告警，如果配置了安全扫描工具，例如 Fortify，安全威胁应该被清零。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码缺陷，如果配置了缺陷扫描工具，例如 Findbugs，需要清零。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div id=&quot;attachment_12941&quot; class=&quot;wp-caption aligncenter&quot;&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/4-security-high-quality-code.png&quot;&gt;&lt;img aria-describedby=&quot;caption-attachment-12941&quot; src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/4-security-high-quality-code-768x798.png&quot; alt=&quot;常用代码质量指标参考&quot; class=&quot;size-medium_large wp-image-12941&quot; srcset=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/4-security-high-quality-code-768x798.png 768w, https://insights.thoughtworks.cn/wp-content/uploads/2020/09/4-security-high-quality-code-289x300.png 289w, https://insights.thoughtworks.cn/wp-content/uploads/2020/09/4-security-high-quality-code-986x1024.png 986w, https://insights.thoughtworks.cn/wp-content/uploads/2020/09/4-security-high-quality-code.png 1090w&quot; sizes=&quot;(max-width: 700px) 100vw, 700px&quot;/&gt;&lt;/a&gt;&lt;p id=&quot;caption-attachment-12941&quot; class=&quot;wp-caption-text&quot;&gt;常用代码质量指标参考&lt;/p&gt;&lt;/div&gt;
&lt;h3&gt;第三方依赖规范化&lt;/h3&gt;
&lt;p&gt;软件开发过程中，不可避免的需要引入第三方或者开源软件包作为库或者框架引入。“第三方” 其实不是一个软件工程术语，现今在软件行业里面的理解是：第一方为自研的软件，第二方为内部发布的软件，第三方为从社区或者外部商业途径引入的软件包。&lt;/p&gt;
&lt;p&gt;对于个人开发者而言，面向“搜索引擎”编程往往将来源不明的代码片段和程序包引入到项目中。对于企业来说，考虑到的不仅仅是功能是否能实现，还要考虑引入时带来的成本和问题，例如是否需要授权、开源协议是否合理、是否会带来安全威胁。&lt;/p&gt;
&lt;p&gt;企业对于第三方依赖的引入分为几种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;作为开发工具引入&lt;/strong&gt;，例如 gcc、Jenkins，基本没有开源协议问题，但是需要注意开发机、CI 会有安全风险。Jenkins 曾出现过漏洞，CI 服务器被当做远程矿机使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;作为服务部署使用（SaaS&lt;/strong&gt;），部分开源协议会限制这种使用方式，第三方依赖的安全问题会威胁服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;通过软件包再发布&lt;/strong&gt;，大部分开源软件对这种使用方式有较多要求，例如 GPL 开源协议具有传染性，要求使用了 GPL 的项目也要开源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;拷贝源代码引入项目&lt;/strong&gt;，非常不推荐这种方式，尽量通过包管理的方式引入。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;引入第三方依赖需要充分考虑，尽可能最小成本的引入。在一个 React 的前端项目中，有不熟悉的工程师，为了使用一个简单的手风琴效果，引入了整套 bootstrap。不仅破坏了使用 React 的最佳实践，而且让输出的 bundle 文件大小激增数倍，造成首屏加载的性能问题。&lt;/p&gt;
&lt;h3&gt;常见商业友好的开源协议&lt;/h3&gt;
&lt;p&gt;商业用户常用的开源协议实际上只有6种左右，即 LGPL、Mozilla、GPL、BSD、MIT、Apache，另外还有极其宽松的 The Unlicense，但采用的开源软件不多。&lt;/p&gt;
&lt;p&gt;GitHub 提供了一个 license 清单的列表 &lt;a href=&quot;https://choosealicense.com/licenses/&quot;&gt;https://choosealicense.com/licenses/&lt;/a&gt;，&lt;br/&gt;
我根据开源协议的宽松程度，整理了一个列表，方便查看：&lt;/p&gt;
&lt;div id=&quot;attachment_12942&quot; class=&quot;wp-caption aligncenter&quot;&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/5-security-high-quality-code.png&quot;&gt;&lt;img aria-describedby=&quot;caption-attachment-12942&quot; src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/5-security-high-quality-code-768x872.png&quot; alt=&quot;开源协议&quot; class=&quot;size-medium_large wp-image-12942&quot; srcset=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/5-security-high-quality-code-768x872.png 768w, https://insights.thoughtworks.cn/wp-content/uploads/2020/09/5-security-high-quality-code-264x300.png 264w, https://insights.thoughtworks.cn/wp-content/uploads/2020/09/5-security-high-quality-code-902x1024.png 902w, https://insights.thoughtworks.cn/wp-content/uploads/2020/09/5-security-high-quality-code.png 988w&quot; sizes=&quot;(max-width: 700px) 100vw, 700px&quot;/&gt;&lt;/a&gt;&lt;p id=&quot;caption-attachment-12942&quot; class=&quot;wp-caption-text&quot;&gt;开源协议&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;几乎所有的开源协议有一个共同的注意事项：&lt;strong&gt;采用该开源协议的软件项目，不提供任何责任转移和质量保证&lt;/strong&gt;。也就是说采用开源软件造成的法律问题和开源项目无关，另外需要使用者承担因质量问题造成的所有后果。另外，除了引入的程序包之外，字体、图片、特效音、手册等媒体资源也算广义上的“软件”需要考虑开源协议和使用场景。&lt;/p&gt;
&lt;h3&gt;第三方依赖管理&lt;/h3&gt;
&lt;p&gt;对项目中出现的任何第三方依赖有效的管理有非常重要的意义，通过扫描工具，识别出项目中是否有源码、jar包、二进制文件是否来源于某个开源项目。&lt;/p&gt;
&lt;p&gt;任何的第三方软件需要申请入库管理（内部其他团队申请通过可以直接使用），质量团队对申请的软件进行评估：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;是否有开源义务需要履行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引入的第三方依赖是否有 CVEs等漏洞&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三方开源软件是否仍然在维护&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;质量团队根据上面的一些条件，决定出申请的软件能否在项目中使用，允许被采用的软件会定义出优选级别，优先推荐团队使用较为优选的软件，并对项目整体的优选率有一定要求。如果项目中出现了无法识别的二进制文件、非约定目录下的代码片段，需要报备。通过良好的依赖管理和规范化，能减少不良第三方依赖的引入，让软件项目透明、可信。&lt;/p&gt;
&lt;p&gt;一些商业公司提供这些完整的服务，例如 fossid、blackduck、code-climate 等。&lt;/p&gt;
&lt;h3&gt;运维安全&lt;/h3&gt;
&lt;p&gt;大的软件公司，往往有一堆流程和要求。虽然一线开发对堡垒机、防火墙、各种安全规范显得不耐烦，但这些安全措施也在保护开发者。&lt;/p&gt;
&lt;h4&gt;防火墙用于环境隔离&lt;/h4&gt;
&lt;p&gt;往往开发者理解的防火墙用于防止网络入侵、审计、入侵检测等功能，除此之外，防火墙还可以用于各个环境的隔离。一般来说，企业对于生产环境的数据控制比较严格，不会将生产环境的权限交给团队所有开发者，但网络连接有可能疏漏。&lt;/p&gt;
&lt;p&gt;曾经出现过一次线上事故，由于配置文件错误，将原本应该连接到测试的数据库连接到了生产环境，造成大量脏数据写入。如果通过防火墙规则对各个环境进行隔离，这类问题将不会出现。&lt;/p&gt;
&lt;p&gt;另外也可以设计 DMZ 区，将面向用户侧的网关部署到 DMZ 区，仅仅开放必要的端口给网关，实现内外网的物理隔离。同时，对整个系统的防火墙策略应该清晰地记录，否则在做大的基础设施更新时，梳理出所有的防火墙策略，是一件比较困难的事情。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/6-security-high-quality-code.jpg&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/6-security-high-quality-code-768x363.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;凭据管理&lt;/h4&gt;
&lt;p&gt;项目中会用到大量的凭据，例如数据库、第三方系统对接的 key，使用明文不是一件好事。理想的情况下，对项目中所有的密码信息进行掩盖(mask)，避免 CI、日志中敏感信息的泄露。&lt;/p&gt;
&lt;p&gt;有很多种方法可以掩盖项目中的密码信息：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用环境变量对密码信息进行覆盖。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用Spring boot 的项目可以配置 jasypt，使用 jasypt 将密码加密，将生成的加密串配置 ENC(加密串) 到工程的配置文件中。加密过程可以加盐作为解密的凭据，“盐” 可以不存放到工程中，在工程部署的时候注入即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果使用 Jenkins 等 CI/CD 工具，可以使用构建平台提供的凭证管理工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果使用 Spring cloud，可以使用 spring cloud vault 组件部署一个凭证管理服务&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外，建议不要用任何个人凭据用作系统对接，应该使用一个公共的应用凭据。&lt;/p&gt;
&lt;h4&gt;堡垒机&lt;/h4&gt;
&lt;p&gt;一般来说我们管理服务器，所有的运维操作需要通过堡垒机进行操作。开放 22 等高危端口，允许开发者直接登录到服务器是一种不安全的做法。&lt;/p&gt;
&lt;p&gt;堡垒机，通俗的来说是跳板机 + 监控。最初使用的跳板机配置了两张网卡，用于连接开发环境和生产环境，并没有监控功能。在此基础上，堡垒机增加了统一运维管理的功能，往往需要两步验证（SMS 或 Email），并对所有的操作进行记录和监控。&lt;/p&gt;
&lt;p&gt;在需要团队参与运维工作的场景中，非常有必要部署一套堡垒机服务，并使用 LDAP 对接到团队成员的 ID 上，便于集中运维管理。&lt;/p&gt;
&lt;h4&gt;定期对系统软件扫描&lt;/h4&gt;
&lt;p&gt;Linux 系统往往有云厂商推送安全补丁和风险提示，但是安装到服务器上的软件，例如 JDK、nodejs，需要自己检查安全问题。因此需要在系统中安装并定期运行 CVEs 检查并及时更新。有一款 cvechecker 可以帮助运维人员，编写一个脚本定期运行 cvechecker  检查系统中已知的软件是否存在 CVEs 漏洞，并提醒开发者及时更新。&lt;/p&gt;
&lt;h3&gt;写在后面&lt;/h3&gt;
&lt;p&gt;刚开始工作时候，喜欢动态的、灵活的编程语言，讨厌的死板的、套路化的编程语言，然而需要很长一段时间，才能意识到 “约束是程序员的朋友”。对一些安全知识了解的来源大多来自修复 SonarQube 的经历，使用 findbugs 也让我对 Java 基础认识的更加深刻。&lt;/p&gt;
&lt;p&gt;类似的，在使用一些框架、平台的时候往往存在大量的限制，有时候开发者难以意识到 “限制” 正是框架、平台的作者 “保护” 应用开发者的一种方式。有一些开发者以 Hack 框架、平台为乐，但是这样会带来潜在的隐患，在用户量上来之后负面效应表现的尤为明显。&lt;/p&gt;
&lt;p&gt;项目的规范化对于 Tech Lead来说可以减少程序的运行事故和 codereview 时间，对于团队来说也许可以少加班吧。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;更多精彩洞见，请关注微信公众号：ThoughtWorks洞见&lt;/strong&gt;&lt;/p&gt;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>da722aaabcdc6b40e6a359f38ea28496</guid>
<title>你还在用 Swagger？试试这个神器</title>
<link>https://toutiao.io/k/k9tsk1j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天给大家安利一款接口文档生成器——JApiDocs。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Swagger想必大家都用过吧，非常方便，功能也十分强大。如果非要说Swaager有什么缺点，想必就是注解写起来比较麻烦。如果我说有一款不用写注解，就可以生成文档的工具，你心动了吗？他就是我们今天的主角——JApiDocs。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们一起来看看如何使用！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、添加依赖&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;io.github.yedaxia&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;japidocs&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.3&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、配置生成参数&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们新建一个项目，然后随便写一个main方法，增加生成文档的配置，然后运行main方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;DocsConfig config = &lt;span&gt;new&lt;/span&gt; DocsConfig();&lt;br/&gt;config.setProjectPath(&lt;span&gt;&quot;F:\\Java旅途\\japi-docs&quot;&lt;/span&gt;); &lt;span&gt;// 项目根目录&lt;/span&gt;&lt;br/&gt;config.setProjectName(&lt;span&gt;&quot;japi-docs&quot;&lt;/span&gt;); &lt;span&gt;// 项目名称&lt;/span&gt;&lt;br/&gt;config.setApiVersion(&lt;span&gt;&quot;V1.0&quot;&lt;/span&gt;);       &lt;span&gt;// 声明该API的版本&lt;/span&gt;&lt;br/&gt;config.setDocsPath(&lt;span&gt;&quot;F:\\test&quot;&lt;/span&gt;); &lt;span&gt;// 生成API 文档所在目录&lt;/span&gt;&lt;br/&gt;config.setAutoGenerate(Boolean.TRUE);  &lt;span&gt;// 配置自动生成&lt;/span&gt;&lt;br/&gt;Docs.buildHtmlDocs(config); &lt;span&gt;// 执行生成文档&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、编码规范&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于JApiDocs是通过解析Java源码来实现的，因此如果要想实现想要的文档，还是需要遵循一定的规范。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.1 类注释、方法注释和属性注释&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们想生成类的注释，我们可以直接在类上加注释，也可以通过加@description来生成。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 用户接口类&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/api/user&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserController&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; Java旅途&lt;br/&gt; * &lt;span&gt;@Description&lt;/span&gt; 用户接口类&lt;br/&gt; * &lt;span&gt;@Date&lt;/span&gt; 2020-06-15 21:46&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/api/user&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserController&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们想生成方法的注释，只能直接加注释，不能通过加@description来生成。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 查询用户&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; age 年龄&lt;br/&gt; * &lt;span&gt;@return&lt;/span&gt; R&amp;lt;User&amp;gt;&lt;br/&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/list&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; R&amp;lt;User&amp;gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(@RequestParam &lt;span&gt;int&lt;/span&gt; age)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    User user = &lt;span&gt;new&lt;/span&gt; User(&lt;span&gt;&quot;Java旅途&quot;&lt;/span&gt;, &lt;span&gt;18&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; R.ok(user);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JApiDocs可以自动生成实体类，关于实体类属性的注释有三种方式，生成的效果都是一样的，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 用户名称&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 用户年龄&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; age;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 用户名称&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;&lt;span&gt;// 用户年龄&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; age;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; String name;&lt;span&gt;// 用户名称&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; age;&lt;span&gt;// 用户年龄&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他除了支持咱们常用的model外，还支持IOS的model生成效果如下：&lt;/p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgiaG5BicLkVfmPrsb9MqYQCVtCjB2IUZXjSBEsDhr4zicfGSNQ47u2xqkcK42zaOMNuvbicGEYwWspxAnTG4NFK5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.65406162464986&quot; data-w=&quot;714&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgiaG5BicLkVfmPrsb9MqYQCVtCjB2IUZXSuJCnaojdk5YZ7LnuH0sR5zibDdTGKibJ5BzYYKTdDDLddAIAnT6icocQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.438375350140056&quot; data-w=&quot;714&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.2 请求参数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果提交的表单是 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; 类型的&lt;code&gt;key/value&lt;/code&gt;格式，则我们通过@param注解来获取参数，在参数后面添加注释，示例如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt;  * &lt;span&gt;@param&lt;/span&gt; age 年龄&lt;br/&gt;  */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/list&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; R&amp;lt;User&amp;gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(@RequestParam &lt;span&gt;int&lt;/span&gt; age)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    User user = &lt;span&gt;new&lt;/span&gt; User(&lt;span&gt;&quot;Java旅途&quot;&lt;/span&gt;, &lt;span&gt;18&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; R.ok(user);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成的文档效果如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求参数&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果提交的表单是 &lt;code&gt;application/json&lt;/code&gt; 类型的&lt;code&gt;json&lt;/code&gt;数据格式，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt;  * &lt;span&gt;@param&lt;/span&gt; user&lt;br/&gt;  * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;  */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@PostMapping&lt;/span&gt;(&lt;span&gt;&quot;/add&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; R&amp;lt;User&amp;gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(@RequestBody User user)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; R.ok(user);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成的文档效果如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求参数&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;string //用户名称&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;age&quot;&lt;/span&gt;: &lt;span&gt;&quot;int //用户年龄&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.3 响应结果&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;我们知道，如果&lt;code&gt;Controller&lt;/code&gt;声明了&lt;code&gt;@RestController&lt;/code&gt;，SpringBoot会把返回的对象直接序列成Json数据格式返回给前端。JApiDocs也利用了这一特性来解析接口返回的结果，但由于JApiDocs是静态解析源码的，因此你要明确指出返回对象的类型信息，JApiDocs支持继承、泛型、循环嵌套等复杂的类解析。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此我们不需要再写注释，它会根据我们的返回结果进行解析，效果如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;code&quot;&lt;/span&gt;: &lt;span&gt;&quot;int&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;msg&quot;&lt;/span&gt;: &lt;span&gt;&quot;string&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;data&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;string //用户名称&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;age&quot;&lt;/span&gt;: &lt;span&gt;&quot;int //用户年龄&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终，我们生成的接口文档，如下：&lt;/p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgiaG5BicLkVfmPrsb9MqYQCVtCjB2IUZXatmESj3XfnydX7G69LicicTE8Gyb9piaduK1F2TjoXeXo67KttcrC2JdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.44537037037037036&quot; data-w=&quot;1080&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、高级配置&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.1 @ApiDoc&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你不希望把所有的接口都导出，我们可以在配置中设置config.setAutoGenerate(Boolean.FALSE);然后在想要生成的接口上添加@ApiDoc。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@ApiDoc有以下三个属性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;result: 这个可以直接声明返回的对象类型，如果你声明了，将会覆盖SpringBoot的返回对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;url: 请求URL，扩展字段，用于支持非SpringBoot项目&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;method: 请求方法，扩展字段，用于支持非SpringBoot项目&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@ApiDoc&lt;/span&gt;(result = User.class, url = &lt;span&gt;&quot;/api/user/view&quot;&lt;/span&gt;, method = &lt;span&gt;&quot;post&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.2 @Ignore&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你不想导出对象里面的某个字段，可以给这个字段加上&lt;code&gt;@Ignore&lt;/code&gt;注解，这样JApiDocs导出文档的时候就会自动忽略掉了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Ignore&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; age;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;五、总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JApiDocs就介绍到这里了，优势劣势大家很容易就看出来了。几乎不需要注释即可生成接口文档，仅有的几个注释我们也可以通过ide来自动生成。但是JApiDocs不具备Swagger在线调试功能。如果有一天JApiDocs支持在线调试后，那时候肯定会有一大波追随者，毕竟写代码的谁喜欢写多余的注解！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>21699ca6929852001f3040e49b8fe6df</guid>
<title>分库分表中间件的高可用实践</title>
<link>https://toutiao.io/k/3m3ovcd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h2&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;分库分表中间件在我们一年多的锤炼下，基本解决了可用性和高性能的问题(只能说基本，肯定还有隐藏的坑要填)，问题自然而然的就聚焦于高可用。本文就阐述了我们在这方面做出的一些工作。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;哪些高可用的问题&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;作为一个无状态的中间件，高可用问题并没有那么困难。但是尽量减少不可用期间的流量损失，还是需要一定的工作的。这些流量损失主要分布在:&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;(1)某台中间件所在的物理机突然宕机。&lt;br/&gt;(2)中间件的升级和发布。&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;由于我们的中间件是作为数据库的代理提供给应用的,即应用把我们的中间件当做数据库，如下图所示:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5976154992548435&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WlIksv5EUJn5gEK3x4baP5ibQGotPicwQ4cMHvh6DeyQf4OLXFvicUeEBR4rVxGic2JjPibYN3swKSLpeoWlDMDo6fg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1342&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以出现上述问题后，业务上很难通过重试等操作去屏蔽这些影响。这就势必需要我们在底层做一些操作，能够自动的感知中间件的状态从而有效避免流量的损失。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;中间件所在物理机宕机的情况&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;物理机宕机其实是一种常见现象，这时候应用一瞬间就没了响应。那么跑在上面的sql肯定也是失败了的(准确来说是未知状态，除非重新查询后端数据库，应用无法得知准确的状态)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这部分流量我们肯定是无法挽救。我们所做的是在client端(Druid数据源)能够快速的发现并剔除宕机的中间件节点。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;发现并剔除不可用节点&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;通过心跳去发现不可用节点&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;自然而然的我们通过心跳来探查后端中间件的存活状态。我们通过定时创建一个新连接ping(mysql的ping)一下然后立马关闭来做心跳(这种做法便于我们区分正常流量和心跳流量，如果通过保持一个连接然后一直发送类似select ‘1’的sql这种方式的话区分流量会稍微麻烦点)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;269&quot; data-ratio=&quot;0.46567967698519513&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WlIksv5EUJn5gEK3x4baP5ibQGotPicwQ4DoLpyQBJ0S8xX6CgMgO7JQck5iaDtBWPwCjYZGVgbr1SvNn0cck5lBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1486&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了防止网络抖动造成的偶发性connect失败，我们在三次connect都失败后才判定某台中间件处于不可用状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而这三次的探活却延长了错误感知时间，所以我们三次connect的时间间隔是指数级衰减的，如下图所示:&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;309&quot; data-ratio=&quot;0.5341701534170153&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WlIksv5EUJn5gEK3x4baP5ibQGotPicwQ47BuK7tLo9BW71JIwOpxE4EyYbNYFpwN1Qh3icn1uDwLPxhibr13qn2pQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1434&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;为何不在第一次connect失败后，连续发送两次connect呢？可能考虑到网络的抖动可能会有一个时间窗口，如果在时间窗口内连续发了3次，出了这个时间窗口网络又okay了，那么会错误的发现后端某节点不可用了,所以我们就做了指数级衰减的折衷。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;通过错误计数去发现不可用节点&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;上述的心跳感知始终有一个时间窗口，当流量很大的时候，在这个时间窗口内使用这个不可用节点的都会失败,所以我们可以使用错误计数去辅助不可用节点的感知(当然这个手段的实现还在计划中)。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;305&quot; data-ratio=&quot;0.5272988505747126&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WlIksv5EUJn5gEK3x4baP5ibQGotPicwQ4PQZLXu1V9cQCL2zOzQHO4mwsiaGnKAfpiaHgDAAdltAc5lMn92gD97ZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1392&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这边有一个注意的点是，只能通过创建连接异常来计数，并不能通过read timeout之类的来计算。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原因是，read timeout异常可能是慢sql或者后端数据库的问题导致，只有创建连接异常才能确定是中间件的问题(connection closed也可能是后端关闭了这个连接, 并不代表整体不可用), 如下图所示:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;324&quot; data-ratio=&quot;0.5608108108108109&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WlIksv5EUJn5gEK3x4baP5ibQGotPicwQ40U6aib7KT3H85nvwgw1A0BmdI0gicTQ3NunmhY27XJWS5UkzpEIWRAVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1480&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;一个请求使用若干个连接导致的问题&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;由于我们需要保证事务尽可能小，所以在一个请求里面多条sql并不使用同一个连接。在非事务(auto-commit)情况下，运行多少条sql就从连接池里面取出多少连接，并放回。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;保证事务小是非常重要的，但是这在中间件宕机的时候会导致一些问题，如下图所示:&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;323&quot; data-ratio=&quot;0.5587392550143266&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WlIksv5EUJn5gEK3x4baP5ibQGotPicwQ4thfobKVEyO8etrDWVOYITRic4TISz1xg7MiaOCArYewU8pOib6rq7Ihqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1396&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如上图所示，在故障发现窗口期中(即还没有确定某台中间件不可用时)，数据源是随机选择连接的。而这个连接就有一定1/N(N为中间件个数)的概率命中不可用中间件导致一条sql失败进而导致整个请求失败。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们做一个计算：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;假设N为8,一个请求有20条sql,&lt;br/&gt;那么在这个期间每个请求失败的概率就为(1-(7/8)的20次方)=0.93,&lt;br/&gt;即有93%的概率会失败！&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;更为甚者，整个应用集群都会经历这个阶段，即每台应用都有93%的概率失败。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一台中间件宕机导致整个服务在十几秒内基本所有请求基本都失败，这是不可忍受的。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;采用sticky数据源解决问题&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;由于我们不能瞬间发现并确认中间件不可用，所以这个故障发现窗口肯定存在(当然，错误计数法会在很大程度上缩短发现时间)。但理想状况下，宕机一台，只损失1/N的流量就好了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们采用了sticky数据源解决了这个问题，使得在概率上大致只损失1/N的流量,如下图所示:&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;327&quot; data-ratio=&quot;0.5654676258992806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WlIksv5EUJn5gEK3x4baP5ibQGotPicwQ4eibvO0ibpKbJXxiczxiamlFphJYXXB3j7bDiacUJhfjCd1dapHVpSFDltgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1390&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;而配合错误计数的话，总流量的损失会更小(因为故障窗口短)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如上图所示，只有在故障时间内随机选择到中间件2(不可用)的请求才会失败，再让我们看下整个应用集群的情况。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;207&quot; data-ratio=&quot;0.3576437587657784&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WlIksv5EUJn5gEK3x4baP5ibQGotPicwQ4N2Vmr9k6rFibBQg9sghLBhOyuSaxDR4ZWAibhtrSMEuRxBzTrrmvYYwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1426&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;只有sticky到中间件2的请求流量才有损失，由于是随机选择，所以这个流量的损失应用在1/N。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;中间件升级发布过程中的高可用&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;分库分表中间件的升级发布不可避免。例如bug fix以及新功能添加等都需要重启中间件。而重启的时间也会导致不可用，与物理机宕机的情况相比是其不可用的时间点是可知的，重启的动作也是可控的，那么我们就可以利用这些信息去做到流量的平滑无损。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;让client端感知即将下线&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;在笔者所知的很多做法中，让client端感知下线是引入一个第三方协调者(例如zookeeper/etcd)。而我们并不想引入第三方的组件去做这个操作，因为这又会引入zookeeper的高可用问题，而且会让client端的配置更加复杂。平滑无损的大致思路(状态机)如下图所示:&lt;/span&gt;&lt;br/&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;176&quot; data-ratio=&quot;0.30404463040446306&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WlIksv5EUJn5gEK3x4baP5ibQGotPicwQ4cBD1wSQF2dCvuj4rQicbH1fe5HibtQic8MLEj1UkTCW2bwRvMvYJ2Pl5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1434&quot;/&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;让心跳流量感知下线而正常流量保持&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;我们可以复用之前client端检测不可用的逻辑，即让心跳的新建连接失败，而正常请求的新建连接成功。这样，client端就会认为Server不可用，而在内部剔除调这个server。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于我们只是模拟不可用，所以已经建立的连接和正常新建的连接(非心跳)都是正常可用的，如下图所示:&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;278&quot; data-ratio=&quot;0.48010610079575594&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WlIksv5EUJn5gEK3x4baP5ibQGotPicwQ4I0Y2dQx3yw7JolJsIhW51bMHNbTjfP6FxKBjAqBwfvRwgLXuan1w7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1508&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;心跳连接的创建在server端可以通过其第一条执行的是mysql的ping而正常流量第一条执行的是一条sql来区分(当然我们采用的Druid连接池在新建连接成功以后也会ping一下，所以采用了另一种方式区分,这个细节在这里就不阐述了)。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;三次心跳失败后，client端判定Server1失败，需要将连接到server1的连接销毁。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其思路是，业务层用完连接返回连接池的时候, 直接给close掉(当然这个是简单的描述，实际操作到Druid数据源也是有细微的差别的)。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;193&quot; data-ratio=&quot;0.33375796178343947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WlIksv5EUJn5gEK3x4baP5ibQGotPicwQ4dXrJVMqQtMquxTuS8nklcVUWS2NicKfUXvw3DmfqJL7LKVxsOhqjQRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1570&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;由于配置了一个connection最长保持时间,所以在这个时间之后肯定会对Server1的连接数为0&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于线上流量也不低,这个收敛时间是比较快的(进一步的做法，其实是主动去销毁,不过我们尚未做这个操作)。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;如何判定下线Server再也没有流量&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;在上述小心翼翼的操作之后，在Server1下线的过程中，是不会有流量损失的。但是我们在Server端还需要判定何时不会再有新的流量,这个判定标准即是Server1没有任何一个client端的连接。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这也是上面我们在执行完sql后销毁连接从而可以让连接数变为0的原因，如下图所示:&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;231&quot; data-ratio=&quot;0.39880952380952384&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WlIksv5EUJn5gEK3x4baP5ibQGotPicwQ4tRhVnc9hNpxVH6licO6X8UrkmZXCKzcVCGtdgYOe2cUg4iaAxATCB4fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1344&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;当连接数为0后，我们就可以重新发布Server1(分库分表中间件)了。对于这一点，我们写了个脚本, 其伪代码如下所示:&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;while(true){&lt;br/&gt;    count =`netstat -anp | grep port | grep ESTABLISHED | wc -l`&lt;br/&gt;    if(0 == count){&lt;br/&gt;        // 流量已经为0，关掉服务器&lt;br/&gt;        kill Server&lt;br/&gt;        // 发布升级服务器&lt;br/&gt;        public Server&lt;br/&gt;        break&lt;br/&gt;    }else{&lt;br/&gt;        Sleep(30s)&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;将这个脚本接入发布平台，即可进行滚动式上下线了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在可以解释下recover_time为何要较长了，因为新建连接也会导致脚本计算出来的 connection count数量增加，所以需要一个时间窗口不去建立心跳，从而能让这个脚本顺利运行。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;recover_time其实是非必要的&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;如果我们将心跳创建的端口号和正常流量的端口号分开，是不需要recover_time的，如下图所示:&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;235&quot; data-ratio=&quot;0.4073482428115016&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WlIksv5EUJn5gEK3x4baP5ibQGotPicwQ4bmFPggP6JfaulmyVT01YWj4x5Hstiaz7m9Atic2yBibre9OD30HmbEzxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1252&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;采用这种方案的话，会在很大程度上降低我们client端代码的复杂度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是这样无疑又给client端增加了一个新的配置，对使用人员就又多了一个负担，还得在网络上多一次开墙的操作，所以我们采取了recover_time的方案。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;中间件的启动顺序问题&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;前面的过程是一个优雅下线的过程，但我们发现我们的中间件才上线的时候在某些情况下也不会优雅。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;即在中间件启动时候，如果对后端数据库刚建立的连接建立上去后由于某些原因断开了，会导致中间件的reactor线程卡住一分钟左右，这段时间无法服务，造成流量损失。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以我们在后端数据库连接全部创建成功后，再启动reactor的accept线程从而接收新的流量，从而解决这一问题，如下图所示:&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;205&quot; data-ratio=&quot;0.35426731078904994&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WlIksv5EUJn5gEK3x4baP5ibQGotPicwQ4fBeBtsquUMMicWf9XTEpkGn4CpKlzcGXFWLVqfSogzfYUibxBtx62QYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1242&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;笔者个人感觉高可用比高性能还要复杂。因为高性能可以在线下反复的去压测，通过压测的数据去分析瓶颈，提高性能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而高可用需要应付线上各种千奇百怪的现象，本篇博客讲述的高可用方案只是我们工作的一小部分，还有很大一部分精力是处理中间件本身的问题上。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但只要不放过任何一个点，将问题都能够分析清楚并解决，就会让系统越来越好。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;59&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;&lt;span&gt;作者：无毁的湖光-Al&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;博客园文章地址： &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;cnblogs.com/alchemystar/p/13678687.html&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;阅读更多&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>