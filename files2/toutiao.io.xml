<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0fe8535ab3eba95438f02d51363de5c3</guid>
<title>使用谷歌中文搜索终于可以远离垃圾 SEO 站了</title>
<link>https://toutiao.io/k/0m5pyi6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;最近这段时间使用Google搜索查个技术问题总是经常误入到一些垃圾站，什么“小X知识网/xspdf.com...”之类的东东，内容不是AI拼凑就是stackoverflow机器翻译，还整出一大堆广告。一次俩次还行，次数多了那就恶心了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.86484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/dOoqs5O3OOGw4Ht19c7Qn110qbjwmqnbB07KGpZBTV6mmEkNibsoVdTqiaraBqC3Ir0X9CdYicXofrkSdviaFn6Gicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;网上查了下，原来被折磨的人儿还真不少a:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;* [v2ex - google 搜中文太毒了吧，是不是已经放弃中文搜索了](https://www.v2ex.com/t/806592)&lt;br/&gt;* [v2ex - 为什么最近 Google 搜索会出现这么多垃圾靠 seo 的站点](https://www.v2ex.com/t/806536#reply75)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;好在发现已经有大牛们祀出了神器（uBlacklist）来清理这些垃圾玩意，这里一定要给点个赞。通过uBlacklist 过滤展示的内容基本上可以避开90%以上的坑了。剩下的还是需要大家共同来完善，一起打击这些个赚钱无底线的seoer。&lt;/p&gt;&lt;p&gt;好了不多说了，下面我们介绍下如何快速上手uBlacklist，远离垃圾站。&lt;/p&gt;&lt;h3&gt;uBlacklist官方的使用解释说明：&lt;/h3&gt;&lt;p&gt;You can add rules on search result pages, or on sites to be blocked by clicking the toolbar icon. Rules can be specified either by match patterns (e.g. &lt;em&gt;://&lt;/em&gt;.example.com/*) or by regular expressions (e.g. /example.(net|org)/).&lt;/p&gt;&lt;h3&gt;屏蔽 Google 中文搜索结果&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;uBlacklist插件下载和安装&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Chrome Web Store&lt;/strong&gt;: https://chrome.google.com/webstore/detail/ublacklist/pncfbmialoiaghdehhbnbhkkgmjanfhe&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Firefox Add-ons&lt;/strong&gt;: https://addons.mozilla.org/en-US/firefox/addon/ublacklist/&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Mac App Store&lt;/strong&gt;: https://apps.apple.com/app/ublacklist-for-safari/id1547912640&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;uBlacklist插件过滤策略&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如何快速订阅已有的过滤策略来过滤垃圾站(&lt;span&gt;&lt;strong&gt;&lt;em&gt;文章结尾有提供可订阅的过滤策略&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;)：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7095959595959596&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/dOoqs5O3OOGw4Ht19c7Qn110qbjwmqnbK7GqhBQezRgDdzvPNzcFUkrvCsZ6icv4OLEdbqMXI4tuGQb6A2cMYew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1584&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如何手动将已确认的垃圾站一并屏蔽掉：&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7518479408658922&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/dOoqs5O3OOGw4Ht19c7Qn110qbjwmqnbfZuW1P9CtwUq9GIJNqZd5Nf6XcOuDTs4V5N9cU74Dfm3c5MemyYQEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1894&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最终过滤后的效果：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4449648711943794&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/dOoqs5O3OOGw4Ht19c7Qn110qbjwmqnbmsUfxWEKicc8gdHOREGGPrxP7vpCrLL0ZnUSqiaVPfkljKFXRz2JorAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1708&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外，还有一些类似的插件可以使用：Google Hit Hider by Domain 和 AC-baidu，但是没有匹配标题的功能。具体的使用办法可以参考这位大牛github@cobaltdisco 的文档就好了(https://github.com/cobaltdisco/Google-Chinese-Results-Blocklist)。&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;216&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;订阅过滤策略&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;span&gt;// 针对大&lt;/span&gt;&lt;span&gt;众化搜索&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://raw.githubusercontent.com/secanylab/uBlacklist_subscription/master/content-farm_v1.txt&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// 针对机器翻译&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://raw.githubusercontent.com/secanylab/uBlacklist_subscription/master/ml-translation_v1.txt&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;参考&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. https://github.com/iorate/uBlacklist&lt;br/&gt;2. https://github.com/liubiantao/uBlacklist-Websites&lt;br/&gt;3. https://github.com/cobaltdisco/Google-Chinese-Results-Blocklist&lt;br/&gt;4. https://github.com/dallaslu/penzai-list&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4fab7850993e303ccb01bfd4c9c1d541</guid>
<title>前端 100 万行代码是怎样的体验？</title>
<link>https://toutiao.io/k/vr8buxr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg4MjE5OTI4Mw==&amp;amp;action=getalbum&amp;amp;album_id=1836961491418185729#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1836961491418185729&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#语言/框架/工具&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;29个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QRibyjewM1IDOAn1vUpiavMqYib5AMZMeIXFoNefpTj1WtpBiaKsqugJsKsfaoiaicH3xNV6c3Rlov9pw9APRgSgib88w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;近年来，阿里数据中台产品发展迅速。核心产品之 Quick BI 连续 2 年成为国内唯一入选 Gartner 魔力象限的国产 BI。Quick BI 单一代码仓库源码突破了 100万行。整个开发过程涉及到的人员和模块都很多，因为下面讲的一些原则，产品能一直保持在快速的开发状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先分享几个关键数据：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码：TypeScript 82万行，样式 Sass+Less+CSS 18万行。（cloc 统计，去除自动生成代码）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;协同：Code Review 12,111 次，Commit 53,026 次。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.25703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QRibyjewM1IDOAn1vUpiavMqYib5AMZMeIXujKJApOjZ2iaUf5ngUnhNDyaDkakKEk1MEjicompEPDD4gT0E22SAOFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多人会问，这么多代码，为什么不切分代码库？还不赶快引入微前端、Serverless 框架？你们就不担心无法维护，启动龟速吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际情况是，从第一天开始，就预估到会有这么大的代码量。启动时间也从最初的几秒钟到后面越来越慢5～10分钟，再优化到近期的5秒钟。整个过程下来，团队更感受到 Monorepo（单一代码仓库）的优势。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个实践想说明：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;开工&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;2019年4月30号，晴朗的下午，刚好是喜迎五一的前一天，发挥集体智慧，投票选出满意的仓库名。同时借 Quick BI 和 FBI 底座融合的契机，项目开启。后来底座代码转正，把上层业务代码也吸纳进来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;commit&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;769&lt;/span&gt;bf68c1740631b39dca6931a19a5e1692be48d&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Date&lt;/span&gt;:   Tue Apr &lt;span class=&quot;code-snippet__number&quot;&gt;30&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;17&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;48&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;52&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;2019&lt;/span&gt; +&lt;span class=&quot;code-snippet__number&quot;&gt;0800&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    A &lt;span class=&quot;code-snippet__keyword&quot;&gt;New&lt;/span&gt; Era &lt;span class=&quot;code-snippet__keyword&quot;&gt;of&lt;/span&gt; BI Begins&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;Why Monorepo？&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QRibyjewM1IDOAn1vUpiavMqYib5AMZMeIXSVr7k7fLLMNibiaN3byg7rbibtjssXVyukqxXlTRboE97nmIcDbIpfwlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在开工之前，对单一仓库（Monorepo）和多仓库（Polyrepo）团队内做了很多的讨论。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;曾经我也很喜欢 Polyrepo，为每个组件建立独立 repo 独立 npm，比如2019年前，单是表单类的编辑器组件就有 43 个：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7804054054054054&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QRibyjewM1IDOAn1vUpiavMqYib5AMZMeIXxJOxK74UYxqEIY75icWNuDghkKqhgtv8r5pFTWT9Ru4DGyic87rqacFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1184&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本以为这样可以做到 &lt;strong&gt;完美的解耦、极致的复用&lt;/strong&gt;？？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但实际上：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每次 Babel、React 等依赖整体升级能让人脱层皮，所以自研了脚手架。造轮子都是被逼出来的，事情做了一点点，但写脚本能力直线上升&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每次 调试组件，npm link 一下。后来组件跨级，可以做 3 层 npm link，使用过的都知道这是多么糟糕的体验&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;版本难对齐，每次主仓库发布前，组件间版本对齐更是考验眼力，稍有不慎触发线上故障&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;方便别人复用的优势呢？最终支持自己业务都捉襟见肘，哪还敢让别人复用&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终我们把所有这些组件都合并到一个仓库，其实像 Google/Facebook/Microsoft 这些公司内部都很推崇 Monorepo。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但我们不是原教旨主义的 Monorepo，没必要把不相关的产品代码硬放到一起。在实线团队内部，单个产品可以使用 Monorepo，会极大降低协同成本。但开始的时候，团队内还是有很多疑问。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;关于 Monorepo 的几个核心疑问？&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;1. 单一仓库，体积会很大吧？&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;100 万行&lt;/span&gt;&lt;/code&gt;&lt;span&gt;代码的体积有多大？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先来猜一下：1GB？10GB？还是更多？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，按照公式计算一下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代码的体积 = 源码的体积 + .git 的体积 + 资源文件（音视频、图片、其他文件）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;我们一起来算一下源码的体积：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;一般建议每行小于 120 字符，我们取每行 100 个字符来算，100 万行就是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;* 1000,000 = 100,000,000 B&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;转换之后就是&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;100 MB！&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那我们的仓库实际多大呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只有 85 MB！也就是平均每行 85 个字符。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;再来算一下 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.git&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的体积：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;.git&lt;/span&gt;&lt;/code&gt;&lt;span&gt;里记录了所有代码的提交历史、branch 和 tag 信息。会很大体积吧？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际上 Git 底层做了很多的优化：1. 所有 branch 和 tag 都是引用；2. 对变更是增量存储；3. 变更对象存储的时候会使用 zlib 压缩。（对于重复出现的样板代码只会存储一次，对于规范化的代码压缩比例极高）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;按照我们的经验，&lt;/span&gt;&lt;code&gt;&lt;span&gt;.git&lt;/span&gt;&lt;/code&gt;&lt;span&gt;记录 &lt;/span&gt;&lt;code&gt;&lt;span&gt;10,000&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 次 commit 提交只需要额外的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;1～3&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 个代码体积即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;资源文件大小&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;Git 做了很多针对源码的优化，但视频和音频这类资源文件除外。我们最近使用 &lt;/span&gt;&lt;span&gt;BFG&lt;/span&gt;&lt;span&gt; 把另一个产品的仓库从 22GB 优化到 200MB，降低 99%！而且优化后代码的提交历史和分支都得到了保留（因为 BFG 会编辑 Git 提交记录，部分 commit id 会变化）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以前 22 GB 是因为仓库里存放视频、发布的 build 文件和 sourcemap 文件，这些都不应该放到源码仓库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小结一下，百万行代码体积一般在 200MB ～ 400MB 之间。那来估算下 &lt;/span&gt;&lt;code&gt;&lt;span&gt;1000 万行&lt;/span&gt;&lt;/code&gt;&lt;span&gt;代码占用体积是多少？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;乘以十也就是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;2GB ~ 4GB&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 之间。这对比 &lt;/span&gt;&lt;code&gt;&lt;span&gt;node_modules&lt;/span&gt;&lt;/code&gt;&lt;span&gt;随随便便几个 G 来说，并不算什么，很容易管理。&lt;/span&gt;&lt;span&gt;补充个案例，&lt;/span&gt;Linux 内核&lt;span&gt;有 2800 万行，使用 Monorepo，数千人协同。据说当时 Linus 就是为了管理 Linux 的源码而开发出 Git。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2. 启动很慢吧？5分钟还是10分钟？&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;听到有些团队讲，代码十几万行，启动 10+分钟，典型的“巨石”项目，已经很难维护了。赶紧拆包、或者改微前端。可能团队才 3 个人却拆了 5 个项目，协同起来非常麻烦。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们做法有3个：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;按照页面来拆分多 Entry，每次只需启动一个 Entry&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;梳理子包间的依赖关系，追求极致的 Lazy loading，Tree-Shaking&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Webpack 切换到 Vite&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尤其是 Webpack 切换到 Vite 以后，最终项目冷启动时间由 2-5分钟 优化到 &lt;strong&gt;5秒 &lt;/strong&gt;内。&lt;/span&gt;&lt;span&gt;热编译时间由原来 5秒 优化到 1秒 内，Apple M1 电脑基本都是 500ms 以内。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;3. 代码复用怎么办？Monorepo 复用的时候是否要引入全部？&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;传统的软件工程思想追求 DRY，但并不是越 DRY 越好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每写一行代码，都产生了相应代价：&lt;strong&gt;维护&lt;/strong&gt;的成本。为了减少代码，我们有了可复用的模块。但是代码复用有一个问题：当你以后想要修改的时候它就会成为一个障碍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于像 Quick BI 这样长期迭代的产品，绝大部分需求都是对原有功能的扩展，所以写出易维护的代码最重要。因此，团队不鼓励使用 magic 的特技写法；不单纯追求代码复用率，而是追求更易于修改；鼓励在未来模块下线的时候易于删除的编码方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于确实存在复用的场景，我们做了拆包。Monorepo 内部我们拆了多个 package（后面有截图），比如其他产品需要 BI 搭建，可以复用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;@alife/bi-designer&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，并借助于 Tree-Shaking 做到依赖引入的最小化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;目前的开发体验&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;冷启动 5秒，热编译 1秒内&lt;/strong&gt;。以前是 5~10分钟。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;改一行代码能解决的问题，&lt;strong&gt;真正改一行且发布一次&lt;/strong&gt;。而不是改 10+ 个项目，按依赖发布 N 次。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;新人 10分钟 搭建好环境&lt;/strong&gt;，上手开发&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;ol ne-level=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;相比于以前每个组件一个 Repo，包赋权都要搞很久&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;避免了版本不对齐的问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;ol ne-level=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于 2C 产品，不需要多版本多主干分支，但多个 npm 依赖对齐版本也不容易&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于 2B 产品，由于多环境、多版本，会更加复杂，复杂度极高。Monorepo 通过分支来统一内部依赖的版本&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;ol start=&quot;5&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;工程化升级只需要一次。目前是基于 Lerna 开发的 Pri Monorepo 方案。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样的体验要保持并不容易，开发中还有很多问题要解决。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;真正需要解决的问题&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;并不是把代码放到一起就完了，背后复杂的问题是 协同、技术方案、稳定性（如何避免一个人提交代码导致整个产品崩溃？）&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;1. 包依赖管理&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;内部拆分多个子包，每个子包是子文件，可以单独发布 npm，见下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.64609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QRibyjewM1IDOAn1vUpiavMqYib5AMZMeIXficgFNTz8HxZjl6QvxbtRrAwJNiabJkY2gcMvxLxTYiaou9OVFnbRBiarg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;内部包管理的核心原则是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于开源 npm 的引入，应该更慎重。大部分 npm 的维护时长不超过x年，即使像 Moment.js 这样曾经标配的工具库也会终止维护。可能有 &lt;/span&gt;&lt;span&gt;20% 的 npm 是没人维护&lt;/span&gt;&lt;span&gt;。但未来如果你的线上用户遇到问题，你就需要靠自己啃源码，陷入被动。所以我们的原则是，引入开源 npm 要三人线下评审通过才行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;2. Code Review 文化&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;互相 Code Review 能帮助新人快速成长，同时也是打造团队技术文化的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;过去几年一直在团队内推行 100% CR，但这还不够。机械的执行很容易把 CR 流于形式，还要分场景来做。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Monorepo 有个风险是一旦有问题就可能是整体的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前我们的 Code Review 主要分为3个场景：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;线上 MR Code Review【1对1】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主题式 Code Review【3-5个人】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;大版本发布前集体 Code Review【All】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;12,111 次 Code Review 的经验很多，主要是：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;及时 Review，鼓励小颗粒度的 MR，不必等整个功能开发完成&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码是写给人看的，鼓励白话文一样的代码，而不是文言文&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;建立最佳实践（目录树结构、命名规范、数据流规范）。开发一个功能可以有 10 种方法，但团队需要选 1 种并推广&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不鼓励炫技，为了未来可维护性。能用简单技术实现，不要用“高深”冷门的技术&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;5&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;强调开发洁癖，追求优雅代码的文化。（命名是否易于理解、注释是否完整、是否有性能隐患等）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;3. 工程化建设&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个过程首先要感谢淘系前端 DEF 工程化团队的支持，在这么多代码的情况下，不断挑战极限升级 DEF 支持我们。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了制定文档的规范之外，能够自动化工具检查的规范才是好规范。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;检查器：ESLint、TS 类型校验、Prettier&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;语法检查器是推动规范落地的重要方法，ESLint 可以做增量，优化后 git commit 的 pre-hooks 依旧很快。但 TS type check 因为不支持增量就比较慢了，需要搭配 CI/CD 来使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;Webpack vs Vite&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;发布使用 Webpack，开发使用 Vite。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开发环境使用 Vite 快速调试，生产环境依旧使用 Webpack 打包。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;风险是开发和生产编译产物不一致，这一块需要上线前回归测试避免。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;4. 性能优化&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于数据产品而言，性能的挑战除了来自于 Monorepo 后资源包的变大，还有大数据量对渲染计算带来的挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;性能优化可以分为3个环节：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外还有性能检测工具，定位性能卡点。计划做代码性能门闩，代码提交前如果发现包体积增大发出提醒。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;5. 数据化驱动架构优化&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;身在数据中台，我对数据的业务价值深信不疑。但对于开发本身而言，很少深度使用过数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以 S1 重点探索了开发体验的数字化。通过采集大家的开发环境和启动耗时数据来做分析【不统计其他数据避免内卷】。发现很多有意思的事情，比如有个同学热编译 3～5 分钟，他以为别人也是这样慢，严重影响了开发效率，当从报表发现数据异常后十分钟帮他解决。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外一个例子，为了保持线上打包产物的一致性，推动团队做 Node.js 版本统一，以前都是靠钉，钉多少次都无法知道效果如何。有了报表以后就一目了然。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.271875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QRibyjewM1IDOAn1vUpiavMqYib5AMZMeIX9YBoraY7SV9wQpQZibLSMzqlmiaRRXlUlQ90fV02mZjXEficqJURnv8RA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前整个数据化的流程跑通，初步尝到甜头。未来还有很多好玩的分析可以做。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;更深层的经验&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;效率最高的方式就是一次最好&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;每行代码都会留下成本。长远考虑，效率最高的方法就是一次做好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;苏世民说“做大事和做小事的难度是一样的。两者都会消耗你的时间和精力”。既然如此，不妨把代码一次写好。代码中如果遗留 “TODO” 可能就永远 TO DO。客观来讲，一次做好比较难，首先是每个人认为的“好”标准不同，背后是个人的技术能力、体验的追求、业务的理解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;组织文化技术 相辅相成&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;技术架构和组织结构有很大关系，选择适合组织的技术架构更重要。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果一个组织是分散的，使用 Monorepo 会有很大的协同成本。但组织如果是内聚的，Monorepo 能极大提效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;工程化和架构底座是团队的事情，靠个人很难去推动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;短期可以靠战役靠照搬，长期要形成文化才能持续迭代。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;组织沟通成本高应该通过组织来解，通过技术来解的力量是渺小的。技术可以做的是充分发挥工具的优势，让变化快速发生。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;简单不先于复杂，而是在复杂之后&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;对于一个简单的架构，总有人会想办法把它做复杂。踩了坑，下决心重构，成功则回归简单，失败就会被新的简单模式颠覆。踩坑本身也是有价值的，不然新人总是按捺不住还会再踩一次。做复杂很容易，但保持简单需要远见和克制。没有经历过过程的磨练，别人的解药对你可能是毒药。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;架构不可能一成不变的，我们的图表最开始直接使用 D3、ECharts 很简单，后来定制很多逐渐复杂到难以维护，于是基于 G2 自研 bi-charts 后架构又一次变简单，前后的开发体验可能是差不多的，但背后的技术完全变了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;总结与展望&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;百万行代码没什么可怕，是一个正常的节点，仍然可以像几万行代码那样敏捷。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在 Quick BI 已经向千万行迈进，向世界一流 BI 的目标迈进。以上内容更多是工程化相关，把工程化做好目的是想让开发者更专注于业务，没讲的业务挑战其实更多，因为数据分析天生就要与海量数据打交道，性能优化有长期的实践；洞察丰富异样的数据，有很多可视化及复杂表格方面的沉淀，可视化不仅是技术，也是业务本身；手机平板电视等多端展示，跨端适配的挑战。未来还希望能够把数据分析打造成一个引擎，能够快速集成到办公和商业流程中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前的开发模式并不完美，在迭代的过程中，不可避免会产生技术债，架构的优化本质就是在保持可维护性和减少技术债。最近团队在酝酿一次 Redux-Toolkit 的引入，会对取数和数据流有大的升级，有进展再分享。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg4MjE5OTI4Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/QRibyjewM1IBw49BrMXhuGAyhmAKA0jiabJkQx7dXYbRWRSffHNGyahxmAdToib28VaTjzFqyMKgcnvA4iaiczGy3ug/0?wx_fmt=png&quot; data-nickname=&quot;Alibaba F2E&quot; data-alias=&quot;alibabaf2e&quot; data-signature=&quot;阿里巴巴前端官方公众号&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;关注&lt;/span&gt;&lt;span&gt;「Alibaba F2E」&lt;/span&gt;&lt;span&gt;微信公众号&lt;/span&gt;&lt;span&gt;把握阿里巴巴前端新动向&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9bb95e7da76f673cc117f91310f003ef</guid>
<title>JWT 怎么实现操作不掉线？</title>
<link>https://toutiao.io/k/v10fj5r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2&gt;什么是Jwt ?&lt;/h2&gt;&lt;p&gt;JSON Web Token 简称Jwt ，一个jwt实际上就是一个字符串，它由三部分组成，&lt;strong&gt;头部&lt;/strong&gt;、&lt;strong&gt;载荷&lt;/strong&gt;与&lt;strong&gt;签名&lt;/strong&gt;，这三个部分都是json格式。&lt;/p&gt;&lt;p&gt;Jwt 由服务器端颁发给客户端。&lt;/p&gt;&lt;h3&gt;头部&lt;/h3&gt;&lt;p&gt;头部用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;typ&quot;&lt;/span&gt;: &lt;span&gt;&quot;JWT&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;alg&quot;&lt;/span&gt;: &lt;span&gt;&quot;HS256&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;在这里，我们说明了这是一个JWT，并且我们所用的签名算法是HS256算法。&lt;/p&gt;&lt;h3&gt;载荷（Payload）&lt;/h3&gt;&lt;p&gt;载荷可以用来放一些不敏感的信息。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;{&lt;br/&gt;    &lt;span&gt;&quot;iss&quot;&lt;/span&gt;: &lt;span&gt;&quot;John Wu JWT&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;iat&quot;&lt;/span&gt;: 1441593502,&lt;br/&gt;    &lt;span&gt;&quot;exp&quot;&lt;/span&gt;: 1441594722,&lt;br/&gt;    &lt;span&gt;&quot;aud&quot;&lt;/span&gt;: &lt;span&gt;&quot;www.monkeyjava.com&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;sub&quot;&lt;/span&gt;: &lt;span&gt;&quot;monkey@example.com&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;from_user&quot;&lt;/span&gt;: &lt;span&gt;&quot;B&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;target_user&quot;&lt;/span&gt;: &lt;span&gt;&quot;A&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;这里面的前五个字段都是由JWT的标准所定义的。&lt;/p&gt;&lt;p&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;iss: 该JWT的签发者&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;    •&lt;/span&gt;sub: 该JWT所面向的用户&lt;/span&gt;&lt;span&gt;&lt;span&gt;    • &lt;/span&gt;aud: 接收该JWT的一方&lt;/span&gt;&lt;span&gt;&lt;span&gt;    •&lt;/span&gt;exp(expires): 什么时候过期，这里是一个Unix时间戳&lt;/span&gt;&lt;span&gt;&lt;span&gt;    •&lt;/span&gt;iat(issued at): 在什么时候签发的&lt;/span&gt;&lt;/p&gt;&lt;p&gt;把头部和载荷分别进行Base64编码之后得到两个字符串，然后再将这两个编码后的字符串用英文句号.连接在一起（头部在前），形成新的字符串：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span&gt;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9&lt;/span&gt;&lt;span&gt;.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;签名（signature）&lt;/h3&gt;&lt;p&gt;最后，我们将上面拼接完的字符串用HS256算法进行加密。在加密的时候，我们还需要提供一个密钥（secret）。加密后的内容也是一个字符串，最后这个字符串就是签名，把这个签名拼接在刚才的字符串后面就能得到完整的jwt。&lt;/p&gt;&lt;p&gt;header部分和payload部分如果被篡改，由于篡改者不知道密钥是什么，也无法生成新的signature部分，服务端也就无法通过，在jwt中，消息体是透明的，使用签名可以保证消息不被篡改。&lt;/p&gt;&lt;h3&gt;使用流程&lt;/h3&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5119291070211316&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ExViakhaSiafGWFOlibOnXAibsu5dDHKM2Wyc8pF6KCKxuAW4tvWylvlShhUWh9LsuX0UlyKv2grFWCOztgAcTllYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1467&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;使用场景&lt;/h2&gt;&lt;p&gt;Jwt 通常用于登录校验，服务器端在颁发Jwt token时，失效时间已经生成好了，在用户每次请求时会校验token的失效时间，如果已失效，用户会退出登录状态。试想用户操作过程中如果jwt 突然失效了，用户退出了岂不是很尴尬？怎么实现用户操作中jwt 自动延期呢？下面给大家介绍jwt + shiro + redis 实现jwt 操作不掉线功能案例代码。&lt;/p&gt;&lt;h2&gt;登录颁发token&lt;/h2&gt;&lt;p&gt;登录接口方法代码&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;    @ApiOperation(&lt;span&gt;&quot;登录接口&quot;&lt;/span&gt;)&lt;br/&gt;    @RequestMapping(value = &lt;span&gt;&quot;/login&quot;&lt;/span&gt;, method = RequestMethod.POST)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Result&amp;lt;JSONObject&amp;gt; &lt;span&gt;login&lt;/span&gt;(&lt;span&gt;@RequestBody SysLoginModel sysLoginModel&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;        Result&lt;span&gt;&amp;lt;&lt;span&gt;JSONObject&lt;/span&gt;&amp;gt;&lt;/span&gt; result = new Result&lt;span&gt;&amp;lt;&lt;span&gt;JSONObject&lt;/span&gt;&amp;gt;&lt;/span&gt;();&lt;br/&gt;        &lt;span&gt;String&lt;/span&gt; username = sysLoginModel.getUsername();&lt;br/&gt;        &lt;span&gt;String&lt;/span&gt; password = sysLoginModel.getPassword();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;SysUser&lt;/span&gt; sysUser = sysUserService.getUserByName(username);&lt;br/&gt;        &lt;span&gt;result&lt;/span&gt; = sysUserService.checkUserIsEffective(sysUser);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(!result.isSuccess()) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;String&lt;/span&gt; userpassword = PasswordUtil.encrypt(username, password, sysUser.getSalt());&lt;br/&gt;        &lt;span&gt;String&lt;/span&gt; syspassword = sysUser.getPassword();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!syspassword.equals(userpassword)) {&lt;br/&gt;            &lt;span&gt;result&lt;/span&gt;.error500(&lt;span&gt;&quot;用户名或密码错误&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        }&lt;br/&gt;    &lt;span&gt;String&lt;/span&gt; syspassword = sysUser.getPassword();&lt;br/&gt;        &lt;span&gt;String&lt;/span&gt; username = sysUser.getUsername();&lt;br/&gt;        &lt;span&gt;// 生成token&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;String&lt;/span&gt; token = JwtUtil.sign(username, syspassword);&lt;br/&gt;   &lt;span&gt;// 设置token缓存有效时间&lt;/span&gt;&lt;br/&gt;        redisUtil.&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;&quot;user_token&quot;&lt;/span&gt; + token, token);&lt;br/&gt;        &lt;span&gt;redisUtil&lt;/span&gt;.expire(&lt;span&gt;&quot;usre_token&quot;&lt;/span&gt; token, JwtUtil.EXPIRE_TIME*2 / 1000);&lt;br/&gt;        &lt;span&gt;obj&lt;/span&gt;.put(&lt;span&gt;&quot;token&quot;&lt;/span&gt;, token);&lt;br/&gt;        &lt;span&gt;obj&lt;/span&gt;.put(&lt;span&gt;&quot;userInfo&quot;&lt;/span&gt;, sysUser);&lt;br/&gt;        &lt;span&gt;result&lt;/span&gt;&lt;span&gt;.setResult&lt;/span&gt;(&lt;span&gt;obj&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;result&lt;/span&gt;.success(&lt;span&gt;&quot;登录成功&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;关键&lt;/p&gt;&lt;p&gt;用户token生成好之后，会往redis 里面存一份token，key=user_token + token、value = token ,过期时间为jwt 过期时间的2倍。&lt;/p&gt;&lt;p&gt;下面整合shiro 时会在授权校验中对redis中token 进行续期操作，详细见ShiroRealm jwtTokenRefresh方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;JwtUtil 工具类&lt;/h2&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.auth0&lt;/span&gt;&lt;span&gt;.jwt&lt;/span&gt;&lt;span&gt;.JWT&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.auth0&lt;/span&gt;&lt;span&gt;.jwt&lt;/span&gt;&lt;span&gt;.JWTVerifier&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.auth0&lt;/span&gt;&lt;span&gt;.jwt&lt;/span&gt;&lt;span&gt;.algorithms&lt;/span&gt;&lt;span&gt;.Algorithm&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.auth0&lt;/span&gt;&lt;span&gt;.jwt&lt;/span&gt;&lt;span&gt;.exceptions&lt;/span&gt;&lt;span&gt;.JWTDecodeException&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.auth0&lt;/span&gt;&lt;span&gt;.jwt&lt;/span&gt;&lt;span&gt;.interfaces&lt;/span&gt;&lt;span&gt;.DecodedJWT&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.google&lt;/span&gt;&lt;span&gt;.common&lt;/span&gt;&lt;span&gt;.base&lt;/span&gt;&lt;span&gt;.Joiner&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.Date&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;javax&lt;/span&gt;&lt;span&gt;.servlet&lt;/span&gt;&lt;span&gt;.http&lt;/span&gt;&lt;span&gt;.HttpServletRequest&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;javax&lt;/span&gt;&lt;span&gt;.servlet&lt;/span&gt;&lt;span&gt;.http&lt;/span&gt;&lt;span&gt;.HttpSession&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.apache&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.SecurityUtils&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * @Author monkey&lt;br/&gt; * @Date &lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-10&lt;/span&gt;&lt;span&gt;-11&lt;/span&gt; &lt;span&gt;23&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;&lt;br/&gt; * @Desc JWT工具类&lt;br/&gt; **/&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;JwtUtil&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Token过期时间30分钟（用户登录过期时间是此时间的两倍，以token在reids缓存时间为准）&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; EXPIRE_TIME = &lt;span&gt;30&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;1000&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 校验token是否正确&lt;br/&gt;     *&lt;br/&gt;     * @param token  密钥&lt;br/&gt;     * @param secret 用户的密码&lt;br/&gt;     * @&lt;span&gt;return&lt;/span&gt; 是否正确&lt;br/&gt;     */&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;verify&lt;/span&gt;&lt;span&gt;(String token, String username, String secret)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 根据密码生成JWT效验器&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;Algorithm&lt;/span&gt; algorithm = Algorithm.HMAC256(secret);&lt;br/&gt;            JWTVerifier verifier = JWT.&lt;span&gt;require&lt;/span&gt;(algorithm).withClaim(&lt;span&gt;&quot;username&quot;&lt;/span&gt;, username).build();&lt;br/&gt;            &lt;span&gt;// 效验TOKEN&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;DecodedJWT&lt;/span&gt; jwt = verifier.verify(token);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (&lt;span&gt;Exception&lt;/span&gt; &lt;span&gt;exception&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 获得token中的信息无需secret解密也能获得&lt;br/&gt;     *&lt;br/&gt;     * @&lt;span&gt;return&lt;/span&gt; token中包含的用户名&lt;br/&gt;     */&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String &lt;span&gt;getUsername&lt;/span&gt;&lt;span&gt;(String token)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;DecodedJWT&lt;/span&gt; jwt = JWT.decode(token);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; jwt.getClaim(&lt;span&gt;&quot;username&quot;&lt;/span&gt;).asString();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (JWTDecodeException e) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 生成签名,5min后过期&lt;br/&gt;     *&lt;br/&gt;     * @param username 用户名&lt;br/&gt;     * @param secret   用户的密码&lt;br/&gt;     * @&lt;span&gt;return&lt;/span&gt; 加密的token&lt;br/&gt;     */&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String &lt;span&gt;sign&lt;/span&gt;&lt;span&gt;(String username, String secret)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;Date&lt;/span&gt; date = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;(System.currentTimeMillis() + EXPIRE_TIME);&lt;br/&gt;        &lt;span&gt;Algorithm&lt;/span&gt; algorithm = Algorithm.HMAC256(secret);&lt;br/&gt;        &lt;span&gt;// 附带username信息&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;JWT&lt;/span&gt;&lt;span&gt;.create&lt;/span&gt;()&lt;span&gt;.withClaim&lt;/span&gt;(&quot;&lt;span&gt;username&lt;/span&gt;&quot;, &lt;span&gt;username&lt;/span&gt;)&lt;span&gt;.withExpiresAt&lt;/span&gt;(&lt;span&gt;date&lt;/span&gt;)&lt;span&gt;.sign&lt;/span&gt;(&lt;span&gt;algorithm&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 根据request中的token获取用户账号&lt;br/&gt;     * &lt;br/&gt;     * @param request&lt;br/&gt;     * @&lt;span&gt;return&lt;/span&gt;&lt;br/&gt;     * @throws BusinessException&lt;br/&gt;     */&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String &lt;span&gt;getUserNameByToken&lt;/span&gt;&lt;span&gt;(HttpServletRequest request)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; JeecgBootException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;String&lt;/span&gt; accessToken = request.getHeader(&lt;span&gt;&quot;X-Access-Token&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;String&lt;/span&gt; username = getUsername(accessToken);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (oConvertUtils.isEmpty(username)) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BusinessException(&lt;span&gt;&quot;未获取到用户&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; username;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2&gt;Shiro整合&lt;/h2&gt;&lt;h3&gt;AuthenticationToken&lt;/h3&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.apache&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.authc&lt;/span&gt;&lt;span&gt;.AuthenticationToken&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * @Author monkey&lt;br/&gt; * @create &lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-10&lt;/span&gt;&lt;span&gt;-11&lt;/span&gt; &lt;span&gt;23&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;&lt;br/&gt; * @desc&lt;br/&gt; **/&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JwtToken&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;AuthenticationToken&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = &lt;span&gt;1L&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String token;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;JwtToken&lt;/span&gt;&lt;span&gt;(String token)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.token = token;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getPrincipal&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; token;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getCredentials&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; token;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;实现AuthenticationToken 封装jwt token&lt;/p&gt;&lt;h3&gt;鉴权登录拦截器 JwtFilter&lt;/h3&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;javax&lt;/span&gt;&lt;span&gt;.servlet&lt;/span&gt;&lt;span&gt;.ServletRequest&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;javax&lt;/span&gt;&lt;span&gt;.servlet&lt;/span&gt;&lt;span&gt;.ServletResponse&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;javax&lt;/span&gt;&lt;span&gt;.servlet&lt;/span&gt;&lt;span&gt;.http&lt;/span&gt;&lt;span&gt;.HttpServletRequest&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;javax&lt;/span&gt;&lt;span&gt;.servlet&lt;/span&gt;&lt;span&gt;.http&lt;/span&gt;&lt;span&gt;.HttpServletResponse&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.apache&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.authc&lt;/span&gt;&lt;span&gt;.AuthenticationException&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.apache&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.web&lt;/span&gt;&lt;span&gt;.filter&lt;/span&gt;&lt;span&gt;.authc&lt;/span&gt;&lt;span&gt;.BasicHttpAuthenticationFilter&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.jeecg&lt;/span&gt;&lt;span&gt;.modules&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.authc&lt;/span&gt;&lt;span&gt;.JwtToken&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.jeecg&lt;/span&gt;&lt;span&gt;.modules&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.vo&lt;/span&gt;&lt;span&gt;.DefContants&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.springframework&lt;/span&gt;&lt;span&gt;.http&lt;/span&gt;&lt;span&gt;.HttpStatus&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.springframework&lt;/span&gt;&lt;span&gt;.web&lt;/span&gt;&lt;span&gt;.bind&lt;/span&gt;&lt;span&gt;.annotation&lt;/span&gt;&lt;span&gt;.RequestMethod&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;lombok&lt;/span&gt;&lt;span&gt;.extern&lt;/span&gt;&lt;span&gt;.slf4j&lt;/span&gt;&lt;span&gt;.Slf4j&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * @Description: 鉴权登录拦截器&lt;br/&gt; * @Author: monkey&lt;br/&gt; * @Date &lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-10&lt;/span&gt;&lt;span&gt;-11&lt;/span&gt; &lt;span&gt;23&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;&lt;br/&gt; **/&lt;br/&gt;@Slf4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JwtFilter&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BasicHttpAuthenticationFilter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 执行登录认证&lt;br/&gt;     *&lt;br/&gt;     * @param request&lt;br/&gt;     * @param response&lt;br/&gt;     * @param mappedValue&lt;br/&gt;     * @&lt;span&gt;return&lt;/span&gt;&lt;br/&gt;     */&lt;br/&gt;    @Override&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isAccessAllowed&lt;/span&gt;&lt;span&gt;(ServletRequest request, ServletResponse response, Object mappedValue)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            executeLogin(request, response);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (&lt;span&gt;Exception&lt;/span&gt; e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AuthenticationException(&lt;span&gt;&quot;Token失效，请重新登录&quot;&lt;/span&gt;, e);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     *&lt;br/&gt;     */&lt;br/&gt;    @Override&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;executeLogin&lt;/span&gt;&lt;span&gt;(ServletRequest request, ServletResponse response)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;HttpServletRequest&lt;/span&gt; httpServletRequest = (HttpServletRequest) request;&lt;br/&gt;        &lt;span&gt;String&lt;/span&gt; token = httpServletRequest.getHeader(DefContants.X_ACCESS_TOKEN);&lt;br/&gt;&lt;br/&gt;        JwtToken jwtToken = &lt;span&gt;new&lt;/span&gt; JwtToken(token);&lt;br/&gt;        &lt;span&gt;// 提交给realm进行登入，如果错误他会抛出异常并被捕获&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;getSubject&lt;/span&gt;(&lt;span&gt;request&lt;/span&gt;, &lt;span&gt;response&lt;/span&gt;)&lt;span&gt;.login&lt;/span&gt;(&lt;span&gt;jwtToken&lt;/span&gt;);&lt;br/&gt;        // 如果没有抛出异常则代表登入成功，返回&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 对跨域提供支持&lt;br/&gt;     */&lt;br/&gt;    @Override&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;preHandle&lt;/span&gt;&lt;span&gt;(ServletRequest request, ServletResponse response)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;HttpServletRequest&lt;/span&gt; httpServletRequest = (HttpServletRequest) request;&lt;br/&gt;        &lt;span&gt;HttpServletResponse&lt;/span&gt; httpServletResponse = (HttpServletResponse) response;&lt;br/&gt;        &lt;span&gt;httpServletResponse&lt;/span&gt;.setHeader(&lt;span&gt;&quot;Access-control-Allow-Origin&quot;&lt;/span&gt;, httpServletRequest.getHeader(&lt;span&gt;&quot;Origin&quot;&lt;/span&gt;));&lt;br/&gt;        &lt;span&gt;httpServletResponse&lt;/span&gt;.setHeader(&lt;span&gt;&quot;Access-Control-Allow-Methods&quot;&lt;/span&gt;, &lt;span&gt;&quot;GET,POST,OPTIONS,PUT,DELETE&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;httpServletResponse&lt;/span&gt;.setHeader(&lt;span&gt;&quot;Access-Control-Allow-Headers&quot;&lt;/span&gt;, httpServletRequest.getHeader(&lt;span&gt;&quot;Access-Control-Request-Headers&quot;&lt;/span&gt;));&lt;br/&gt;        &lt;span&gt;// 跨域时会首先发送一个option请求，这里我们给option请求直接返回正常状态&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;httpServletRequest&lt;/span&gt;&lt;span&gt;.getMethod&lt;/span&gt;()&lt;span&gt;.equals&lt;/span&gt;(&lt;span&gt;RequestMethod&lt;/span&gt;&lt;span&gt;.OPTIONS&lt;/span&gt;&lt;span&gt;.name&lt;/span&gt;())) {&lt;br/&gt;            &lt;span&gt;httpServletResponse&lt;/span&gt;&lt;span&gt;.setStatus&lt;/span&gt;(&lt;span&gt;HttpStatus&lt;/span&gt;&lt;span&gt;.OK&lt;/span&gt;&lt;span&gt;.value&lt;/span&gt;());&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.preHandle(request, response);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;用户登录鉴权和获取用户授权Realm&lt;/h3&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.Set&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.apache&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.authc&lt;/span&gt;&lt;span&gt;.AuthenticationException&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.apache&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.authc&lt;/span&gt;&lt;span&gt;.AuthenticationInfo&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.apache&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.authc&lt;/span&gt;&lt;span&gt;.AuthenticationToken&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.apache&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.authc&lt;/span&gt;&lt;span&gt;.SimpleAuthenticationInfo&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.apache&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.authz&lt;/span&gt;&lt;span&gt;.AuthorizationInfo&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.apache&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.authz&lt;/span&gt;&lt;span&gt;.SimpleAuthorizationInfo&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.apache&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.realm&lt;/span&gt;&lt;span&gt;.AuthorizingRealm&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.apache&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.subject&lt;/span&gt;&lt;span&gt;.PrincipalCollection&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.springframework&lt;/span&gt;&lt;span&gt;.beans&lt;/span&gt;&lt;span&gt;.BeanUtils&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.springframework&lt;/span&gt;&lt;span&gt;.beans&lt;/span&gt;&lt;span&gt;.factory&lt;/span&gt;&lt;span&gt;.annotation&lt;/span&gt;&lt;span&gt;.Autowired&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.springframework&lt;/span&gt;&lt;span&gt;.context&lt;/span&gt;&lt;span&gt;.annotation&lt;/span&gt;&lt;span&gt;.Lazy&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.springframework&lt;/span&gt;&lt;span&gt;.stereotype&lt;/span&gt;&lt;span&gt;.Component&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;lombok&lt;/span&gt;&lt;span&gt;.extern&lt;/span&gt;&lt;span&gt;.slf4j&lt;/span&gt;&lt;span&gt;.Slf4j&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * @Description: 用户登录鉴权和获取用户授权&lt;br/&gt; * @Author: monkey&lt;br/&gt; * @Date &lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-10&lt;/span&gt;&lt;span&gt;-11&lt;/span&gt; &lt;span&gt;23&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;&lt;br/&gt; */&lt;br/&gt;@Component&lt;br/&gt;@Slf4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ShiroRealm&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AuthorizingRealm&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    @Lazy&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RedisUtil redisUtil;&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 必须重写此方法，不然Shiro会报错&lt;br/&gt;     */&lt;br/&gt;    @Override&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;supports&lt;/span&gt;&lt;span&gt;(AuthenticationToken token)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; token &lt;span&gt;instanceof&lt;/span&gt; JwtToken;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 权限信息认证(包括角色以及权限)是用户访问controller的时候才进行验证(redis存储的此处权限信息)&lt;br/&gt;     * 触发检测用户权限时才会调用此方法，例如checkRole,checkPermission&lt;br/&gt;     *&lt;br/&gt;     * @param principals 身份信息&lt;br/&gt;     * @&lt;span&gt;return&lt;/span&gt; AuthorizationInfo 权限信息&lt;br/&gt;     */&lt;br/&gt;    @Override&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; AuthorizationInfo &lt;span&gt;doGetAuthorizationInfo&lt;/span&gt;&lt;span&gt;(PrincipalCollection principals)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;// 此处代码省区.....&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 用户信息认证是在用户进行登录的时候进行验证(不存redis)&lt;br/&gt;     * 也就是说验证用户输入的账号和密码是否正确，错误抛出异常&lt;br/&gt;     *&lt;br/&gt;     * @param auth 用户登录的账号密码信息&lt;br/&gt;     * @&lt;span&gt;return&lt;/span&gt; 返回封装了用户信息的 AuthenticationInfo 实例&lt;br/&gt;     * @throws AuthenticationException&lt;br/&gt;     */&lt;br/&gt;    @Override&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; AuthenticationInfo &lt;span&gt;doGetAuthenticationInfo&lt;/span&gt;&lt;span&gt;(AuthenticationToken auth)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; AuthenticationException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;String&lt;/span&gt; token = (&lt;span&gt;String&lt;/span&gt;) auth.getCredentials();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (token == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AuthenticationException(&lt;span&gt;&quot;token为空!&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 校验token有效性&lt;/span&gt;&lt;br/&gt;        LoginUser loginUser = &lt;span&gt;this&lt;/span&gt;.checkUserTokenIsEffect(token);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; SimpleAuthenticationInfo(loginUser, token, getName());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 校验token的有效性&lt;br/&gt;     *&lt;br/&gt;     * @param token&lt;br/&gt;     */&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; LoginUser &lt;span&gt;checkUserTokenIsEffect&lt;/span&gt;&lt;span&gt;(String token)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; AuthenticationException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 解密获得username，用于和数据库进行对比&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;String&lt;/span&gt; username = JwtUtil.getUsername(token);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (username == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AuthenticationException(&lt;span&gt;&quot;token非法无效!&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 查询用户信息&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;log&lt;/span&gt;.info(&lt;span&gt;&quot;———校验token是否有效————checkUserTokenIsEffect——————— &quot;&lt;/span&gt;+ token);&lt;br/&gt;        &lt;span&gt;LoginUser&lt;/span&gt; loginUser = sysBaseAPI.getUserByName(username);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (loginUser == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AuthenticationException(&lt;span&gt;&quot;用户不存在!&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 判断用户状态&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (loginUser.getStatus() != 1) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AuthenticationException(&lt;span&gt;&quot;账号已被锁定,请联系管理员!&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 校验token是否超时失效 &amp;amp; 或者账号密码是否错误&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!jwtTokenRefresh(token, username, loginUser.getPassword())) {&lt;br/&gt;              &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AuthenticationException(&lt;span&gt;&quot;Token失效，请重新登录!&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; loginUser;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * &lt;br/&gt;     *注意：前端请求Header中设置Authorization保持不变，校验有效性以缓存中的token为准。&lt;br/&gt;     * @param userName&lt;br/&gt;     * @param passWord&lt;br/&gt;     * @&lt;span&gt;return&lt;/span&gt;&lt;br/&gt;     */&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;jwtTokenRefresh&lt;/span&gt;&lt;span&gt;(String token, String userName, String passWord)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;String&lt;/span&gt; cacheToken = &lt;span&gt;String&lt;/span&gt;.valueOf(redisUtil.get(CommonConstant.PREFIX_USER_TOKEN + token));&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (oConvertUtils.isNotEmpty(cacheToken)) {&lt;br/&gt;            &lt;span&gt;// 校验token有效性&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (!JwtUtil.verify(cacheToken, userName, passWord)) {&lt;br/&gt;                &lt;span&gt;String&lt;/span&gt; newAuthorization = JwtUtil.sign(userName, passWord);&lt;br/&gt;                &lt;span&gt;// 设置超时时间&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;redisUtil&lt;/span&gt;&lt;span&gt;.set&lt;/span&gt;(&lt;span&gt;CommonConstant&lt;/span&gt;&lt;span&gt;.PREFIX_USER_TOKEN&lt;/span&gt; + &lt;span&gt;token&lt;/span&gt;, &lt;span&gt;newAuthorization&lt;/span&gt;);&lt;br/&gt;                redisUtil.expire(CommonConstant.PREFIX_USER_TOKEN + token, JwtUtil.EXPIRE_TIME *2 / 1000);&lt;br/&gt;        &lt;span&gt;log&lt;/span&gt;.info(&lt;span&gt;&quot;——————————用户在线操作，更新token保证不掉线—————————jwtTokenRefresh——————— &quot;&lt;/span&gt;+ token);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 清除当前用户的权限认证缓存&lt;br/&gt;     *&lt;br/&gt;     * @param principals 权限信息&lt;br/&gt;     */&lt;br/&gt;    @Override&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;clearCache&lt;/span&gt;&lt;span&gt;(PrincipalCollection principals)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;.clearCache(principals);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;jwtTokenRefresh 声明周期刷新逻辑&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt; 登录成功后将用户的JWT生成的Token作为k、v存储到cache缓存里面(这时候k、v值一样)，缓存有效期设置为Jwt有效时间的2倍&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt; 当该用户再次请求时，通过JWTFilter层层校验之后会进入到doGetAuthenticationInfo进行身份验证&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt; 当该用户这次请求jwt生成的token值已经超时，但该token对应cache中的k还是存在，则表示该用户一直在操作只是JWT的token失效了，程序会给token对应的k映射的v值重新生成JWTToken并覆盖v值，该缓存生命周期重新计算&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt; 当该用户这次请求jwt在生成的token值已经超时，并在cache中不存在对应的k，则表示该用户账户空闲超时，返回用户信息已失效，请重新登录。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;注意：前端请求Header中设置Authorization保持不变，校验有效性以缓存中的token为准。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;用户过期时间 = Jwt有效时间 * 2。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;最后ShiroConfig 配置&lt;/h3&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;lombok&lt;/span&gt;&lt;span&gt;.extern&lt;/span&gt;&lt;span&gt;.slf4j&lt;/span&gt;&lt;span&gt;.Slf4j&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.apache&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.mgt&lt;/span&gt;&lt;span&gt;.DefaultSessionStorageEvaluator&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.apache&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.mgt&lt;/span&gt;&lt;span&gt;.DefaultSubjectDAO&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.apache&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.mgt&lt;/span&gt;&lt;span&gt;.SecurityManager&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.apache&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.spring&lt;/span&gt;&lt;span&gt;.LifecycleBeanPostProcessor&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.apache&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.spring&lt;/span&gt;&lt;span&gt;.security&lt;/span&gt;&lt;span&gt;.interceptor&lt;/span&gt;&lt;span&gt;.AuthorizationAttributeSourceAdvisor&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.apache&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.spring&lt;/span&gt;&lt;span&gt;.web&lt;/span&gt;&lt;span&gt;.ShiroFilterFactoryBean&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.apache&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.web&lt;/span&gt;&lt;span&gt;.mgt&lt;/span&gt;&lt;span&gt;.DefaultWebSecurityManager&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.crazycake&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.RedisCacheManager&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.crazycake&lt;/span&gt;&lt;span&gt;.shiro&lt;/span&gt;&lt;span&gt;.RedisManager&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.springframework&lt;/span&gt;&lt;span&gt;.aop&lt;/span&gt;&lt;span&gt;.framework&lt;/span&gt;&lt;span&gt;.autoproxy&lt;/span&gt;&lt;span&gt;.DefaultAdvisorAutoProxyCreator&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.springframework&lt;/span&gt;&lt;span&gt;.beans&lt;/span&gt;&lt;span&gt;.factory&lt;/span&gt;&lt;span&gt;.annotation&lt;/span&gt;&lt;span&gt;.Value&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.springframework&lt;/span&gt;&lt;span&gt;.context&lt;/span&gt;&lt;span&gt;.annotation&lt;/span&gt;&lt;span&gt;.Bean&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.springframework&lt;/span&gt;&lt;span&gt;.context&lt;/span&gt;&lt;span&gt;.annotation&lt;/span&gt;&lt;span&gt;.Configuration&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.springframework&lt;/span&gt;&lt;span&gt;.context&lt;/span&gt;&lt;span&gt;.annotation&lt;/span&gt;&lt;span&gt;.DependsOn&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;org&lt;/span&gt;&lt;span&gt;.springframework&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.StringUtils&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;javax&lt;/span&gt;&lt;span&gt;.servlet&lt;/span&gt;&lt;span&gt;.Filter&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.HashMap&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.LinkedHashMap&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.Map&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * @author: monkey&lt;br/&gt; * @Date &lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-10&lt;/span&gt;&lt;span&gt;-11&lt;/span&gt; &lt;span&gt;23&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;&lt;br/&gt; * @description: shiro 配置类&lt;br/&gt; */&lt;br/&gt;&lt;br/&gt;@Slf4j&lt;br/&gt;@Configuration&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;ShiroConfig&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * Filter Chain定义说明 &lt;br/&gt;     * &lt;br/&gt;     * 1、一个URL可以配置多个Filter，使用逗号分隔&lt;br/&gt;     * 2、当设置多个过滤器时，全部验证通过，才视为通过&lt;br/&gt;     * 3、部分过滤器可指定参数，如perms，roles&lt;br/&gt;     */&lt;br/&gt;    @Bean(&lt;span&gt;&quot;shiroFilter&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ShiroFilterFactoryBean &lt;span&gt;shiroFilter&lt;/span&gt;&lt;span&gt;(SecurityManager securityManager)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ShiroFilterFactoryBean shiroFilterFactoryBean = &lt;span&gt;new&lt;/span&gt; ShiroFilterFactoryBean();&lt;br/&gt;        &lt;span&gt;shiroFilterFactoryBean&lt;/span&gt;&lt;span&gt;.setSecurityManager&lt;/span&gt;(&lt;span&gt;securityManager&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 拦截器&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;Map&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;String&lt;/span&gt;&amp;gt; filterChainDefinitionMap = &lt;span&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;String&lt;/span&gt;&amp;gt;();&lt;br/&gt;        filterChainDefinitionMap.put(&lt;span&gt;&quot;/sys/login&quot;&lt;/span&gt;, &lt;span&gt;&quot;anon&quot;&lt;/span&gt;); &lt;span&gt;//登录接口排除&lt;/span&gt;&lt;br/&gt;        filterChainDefinitionMap.put(&lt;span&gt;&quot;/sys/logout&quot;&lt;/span&gt;, &lt;span&gt;&quot;anon&quot;&lt;/span&gt;); &lt;span&gt;//登出接口排除&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 添加自己的过滤器并且取名为jwt&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;Map&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, Filter&amp;gt; filterMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&lt;span&gt;String&lt;/span&gt;, Filter&amp;gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        filterMap.put(&lt;span&gt;&quot;jwt&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; JwtFilter());&lt;br/&gt;        &lt;span&gt;shiroFilterFactoryBean&lt;/span&gt;&lt;span&gt;.setFilters&lt;/span&gt;(&lt;span&gt;filterMap&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// &amp;lt;!-- 过滤链定义，从上向下顺序执行，一般将/**放在最为下边&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;filterChainDefinitionMap&lt;/span&gt;.put(&lt;span&gt;&quot;/**&quot;&lt;/span&gt;, &lt;span&gt;&quot;jwt&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 未授权界面返回JSON&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;shiroFilterFactoryBean&lt;/span&gt;.setUnauthorizedUrl(&lt;span&gt;&quot;/sys/common/403&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;shiroFilterFactoryBean&lt;/span&gt;.setLoginUrl(&lt;span&gt;&quot;/sys/common/403&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;shiroFilterFactoryBean&lt;/span&gt;&lt;span&gt;.setFilterChainDefinitionMap&lt;/span&gt;(&lt;span&gt;filterChainDefinitionMap&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; shiroFilterFactoryBean;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Bean(&lt;span&gt;&quot;securityManager&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; DefaultWebSecurityManager &lt;span&gt;securityManager&lt;/span&gt;&lt;span&gt;(ShiroRealm myRealm)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        DefaultWebSecurityManager securityManager = &lt;span&gt;new&lt;/span&gt; DefaultWebSecurityManager();&lt;br/&gt;        &lt;span&gt;securityManager&lt;/span&gt;&lt;span&gt;.setRealm&lt;/span&gt;(&lt;span&gt;myRealm&lt;/span&gt;);&lt;br/&gt;        /*&lt;br/&gt;         * 关闭shiro自带的session，详情见文档&lt;br/&gt;         * &lt;span&gt;http:&lt;/span&gt;/&lt;span&gt;/shiro.apache.org/session&lt;/span&gt;-management.html&lt;span&gt;#SessionManagement-&lt;/span&gt;&lt;br/&gt;         * StatelessApplications%28Sessionless%29&lt;br/&gt;         */&lt;br/&gt;        DefaultSubjectDAO subjectDAO = &lt;span&gt;new&lt;/span&gt; DefaultSubjectDAO();&lt;br/&gt;        DefaultSessionStorageEvaluator defaultSessionStorageEvaluator = &lt;span&gt;new&lt;/span&gt; DefaultSessionStorageEvaluator();&lt;br/&gt;        defaultSessionStorageEvaluator.setSessionStorageEnabled(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;subjectDAO&lt;/span&gt;&lt;span&gt;.setSessionStorageEvaluator&lt;/span&gt;(&lt;span&gt;defaultSessionStorageEvaluator&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;securityManager&lt;/span&gt;&lt;span&gt;.setSubjectDAO&lt;/span&gt;(&lt;span&gt;subjectDAO&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//自定义缓存实现,使用redis&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;securityManager&lt;/span&gt;&lt;span&gt;.setCacheManager&lt;/span&gt;(&lt;span&gt;redisCacheManager&lt;/span&gt;());&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; securityManager;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 下面的代码是添加注解支持&lt;br/&gt;     * @&lt;span&gt;return&lt;/span&gt;&lt;br/&gt;     */&lt;br/&gt;    @Bean&lt;br/&gt;    @DependsOn(&lt;span&gt;&quot;lifecycleBeanPostProcessor&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; DefaultAdvisorAutoProxyCreator &lt;span&gt;defaultAdvisorAutoProxyCreator&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = &lt;span&gt;new&lt;/span&gt; DefaultAdvisorAutoProxyCreator();&lt;br/&gt;        defaultAdvisorAutoProxyCreator.setProxyTargetClass(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; defaultAdvisorAutoProxyCreator;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Bean&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; LifecycleBeanPostProcessor &lt;span&gt;lifecycleBeanPostProcessor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LifecycleBeanPostProcessor();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Bean&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; AuthorizationAttributeSourceAdvisor &lt;span&gt;authorizationAttributeSourceAdvisor&lt;/span&gt;&lt;span&gt;(DefaultWebSecurityManager securityManager)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        AuthorizationAttributeSourceAdvisor advisor = &lt;span&gt;new&lt;/span&gt; AuthorizationAttributeSourceAdvisor();&lt;br/&gt;        &lt;span&gt;advisor&lt;/span&gt;&lt;span&gt;.setSecurityManager&lt;/span&gt;(&lt;span&gt;securityManager&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; advisor;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA4Mzk3NDAyOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ExViakhaSiafF9PQBaFnQkD6AO43WQdToSxBpzal8BoephuEeVU2X9rcGWwiavCibNLibQ4ib454XU0aTEibqx8y0o5yA/0?wx_fmt=png&quot; data-nickname=&quot;猴哥说Java&quot; data-alias=&quot;MonkeyTalkProgram&quot; data-signature=&quot;互联网码农一枚，Java 技术爱好者，喜欢分享交流&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a1765604c3626b382e398be17869cddc</guid>
<title>C++ 分布式编程来了</title>
<link>https://toutiao.io/k/nbyqv4r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.41382765531062127&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xicDr3kHliakcnic1VUhiaZhfufI6UVZZf3I8ZKvpggCq4Oia6TRicGJfLInSgrpMcSObDK4c28q0picBVUo2dONYcCug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;998&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;引言&lt;/strong&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着互联网数据的爆发式增长，互联网业务的发展速度已经明显高于计算机硬件的发展速度。在此背景下，我们可以看到仅靠单机系统能解决的问题越来越少，而越来越多的领域和应用场景需要构建分布式系统。C++作为native的编程语言，由于其高性能、轻量级的特点广泛应用于现代分布式系统中，如Tensorflow、Caffe、XGboost、Redis等都选择C/C++作为主要的编程语言。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相比单机应用，想要构建一个功能完善、高可用、可应用于生产环境的C++分布式系统并没有那么简单。通常我们需要做以下考虑：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;解决通信问题。我们通过protobuf等序列化工具定义组件间的通信协议，然后通过RPC框架（或者socket）实现通信。这里面还需要考虑服务发现、同/异步IO和多路复用等问题，整个实现较为繁琐。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;解决部署问题。我们需要找到满足特定资源规格的服务器，对不同组件的进程进行部署。这个过程可能需要对接不同的云平台实现资源调度。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;解决故障恢复问题。监控任意一个节点的故障事件，重启并恢复系统状态。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看起来，整个实现中需要考虑的问题非常多，完成所有这些事情并不容易。那么有没有一个系统，能够帮你解决以上所有的分布式问题，让你能够专注在系统本身的逻辑上呢？随着Ray的到来，理想即将成为现实。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;Ray是什么&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;整体介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Ray（&lt;/span&gt;&lt;span&gt;https://github.com/ray-project/ray&lt;/span&gt;&lt;span&gt;）是一个简单、通用的分布式计算框架。项目最初由加州大学伯克利分校RISELab发起并开源。在过去的几年中，Ray项目发展迅速，在蚂蚁集团、Intel、微软、AWS、Uber等公司被广泛应用于构建各种AI、大数据系统，并且已经形成了较为完善的生态圈（Tune、Rlib、Serve、分布式Scikit-learn&lt;/span&gt;&lt;span&gt;、XGboost on Ray等&lt;/span&gt;&lt;span&gt;）。相比现有的大数据计算系统（Spark、Flink等），Ray最本质的特点和不同点在于，Ray的设计没有基于某种特定的计算范式（例如DataStream、DataSet），而是回归编程本身，通过抽象编程中最基本的Function和Class等概念，构建了一套简单易用的分布式编程API。所以从系统层次的角度看，Ray的API更加底层，更加灵活。Ray不会限制你的应用场景，无论是批处理、流计算、图计算，还是机器学习、科学计算等，只要你的系统具有分布式特性，需要利用多机协同完成一个特定的任务，你就可以选择Ray帮你完成分布式系统的构建。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;C++ API&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Ray在创建初期只支持Python API，2018年中旬蚂蚁集团开源了Java API。本文介绍的C++ API是Ray上用户接口的第三种语言实现。有人会问，已经有了Python语言和Java语言的支持，为什么还要开发C++版本？我们开发C++ API的主要原因是，在某些高性能场景，Java和Python在系统调优之后仍然无法满足业务需求。除此之外，Ray底层内核和组件本身就是纯C++实现，使用C++ API会让用户层和内核层无缝衔接，整个系统无语言间调用开销。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xicDr3kHliakcnic1VUhiaZhfufI6UVZZf3IFZnibngRUPeicmCGbHnibh53sHKD1Vf2yJVc9VJkmcBNv3xsyVbbcHicQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面简要介绍一下Ray C++ API中几个核心概念和使用方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Task&lt;/strong&gt;&lt;/h4&gt;&lt;h4&gt;R&lt;span&gt;ay中的Task对应单机编程中的function。通过Ray的Task API，我们可以很容易地把任意一个C++函数放到分布式集群中异步执行，大幅提高执行效率。&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;假设我们有一个耗时的heavy_compute函数，如果在单机环境中串行执行10000次，整体耗时很长：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;heavy_compute&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt;;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;std::vector&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;&amp;gt; results;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;10000&lt;/span&gt;; i++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  results.push_back(heavy_compute(i));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;利用Ray将单机的heavy_compute改造成分布式的heavy_compute：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;RAY_REMOTE(heavy_compute);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;ray::ObjectRef&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt; results;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;10000&lt;/span&gt;; i++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  results.push_back(ray::Task(heavy_compute).Remote(i));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; result : ray::Get(results)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt; *result &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;strong&gt;Actor&lt;/strong&gt;&lt;/h4&gt;&lt;h4&gt;普&lt;span&gt;通的Task是一种无状态的计算，如果想实现有状态的计算，需要使用Actor。&lt;/span&gt;&lt;/h4&gt;&lt;h4&gt;Actor对应单机编程中的Class。&lt;span&gt;基于Ray强大的分布式能力，我们可以将以下的单机Counter改造成部署在远程节点的分布式Counter。&lt;/span&gt;&lt;/h4&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Counter&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; count;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Counter(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; init) { count = init; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;{ &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; x + &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;Counter *&lt;span class=&quot;code-snippet__title&quot;&gt;CreateCounter&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; init)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Counter(init);   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;RAY_REMOTE(CreateCounter, &amp;amp;Counter::Add);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ActorHandle&amp;lt;Counter&amp;gt; actor = ray::Actor(CreateCounter).Remote(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; result = actor.Task(&amp;amp;Counter::Add).Remote(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;EXPECT_EQ(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, *(ray::Get(result)));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;strong&gt;Object&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在以上Task和Actor的例子中，我们注意到，最后都是使用“ray::Get”获取计算结果。这里绕不开的一个概念就是Object。每次调用“Remote”方法返回的是一个Object引用（ObjectRef），每个ObjectRef指向一个集群内唯一的远程Object。Ray的Object类似异步编程中常见的future概念。在Ray中，Object会存储在底层的分布式Object Store中（基于shared memory）。当你调用“ray::Get”方法获取一个Object时，会从远程节点拉取数据到当前节点，经过反序列化返回到你的程序中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了存储应用的中间计算结果，你也可以通过“ray::Put”创建一个Object。除此之外，你也可以通过“ray::Wait”接口等待一组Object的结果。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; obj_ref1 = ray::Put(&lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; res1 = obj_ref1.Get();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;EXPECT_EQ(&lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;, *res1);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; obj_ref2 = ray::Put(&lt;span class=&quot;code-snippet__number&quot;&gt;200&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ray::Wait({obj_ref1, obj_ref2}, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从以上基础API可以看出，Ray已经解决了分布式系统组件间通信、存储和传输等问题。Ray还有一些高级功能用来解决分布式系统中的其他问题，例如调度、故障恢复、部署运维等，具体的将在下面的例子中进行介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;用Ray C++实现分布式存储系统&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;简单了解了Ray的定位和Ray C++ API后，让我们用一个实际的例子看一下如何利用Ray C++ API，构建一个简单的KV存储系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;demo说明&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这个简单的KV存储系统中，有一个main server和一个backup server，仅main server提供服务，backup server则只用于备份数据，不提供服务。同时要求系统具备自动故障恢复能力，即任意一个server重启后数据不会丢失，能继续提供服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;注&lt;/strong&gt;：这只是一个demo，不专注存储本身的逻辑和优化，目的是使用尽可能简单的代码来展示如何用Ray来快速开发一个分布式存储系统。&lt;/span&gt;&lt;span&gt;完整代码请在文末点击“阅读原文”查看&lt;/span&gt;&lt;span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xicDr3kHliakcnic1VUhiaZhfufI6UVZZf3IuXmQVPibnNUegu8HgUAVpUOALMv817Gk9O709Cr25ibj9SpZ78XRxq2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;Server实现&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用C++ API实现一个分布式存储比较简单，用户可以先按照单机版的KV store的思路去写server，稍后再利用Ray的分布式部署和调度能力将单机版的KV store变成一个分布式的KV store。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;main server&lt;/strong&gt;&lt;/h4&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MainServer&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  MainServer();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::pair&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;&amp;gt; Get(&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; &amp;amp;key);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Put&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; &amp;amp;key, &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; &amp;amp;val)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;unordered_map&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;&amp;gt; data_;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::pair&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;&amp;gt; MainServer::Get(&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; &amp;amp;key) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; it = data_.find(key);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (it == data_.end()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::pair&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;&amp;gt;{};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; {&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;, it-&amp;gt;second};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; MainServer::Put(&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; &amp;amp;key, &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; &amp;amp;val) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  data_[key] = val;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到分布式KV store的读数据(MainServer::Get)的实现和单机版的实现相比没有任何差异，用户不必关心分布式的细节，关注业务逻辑本身即可。Put时要注意先将数据同步写到backup server中再写本地，确保数据的一致性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;backup server&lt;/strong&gt;&lt;/h4&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;BackupServer&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  BackupServer();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;unordered_map&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;&amp;gt; GetAllData() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; data_;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;SyncData&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; &amp;amp;key, &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; &amp;amp;val)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      data_[key] = val;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;unordered_map&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;&amp;gt; data_;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;部署&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;集群部署&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;部署应用之前需要首先部署一个Ray集群。目前Ray已经支持在多个主流云平台进行一键部署，如AWS、Azure、GCP、Aliyun和Kubernetes环境等。如果你已经拥有了一个配置文件，可以在安装Ray之后通过命令行进行一键部署：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;ray&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;up&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.yaml&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;具体如何配置可以参考官方&lt;/span&gt;&lt;span&gt;文档&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外一种选择，如果你拥有正在运行的服务器，也可以通过在各服务器上执行start命令手动组建Ray集群：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ray &lt;span class=&quot;code-snippet__keyword&quot;&gt;start&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;ray&lt;/span&gt; start --address=&lt;span class=&quot;code-snippet__variable&quot;&gt;${HRAD_ADDRESS}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;strong&gt;actor部署&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;Ray集群部署之后，我们需要将前面创建的MainServer和BackupServer这两个actor&lt;/span&gt;&lt;span&gt;实例部署到集群中，以提供分布式存储服务。用Ray创建Actor的API就可以很简单的实现actor部署。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; MainServer *&lt;span class=&quot;code-snippet__title&quot;&gt;CreateMainServer&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; MainServer(); }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; BackupServer *&lt;span class=&quot;code-snippet__title&quot;&gt;CreateBackupServer&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; BackupServer(); }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;RAY_REMOTE(CreateMainServer, CreateBackupServer);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; MAIN_SERVER_NAME = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;main_actor&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; BACKUP_SERVER_NAME = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;backup_actor&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;StartServer&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ray::Actor(CreateMainServer)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .SetName(MAIN_SERVER_NAME)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .Remote();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ray::Actor(CreateBackupServer)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .SetName(BACKUP_SERVER_NAME)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .Remote();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;调度&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;设置资源&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;如果你对actor运行环境的硬件有特殊要求，还可以通过API设置actor所需要的资源，比如CPU，内存等资源。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;unordered_map&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;double&lt;/span&gt;&amp;gt; RESOUECES{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;CPU&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;1.0&lt;/span&gt;}, {&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;memory&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;1024.0&lt;/span&gt; * &lt;span class=&quot;code-snippet__number&quot;&gt;1024.0&lt;/span&gt; * &lt;span class=&quot;code-snippet__number&quot;&gt;1024.0&lt;/span&gt;}};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;StartServer&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ray::Actor(CreateMainServer)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .SetName(MAIN_SERVER_NAME)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .SetResources(RESOUECES) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .Remote();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ray::Actor(CreateBackupServer)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .SetName(BACKUP_SERVER_NAME)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .SetResources(RESOUECES) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .Remote();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;strong&gt;设置调度策略&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;我们希望将main server和backup server两个actor调度到不同的节点上，以保证某一个节点挂掉不会同时影响两个server。可以利用Ray的Placement Group实现这种特殊的调度功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Placement Group允许用户从集群中预置一部分资源供Task和Actor调度。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ray::&lt;span class=&quot;code-snippet__function&quot;&gt;PlacementGroup &lt;span class=&quot;code-snippet__title&quot;&gt;CreateSimplePlacementGroup&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; &amp;amp;name)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;unordered_map&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;double&lt;/span&gt;&amp;gt;&amp;gt; bundles{RESOUECES, RESOUECES};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ray::PlacementGroupCreationOptions options{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;, name, bundles, ray::PlacementStrategy::SPREAD};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; ray::CreatePlacementGroup(options);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; placement_group = CreateSimplePlacementGroup(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;my_placement_group&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;assert(placement_group.Wait(&lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上面的代码创建了一个Placement Group，调度策略为平铺(SPREAD), 平铺调度的含义是将actor以平铺的方式调度到不同的节点上。更多的调度策略可以参考Ray的官方文档 https://docs.ray.io/en/master/placement-group.html&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来就可以通过Placement Group将actor调度到不同的节点上了。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;StartServer&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ray::Actor(CreateMainServer)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .SetName(MAIN_SERVER_NAME)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .SetResources(RESOUECES)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .SetPlacementGroup(placement_group, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .Remote();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ray::Actor(CreateBackupServer)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .SetName(BACKUP_SERVER_NAME)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .SetResources(RESOUECES)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .SetPlacementGroup(placement_group, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .Remote();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;服务发现和组件通信&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在我们已经把main server和backup server两个actor实例部署到Ray集群中的两个节点上了，接下来需要解决main server的服务发现问题和client-server的通信问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Ray的named actor可以很方便的实现服务发现，我们在创建actor的时候设置了actor的名字，后续就可以通过ray::GetActor(name)来发现之前创建的actor了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Ray Task则可以解决client-server之间的通信问题，就像调用本地函数一样实现远程函数调用，用户无需关心数据通信的细节（如传输协议、网络通信等）。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Client&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Client() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    main_actor_ = ray::GetActor&amp;lt;MainServer&amp;gt;(MAIN_SERVER_NAME);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Put&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; &amp;amp;key, &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; &amp;amp;val)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    (*main_actor_).Task(&amp;amp;MainServer::Put).Remote(key, val).Get();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::pair&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;&amp;gt; Get(&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; &amp;amp;key) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; *(*main_actor_).Task(&amp;amp;MainServer::Get).Remote(key).Get();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  boost::optional&amp;lt;ray::ActorHandle&amp;lt;MainServer&amp;gt;&amp;gt; main_actor_;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;故障恢复&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;进程故障恢复&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;Ray提供了进程故障恢复的功能，比如actor进程挂掉之后Ray会自动将actor进程拉起来，并重新创建actor实例，只需要设置&lt;span&gt;actor的最大重启次数即可。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;StartServer&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ray::Actor(CreateMainServer)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .SetName(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;main_actor&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .SetResources(RESOUECES)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .SetPlacementGroup(placement_group, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .SetMaxRestarts(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .Remote();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ray::Actor(CreateBackupServer)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .SetName(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;backup_actor&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .SetResources(RESOUECES)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .SetPlacementGroup(placement_group, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .SetMaxRestarts(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .Remote();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h4/&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;strong&gt;状态恢复&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;虽然Ray会做进程故障恢复，重新创建actor实例，但是actor的运行状态需要用户去做状态恢复处理，比如main actor挂掉之后重新拉起来，之前在main actor内存中的数据都会丢失，需要做数据恢复。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;MainServer::MainServer() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (ray::WasCurrentActorRestarted()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    HandleFailover();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;void MainServer::HandleFailover() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  backup_actor_ = *ray::GetActor&amp;lt;BackupServer&amp;gt;(BACKUP_SERVER_NAME);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  data_ = *backup_actor_.Task(&amp;amp;BackupServer::GetAllData).Remote().Get();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  RAYLOG(INFO) &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;MainServer get all data from BackupServer&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;main server的failover是在构造函数里面做的，Ray提供了判断actor实例是否重启的API。在actor的构造函数中如果发现是重启的实例则做数据恢复的处理，具体方法就是从backup server拉取所有数据。&lt;/span&gt;backup server的failover处理也是类似的, 不再赘述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;运维与监控&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;R&lt;span&gt;ay提供了一套简单的运维和监控系统(Dashboard)让我们可以实时查看系统的运行情况。&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;以上面的KV store为例，我们可以看到actor列表、node列表和运行日志等信息，并且可以捕捉到一些异常的events。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;actor列表&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.38066666666666665&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xicDr3kHliakcnic1VUhiaZhfufI6UVZZf3IASMasu0q4ErTAGUX5L0bXzSP9W7H3HYG33ld57WTiaElJTCnDqDadTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;node列表&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.22333333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xicDr3kHliakcnic1VUhiaZhfufI6UVZZf3Id55AeI0FecS2xBrInOjbfjicCGul2UfX39PcHpffeC2fcWRo2f0w5ibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;运行日志&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.292&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xicDr3kHliakcnic1VUhiaZhfufI6UVZZf3IicFAocnldhKcVRfKACjSib5W4BaTRBhIxLXnXhOcfutbxewDmbp0hIJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;异常events透出&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.21133333333333335&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xicDr3kHliakcnic1VUhiaZhfufI6UVZZf3Id3PZFTdgJ7EYkvhuabhlqcTBVafXFrWTpjEOdic3H88IVLBWh3KD4ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;如何快速开始&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Ray目前已经完成了1.7.0版本的release，C++ API作为其中一个highlight功能正式集成到wheel包发布，详见发布记录&lt;/span&gt;&lt;span&gt;https://github.com/ray-project/ray/releases/tag/ray-1.7.0&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;考虑到Ray内核的实现是多语言的，跑C++应用需要同时具备Python环境和C++环境，我们将Ray整体打包成wheel用pip进行管理。你可以通过以下方式快速获取一个Ray C++模版工程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;环境要求：Linux系统或macOS, Python 3.6-3.9版本，C++17环境，bazel 3.4以上版本（可选，模版工程基于bazel）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;pip&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-U&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;ray&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[cpp]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt; &lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;mkdir ray-&lt;span class=&quot;code-snippet__keyword&quot;&gt;template&lt;/span&gt; &amp;amp;&amp;amp; ray cpp --generate-bazel-project-&lt;span class=&quot;code-snippet__keyword&quot;&gt;template&lt;/span&gt;-to ray-&lt;span class=&quot;code-snippet__keyword&quot;&gt;template&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;cd&lt;/span&gt; ray-template &amp;amp;&amp;amp; sh run.sh&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上运行方式会在跑example的过程中在本地拉起Ray集群，example运行结束后自动关闭Ray集群。如果你想让应用连接已有的Ray集群，可以按如下方式启动：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ray start --head&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;RAY_ADDRESS=127.0.0.1:6379 sh run.sh&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;测试结束后可以通过stop命令关闭ray集群，避免残留进程：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;ray&lt;/span&gt; stop&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在，你可以开始基于模版工程开发自己的C++分布式系统了！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h2&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;本文通过一个存储系统的例子介绍了如何利用Ray C++ API构建分布式系统，整个demo代码不过200多行，却同时解决了部署、调度、通信、故障恢复和运维监控等问题。我们可以发现，Ray致力于解决分布式系统的通用问题，不限制你的计算范式和应用场景，无论是针对新建应用还是已有的应用，都可以通过Ray快速升级为强大的分布式系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;联系我们&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;了解更多细节，请阅读 &lt;/span&gt;&lt;span&gt;Ray官方文档 https://docs.ray.io/en/master/index.html&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;贡献代码，可以直接提PR到 https://github.com/ray-project/ray&lt;/span&gt;&lt;span&gt;，或者给我们提issue&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;您也可以通过slack联系我们，加入Ray的&lt;/span&gt;&lt;span&gt;channel&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;微信公众号：搜索并关注“Ray中文社区”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;关于我们&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们是蚂蚁计算智能技术部团队，横跨美国硅谷、中国北京、上海、杭州和成都。我们追求的工程师文化是开放、简单、迭代、追求效率、用技术解决问题！热情相邀加入我们！！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;请联系我们的邮箱：antcomputing@antgroup.com&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0080ab83a62b2f5d62d0ad6a16e063f4</guid>
<title>CQRS 是个什么东东？</title>
<link>https://toutiao.io/k/8tb0cdi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;概述&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从一开始，软件系统就被用于各种用途，针对它们的需求也随着时间的推移而增长。需求的变更可能与业务逻辑、伸缩性或系统的其他方面有关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了满足这些相互矛盾或重叠的需求，工程师必须在设计系统时做出各种各样的权衡。问题在于，很多权衡在一开始并不是必需的，而当需要做出权衡时，系统已经演变成到无法做出权衡的地步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我看来，最有害的设计锁定通常发生在数据层。在设计典型的应用程序数据模型时，通常会结合考虑领域知识与性能因素。领域知识规定了实体是什么以及它们在逻辑上如何相互关联，性能因素决定了它们是如何在物理层面实现的（例如：采用关系型数据库还是 NoSQL 数据库、主键、索引等)。这两个方面的选型让应用程序能有效地为目标场景提供服务。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5214285714285715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PxMzT0Oibf4iaIJLPQmGX1J65iaScBuwFiaUBxoZbF88qNVibia1TPibddfibpprmwpBYTBONiaEYrHxtaIahKmva7Q1WQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;560&quot;/&gt;&lt;figcaption&gt;数据及其不同的视图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在拥有大量数据和复杂实体模型的大型应用程序中，一些实现细节随着时间推移变成了“核心”部分。有时候，这些东西是工程师在很明确的情况下完成的，但更多的是以一种隐式甚至是无意的方式发生。于是，新需求可能与现有的实现不一致，以至于根本无法很好地容纳它们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这类问题在不同的情况下需要不同的解决方案。在本文中，我将重点关注一种情况，即从应用程序读取数据的方式与向系统写入数据的方式非常不同时所出现的问题。这里的不同点可以是指查询模式、输出格式或规模方面的不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在这篇文章里写了自己所遇到的这种情况。我当时正在开发的订单管理系统使用了实体 ID (订单 ID、商品 ID 等)，但是随着时间推移，出现了一些复杂的读取需求，我们的数据模型无法支持这些需求。问题出在两个方面：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一方面，现有的实现很难有效地满足新的查询模式。另一方面，订单数据的读取方希望有一种截然不同的数据模型。例如，电子商务平台上的卖家希望他们的大客户数据切片能以特定的方式来呈现，而面向客户的应用程序希望数据看起来与购物车中的样子一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况并不少见，特别是对于拥有核心实体的系统。它们封装的数据被广泛使用，因此需要提供多种不同的格式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，我们该如何弥合这一鸿沟？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CQRS&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CQRS 是 &lt;code&gt;“命令查询责任分离”（Command Query Responsibility Segregation）&lt;/code&gt; 的缩写。在基于 CQRS 的系统中，命令 (写操作) 和查询 (读操作) 所使用的数据模型是有区别的。命令模型用于有效地执行写 / 更新操作，而查询模型用于有效地支持各种读模式。通过领域事件或其他各种机制将命令模型中的变更传播到查询模型中，让两个模型之间的数据保持同步。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.806146572104019&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PxMzT0Oibf4iaIJLPQmGX1J65iaScBuwFiaUlLDCDasRNsnYP0kPG3p2KmMKECcGvw0AIF5eicNo7j5z6AQSEO6T4HQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;423&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你觉得它们看起来就像是两个不同的微服务，那么我来说一说它们之间的一个细微区别。从物理实现层面来看，这两个数据模型可以作为两个独立的微服务，甚至可以用一个命令模型来支持多个查询模型。但是，微服务架构的一个关键构造是两个微服务通常代表两个独立的领域，而在 CQRS 中，无论运行时架构是怎样的，命令模型和查询模型都属于同一逻辑领域。如果查询模型对命令模型一无所知，就无法发挥作用。这里的耦合是预期的，不同于微服务之间的解耦行为。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CQRS 并没有规定这两个模型如何保持同步。同步可以通过同时更新两个模型来同步实现，也可以通过消息代理（如 Kafka）将命令从命令模型传输到查询模型来异步实现。后一种比较常用，因为它让系统更加可伸缩，尽管它需要在写操作和读操作的最终一致性方面做出权衡。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38837920489296635&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PxMzT0Oibf4iaIJLPQmGX1J65iaScBuwFiaUdBBR85O3zOfpGTAOicsicnxmpvKoUSwwmP9LWoYa0kz9AlvmK4TGoL4w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;981&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;这不就是缓存吗？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只用于读取的数据模式看起来就像是一个缓存。事实上，查询模型可以使用 Redis 这样的缓存技术来实现。但是，CQRS 不只是为了分离数据的写入和读取，它的根本目的是为了实现数据的多重表示，每一种表示都能够满足某些用户的需求。CQRS 可能会有多种查询模式，每个模式可能使用不同的物理实现。有些可能使用数据库，有些可能使用 Redis，等等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么时候应该使用 CQRS&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一部分场景，CQRS 是一种非常有用的架构模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个是我在前面已经提到过的。如果同一个数据模型不能有效地满足系统的读和写模式，那么通过应用 CQRS 来解耦读写是很有意义的。解耦后的数据模型可以满足特定的需求。CQRS 有效地将单个数据表示变成任意数量的 (读) 表示，所有这些表示都与负责处理所有更新的核心表示保持一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;适用 CQRS 的第二个场景是将读负载与写负载分开。前面我讲了缓存和 CQRS 的区别，缓存并不是应用 CQRS 的目的。但是，通过分离命令模式和查询模式，就有了对单个模式进行伸缩的可能性。查询模型可以有自己的数据库和缓存，可以使用最适合某些特定场景的技术来实现。但不管怎样，命令模型的伸缩都不会受制于查询模型。我在这里需要重申的是，它们不是独立的系统，尽管它们之间有深度的耦合，但这不是问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么时候不该使用 CQRS&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在系统中使用 CQRS 会带来显著的认知负担和复杂性。开发人员必须面对至少两个数据模型和多种技术选择，所有这些都是不可忽略的负担。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个问题是如何保持命令模型和查询模型的数据同步。如果选择了异步方式，那么整个系统就要承担最终一致性所带来的后果。这可能非常麻烦，特别是当用户希望系统能够立即反映出他们的操作时，即使是单个一致性要求也会危及整个系统的设计。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们选择让模型在任何时候都保持一致，就会有 CAP 和两阶段提交问题。如果两个模型使用同一个支持 ACID 的数据库，我们可以通过事务来保持它们的一致性，但 CQRS 的很多可伸缩性优势就发挥不出来了。如果要支持多个查询模型，写操作将会越来越慢，因为需要更新所有的查询模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为这两个问题的存在，在选择是否使用 CQRS 时就要十分谨慎。如果使用得当，它可以极大提升应用程序的伸缩性。但是，支持多个数据模型并不是件容易的事，所以应该只在没有其他方法可以满足要求时才考虑这么做。&lt;/p&gt;&lt;hr/&gt;&lt;section data-width=&quot;100%&quot; data-opacity=&quot;1&quot; data-rotate=&quot;0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot; data-opacity=&quot;1&quot; data-rotate=&quot;0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot; data-opacity=&quot;1&quot; data-rotate=&quot;0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好了，今天的文章就到这里了，看完对你有没有收获呢？欢迎留言评论！&lt;/span&gt;&lt;span&gt;最后，&lt;/span&gt;&lt;span&gt;我是飘渺Jam，一名写代码的架构师，做架构的程序员，期待您的转发与关注，当然也可以通过下方二维码添加我的个人微信 &lt;/span&gt;&lt;span&gt;，咱们一起聊技术！&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PxMzT0Oibf4iaaq1LHN5nmBoW0HpH70QAzKz7kqcXajmMbhLkK7rc6CRLcKhybrXOkejBIMwTr56xxbGiameeNPEg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-opacity=&quot;1&quot; data-rotate=&quot;0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot; data-opacity=&quot;1&quot; data-rotate=&quot;0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot; data-opacity=&quot;1&quot; data-rotate=&quot;0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&amp;lt; END &amp;gt;&lt;/span&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p data-darkmode-bgcolor-162350995814910=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-162350995814910=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-162350995814910=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-162350995814910=&quot;#fff|rgb(63, 63, 63)&quot; data-style=&quot;margin-top: 15px; margin-bottom: 10px; padding-left: 8px; max-width: 100%; min-height: 1em; color: rgb(63, 63, 63); font-size: 16px; letter-spacing: 0.544px; text-align: left; white-space: normal; background-color: rgb(255, 255, 255); word-spacing: 2px; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__74&quot;&gt;&lt;strong data-darkmode-bgcolor-162350995814910=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-162350995814910=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-162350995814910=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-162350995814910=&quot;#fff|rgb(63, 63, 63)&quot;&gt;往期精选：&lt;/strong&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-162350995814910=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-162350995814910=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-162350995814910=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-162350995814910=&quot;#fff|rgb(63, 63, 63)&quot; data-style=&quot;margin-top: 15px; margin-bottom: 10px; padding-left: 8px; max-width: 100%; min-height: 1em; color: rgb(63, 63, 63); font-size: 16px; letter-spacing: 0.544px; text-align: left; white-space: normal; background-color: rgb(255, 255, 255); word-spacing: 2px; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__74&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&amp;amp;mid=2247496457&amp;amp;idx=1&amp;amp;sn=f5ba01dba3c7e142a7265a8e096da916&amp;amp;chksm=9ad3e948ada4605ed8617224ae1c0ab5ff846edace414485fb548b28138eb9ac70f57d50d497&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;慎入警告！某架构师去面试，被问到如何设计海量商品数据的存储？&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;慎入警告！某架构师去面试，被问到如何设计海量商品数据的存储？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-162350995814910=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-162350995814910=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-162350995814910=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-162350995814910=&quot;#fff|rgb(63, 63, 63)&quot; data-style=&quot;margin-top: 15px; margin-bottom: 10px; padding-left: 8px; max-width: 100%; min-height: 1em; color: rgb(63, 63, 63); font-size: 16px; letter-spacing: 0.544px; text-align: left; white-space: normal; background-color: rgb(255, 255, 255); word-spacing: 2px; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__74&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&amp;amp;mid=2247496350&amp;amp;idx=1&amp;amp;sn=c5a4cff02c33e68d0e6c6ec5680aa5f7&amp;amp;chksm=9ad3e8dfada461c941eee2d2d6c0a53edc6543ff1daadb14d9d9408bee129766cf8ff18e004b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;SpringBoot 生成接口文档，老鸟也被打脸了！&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;SpringBoot 生成接口文档，老鸟也被打脸了&lt;/span&gt;&lt;/a&gt;！&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>