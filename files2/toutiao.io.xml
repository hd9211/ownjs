<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f2714a6e862ac70abccad2990f481e92</guid>
<title>成为更好的开发者！行动起来！</title>
<link>https://toutiao.io/k/bcodelm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>97d72055849a1c945d703331855d2615</guid>
<title>程序员必知的分布式容错和降级技术</title>
<link>https://toutiao.io/k/wl65hu4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1379310344827587&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XJlI2e4PlFCAo31qnIMbDbZYjZiaoMc13vKFLjK6kut61aP4k8Uxmzic3FzFMtZapG4jlyBmJMg0UOndMMRWaTLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;58&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;em data-mid=&quot;&quot;/&gt;&lt;p data-mid=&quot;&quot;&gt;可以参与抽奖&lt;/p&gt;&lt;em data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/em&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.2&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibl6u6nJ01g9icia42icDbWWvO2ObicnIUHjwQKVp30YzLS8xSInYupoEXAKjYeYDibY50CgKLz6ViaDjTjuRqUqaae0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;参与方式&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.2&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/K8beZoNWDcUm9I6ia4UU97K1XHrQx2PavruEm3xAL2W3Vd7JxrB8PLXtmT5JkwqpC9Dg9hEmtVZkY2hibnlkib0Qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;关注公众号：35岁程序员那些事，后台回复关键词“参与抽奖”，获取抽奖链接，点击抽奖。 中奖之后，可以联系笔者的微信号或者公众号后台回复关键词“联系笔者”，获取联系方式。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式容错和降级是微服务架构中应对瞬时大流量的最佳解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;推荐使用Spring Cloud Alibaba+Sentinel&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Nginx&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Nginx是一块轻量级的Web服务器/反向代理服务器，目前在github上Star 13.3k Fork 4.9k Watch 951，整体关注度也非常高，最近一次更新是2020年12月5日，最新的版本为release-1.19.6。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么如何使用Nginx进行应用的分布式容错和降级呢？答案就是Nginx+Lua可以实现分布式容错和降级，利用Lua脚本可以实现限流算法，并从应用接入层做容错和降级。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Guava&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Guava是一种基于开源的Java库，其中包含谷歌内部使用的很多核心库。这个库是为了方便编码，并减少编码错误。这个库提供了用于集合、缓存、支持原语、并发性、常见注解、字符串处理、I/O等实用方法API，这些都是谷歌开发者结合自身业务场景的最佳实践，可以说是一块非常优秀的开源中间件框架。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Guava - RateLimiter使用的是一种叫令牌桶的流控算法，RateLimiter会按照一定的频率往桶里扔令牌，线程拿到令牌才能执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Guava目前在github上Star 40k Fork 8.9k Watch 2.5k，最近一次更新是2020年12月15日，最新版本为30.1，无论是开源的关注度和活跃度都非常高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Redis&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis是互联网技术领域使用最为广泛的存储中间件，它是“Remote Dictionary Service”（远程字典服务）的首字母缩写。Redis以其超高的性能、完美的文档、简洁易懂的源码和丰富的客户端库支持在开源中间件领域广受&lt;/span&gt;&lt;span&gt;好评。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis采用C语言开发，目前在github上Star 47k Fork 18.5k Watch 2.7k，关注度也非常高，最近一次更新是2021年1月12日，目前最新版本为6.0.10，社区更新活跃度非常高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Redis中，有5种基础数据结构，分别为：string（字符串）、list（列表）、hash（字典）、set（集合）和zset（有序集合），合理的利用这些数据结构是可以达到分布式限流的效果，比如通过zset数据结构中的score值，来构造一个时间窗口，作为限流的滑动窗口，这样就可以快速的构造一个分布式限流算法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Hystrix&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Hystrix是Netflix公司开源的一款容错框架，包含常用的容错方法：线程池隔离、信号量隔离、熔断和降级回退。在高并发访问下，系统所依赖的服务的稳定性对系统的影响非常大，依赖有很多不可控的因素，比如网络连接变慢、资源突然繁忙、暂时不可用、服务宕机等。我们要构建稳定、可靠的分布式系统，就必须要有一套容错的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Hystrix目前在github上Star 20.9k fork 4.3k Watch 1.7k，可以说关注度非常高，但是最近一次版本更新是2018年11月17日，版本为v1.5.18，已经有两年没更新代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;Resilience4j&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Resilience4j 是一个比较轻量的熔断降级库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，Resilience4j 的模块化做的比较好，将每个功能点（如熔断、限速器、自动重试）都拆成了单独的模块，这样整体结构很清晰，用户也只需要引入相应功能的依赖即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，Resilience4jR是针对 Java 8 和函数式编程设计的，API 比较简洁优雅。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时，与 Hystrix 相比，Resilience4j 增加了简单的限速器和自动重试特性，使用场景更加丰富。Resilience4j 属于一个新兴项目，社区也在蓬勃发展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总的来说，Resilience4j 是比较轻量的库，在较小较新的项目中使用还是比较方便的。但是 Resilience4j 只包含限流降级的基本场景，对于非常复杂的企业级服务架构可能无法很好地 cover 住；同时 Resilience4j 缺乏生产级别的配套设施（如提供规则管理和实时监控能力的控制台）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Resilience4j目前在github上Star 6.4k Fork 857 Watch 215，最近一次版本更新是2020年10月19号，最新的release版本是v1.6.1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Sentinel&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Sentinel 一款面向分布式服务架构的轻量级流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统自适应保护等多个维度来帮助用户保障服务的稳定性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Sentinel 的核心思想：根据对应资源配置的规则来为资源执行相应的流控/降级/系统保护策略。在 Sentinel 中资源定义和规则配置是分离的。用户先通过 Sentinel API 给对应的业务逻辑定义资源，然后可以在需要的时候动态配置规则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Sentinel 的优势和特性：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;轻&lt;/span&gt;&lt;span&gt;量级，核心库无多余依赖，性能损耗小；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;方便接入，开源生态广泛。&lt;/span&gt;&lt;span&gt;Sentine&lt;/span&gt;&lt;span&gt;l &lt;/span&gt;&lt;span&gt;对&lt;/span&gt;&lt;span&gt; Dubbo&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Spring Cloud&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Web Servlet&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;gRPC &lt;/span&gt;&lt;span&gt;等常用框架提供适配模块，只需引入相应依赖并简单配置即可快速接入；&lt;/span&gt;&lt;span&gt;同时针对自定义的场景&lt;/span&gt;&lt;span&gt; Sentinel &lt;/span&gt;&lt;span&gt;还提供低侵入性的注解资源定义方式，方便自定义接入；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;丰富的流量控制场景。&lt;/span&gt;&lt;span&gt;Sentinel &lt;/span&gt;&lt;span&gt;承接了阿里巴巴近&lt;/span&gt;&lt;span&gt; 10 &lt;/span&gt;&lt;span&gt;年的双十一大促流量的核心场景，流控维度包括流控指标、流控效果（塑形）、调用关系、热点、集群等各种维度，针对系统维度也提供自适应的保护机制；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;易用的控制台，提供实时监控、机器发现、规则管理等能力；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;完善的扩展性设计，提供多样化的 SPI 接口，方便用户根据需求给 Sentinel 添加自定义的逻辑。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;对比以上几种解决方案&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Nginx和Redis具备一定的分布式容错和降级能力，但是从功能完整性角度肯定是不如Sentinel、Hystrix和Resilience4j，Guava虽然也具备容错和降级能力，但是不具备分布式能力，它是基于单实例JVM的。基于以上原因，这里就对比下Sentinel、Hystrix和Resilience4j。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Sentinel&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Hystrix&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Resilience4j&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;隔离策略&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;信号量隔离（并发线程数限流）&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;线程池隔离/信号量隔离&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;信号量隔离&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;熔断降级策略&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;基于响应时间、异常比率、异常数&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;基于异常比率&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;基于异常比率、响应时间&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;实时指标实现&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;滑动窗口（LeapArray）&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;滑动窗口（基于RxJava）&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Ring Bit Buffer&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;动态规则配置&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持多种数据源&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持多种数据源&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;有限支持&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;扩展性&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;多个扩展点&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;插件形式&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;SDK形式&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;基于注解的支持&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;限流&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;基于QPS限流和基于调用关系限流&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;有限的支持&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;Rate Limiter&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;流量整形&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持预热模式、匀速器模式和预热排队模式&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;不支持&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;简单的Rate Limiter模式&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;系统自适应保护&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;不支持&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;不支持&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;控制台&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;提供开箱即用的控制台，可配置规则、查看秒级监控、机器治理等。&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;简单的监控查看&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;不提供控制台，可对接其它监控系统。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;常见框架适配&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;Servlet、HttpClient、Dubbo、Spring Web等&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;Servlet、Spring Cloud Netflix&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;部分支持&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐使用Spring Cloud Alibaba+Sentinel，可以从服务治理和流量治理，两重维度去治理微服务，高效、简单并且符合主流。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>76da670a0e6cbc43c400a48d0b2c2a5d</guid>
<title>阿里巴巴开源的低代码引擎</title>
<link>https://toutiao.io/k/gsosp6w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>71f55c8a2335c845900e30be0385c0b8</guid>
<title>行业实践-Apache Flink 在移动云实时计算的实践</title>
<link>https://toutiao.io/k/4zaegp9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;span&gt;&lt;span&gt;▼ 关注「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Apache Flink&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」，获取更多技术干货 &lt;span&gt;▼&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU3Mzg4OTMyNQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/8AsYBicEePu6FJHxaI14AsXuzeg4SybT0hiaCSohrIY75oiaOMzhQU7RouiafjNa76k2CtD6xxB2JqnawqFqV3zg3A/0?wx_fmt=png&quot; data-nickname=&quot;Apache Flink&quot; data-alias=&quot;apacheflinkcc&quot; data-signature=&quot;Flink 中文社区官微，Flink PMC 维护&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;摘要&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;本文整理自移动软件开发工程师谢磊在 Flink Forward Asia 2021 平台建设专场的演讲。本篇内容主要分为四个部分：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;实时计算平台建设&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;中移信令业务优化&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;稳定性实践&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;未来方向的探索&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Tips：&lt;/strong&gt;点击&lt;/span&gt;&lt;span&gt;&lt;strong&gt;「阅读原&lt;/strong&gt;&lt;strong&gt;文」&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;查看原文视频 &amp;amp; 演讲PDF～&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n105&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaicTdI1oDK7yFxKWpKX6KICTskSFfHERMZqrTk90NRyzwLbib9ica3Lo3g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;中移（苏州）软件技术有限公司是中国移动通信有限公司的全资子公司，公司定位为中国移动云设施的构建者、云服务的提供者、云生态的绘制者。公司以移动云为运营中心，产品和服务在电信、政务、金融、交通等领域都有广泛应用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p cid=&quot;n107&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;一、实时计算平台介绍&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2 cid=&quot;n107&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p cid=&quot;n12&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaSibEYHjILFpDKQT1KM5RkiaflpeO6GyWicMgaLb4tIwGedEbGSblKcedg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;实时计算引擎在移动云的演进分为几个阶段：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;2015 年到 16 年，我们使用的是第一代实时计算引擎 Apache Storm；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;17 年我们开始调研 Apache Spark Streaming，它可以与自研框架进行整合，降低了运维压力和维护成本；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;18 年，用户对云计算的需求越来越多，Storm 和 Spark已经无法很好地满足业务。同时我们研究了流计算比较出名的几篇文章，发现 Apache Flink 已经比较完整地具备了文中提到的一些语义；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;19 年 - 20 年，我们开始实现云服务，并把实时计算平台上线至公有云和私有云；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;20 年 - 21 年，我们开始调研实时数仓，并将 LakeHouse 上线移动云。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n14&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaMVSQzAbcOIgflHM6gQTiaibTrgwtPuKEKOiaaLGIy8CKZ106ibrFIoLtVg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;目前 Flink 主要用于中移信令数字的处理、实时用户画像和埋点、实时数仓、实时运维监控、实时推荐以及移动云的数据管道服务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n16&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaHhTiayHjeG7X5OctEfMCs8ltTQ99ib5So6bupIYAiaBfwWxBRiaB1Ob7Iw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;中移的实时计算平台功能分为三大部分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一部分是服务管理，支持了任务生命周期的托管、Flink 和 SQL 作业、Spark Streaming 作业以及引擎多版本的支持；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二部分是 SQL 的支持，提供了在线 Notebook 编写、SQL 语法检测、UDF 管理和元数据管理；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第三部分是任务运维，支持实时任务的日志检索、实时性能指标采集以及消息延迟报警和任务反压报警等。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文主要分享两个核心设计：引擎多版本的设计和实时任务日志检索。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n19&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaBeTWgzLibT5uxOhndeqCwib368lNHvz5d5kfyvOX8qYziblnktm0Eicuhg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在日常有任务场景中，我们发现用户程序调试成本比较高，用户尝试新版本引擎的周期也比较长，此外无法规避用户 hack 引擎的功能以及有些任务运行失败但是没有异常信息，因此我们引入了引擎多版本设计。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;多版本提交的流程如下：用户的任务首先会提交到 rtp 服务，rtp 服务将用户程序上传到 HDFS 保存，需要提交的时候再从 HDFS 拉回来提交到 Yarn 集群。此类任务存在一个共性——作业中包含 Apache Flink 的核心包，这会导致很多问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n22&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiabxg1sZtwFovEYXFlp2n3Cjm4iaeIFiaJ4L01gGrQticvQ2sBJPTb31Nfg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;因此，首先我们会与业务沟通，使作业包里面不包含 Flink 的 core 包，但是这样的收益比较小，所以我们在平台侧做了一次检测，在用户在上传 jar 包的过程中主动检测用户包里是否包含 core 包。如果发现作业包含了非法核心包，则会阻止用户提交。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如此简单的操作，却为公司带来了很大的收益：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一，极大降低了一些低价值 bug 的定位成本；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二，作业升级和回退版本更加方便；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第三，提高了作业的稳定性和安全性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n25&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaya9EMV5Bj5KaV1JVic8hjhVA5hcGkpxibpuGcUBerBwTE64P3RqL3KFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在日常业务场景中，我们需要通过日志检索来验证流程的复杂逻辑。此外，原生 TM 的 UI 日志打不开，容易卡死。以及 TM UI 不支持检索，如上图所示，当业务逻辑非常复杂的时候，Flink UI 无法提供以上功能。因此我们设计了实时任务日志检索功能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n27&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaickibr1hK5bR6icJLafcuH0r3ne04d1wMt2FRma6bKG9G2FEraUncJMGQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实时任务日志检索的设计上需要考虑以下几个问题：如何采集作业程序日志，并将 TM 分布在不同的机器上？如何不侵入作业进行采集日志？如何限制作业打印大量无用日志？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;针对第一个问题，我们采用的push模式来降低采集日志的压力；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;针对第二个问题，参考 spring 中的 AOP 机制，我们使用 AspectJWeaver，切入点是 log4j 的 input 或 event，之后把日志发送到 Sender；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;针对第三个问题，我们采用的是 RateLimiter 来进行限流。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n32&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaytr52sy9yhZoYlhia3lkO2ibr55MKy2MINxhibGWIEoUdFFcvSfVrUENw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上图是实时任务日志检索的整体设计。我们在原生的 TaskManager 下面加了 AOP 层，日志会先通过 TaskManager 发送 task，再发送到 AOP。整个 AOP 对用户无感知，因为采用了切面的方式。之后再发送到 RateLimiter，再到 Sender，由 RateLimiter 进行限流的操作。接着日志继续发送到 Kafka，做检索的时候日志会被发送到 Elestic Search。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n34&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiagXbrCWxdnic9qV2QibjNdiaic2iceI7UR3FvxicLY6EeXKRh456SQhjWmc3Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有了实时任务日志检索之后，业务程序不需要做任何改动就可以支持日志的检索。同时，开发人员可以便捷地验证业务逻辑。得益于限流措施，也不会存在日志存储瓶颈。此外，也减轻了平台管理的压力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p cid=&quot;n211&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;二、中移信令业务优化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2 cid=&quot;n211&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p cid=&quot;n37&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCia2EibDopppjGYWs9D0fIG36icEVUdVp46wBlKSea2bA4icZywL7zKwGW0w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;中国移动信令业务的出现是为了解决各级政府部门有关于移动用户资源数据的需求，包括旅游部门、应急部门、交通行业等，如交通规划、交通调查、旅游景区等重点区域的人口流量监测、流动人口监测管理等等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;依赖于中国移动手机用户的高覆盖率，利用移动通信网络区域服务技术以及 GIS 技术，通过对移动用户信令数据的统计，对城市人口数量、流动性等要素进行分析预测，为城市规划、交通规划、管理、资源配置、外来人口管理、政策制定等政府管理行为提供决策数据支持。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n40&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaF1IIW1fXEMibKURLIqHV2grQyQ8VXB5jrUTTQgZ0gNV4mE6GEUfTIxw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;业务日均数据大概是 10PB，20 万亿/天，单条数据大小 0.5KB，包含了 2345G 上网数据、位置信令、省份城市、网络类型、接口类型等等。数据处理也比较复杂，要做数据加密、压缩以及版本的统一等。上图是处理信令数字时的条件和业务逻辑等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n42&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaDoy9dwFSVYQ7OcexrCQd33aPHZ8Rlw1z2Aw2doMvichz7WIf2ibWHEOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;将需求化繁为简，应对到集群上，就是一个上报网关。它会将各地的信令数据进行上传，由 Flume 集群进行数据接收，再传输到 Hadoop 集群。上图可以看到，Flume 与 Hadoop 之间存在一面物理墙。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p cid=&quot;n44&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaQS3DqfmYNVs8NO9XN6qZtcKDppz7nbYicjRZL8ia3hu7BGj9mTUkYHog/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着数据量增大，我们也遇到了很多问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一，Flume 集群会一直报警提示 Flume channel full；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二，防火墙超限，也会进行报警；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第三，Flume 在写 Kafka 的时候，Kafka 发送端会发送超时报警；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第四，下游处理信令数据的时候，Spark Streaming 处理是不稳定的。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n46&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiauvBeLQTssCxO4WvFbW4rQ89RoAMjzLxPRaRricA4iauLibGc5AHBaLxMQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上述问题总结起来可以分为两大类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一类是写入性能问题。Kafka 在写入的时候频繁超时，生产性能存在瓶颈。以及 Flume 在发送数据时无法达到网卡的上限速度；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二类是架构设计问题。&lt;span&gt;架构涉及的组件比较多导致维护的成本比较高；此外，组件职责不清晰，比如 Flume 中存在数据清洗的逻辑；还有 Spark 逻辑和处理逻辑复杂，存在多处 shuffle，处理性能不稳定。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n50&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaPJu8VeibGtwpkRKHBtRscyrkib0u9naG9rLN2u0Qry4mQicoPkkUaDXOg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先要解决的是 PRO 写入 Kafka 超时的问题。为了解决这个问题，我们进行了以下优化：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;优化了防火墙端口；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;优化了 Kafka 服务器的一些性能参数；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在 Kafka 服务器端进行了一些性能参数调优。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是这并不能彻底解决 Flume 写入 Kafka 超时的问题，于是我们把重点聚焦到客户端。首先是客户端的参数如何优化，尤其是 batch.size、buffer.memory 和 request.time.out 如何调优。其次是如何达到单机网络最大数网速，即单机情况下设置多少客户端并发合适。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n56&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiavwz4q01BkNIOFnT21LCnYAiaC5xf5ICCUcBuxUqibQhQfdLcBYmpUS2g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;经过实践我们发现，当 batch.size 为 256 兆，buffer.memory 为 128 兆时，性能会达到最优，但此时并没有达到网卡的最大速度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n58&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaQoGFtRq2nicFicJlPSHCOqodD1K8WcVOL4GN3sb406zfY3XElk2fVNYA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;于是我们进行了第二轮测试，增加了 compression.type，期望通过压缩发送的数据来提高发送带宽，但是结果并不符合我们的期望。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这是由于 Kafka 在低版本的时候存在一个问题，参数在它的验证脚本里的每个值都是一样的，所以它的压缩比会比较大。但是实际的生产环境中每条数字都是不一样的，所以压缩比非常小。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n61&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaOCmZxB6T79UT5pvMLWAPy4mQqPJJwsiauc2ThibzOdmaHLB9sCErzANA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外一个问题是如何达到网卡的最大速度？最简单的方式是增加并行度，但是并行度并不是越大越好。经过实践发现，并发度为 4 的时候能达到网卡的最大速度，超过 4 以后平均耗时会明显增加，也会导致 Kafka 写入超时。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n63&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiazcymdg4fe6ZsNL62ibgHZfHqmORXfUDlTPibRI71uEMmhiaGLUwOCt7fQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第二点是 Flume channel full 的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;扩展服务的时候，服务的事务 API 处理是比较底层的，需要手动进行处理。此外服务的事务处理数据的时候，需要将数据进行拷贝。如上图所示，当数据从 source 发送到 channel 的时候，会把一份数据先 copy 到内存里，从 channel 再发送到 sink 的时候，又会从 channel 再 copy 到内存。这个过程中的两次 copy 浪费了资源。而 Flink 做事务的时候是借助于状态管理，因而它的处理性能是比较稳定的。另外，Flink 拥有丰富的 source 和 sink，扩展性比较强。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n66&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaickpibjGKJDASLQ2ssQf27BXLlBINe6UibLFaGFmqzO48YddHKjDB2Vrg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此，我们决定使用 Flink 代替 Flume 来解决问题。替换成 Flink 以后，提升了采集性能，解决了海量数据发送性能瓶颈，稳定性显著提高。同时，明确了组件职责，我们将原有的服务中存在的逻辑全部转移至后端实时数据分解，让采集层专注于数据汇聚，处理层专注于数据分拣。另外，我们统一了技术栈，端到端采用了 Flink 框架，获得了更高的性能，也降低了开发和运维成本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最终整体性能提升了 1/3 且降低了维护成本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p cid=&quot;n294&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;三、稳定性实践&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2 cid=&quot;n294&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p cid=&quot;n70&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaGxswW4dBbkRuhM6VryIRPsHicicj3YKicqXS2R31mz1zAPiaiaibuANzDXrw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作业稳定性主要指服务故障以及处理方案，服务故障主要包括作业运行失败、作业消费延迟、作业出现 OOM 以及作业异常重启。对应的处理方案是可以将作业进行物理隔离，服务进行降级，加强资源监控以及对服务进行拆分。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而平台维护人员最关心的是整体性的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n73&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaS78pZkA1ib4E2Xg54N5UkAdUTH7mS85JLibxnvzbeia65JSeoR23v8vOQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果 ZooKeeper 集群中有一台服务器出现了网络服务瞬断，它也会引起大批量的任务重启。Flink JobManager 会通过 ZooKeeper 来进行 leader 的选举和发现 CheckpointID 的计数器管理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n75&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaiaOasARggkxiaxldQQro51xJ9313eNcbIaicoRRBsleKiafLyAZo1o7WGw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;于是我们分析了 ZooKeeper 网络状态的转换。客户端在连接 ZooKeeper 集群的时候，它的状态先是 connected 状态，网络瞬断后它会变成 Suspended 状态，Suspended 状态会转换为 lost 状态，还会继续转换为 reconnected 状态。Flink 在使用 ZooKeeper 的时候会依赖一个 curator2.0 组件，然而这个组件存在一个缺陷，遇到 Suspended 状态就会直接将 leader 丢弃，这会导致大部分作业进行重启，这对于我们的业务来说是不可接受的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n77&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaV1dr19kNh7kElyMaXsVcPVu3zvuh7nDXJI4tgahbibNDa3FfruicD9oA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;官方直到 Flink 1.14 版本才对此问题进行修复。在之前的版本下，需要重新写 LeaderLatch，同时如果使用的是 Flink 1.8 版本，还需要同时修改 ZooKeeperCheckpointIDCounter。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p cid=&quot;n316&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;四、未来方向的探索&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2 cid=&quot;n316&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p cid=&quot;n80&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCianrVq2cX16AiccaVduIs3wHldwAeq3Daic63HU5iaRKotHGPiccwq0ZdZMA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;未来，我们主要会在这两个方向进行持续探索：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一，资源利用方向。包括 Elastic Scaling 调研和 K8s Yunikorn 资源队列调研。我们发现 Flink 上云之后存在着资源队列的问题，所以需要将用户的资源进行分队列管理；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二，数据湖方向。&lt;span&gt;首先是统一流批服务网关，做实时数仓的时候可能会采用不同的引擎，比如 Flink 和 Spark，它们属于两套不同的服务，所以需要做统一流批的服务网关。其次是数据血缘、数据资产和数据质量服务化。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;往期精选&lt;/p&gt;&lt;/section&gt;&lt;img data-ratio=&quot;2&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8AsYBicEePu618icsCRqdhl723vSPl4FCiavs1wZVIo7nOPuhVkV0Kicx3blfX3YMugVCXiabaR0K1XZAiaD0Ca05GHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;50&quot;/&gt; &lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3Mzg4OTMyNQ==&amp;amp;mid=2247495939&amp;amp;idx=1&amp;amp;sn=bf8ce5292bc685425a829831355cd558&amp;amp;chksm=fd387f41ca4ff657c57c77aca6bdc99de9aec00c1a40bc9c3e533be1ffdfa5cf6d7ee3de3516&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;联通实时计算平台演进与实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4255556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaVI3TPMGC3avOMpELzOH1ppdzkXAk6xz6Xs6vpo59K4hNatdPP25oAw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3Mzg4OTMyNQ==&amp;amp;mid=2247495906&amp;amp;idx=1&amp;amp;sn=8806069228df05ec3633de7a1e305227&amp;amp;chksm=fd387ea0ca4ff7b61fcde0d8b7b051b2ce91fa3bbda96789d9dc62fe1fb08077eb5a2d16e626&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4255556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaukXBfgnr0IgInXqXKyafGHj3hEFhysHCkibM13AznToSHzLrMkIrBcA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3Mzg4OTMyNQ==&amp;amp;mid=2247495878&amp;amp;idx=1&amp;amp;sn=d63bdeb4c790faf999bc038cd19131d5&amp;amp;chksm=fd387e84ca4ff792a0931917d19bbe6c28026f9ea09e0f1097b3626a84c851cb9afeaf763c0f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4255556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiakGvjYd3oOm6Y1diaUtPamXVhIBtGpvmwsibRYGzXurPWpKELEZzagquA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;更多 Flink 相关技术问题，可扫码加入社区钉钉交流群～&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100010716&quot; data-ratio=&quot;1.2078189300411524&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8AsYBicEePu6PUTQaA1BP3Fb8uViccQpspmTibIYEfM7Wv6VACia9CDQfcN8huMVCafZ5s36wThUmbYRTOzMu4hd8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;972&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-fileid=&quot;100010714&quot; data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Z6bicxIx5naLWBBEcl44aIic1Mthe1nZiaramW5s4e8WwyCYYbTzu6uPBpgI6sxNXNymEnOYKpJpcrItUia7lS64mA/640?wx_fmt=gif&quot;/&gt;  &lt;/span&gt;&lt;strong&gt;&lt;span&gt;戳我，查看原文视频&amp;amp;演讲PDF～&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b56bb29d58b53a1f089c088b27afaade</guid>
<title>91.6K 的 Axios 项目有哪些值得借鉴的地方</title>
<link>https://toutiao.io/k/z9a31ne</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Axios 是一个基于 Promise 的 HTTP 客户端，同时支持浏览器和 Node.js 环境。它是一个优秀的 HTTP 客户端，被广泛地应用在大量的 Web 项目中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阅读完本文，你将了解以下内容：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;HTTP 拦截器的设计与实现；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HTTP 适配器的设计与实现；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何防御 CSRF 攻击。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们从简单的开始，先来了解一下 Axios。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;一、Axios 简介&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Axios 是一个基于 Promise 的 HTTP 客户端，拥有以下特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;支持 Promise API；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;能够拦截请求和响应；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;能够转换请求和响应数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端支持防御 CSRF 攻击；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同时支持浏览器和 Node.js 环境；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;能够取消请求及自动转换 JSON 数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在浏览器端 Axios 支持大多数主流的浏览器，比如 Chrome、Firefox、Safari 和 IE 11。此外，Axios 还拥有自己的生态：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22685185185185186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8RrZlXlKCGTZqlmNMEia7MFJvWsJVq6gzaaTOyTKDxGfXIrhNcY8icO33Ww/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（数据来源 —— https://github.com/axios/axios/blob/master/ECOSYSTEM.md）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单介绍完 Axios，我们来分析一下它提供的一个核心功能 —— 拦截器。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;二、HTTP 拦截器的设计与实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;2.1 拦截器简介&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于大多数 SPA 应用程序来说， 通常会使用 token 进行用户的身份认证。这就要求在认证通过后，我们需要在每个请求上都携带认证信息。针对这个需求，为了避免为每个请求单独处理，我们可以通过封装统一的 &lt;code&gt;request&lt;/code&gt; 函数来为每个请求统一添加 token 信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但后期如果需要为某些 GET 请求设置缓存时间或者控制某些请求的调用频率的话，我们就需要不断修改 &lt;code&gt;request&lt;/code&gt; 函数来扩展对应的功能。此时，如果在考虑对响应进行统一处理的话，我们的 &lt;code&gt;request&lt;/code&gt; 函数将变得越来越庞大，也越来越难维护。那么对于这个问题，该如何解决呢？Axios 为我们提供了解决方案 —— 拦截器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Axios 是一个基于 Promise 的 HTTP 客户端，而 HTTP 协议是基于请求和响应：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.298&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8RrV5Em4ECwHynNEKTibfKiceMTGLfoXfpIuIkR67S4NdHX8YE1BQXFJP0w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 Axios 提供了请求拦截器和响应拦截器来分别处理请求和响应，它们的作用如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;请求拦截器：该类拦截器的作用是在请求发送前统一执行某些操作，比如在请求头中添加 token 字段。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;响应拦截器：该类拦截器的作用是在接收到服务器响应后统一执行某些操作，比如发现响应状态码为 401 时，自动跳转到登录页。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Axios 中设置拦截器很简单，通过 &lt;code&gt;axios.interceptors.request&lt;/code&gt; 和 &lt;code&gt;axios.interceptors.response&lt;/code&gt; 对象提供的 &lt;code&gt;use&lt;/code&gt; 方法，就可以分别设置请求拦截器和响应拦截器：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 添加请求拦截器&lt;/span&gt;&lt;br/&gt;axios.interceptors.request.use(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  config.headers.token = &lt;span&gt;&#x27;added by interceptor&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; config;&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 添加响应拦截器&lt;/span&gt;&lt;br/&gt;axios.interceptors.response.use(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;data&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  data.data = data.data + &lt;span&gt;&#x27; - modified by interceptor&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; data;&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么拦截器是如何工作的呢？在看具体的代码之前，我们先来分析一下它的设计思路。Axios 的作用是用于发送 HTTP 请求，而请求拦截器和响应拦截器的本质都是一个实现特定功能的函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以按照功能把发送 HTTP 请求拆解成不同类型的子任务，比如有用于处理请求配置对象的子任务，用于发送 HTTP 请求的子任务和用于处理响应对象的子任务。当我们按照指定的顺序来执行这些子任务时，就可以完成一次完整的 HTTP 请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解完这些，接下来我们将从 &lt;strong&gt;「任务注册、任务编排和任务调度」&lt;/strong&gt; 三个方面来分析 Axios 拦截器的实现。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;2.2 任务注册&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过前面拦截器的使用示例，我们已经知道如何注册请求拦截器和响应拦截器，其中请求拦截器用于处理请求配置对象的子任务，而响应拦截器用于处理响应对象的子任务。要搞清楚任务是如何注册的，就需要了解 &lt;code&gt;axios&lt;/code&gt; 和 &lt;code&gt;axios.interceptors&lt;/code&gt; 对象。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/axios.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createInstance&lt;/span&gt;(&lt;span&gt;defaultConfig&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt; Axios(defaultConfig);&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; instance = bind(Axios.prototype.request, context);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Copy axios.prototype to instance&lt;/span&gt;&lt;br/&gt;  utils.extend(instance, Axios.prototype, context);&lt;br/&gt;  &lt;span&gt;// Copy context to instance&lt;/span&gt;&lt;br/&gt;  utils.extend(instance, context);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; instance;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Create the default instance to be exported&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; axios = createInstance(defaults);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Axios 的源码中，我们找到了 &lt;code&gt;axios&lt;/code&gt; 对象的定义，很明显默认的 &lt;code&gt;axios&lt;/code&gt; 实例是通过 &lt;code&gt;createInstance&lt;/code&gt; 方法创建的，该方法最终返回的是 &lt;code&gt;Axios.prototype.request&lt;/code&gt; 函数对象。同时，我们发现了 &lt;code&gt;Axios&lt;/code&gt; 的构造函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/core/Axios.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Axios&lt;/span&gt;(&lt;span&gt;instanceConfig&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.defaults = instanceConfig;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.interceptors = {&lt;br/&gt;    &lt;span&gt;request&lt;/span&gt;: &lt;span&gt;new&lt;/span&gt; InterceptorManager(),&lt;br/&gt;    &lt;span&gt;response&lt;/span&gt;: &lt;span&gt;new&lt;/span&gt; InterceptorManager()&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在构造函数中，我们找到了 &lt;code&gt;axios.interceptors&lt;/code&gt; 对象的定义，也知道了 &lt;code&gt;interceptors.request&lt;/code&gt; 和 &lt;code&gt;interceptors.response&lt;/code&gt; 对象都是 &lt;code&gt;InterceptorManager&lt;/code&gt; 类的实例。因此接下来，进一步分析 &lt;code&gt;InterceptorManager&lt;/code&gt; 构造函数及相关的 &lt;code&gt;use&lt;/code&gt; 方法就可以知道任务是如何注册的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/core/InterceptorManager.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;InterceptorManager&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.handlers = [];&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;InterceptorManager.prototype.use = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;use&lt;/span&gt;(&lt;span&gt;fulfilled, rejected&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.handlers.push({&lt;br/&gt;    &lt;span&gt;fulfilled&lt;/span&gt;: fulfilled,&lt;br/&gt;    &lt;span&gt;rejected&lt;/span&gt;: rejected&lt;br/&gt;  });&lt;br/&gt;  &lt;span&gt;// 返回当前的索引，用于移除已注册的拦截器&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.handlers.length - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过观察 &lt;code&gt;use&lt;/code&gt; 方法，我们可知注册的拦截器都会被保存到 &lt;code&gt;InterceptorManager&lt;/code&gt; 对象的 &lt;code&gt;handlers&lt;/code&gt; 属性中。下面我们用一张图来总结一下 &lt;code&gt;Axios&lt;/code&gt; 对象与 &lt;code&gt;InterceptorManager&lt;/code&gt; 对象的内部结构与关系：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36944444444444446&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8Rr6X41s2fQrIMwmnvc2eGgtMgTOYPKcq4Ljibt4hPMZKpgPFHfKYSib4Sg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;2.3 任务编排&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们已经知道如何注册拦截器任务，但仅仅注册任务是不够，我们还需要对已注册的任务进行编排，这样才能确保任务的执行顺序。这里我们把完成一次完整的 HTTP 请求分为处理请求配置对象、发起 HTTP 请求和处理响应对象 3 个阶段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们来看一下 Axios 如何发请求的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;axios({&lt;br/&gt;  &lt;span&gt;url&lt;/span&gt;: &lt;span&gt;&#x27;/hello&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;method&lt;/span&gt;: &lt;span&gt;&#x27;get&#x27;&lt;/span&gt;,&lt;br/&gt;}).then(&lt;span&gt;&lt;span&gt;res&lt;/span&gt; =&amp;gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;axios res: &#x27;&lt;/span&gt;, res)&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;axios res.data: &#x27;&lt;/span&gt;, res.data)&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过前面的分析，我们已经知道 &lt;code&gt;axios&lt;/code&gt; 对象对应的是 &lt;code&gt;Axios.prototype.request&lt;/code&gt; 函数对象，该函数的具体实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/core/Axios.js&lt;/span&gt;&lt;br/&gt;Axios.prototype.request = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;request&lt;/span&gt;(&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  config = mergeConfig(&lt;span&gt;this&lt;/span&gt;.defaults, config);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; chain = [dispatchRequest, &lt;span&gt;undefined&lt;/span&gt;];&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; promise = &lt;span&gt;Promise&lt;/span&gt;.resolve(config);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 任务编排&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.interceptors.request.forEach(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;unshiftRequestInterceptors&lt;/span&gt;(&lt;span&gt;interceptor&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    chain.unshift(interceptor.fulfilled, interceptor.rejected);&lt;br/&gt;  });&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.interceptors.response.forEach(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;pushResponseInterceptors&lt;/span&gt;(&lt;span&gt;interceptor&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    chain.push(interceptor.fulfilled, interceptor.rejected);&lt;br/&gt;  });&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 任务调度&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (chain.length) {&lt;br/&gt;    promise = promise.then(chain.shift(), chain.shift());&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; promise;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任务编排的代码比较简单，我们来看一下任务编排前和任务编排后的对比图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5194805194805194&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8Rrbbd0KNQHAppniblnic3LV8tY3HNr34y3cjVNCiaribABHttdsutYh0fYnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1078&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;2.4 任务调度&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任务编排完成后，要发起 HTTP 请求，我们还需要按编排后的顺序执行任务调度。在 Axios 中具体的调度方式很简单，具体如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; &lt;span&gt;// lib/core/Axios.js&lt;/span&gt;&lt;br/&gt;Axios.prototype.request = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;request&lt;/span&gt;(&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; promise = &lt;span&gt;Promise&lt;/span&gt;.resolve(config);&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (chain.length) {&lt;br/&gt;    promise = promise.then(chain.shift(), chain.shift());&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 chain 是数组，所以通过 while 语句我们就可以不断地取出设置的任务，然后组装成 Promise 调用链从而实现任务调度，对应的处理流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4064272211720227&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8RrGEhJn06UYia59qWyW9WahD8KZ6t4ibshrPKcgg5aia1TO8yHibPJDAxveQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1058&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来回顾一下 Axios 拦截器完整的使用流程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 添加请求拦截器 —— 处理请求配置对象&lt;/span&gt;&lt;br/&gt;axios.interceptors.request.use(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  config.headers.token = &lt;span&gt;&#x27;added by interceptor&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; config;&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 添加响应拦截器 —— 处理响应对象&lt;/span&gt;&lt;br/&gt;axios.interceptors.response.use(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;data&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  data.data = data.data + &lt;span&gt;&#x27; - modified by interceptor&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; data;&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;axios({&lt;br/&gt;  &lt;span&gt;url&lt;/span&gt;: &lt;span&gt;&#x27;/hello&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;method&lt;/span&gt;: &lt;span&gt;&#x27;get&#x27;&lt;/span&gt;,&lt;br/&gt;}).then(&lt;span&gt;&lt;span&gt;res&lt;/span&gt; =&amp;gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;axios res.data: &#x27;&lt;/span&gt;, res.data)&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍完 Axios 的拦截器，我们来总结一下它的优点。Axios 通过提供拦截器机制，让开发者可以很容易在请求的生命周期中自定义不同的处理逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，也可以通过拦截器机制来灵活地扩展 Axios 的功能，比如 Axios 生态中列举的 axios-response-logger 和 axios-debug-log 这两个库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考 Axios 拦截器的设计模型，我们就可以抽出以下通用的任务处理模型：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3054945054945055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8Rroqic2FNRDU5ZGvq9jQ47sxYjCnQ658mM93CSTTc8sfjteQNNoAQqaHg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;910&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;三、HTTP 适配器的设计与实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;3.1 默认 HTTP 适配器&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Axios 同时支持浏览器和 Node.js 环境，对于浏览器环境来说，我们可以通过 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 或 &lt;code&gt;fetch&lt;/code&gt; API 来发送 HTTP 请求，而对于 Node.js 环境来说，我们可以通过 Node.js 内置的 &lt;code&gt;http&lt;/code&gt; 或 &lt;code&gt;https&lt;/code&gt; 模块来发送 HTTP 请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了支持不同的环境，Axios 引入了适配器。在 HTTP 拦截器设计部分，我们看到了一个 &lt;code&gt;dispatchRequest&lt;/code&gt; 方法，该方法用于发送 HTTP 请求，它的具体实现如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/core/dispatchRequest.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;dispatchRequest&lt;/span&gt;(&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; adapter = config.adapter || defaults.adapter;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; adapter(config).then(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;onAdapterResolution&lt;/span&gt;(&lt;span&gt;response&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; response;&lt;br/&gt;  }, &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;onAdapterRejection&lt;/span&gt;(&lt;span&gt;reason&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.reject(reason);&lt;br/&gt;  });&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过查看以上的 &lt;code&gt;dispatchRequest&lt;/code&gt; 方法，我们可知 Axios 支持自定义适配器，同时也提供了默认的适配器。对于大多数场景，我们并不需要自定义适配器，而是直接使用默认的适配器。因此，默认的适配器就会包含浏览器和 Node.js 环境的适配代码，其具体的适配逻辑如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/defaults.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; defaults = {&lt;br/&gt;  &lt;span&gt;adapter&lt;/span&gt;: getDefaultAdapter(),&lt;br/&gt;  &lt;span&gt;xsrfCookieName&lt;/span&gt;: &lt;span&gt;&#x27;XSRF-TOKEN&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;xsrfHeaderName&lt;/span&gt;: &lt;span&gt;&#x27;X-XSRF-TOKEN&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getDefaultAdapter&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; adapter;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; XMLHttpRequest !== &lt;span&gt;&#x27;undefined&#x27;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;// For browsers use XHR adapter&lt;/span&gt;&lt;br/&gt;    adapter = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;./adapters/xhr&#x27;&lt;/span&gt;);&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; process !== &lt;span&gt;&#x27;undefined&#x27;&lt;/span&gt; &amp;amp;&amp;amp; &lt;br/&gt;    &lt;span&gt;Object&lt;/span&gt;.prototype.toString.call(process) === &lt;span&gt;&#x27;[object process]&#x27;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;// For node use HTTP adapter&lt;/span&gt;&lt;br/&gt;    adapter = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;./adapters/http&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; adapter;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;getDefaultAdapter&lt;/code&gt; 方法中，首先通过平台中特定的对象来区分不同的平台，然后再导入不同的适配器，具体的代码比较简单，这里就不展开介绍。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;3.2 自定义适配器&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实除了默认的适配器外，我们还可以自定义适配器。那么如何自定义适配器呢？这里我们可以参考 Axios 提供的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; settle = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;./../core/settle&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;myAdapter&lt;/span&gt;(&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 当前时机点：&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//  - config配置对象已经与默认的请求配置合并&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//  - 请求转换器已经运行&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//  - 请求拦截器已经运行&lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;// 使用提供的config配置对象发起请求&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 根据响应对象处理Promise的状态&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; response = {&lt;br/&gt;      &lt;span&gt;data&lt;/span&gt;: responseData,&lt;br/&gt;      &lt;span&gt;status&lt;/span&gt;: request.status,&lt;br/&gt;      &lt;span&gt;statusText&lt;/span&gt;: request.statusText,&lt;br/&gt;      &lt;span&gt;headers&lt;/span&gt;: responseHeaders,&lt;br/&gt;      &lt;span&gt;config&lt;/span&gt;: config,&lt;br/&gt;      &lt;span&gt;request&lt;/span&gt;: request&lt;br/&gt;    };&lt;br/&gt;&lt;br/&gt;    settle(resolve, reject, response);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 此后:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//  - 响应转换器将会运行&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//  - 响应拦截器将会运行&lt;/span&gt;&lt;br/&gt;  });&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上示例中，我们主要关注转换器、拦截器的运行时机点和适配器的基本要求。比如当调用自定义适配器之后，需要返回 Promise 对象。这是因为 Axios 内部是通过 Promise 链式调用来完成请求调度，不清楚的小伙伴可以重新阅读 “拦截器的设计与实现” 部分的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们已经知道如何自定义适配器了，那么自定义适配器有什么用呢？在 Axios 生态中，阿宝哥发现了 axios-mock-adapter 这个库，该库通过自定义适配器，让开发者可以轻松地模拟请求。对应的使用示例如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; axios = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;axios&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; MockAdapter = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;axios-mock-adapter&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 在默认的Axios实例上设置mock适配器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; mock = &lt;span&gt;new&lt;/span&gt; MockAdapter(axios);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 模拟 GET /users 请求&lt;/span&gt;&lt;br/&gt;mock.onGet(&lt;span&gt;&quot;/users&quot;&lt;/span&gt;).reply(&lt;span&gt;200&lt;/span&gt;, {&lt;br/&gt;  &lt;span&gt;users&lt;/span&gt;: [{ &lt;span&gt;id&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&quot;John Smith&quot;&lt;/span&gt; }],&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;axios.get(&lt;span&gt;&quot;/users&quot;&lt;/span&gt;).then(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;response&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(response.data);&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对 MockAdapter 感兴趣的小伙伴，可以自行了解一下 &lt;strong&gt;axios-mock-adapter&lt;/strong&gt; 这个库。到这里我们已经介绍了 Axios 的拦截器与适配器，下面阿宝哥用一张图来总结一下 Axios 使用请求拦截器和响应拦截器后，请求的处理流程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5703703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8Rr1maSvPU0SEtQ3Zfic9MFuiaSRx6n9G7obyic6fLh5MibuQ1TvENWriarQ1w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;四、CSRF 防御&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;4.1 CSRF 简介&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「跨站请求伪造」&lt;/strong&gt;（Cross-site request forgery），通常缩写为 &lt;strong&gt;「CSRF」&lt;/strong&gt; 或者 &lt;strong&gt;「XSRF」&lt;/strong&gt;， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了让小伙伴更好地理解上述的内容，阿宝哥画了一张跨站请求攻击示例图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;277&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8RrPibSnhKic2Jj4nIV2utblUK6JU3dJ1ZSkKTXWsEJJwwG8OyWRoUJJKtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中攻击者利用了 Web 中用户身份验证的一个漏洞：&lt;strong&gt;「简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的」&lt;/strong&gt;。既然存在以上的漏洞，那么我们应该怎么进行防御呢？接下来我们来介绍一些常见的 CSRF 防御措施。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;4.2 CSRF 防御措施&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.1 检查 Referer 字段&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 头中有一个 Referer 字段，这个字段用以标明请求来源于哪个地址。&lt;strong&gt;「在处理敏感数据请求时，通常来说，Referer 字段应和请求的地址位于同一域名下」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以示例中商城操作为例，Referer 字段地址通常应该是商城所在的网页地址，应该也位于 www.semlinker.com 之下。而如果是 CSRF 攻击传来的请求，Referer 字段会是包含恶意网址的地址，不会位于 www.semlinker.com 之下，这时候服务器就能识别出恶意的访问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种办法简单易行，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.2 同步表单 CSRF 校验&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CSRF 攻击之所以能够成功，是因为服务器无法区分正常请求和攻击请求。针对这个问题我们可以要求所有的用户请求都携带一个 CSRF 攻击者无法获取到的 token。对于 CSRF 示例图中的表单攻击，我们可以使用 &lt;strong&gt;「同步表单 CSRF 校验」&lt;/strong&gt; 的防御措施。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「同步表单 CSRF 校验」&lt;/strong&gt; 就是在返回页面时将 token 渲染到页面上，在 form 表单提交的时候通过隐藏域或者作为查询参数把 CSRF token 提交到服务器。比如，在同步渲染页面时，在表单请求中增加一个 &lt;code&gt;_csrf&lt;/code&gt; 的查询参数，这样当用户在提交这个表单的时候就会将 CSRF token 提交上来：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;form&lt;/span&gt; &lt;span&gt;method&lt;/span&gt;=&lt;span&gt;&quot;POST&quot;&lt;/span&gt; &lt;span&gt;action&lt;/span&gt;=&lt;span&gt;&quot;/upload?_csrf={{由服务端生成}}&quot;&lt;/span&gt; &lt;span&gt;enctype&lt;/span&gt;=&lt;span&gt;&quot;multipart/form-data&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  用户名: &lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;name&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;  选择头像: &lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;file&quot;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;file&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;submit&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;提交&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;form&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.3 双重 Cookie 防御&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「双重 Cookie 防御」&lt;/strong&gt; 就是将 token 设置在 Cookie 中，在提交（POST、PUT、PATCH、DELETE）等请求时提交 Cookie，并通过请求头或请求体带上 Cookie 中已设置的 token，服务端接收到请求后，再进行对比校验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们以 jQuery 为例，来看一下如何设置 CSRF token：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; csrfToken = Cookies.get(&lt;span&gt;&#x27;csrfToken&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;csrfSafeMethod&lt;/span&gt;(&lt;span&gt;method&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 以下HTTP方法不需要进行CSRF防护&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;/^(GET|HEAD|OPTIONS|TRACE)$/&lt;/span&gt;.test(method));&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;$.ajaxSetup({&lt;br/&gt;  &lt;span&gt;beforeSend&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;xhr, settings&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!csrfSafeMethod(settings.type) &amp;amp;&amp;amp; !&lt;span&gt;this&lt;/span&gt;.crossDomain) {&lt;br/&gt;      xhr.setRequestHeader(&lt;span&gt;&#x27;x-csrf-token&#x27;&lt;/span&gt;, csrfToken);&lt;br/&gt;    }&lt;br/&gt;  },&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍完 CSRF 攻击的方式和防御手段，最后我们来看一下 Axios 是如何防御 CSRF 攻击的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;4.3 Axios CSRF 防御&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Axios 提供了 &lt;code&gt;xsrfCookieName&lt;/code&gt; 和 &lt;code&gt;xsrfHeaderName&lt;/code&gt; 两个属性来分别设置 CSRF 的 Cookie 名称和 HTTP 请求头的名称，它们的默认值如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/defaults.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; defaults = {&lt;br/&gt;  &lt;span&gt;adapter&lt;/span&gt;: getDefaultAdapter(),&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;xsrfCookieName&lt;/span&gt;: &lt;span&gt;&#x27;XSRF-TOKEN&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;xsrfHeaderName&lt;/span&gt;: &lt;span&gt;&#x27;X-XSRF-TOKEN&#x27;&lt;/span&gt;,&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们已经知道在不同的平台中，Axios 使用不同的适配器来发送 HTTP 请求，这里我们以浏览器平台为例，来看一下 Axios 如何防御 CSRF 攻击：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/adapters/xhr.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;xhrAdapter&lt;/span&gt;(&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;dispatchXhrRequest&lt;/span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; requestHeaders = config.headers;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; request = &lt;span&gt;new&lt;/span&gt; XMLHttpRequest();&lt;br/&gt;    &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 添加xsrf头部&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (utils.isStandardBrowserEnv()) {&lt;br/&gt;      &lt;span&gt;var&lt;/span&gt; xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) &amp;amp;&amp;amp; config.xsrfCookieName ?&lt;br/&gt;        cookies.read(config.xsrfCookieName) :&lt;br/&gt;        &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (xsrfValue) {&lt;br/&gt;        requestHeaders[config.xsrfHeaderName] = xsrfValue;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    request.send(requestData);&lt;br/&gt;  });&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完以上的代码，相信小伙伴们就已经知道答案了，原来 Axios 内部是使用 &lt;strong&gt;「双重 Cookie 防御」&lt;/strong&gt; 的方案来防御 CSRF 攻击。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的，到这里本文的主要内容都已经介绍完了，其实 Axios 项目还有一些值得我们借鉴的地方，比如 CancelToken 的设计、异常处理机制等，感兴趣的小伙伴可以自行学习一下。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;五、参考资源&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Github - axios&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;维基百科 - 跨站请求伪造&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Egg - 安全威胁 CSRF 的防范&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3913677&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.006666666666666667&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot; data-width=&quot;100%&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCu1rRLicXibOB6jq4wpe7W4Ioibu7XTJR1ABzARKoLxyWEWeIV6HJRII2GK1ntnCkVIqjY852gntBd5Q/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;敬请关注「Nodejs技术栈」微信公众号，&lt;span&gt;期望与志同道合的你一起打造优质 “Nodejs技术栈” 交流群，一起互相学习进步！&lt;/span&gt;&lt;span&gt;可长按下方二维码&lt;/span&gt;&lt;span&gt;添加【五月君】个人微信备注 “Node” 邀请入群。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zPkNS9m6iatLmT5coKbicuqENgoc3Pz4QWwtrEoP2RU2thicCJHaKNmJ23Hh9jYvicpVgiauY6NxNaZ59D6svw1Qskg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>