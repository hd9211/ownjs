<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1d4d4b44df832196f22d59defa74c8f3</guid>
<title>求抱抱，小王被这 10 道 Java 面试题虐哭了</title>
<link>https://toutiao.io/k/jnjaul9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一天，小王告诉我，他去一家公司面试 Java 岗，结果被面试官虐哭了。整整 10 道 Java 面试题，小王一道也没答正确。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他沮丧地给我说，“哥，说点我的情况，你愿意听吗？我和一个女孩相处，女孩大我两岁，我非科班。本来打算国庆换一家薪水高点的，好确认关系。我经验不多，技术一般般，之前在一家外包公司，有一个甲方内推，我就鲁莽地把外包的工作辞了，结果没想到面试被虐了，我担心女朋友会不会因为我没有工作和我分手。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;听他这么一说，确实挺虐心的。后来我就安慰他，要他端正心态，先把这些面试题整明白，然后继续找工作，不要想太多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;借这个机会，我就把小王遇到的这 10 道面试题分享出来，希望能对其他小伙伴一些帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第一题，下面这串代码打印的结果是什么&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(Math.min(Double.MIN_VALUE, &lt;span&gt;0.0&lt;/span&gt;d));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他觉得 Double.MIN_VALUE 和 Integer.MIN_VALUE 一样，是个负数，应该小于 0.0d。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但事实上，Double. MIN_VALUE 和 Double. MAX_VALUE 一样，都是正数，Double. MIN_VALUE 的值是 &lt;code&gt;2^(-1074)&lt;/code&gt;，直接打印 Double. MIN_VALUE 的话，输出结果为 &lt;code&gt;4.9E-324&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此这道题的正确答案是输出 &lt;code&gt;0.0&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第二题，在 try 块或者 catch 语句中执行 return 语句或者 &lt;code&gt;System.exit()&lt;/code&gt; 会发生什么，finally 语句还会执行吗？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为在他的刻板印象中，finally 语句是无论如何都会执行的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但事实上，在 try 块或者 catch 语句中执行 return 语句时，finally 语句会执行；在 try 块或者 catch 语句中执行 &lt;code&gt;System.exit()&lt;/code&gt; 时，finally 语句不会执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        returnTryExec();&lt;br/&gt;        returnCatchExec();&lt;br/&gt;        exitTryExec();&lt;br/&gt;        exitCatchExec();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;returnTryExec&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;finally returnTryExec&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;returnCatchExec&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; { } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;finally returnCatchExec&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;exitTryExec&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            System.exit(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;finally exitTryExec&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;exitCatchExec&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; { } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            System.exit(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;finally exitCatchExec&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序执行结果如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;finally returnTryExec&lt;br/&gt;finally returnCatchExec&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第三题，私有方法或者静态方法能被重写（override）吗？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他不确定私有方法或者静态方法与重写之间的关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重写的两个方法名相同，方法参数的个数也相同；不过一个方法在父类中，另外一个在子类中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LaoWang&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;老王写了一本《基督山伯爵》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;XiaoWang&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;LaoWang&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;小王写了一本《茶花女》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OverridingTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        LaoWang wang = &lt;span&gt;new&lt;/span&gt; XiaoWang();&lt;br/&gt;        wang.write();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;父类 LaoWang 有一个 &lt;code&gt;write()&lt;/code&gt; 方法（无参），方法体是写一本《基督山伯爵》；子类 XiaoWang 重写了父类的 &lt;code&gt;write()&lt;/code&gt; 方法（无参），但方法体是写一本《茶花女》。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 main 方法中，我们声明了一个类型为 LaoWang 的变量 wang。在编译期间，编译器会检查 LaoWang 类是否包含了 &lt;code&gt;write()&lt;/code&gt; 方法，发现 LaoWang 类有，于是编译通过。在运行期间，new 了一个 XiaoWang 对象，并将其赋值给 wang，此时 Java 虚拟机知道 wang 引用的是 XiaoWang 对象，所以调用的是子类 XiaoWang 中的 &lt;code&gt;write()&lt;/code&gt; 方法而不是父类 LaoWang  中的 &lt;code&gt;write()&lt;/code&gt; 方法，因此输出结果为“小王写了一本《茶花女》”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而私有方法对子类是不可见的，它仅在当前声明的类中可见，private 关键字满足了封装的最高级别要求。另外，Java 中的私有方法是通过编译期的静态绑定的方式绑定的，不依赖于特定引用变量所持有的对象类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法重写适用于动态绑定，因此私有方法无法被重写。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LaoWang&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;LaoWang&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        write();&lt;br/&gt;        read();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;老王写了一本《基督山伯爵》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;老王在读《哈姆雷特》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;XiaoWang&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;LaoWang&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;小王写了一本《茶花女》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;小王在读《威尼斯商人》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PrivateOrrideTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        LaoWang wang = &lt;span&gt;new&lt;/span&gt; XiaoWang();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序输出结果如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;小王写了一本《茶花女》&lt;br/&gt;老王在读《哈姆雷特》&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在父类的构造方法中，分别调用了 &lt;code&gt;write()&lt;/code&gt; 和 &lt;code&gt;read()&lt;/code&gt; 方法，&lt;code&gt;write()&lt;/code&gt;方法是 public 的，可以被重写，因此执行了子类的 &lt;code&gt;write()&lt;/code&gt; 方法，&lt;code&gt;read()&lt;/code&gt; 方法是私有的，无法被重写，因此执行的仍然是父类的 &lt;code&gt;read()&lt;/code&gt; 方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和私有方法类似，静态方法在编译期也是通过静态绑定的方式绑定的，不依赖于特定引用变量所持有的对象类型。方法重写适用于动态绑定，因此静态方法无法被重写。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;StaticOrrideTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Laozi zi = &lt;span&gt;new&lt;/span&gt; Xiaozi();&lt;br/&gt;        zi.write();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Laozi&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;老子写了一本《基督山伯爵》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Xiaozi&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Laozi&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;小子写了一本《茶花女》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序输出结果如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;老子写了一本《基督山伯爵》&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用变量 zi 的类型为 Laozi，所以 &lt;code&gt;zi.write()&lt;/code&gt; 执行的是父类中的 &lt;code&gt;write()&lt;/code&gt; 方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;静态方法也叫类方法，直接通过类名就可以调用，通过对象调用的时候，IDE 会发出警告。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21129032258064517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHplr7ZibLgLzL5cP90VDbAx0vjaQrDk8rK6mIlHibUKfIo2ahrauLT88w9ncxN74MfVEq6QWYmOdLyQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第四题，&lt;code&gt;1.0/0.0&lt;/code&gt; 得到的结果是什么？会抛出异常吗，还是会出现编译错误？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他没有深入研究过 double 类型和 int 类型的除法运算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数字在 Java 中可以分为两种，一种是整形，一种是浮点型。不太清楚的小伙伴先去研究一下&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxNzQwNjM3NA==&amp;amp;mid=2247489521&amp;amp;idx=2&amp;amp;sn=869f20ba8b26b523b5b0d7d10f3ef87a&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;数据类型&lt;/a&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当浮点数除以 0 的时候，结果为 Infinity 或者 NaN。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;System.out.println(1.0 / 0.0); // Infinity&lt;br/&gt;System.out.println(0.0 / 0.0); // NaN&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Infinity 的中文意思是无穷大，NaN 的中文意思是这不是一个数字（Not a Number）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当整数除以 0 的时候（&lt;code&gt;10 / 0&lt;/code&gt;），会抛出异常：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Exception &lt;span&gt;in&lt;/span&gt; thread &lt;span&gt;&quot;main&quot;&lt;/span&gt; java.lang.ArithmeticException: / by zero&lt;br/&gt; at com.itwanger.eleven.ArithmeticOperator.main(ArithmeticOperator.java:32)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常，我们在进行整数的除法运算时，需要先判断除数是否为 0，以免程序抛出异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第五题，Java 支持多重继承吗？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他知道，通过接口可以达到多重继承的目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来定义两个接口，Fly 会飞，Run 会跑。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public interface Fly {&lt;br/&gt;    void fly();&lt;br/&gt;}&lt;br/&gt;public interface Run {&lt;br/&gt;    void run();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后让一个类同时实现这两个接口。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Pig&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Fly&lt;/span&gt;,&lt;span&gt;Run&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fly&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;会飞的猪&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;会跑的猪&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但说到多重继承，讨论的关键字是 extends，而非 implements。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 只支持单一继承，是因为涉及到菱形问题。如果有两个类共同继承一个有特定方法的父类，那么该方法可能会被两个子类重写。然后，如果你决定同时继承这两个子类，那么在你调用该重写方法时，编译器不能识别你要调用哪个子类的方法。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7518939393939394&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHplr7ZibLgLzL5cP90VDbAx0vpLyyBPgeyaDBb4ic38y0Nt62WnH5lCqgojdcbfyUlg2wgToialPRnCibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类 C 同时继承了类 A 和类 B，类 C 的对象在调用类 A 和类 B 中重写的方法时，就不知道该调用类 A 的方法，还是类 B 的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第六题，当在 HashMap 中放入一个已经存在的 key 时，会发生什么？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他没有深入研究过 HashMap 的工作原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hash，一般译作“散列”，也有直接音译为“哈希”的，这玩意什么意思呢？就是把任意长度的数据通过一种算法映射到固定长度的域上（散列值）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再直观一点，就是对一串数据 wang 进行杂糅，输出另外一段固定长度的数据 er——作为数据 wang 的特征。我们通常用一串指纹来映射某一个人，别小瞧手指头那么大点的指纹，在你所处的范围内很难找出第二个和你相同的（人的散列算法也好厉害，有没有）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于任意两个不同的数据块，其散列值相同的可能性极小，也就是说，对于一个给定的数据块，找到和它散列值相同的数据块极为困难。再者，对于一个数据块，哪怕只改动它的一个比特位，其散列值的改动也会非常的大——这正是 Hash 存在的价值！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家应该知道，HashMap 的底层数据结构是一个数组，通过 &lt;code&gt;hash()&lt;/code&gt; 方法来确定下标。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;hash&lt;/span&gt;&lt;span&gt;(Object key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; h;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;0&lt;/span&gt; : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们放入一个键值对的时候，会先调用 &lt;code&gt;hash()&lt;/code&gt; 方法对 key 进行哈希算法，如果 key 是相同的，那么哈希后的结果也是相同的，意味着数组中的下标是相同的，新放入的值就会覆盖原来的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第七题，下面这段代码将会打印出什么？&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;char&lt;/span&gt;[] chars = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[]{&lt;span&gt;&#x27;\u0097&#x27;&lt;/span&gt;};&lt;br/&gt;        String str = &lt;span&gt;new&lt;/span&gt; String(chars);&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt;[] bytes = str.getBytes();&lt;br/&gt;        System.out.println(Arrays.toString(bytes));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他没有深入研究过字符编码方面的一些知识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这段程序中，我们通过一个字符数组创建了一个字符串对象，然后调用 String 类的 &lt;code&gt;getByte()&lt;/code&gt; 方法得到字节数组并将其打印到控制台。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道面试题考察的核心并不是最终的打印结果（结果是不确定的），而是字符编码。通常情况下，我们在调用 &lt;code&gt;getBytes()&lt;/code&gt; 方法时，要指定编码，比如说 &lt;code&gt;str.getBytes(StandardCharsets.UTF_8)&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们没有指定编码的时候，JDK 会调用平台默认的字符编码，而不同的操作系统，编码不尽相同的，bytes 的结果也就会不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用 UTF_8 时，结果为 &lt;code&gt;-62, -105&lt;/code&gt;，当使用 GB2312 时，结果为 &lt;code&gt;63&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第八题，当方法在父类中抛出 &lt;code&gt;NullPointerException&lt;/code&gt; 时，是否可以使用抛出 &lt;code&gt;RuntimeException&lt;/code&gt; 的方法来重写它？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他被重写（overriding）和重载（overloading）的概念搞混了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法重写和方法重载时，方法名可以完全相同，但根本的不同在于方法重写时发生在运行时，方法重载时发生在编译时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，方法重写和方法重载时的规则也不尽相同。在 Java 中，不能重写 private、static 和 final 方法，但可以重载它们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来重点看一下方法重写时的规则：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）方法签名必须相同，包括返回类型、参数的数量、参数的类型和参数的顺序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）重写后的方法不能抛出比父类中更高级别的异常。举例来说，如果父类中的方法抛出的是 IOException，那么子类中重写的方法不能抛出 Exception，可以是 IOException 的子类或者不抛出任何异常。这条规则只适用于可检查的异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可检查（checked）异常必须在源代码中显式地进行捕获处理，不检查（unchecked）异常就是所谓的运行时异常，比如说 NullPointerException、ArrayIndexOutOfBoundsException 之类的，不会在编译器强制要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）重写后的方法访问权限不能比父类中的方法低，比如说父类中的方法是 public，重写后的方法就不能是 protected。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ExceptionDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Super s = &lt;span&gt;new&lt;/span&gt; Child();&lt;br/&gt;        s.write();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Super&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; NullPointerException &lt;/span&gt;{ }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Child&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Super&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; RuntimeException &lt;/span&gt;{ }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RuntimeException 和 NullPointerException 属于不检查异常，所以本题的答案是可以的。如果是可检查异常的话，IDE 就会发出警告。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2725806451612903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHplr7ZibLgLzL5cP90VDbAx0vqiaNGoCuwE2WOibPSf0f5aicWWzt3tgIFGWcRnEticCSPlGCEZlB9Vr9QQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第九题，下面这段代码使用了 &lt;code&gt;compareTo()&lt;/code&gt; 方法，有问题吗？&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Employee&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Comparable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;compareTo&lt;/span&gt;&lt;span&gt;(Object o)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Employee emp = (Employee) o;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.id - emp.id;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他想当然地认为 id 的都是正整数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们需要按照一定的规则进行排序的时候，通常要实现 Comparable 接口，并实现 compareTo 方法，规则如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）如果当前对象小于另外一个对象，则 compareTo 方法必须返回负数；如果当前对象大于另外一个对象，则必须返回正数；如果两个对象相等，则返回零。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）通常来说，compareTo 方法必须和 equals 方法一致，如果两个对象通过 equals 方法判断的结果为 true，那么 compareTo 必须返回零。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，JDK 中有一个反例，就是 BigDecimal。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BigDecimal bd1 = &lt;span&gt;new&lt;/span&gt; BigDecimal(&lt;span&gt;&quot;2.0&quot;&lt;/span&gt;);&lt;br/&gt;BigDecimal bd2 = &lt;span&gt;new&lt;/span&gt; BigDecimal(&lt;span&gt;&quot;2.00&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;System.out.println(&lt;span&gt;&quot;equals: &quot;&lt;/span&gt; + bd1.equals(bd2));&lt;br/&gt;System.out.println(&lt;span&gt;&quot;compareTo: &quot;&lt;/span&gt; + bd1.compareTo(bd2));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;equals: &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;compareTo: 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是因为 JDK 认为 2.0 和 2.00 的精度不一样，所以不能 equals，但值确实是相等的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）不能使用减法来比较整数值，因为减法的结果可能溢出。应该使用 &lt;code&gt;Integer.compareTo()&lt;/code&gt; 来进行比较。如果你想通过减法操作来提高性能，必须得确保两个操作数是正整数，或者确保两者相差的值小于 Integer.MAX_VALUE。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CompareDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;Employee&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        list.add(&lt;span&gt;new&lt;/span&gt; Employee(&lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;        list.add(&lt;span&gt;new&lt;/span&gt; Employee(Integer.MIN_VALUE));&lt;br/&gt;        list.add(&lt;span&gt;new&lt;/span&gt; Employee(Integer.MAX_VALUE));&lt;br/&gt;        Collections.sort(list);&lt;br/&gt;        System.out.println(list);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Employee&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Comparable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Employee&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; id)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.id = id;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;compareTo&lt;/span&gt;&lt;span&gt;(Object o)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Employee emp = (Employee) o;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.id - emp.id;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Employee{&quot;&lt;/span&gt; +&lt;br/&gt;                &lt;span&gt;&quot;id=&quot;&lt;/span&gt; + id +&lt;br/&gt;                &lt;span&gt;&#x27;}&#x27;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序的输出结果如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[Employee{id=1}, Employee{id=2147483647}, Employee{id=-2147483648}]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;排序就乱了。因为 &lt;code&gt;Integer.MIN_VALUE - 1&lt;/code&gt; 变成了正数 &lt;code&gt;2147483647&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第十题，StringBuffer 和 StringBuilder 之间有什么区别？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他觉得这道题太简单了，结果说反了，大意了啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;StringBuilder 是 JDK 1.5 之后引入的，它和 StringBuffer 最大的区别就在于它的一系列方法都是非同步的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5018867924528302&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHplr7ZibLgLzL5cP90VDbAx0vZ4VQSwpWC08xoJfx4ibOH2Ap3e7Fbgicu7DtxX7jGWY2Aq7yGASwUBrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，以上就是小王这次面试遇到的 10 道虐心的面试题，本来最后一道是送分题，结果大意说反了，让小王更加懊恼。年后是跳槽的高峰期，有打算的小伙伴要提前准备了，希望大家都能够顺利面上心仪的岗位。&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>04bc38bbea86d71b2d6e25bbcd995ba3</guid>
<title>白话科普系列：网站靠什么提升加载速度？</title>
<link>https://toutiao.io/k/h61rg9r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;随着生活节奏的不断加快，时间变得极其宝贵，等待页面加载的时间也随之缩短。这样一来如何留住客户变成了一项重要的考验。而减少页面加载等待时间，加快加载速度，就成了提高用户参与度S，提升业务可靠性的有效策略。&lt;/p&gt;&lt;p&gt;根据 Google 的一项研究，有 40％ 的人放弃了某网站，是因为该网站的加载时间超过 3 秒，而页面加载时间增加1 秒，转化就相应减少了 7％。可见，互联网中的每一秒都至关重要。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-dc195edacbcb9f33d918ca2fe35f3d97_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;519&quot; data-rawheight=&quot;300&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-dc195edacbcb9f33d918ca2fe35f3d97_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;519&quot; data-rawheight=&quot;300&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-dc195edacbcb9f33d918ca2fe35f3d97_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-dc195edacbcb9f33d918ca2fe35f3d97_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;那么如何提升网站速度呢？可以通过网页“压缩”也就减少网页体积来实现。至于要如何才能压缩网站，我们需要先了解两个算法，&lt;b&gt;Gzip 和 Brotli 压缩算法。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;                                         Gzip 压缩算法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Gzip 基于 DEFLATE 算法，它是 LZ77 和霍夫曼编码的组合，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 Gzip 编码是一种用来改进 Web 应用程序性能的技术，它要求 Web 服务器和客户端（浏览器）必须共同支持 Gzip。而当下主流的浏览器，包括 IE6、IE7、IE8、IE9、FireFox、Google Chrome、Opera 等都已经开始支持 Gzip 压缩。可见 Gzip 的使用已经成为了互联网发展的必然趋势。&lt;/p&gt;&lt;p&gt;作为 Internet 上使用非常普遍的一种数据压缩格式，Gzip 对一般纯文本内容可压缩到原大小的 40％，这大大减少了网站文件中重复代码和空白的数量。它还可以提供 9 个压缩级别，可以方便使用者微调压缩量和压缩时间。&lt;/p&gt;&lt;p&gt;在用于提高 Web 应用程序的性能这一点上，Gzip 压缩一直是最受欢迎的。直到另一种压缩算法 Brotli 的出现，它成为了 Gzip 最大的竞争对手。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;                                         Brotli 压缩算法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Brotli 是 Google 在 2015 年 9 月推出的一种压缩算法，Google 认为互联网用户的时间是宝贵的，他们的时间不应该消耗在漫长的网页加载中，因此与其他压缩算法相比，Brotli 有着更高的压缩效率。它通过变种的 LZ77 算法、Huffman 编码以及二阶文本建模等方式进行数据压缩。&lt;/p&gt;&lt;p&gt;根据 Google 发布的研究报告，Brotli 压缩算法具有多个特点，最典型的是以下 3 个：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;针对常见的 Web 资源内容，Brotli 的性能相比 Gzip 提高了 17-25%；&lt;/li&gt;&lt;li&gt;当 Brotli 压缩级别为 1 时，压缩率比 Gzip 压缩等级为 9（最高）时还要高；&lt;/li&gt;&lt;li&gt;在处理不同 HTML 文档时，Brotli 依然能够提供非常高的压缩率&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;依靠着自身卓越的压缩性能，Brotli 自推出后就迅速开始占领压缩市场，从下图可以看到，除了 IE 和 Opera Mini 之外，几乎所有的主流浏览器都已支持 Brotli 算法。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e9ab7e95798faba589cc1f55e35034df_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1229&quot; data-rawheight=&quot;280&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-e9ab7e95798faba589cc1f55e35034df_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1229&quot; data-rawheight=&quot;280&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-e9ab7e95798faba589cc1f55e35034df_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-e9ab7e95798faba589cc1f55e35034df_b.jpg&quot;/&gt;&lt;figcaption&gt;△ Brotli 浏览器支持情况&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在压缩效率上 Brotli 毫无疑问的遥遥领先。那么我们是否可以无脑盲选 Brotli 呢，Gzip 是不是应该就此退出市场？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;                                    Brotli 比 Gzip 更好吗？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;显然与 Gzip 相比，Brotli 压缩在研究中显示出了不俗的成果。，例如 Gzip 有 9 个压缩级别，而 Brotli 有 11 个。此外，Brotli 还使用一个预定义的 120 千字节字典，该字典包含超过 13000 个常用单词、短语和其他子字符串。这些因素都有效提高了 Brotli 的压缩率。根据 Certsimple 的研究，用 Brotli 压缩的 Javascript 文件比 Gzip 小 14％，HTML 文件比 Gzip 小 21％，CSS 文件比 Gzip 小 17％。&lt;/p&gt;&lt;p&gt;无论从哪方面看 Gzip 都已经被 Brotli 碾压，两者之间毫无对比的可能性，我们似乎也完全不需要考虑选择左边或者右边。&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;注意：图像不应该被 Gzip 或 Brotli 压缩，因为它们已经被压缩，再次压缩将使其尺寸变大。&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;诚然 Brotli 在压缩程度上有着绝对的优势，但是这些优势是用其他代价换来的。Brotli 压缩操作所花费的时间会随着压缩级别的增加而增加。简而言之，就是 Brotli 需要更多的计算能力，而大家都知道计算能力需求的增加代表着设备和软件设施的成本上涨。另外 Brotli 要求浏览器必须支持与 HTTPS 一起使用，这也是他相比在浏览器支持量上比 Gzip 少的原因。毕竟 Gzip 同时支持 HTTP 和 HTTPS。&lt;/p&gt;&lt;p&gt;一边是压缩效果奇佳但是可能会因为浏览器的不支持而导致用户无法访问网站，另一边则是浏览器支持但是压缩效果降低用户加载网页时间依然略长，一个两难的抉择出现在了网站运营者面前。有机灵的小伙伴可能会说：“也不是所有用户都能使用 HTTPS，但是不是有功能判断么？难道压缩算法就不能整一个这种自动判断？让能使用 Brotli 的使用 Brotli，不能的使用 Gzip。”&lt;/p&gt;&lt;p&gt;bingo！华生，你发现了盲点。让我们愉快地掏出又拍云一站式减流量秘籍之智能压缩！&lt;/p&gt;&lt;h2&gt;&lt;b&gt;                                 又拍云秘籍——智能压缩&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;又拍云智能压缩功能旨在为网站减少了流量开支，减少资源加载时间，让终端用户的体验更上一层楼。它同时支持 Gzip 和 Brotli 压缩算法，可同时开启，也可开启其中一种。开启该功能，可对静态文件类型进行压缩，有效减少用户传输内容大小，加速分发效果。为了配置的灵活性，“智能压缩”功能支持压缩等级（1 到 5）的设置。两种压缩算法的压缩等级默认为 1，等级越高，压缩率越大。考虑到压缩等级越高，压缩速度会降低，实际生产环境，建议压缩等级控制在 3 以内，具体请以线上环境实测为准进行自主设置。&lt;/p&gt;&lt;p&gt;当用户在后台同时开启 Gzip 和 Brotli 压缩时，后台会自行判断浏览器是否支持 Brotli 来选择进行哪种压缩。&lt;/p&gt;&lt;p&gt;那么这个浏览器自行判断是怎么操作的呢？&lt;/p&gt;&lt;p&gt;其实支持 Brotli 的浏览器会在接受编码请求标头中发送“ br”和“ gzip”（例如：Accept-Encoding: gzip, deflate, br）。如果 Web 服务器上启用了 Brotli，则用户将获取到 Brotli 压缩格式的响应。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f0620bb612b5c9deb73925d825277c45_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;667&quot; data-rawheight=&quot;381&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-f0620bb612b5c9deb73925d825277c45_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;667&quot; data-rawheight=&quot;381&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-f0620bb612b5c9deb73925d825277c45_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f0620bb612b5c9deb73925d825277c45_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这样就能有效避免选择 A 还是选择 B 的烦恼，你可以两者都拥有，在提升用户浏览体验的同时降低你的 CDN 流量。&lt;/p&gt;&lt;p&gt;当然对于“如果浏览器同时支持 Gzip 和 Brotli 会不会出现两次压缩，或者选择错误”的问题，又拍云也考虑到了哦。当客户端同时支持 Gzip 和 Brotli 算法的情况下，Brotli 的优先级高于 Gzip。&lt;/p&gt;&lt;p&gt;这么方便的功能，只需要登陆 CDN 控制台，进入 「性能优化」配置页面，找到「智能压缩」配置项，点击【管理】按钮，进入如下配置界面：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b54a719a3ac378367c37ad71df0d3038_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1077&quot; data-rawheight=&quot;473&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-b54a719a3ac378367c37ad71df0d3038_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1077&quot; data-rawheight=&quot;473&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-b54a719a3ac378367c37ad71df0d3038_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-b54a719a3ac378367c37ad71df0d3038_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;配置好压缩等级就可以愉快使用了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-202d053a7bcd5118c9ce91d3e3a7fa69_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;892&quot; data-rawheight=&quot;486&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-202d053a7bcd5118c9ce91d3e3a7fa69_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;892&quot; data-rawheight=&quot;486&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-202d053a7bcd5118c9ce91d3e3a7fa69_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-202d053a7bcd5118c9ce91d3e3a7fa69_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 开启智能压缩前&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-305f9d635be7e11e48b8caea6a2c9688_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;888&quot; data-rawheight=&quot;485&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-305f9d635be7e11e48b8caea6a2c9688_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;888&quot; data-rawheight=&quot;485&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-305f9d635be7e11e48b8caea6a2c9688_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-305f9d635be7e11e48b8caea6a2c9688_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 开启智能压缩后&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;除了智能压缩，又拍云还提供了一系列“省带宽，压成本”的绝招，包括 Webp 自适应、H.265 自适应、码率适配限速、窄带高清 等等，从编码技术、网络架构等角度出发，结合又拍云的产品成果，为大家节省流量，降低成本。有兴趣可以随时联系我们了解哦！&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;推荐阅读：&lt;/h2&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/590/%25E7%2599%25BD%25E8%25AF%259D%25E7%25A7%2591%25E6%2599%25AE%25E7%25B3%25BB%25E5%2588%2597%25E2%2580%2594%25E2%2580%2594Chrome%2520%25E6%25B5%258F%25E8%25A7%2588%25E5%2599%25A8%25EF%25BC%258C%25E4%25BD%25A0%25E7%2594%25A8%25E4%25BA%2586%25E4%25B9%2588%25EF%25BC%259F.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic4.zhimg.com/v2-0ce93b77d899e27bf9e9fece8a7086db_180x120.jpg&quot; data-image-width=&quot;1272&quot; data-image-height=&quot;718&quot; class=&quot;LinkCard LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;白话科普系列--Chrome 浏览器，你用了么？&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic4.zhimg.com/v2-0ce93b77d899e27bf9e9fece8a7086db_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/588/%25E7%2599%25BD%25E8%25AF%259D%25E7%25A7%2591%25E6%2599%25AE%25EF%25BC%258C10s%2520%25E4%25BA%2586%25E8%25A7%25A3%2520API.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-e2a633e9f561dfa40182f0e6923268a6_180x120.jpg&quot; data-image-width=&quot;546&quot; data-image-height=&quot;346&quot; class=&quot;LinkCard LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;白话科普，10s 了解 API - 又拍云&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic3.zhimg.com/v2-e2a633e9f561dfa40182f0e6923268a6_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0e0dd808728704db999b3a64292ec014</guid>
<title>好的重构方法才能摆脱 “屎山”</title>
<link>https://toutiao.io/k/rr23n1t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;strong&gt;&lt;span&gt;这里是Z哥的个人公众号&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;每周五11：45 按时送达&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;当然了，也会时不时加个餐～&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;我的第「171」篇原创敬上&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;大家好，我是Z哥。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最近在整理一些项目，所以相关的文章写的多了些。之前的相关文章有《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NzEwMDc4OQ==&amp;amp;mid=2247485351&amp;amp;idx=1&amp;amp;sn=63580ffa1d350032afab8aae7544adb8&amp;amp;chksm=fca313bdcbd49aab984df27355ef518c0ab6100bc96580a26fa1969042ad71093b6ba4282062&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;聊聊单元测试&lt;/a&gt;》，感兴趣的话可以点击文末链接去阅读。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这次整理项目的时候，做了比较多的codereview和重构。好久没做这么高强度了重构了，所以对重构这件事有了新的思考和理解。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;突然发现叫我们程序员“码农”还挺形象的，因为写代码和种田很像，想有个好收成，就要好好管理代码，让它们井井有条。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;吴军老师在《文明之光》里讲到一个「垄耕种植法」，它由中国人发明，后发扬到全球，影响了全世界的粮食生产。据说欧洲人民以前是把种子随意地撒在地里，任其自由生长，结果收成很低，如果种下20斤，大概只能收获60斤左右粮食。而中国早在先秦时期亩产最少都在240斤以上，最新的数据是今年11月初袁隆平的杂交水稻，早晚稻加起来达到3000斤，这都得益于「垄耕种植法」。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，当你看到那些被随意“播种”的糟糕代码，是改，还是不改？改吧，花时间；不改吧，就像上面的欧洲人民。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其实很多人对「重构」的理解还有些误区。「重构」仅仅是所谓的优化代码吗？并不是。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Martin Fowler大神在他的《重构》一书中对「重构」的定义就非常准确。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;95&quot; data-source-title=&quot;《重构》Martin Fowler&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22out%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%22%2C%22digestLen%22%3A95%2C%22text%22%3A%22%E9%87%8D%E6%9E%84%EF%BC%88%E5%90%8D%E8%AF%8D%EF%BC%89%EF%BC%9A%E5%AF%B9%E8%BD%AF%E4%BB%B6%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%80%E7%A7%8D%E8%B0%83%E6%95%B4%EF%BC%8C%E7%9B%AE%E7%9A%84%E6%98%AF%E5%9C%A8%E4%B8%8D%E6%94%B9%E5%8F%98%E8%BD%AF%E4%BB%B6%E5%8F%AF%E8%A7%82%E5%AF%9F%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%89%8D%E6%8F%90%E4%B8%8B%EF%BC%8C%E6%8F%90%E9%AB%98%E5%85%B6%E5%8F%AF%E7%90%86%E8%A7%A3%E6%80%A7%EF%BC%8C%E9%99%8D%E4%BD%8E%E5%85%B6%E4%BF%AE%E6%94%B9%E6%88%90%E6%9C%AC%E3%80%82%C2%A0%E9%87%8D%E6%9E%84%EF%BC%88%E5%8A%A8%E8%AF%8D%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%B8%80%E7%B3%BB%E5%88%97%E9%87%8D%E6%9E%84%E6%89%8B%E6%B3%95%EF%BC%8C%E5%9C%A8%E4%B8%8D%E6%94%B9%E5%8F%98%E8%BD%AF%E4%BB%B6%E5%8F%AF%E8%A7%82%E5%AF%9F%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%89%8D%E6%8F%90%E4%B8%8B%EF%BC%8C%E8%B0%83%E6%95%B4%E5%85%B6%E7%BB%93%E6%9E%84%E3%80%82%22%2C%22article%22%3A%7B%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%5D%2C%22from%22%3A%22%E3%80%8A%E9%87%8D%E6%9E%84%E3%80%8BMartin%20Fowler%22%7D&quot;&gt;&lt;span class=&quot;blockquote_other&quot;&gt;《重构》Martin Fowler&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，重构不仅仅是修改代码，是对软件结构的调整，修改代码只是其中的一个手段而已。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么具体应该怎么做呢？在这之前，需要考虑清楚以下几个问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;/01  什么时候重构？/&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;很多理想主义者认为的理想情况自然是随时发现坏代码就重构。但是这里存在两个问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以我们需要几个更加客观的外部标准，Z哥建议你可以从以下三个方面来观察，如果发现了类似的现象，说明它在给你发出需要重构的信号。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/02  怎么重构？/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了保证重构的质量，在你重构的过程中，一定要关注以下4个关键点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以回想一下，你之前做过的重构是否都符合了以上的这些要求？反正Z哥最近做的重构是不符合的，所以感觉很累很痛苦～&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体的重构工作其实说起来很简单，因为一段代码无非就是「输入参数」、「输出参数」、「方法体」3个东西，重构也自然以这几个地方展开。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/01  输入参数/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于输入参数的重构，主要关注在参数的个数上。那些优秀的开源项目里，你几乎看不到参数很多的方法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因为过多的参数个数，不但不容易理解，而且你在写调用这个方法的代码的时候也会很头疼，时不时要数一下这是第几个参数，对应的参数说明是什么。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有一些工具推荐的默认参数最大长度是7个（如SonarQube）。如果你没有更好的定义和理解，那么不妨以“7”这个标准来执行。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/02  输出参数/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;输出参数只有一个，能够出乱子的空间也很小，所以一般来说不需要怎么优化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;唯一值得提醒的两点是：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;参数类型尽量用强类型。弱类型的返回值虽然让你的Function向后兼容性很好，但是也带来了很多无法在编译期间被发现的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不返回不需要的参数。添加更多参数在最初肯定是为了“跑在业务前面”，但这份好心往往最终带来的是更多“意料之外的耦合”，导致后续的重构成本大增。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/03  方法体/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于方法体的重构是花费时间最多的地方，具体的方式方法也很多。但是我建议你一定要坚持一个核心要点，我将它称为「NRD重构法」，这3个字母分别表示：New、Replace、Delete。也就是说，做重构的时候不要直接在原来的方法体里改，重新建一个新的方法，然后等单测跑通之后再替换掉老方法，最后再把老方法删除。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;只要做到这点，要满足前面提到的4个关键点，就没那么困难了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体的重构内容自然是以减少复杂度为核心思路去做。衡量代码复杂度有一个概念叫「圈复杂度」（也叫「循环复杂度」），在1976年由Thomas J. McCabe, Sr. 提出。现在有不少工具有统计这个指标。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;复杂度大说明程序代码可能质量低且难于测试和维护，根据经验，程序的可能错误和高的圈复杂度有着很大关系。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;复杂度大的代码往往伴随着大量的if/switch/for/foreach/try...catch/while等等。每一次试用都会让「圈复杂度」+1，并且其中的条件判断越多，增加的越快。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，常见的重构方式大多以降低代码的圈复杂度为主。比如，&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;还有很多小众的重构技巧这里就不赘述了，真是觉得大家都应该读一读《重构》这本书。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;多说一句，不提倡刻意降低代码行数的方法，因为你的复杂度不下降，减少代码行数只是“掩耳盗铃”而已。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外，重构有一个最佳伴侣，就是单元测试。你想象一个画面，当你重构之前通过率100%的单元测试在重构完成后跑一遍，发现了10%的失败。此时你的心情肯定是“真香，否则一堆bug等着我修”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不过，如果你的代码「圈复杂度」越高，单元测试写起来越费劲。如何写好单元测试可以看我之前写的文章《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NzEwMDc4OQ==&amp;amp;mid=2247485351&amp;amp;idx=1&amp;amp;sn=63580ffa1d350032afab8aae7544adb8&amp;amp;chksm=fca313bdcbd49aab984df27355ef518c0ab6100bc96580a26fa1969042ad71093b6ba4282062&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;聊聊单元测试&lt;/a&gt;》。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，怎么判断重构的效果好不好呢？自然是工作效率是否提高了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;增加一个功能或者接口的时间是不是缩短了？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;测试那边回归测试的平均时间是不是缩短了？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;好了，就这么多。如果你还是觉得无从下手，不妨试试《重构》作者推荐的一种做法:&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;随机挑选一个目标，比如，“去掉一堆不必要的子类”。然后朝着目标前进，没把握就停下来。当你无法证明自己所做的修改能够保证原有程序的逻辑和语义时，立马停下来思考：当前做的重构是改善了？还是毫无成果需要撤销？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后再次强力推荐《重构》这本书，里面有很多非常具体的代码重构方法，值得每一位程序员入手一本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;mpcps frameborder=&quot;0&quot; class=&quot;js_editor_cps&quot; data-datakey=&quot;1604914048250_0.953375247605875&quot; data-uid=&quot;1604914048249&quot; data-type=&quot;1&quot; data-product=&quot;&quot; data-templateid=&quot;list&quot; data-pid=&quot;12584498&quot; data-categoryid=&quot;3&quot; data-appuin=&quot;3208869061&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;好了，总结一下。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这篇呢，Z哥和你分享了我对代码重构这件事的看法。要想提高你代码的“产出”，那么就得好好重视重构这件事。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在重构代码的「输入参数」、「输出参数」、「方法体」的时候需要持续保持以下4个关键点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这才能使得你的重构工作平稳的进行，而不会是一场赌博。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;并且，重构方法体的时候要以降低「圈复杂度」为目的，而不是代码行数。如果条件允许，尽量多写一些单元测试来保障重构的稳定性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;希望对你有所启发。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;重构可以使软件更容易地被修改和被理解，这个意义甚至大于所谓的“优化和改进”。Kent Beck大神曾也经说过：首先让代码架构易于改变，然后再进行简单的改进。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你想摆脱代码越改越痛苦的困境，那么赶紧行动起来吧。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原创不易，如果你觉得这篇文章还不错，就「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」或者「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;分享&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」一下吧。鼓励我的创作 ：）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.4428822495606327&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/oB5bd6W6hI1Xrkr3iaFRP5fErfmjHqlBw160icnia8yicWBlicnPEfqGE80alzGl9FLj6FxyuibIuliceoH9zicibj95loQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1138&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你有关于软件架构、分布式系统、产品、运营的困惑&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以试试点击「&lt;strong&gt;阅读原文&lt;/strong&gt;」&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>16d4cc0a03424ffd42116d4593082651</guid>
<title>每个程序员都应该知道的 CPU 知识：NUMA</title>
<link>https://toutiao.io/k/b13e8n2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是 NUMA？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;早期的计算机，内存控制器还没有整合进 CPU，所有的内存访问都需要经过北桥芯片来完成。如下图所示，CPU 通过前端总线（FSB，Front Side Bus）连接到北桥芯片，然后北桥芯片连接到内存——内存控制器集成在北桥芯片里面。&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;368&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;252&quot; data-ratio=&quot;0.7245508982035929&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9637P74IBOE3mOYRvZ13aE8ZFytOzExOK255TDstq8PiaqpZcGGUicjEgZykQOlEjRsjYWE0307wtoWg4ncmVKhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;668&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种架构被称为 UMA&lt;sup&gt;1&lt;/sup&gt;（Uniform Memory Access, 一致性内存访问 ）：总线模型保证了 CPU 的所有内存访问都是一致的，不必考虑不同内存地址之间的差异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 UMA 架构下，CPU 和内存之间的通信全部都要通过前端总线。而提高性能的方式，就是不断地提高 CPU、前端总线和内存的工作频率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面的故事，大部分人都很清楚：因为物理条件的限制，不断提高工作频率的路子走不下去了。CPU 性能的提升开始从提高主频转向增加 CPU 数量（多核、多 CPU）。越来越多的 CPU 对前端总线的争用，使前端总线成为了瓶颈。为了消除 UMA 架构的瓶颈，NUMA&lt;sup&gt;2&lt;/sup&gt;（Non-Uniform Memory Access, 非一致性内存访问）架构诞生了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;1&quot; data-cropselx2=&quot;374&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;226&quot; data-ratio=&quot;0.6021180030257186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9637P74IBOE3mOYRvZ13aE8ZFytOzExOA0POIUeuUnZpzmcWVU71CCRBu6tKPt0GftYx1Qu3lZvPWmny5StPaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;661&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CPU 厂商把内存控制器集成到 CPU 内部，一般一个 CPU socket 会有一个独立的内存控制器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个 CPU scoket 独立连接到一部分内存，这部分 CPU 直连的内存称为“本地内存”。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CPU 之间通过 QPI（Quick Path Interconnect） 总线进行连接。CPU 可以通过 QPI 总线访问不和自己直连的“远程内存”。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和 UMA 架构不同，在 NUMA 架构下，内存的访问出现了本地和远程的区别：访问远程内存的延时会明显高于访问本地内存。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;NUMA 的设置&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 有一个命令 numactl&lt;sup&gt;3&lt;/sup&gt; 可以查看或设置 NUMA 信息。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;执行 &lt;code&gt;numactl --hardware&lt;/code&gt; 可以查看硬件对 NUMA 的支持信息：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# numactl --hardware&lt;/span&gt;&lt;br/&gt;available: 2 nodes (0-1)&lt;br/&gt;node 0 cpus: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71&lt;br/&gt;node 0 size: 96920 MB&lt;br/&gt;node 0 free: 2951 MB&lt;br/&gt;node 1 cpus: 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95&lt;br/&gt;node 1 size: 98304 MB&lt;br/&gt;node 1 free: 33 MB&lt;br/&gt;node distances:&lt;br/&gt;node   0   1 &lt;br/&gt;  0:  10  21 &lt;br/&gt;  1:  21  10&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CPU 被分成 node 0 和 node 1 两组（这台机器有两个 CPU Socket）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一组 CPU 分配到 96 GB 的内存（这台机器总共有 192GB 内存）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;node distances 是一个二维矩阵，node[i][j] 表示 node i 访问 node j 的内存的相对距离。比如 node 0 访问 node 0 的内存的距离是 10，而 node 0 访问 node 1 的内存的距离是 21。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;执行 &lt;code&gt;numactl --show&lt;/code&gt; 显示当前的 NUMA 设置：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# numactl --show&lt;/span&gt;&lt;br/&gt;policy: default&lt;br/&gt;preferred node: current&lt;br/&gt;physcpubind: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 &lt;br/&gt;cpubind: 0 1 &lt;br/&gt;nodebind: 0 1 &lt;br/&gt;membind: 0 1 &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--cpubind=0&lt;/code&gt;：绑定到 node 0 的 CPU 上执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--membind=1&lt;/code&gt;：只在 node 1 上分配内存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--interleave=nodes&lt;/code&gt;：nodes 可以是 all、N,N,N 或 N-N，表示在 nodes 上轮循（round robin）分配内存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--physcpubind=cpus&lt;/code&gt;：cpus 是 /proc/cpuinfo 中的 processor（超线程） 字段，cpus 的格式与 --interleave=nodes 一样，表示绑定到 cpus 上运行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--preferred=1&lt;/code&gt;：优先考虑从 node 1 上分配内存。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# 运行 test_program 程序，参数是 argument，绑定到 node 0 的 CPU 和 node 1 的内存&lt;/span&gt;&lt;br/&gt;numactl --cpubind=0 --membind=1 test_program arguments&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 在 processor 0-4，8-12 上运行 test_program&lt;/span&gt;&lt;br/&gt;numactl --physcpubind=0-4,8-12 test_program arguments&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 轮询分配内存&lt;/span&gt;&lt;br/&gt;numactl --interleave=all test_program arguments&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 优先考虑从 node 1 上分配内存&lt;/span&gt;&lt;br/&gt;numactl --preferred=1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;测试 NUMA&lt;/h1&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sys/time.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;** argv)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;std&lt;/span&gt;::stoi(argv[&lt;span&gt;1&lt;/span&gt;]);&lt;br/&gt;  &lt;span&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;&lt;span&gt;uint64_t&lt;/span&gt;&amp;gt;&amp;gt; &lt;span&gt;data&lt;/span&gt;&lt;span&gt;(size, &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;&lt;span&gt;uint64_t&lt;/span&gt;&amp;gt;(size))&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;timeval&lt;/span&gt; &lt;span&gt;b&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;  gettimeofday(&amp;amp;b, &lt;span&gt;nullptr&lt;/span&gt;);&lt;br/&gt;  # 按列遍历，避免 CPU cache 的影响&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; col = &lt;span&gt;0&lt;/span&gt;; col &amp;lt; size; ++col) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; row = &lt;span&gt;0&lt;/span&gt;; row &amp;lt; size; ++row) {&lt;br/&gt;      data[row][col] = rand();&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;timeval&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;  gettimeofday(&amp;amp;e, &lt;span&gt;nullptr&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;Use time &quot;&lt;/span&gt;&lt;br/&gt;            &amp;lt;&amp;lt; e.tv_sec * &lt;span&gt;1000000&lt;/span&gt; + e.tv_usec - b.tv_sec * &lt;span&gt;1000000&lt;/span&gt; - b.tv_usec&lt;br/&gt;            &amp;lt;&amp;lt; &lt;span&gt;&quot;us&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# numactl --cpubind=0 --membind=0 ./numa_test 20000&lt;/span&gt;&lt;br/&gt;Use time 16465637us&lt;br/&gt;&lt;span&gt;# numactl --cpubind=0 --membind=1 ./numa_test 20000 &lt;/span&gt;&lt;br/&gt;Use time 21402436us&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出，测试程序使用远程内存比使用本地内存慢了接近 30%&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Linux 的 NUMA 策略&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 识别到 NUMA 架构后，默认的内存分配方案是：优先从本地分配内存。如果本地内存不足，优先淘汰本地内存中无用的内存。使内存页尽可能地和调用线程处在同一个 node。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种默认策略在不需要分配大量内存的应用上一般没什么问题。但是对于数据库这种可能分配超过一个 NUMA node 的内存量的应用来说，可能会引起一些奇怪的性能问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是在网上看到的的例子：由于 Linux 默认的 NUMA 内存分配策略，导致 MySQL 在内存比较充足的情况下，出现大量内存页被换出，造成性能抖动的问题。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;The MySQL “swap insanity” problem and the effects of the NUMA architecture&lt;sup&gt;4&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;A brief update on NUMA and MySQL&lt;sup&gt;5&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;参考资料&lt;/h1&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;UMA（Uniform Memory Access, 一致性内存访问）：https://en.wikipedia.org/wiki/Uniform_memory_access&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NUMA（Non-Uniform Memory Access, 非一致性内存访问）：https://en.wikipedia.org/wiki/Non-uniform_memory_access&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;numactl：https://linux.die.net/man/8/numactl&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;The MySQL “swap insanity” problem and the effects of the NUMA architecture：http://blog.jcole.us/2010/09/28/mysql-swap-insanity-and-the-numa-architecture/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;A brief update on NUMA and MySQL：http://blog.jcole.us/2012/04/16/a-brief-update-on-numa-and-mysql/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NUMA架构的CPU -- 你真的用好了么？：http://cenalulu.github.io/linux/numa/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Thread and Memory Placement on NUMA Systems: Asymmetry Matters：https://www.usenix.org/conference/atc15/technical-session/presentation/lepers&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NUMA (Non-Uniform Memory Access): An Overview：https://queue.acm.org/detail.cfm?id=2513149&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NUMA Memory Policy：https://www.kernel.org/doc/html/latest/admin-guide/mm/numa_memory_policy.html&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;What is NUMA?：https://www.kernel.org/doc/html/latest/vm/numa.html&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>32da990d9389db0c5a84246e2d13fbb1</guid>
<title>从 Druid 到 ClickHouse：eBay 广告平台数据 OLAP 实战</title>
<link>https://toutiao.io/k/zrzpydr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;img data-ratio=&quot;0.4555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nwwClDeS1mMMxSxibzd3N6pskLxemT97kHiaib9Huemcq53Wh6YiaXicumPkdfCdojfchR05wZ8X0G11bc3PJYR9G7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;供稿 | &lt;span&gt;eBay Ads Team&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作者 | 吴寒思 周路 余何&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;编辑 | 顾欣怡&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文5272字，预计阅读时间17分钟&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;更多干货请关注“eBay技术荟”公众号&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;导读&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt; &lt;span&gt;INTRODUCTION&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;本文介绍eBay广告数据平台的基本情况，并对比分析了ClickHouse与Druid的使用特点。基于ClickHouse表现出的良好性能和扩展能力，本文介绍了如何将eBay广告系统从Druid迁移至ClickHouse，希望能为同业人员带来一定的启发。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;01&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;eBay广告数据平台为eBay第一方广告主（使用Promoted Listing服务的卖家）提供了广告流量、用户行为和效果数据分析功能。广告卖家通过卖家中心（Seller Hub）的营销标签页、效果标签页和公开API，有效掌控和对比店铺的营销活动和推广商品的流量、销量的实时和历史数据，并通过网页或者API 下载数据分析报告。&lt;/p&gt;&lt;section&gt;这一系统上线之初使用了自研的分布式SQL引擎，构建在对象存储系统之上。3年前随着广告流量增加，我们把数据引擎切换到Druid上。&lt;/section&gt;&lt;section&gt;这一平台的主要挑战如下：&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;数据量大&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：每日的插入数据记录有&lt;/span&gt;&lt;strong&gt;&lt;span&gt;数百亿条&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，每秒的插入峰值接近&lt;/span&gt;&lt;strong&gt;&lt;span&gt;一百万条&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;离线数据摄入&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：在不影响实时数据摄入的情况下，每天需要对前1-2天的数据进行在线替换。根据上游数据团队发布清洗过的每日数据，广告数据平台需要在不影响查询的情况下每日替换实时数据，数据切换要求实现跨节点的全局原子操作。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;完整性和一致性&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：面向卖家的财务数据，离线更新后的数据要求不能有遗漏和重复；实时数据要求端对端的延迟在&lt;/span&gt;&lt;strong&gt;&lt;span&gt;十秒&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;内。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt; Druid &lt;span&gt;&lt;em&gt;VS.&lt;/em&gt;&lt;/span&gt; ClickHouse&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Druid于2011年由Metamarkets开发，是一款高性能列式在线分析和存储引擎。它于2012年开源，2015年成为Apache基金会旗下项目。Druid在业界使用广泛，为千亿级数据提供亚秒级的查询延迟，擅长高可用、水平扩展；另外为数据摄入提供了很多非常方便的聚合、转换模版，内建支持多种数据源，最快可以在几十分钟内配置好新的数据表，包括数据定义和数据摄入链路（Lambda架构），大大提高了开发效率。&lt;/p&gt;&lt;section&gt;ClickHouse由俄罗斯最大的搜索引擎公司Yandex研发，设计目标是支持Yandex.Metrica（世界第二大Web分析平台）生成用户分析报表等核心功能。ClickHouse是一个数据库管理系统（DBMS），有数据库、表、视图、DDL、DML等概念，并提供了较为完整的SQL支持。其核心特性有如下几点：&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;高效的数据存储&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：通过数据压缩和列式存储，可以达到最高10倍的数据压缩率。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;高效的数据查询&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：通过主键索引、向量化引擎处理、多处理器并发和分布式查询，最大压榨CPU的所有能力，在中小规模的数据量上尤为突出。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;灵活的数据定义和接入&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：通过支持SQL语言、JDBC和关系模型，降低学习和迁移成本，可以和其他现有数据的产品无缝集成。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;03&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;为什么迁移？&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 3.1&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;运维&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;Druid虽然提供了很多非常方便的数据摄入功能，但它的组件构成也较为复杂，节点类型有6种（Overload, Coordinator, Middle Manager, Indexer, Broker和Historical）。除了自身的节点，Druid还依赖于MySQL存储元数据信息、Zookeeper选举Coordinator和Overlord、HDFS备份历史数据。&lt;/section&gt;&lt;section&gt;ClickHouse的架构采用了对等节点的设计，节点只有一种类型，没有主从节点。如果使用了副本功能，则依赖于Zookeeper保存数据段的同步进度。&lt;/section&gt;&lt;section&gt;与此同时，eBay的基础架构团队提出在定制ClickHouse的基础上，向产品团队提供列式数据库存储的服务。除了运维和生命周期管理，基础架构团队对ClickHouse进行改造和二次开发，进一步提高了数据摄入和存储的效率，并在离线摄入方面弥补了和Druid的功能差距。&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 3.2&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;延时数据插入&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Druid通过引入实时数据的索引任务，把实时数据处理成一个个分段数据(segment)，并归档成历史数据。成为分段数据之后，该时段数据即不可写入。由于并发实时索引任务数的限制，我们设置了3个小时的窗口长度（每个小时一个任务），因此超过3个小时的数据就无法写入。在某些极端情况下，例如上游数据延迟或者实时数据消费过于滞后，就会导致离线数据替换前这部分数据的缺失。ClickHouse则没有这个限制，任意分区都可以随时写入。&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 3.3&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;主键优化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;ClickHouse支持的主键并不是传统意义下关系型数据库的主键。传统的主键要求每条表记录都有唯一的键值，通过查询主键可以唯一地查询到一条表记录。而在ClickHouse中，主键定义了记录在存储中排序的顺序，允许重复，所以称之为排序键似乎更加合理。事实上在ClickHouse里的主键定义通过ORDER BY声明，仅在个别场景中允许和排序键不一致（但必须是排序键的前缀）。&lt;/section&gt;&lt;section&gt;由于我们的产品是给卖家提供分析功能，几乎所有的查询限定在了单一卖家维度，因此通过主键按照卖家排序，可以极大地提高查询效率以及数据压缩率。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;04&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;系统架构&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5101852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nwwClDeS1mMMxSxibzd3N6pskLxemT97kEpyAiag4mPibaSLp74LoCvNLzdHxziayrsSLC0KfBeBJUibricRhgg1U6iaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图1（点击可查看大图）&lt;/span&gt;&lt;/section&gt;&lt;p&gt;如图1所示，系统由4个部分组成：&lt;/p&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;实时数据获取模块，接入eBay的行为和交易实时消息平台；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;离线数据替换模块，接入eBay内部的数据仓库平台；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;ClickHouse部署和外围数据服务；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;报表服务，支撑广告主、商家后台和eBay公开API。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;05&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;实战经历&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 5.1&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Schema 设计&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;ClickHouse提供了丰富的schema配置。这方面需要根据业务场景和数据模式反复斟酌和多次试验，因为不同的选择会对存储和性能有数量级的影响，一个错误的选择会导致后期巨大的调优和变更成本。&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;strong&gt;1）表引擎&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;ClickHouse的存储引擎的核心是合并树(MergeTree)，以此为基础衍生出汇总合并树（SummingMergeTree），聚合合并树（AggregationMergeTree），版本折叠树（VersionCollapsingTree）等常用的表引擎。另外上述所有的合并树引擎都有复制功能（ReplicatedXXXMergeTree）的对应版本。&lt;/section&gt;&lt;section&gt;我们的广告数据平台的展示和点击数据选择了复制汇总合并树。这两类用户行为数据量极大，减小数据量节省存储开销并提升查询效率是模式设计的主要目标。ClickHouse在后台按照给定的维度汇总数据，降低了&lt;strong&gt;&lt;span&gt;60%&lt;/span&gt;&lt;/strong&gt;的数据量。销售数据选择了普通的复制合并树，一方面由于销售数据对某些指标有除汇总以外的聚合需求，另一方面由于本身数据量不大，合并数据的需求并不迫切。&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;strong&gt;2）主键&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;一般情况下，ClickHouse表的主键（Primary Key）和排序键（Order By Key）相同，但是采用了汇总合并树引擎（SummingMergeTree）的表可以单独指定主键。把一些不需要排序或者索引功能的维度字段从主键里排除出去，可以减小主键的大小（主键运行时需要全部加载到内存中），提高查询效率。&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;strong&gt;3）压缩&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;ClickHouse支持列级别的数据压缩，显著地减少原始数据的存储量，这也是列存储引擎的巨大优势。查询阶段，较小的存储占用也可以减少IO量。对不同列选择一种合适的压缩算法和等级，能把压缩和查询的平衡做到性价比最优。&lt;/section&gt;&lt;section&gt;ClickHouse的所有列默认使用LZ4压缩。除此以外，一般的数据列可以选择更高压缩率的算法如LZ4HC，ZSTD；而对于类似时间序列的单调增长数据可以选择DoubleDelta, Gorilla等特殊压缩算法。LZ4HC和ZSTD等高压缩率的算法还可以自己选择压缩级别。在我们的生产数据集上，ZSTD算法对String类型字段压缩效果较为显著。LZ4HC是LZ4的高压缩比改进版，更适用于非字符串类型。&lt;/section&gt;&lt;section&gt;更高的压缩率意味着更少的存储空间，同时由于降低了查询的IO量，可以间接提升查询性能。不过CPU也不是大风刮来的，数据的插入性能就成了牺牲品。根据我们内部测试的数据，在我们的生产数据集上使用LZ4HC(6)相比LZ4可以节省&lt;span&gt;&lt;strong&gt;30%&lt;/strong&gt;&lt;/span&gt;的数据，但实时数据摄取性能下降了&lt;strong&gt;&lt;span&gt;60%&lt;/span&gt;&lt;/strong&gt;。&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;strong&gt;4）低基&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;值得一提的是，对于基数较低的列（即列值多样性低），可以使用LowCardinality来降低原始存储空间（从而降低最终存储空间）。如果在使用压缩算法的情况下对一字符串类型的列使用LowCardinality，还能再缩小25%的空间量。&lt;/section&gt;&lt;section&gt;在我们的测试数据集上，如果整表组合使用LowCardinality、LZ4HC(6)和ZSTD(15)，整体压缩比大约在原来的&lt;strong&gt;&lt;span&gt;13%&lt;/span&gt;&lt;/strong&gt;左右。&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 5.2&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;离线数据替换&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;strong&gt;1）挑战&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;针对广告主的数据报表要求数据准确、一致。实时的行为数据存在少量的bot数据（需要离线清除），另外广告的归因也需要在离线阶段重新调整，因此我们引入了离线数据链路，在实时数据写入24-72小时之后，用离线数据替换实时数据。其中的挑战如下：&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;广告系统每天需要处理的用户离线数据量近&lt;/span&gt;&lt;span&gt;&lt;strong&gt;1TB&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，在此之前，需要耗费大量时间将数据从Hadoop导入Druid。另外，导入期间的I/O、CPU和内存的开销对查询的压力不小。如何在保证数据一致性的同时，亦确保数据迁移的效率，是问题的关键。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如何在数据替换期间，确保用户可见的数据波动最小。这就要求数据替换操作是原子性的，或者至少对每个广告主都是原子的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;除了日常的离线数据更新，在数据仓库数据出现偏差遗漏时，需要支持大范围的数据修正和补偿。作业调度要求保证日常工作及时完成，并尽快完成数据修正工作。此外还需要监控数据更新中的各种指标，以应对各种突发状况。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;Druid原生支持数据离线更新服务，我们与基础架构团队合作，在ClickHouse平台实现了这一功能。&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;strong&gt;2）数据架构&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;对于整合在线数据和离线数据的大数据架构，业界通常的做法是Lambda架构。即离线层和在线层分别导入数据，在展示层进行数据的合并。&lt;/section&gt;&lt;section&gt;我们也大致上采用了这一架构。但具体的做法和经典有所不同。ClickHouse里数据分区(partition)是一个独立的数据存储单元，每一个分区都可以单独从现有表里脱离(detach)、引入(attach)和替换(replace)。分区的条件可以自定义，一般按照时间划分。通过对数据表内数据分区的单个替换，我们可以做到查询层对底层数据更新的透明，也不需要额外的逻辑进行数据合并。&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;strong&gt;3）Spark聚合与分片&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;为了降低ClickHouse导入离线数据性能压力，我们引入了Spark任务对原始离线数据进行聚合和分片。每个分片可以分别拉取并导入数据文件，节省了数据路由、聚合的开销。&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;strong&gt;4）数据更新任务管理&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;A. 锁定分区拓扑结构&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;在处理数据前，离线数据更新系统向基础架构团队提供的服务请求锁定ClickHouse的分区拓扑结构，在此期间该分区的拓扑结构不会改变。服务端根据预先定义好的数据表结构与分区信息返回数据的分片逻辑与分片ID。离线数据更新系统根据拓扑信息提交Spark任务。多张表的数据处理通过Spark并行完成，显著提升了数据更新的速度。&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;B. 数据聚合与分片&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;对于每一张需要更新的表，启动一个Spark任务对数据进行聚合与分片。根据ClickHouse服务端返回的表结构与分片拓扑将数据写入Hadoop，同时输出数据替换阶段用于校验一致性的checksum与分片行数。系统通过Livy Server API提交并轮询任务状态，在有任务失败的情况下进行重试，以排除Spark集群资源不足导致的任务失败。离线数据更新不但要满足每天的批量数据更新需求，还需要支持过往数据的再次更新，以便同步上游数据在日常定时任务更新之外的数据变动。&lt;/section&gt;&lt;section&gt;我们利用平台团队封装的Spring Batch管理更新任务，按照日期将每天的数据划分为一个子任务。通过Spring Batch实现的Continuously Job保证在同一时刻子任务在运行的唯一性，避免产生任务竞争问题。对于过往数据的更新，我们将Batch任务分类，除了日常任务之外，还可以手动触发给定时间范围内的数据修正任务（如图2）。&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.556962&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nwwClDeS1mMMxSxibzd3N6pskLxemT97k6Ay9hz6WGoqr6ROW840MuAwsJhupQSdWtS9Jxgb5WnPEcjibkRM1Slw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;948&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;图2（点击可查看大图）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;C. 数据替换&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;在子任务中的所有Spark Job完成后，离线数据更新系统会调用基础架构团队提供的数据替换接口，发起数据替换请求。服务端按照定义好的分区，将数据从Hadoop直接写入ClickHouse，如图3所示。&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7981481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nwwClDeS1mMMxSxibzd3N6pskLxemT97kMHjnDKV827mq83mRjTyb5G38VWP861SlVC9grJwITHePLR6ZiaPXKpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图3（点击可查看大图）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;离线数据更新系统的架构如图4所示。MySQL数据库用于记录数据替换过程中任务的状态与优先级，当Spark Job失败或者由于其他原因导致替换任务失败重启后，恢复任务的进度。&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.8185185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nwwClDeS1mMMxSxibzd3N6pskLxemT97k0oba3zjzk3VFTicPVfwficMrJLQrp4hdPuib82FNgDUu2MLvXazxBDMZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图4（点击可查看大图）&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;strong&gt;5） 原子性与一致性&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;为了保证数据替换的原子性，基础架构团队提供了分区替换的方式。在离线数据导入的过程中，首先创建目标分区的临时分区。当数据替换完毕并且校验完成之后，目标分区会被临时分区替换。针对不同机器上不同分片的原子性替换问题，基础架构团队为每一条数据引入了数据版本。对于每一个数据分区，都有对应的活跃版本号。直到待替换数据分区的所有分片都成功导入之后，分区的版本号进行更新。上游应用的同一条SQL只能读取同一分区一个版本的数据，每个分区的数据替换只感觉到一次切换，并不会出现同时读取新旧数据的问题。&lt;/section&gt;&lt;section&gt;广告平台报表生成应用因此在SQL层面引入了相应的修改，通过引入固定的WITH和PREWHERE语句，在字典中查询出每个数据分区对应的版本号，并在查询计划中排除掉不需要的数据分区。&lt;/section&gt;&lt;section&gt;为了确保数据替换的一致性，在完成Spark数据处理之后，离线数据更新系统会计算各数据分片的校验码与数据总量。当替换完毕之后，ClickHouse服务端会对分片数据进行校验，确保在数据搬迁过程中没有数据丢失和重复。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;06&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;数据查询&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ClickHouse支持SQL查询（不完全），有HTTP和TCP两种连接方式，官方和第三方的查询工具和库丰富。用户可以使用命令行，JDBC或者可视化工具快速进行数据查询的开发和调试。ClickHouse通过MPP(Massively Parallel Processing) + SMP(Symmetric Multiprocessing)充分地利用机器资源，单条查询语句默认使用机器核数一半的CPU，因此ClickHouse不支持高并发的应用场景。在业务使用层面，最核心的问题是查询校验和并发控制，单条过大的查询或者过高的并发都会导致集群资源使用率过高，影响集群稳定性。&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 6.1&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;应用架构&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;Ebay Seller Hub通过Reports Service接入ClickHouse查询，Reports Service提供了Public和Internal两套API。Internal API提供给Seller Hub以及其他内部的已知应用使用，Public API在eBay Developers Program（详情见：&lt;span&gt;https://developer.ebay.com/&lt;/span&gt;）开放给第三方开发者。&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/nwwClDeS1mMMxSxibzd3N6pskLxemT97kicsqMkAf9nBSlGbeR9plgWU6x19d9jAiamvPKYNN6WYhXSk52Mdh0Gkw/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;830.9225092250922&quot; data-ratio=&quot;0.7685185185185185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nwwClDeS1mMMxSxibzd3N6pskLxemT97kAkszdaRe8cKMrpwwWebpIjjozAnuoXWUzQicicpMAKgibIgfQ0iaatNzKw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;图5（点击可查看大图）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;Internal API的查询直接提交内部线程池执行，线程池的大小根据ClickHouse的集群机器数量设置。查询请求执行前会进行校验，过滤所有非法以及资源不可预估的请求。&lt;/section&gt;&lt;section&gt;Public API通过任务提交的方式异步执行查询，用户提交的查询任务存入DB中，Service内部的Schedule定时扫表，根据任务的状态串行执行查询任务。执行成功的任务上传生成Report到文件服务器，用户拿到URL后自行下载。执行失败的任务，根据错误类型（非法的请求，资源不足等）来选择是否在下一个周期再次执行。&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 6.2&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;测试发布&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;在生产环境部署完成后，我们开启了数据双写，往ClickHouse里不断地插入实时数据和离线数据，直到达到Druid的数据水平。在数据一致性验证过后，我们镜像了一份生产服务的查询，然后把这些查询转发给ClickHouse。通过收集和对比Druid和ClickHouse的响应，我们能够验证ClickHouse链路的数据质量和查询性能。之后的灰度阶段，我们逐渐提升ClickHouse服务生产系统的比例，并保持Druid继续运行，以保证出现问题可以及时回滚。&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 6.3&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;查询GUI&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;数据可视化方面，我们需要提供类似Turnilo的可视化工具给开发、测试和BI人员使用。ClickHouse支持多种商业和开源的产品接入，我们选用了Cube.JS，并进行了简单的二次开发。&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4842593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nwwClDeS1mMMxSxibzd3N6pskLxemT97kvNQ1bsvc8Fz8ibyLHFE5kke8lwWrktE6GOExGKztVmOic69WyfZQE37Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;图6（点击可查看大图）&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;07&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;本文介绍了广告数据平台的基本情况，ClickHouse/Druid的特点对比和团队使用ClickHouse替换Druid的架构方案。ClickHouse表现出了良好的性能和扩展能力，并且还在快速的迭代更新。目前项目已经上线，接下来我们还会和大家继续分享过程中的碰到的一些问题和解决方法，欢迎大家持续关注。&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;您可能还感兴趣：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MDMyNDUzOQ==&amp;amp;mid=2650508894&amp;amp;idx=1&amp;amp;sn=4bf7318920e8da0c1870279be18bd60a&amp;amp;chksm=8731b60ab0463f1c5fa0edd6aaf95984bed5c125d6f1dde542648f7f5dd29fead7f68a1c1fe5&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Hadoop平台进阶之路| 一场PB规模量级的HDFS数据迁移实战&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MDMyNDUzOQ==&amp;amp;mid=2650508767&amp;amp;idx=1&amp;amp;sn=d48f285471b735c59888033973032959&amp;amp;chksm=8731b58bb0463c9d8b594218f915dd77a181bdf0399dd7554b54f80fff5a135912504218d6e1&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Hadoop平台进阶之路 | eBay Spark测试框架——Woody&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MDMyNDUzOQ==&amp;amp;mid=2650508891&amp;amp;idx=1&amp;amp;sn=c57f53b58860301f34f7c1839f70d889&amp;amp;chksm=8731b60fb0463f195acc49547b90bbfd24206cdf86a4260fccc5dc69c00c62900cd64d207132&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;技术分享｜基于图的大规模微服务Trace分析方法与企业实践&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MDMyNDUzOQ==&amp;amp;mid=2650508843&amp;amp;idx=1&amp;amp;sn=b43da4c2691cab6e67f66d90a7154024&amp;amp;chksm=8731b67fb0463f691d00b37dda441eee867840a97f58da139478d91c87bedc8c555b5966051a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;超越“双十一” | ebay支付核心账务系统架构演进之路&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MDMyNDUzOQ==&amp;amp;mid=2650507100&amp;amp;idx=1&amp;amp;sn=08133d64ad916afd60deb4e61ac7e928&amp;amp;chksm=8731bf08b046361e003df71703fabc71c0cacaf39fe4b94bf2a64189d09156f62a36a0cebc4d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;超越“双十一”—— ebay百万TPS支付账务系统的设计与实现&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MDMyNDUzOQ==&amp;amp;mid=2650508841&amp;amp;idx=1&amp;amp;sn=20b1e5cf0796cb658ede3cc6876797db&amp;amp;chksm=8731b67db0463f6b17fdf5431246cfec39b0d0ddb705149e2e14c011ebb5a74793a12a9c953f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;平台迁移那些事 | eBay GC调优策略的实践&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MDMyNDUzOQ==&amp;amp;mid=2650508307&amp;amp;idx=1&amp;amp;sn=e1a2efbdcfe871929ad9f6511e40f8d9&amp;amp;chksm=8731b447b0463d519c8bf1f802577576cebf145eee8a6f3522924505c17a79990f2f4d6e04c5&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;平台迁移那些事 | eBay百亿级流量迁移策略&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MDMyNDUzOQ==&amp;amp;mid=2650507960&amp;amp;idx=1&amp;amp;sn=f6a63284aacf287e9d926e122a753da5&amp;amp;chksm=8731b2ecb0463bfa92430e6fa638e77cd17e59321481c7cac0ba7a07dfda5065aa0c0d0516c6&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;分享 | eBay TESS，我心中的那朵“云”&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MDMyNDUzOQ==&amp;amp;mid=2650507912&amp;amp;idx=1&amp;amp;sn=653f41ceb4c97c8a2a19b7cb7fd4870a&amp;amp;chksm=8731b2dcb0463bca70122af8c37c99f12881f12c9970517b7b87557cbe8f25f27e88ecbaf1cb&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;前沿 | BERT在eBay推荐系统中的实践&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MDMyNDUzOQ==&amp;amp;mid=2650508098&amp;amp;idx=1&amp;amp;sn=2f11f7af732f4e505a188f6db23f215b&amp;amp;chksm=8731b316b0463a00d74e2aa01dca3f8fbad25aad3b43a9182e0262cb0b61760c54581aa7260c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;eBay云计算“网”事｜网络重传篇&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MDMyNDUzOQ==&amp;amp;mid=2650507840&amp;amp;idx=1&amp;amp;sn=20e2d810c56f92a8eb2e7f4820ffa549&amp;amp;chksm=8731b214b0463b0254b6ebfc7cdc631de513f915066aec03a82719eda725cb4847367452c5a4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;eBay云计算“网”事｜网络丢包篇&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MDMyNDUzOQ==&amp;amp;mid=2650507734&amp;amp;idx=1&amp;amp;sn=1423e8eadb6118c889dd5da77622c8d0&amp;amp;chksm=8731b182b046389408d1e751f3f2492e2cba7a3735a8b2f6233ef1355ed095ffe711c20b3f9e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;eBay云计算“网”事 | 网络超时篇&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.36134453781512604&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nwwClDeS1mMMxSxibzd3N6pskLxemT97krldGO0LhpEW4icgaCHTXaQojQe6YzzjSsYaibwTgIS07K05GP9IyJ5Mg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;119&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;👇点击&lt;/span&gt;&lt;span&gt;阅读原文&lt;/span&gt;&lt;span&gt;，一键投递 &lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;    eBay大量优质职位，等的就是你&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>