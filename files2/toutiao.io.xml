<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>722d26290f0db20d0cc70fb4338784dd</guid>
<title>今天搬砖不狠，明天地位不稳！</title>
<link>https://toutiao.io/k/iuxq2xo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一周过得好快啊！又快周五啦！&lt;span&gt;第 030 期「码农周刊 VIP 会员专属邮件周报」，将于本周五晚发送。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数位上市公司 CTO 都在订阅的「码农周刊 VIP 会员专属邮件周报」，你还等什么？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;255&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;255&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ4LlicrXjOxMtaQDWoib2X24FnCibVaaZDqGa6VhDuw5a6cJtG8eg35xVuS75hozib0Z3Kib07lhzJsTSA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;274&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;「码农周刊 VIP 会员」是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;简介版&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;码农周刊 VIP 会员 = 全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;详细版&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击「阅读原文」即可查看详细介绍&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;加入「码农周刊 VIP 会员」，与上市公司 CTO 一起成长！&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利，你值得拥有！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;原价 365 元/年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;，现价仅需 108 元！&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;260&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;260&quot; data-ratio=&quot;1.3478260869565217&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavibNJDoLvVWUq6RKn5LwtlzRHSMFBED29234hRwibmOzJF4XxKOv5lzRVCelQJIEIOaXh3vYRHOMRzQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2e0971b9ffb0f94adda848db1660fad3</guid>
<title>[推荐] Docker 底层原理浅析</title>
<link>https://toutiao.io/k/nvbge2t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：vitovzhong，腾讯 TEG 应用开发工程师&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;容器的实质是进程，与宿主机上的其他进程是共用一个内核，但与直接在宿主机执行的进程不同，容器进程运行在属于自己的独立的命名空间。命名空间隔离了进程间的资源，使得 a,b 进程可以看到 S 资源，而 c 进程看不到。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1.  演进&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于统一开发、测试、生产环境的渴望，要远远早于 docker 的出现。我们先来了解一下在 docker 之前出现过哪些解决方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1.1 vagrant&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vagarant 是笔者最早接触到的一个解决环境配置不统一的技术方案。它使用 Ruby 语言编写，由 HashCorp 公司在 2010 年 1 月发布。Vagrant 的底层是虚拟机，最开始选用的是 virtualbox。一个个已经配置好的虚拟机被称作 box。用户可自由在虚拟机内部的安装依赖库和软件服务，并将 box 发布。通过简单的命令，就能够拉取 box，将环境搭建起来。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 拉取一个ubuntu12.04的box&lt;br/&gt;$ vagrant init hashicorp/precise32&lt;br/&gt;&lt;br/&gt;// 运行该虚拟机&lt;br/&gt;$ vagrant up&lt;br/&gt;&lt;br/&gt;// 查看当前本地都有哪些box&lt;br/&gt;$ vagrant box list&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果需要运行多个服务，也可以通过编写 vagrantfile，将相互依赖的服务一起运行，颇有如今 docker-compose 的味道。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;config.vm.define(&lt;span&gt;&quot;web&quot;&lt;/span&gt;) &lt;span&gt;do&lt;/span&gt; |web|web.vm.box = &lt;span&gt;&quot;apache&quot;&lt;/span&gt;&lt;br/&gt;end&lt;br/&gt;config.vm.define(&lt;span&gt;&quot;db&quot;&lt;/span&gt;) &lt;span&gt;do&lt;/span&gt; |db|db.vm.box = &lt;span&gt;&quot;mysql”&lt;br/&gt;end&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7592592592592593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmLHibX7PrevicHnsnVshLfria4srekIQ9ibETqzE4Jaic4gmR9hEKzkDiaByyA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;864&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1.2 LXC (LinuX Container)&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0236559139784946&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmLgP86LTkBOIu4yyWEBrHKveaMZbhXM3oGCeNqKbMXcREbWPc1YJ7F4g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;465&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 2008 年，Linux 2.6.24 将 cgroups 特性合入了主干。Linux Container 是 Canonical 公司基于 namespace 和 cgroups 等技术，瞄准容器世界而开发的一个项目，目标就是要创造出运行在 Linux 系统中，并且隔离性良好的容器环境。当然它最早也就见于 Ubuntu 操作系统上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2013 年，在 PyCon 大会上 Docker 正式面世。当时的 Docker 是在 Ubuntu 12.04 上开发实现的，只是基于 LXC 之上的一个工具，屏蔽掉了 LXC 的使用细节（类似于 vagrant 屏蔽了底层虚拟机），让用户可以一句  docker run  命令行便创建出自己的容器环境。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.  技术发展&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;容器技术是操作系统层面的虚拟化技术，可以概括为使用  Linux 内核的 cgroup，namespace 等技术，对进程进行的封装隔离。早在  Docker 之前，Linux 就已经提供了今天的 Docker 所使用的那些基础技术。Docker 一夜之间火爆全球，但技术上的积累并不是瞬间完成的。我们摘取其中几个关键技术节点进行介绍。&lt;span/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.19133574007220217&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmLtqibDhUFmUyhx92jvtAefEdXTS9THopiawPj8euxfqc0yjAQicAfK7OxQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;554&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.1 Chroot&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件主要分为系统软件和应用软件，而容器中运行的程序并非系统软件。容器中的进程实质上是运行在宿主机上，与宿主机上的其他进程共用一个内核。而每个应用软件运行都需要有必要的环境，包括一些 lib 库依赖之类的。所以，为了避免不同应用程序的 lib 库依赖冲突，很自然地我们会想是否可以把他们进行隔离，让他们看到的库是不一样的。基于这个朴素的想法，1979 年， chroot 系统调用首次问世。来举个例子感受一下。在 devcloud 上申请的云主机，现在我的 home 目录下准备好了一个 alpine 系统的 rootfs，如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.11079943899018233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmLiaaiaSWYZq9RPIEZeBiclwB6V8fa7EEg3teMB7dZdZVB9p648IPEdRG3g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;713&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在该目录下执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;chroot rootfs/ /bin/bash&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后将/etc/os-release 打印出来，就看到是”Alpine Linux”，说明新运行的 bash 跟 devcloud 主机上的 rootfs 隔离了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.26810477657935283&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmL3HNXD88cPkpbY0H9QheibCtH7dXvicdtNZbua88PIWcZ5543oIu1n3iaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;649&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.1 Namespace&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说  namespace 是由 Linux 内核提供的，用于进程间资源隔离的一种技术，使得 a,b 进程可以看到 S 资源；而 c 进程看不到。它是在 2002 年 Linux 2.4.19 开始加入内核的特性，到 2013 年 Linux 3.8 中 user namespace 的引入，对于我们现在所熟知的容器所需的全部 namespace 就都实现了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 提供了多种 namespace，用于对多种不同资源进行隔离。容器的实质是进程，但与直接在宿主机执行的进程不同，容器进程运行在属于自己的独立的命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是来看一个简单的例子，让我们有个感性认识，namespace 到底是啥，在哪里能直观的看到。在 devcloud 云主机上，执行：&lt;em&gt;ls-l /proc/self/ns  看到的就是当前系统所支持的 namespace。&lt;/em&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.17687747035573123&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmL5nxb8m8CJrgicOR3Y86xe7AUic9ys5zdsV3fMHfiatPYolWEDKibO7CYZA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1012&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着我们使用 unshare 命令，运行一个 bash，让它不使用当前的 pid namespace：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;unshare --pid --fork --mount-proc bash&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后运行: &lt;em&gt;ps -a&lt;/em&gt; 看看当前 pid namespace 下的进程都有哪些：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1553398058252427&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmLK75YbibWvuRX3mQO8wE1ttQjcGQmZYAJDQGSRIsnkibXoZ3ziaV5SEaRg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;515&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在新起的 bash 上执行：&lt;em&gt;ls -l /proc/self/ns，&lt;/em&gt; 发现当前 bash 的 pid namespace 与之前是不相同的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.17676767676767677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmLKkfs89x4hcPib4DrvAZ7ibODcQib0pdiaJ28ib8ZmXKELvqlmicZHl9PicEhg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;990&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然 docker 就是基于内核的 namespace 特性来实现的，那么我们可以简单来认证一下，执行指令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; docker run –pid host --rm -it alpine sh&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行一个简单的 alpine 容器，让它与主机共用同一个 pid namespace。然后在容器内部执行指令 ps -a 会发现进程数量与 devcloud 机器上的一样；执行指令 &lt;em&gt;ls -l /proc/self/ns/&lt;/em&gt; 同样会看到容器内部的 pid namespace 与 devcloud 机器上的也是一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.2 cgroups&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cgroups 是 namespace 的一种，是为了实现虚拟化而采取的资源管理机制，决定哪些分配给容器的资源可被我们管理，分配容器使用资源的多少。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。例如可以设定一个 memory 使用上限，一旦进程组（容器）使用的内存达到限额再申请内存，就会出发 OOM（out of memory），这样就不会因为某个进程消耗的内存过大而影响到其他进程的运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是来看个例子感受一下。在 devcloud 机器上运行一个 apline 容器，限制只能使用前 2 个 CPU 且只能使用 1.5 个核：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;docker run --rm -it --cpus &lt;span&gt;&quot;1.5&quot;&lt;/span&gt; --cpuset-cpus 0,1 alpine&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后再开启一个新的终端，先看看系统上有哪些资源是我们可以控制的：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;cat&lt;/span&gt; /proc/cgroups&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.39526184538653364&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmLLORZskAEV0YBb7JUVllJv9MmDqPfMWkYr4ibxQ2bXjzzeUz7yFIMerw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;802&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最左边一侧就是可以设置的资源了。接着我们需要找到这些控制资源分配的信息都放在哪个目录下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;mount&lt;/span&gt; | grep cgroup&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21585903083700442&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmL76IK6RWwfuh84DtIljmzZicLhWdZiaSJJY9Cd6TkwQS6uNibplXJYBF2w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1362&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们找到刚刚运行的 alpine 镜像的 cgroups 配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cat /proc/`docker inspect --format=&lt;span&gt;&#x27;{{.State.Pid}}&#x27;&lt;/span&gt; $(docker ps -ql)`/cgroup&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2237936772046589&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmLkriaiaiaNtiagKlHkE0Y5bCaeMOzAEFzdToichU3usrv6ic17BiahxH8KtcpA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1202&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，把二者拼接起来，就可以看到这个容器的资源配置了。我们先来验证 cpu 的用量是否是 1.5 个核：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cat /sys/fs/cgroup/cpu,cpuacct/docker/c1f68e86241f9babb84a9556dfce84ec01e447bf1b8f918520de06656fa50ab4/cpu.cfs_period_us&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出 100000，可以认为是单位，然后再看配额：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cat /sys/fs/cgroup/cpu,cpuacct/docker/c1f68e86241f9babb84a9556dfce84ec01e447bf1b8f918520de06656fa50ab4/cpu.cfs_quota_us&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出 150000，与单位相除正好是设置的 1.5 个核，接着验证是否使用的是前两个核心：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cat /sys/fs/cgroup/cpuset/docker/c1f68e86241f9babb84a9556dfce84ec01e447bf1b8f918520de06656fa50ab4/cpuset.cpus&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出 0-1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前来看，容器的资源配置都是按照我们设定的来分配的，但实际真能在 CPU0-CPU1 上限制使用 1.5 个核吗？我们先看一下当前 CPU 的用量：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;docker stats $(docker ps -ql)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.15146579804560262&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmLeYIDdBxfJZUb42crauDXpBpnlrgVfSfkkysrCy2YpYoKR0UEgYnFzQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;614&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为没有在 alpine 中运行程序，所以 CPU 用量为 0，我们现在回到最开始执行 docker 指令的 alpine 终端，执行一个死循环：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;i=0; &lt;span&gt;while&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;do&lt;/span&gt; i=i+i; &lt;span&gt;done&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来观察当前的 CPU 用量：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1492776886035313&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmL8WgWcW2rV65GSjhFCyGofnwkRgWyG8uu1bbtB01ia0Su3vFbK3Q8ofA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;623&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接近 1，但为啥不是 1.5？因为刚刚运行的死循环只能跑在一个核上，所以我们再打开一个终端，进入到 alpine 镜像中，同样执行死循环的指令，看到 CPU 用量稳定在了 1.5，说明资源的使用量确实是限制住了的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1646153846153846&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmLCibiaAtJ7z4YlUPzqAcOrr6QrNCK4GWqfkEFOb1X2vPFvb4mYiclow0lw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;650&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们对 docker 容器实现了进程间资源隔离的黑科技有了一定认识。如果单单就隔离性来说，vagrant 也已经做到了。那么为什么是 docker 火爆全球？是因为它允许用户将容器环境打包成为一个镜像进行分发，而且镜像是分层增量构建的，这可以大大降低用户使用的门槛。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3.  存储&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Image 是 Docker 部署的基本单位，它包含了程序文件，以及这个程序依赖的资源的环境。Docker Image 是以一个 mount 点挂载到容器内部的。容器可以近似理解为镜像的运行时实例，默认情况下也算是在镜像层的基础上增加了一个可写层。所以，一般情况下如果你在容器内做出的修改，均包含在这个可写层中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3.1  联合文件系统（UFS）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Union File System 从字面意思上来理解就是“联合文件系统”。它将多个物理位置不同的文件目录联合起来，挂载到某一个目录下，形成一个抽象的文件系统。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.25596816976127323&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmLg5g4w460yZIzLceoCY7wGoDXOPvRV1jsEib4IGhcQFOaXMPNUAedysw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;754&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图，从右侧以 UFS 的视角来看，lowerdir 和 upperdir 是两个不同的目录，UFS 将二者合并起来，得到 merged 层展示给调用方。从左侧的 docker 角度来理解，lowerdir 就是镜像，upperdir 就相当于是容器默认的可写层。在运行的容器中修改了文件，可以使用 docker commit 指令保存成为一个新镜像。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3.2 Docker 镜像的存储管理&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了 UFS 的分层概念，我们就很好理解这样的一个简单 Dockerfile：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;FROM alpine&lt;br/&gt;COPY foo /foo&lt;br/&gt;COPY bar /bar&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在构建时的输出所代表的含义了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.36885245901639346&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmLV5EPhea68A7VBz6EfhiauqU4WX2Nj0tU5Cw6U1YJUgxCtZnUuWaG5SA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;488&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是使用 docker pull 拉取的镜像文件，在本地机器上存储在哪，又是如何管理的呢？还是来实际操作认证一下。在 devcloud 上确认当前 docker 所使用的存储驱动（默认是 overlay2）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;docker info --format &lt;span&gt;&#x27;{{.Driver}}&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以及镜像下载后的存储路径（默认存储在/var/lib/docker）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;docker info --format &lt;span&gt;&#x27;{{.DockerRootDir}}&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当前我的 docker 修改了默认存储路径，配置到/data/docker-data，我们就以它为例进行展示。先查看一下该目录下的结构：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;tree -L &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; /&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;/docker-&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5904255319148937&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmLy2FiaXDAoxmQl2B4ica06UAOJ5spBYhhqEqj124hf6NWAdWicDRpRnNjQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;564&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关注一下其中的 image 和 overlay2 目录。前者就是存放镜像信息的地方，后者则是存放具体每一分层的文件内容。我们先深入看一下 image 目录结构：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;tree -L &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt; /&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;/docker-&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;/image/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.39165009940357853&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmLqlavAsZkzmBQGkS30fuoHB2BRq3vIx19VaI8yHy4icpoK5zj4xNibsWg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;503&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;留心这个 imagedb 目录，接下来以我们以最新的 alpine 镜像为例子，看看 docker 是如何管理镜像的。执行指令：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;docker&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;pull&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;alpine&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:latest&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.09414990859232175&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmLXkwhzdE6VicPhg8EShdJD2dqibyWta4doI3BDLTUzm9yV3XuBHpyTvJw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1094&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;紧接着查看它的镜像 ID：docker image ls alpine:latest&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.050397877984084884&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmLDUIwZIWdU4Vq4uBGrdhyibs6GN3IBWe13Qq1QVefQXXt4FDk6IXEsiaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1131&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记住这个 ID a24bb4013296，现在可以看一下 imagedb 目录下的变化：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;tree -L &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt; /&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;/docker-&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;/image/overlay2/imagedb/content/ | grep&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;a24bb4013296&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.03232533889468196&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmLRWI8G93MI8pChrUA4cFiaRKDfFOibwYndDz5DQVicXnWVdmWiaziaxic0DCQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;959&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多了这么一个镜像 ID 的文件，它是一个 json 格式的文件，这里包含了该镜像的参数信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jq .&lt;br/&gt;/data/docker-data/image/overlay2/imagedb/content/sha256/a24bb4013296f61e89ba57005a7b3e52274d8edd3ae2077d04395f806b63d83e&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5502183406113537&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmLpfUxYIOxWBYQ2oXpCwibRYHF4RWR3a6KaKBuiax4f882D2rT2XwFWcrg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1145&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们看看将一个镜像运行起来之后会有什么变化。运行一个 alpine 容器，让它 sleep10 分钟：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;docker&lt;/span&gt; run --rm -d alpine sleep &lt;span class=&quot;code-snippet__number&quot;&gt;600&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后找到它的 overlay 挂载点：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;docker inspect --format=&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;{{.GraphDriver.Data}}&#x27;&lt;/span&gt; $(docker ps -ql) | grep MergedDir&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.11620553359683794&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmL69z5DDt5N3pbjJs9dxxAGTTViarztD9U1VibwZ6dFaXiaoiasf66jM9nGQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1265&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合上一节讲到的 UFS 文件系统，可以 ls 一下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ls /&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;/docker-&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;/overlay2/&lt;span class=&quot;code-snippet__number&quot;&gt;74e92699164736980&lt;/span&gt;c9e20475388568f482671625a177cb946c4b136e4d94a64/merged&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.02702702702702703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmLy8TWLUdcCecclEic9U5RqSjAWC5Tn7jarF6s2lA8KoIgOZbQ5PkzMGA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1184&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到它就是合并后所呈现在 alpine 容器的文件系统。先进入到容器内：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;docker exec -it $(docker ps -ql) sh&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;紧接着新开一个终端查看容器运行起来后跟镜像相比，有哪些修改：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;docker diff $(docker ps -ql)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.09532062391681109&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmLqE9gzc47ibJ1KkcoRQb52vVvFX9qPkGq8h12Iib1D40Ats4cWQplPG3Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;577&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在/root 目录下，增加了 sh 的历史记录文件。然后我们在容器中手动增加一个 hello.txt 文件：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;Hello Docker&#x27;&lt;/span&gt; &amp;gt; hello.txt&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.09473684210526316&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmL8B6toa9mj3V85LY7t7PsWibRcUAdQibGaT2icQq9fs7fF20e7ZsXxujRw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;855&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候来看看容器默认在镜像之上增加的可写层 UpperDir 目录的变化：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ls /data/docker-data/overlay2/74e92699164736980c9e20475388568f482671625a177cb946c4b136e4d94a64/diff&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.08753315649867374&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmLnH2F8Fe33ZN34Nt2wSYh7AFRBxVhibm45tPic8O1y0kXJqhzBsnNeyjA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;377&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就认证了 overlay2 驱动是将镜像和可写层的内容 merged 之后，供容器作为文件系统使用。多个运行的容器共用一份基础镜像，而各自有独立的可写层，节省了存储空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候，我们也可以回答一下镜像的实际内容是存储在哪里呢：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cat /data/docker-data/overlay2/74e92699164736980c9e20475388568f482671625a177cb946c4b136e4d94a64/lower&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.049597855227882036&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmLrMibhT5OHlBodQ8zDcJfXLaPzzuCr7tECXJouBM0xnjKicF9XkTpZRHg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;746&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看这些分层：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ls /&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;/docker-&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;/overlay2/l/ZIIZFSQUQ4CIKRNCMOXXY4VZHY/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.02951096121416526&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasYrf0CiabxIpGJ7hz90zBmL4icliaOmOibRoMZDc8ZVJ8m6WDkkcRbtYfs9yrxFwaMCaiaSp4sP1q7kzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1186&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是 UFS 中低层的镜像内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一次跟大家分享了 Docker 所使用的底层技术，包括 namespace，cgroups 和 overlay2 联合文件系统，着重介绍了隔离环境是如何在宿主机上演进实现的。通过实际手动操作，对这些概念有了真实的感受。希望下一次为大家再介绍 docker 的网络实现机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;欢迎关注我们的视频号：腾讯程序员&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;最新视频：程序员的小黄鸭&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAxLsOFFRclwAAAAstQy6ubaLX4KHWvLEZgBPE0KEoSl8EUIf5zNPgMIv_YSbcv_JUf3cKJRK3cceq&quot; data-url=&quot;https://findermp.video.qq.com/251/20350/stodownload?encfilekey=jEXicia3muM3GjTlk1Z3kYCefzc4VU4EASxaTR8JjOuRys8V7z5mKRvspuHsIyqwoyop6whb6lGwFxHQMWJqtZgPLGBiaXuFVbzZb74ibfA8SSTF1m5krShvU36xNSkqlOwUxodcUr5Fw52hB8oJjY3Z4m4mwpWzwqnH4ku6lVLyU9c&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=7c22cd450d3542f057205489bcba868f&amp;amp;token=x5Y29zUxcibBv0wC1vh8PiaPC5Rba6WZeibgI8cDic93T5pjiagnlsuib6f4NBlFv3ZPbF&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xEecUymmic8cw4v7Y2zbnVDuo/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;有人试过“小黄鸭调试法”吗？@腾讯程序员 &amp;#10;鹅厂某程序员答：试过，屡试不爽！有时候一个奇怪的问题卡好久，晚上回家跟我老婆讲一会儿，虽然她听不懂，但就是会突然产生灵感，然后发现问题的所在。&amp;#10;&amp;#10;你的小黄鸭长啥样，有什么功能呢？&amp;#10;#程序员 #bug #小黄鸭调试法&amp;#10;&quot; data-nonceid=&quot;6638268027426320372&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;腾讯技术官方交流微信群已经开放&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;进群添加微信：journeylife1900&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（备注：腾讯技术）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.729264475743349&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvatricjRxhpM1x45aB6doaVg7WMhINPwOiaqpskia1kH7hgibO0dicW2HLcW8HRGMzESQwehIcyckLXtwsA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;639&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>96745a693e4f07817eb94d89cda83ee7</guid>
<title>[推荐] 自定义注解！绝对是程序员装逼的利器</title>
<link>https://toutiao.io/k/gnbzbuw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;article-content&quot;&gt;
&lt;p&gt;相信很多人对Java中的注解都很熟悉，比如我们经常会用到的一些如@Override、@Autowired、@Service等，这些都是JDK或者诸如Spring这类框架给我们提供的。&lt;/p&gt;
&lt;p&gt;在以往的面试过程中，我发现，关于注解的知识很多程序员都仅仅停留在使用的层面上，很少有人知道注解是如何实现的，更别提使用自定义注解来解决实际问题了。&lt;/p&gt;
&lt;p&gt;但是其实，我觉得一个好的程序员的标准就是懂得如何优化自己的代码，那在代码优化上面，如何精简代码，去掉重复代码就是一个至关重要的话题，在这个话题领域，自定义注解绝对可以算得上是一个大大的功臣。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;在我看来，会使用自定义注解 ≈ 好的程序员。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么，本文，就来介绍几个，作者在开发中实际用到的几个例子，向你介绍下如何使用注解来提升你代码的逼格。&lt;/p&gt;
&lt;h3&gt;基本知识&lt;/h3&gt;
&lt;p&gt;在Java中，注解分为两种，元注解和自定义注解。&lt;/p&gt;
&lt;p&gt;很多人误以为自定义注解就是开发者自己定义的，而其它框架提供的不算，但是其实上面我们提到的那几个注解其实都是自定义注解。&lt;/p&gt;
&lt;p&gt;关于”元”这个描述，在编程世界里面有都很多，比如”元注解”、”元数据”、”元类”、”元表”等等，这里的”元”其实都是从meta翻译过来的。&lt;/p&gt;
&lt;p&gt;一般我们把&lt;strong&gt;元注解理解为描述注解的注解&lt;/strong&gt;，&lt;strong&gt;元数据理解为描述数据的数据&lt;/strong&gt;，&lt;strong&gt;元类理解为描述类的类&lt;/strong&gt;…&lt;/p&gt;
&lt;p&gt;所以，在Java中，除了有限的几个固定的”描述注解的注解”以外，所有的注解都是自定义注解。&lt;/p&gt;
&lt;p&gt;在JDK中提供了4个标准的用来对注解类型进行注解的注解类（元注解），他们分别是:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Target
@Retention
@Documented
@Inherited
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了以上这四个，所有的其他注解全部都是自定义注解。&lt;/p&gt;
&lt;p&gt;这里不准备深入介绍以上四个元注解的作用，大家可以自行学习。&lt;/p&gt;
&lt;p&gt;本文即将提到的几个例子，都是作者在日常工作中真实使用到的场景，这例子有一个共同点，那就是都用到了Spring的AOP技术。&lt;/p&gt;
&lt;p&gt;什么是AOP以及他的用法相信很多人都知道，这里也就不展开介绍了。&lt;/p&gt;
&lt;h3&gt;使用自定义注解做日志记录&lt;/h3&gt;
&lt;p&gt;不知道大家有没有遇到过类似的诉求，就是希望在一个方法的入口处或者出口处做统一的日志处理，比如记录一下入参、出参、记录下方法执行的时间等。&lt;/p&gt;
&lt;p&gt;如果在每一个方法中自己写这样的代码的话，一方面会有很多代码重复，另外也容易被遗漏。&lt;/p&gt;
&lt;p&gt;这种场景，就可以使用自定义注解+切面实现这个功能。&lt;/p&gt;
&lt;p&gt;假设我们想要在一些web请求的方法上，记录下本次操作具体做了什么事情，比如新增了一条记录或者删除了一条记录等。&lt;/p&gt;
&lt;p&gt;首先我们自定义一个注解：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Operate Log 的自定义注解
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface OpLog {

    /**
     * 业务类型，如新增、删除、修改
     *
     * @return
     */
    public OpType opType();

    /**
     * 业务对象名称，如订单、库存、价格
     *
     * @return
     */
    public String opItem();

    /**
     * 业务对象编号表达式，描述了如何获取订单号的表达式
     *
     * @return
     */
    public String opItemIdExpression();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为我们不仅要在日志中记录本次操作了什么，还需要知道被操作的对象的具体的唯一性标识，如订单号信息。&lt;/p&gt;
&lt;p&gt;但是每一个接口方法的参数类型肯定是不一样的，很难有一个统一的标准，那么我们就可以借助Spel表达式，即在表达式中指明如何获取对应的对象的唯一性标识。&lt;/p&gt;
&lt;p&gt;有了上面的注解，接下来就可以写切面了。主要代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * OpLog的切面处理类，用于通过注解获取日志信息，进行日志记录
 *
 * @author Hollis
 */
@Aspect
@Component
public class OpLogAspect {

    private static final Logger LOGGER = LoggerFactory.getLogger(OpLogAspect.class);

    @Autowired
    HttpServletRequest request;

    @Around(&quot;@annotation(com.hollis.annotation.OpLog)&quot;)
    public Object log(ProceedingJoinPoint pjp) throws Exception {

        Method method = ((MethodSignature)pjp.getSignature()).getMethod();
        OpLog opLog = method.getAnnotation(OpLog.class);

        Object response = null;

        try {
            // 目标方法执行
            response = pjp.proceed();
        } catch (Throwable throwable) {
            throw new Exception(throwable);
        } 

        if (StringUtils.isNotEmpty(opLog.opItemIdExpression())) {
            SpelExpressionParser parser = new SpelExpressionParser();
            Expression expression = parser.parseExpression(opLog.opItemIdExpression());

            EvaluationContext context = new StandardEvaluationContext();
            // 获取参数值
            Object[] args = pjp.getArgs();

            // 获取运行时参数的名称
            LocalVariableTableParameterNameDiscoverer discoverer
                = new LocalVariableTableParameterNameDiscoverer();
            String[] parameterNames = discoverer.getParameterNames(method);

            // 将参数绑定到context中
            if (parameterNames != null) {
                for (int i = 0; i &amp;lt; parameterNames.length; i++) {
                    context.setVariable(parameterNames[i], args[i]);
                }
            }

            // 将方法的resp当做变量放到context中，变量名称为该类名转化为小写字母开头的驼峰形式
            if (response != null) {
                context.setVariable(
                    CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, response.getClass().getSimpleName()),
                    response);
            }

            // 解析表达式，获取结果
            String itemId = String.valueOf(expression.getValue(context));

            // 执行日志记录
            handle(opLog.opType(), opLog.opItem(), itemId);
        }

        return response;
    }


    private void handle(OpType opType,  String opItem, String opItemId) {
      // 通过日志打印输出
      LOGGER.info(&quot;opType = &quot; + opType.name() +&quot;,opItem = &quot; +opItem + &quot;,opItemId = &quot; +opItemId);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上切面中，有几个点需要大家注意的：&lt;/p&gt;
&lt;p&gt;1、使用@Around注解来指定对标注了OpLog的方法设置切面。 2、使用Spel的相关方法，通过指定的表示，从对应的参数中获取到目标对象的唯一性标识。 3、再方法执行成功后，输出日志。&lt;/p&gt;
&lt;p&gt;有了以上的切面及注解后，我们只需要在对应的方法上增加注解标注即可，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; @RequestMapping(method = {RequestMethod.GET, RequestMethod.POST})
@OpLog(opType = OpType.QUERY, opItem = &quot;order&quot;, opItemIdExpression = &quot;#id&quot;)
public @ResponseBody
HashMap view(@RequestParam(name = &quot;id&quot;) String id)
    throws Exception {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面这种是入参的参数列表中已经有了被操作的对象的唯一性标识，直接使用&lt;code&gt;#id&lt;/code&gt;指定即可。&lt;/p&gt;
&lt;p&gt;如果被操作的对象的唯一性标识不在入参列表中，那么可能是入参的对象中的某一个属性，用法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; @RequestMapping(method = {RequestMethod.GET, RequestMethod.POST})
@OpLog(opType = OpType.QUERY, opItem = &quot;order&quot;, opItemIdExpression = &quot;#orderVo.id&quot;)
public @ResponseBody
HashMap update(OrderVO orderVo)
    throws Exception {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上，即可从入参的OrderVO对象的id属性的值获取。&lt;/p&gt;
&lt;p&gt;如果我们要记录的唯一性标识，在入参中没有的话，应该怎么办呢？最典型的就是插入方法，插入成功之前，根本不知道主键ID是什么，这种怎么办呢？&lt;/p&gt;
&lt;p&gt;我们上面的切面中，做了一件事情，就是我们把方法的返回值也会使用表达式进行一次解析，如果可以解析得到具体的值，可以是可以。如以下写法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; @RequestMapping(method = {RequestMethod.GET, RequestMethod.POST})
@OpLog(opType = OpType.QUERY, opItem = &quot;order&quot;, opItemIdExpression = &quot;#insertResult.id&quot;)
public @ResponseBody
InsertResult insert(OrderVO orderVo)
    throws Exception {

    return orderDao.insert(orderVo);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上，就是一个简单的使用自定义注解+切面进行日志记录的场景。下面我们再来看一个如何使用注解做方法参数的校验。&lt;/p&gt;
&lt;h3&gt;使用自定义注解做前置检查&lt;/h3&gt;
&lt;p&gt;当我们对外部提供接口的时候，会对其中的部分参数有一定的要求，比如某些参数值不能为空等。大多数情况下我们都需要自己主动进行校验，判断对方传入的值是否合理。&lt;/p&gt;
&lt;p&gt;这里推荐一个使用HibernateValidator + 自定义注解 + AOP实现参数校验的方式。&lt;/p&gt;
&lt;p&gt;首先我们会有一个具体的入参类，定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class User {
    private String idempotentNo;
    @NotNull(
        message = &quot;userName can&#x27;t be null&quot;
    )
    private String userName;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上，对userName参数注明不能为null。&lt;/p&gt;
&lt;p&gt;然后再使用hibernate validator定义一个工具类，用于做参数校验。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 参数校验工具
 *
 * @author Hollis
 */
public class BeanValidator {

    private static Validator validator = Validation.byProvider(HibernateValidator.class).configure().failFast(true)
        .buildValidatorFactory().getValidator();

    /**
     * @param object object
     * @param groups groups
     */
    public static void validateObject(Object object, Class&amp;lt;?&amp;gt;... groups) throws ValidationException {
        Set&amp;lt;ConstraintViolation&amp;lt;Object&amp;gt;&amp;gt; constraintViolations = validator.validate(object, groups);
        if (constraintViolations.stream().findFirst().isPresent()) {
            throw new ValidationException(constraintViolations.stream().findFirst().get().getMessage());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上代码，会对一个bean进行校验，一旦失败，就会抛出ValidationException。&lt;/p&gt;
&lt;p&gt;接下来定义一个注解：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * facade接口注解， 用于统一对facade进行参数校验及异常捕获
 * &amp;lt;pre&amp;gt;
 *      注意，使用该注解需要注意，该方法的返回值必须是BaseResponse的子类
 * &amp;lt;/pre&amp;gt;
 */

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Facade {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个注解里面没有任何参数，只用于标注那些方法要进行参数校验。&lt;/p&gt;
&lt;p&gt;接下来定义切面：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Facade的切面处理类，统一统计进行参数校验及异常捕获
 *
 * @author Hollis
 */
@Aspect
@Component
public class FacadeAspect {

    private static final Logger LOGGER = LoggerFactory.getLogger(FacadeAspect.class);

    @Autowired
    HttpServletRequest request;

    @Around(&quot;@annotation(com.hollis.annotation.Facade)&quot;)
    public Object facade(ProceedingJoinPoint pjp) throws Exception {

        Method method = ((MethodSignature)pjp.getSignature()).getMethod();
        Object[] args = pjp.getArgs();

        Class returnType = ((MethodSignature)pjp.getSignature()).getMethod().getReturnType();

        //循环遍历所有参数，进行参数校验
        for (Object parameter : args) {
            try {
                BeanValidator.validateObject(parameter);
            } catch (ValidationException e) {
                return getFailedResponse(returnType, e);
            }
        }

        try {
            // 目标方法执行
            Object response = pjp.proceed();
            return response;
        } catch (Throwable throwable) {
            return getFailedResponse(returnType, throwable);
        }
    }

    /**
     * 定义并返回一个通用的失败响应
     */
    private Object getFailedResponse(Class returnType, Throwable throwable)
        throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {

        //如果返回值的类型为BaseResponse 的子类，则创建一个通用的失败响应
        if (returnType.getDeclaredConstructor().newInstance() instanceof BaseResponse) {
            BaseResponse response = (BaseResponse)returnType.getDeclaredConstructor().newInstance();
            response.setSuccess(false);
            response.setResponseMessage(throwable.toString());
            response.setResponseCode(GlobalConstant.BIZ_ERROR);
            return response;
        }

        LOGGER.error(
            &quot;failed to getFailedResponse , returnType (&quot; + returnType + &quot;) is not instanceof BaseResponse&quot;);
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上代码，和前面的切面有点类似，主要是定义了一个切面，会对所有标注@Facade的方法进行统一处理，即在开始方法调用前进行参数校验，一旦校验失败，则返回一个固定的失败的Response，特别需要注意的是，这里之所以可以返回一个固定的BaseResponse，是因为我们会要求我们的所有对外提供的接口的response必须继承BaseResponse类，这个类里面会定义一些默认的参数，如错误码等。&lt;/p&gt;
&lt;p&gt;之后，只需要对需要参数校验的方法增加对应注解即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Facade
public TestResponse query(User user) {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，有了以上注解和切面，我们就可以对所有的对外方法做统一的控制了。&lt;/p&gt;
&lt;p&gt;其实，以上这个facadeAspect我省略了很多东西，我们真正使用的那个切面，不仅仅做了参数检查，还可以做很多其他事情。比如异常的统一处理、错误码的统一转换、记录方法执行时长、记录方法的入参出参等等。&lt;/p&gt;
&lt;p&gt;总之，使用切面+自定义注解，我们可以统一做很多事情。除了以上的这几个场景，我们还有很多相似的用法，比如：&lt;/p&gt;
&lt;p&gt;统一的缓存处理。如某些操作需要在操作前查缓存、操作后更新缓存。这种就可以通过自定义注解+切面的方式统一处理。&lt;/p&gt;
&lt;p&gt;代码其实都差不多，思路也比较简单，就是通过自定义注解来标注需要被切面处理的累或者方法，然后在切面中对方法的执行过程进行干预，比如在执行前或者执行后做一些特殊的操作。&lt;/p&gt;
&lt;p&gt;使用这种方式可以大大减少重复代码，大大提升代码的优雅性，方便我们使用。&lt;/p&gt;
&lt;p&gt;但是同时也不能过度使用，因为注解看似简单，但是其实内部有很多逻辑是容易被忽略的。就像我之前写过一篇《&lt;a href=&quot;https://www.hollischuang.com/archives/5608&quot;&gt;Spring官方都推荐使用的@Transactional事务，为啥我不建议使用！&lt;/a&gt;》中提到的观点一样，无脑的使用切面和注解，可能会引入一些不必要的问题。&lt;/p&gt;
&lt;p&gt;不管怎么说，自定义注解却是是一个很好的发明，可以减少很多重复代码。快快在你的项目中用起来吧。&lt;/p&gt;
&lt;center&gt;&lt;b&gt;(全文完)&lt;/b&gt;&lt;/center&gt;&lt;hr/&gt;&lt;center&gt;&lt;b&gt;扫描二维码，关注作者微信公众号&lt;/b&gt;&lt;/center&gt;&lt;img src=&quot;http://www.hollischuang.com/wp-content/uploads/2019/04/二维码.png&quot;/&gt;
&lt;/article&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>424c63b0e3efa0f418b74466abbb489f</guid>
<title>[推荐] 阿里终面：分布式事务原理</title>
<link>https://toutiao.io/k/vunm1k6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文提纲如下&lt;/p&gt;&lt;ol start=&quot;0&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;前言&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单数据源事务 &amp;amp; 多数据源事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;常见分布式事务解决方案&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;2.1. 分布式事务模型&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.2. 二将军问题和幂等性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.3. 两阶段提交（2PC） &amp;amp; 三阶段提交（3PC）方案&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.4. TCC 方案&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.5. 事务状态表方案&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.6. 基于消息中间件的最终一致性事务方案&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;Seata in AT mode 的实现&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;3.1. Seata in AT mode 工作流程概述&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3.2. Seata in AT mode 工作流程详述&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;结束语&lt;/section&gt;&lt;/li&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5766793409378961&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OqmCT8JwGrJu90FJetDcJDBrHYylXMP3X9Lsru4V0SbK3NzuqmqJbCA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;789&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;0. 前言&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 CPU 到内存、到磁盘、到操作系统、到网络，计算机系统处处存在不可靠因素。工程师和科学家努力使用各种软硬件方法对抗这种不可靠因素，保证数据和指令被正确地处理。在网络领域有 &lt;strong&gt;TCP 可靠传输协议&lt;/strong&gt;、在存储领域有 &lt;strong&gt;Raid5&lt;/strong&gt; 和 &lt;strong&gt;Raid6&lt;/strong&gt; 算法、在数据库领域有 &lt;strong&gt;基于 ARIES 算法理论实现的事务机制&lt;/strong&gt;……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章先介绍&lt;strong&gt;单机数据库事务的 ACID 特性&lt;/strong&gt;，然后指出&lt;strong&gt;分布式场景下操作多数据源面临的困境&lt;/strong&gt;，引出&lt;strong&gt;分布式系统中常用的分布式事务解决方案&lt;/strong&gt;，这些解决方案可以保证业务代码在操作多个数据源的时候，能够像操作单个数据源一样，具备 ACID 特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章在最后给出业界较为成熟的分布式事务框架——&lt;strong&gt;Seata 的 AT 模式全局事务的实现&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;1. 单数据源事务 &amp;amp; 多数据源事务&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个应用程序在一次业务流中通过连接驱动和数据源接口只连接并查询（这里的查询是广义的，包括增删查改等）一个特定的数据库，该应用程序就可以利用数据库提供的事务机制（如果数据库支持事务的话）保证对库中记录所进行的操作的可靠性，这里的可靠性有四种语义：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;笔者在这里不再对这四种语义进行解释，了解单数据源事务及其 ACID 特性是读者阅读这篇文章的前提。单个数据库实现自身的事务特性是一个复杂又微妙的过程，例如 &lt;strong&gt;MySQL 的 InnoDB 引擎通过 Undo Log + Redo Log + ARIES 算法来实现&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个很宏大的话题，不在本文的描述范围，读者有兴趣的话可自行研究。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;单数据源事务也可以叫做单机事务，或者本地事务。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式场景下，一个系统由多个子系统构成，每个子系统有独立的数据源。多个子系统之间通过互相调用来组合出更复杂的业务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在时下流行的微服务系统架构中，每一个子系统被称作一个微服务，同样每个微服务都维护自己的数据库，以保持独立性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，一个电商系统可能由购物微服务、库存微服务、订单微服务等组成。购物微服务通过调用库存微服务和订单微服务来整合出购物业务。用户请求购物微服务商完成下单时，购物微服务一方面调用库存微服务扣减相应商品的库存数量，另一方面调用订单微服务插入订单记录（为了后文描述分布式事务解决方案的方便，这里给出的是一个最简单的电商系统微服务划分和最简单的购物业务流程，后续的支付、物流等业务不在考虑范围内）。电商系统模型如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2506596306068603&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5O1Z1djEJzPNiaVyvIGQPgtQZm8gG81ibunnYh7yMjH62MDpNqDvToXrlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;379&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在用户购物的业务场景中，&lt;strong&gt;shopping-service&lt;/strong&gt; 的业务涉及两个数据库：&lt;strong&gt;库存库（repo_db）&lt;strong&gt;和&lt;/strong&gt;订单库（repo_db）&lt;/strong&gt;，也就是 g 购物业务是调用多数据源来组合而成的。作为一个面向消费者的系统，电商系统要保证购物业务的高度可靠性，这里的可靠性同样有 ACID 四种语义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是一个数据库的本地事务机制仅仅对落到自己身上的查询操作（这里的查询是广义的，包括增删改查等）起作用，无法干涉对其他数据库的查询操作。所以，&lt;strong&gt;数据库自身提供的本地事务机制无法确保业务对多数据源全局操作的可靠性。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于此，针对多数据源操作提出的分布式事务机制就出现了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分布式事务也可以叫做全局事务。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;2. 常见分布式事务解决方案&lt;/strong&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1. 分布式事务模型&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5Og9TkSZzCB0expnKC5ceF7Tk0YXTRic9v38yKfKYXnic2CEbFbM1JEGPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;描述分布式事务，常常会使用以下几个名词：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;事务参与者&lt;/strong&gt;：例如每个数据库就是一个事务参与者&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;事务协调&lt;/strong&gt;者：访问多个数据源的服务程序，例如 shopping-service 就是事务协调者&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;资源管理器（Resource Manager, RM）&lt;/strong&gt;：通常与事务参与者同义&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;事务管理器（Transaction Manager, TM）&lt;/strong&gt;：通常与事务协调者同义&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式事务模型中，一个 TM 管理多个 RM，即一个服务程序访问多个数据源；TM 是一个全局事务管理器，协调多方本地事务的进度，使其共同提交或回滚，最终达成一种全局的 ACID 特性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2. 二将军问题和幂等性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二将军问题是网络领域的一个经典问题，用于表达计算机网络中互联协议设计的微妙性和复杂性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里给出一个二将军问题的简化版本：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;一支白军被围困在一个山谷中，山谷的左右两侧是蓝军。困在山谷中的白军人数多于山谷两侧的任意一支蓝军，而少于两支蓝军的之和。若一支蓝军对白军单独发起进攻，则必败无疑；但若两支蓝军同时发起进攻，则可取胜。两只蓝军的总指挥位于山谷左侧，他希望两支蓝军同时发起进攻，这样就要把命令传到山谷右侧的蓝军，以告知发起进攻的具体时间。假设他们只能派遣士兵穿越白军所在的山谷（唯一的通信信道）来传递消息，那么在穿越山谷时，士兵有可能被俘虏。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.8775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5O4MyMt1lE2m7kwf2SLLeXXfqlAQqReD1hhndqm28XPibMl2F1J1iazyKw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有当送信士兵成功往返后，总指挥才能确认这场战争的胜利（上方图）。现在问题来了，派遣出去送信的士兵没有回来，则左侧蓝军中的总指挥能不能决定按命令中约定的时间发起进攻？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是不确定，派遣出去送信的士兵没有回来，他可能遇到两种状况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;命令还没送达就被俘虏了（中间图），这时候右侧蓝军根本不知道要何时进攻；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;命令送达，但返回途中被俘虏了（下方图），这时候右侧蓝军知道要何时进攻，但左侧蓝军不知道右侧蓝军是否知晓进攻时间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似的问题在计算机网络中普遍存在，例如发送者给接受者发送一个 HTTP 请求，或者 MySQL 客户端向 MySQL 服务器发送一条插入语句，然后超时了没有得到响应。请问服务器是写入成功了还是失败了？答案是不确定，有以下几种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可能请求由于网络故障根本没有送到服务器，因此写入失败；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可能服务器收到了，也写入成功了，但是向客户端发送响应前服务器宕机了；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可能服务器收到了，也写入成功了，也向客户端发送了响应，但是由于网络故障未送到客户端。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论哪种场景，在客户端看来都是一样的结果：它发出的请求没有得到响应。为了确保服务端成功写入数据，客户端只能重发请求，直至接收到服务端的响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似的问题问题被称为&lt;strong&gt;网络二将军问题&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;网络二将军问题的存在使得消息的发送者往往要重复发送消息，直到收到接收者的确认才认为发送成功，但这往往又会导致消息的重复发送。&lt;/strong&gt; 例如电商系统中订单模块调用支付模块扣款的时候，如果网络故障导致二将军问题出现，扣款请求重复发送，产生的重复扣款结果显然是不能被接受的。因此要保证一次事务中的扣款请求无论被发送多少次，接收方有且只执行一次扣款动作，这种保证机制叫做接收方的幂等性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OCkOSATodib1kENFfXyARy7uI3wEzS2QyG1K5y8tyqepjg7d4O17faicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3. 两阶段提交（2PC） &amp;amp; 三阶段提交（3PC）方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2PC 是一种实现分布式事务的简单模型&lt;/strong&gt;，这两个阶段是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;准备阶段&lt;/strong&gt;：事务协调者向各个事务参与者发起询问请求：“我要执行全局事务了，这个事务涉及到的资源分布在你们这些数据源中，分别是……，你们准备好各自的资源（即各自执行本地事务到待提交阶段）”。各个参与者协调者回复 yes（表示已准备好，允许提交全局事务）或 no（表示本参与者无法拿到全局事务所需的本地资源，因为它被其他本地事务锁住了）或超时。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提交阶段：如果各个参与者回复的都是 yes，则协调者向所有参与者发起事务提交操作，然后所有参与者收到后各自执行本地事务提交操作并向协调者发送 ACK；如果任何一个参与者回复 no 或者超时，则协调者向所有参与者发起事务回滚操作，然后所有参与者收到后各自执行本地事务回滚操作并向协调者发送 ACK。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2PC 的流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8847184986595175&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5Oqr1VBDytKVqEicFfa8Wg3HOXmF3GyUkIILDj7VUHOWvAoe7LQ4bKvCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;746&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图可以看出，要实现 2PC，所有的参与者都要实现三个接口：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Prepare()&lt;/strong&gt;：TM 调用该接口询问各个本地事务是否就绪&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Commit()&lt;/strong&gt;：TM 调用该接口要求各个本地事务提交&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Rollback()&lt;/strong&gt;：TM 调用该接口要求各个本地事务回滚&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以将这三个接口简单地（但不严谨地）理解成 &lt;strong&gt;XA 协议&lt;/strong&gt;。XA 协议是 X/Open 提出的分布式事务处理标准。MySQL、Oracle、DB2 这些主流数据库都实现了 XA 协议，因此都能被用于实现 2PC 事务模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2PC 简明易懂，但存在如下的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;性能差。在准备阶段，要等待所有的参与者返回，才能进入阶段二，在这期间，各个参与者上面的相关资源被排他地锁住，参与者上面意图使用这些资源的本地事务只能等待。因为存在这种同步阻塞问题，所以影响了各个参与者的本地事务并发度；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;准备阶段完成后，如果协调者宕机，所有的参与者都收不到提交或回滚指令，导致所有参与者“不知所措”；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在提交阶段，协调者向所有的参与者发送了提交指令，如果一个参与者未返回 ACK，那么协调者不知道这个参与者内部发生了什么（由于网络二将军问题的存在，这个参与者可能根本没收到提交指令，一直处于等待接收提交指令的状态；也可能收到了，并成功执行了本地提交，但返回的 ACK 由于网络故障未送到协调者上），也就无法决定下一步是否进行全体参与者的回滚。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2PC 之后又出现了 3PC，把两阶段过程变成了三阶段过程，分别是：&lt;strong&gt;1.询问阶段&lt;/strong&gt;、&lt;strong&gt;2.准备阶段&lt;/strong&gt;、&lt;strong&gt;3.提交或回滚阶段&lt;/strong&gt;，这里不再详述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3PC 利用超时机制解决了 2PC 的同步阻塞问题，避免资源被永久锁定，进一步加强了整个事务过程的可靠性。但是 3PC 同样无法应对类似的宕机问题，只不过出现多数据源中数据不一致问题的概率更小。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2PC 除了性能和可靠性上存在问题，它的适用场景也很局限，它要求参与者实现了 XA 协议，例如使用实现了 XA 协议的数据库作为参与者可以完成 2PC 过程。但是在多个系统服务利用 api 接口相互调用的时候，就不遵守 XA 协议了，这时候 2PC 就不适用了。所以 2PC 在分布式应用场景中很少使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以前文提到的电商场景无法使用 2PC，因为 shopping-service 通过 RPC 接口或者 Rest 接口调用 repo-service 和 order-service 间接访问 repo_db 和 order_db。除非 shopping-service 直接配置 repo_db 和 order_db 作为自己的数据库。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4. TCC 方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;描述 TCC 方案使用的电商微服务模型如下图所示，在这个模型中，shopping-service 是事务协调者，repo-service 和 order-service 是事务参与者。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2440944881889764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5ORRW2eiaJESv0YyxfNQAuR78nibPibYPCQFiabSjhD6LORxttFiaKYLHsNBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;381&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文提到，2PC 要求参与者实现了 XA 协议，通常用来解决多个数据库之间的事务问题，比较局限。在多个系统服务利用 api 接口相互调用的时候，就不遵守 XA 协议了，这时候 2PC 就不适用了。现代企业多采用分布式的微服务，因此更多的是要解决多个微服务之间的分布式事务问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCC 就是一种解决多个微服务之间的分布式事务问题的方案。TCC 是 Try、Confirm、Cancel 三个词的缩写，其本质是一个应用层面上的 2PC，同样分为两个阶段：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;准备阶段&lt;/strong&gt; ：协调者调用所有的每个微服务提供的 try 接口，将整个全局事务涉及到的资源锁定住，若锁定成功 try 接口向协调者返回 yes。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;提交阶段&lt;/strong&gt; ：若所有的服务的 try 接口在阶段一都返回 yes，则进入提交阶段，协调者调用所有服务的 confirm 接口，各个服务进行事务提交。如果有任何一个服务的 try 接口在阶段一返回 no 或者超时，则协调者调用所有服务的 cancel 接口。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCC 的流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.871222076215506&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5ObtPwqrF3V59taSch79uRGELZNib6CwWcE6nvlbicFUaP2xCiaeiaZXmz3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;761&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有个关键问题，既然 TCC 是一种服务层面上的 2PC。&lt;strong&gt;它是如何解决 2PC 无法应对宕机问题的缺陷的呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是不断重试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 try 操作锁住了全局事务涉及的所有资源，保证了业务操作的所有前置条件得到满足，因此无论是 confirm 阶段失败还是 cancel 阶段失败都能通过不断重试直至 confirm 或 cancel 成功（所谓成功就是所有的服务都对 confirm 或者 cancel 返回了 ACK）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5Ob3qPfib0qAIB6F5nIrO0R9HKS3O8bIxv2m6FMciaF3DOQgHdYJAV10Gg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里还有个关键问题，在不断重试 confirm 和 cancel 的过程中（考虑到网络二将军问题的存在）有可能重复进行了 confirm 或 cancel，因此还要再保证 confirm 和 cancel 操作具有幂等性，也就是整个全局事务中，每个参与者只进行一次 confirm 或者 cancel。实现 confirm 和 cancel 操作的幂等性，有很多解决方案，例如每个参与者可以维护一个去重表（可以利用数据库表实现也可以使用内存型 KV 组件实现），记录每个全局事务（以全局事务标记 XID 区分）是否进行过 confirm 或 cancel 操作，若已经进行过，则不再重复执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCC 由支付宝团队提出，被广泛应用于金融系统中。我们用银行账户余额购买基金时，会注意到银行账户中用于购买基金的那部分余额首先会被冻结，由此我们可以猜想，这个过程大概就是 TCC 的第一阶段。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5. 事务状态表方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外有一种类似 TCC 的事务解决方案，借助事务状态表来实现。假设要在一个分布式事务中实现调用 repo-service 扣减库存、调用 order-service 生成订单两个过程。在这种方案中，协调者 shopping-service 维护一张如下的事务状态表：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;分布式事务 ID&lt;/th&gt;&lt;th&gt;事务内容&lt;/th&gt;&lt;th&gt;事务状态&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;global_trx_id_1&lt;/td&gt;&lt;td&gt;操作 1：调用 repo-service 扣减库存 操作 2：调用 order-service 生成订单&lt;/td&gt;&lt;td&gt;状态 1：初始 状态 2：操作 1 成功 状态 3：操作 1、2 成功&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始状态为 1，每成功调用一个服务则更新一次状态，最后所有的服务调用成功，状态更新到 3。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这张表，就可以启动一个后台任务，扫描这张表中事务的状态，如果一个分布式事务一直（设置一个事务周期阈值）未到状态 3，说明这条事务没有成功执行，于是可以重新调用 repo-service 扣减库存、调用 order-service 生成订单。直至所有的调用成功，事务状态到 3。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果多次重试仍未使得状态到 3，可以将事务状态置为 error，通过人工介入进行干预。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于存在服务的调用重试，因此每个服务的接口要根据全局的分布式事务 ID 做幂等，原理同 2.4 节的幂等性实现。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.6. 基于消息中间件的最终一致性事务方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;无论是 2PC &amp;amp; 3PC 还是 TCC、事务状态表，基本都遵守 XA 协议的思想&lt;/strong&gt;。即这些方案本质上都是事务协调者协调各个事务参与者的本地事务的进度，使所有本地事务共同提交或回滚，最终达成一种全局的 ACID 特性。在协调的过程中，协调者需要收集各个本地事务的当前状态，并根据这些状态发出下一阶段的操作指令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这些全局事务方案由于操作繁琐、时间跨度大，或者在全局事务期间会排他地锁住相关资源，使得整个分布式系统的全局事务的并发度不会太高。这很难满足电商等高并发场景对事务吞吐量的要求，因此互联网服务提供商探索出了很多与 XA 协议背道而驰的分布式事务解决方案。其中利用消息中间件实现的最终一致性全局事务就是一个经典方案。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5O5yszDOGWs9CVicia8qFwcH3GnYiah4b1Zkqibbk7eLib20LfJwaaRIZicHxg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了表现出这种方案的精髓，我将使用如下的电商系统微服务结构来进行描述：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.828752642706131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5O8H5s6iccLprEicEBucv7WjVyZXic6bmf3BWqRreuy8W5kr5K30icWkDRog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;473&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个模型中，用户不再是请求整合后的 shopping-service 进行下单，而是直接请求 order-service 下单，order-service 一方面添加订单记录，另一方面会调用 repo-service 扣减库存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种基于消息中间件的最终一致性事务方案常常被误解成如下的实现方式：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4182939362795478&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OT1CRZAQpT4dxQ6xzmjoHCHmrt3ue8pldzqI2LicXibOmDqicttDEGicK4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;973&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种实现方式的流程是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;order-service 负责向 MQ server 发送扣减库存消息（repo_deduction_msg）；repo-service 订阅 MQ server 中的扣减库存消息，负责消费消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户下单后，order-service 先执行插入订单记录的查询语句，后将 repo_deduction_msg 发到消息中间件中，这两个过程放在一个本地事务中进行，一旦“执行插入订单记录的查询语句”失败，导致事务回滚，“将 repo_deduction_msg 发到消息中间件中”就不会发生；同样，一旦“将 repo_deduction_msg 发到消息中间件中”失败，抛出异常，也会导致“执行插入订单记录的查询语句”操作回滚，最终什么也没有发生。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9090909090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5ODyrv0PYJv9icmhjQaMIQdTAAYTM3qk02BNWdLW5TNwGYQ7KUic8ISTGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;198&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;repo-service 接收到 repo_deduction_msg 之后，先执行库存扣减查询语句，后向 MQ sever 反馈消息消费完成 ACK，这两个过程放在一个本地事务中进行，一旦“执行库存扣减查询语句”失败，导致事务回滚，“向 MQ sever 反馈消息消费完成 ACK”就不会发生，MQ server 在 Confirm 机制的驱动下会继续向 repo-service 推送该消息，直到整个事务成功提交；同样，一旦“向 MQ sever 反馈消息消费完成 ACK”失败，抛出异常，也对导致“执行库存扣减查询语句”操作回滚，MQ server 在 Confirm 机制的驱动下会继续向 repo-service 推送该消息，直到整个事务成功提交。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.025974025974026&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OVWRCuEW5KCPYlqibgVGQsicA9gejI9v31kgRaIl7B4CeHEVOEpnOic7fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;154&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种做法看似很可靠。但没有考虑到网络二将军问题的存在，有如下的缺陷：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;网络的 2 将军问题&lt;/strong&gt; ：上面第 2 步中 order-service 发送 repo_deduction_msg 消息失败，对于发送方 order-service 来说，可能是消息中间件没有收到消息；也可能是中间件收到了消息，但向发送方 order-service 响应的 ACK 由于网络故障没有被 order-service 收到。因此 order-service 贸然进行事务回滚，撤销“执行插入订单记录的查询语句”，是不对的，因为 repo-service 那边可能已经接收到 repo_deduction_msg 并成功进行了库存扣减，这样 order-service 和 repo-service 两方就产生了数据不一致问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;数据库长事务问题&lt;/strong&gt; ：repo-service 和 order-service 把网络调用（与 MQ server 通信）放在本地数据库事务里，可能会因为网络延迟产生数据库长事务，影响数据库本地事务的并发度。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OSm6gAKgOZZIjZ4Bv73QOqkN493ibeKdichC6M9iaeiac5mCbiauWxJ1yJSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上是被误解的实现方式，下面给出正确的实现方式，如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.36018518518518516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OSWufbwc1iahgpyuxuk4HBjNbqk4BhZwMalMMnFiaN7U8a8iaPjs77RJHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图所示的方案，利用消息中间件如 rabbitMQ 来实现分布式下单及库存扣减过程的最终一致性。对这幅图做以下说明：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）order-service 中，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;在 t_order 表添加订单记录 &amp;amp;&amp;amp;&lt;br/&gt;&lt;br/&gt;在 t_local_msg 添加对应的扣减库存消息&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个过程要在一个事务中完成，保证过程的原子性。同样，repo-service 中，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;检查本次扣库存操作是否已经执行过 &amp;amp;&amp;amp;&lt;br/&gt;&lt;br/&gt;执行扣减库存如果本次扣减操作没有执行过 &amp;amp;&amp;amp;&lt;br/&gt;&lt;br/&gt;写判重表 &amp;amp;&amp;amp;&lt;br/&gt;&lt;br/&gt;向 MQ sever 反馈消息消费完成 ACK&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这四个过程也要在一个事务中完成，保证过程的原子性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）order-service 中有一个后台程序，源源不断地把消息表中的消息传送给消息中间件，成功后则删除消息表中对应的消息。如果失败了，也会不断尝试重传。由于存在网络 2 将军问题，即当 order-service 发送给消息中间件的消息网络超时时，这时候消息中间件可能收到了消息但响应 ACK 失败，也可能没收到，order-service 会再次发送该消息，直至消息中间件响应 ACK 成功，这样可能发生消息的重复发送，不过没关系，只要保证消息不丢失，不乱序就行，后面 repo-service 会做去重处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）消息中间件向 repo-service 推送 repo_deduction_msg，repo-service 成功处理完成后会向中间件响应 ACK，消息中间件收到这个 ACK 才认为 repo-service 成功处理了这条消息，否则会重复推送该消息。但是有这样的情形：repo-service 成功处理了消息，向中间件发送的 ACK 在网络传输中由于网络故障丢失了，导致中间件没有收到 ACK 重新推送了该消息。这也要靠 repo-service 的消息去重特性来避免消息重复消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4）在 2）和 3）中提到了两种导致 repo-service 重复收到消息的原因，一是生产者重复生产，二是中间件重传。为了实现业务的幂等性，repo-service 中维护了一张判重表，这张表中记录了被成功处理的消息的 id。repo-service 每次接收到新的消息都先判断消息是否被成功处理过，若是的话不再重复处理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9345794392523364&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OHdf2TqjpXFrdlicGyn9tsqebB0wTFauZzC41lpRvXYE6ddfzBGibGOdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;214&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这种设计，实现了消息在发送方不丢失，消息在接收方不被重复消费，联合起来就是消息不漏不重，严格实现了 order-service 和 repo-service 的两个数据库中数据的最终一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于消息中间件的最终一致性全局事务方案是互联网公司在高并发场景中探索出的一种创新型应用模式，利用 MQ 实现微服务之间的异步调用、解耦合和流量削峰，支持全局事务的高并发，并保证分布式数据记录的最终一致性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5ODAtXVRcibzJbWT3AVC0wSuOjJYeOmeI1cGmTFCc8hNrrPtxR7AMLWJg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;3. Seata in AT mode 的实现&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第 2 章给出了实现实现分布式事务的集中常见的理论模型。本章给出业界开源分布式事务框架 Seata 的实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Seata 为用户提供了 AT、TCC、SAGA 和 XA 事务模式&lt;/strong&gt;。其中 &lt;strong&gt;AT 模式是 Seata 主推的事务模式&lt;/strong&gt;，因此本章分析 Seata in AT mode 的实现。&lt;strong&gt;使用 AT 有一个前提，那就是微服务使用的数据库必须是支持事务的关系型数据库。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1. Seata in AT mode 工作流程概述&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Seata 的 AT 模式建立在关系型数据库的本地事务特性的基础之上，通过数据源代理类拦截并解析数据库执行的 SQL，记录自定义的回滚日志，如需回滚，则重放这些自定义的回滚日志即可。AT 模式虽然是根据 XA 事务模型（2PC）演进而来的，但是 AT 打破了 XA 协议的阻塞性制约，在一致性和性能上取得了平衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AT 模式是基于 XA 事务模型演进而来的，它的整体机制也是一个改进版本的两阶段提交协议。AT 模式的两个基本阶段是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先获取本地锁，执行本地事务，业务数据操作和记录回滚日志在同一个本地事务中提交，最后释放本地锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如需全局提交，异步删除回滚日志即可，这个过程很快就能完成。如需要回滚，则通过第一阶段的回滚日志进行反向补偿。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本章描述 Seata in AT mode 的工作原理使用的电商微服务模型如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2440944881889764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5ORRW2eiaJESv0YyxfNQAuR78nibPibYPCQFiabSjhD6LORxttFiaKYLHsNBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;381&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，协调者 shopping-service 先调用参与者 repo-service 扣减库存，后调用参与者 order-service 生成订单。这个业务流使用 Seata in XA mode 后的全局事务流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9425113464447806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OyGdkslGbeFtwvuf8Iic138nocN06p7WNjuIx8pXicL7ibbOxgRGF7WOpg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;661&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图描述的全局事务执行流程为：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;shopping-service 向 Seata 注册全局事务，并产生一个全局事务标识 XID&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 repo-service.repo_db、order-service.order_db 的本地事务执行到待提交阶段，事务内容包含对 repo-service.repo_db、order-service.order_db 进行的查询操作以及写每个库的 undo_log 记录&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;repo-service.repo_db、order-service.order_db 向 Seata 注册分支事务，并将其纳入该 XID 对应的全局事务范围&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提交 repo-service.repo_db、order-service.order_db 的本地事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;repo-service.repo_db、order-service.order_db 向 Seata 汇报分支事务的提交状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Seata 汇总所有的 DB 的分支事务的提交状态，决定全局事务是该提交还是回滚&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Seata 通知 repo-service.repo_db、order-service.order_db 提交/回滚本地事务，若需要回滚，采取的是补偿式方法&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 1）2）3）4）5）属于第一阶段，6）7）属于第二阶段。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2. Seata in AT mode 工作流程详述&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的电商业务场景中，购物服务调用库存服务扣减库存，调用订单服务创建订单，显然这两个调用过程要放在一个事务里面。即：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;start global_trx&lt;br/&gt;&lt;br/&gt; call 库存服务的扣减库存接口&lt;br/&gt;&lt;br/&gt; call 订单服务的创建订单接口&lt;br/&gt;&lt;br/&gt;commit global_trx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在库存服务的数据库中，存在如下的库存表 t_repo：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;10001&lt;/td&gt;&lt;td&gt;20001&lt;/td&gt;&lt;td&gt;xx 键盘&lt;/td&gt;&lt;td&gt;98&lt;/td&gt;&lt;td&gt;200.0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;10002&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;yy 鼠标&lt;/td&gt;&lt;td&gt;199&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在订单服务的数据库中，存在如下的订单表 t_order：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;order_code&lt;/th&gt;&lt;th&gt;user_id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;30001&lt;/td&gt;&lt;td&gt;2020102500001&lt;/td&gt;&lt;td&gt;40001&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;30002&lt;/td&gt;&lt;td&gt;2020102500001&lt;/td&gt;&lt;td&gt;40001&lt;/td&gt;&lt;td&gt;20001&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;400.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，id 为 40002 的用户要购买一只商品代码为 20002 的鼠标，整个分布式事务的内容为：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）在库存服务的库存表中将记录&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;10002&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;yy 鼠标&lt;/td&gt;&lt;td&gt;199&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改为&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;10002&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;yy 鼠标&lt;/td&gt;&lt;td&gt;198&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）在订单服务的订单表中添加一条记录&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;order_code&lt;/th&gt;&lt;th&gt;user_id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;30003&lt;/td&gt;&lt;td&gt;2020102500002&lt;/td&gt;&lt;td&gt;40002&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上操作，在 AT 模式的第一阶段的流程图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4167623421354765&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OOxsngRHRibdaZNwOtfLLbr4ffLUuP8OIzr92CfQK6FS5urJpDnAeviag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;871&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 AT 模式第一阶段的流程来看，分&lt;strong&gt;支的本地事务在第一阶段提交完成之后，就会释放掉本地事务锁定的本地记录&lt;/strong&gt;。这是 AT 模式和 XA 最大的不同点，在 XA 事务的两阶段提交中，被锁定的记录直到第二阶段结束才会被释放。所以 &lt;strong&gt;AT 模式减少了锁记录的时间，从而提高了分布式事务的处理效率&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;AT 模式之所以能够实现第一阶段完成就释放被锁定的记录，是因为 Seata 在每个服务的数据库中维护了一张 undo_log 表&lt;/strong&gt;，其中记录了对 t_order / t_repo 进行操作前后记录的镜像数据，即便第二阶段发生异常，只需回放每个服务的 undo_log 中的相应记录即可实现全局回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;undo_log 的表结构：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;branch_id&lt;/th&gt;&lt;th&gt;xid&lt;/th&gt;&lt;th&gt;context&lt;/th&gt;&lt;th&gt;rollback_info&lt;/th&gt;&lt;th&gt;log_status&lt;/th&gt;&lt;th&gt;log_created&lt;/th&gt;&lt;th&gt;log_modified&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;……&lt;/td&gt;&lt;td&gt;分支事务 ID&lt;/td&gt;&lt;td&gt;全局事务 ID&lt;/td&gt;&lt;td&gt;……&lt;/td&gt;&lt;td&gt;分支事务操作的记录在事务前后的记录镜像，即 beforeImage 和 afterImage&lt;/td&gt;&lt;td&gt;……&lt;/td&gt;&lt;td&gt;……&lt;/td&gt;&lt;td&gt;……&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一阶段结束之后，Seata 会接收到所有分支事务的提交状态，然后决定是提交全局事务还是回滚全局事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1）若所有分支事务本地提交均成功，则 Seata 决定全局提交。&lt;/strong&gt; Seata 将分支提交的消息发送给各个分支事务，各个分支事务收到分支提交消息后，会将消息放入一个缓冲队列，然后直接向 Seata 返回提交成功。之后，每个本地事务会慢慢处理分支提交消息，处理的方式为：删除相应分支事务的 undo_log 记录。之所以只需删除分支事务的 undo_log 记录，而不需要再做其他提交操作，是因为提交操作已经在第一阶段完成了（这也是 AT 和 XA 不同的地方）。这个过程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6545012165450121&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OibuibmFbqjPx25ibiabf7w6RTdpwT73oPAnQkKFbZBNvEIfZ48DFA1ZVRw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;822&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分支事务之所以能够直接返回成功给 Seata，是因为真正关键的提交操作在第一阶段已经完成了，清除 undo_log 日志只是收尾工作，即便清除失败了，也对整个分布式事务不产生实质影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2）若任一分支事务本地提交失败，则 Seata 决定全局回滚&lt;/strong&gt;，将分支事务回滚消息发送给各个分支事务，由于在第一阶段各个服务的数据库上记录了 undo_log 记录，分支事务回滚操作只需根据 undo_log 记录进行补偿即可。全局事务的回滚流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7567298105682951&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OtBLLPhVMSkNyFg5Mnl075Kuia52teiaVIBf5pcUUatibUM5FHZ6wuyaGA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1003&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里对图中的 2、3 步做进一步的说明：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由于上文给出了 undo_log 的表结构，所以可以通过 xid 和 branch_id 来找到当前分支事务的所有 undo_log 记录；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拿到当前分支事务的 undo_log 记录之后，首先要做数据校验，如果 afterImage 中的记录与当前的表记录不一致，说明从第一阶段完成到此刻期间，有别的事务修改了这些记录，这会导致分支事务无法回滚，向 Seata 反馈回滚失败；如果 afterImage 中的记录与当前的表记录一致，说明从第一阶段完成到此刻期间，没有别的事务修改这些记录，分支事务可回滚，进而根据 beforeImage 和 afterImage 计算出补偿 SQL，执行补偿 SQL 进行回滚，然后删除相应 undo_log，向 Seata 反馈回滚成功。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OJ6P9q3q6nV7Ug24TQaPnmtt2zmWPWDJQtf59fbJQQJufibIauvySzJQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务具有 ACID 特性，全局事务解决方案也在尽量实现这四个特性。以上关于 Seata in AT mode 的描述很显然体现出了 AT 的原子性、一致性和持久性。下面着重描述一下 AT 如何保证多个全局事务的隔离性的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 AT 中，当多个全局事务操作同一张表时，通过全局锁来保证事务的隔离性。下面描述一下全局锁在读隔离和写隔离两个场景中的作用原理：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）&lt;strong&gt;写隔离&lt;/strong&gt;（若有全局事务在改/写/删记录，另一个全局事务对同一记录进行的改/写/删要被隔离起来，即写写互斥）：写隔离是为了在多个全局事务对同一张表的同一个字段进行更新操作时，避免一个全局事务在没有被提交成功之前所涉及的数据被其他全局事务修改。写隔离的基本原理是：在第一阶段本地事务（开启本地事务的时候，本地事务会对涉及到的记录加本地锁）提交之前，确保拿到全局锁。如果拿不到全局锁，就不能提交本地事务，并且不断尝试获取全局锁，直至超出重试次数，放弃获取全局锁，回滚本地事务，释放本地事务对记录加的本地锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设有两个全局事务 gtrx_1 和 gtrx_2 在并发操作库存服务，意图扣减如下记录的库存数量：&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;10002&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;yy 鼠标&lt;/td&gt;&lt;td&gt;198&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AT 实现写隔离过程的时序图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5651340996168582&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5O1J2BzCm9X9lkuhLEvNEic6SL8d7bFnT75BQADGQtFUUv4P5eicfeXBzQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1044&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图中，1、2、3、4 属于第一阶段，5 属于第二阶段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中 gtrx_1 和 gtrx_2 均成功提交，如果 gtrx_1 在第二阶段执行回滚操作，那么 gtrx_1 需要重新发起本地事务获取本地锁，然后根据 undo_log 对这个 id=10002 的记录进行补偿式回滚。此时 gtrx_2 仍在等待全局锁，且持有这个 id=10002 的记录的本地锁，因此 gtrx_1 会回滚失败（gtrx_1 回滚需要同时持有全局锁和对 id=10002 的记录加的本地锁），回滚失败的 gtrx_1 会一直重试回滚。直到旁边的 gtrx_2 获取全局锁的尝试次数超过阈值，gtrx_2 会放弃获取全局锁，发起本地回滚，本地回滚结束后，自然会释放掉对这个 id=10002 的记录加的本地锁。此时，gtrx_1 终于可以成功对这个 id=10002 的记录加上了本地锁，同时拿到了本地锁和全局锁的 gtrx_1 就可以成功回滚了。整个过程，全局锁始终在 gtrx_1 手中，并不会发生脏写的问题。整个过程的流程图如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.687962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OpXV1Jzj6Gh6vCoJiapTgwCViaHHlSpNHjeF20VObGMyY6Wa0gUe00iaDQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）&lt;strong&gt;读隔离&lt;/strong&gt;（若有全局事务在改/写/删记录，另一个全局事务对同一记录的读取要被隔离起来，即读写互斥）：在数据库本地事务的隔离级别为读已提交、可重复读、串行化时（读未提交不起什么隔离作用，一般不使用），Seata AT 全局事务模型产生的隔离级别是读未提交，也就是说一个全局事务会看到另一个全局事务未全局提交的数据，产生脏读，从前文的第一阶段和第二阶段的流程图中也可以看出这一点。这在最终一致性的分布式事务模型中是可以接受的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要求 AT 模型一定要实现读已提交的事务隔离级别，可以利用 Seata 的 SelectForUpdateExecutor 执行器对 SELECT FOR UPDATE 语句进行代理。SELECT FOR UPDATE 语句在执行时会申请全局锁，如果全局锁已经被其他全局事务占有，则回滚 SELECT FOR UPDATE 语句的执行，释放本地锁，并且重试 SELECT FOR UPDATE 语句。在这个过程中，查询请求会被阻塞，直到拿到全局锁（也就是要读取的记录被其他全局事务提交），读到已被全局事务提交的数据才返回。这个过程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5722222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5Ohz4OheD3PNeibsGnFX0rREpUBicYCM4r6JXeZtpvhgXpCDKOLsj5Mapg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OLeBdUoUwavsbVPliasUqvq03JuFaMDDASq3l0CjK4kKHiamLwGZ3pgfQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;4. 结束语&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;XA 协议是 X/Open 提出的分布式事务处理标准。文中提到的 2PC、3PC、TCC、本地事务表、Seata in AT mode，无论哪一种，本质都是事务协调者协调各个事务参与者的本地事务的进度，使使所有本地事务共同提交或回滚，最终达成一种全局的 ACID 特性。在协调的过程中，协调者需要收集各个本地事务的当前状态，并根据这些状态发出下一阶段的操作指令。这个思想就是 XA 协议的要义，我们可以说这些事务模型遵守或大致遵守了 XA 协议。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;基于消息中间件的最终一致性事务方案是互联网公司在高并发场景中探索出的一种创新型应用模式，利用 MQ 实现微服务之间的异步调用、解耦合和流量削峰，保证分布式数据记录的最终一致性。它显然不遵守 XA 协议。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于某项技术，可能存在业界标准或协议，但实践者针对具体应用场景的需求或者出于简便的考虑，给出与标准不完全相符的实现，甚至完全不相符的实现，这在工程领域是一种常见的现象。TCC 方案如此、基于消息中间件的最终一致性事务方案如此、Seata in AT mode 模式也如此。而新的标准往往就在这些创新中产生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你难道真的没有发现 2.6 节（基于消息中间件的最终一致性事务方案）给出的正确方案中存在的业务漏洞吗？请各位重新看下这张图，仔细品一品两个微服务的调用方向，把你的想法留在评论区吧 :-)&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.36018518518518516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OSWufbwc1iahgpyuxuk4HBjNbqk4BhZwMalMMnFiaN7U8a8iaPjs77RJHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>67e1209d3291219d76675a9c7bbc0be5</guid>
<title>[推荐] 技术人员该如何接手一个复杂的系统？吐血推荐这几招</title>
<link>https://toutiao.io/k/yyjv3sj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;23&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;阅读本文大概需要 5 分钟。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作为程序员，无论是小菜还是老鸟，都会因为离职交接或者岗位异动等各种原因，而避免不了要如羚羊奔跑版的速度接手一个复杂业务系统。&lt;/span&gt;&lt;span&gt;因为只有尽快熟悉系统，方能够快速支持业务需求的研发。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么，问题就来了？面对一个一无所知的复杂的系统，我们该如何入手呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文将结合菜菜同学多年来的沉（经）淀（验），再融合&lt;/span&gt;&lt;span&gt;老中医望闻问切的招式，吐血整理成一副图和一剂&lt;span&gt;锦囊妙药，送给大家&lt;/span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;《一剂良药》&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;「&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;菊花&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;」看文档，记疑惑。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;「&lt;span&gt;&lt;span&gt;薄荷&lt;/span&gt;&lt;/span&gt;」串文档，理脉络。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;「&lt;span&gt;&lt;span&gt;莲&lt;span&gt;心&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;」讲系统，要知彼。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;「&lt;span&gt;&lt;span&gt;荷叶&lt;/span&gt;&lt;/span&gt;」捋代码，了梗概。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;「&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;玄参&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;」盘经验，&lt;/span&gt;&lt;span&gt;理大坑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;「&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;芦根&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;」亲操刀，细解剖&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;《一幅脑图》&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;369&quot; data-backw=&quot;544&quot; data-ratio=&quot;0.6787003610108303&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/waH0DGXhQWOPZShy6w0VLYA9q4QG54aXkVo8OJ9MTP1IQmgia6C8Cia3VD4XlTLgAJc2icPNZADZOcngrGI5Bznsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1662&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;1&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;第一招：&lt;span&gt;看文档，知脉略。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;老中医：望。望诊，是对病人的神、色、形、态、舌象等进行有目的的观察，以测知内脏病变。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;菜菜同学结合「望诊」而独创快速接手一个复杂系统之&lt;/span&gt;&lt;strong&gt;&lt;span&gt;招式一：&lt;/span&gt;&lt;span&gt;看&lt;/span&gt;&lt;span&gt;文档，知脉略&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当一个复杂的系统要交接到你手上时，理想中各种文档样样全，要啥有啥，而现实啪啪打脸。&lt;/span&gt;&lt;span&gt;多数情况下都没有文档，如果有一些文档可看，无论质量如何，都是一件值得庆幸的事情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果项目组比较规范，沉淀了一些入门文档、产品介绍文档、业务架构设计文档、数据库设计文档，那就更值得庆幸啦，静下来仔细去看，&lt;span&gt;通过文档多少会了解一些系统的前世今生，对系统有一个初步的认识。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过，&lt;/span&gt;&lt;span&gt;当接手一个系统时，一定要看看文档在哪里？&lt;/span&gt;&lt;span&gt;是在 Wiki 上，还是在 SVN、Git 上，如若有文档的情况下，尽快找到它，并粗略的看一遍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看了这么多文档，肯定有太多的疑惑，先拿小本本记下来，制造机会请老鸟给你答疑解惑。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;2&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;第二招：听细节&lt;/span&gt;&lt;span&gt;，聊全局。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;老中医：闻。闻诊，主要是听患者语言气息的高低、强弱、清浊、缓急……等变化，以分辨病情的虚实寒热。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;菜菜同学结合「闻诊」而独创快速接手一个复杂系统之&lt;/span&gt;&lt;strong&gt;&lt;span&gt;招式二：&lt;/span&gt;&lt;span&gt;听细节，聊全局。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;拿着你事先记录好满满疑惑的小本本，组个会议，喊上老鸟好好给你指点迷津。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;首先，请老鸟串一串文档。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大概理一理，然后把你之前小本本上的问题，一股脑抛出来当面请教。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;然后，请老鸟讲一讲系统。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大概要了解一下系统的使用方是谁？&lt;/span&gt;&lt;span&gt;系统依赖的系统有哪些？系统&lt;/span&gt;&lt;span&gt;主要干&lt;/span&gt;&lt;span&gt;系&lt;/span&gt;&lt;span&gt;人有哪些？系统研发的需求来自于哪里？&lt;/span&gt;&lt;span&gt;最重要的是要请老鸟演示一下如何把系统跑起来？&lt;/span&gt;&lt;span&gt;跑起来后功能该怎么用？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;最后，请老鸟捋一捋代码。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;大概捋一捋代码的设计，了解一下&lt;span&gt;主要分为几&lt;/span&gt;&lt;span&gt;大&lt;/span&gt;&lt;span&gt;块？&lt;/span&gt;程序入口在哪里？技术栈是啥样子？... ...&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;3&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;第三招：&lt;/span&gt;&lt;span&gt;问疑难，解杂症。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;老中医：问。问诊，通过了解既往病史与家族病史、起病原因、发病经过及治疗过程，主要痛苦所在，自觉症状，饮食喜恶等情况，结合望、切、闻三诊，综合分析，作出判断。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;菜菜同学结合「问诊」而独创快速接手一个复杂系统之&lt;/span&gt;&lt;strong&gt;&lt;span&gt;招式三：问疑难&lt;/span&gt;&lt;span&gt;，解杂症。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;首先，问老鸟：要接手的系统，历史事故都发生过哪些？&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;为了&lt;/span&gt;&lt;span&gt;不贰过，要&lt;/span&gt;了解一下要接手的系统，历史的事故是代码问题，还是人祸导致的？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;最后，问老鸟：要接手的系统，坑在哪里？&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大概了解一下老鸟以往趟过的那些坑，前车之鉴必是后车之师。&lt;/span&gt;&lt;span&gt;重点了解系统有哪块会有潜在的问题，当接手之后一定要细心着重对待，防患于未然。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;4&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;第四招：亲操刀&lt;/span&gt;&lt;span&gt;，细解剖。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;老中医：切。切脉又称诊脉，是医者用手指按其腕后桡动脉搏动处，借以体察脉象变化，辨别脏腑功能盛衰，气血津精虚滞的一种方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;菜菜同学结合「切诊」而独创快速接手一个复杂系统之&lt;/span&gt;&lt;strong&gt;&lt;span&gt;招式四：&lt;/span&gt;&lt;span&gt;亲操刀，细解剖。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过前面三种招式相结合，我们文档也看了，系统功能也了解了，历史事故也知道了，接下来要进入程序员最擅长区域——解剖代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;首先，加注释，加&lt;/span&gt;&lt;span&gt;关键日志。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;找到程序入口，根据自己的理解，一步一步去加注释，&lt;span&gt;要&lt;/span&gt;&lt;span&gt;敢于&lt;/span&gt;&lt;span&gt;动手去&lt;/span&gt;&lt;span&gt;加，确定不了的，有疑问&lt;/span&gt;的用注释标记好，或者记个大大的问号，把你的想法理解都用注释记录一下，相信对代码的理解，一遍比一遍更透彻。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，除了加注释的一种方式，还推荐加关键日志，因为加入关键日志，不过日志最好有一些特色，例如都还有「haha：」，这样能够在子模块调用比较复杂的情形下，在项目启动后，根据加入日志文件，直接关注「haha：」就能把相关子系统的调用流程串在一起，屡试不爽。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;然后，跑应用，Debug。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了加注释，加关键日志能够理解代码逻辑外，Debug 也是推荐的一种方式，从程序入口开始逐步进行调试，也会对代码有一个质的理解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;仁者见仁智者见智，依据个人习惯，还是更推荐加日志，或许是因为 Debug 有些时候遇到反射或者库调用，跟着跟着就乱掉了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这里，建议一定要把应用跑起来，只有跑起来，才能根据之前加入的日志，梳理梳理系统调用关系，模块调用关系，再好好体验体验功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;最后，画画图，善分享。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;加日志、加注释、Debug 的事儿&lt;span/&gt;&lt;span&gt;多数铁子&lt;/span&gt;都干过，但是能把自己对代码的理解真心画下来的估计会很少，这块真心推荐大家没事的时候静下来画一画，是对代码理解质的一次提升，画出来才能理解的更透彻，更清晰，如果闲暇之余把上手系统的经过写成手册，相信对于后面接手的同事而言是一大笔“财富”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然了，除了画图、写手册还是不够的，重要的是能够拉几个同事进行分享一下，这样才能更快变成自己的知识，在这里忍不住要抛一张图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;383&quot; data-backw=&quot;544&quot; data-ratio=&quot;0.7043918918918919&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/waH0DGXhQWOPZShy6w0VLYA9q4QG54aXcqRygDUGZ7A2oNeg0VBT6rLfvn7woyU2HqufDeia1Tv3Dp6KGz5JKnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1184&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，接手系统解剖代码这块放到最后一部分去谈，原因这块确实考验个人的技术能力，而且是一个长久的过程，需要慢慢去磨。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;5&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;真心寄语&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本次主要谈谈如何快速接手一个系统？&lt;/span&gt;&lt;span&gt;吐血推荐的一幅图和一剂药，如果有接手系统的困惑，而且没有更好的方法时，那不妨拿去实践，&lt;/span&gt;&lt;span&gt;屡试不爽。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;前路漫长，&lt;/span&gt;&lt;span&gt;人生实苦，每个人方法都不一样，条条大路通罗马，选择适合自己的。奔跑是追梦人的气质，用奋斗定义人生价值，在奔跑中抵达远方，铁子们加油💪。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好了，分享就到这里，希望对你有帮助。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;一起聊技术、谈业务、喷架构，少走弯路，不踩大坑。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;会持续输出原创精彩分享，敬请期待！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;198&quot; data-backw=&quot;544&quot; data-ratio=&quot;0.3649122807017544&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1710&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/waH0DGXhQWOwkpyEoA1IiakYviaHIX4GnoUHGE4kNCqHqAM54WmxryEd76E7Uf1xibO18pftGiafQqI8ibxqMHG34xA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;amp;mid=2247485536&amp;amp;idx=1&amp;amp;sn=4347aea8740973fea3346fb48e7efd97&amp;amp;chksm=fc00436dcb77ca7ba2c0fcc105c8adbf1c31f61fc6ed143b936fea806c973fdf37e169aeba61&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;真实|技术人员该如何站好最后一班岗？&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;amp;mid=2247485423&amp;amp;idx=1&amp;amp;sn=e74b30d0c5482e2b6f488901229698b5&amp;amp;chksm=fc004ce2cb77c5f419dabb40e9a237d892a3cf489741f4c5f87fc0d9f61d296c763f58cd4726&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;真实|为什么要做有灵魂的程序员？&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>