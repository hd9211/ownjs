<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>986a247577aed1119436b57a629e488d</guid>
<title>装了这几个 IDEA 插件，基本上一站式开发了</title>
<link>https://toutiao.io/k/5l4hrcp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000819&quot; data-ratio=&quot;0.5141666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPzeyWUMj7o2zzbLLN7u8rrnnYFaU2rLAF0a68cGw6AM2X8Q6Ha2sR6rg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前几天有社区小伙伴私聊我，问我都用哪些IDEA插件，我的IDEA的主题看起来不错。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;作为一个开源作者，每周要code大量的代码，提升日常工作效率是我一直追求的，在众多的IDEA插件中，我独钟爱这几款。这期就整理一些我日常中经常使用的IDEA插件，这些插件有些挺小众，但是的确非常提升效率，推荐给大家。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Vuesion Theme&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先推荐是一款皮肤，每天对着看IDEA，默认的皮肤黑白两色，我个人总觉得白色太刺眼，黑色的有点太黑了，代码高亮也不好看，长时间难免看着有点审美疲劳。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;颜值是生产力的第一要素，主题整好了，整个心情也好一点，心情好，自然bug就少点。。。是这个道理么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在众多的IDEA的主题中，我钟爱这一款。非常适中的UI颜色，漂亮的代码高亮主题。看了半年多了，都没有审美疲劳。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000817&quot; data-ratio=&quot;0.67&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPzWqDnPBQB2Ga9FM6vkaSF5kx9U0h18BkDSI8DjsDRbeHQVeGqsJH8IQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;废话不多说，直接看代码主题效果：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000820&quot; data-ratio=&quot;0.564&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPz2kjyk4TTQIOQEXib7vgbeCicJUoVbACLxd79wnXXHxgsz6upicpDShHew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;4500&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我知道每个人审美有所不同，有的小伙伴会说，我就是喜欢默认的暗黑色。okay啦，我只代表个人喜好。这里不杠。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Atom Material ICons&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第二款推荐的是一款ICON插件，相信也有很多小伙伴也有用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实这个Icon虽然不难看，但是我也没觉得多好看。那我为什么还要特意推荐？？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为这款ICon插件附加了一个buff。。。这是我当时如何也想不通的。😂&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000816&quot; data-ratio=&quot;0.8564102564102564&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPzAug7nKUFl1X3VydnclJiaX2tS1zG1UxHOlicDLPfe1tltG16zkNyjSSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;780&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;部分效果如下：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000818&quot; data-ratio=&quot;0.7033898305084746&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPz87khrOibeHMxCTldSsFicPjf4vKtAAHdibn3o3ZLzUCBickvc48vvx7tAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;708&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000822&quot; data-ratio=&quot;0.07851851851851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPzl229LpFwqMvxQpylicZvFEzTajial5u8ZwgJROa7o1uK5SPjtlxvZMHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1350&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实不难看，那我就要说说这个icon插件附带的buff了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;idea在macOs下，无论是我用2018款的Macbook pro还是现在的Macbook pro m1版本，总感觉在拖动滚动条或是鼠标中键滚屏时有点卡顿，并不是电脑性能的问题，我在网上看到有其他小伙伴也遇到了这种情况。应该是idea对MacOs系统的优化问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我尝试过增大Idea的jvm缓存，尝试过优化参数。都无果，后来偶然一次机会在某个论坛上看到有一个人说，装了这个Icon插件之后就变的丝滑无比了，但不知道为啥。我抱着怀疑的态度装了下，卧槽，瞬间丝滑了。虽然我也不懂这是为什么，但是解决问题了之后这个Icon插件就变成必备插件了。如果有小伙伴遇到我想同的问题的话，那么请尝试。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个buff是不是很强大呢。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;File Expander&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有了这个插件，有些小伙伴平时用的Jad工具就可以扔了，它能在Idea里直接打开Jar包，并且反编译代码查看。甚至于能打开tar.gz，zip等压缩格式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里补充下，你项目里之所以不需要装插件就能看jar包里的代码，是因为jar在你的classpath内。如果单独打开一个jar包，不装插件是看不了的。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000823&quot; data-ratio=&quot;0.98559670781893&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPzttZzDYcHaVpVlr1PQSw2aibcia0OgYyicAU8e7RmktE81F9emB6BEDqQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;972&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000825&quot; data-ratio=&quot;0.7307692307692307&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPzQdY030b6uWxWElUQmJwFo5gaWgxVMu2mWBgv1oianAlkWIia5mNMicKpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;988&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000824&quot; data-ratio=&quot;0.7693522906793049&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPztF8qZxfE6OExvx773KuEaibhO087cm3sDqVLbDM8Dgic8GxNJgyuM2PQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1266&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;GitToolBox&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这款插件现在我几乎离不开它。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;他能在项目上提示你还有多少文件没提交，远程还有多少文件没更新下来。还能在每一行代码上提示上次提交的时间。查版本提交问题的时候尤其方便。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000821&quot; data-ratio=&quot;0.8020833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPznuC53ic7hUmfnMQSxTnDVuz3paIWTQ4usx3riaWadeYZrVGUgB6ykCoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;768&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000826&quot; data-ratio=&quot;0.43327556325823224&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPz7P6wNOMMJn21nxl9uVlJmJTLNMMV9QP0cdH3OVLM81N2gaHiclJ3Bgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1154&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000829&quot; data-ratio=&quot;0.3639120545868082&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPzKDUaW4Dv5PxwDiayEy9cGVFQaiabiaQEchozF7L7PoiaoeFvboTjv7aHaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2638&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Maven Helper&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个我想应该是所有使用Idea开发者的标配插件了吧。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我经常使用到的功能便是可视化依赖书，可以清晰的知道，哪个Jar包传递依赖了什么，哪个jar包什么版本和什么版本冲突了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;排查Jar包依赖等问题用这个简直是神器。这个插件也提供了一些其他的快捷命令，右键直接唤起maven命令，颇为方便。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000827&quot; data-ratio=&quot;0.7321428571428571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPzvDniaGIvm6a8bsCyc3wBw9DtNpR3nXgf7UcuQgJZHMSEy8VmMrUic1Nw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;784&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000830&quot; data-ratio=&quot;1.1940700808625337&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPzS5JLBgn2I4accAzR8gmI0UoJkVQuylJ7c59SodHjEMmAEMQeicJf0PQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1484&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Translation&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;源码中很多注解都是英文，有时候看着有点费劲。这款翻译插件基本上与Idea一体化，从集成度和方便程度来说，可以吊打其他的第三方翻译软件了。不需要你切换窗口，直接一个快捷键就可以翻译整段文本了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关键是这个插件的翻译引擎可以与多个翻译接口集成对接，支持google翻译，有道翻译，百度翻译，阿里翻译。实时进行精准快速的翻译，自动识别语言。帮助你在阅读源码里的英文时理解的更加透彻。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000828&quot; data-ratio=&quot;0.5292620865139949&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPz53tiajIEjzt6KFiaQiaFS3n3YBKYgMVHj2szhVh9js558v1SnmXUuWotw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000832&quot; data-ratio=&quot;0.7048192771084337&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPzzZXx9PvWRxhIJuVnaeLY326iby1Ve4vvr9vEKWrhkqmDX384xoUYppA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;664&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000834&quot; data-ratio=&quot;0.8890200708382526&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPzvfYkBzBAqnicmy9yReGSiciaMrVcnEKxswVYDmfGEQmPy8icxJ2UUicxKWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1694&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;arthas idea&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Arthas是阿里开源的一款强大的java在线诊断工具，做java开发的小伙伴一定很熟悉。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个工具几乎已经成为诊断线上java应用的必备工具了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是每次需要输入很长一段命令，有些命令遗忘的话，还要去翻看Arthas的命令文档，然后还要复制代码中类或方法的全路径，很是不方便。而这款arthas的插件就可以让你完全摆脱这些苦恼。生产力大大提升。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000831&quot; data-ratio=&quot;0.5876288659793815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPzcl9NptjmJicyUicpxnOqlic81jWjDl4ewvmTmwaR5Qcq3t0Zdpwn2nltg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;776&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用起来非常方便，进入代码片段，选择你要诊断的类或者方法上面，右击打开Arthas命令，选择一项，即可自动生成命令，省去你敲打命令的时间。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000835&quot; data-ratio=&quot;0.7880676758682101&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPzA8JbvBu3ibDtqafCDyyhfCAJKUswZUqkutptJlYG2FLGupicSJI7EDBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2246&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Search In Repository&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;平时我们如果要依赖一个第三方jar包，但是不知道它的maven/gradle的坐标。我们该怎么做？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;搓点的做法基本上就是baidu了，稍微高级点的就是到中央仓库去查下，最新版本的坐标是什么。然后复制下来，贴到pom里去。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这款插件，就无需你来回跳转，直接把中央仓库的查找集成到了Idea里面。你只需要打开这款插件，输入jar包的名字或者gav关键字，就能查到到这个jar包所有的版本，然后可以直接复制gav坐标。方便又快捷，干净又卫生！&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000833&quot; data-ratio=&quot;0.5024630541871922&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPzMveLadvicoiaJxNYn2rd5D3lmjibQFo81icwWomnET211MiaCccu4lFnjHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;812&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000839&quot; data-ratio=&quot;1.9897058823529412&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPz3Kxy6oDYgMSDtxZtNvoook2djMzdm9AB9tbyF0454UIhXuDCqwIiauA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1360&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;VisualGC&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不知道大家去诊断JVM堆栈用什么工具呢，是不是大部分都是用jdk的原生工具呢。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里推荐大家一个Idea堆栈的可视化工具，和Idea深度集成。直接显示所有进程，双击即可打开JVM的堆栈可视化界面。堆栈和垃圾收集情况一目了然！&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000837&quot; data-ratio=&quot;0.6820512820512821&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPz0gmbicibzMm2tI3kjV5ZrbNt8vaVI721vdjh1V5fiajxQEjZ7qSoIusHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;780&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000840&quot; data-ratio=&quot;0.77947932618683&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPz2cNImyjkN4pBSiciaH7o2GcXO0wib3AjuiaLPQPicKlo0aa4iavBwuMv3EGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2612&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Zoolytic&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一款zookeeper节点的查看分析插件。其实第三方也有一些zk的节点信息查看工具，但是我都觉得不够方便，直到我发现了这款插件。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;idea里面直接可以看zookeeper的节点信息，非常方便。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000836&quot; data-ratio=&quot;0.7741116751269036&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPzB19Df6Y68xTG9YbM0uSgZTILxqbzI5XqMQGmbRpAPFNrIYDsTWrJOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;788&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000838&quot; data-ratio=&quot;1.2523540489642184&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YbBNmAxYwZKtUbMyD6jfjjTguoBwwHPz4emkLc8h7U1ImdXrnnThJhO3p4aia6sdOVZ4g5tRDQXibOheh64eR1dA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1062&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以上这10款Idea插件是我平时中用的非常多且经过筛选的，因为有些大家耳熟能详就不介绍了，相信小伙伴们都有装。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;往期阅读链接：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwNDY1NTU1OA==&amp;amp;mid=2247496992&amp;amp;idx=1&amp;amp;sn=09b6d1148e618d40241c7fd445d63f85&amp;amp;chksm=973e6b89a049e29f6b8f39dafb5c05a15c5efcc27e70b443ef128143c871baaae978dbfef4e7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;当 Swagger 遇上 Torna，瞬间高大上了！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;当 Swagger 遇上 Torna，瞬间高大上了！&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwNDY1NTU1OA==&amp;amp;mid=2247496989&amp;amp;idx=1&amp;amp;sn=02549720a2434c42c4f3e289a84cf7ac&amp;amp;chksm=973e6bb4a049e2a2ba89653e7ce012187a56bc915114098d915652a9d804394a28f5a3197ac6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;在部队当程序员是什么体验？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;在部队当程序员是什么体验？&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwNDY1NTU1OA==&amp;amp;mid=2247496968&amp;amp;idx=1&amp;amp;sn=f30931ff672129655ba107f96fb550d8&amp;amp;chksm=973e6ba1a049e2b72c604b82fc75f58bf6644c5d89c3100c92b7fb1f97c07ce14bf3b62d04c6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;实战！工作中常用到哪些设计模式&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;实战！工作中常用到哪些设计模式&lt;/a&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIwNDY1NTU1OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/DibTgjt8mhxwsibjA6QDEY9evlE1wnIOkZyVgwXynsibtEFZlMuYoEv184ZvcTCunicbRqLiagaMN82PVcFzuwiaibLvg/0?wx_fmt=png&quot; data-nickname=&quot;编程技术进阶&quot; data-alias=&quot;tech_jinjie&quot; data-signature=&quot;编程技术进阶，专注分享Java技术干货，包括多线程、架构设计、微服务、消息队列、Git、面试题、程序员攻略、JVM、Spring Boot、Spring Cloud、Dubbo、Zookeeper、Redis等。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d9778383e2e9491a0b042a1fc48de7e9</guid>
<title>微服务架构中，二次浅封装实践</title>
<link>https://toutiao.io/k/trjpccd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4Njg0MzYwNw==&amp;amp;action=getalbum&amp;amp;album_id=1327025063014596608#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1327025063014596608&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#分布式-数据源-中间件&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;35个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1&gt;&lt;span&gt;一、背景简介&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;分布式系统中存在很多拆分的服务，在不断迭代升级的过程中，会出现如下常见的棘手情况：&lt;/p&gt;&lt;p&gt;某个技术组件版本升级，依赖包升级导致部分语法或者API过期，或者组件修复紧急的漏洞，从而会导致分布式系统下各个服务被动的升级迭代，很容易引发意外的问题；不同的服务中对组件的依赖和版本各不相同，从而导致不兼容问题的出现，很难对版本做统一的管理和维护，一旦出现问题很容易手忙脚乱，引发蝴蝶效应；&lt;/p&gt;&lt;p&gt;所以在复杂的系统中，对于依赖的框架和组件进行统一管理和二次浅封装，可以较大程度降低上述问题的处理成本与风险，同时可以更好的管理和控制技术栈。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、框架浅封装&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、浅封装作用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;为什么浅封装，核心目的在于统一管理和协调组件的依赖与升级，并对常用方法做一层包装，实际上很多组件使用到的功能点并不多，只是在业务中的使用点很多，这样给组件本身的迭代升级带来了一定的难度：&lt;/p&gt;&lt;p&gt;例如某个组件常用的API中存在巨大风险漏洞，或者替换掉过期的用法，需要对整个系统中涉及的地方做升级，这种操作的成本是非常高的；&lt;/p&gt;&lt;p&gt;如果是对这种常用的组件方法进行二次包装，作为处理业务的工具方法，那么解决上面的问题就相对轻松许多，只要对封装的工具方法升级，服务的依赖升级即可，降低时间成本和风险。&lt;/p&gt;&lt;p&gt;通过浅封装的手段，可以实现两个方面的解耦：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;业务与技术&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;技术栈中常用的方法进行二次浅封装，这样可以较大程度的降低业务与技术的耦合，如此可以独立的升级技术栈，扩展功能而不影响业务服务的迭代。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;框架与组件&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;不同的框架与组件都需要一定程度的自定义配置，同时分模块管理，在不同的服务中引入特定的依赖，也可以在基础包中做统一依赖，以此实现技术栈的快速组合搭配。&lt;/p&gt;&lt;p&gt;这里说的浅封装，是指包装常规常用的语法，组件本身就是技术层面的深度封装，所以也不可能完全隔开技术栈原生用法。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、统一版本控制&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;例如微服务架构下，不同的研发组负责不同的业务模块，然而受到开发人员的经验和能力影响，很容易出现不同的服务组件选型不一致，或者相同的组件依赖版本不同，这样很难对系统架构做标准的统一管理。&lt;/p&gt;&lt;p&gt;对于二次封装的方式，可以严格的控制技术栈的迭代扩展，以及版本冲突的问题，通过对二次封装层的统一升级，可以快速实现业务服务的升级，解决不同服务的依赖差异问题。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、实践案例&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、案例简介&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;Java分布式系统中，微服务基础组件（Nacos、Feign、Gateway、Seata）等，系统中间件（Quartz、Redis、Kafka、ElasticSearch，Logstash）等，对常用功能、配置、API等，进行二次浅封装并统一集成管理，以满足日常开发中基础环境搭建与临时工具的快速实现。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;butte-flyer&lt;/strong&gt; 组件封装的应用案例；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;butte-frame&lt;/strong&gt; 常用技术组件二次封装；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;2、分层架构&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;整体划分五层：网关层、应用层、业务层、中间件层、基础层，组合成一套分布式系统。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6415094339622641&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBgfKyQH3qn7iaM7DCD4O8ZLXo4e0fVfaALP4wmsVk1zrTJ8y0csJ6SiaKSCRFclkXLk1icecpHvudZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot;/&gt;&lt;/p&gt;&lt;p&gt;服务总览&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9363817097415507&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBgfKyQH3qn7iaM7DCD4O8ZLAZtbVAf4tEHkia0LpeaDmxGH1ribpITl5Jz5ANK60SkzjRtpMJGAgJww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1006&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、目录结构&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;butte-frame&lt;/code&gt;中对各个技术栈进行二次封装管理，在&lt;code&gt;butte-flyer&lt;/code&gt;中进行依赖引用。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;butte-frame&lt;br/&gt;├── frame-base          基础代码块&lt;br/&gt;├── frame-jdbc          数据库组件&lt;br/&gt;├── frame-core          服务基础依赖&lt;br/&gt;├── frame-gateway       路由网关&lt;br/&gt;├── frame-nacos         注册与配置中心&lt;br/&gt;├── frame-seata         分布式事务&lt;br/&gt;├── frame-feign         服务间调用&lt;br/&gt;├── frame-security      安全管理&lt;br/&gt;├── frame-search        搜索引擎&lt;br/&gt;├── frame-redis         缓存管理&lt;br/&gt;├── frame-kafka         消息中间件&lt;br/&gt;├── frame-quartz        定时任务&lt;br/&gt;├── frame-swagger       接口文档&lt;br/&gt;└── frame-sleuth        链路日志&lt;br/&gt;&lt;br/&gt;butte-flyer&lt;br/&gt;├── flyer-gateway       网关服务：路由控制&lt;br/&gt;├── flyer-facade        门面服务：功能协作接口&lt;br/&gt;├── flyer-account       账户服务：用户账户&lt;br/&gt;├── flyer-quartz        任务服务：定时任务&lt;br/&gt;└── flyer-admin         管理服务：后端管理&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;4、技术栈组件&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;系统常用的技术栈：基础框架、微服务组件、缓存、安全管理、数据库、定时任务、工具依赖等。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.5470941883767535&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBgfKyQH3qn7iaM7DCD4O8ZLCleKhvhjnHVoNsrDTInRNWibbSr6eLlAH2Yvib59snxHCdp3icLq2lX1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;998&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、微服务组件&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、Nacos&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;Nacos在整个组件体系中，提供两个核心能力，注册发现：适配微服务注册与发现标准，快速实现动态服务注册发现、元数据管理等，提供微服务组件中最基础的能力；配置中心：统一管理各个服务配置，集中在Nacos中存储管理，隔离多环境的不同配置，并且可以规避线上配置放开的风险；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.41710296684118675&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBgfKyQH3qn7iaM7DCD4O8ZLqueKRdic2icFoNTKMp5aDwtYdIGqV3eCT17TuXhqgK9Ux6EvqkattIJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1146&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;连接管理&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;cloud:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;nacos:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;# 配置读取&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;config:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;prefix:&lt;/span&gt; &lt;span&gt;application&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;server-addr:&lt;/span&gt; &lt;span&gt;127.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;:8848&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;file-extension:&lt;/span&gt; &lt;span&gt;yml&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;refresh-enabled:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;# 注册中心&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;discovery:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;server-addr:&lt;/span&gt; &lt;span&gt;127.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;:8848&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;配置管理&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;bootstrap.yml&lt;/strong&gt; ：服务中文件，连接和读取Nacos中配置信息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;application.yml&lt;/strong&gt; ：公共基础配置，这里配置mybatis组件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;application-dev.yml&lt;/strong&gt; ：中间件连接配置，用作环境标识隔离；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;application-def.yml&lt;/strong&gt; ：各个服务的自定义配置，参数加载；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.48381294964028776&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBgfKyQH3qn7iaM7DCD4O8ZLdQxB1hKNwgYUBicqXmOfXbDBJTlleaSBNTmuElZvb9jkGZpmSNA7J6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1112&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、Gateway&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;Gateway网关核心能力，提供统一的API路由管理，作为微服务架构体系下请求唯一入口，还可以在网关层处理所有的非业务功能，例如：安全控制，流量监控限流，等等。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;路由控制&lt;/strong&gt;：各个服务的发现和路由；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RouteFactory&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;RouteDefinitionRepository&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RouteService routeService ;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 加载全部路由&lt;br/&gt;     * &lt;span&gt;@since&lt;/span&gt; 2021-11-14 18:08&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Flux&amp;lt;RouteDefinition&amp;gt; &lt;span&gt;getRouteDefinitions&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Flux.fromIterable(routeService.getRouteDefinitions());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 添加路由&lt;br/&gt;     * &lt;span&gt;@since&lt;/span&gt; 2021-11-14 18:08&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Mono&amp;lt;Void&amp;gt; &lt;span&gt;save&lt;/span&gt;&lt;span&gt;(Mono&amp;lt;RouteDefinition&amp;gt; routeMono)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; routeMono.flatMap(routeDefinition -&amp;gt; {&lt;br/&gt;            routeService.saveRouter(routeDefinition);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; Mono.empty();&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;全局过滤&lt;/strong&gt;：作为网关的基础能力；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GatewayFilter&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;GlobalFilter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(GatewayFilter&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Mono&amp;lt;Void&amp;gt; &lt;span&gt;filter&lt;/span&gt;&lt;span&gt;(ServerWebExchange exchange, GatewayFilterChain chain)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ServerHttpRequest request = exchange.getRequest();&lt;br/&gt;        String uri = request.getURI().getPath() ;&lt;br/&gt;        String host = String.valueOf(request.getHeaders().getHost()) ;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;request host : {} , uri : {}&quot;&lt;/span&gt;,host,uri);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; chain.filter(exchange);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;3、Feign&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;Feign组件是声明式的WebService客户端，使微服务之间的调用变得更简单，Feign通过注解手段，将请求进行模板化和接口化管理，可以更加标准的管理各个服务间的通信交互。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;响应解码&lt;/strong&gt;：定义Feign接口响应时解码逻辑，校验和控制统一的接口风格；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FeignDecode&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ResponseEntityDecoder&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;FeignDecode&lt;/span&gt;&lt;span&gt;(Decoder decoder)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(decoder);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;decode&lt;/span&gt;&lt;span&gt;(Response response, Type type)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!type.getTypeName().startsWith(Rep&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getName&lt;/span&gt;())) &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;响应格式异常&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.decode(response, type);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(e.getMessage());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;4、Seata&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;Seata组件是开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务，实现AT、TCC、SAGA、XA事务模式，支持一站式的分布式解决方案。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;事务配置&lt;/strong&gt;：基于nacos管理Seata组件的参数定义；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6023622047244095&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBgfKyQH3qn7iaM7DCD4O8ZLCwDLBU5VqibwECBQ8dybgcp6xHvfoe6wxxv5RSErBEvjrias1IsBHsdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1016&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;服务注册&lt;/strong&gt;：在需要管理分布式事务的服务中连接和使用Seata服务；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;seata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;enabled:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;application-id:&lt;/span&gt; &lt;span&gt;${spring.application.name}&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;tx-service-group:&lt;/span&gt; &lt;span&gt;butte-seata-group&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;config:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;type:&lt;/span&gt; &lt;span&gt;nacos&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;nacos:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;server-addr:&lt;/span&gt; &lt;span&gt;${spring.cloud.nacos.config.server-addr}&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;group:&lt;/span&gt; &lt;span&gt;DEFAULT_GROUP&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;registry:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;type:&lt;/span&gt; &lt;span&gt;nacos&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;nacos:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;server-addr:&lt;/span&gt; &lt;span&gt;${spring.cloud.nacos.config.server-addr}&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;application:&lt;/span&gt; &lt;span&gt;seata-server&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;group:&lt;/span&gt; &lt;span&gt;DEFAULT_GROUP&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;&lt;span&gt;五、中间件集成&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、Kafka&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;Kafka是由Apache开源，具有分布式、分区的、多副本的、多订阅者，基于Zookeeper协调的分布式消息处理平台，由Scala和Java语言编写。还常用于搜集用户在应用服务中产生的日志数据。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;消息发送&lt;/strong&gt;：封装消息发送的基础能力；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;KafkaSendOperate&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; KafkaTemplate&amp;lt;String, String&amp;gt; kafkaTemplate ;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;send&lt;/span&gt; &lt;span&gt;(SendMsgVO entry)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        kafkaTemplate.send(entry.getTopic(),entry.getKey(),entry.getMsgBody()) ;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;消息消费&lt;/strong&gt;：消费监听时有两种策略；&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消息生产方自己消费，通过Feign接口去执行具体消费服务的逻辑，这样有利于流程跟踪排查；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息消费方直接监听，减少消息处理的流程节点，当然也可以打造统一的MQ总线服务（文尾）；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;KafkaListen&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(KafkaListen&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Kafka消息监听&lt;br/&gt;     * &lt;span&gt;@since&lt;/span&gt; 2021-11-06 16:47&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@KafkaListener&lt;/span&gt;(topics = KafkaTopic.USER_TOPIC)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;listenUser&lt;/span&gt; &lt;span&gt;(ConsumerRecord&amp;lt;?,String&amp;gt; record, Acknowledgment acknowledgment)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            String key =  String.valueOf(record.key());&lt;br/&gt;            String body = record.value();&lt;br/&gt;            &lt;span&gt;switch&lt;/span&gt; (key){ }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e){&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            acknowledgment.acknowledge();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;2、Redis&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;Redis是一款开源组件，基于内存的高性能的key-value数据结构存储系统，它可以用作数据库、缓存和消息中间件，支持多种类型的数据结构，如字符串、集合等。在实际应用中，通常用来做变动频率低的热点数据缓存和加锁机制。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;KV数据缓存&lt;/strong&gt;：作为Redis最常用的功能，即缓存一个指定有效期的键和值，在使用时直接获取；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RedisKvOperate&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; StringRedisTemplate stringRedisTemplate ;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 创建缓存，必须带缓存时长&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; key 缓存Key&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; value 缓存Value&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; expire 单位秒&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; boolean&lt;br/&gt;     * &lt;span&gt;@since&lt;/span&gt; 2021-08-07 21:12&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; &lt;span&gt;(String key, String value, &lt;span&gt;long&lt;/span&gt; expire)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            stringRedisTemplate.opsForValue().set(key,value,expire, TimeUnit.SECONDS);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e){&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; Boolean.FALSE ;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE ;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Lock加锁机制&lt;/strong&gt;：基于&lt;code&gt;spring-integration-redis&lt;/code&gt;中&lt;code&gt;RedisLockRegistry&lt;/code&gt;，实现分布式锁；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RedisLockOperate&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; RedisLockRegistry redisLockRegistry;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 尝试一次加锁，采用默认时间&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; lockKey 加锁Key&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; java.lang.Boolean&lt;br/&gt;     * &lt;span&gt;@since&lt;/span&gt; 2021-09-12 13:14&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@SneakyThrows&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;Boolean &lt;span&gt;tryLock&lt;/span&gt;&lt;span&gt;(T lockKey)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; redisLockRegistry.obtain(lockKey).tryLock(time, TimeUnit.MILLISECONDS);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 释放锁&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; lockKey 解锁Key&lt;br/&gt;     * &lt;span&gt;@since&lt;/span&gt; 2021-09-12 13:32&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;unlock&lt;/span&gt;&lt;span&gt;(T lockKey)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        redisLockRegistry.obtain(lockKey).unlock();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;3、ElasticSearch&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;ElasticSearch是一个基于Lucene的搜索服务器，它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口，Elasticsearch是用Java开发的，是当前流行的企业级搜索引擎。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;索引管理&lt;/strong&gt;：索引的创建和删除，结构添加和查询；&lt;/p&gt;&lt;p&gt;基于&lt;code&gt;ElasticsearchRestTemplate&lt;/code&gt;的模板方法操作；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TemplateOperate&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ElasticsearchRestTemplate template ;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 创建索引和结构&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; clazz 基于注解类实体&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; java.lang.Boolean&lt;br/&gt;     * &lt;span&gt;@since&lt;/span&gt; 2021-08-15 19:25&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;Boolean &lt;span&gt;createPut&lt;/span&gt; &lt;span&gt;(Class&amp;lt;T&amp;gt; clazz)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; createIf = template.createIndex(clazz) ;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (createIf){&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; template.putMapping(clazz) ;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.FALSE ;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;基于&lt;code&gt;RestHighLevelClient&lt;/code&gt;原生API操作；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;IndexOperate&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RestHighLevelClient client ;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 判断索引是否存在&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; boolean&lt;br/&gt;     * &lt;span&gt;@since&lt;/span&gt; 2021-08-07 18:57&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;exists&lt;/span&gt; &lt;span&gt;(IndexVO entry)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        GetIndexRequest getReq = &lt;span&gt;new&lt;/span&gt; GetIndexRequest (entry.getIndexName()) ;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; client.indices().exists(getReq, entry.getOptions());&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.FALSE ;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;数据管理&lt;/strong&gt;：数据新增、主键查询、修改、批量操作，业务性质的搜索封装复杂度很高；&lt;/p&gt;&lt;p&gt;数据的增删改方法；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DataOperate&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RestHighLevelClient client ;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 批量更新数据&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; entry 对象主体&lt;br/&gt;     * &lt;span&gt;@since&lt;/span&gt; 2021-08-07 18:16&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;bulkUpdate&lt;/span&gt; &lt;span&gt;(DataVO entry)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (CollUtil.isEmpty(entry.getDataList())){&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; ;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 请求条件&lt;/span&gt;&lt;br/&gt;        BulkRequest bulkUpdate = &lt;span&gt;new&lt;/span&gt; BulkRequest(entry.getIndexName(),entry.getType()) ;&lt;br/&gt;        bulkUpdate.setRefreshPolicy(entry.getRefresh()) ;&lt;br/&gt;        entry.getDataList().forEach(dataMap -&amp;gt; {&lt;br/&gt;            UpdateRequest updateReq = &lt;span&gt;new&lt;/span&gt; UpdateRequest() ;&lt;br/&gt;            updateReq.id(String.valueOf(dataMap.get(&lt;span&gt;&quot;id&quot;&lt;/span&gt;))) ;&lt;br/&gt;            updateReq.doc(dataMap) ;&lt;br/&gt;            bulkUpdate.add(updateReq) ;&lt;br/&gt;        });&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 执行请求&lt;/span&gt;&lt;br/&gt;            client.bulk(bulkUpdate, entry.getOptions());&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;索引主键查询，分组查询方法；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;QueryOperate&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RestHighLevelClient client ;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 指定字段分组查询&lt;br/&gt;     * &lt;span&gt;@since&lt;/span&gt; 2021-10-07 19:00&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String,Object&amp;gt; &lt;span&gt;groupByField&lt;/span&gt; &lt;span&gt;(QueryVO entry)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        Map&amp;lt;String,Object&amp;gt; groupMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;() ;&lt;br/&gt;        &lt;span&gt;// 分组API&lt;/span&gt;&lt;br/&gt;        String groupName = entry.getGroupField()+&lt;span&gt;&quot;_group&quot;&lt;/span&gt; ;&lt;br/&gt;        SearchSourceBuilder sourceBuilder = &lt;span&gt;new&lt;/span&gt; SearchSourceBuilder();&lt;br/&gt;        sourceBuilder.size(&lt;span&gt;0&lt;/span&gt;) ;&lt;br/&gt;        TermsAggregationBuilder termAgg = AggregationBuilders.terms(groupName)&lt;br/&gt;                                                             .field(entry.getGroupField()) ;&lt;br/&gt;        sourceBuilder.aggregation(termAgg);&lt;br/&gt;        &lt;span&gt;// 查询API&lt;/span&gt;&lt;br/&gt;        SearchRequest searchRequest = &lt;span&gt;new&lt;/span&gt; SearchRequest(entry.getIndexName());&lt;br/&gt;        searchRequest.source(sourceBuilder) ;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 执行API&lt;/span&gt;&lt;br/&gt;            SearchResponse response = client.search(searchRequest, entry.getOptions());&lt;br/&gt;            &lt;span&gt;// 响应结果&lt;/span&gt;&lt;br/&gt;            Terms groupTerm = response.getAggregations().get(groupName) ;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (CollUtil.isNotEmpty(groupTerm.getBuckets())){&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; (Terms.Bucket bucket:groupTerm.getBuckets()){&lt;br/&gt;                    groupMap.put(bucket.getKeyAsString(),bucket.getDocCount()) ;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; groupMap ;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;4、Logstash&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;Logstash是一款开源的数据采集组件，具有实时管道功能。Logstash能够动态的从多个来源采集数据，进行标准化转换数据，并将数据传输到所选择的存储容器。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4154676258992806&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBgfKyQH3qn7iaM7DCD4O8ZLP47ibbhtblDQhVqEWpOiciasd8C98JWfj3cpCg7j2Om2uKXHkjAxlLVxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1112&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Sleuth：管理服务链路，提供核心TraceId和SpanId生成；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ElasticSearch：基于ES引擎做日志聚合存储和查询；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Logstash：提供日志采集服务，和数据发送ES的能力；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;logback.xml&lt;/strong&gt;：服务连接Logstash地址，并加载核心配置；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;include&lt;/span&gt; &lt;span&gt;resource&lt;/span&gt;=&lt;span&gt;&quot;org/springframework/boot/logging/logback/defaults.xml&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;springProperty&lt;/span&gt; &lt;span&gt;scope&lt;/span&gt;=&lt;span&gt;&quot;context&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;APP_NAME&quot;&lt;/span&gt; &lt;span&gt;source&lt;/span&gt;=&lt;span&gt;&quot;spring.application.name&quot;&lt;/span&gt; &lt;span&gt;defaultValue&lt;/span&gt;=&lt;span&gt;&quot;butte_app&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;springProperty&lt;/span&gt; &lt;span&gt;scope&lt;/span&gt;=&lt;span&gt;&quot;context&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;DES_URI&quot;&lt;/span&gt; &lt;span&gt;source&lt;/span&gt;=&lt;span&gt;&quot;logstash.destination.uri&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;springProperty&lt;/span&gt; &lt;span&gt;scope&lt;/span&gt;=&lt;span&gt;&quot;context&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;DES_PORT&quot;&lt;/span&gt; &lt;span&gt;source&lt;/span&gt;=&lt;span&gt;&quot;logstash.destination.port&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;!-- 输出到LogStash配置，需要启动LogStash服务 --&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;appender&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;LogStash&quot;&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;destination&lt;/span&gt;&amp;gt;&lt;/span&gt;${DES_URI:- }:${DES_PORT:- }&lt;span&gt;&amp;lt;/&lt;span&gt;destination&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;encoder&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;providers&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;timestamp&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&amp;lt;&lt;span&gt;timeZone&lt;/span&gt;&amp;gt;&lt;/span&gt;UTC&lt;span&gt;&amp;lt;/&lt;span&gt;timeZone&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;/&lt;span&gt;timestamp&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&amp;lt;&lt;span&gt;pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                        {&lt;br/&gt;                        &quot;severity&quot;: &quot;%level&quot;,&lt;br/&gt;                        &quot;service&quot;: &quot;${APP_NAME:-}&quot;,&lt;br/&gt;                        &quot;trace&quot;: &quot;%X{X-B3-TraceId:-}&quot;,&lt;br/&gt;                        &quot;span&quot;: &quot;%X{X-B3-SpanId:-}&quot;,&lt;br/&gt;                        &quot;exportable&quot;: &quot;%X{X-Span-Export:-}&quot;,&lt;br/&gt;                        &quot;pid&quot;: &quot;${PID:-}&quot;,&lt;br/&gt;                        &quot;thread&quot;: &quot;%thread&quot;,&lt;br/&gt;                        &quot;class&quot;: &quot;%logger{40}&quot;,&lt;br/&gt;                        &quot;rest&quot;: &quot;%message&quot;&lt;br/&gt;                        }&lt;br/&gt;                    &lt;span&gt;&amp;lt;/&lt;span&gt;pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;/&lt;span&gt;pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;providers&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;encoder&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;appender&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5594405594405595&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBgfKyQH3qn7iaM7DCD4O8ZLsF50GYHvhlUBgWYMMdBq009zicwFpNzuMxJ4vntkVjUQMHstChxsrWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1144&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;5、Quartz&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;Quartz是一个完全由java编写的开源作业调度框架，用来执行各个服务中的定时调度任务，在微服务体系架构下，通常开发一个独立的Quartz服务，通过Feign接口去触发各个服务的任务执行。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;配置参数&lt;/strong&gt;：定时任务基础信息，数据库表，线程池；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;quartz:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;job-store-type:&lt;/span&gt; &lt;span&gt;jdbc&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;properties:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;org:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;quartz:&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;scheduler:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;instanceName:&lt;/span&gt; &lt;span&gt;ButteScheduler&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;instanceId:&lt;/span&gt; &lt;span&gt;AUTO&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;jobStore:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;class:&lt;/span&gt; &lt;span&gt;org.quartz.impl.jdbcjobstore.JobStoreTX&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;driverDelegateClass:&lt;/span&gt; &lt;span&gt;org.quartz.impl.jdbcjobstore.StdJDBCDelegate&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;tablePrefix:&lt;/span&gt; &lt;span&gt;qrtz_&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;isClustered:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;clusterCheckinInterval:&lt;/span&gt; &lt;span&gt;15000&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;useProperties:&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;threadPool:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;class:&lt;/span&gt; &lt;span&gt;org.quartz.simpl.SimpleThreadPool&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;threadPriority:&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;threadCount:&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;threadsInheritContextClassLoaderOfInitializingThread:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;6、Swagger&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;Swagger是常用的接口文档管理组件，通过对API接口和对象的简单注释，快速生成接口描述信息，并且提供可视化界面可以快速对接口发送请求和调试，该组件在前后端联调中，极大的提高效率。&lt;/p&gt;&lt;p&gt;配置基本的包扫描能力即可；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SwaggerConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Docket &lt;span&gt;createRestApi&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Docket(DocumentationType.SWAGGER_2)&lt;br/&gt;                .apiInfo(apiInfo())&lt;br/&gt;                .select()&lt;br/&gt;                .apis(RequestHandlerSelectors.basePackage(&lt;span&gt;&quot;com.butte&quot;&lt;/span&gt;))&lt;br/&gt;                .paths(PathSelectors.any())&lt;br/&gt;                .build();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;访问：&lt;code&gt;服务:端口/swagger-ui.html&lt;/code&gt;即可打开接口文档；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.39759036144578314&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBgfKyQH3qn7iaM7DCD4O8ZL38qKwqxM5A3g8VsrcjicRgsghUV30AMopslyreb11Eq8iaMSpNvaP98g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1162&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;六、数据库配置&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、MySQL&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;微服务架构下，不同的服务对应不同的MySQL库，基于业务模块做库的划分是当前常用的方式，可以对各自业务下的服务做迭代升级，同时可以避免单点故障导致雪崩效应。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.41605839416058393&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBgfKyQH3qn7iaM7DCD4O8ZLIKdnoDuqZYVRrINjpxWFibV2oaibsl1Qep1uVnlT69hKricvmGZ437oVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1096&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、HikariCP&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;HikariCP作为SpringBoot2版本推荐和默认采用的数据库连接池，具有速度极快、轻量简单的特点。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;datasource:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;type:&lt;/span&gt; &lt;span&gt;com.zaxxer.hikari.HikariDataSource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;driver-class-name:&lt;/span&gt; &lt;span&gt;com.mysql.cj.jdbc.Driver&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;url:&lt;/span&gt; &lt;span&gt;jdbc:mysql://127.0.0.1:3306/${data.name.mysql}?${spring.datasource.db-param}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;username:&lt;/span&gt; &lt;span&gt;root&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;password:&lt;/span&gt; &lt;span&gt;123456&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;db-param:&lt;/span&gt; &lt;span&gt;useUnicode=true&amp;amp;characterEncoding=UTF8&amp;amp;zeroDateTimeBehavior=convertToNull&amp;amp;useSSL=false&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;hikari:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;minimumIdle:&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;maximumPoolSize:&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;idleTimeout:&lt;/span&gt; &lt;span&gt;300000&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;maxLifetime:&lt;/span&gt; &lt;span&gt;500000&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;connectionTimeout:&lt;/span&gt; &lt;span&gt;30000&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;连接池的配置根据业务的并发需求量，做适当的调优即可。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、Mybatis&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;Mybatis持久层的框架组件，支持定制化SQL、存储过程以及高级映射，MyBatis-Plus是一个MyBatis的增强工具，在MyBatis的基础上只做增强不做改变，可以简化开发、提高效率。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;mybatis-plus:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;mapper-locations:&lt;/span&gt; &lt;span&gt;classpath*:/mapper/**/*.xml&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;configuration:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;log-impl:&lt;/span&gt; &lt;span&gt;org.apache.ibatis.logging.stdout.StdOutImpl&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;&lt;span&gt;七、源代码地址&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;应用仓库：&lt;br/&gt;https://gitee.com/cicadasmile/butte-flyer-parent&lt;br/&gt;&lt;br/&gt;组件封装：&lt;br/&gt;https://gitee.com/cicadasmile/butte-frame-parent&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBCuF3zfJnqPKpUia4wfn1FUtTHpxxkR5HvbicPgOjibPicX0goMOkny1NdkLAJvBaqrYh3UdwMjiaDQMA/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累是一个孤独且枯燥的过程&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>86057c8f66f1097d15bb4c7542c14f89</guid>
<title>记一次提升 18 倍的性能优化</title>
<link>https://toutiao.io/k/4m3cbld</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;背景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近负责的一个自研的 Dubbo 注册中心经常收到 CPU 使用率的告警，于是进行了一波优化，效果还不错，于是打算分享下思考、优化过程，希望对大家有一些帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自研 Dubbo 注册中心是个什么东西，我画个简图大家稍微感受一下就好，看不懂也没关系，不影响后续的理解。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7168674698795181&quot; data-type=&quot;png&quot; data-w=&quot;996&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0QgpiaicmhQxRaYqQKBF1WHRwicDhHxz2nWUDaW0gXXwRHwpZCWqia8aR2eNOickuMUiaPG12EqlQxNoD8g/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Consumer 和 Provider 的服务发现请求（注册、注销、订阅）都发给 Agent，由它全权代理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Registry 和 Agent 保持 Grpc 长链接，长链接的目的主要是 Provider 方有变更时，能及时推送给相应的 Consumer。为了保证数据的正确性，做了推拉结合的机制，Agent 会每隔一段时间去 Registry 拉取订阅的服务列表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Agent 和业务服务部署在同一台机器上，类似 Service Mesh 的思路，尽量减少对业务的入侵，这样就能快速的迭代了&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到今天的重点，这个注册中心最近 CPU 使用率长期处于中高水位，偶尔有应用发布，推送量大时，CPU 甚至会被打满。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以前没感觉到，是因为接入的应用不多，最近几个月应用越接越多，慢慢就达到了告警阈值。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;寻找优化点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于这项目是 Go 写的（不懂 Go 的朋友也没关系，本文重点在算法的优化，不在工具的使用上）， 找到哪里耗 CPU 还是挺简单的：打开 pprof 即可，去线上采集一段时间即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体怎么操作可以参考我之前的&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI5NjE2MDQwNg==&amp;amp;mid=2247484717&amp;amp;idx=1&amp;amp;sn=79b15577f555896eedbdc705e9fb2c61&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;这篇文章&lt;/a&gt;，今天文章中用到的知识和工具，这篇文章都能找到。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32934553131597466&quot; data-type=&quot;png&quot; data-w=&quot;2842&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0QgpiaicmhQxRaYqQKBF1WHRwzxU0CiamIgXBSCHLQmN9xffbcBpVbmaiaHDVOHKc0fRZqan9Cn1LlbtA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU profile 截了部分图，其他的不太重要，可以看到消耗 CPU 多的是 &lt;code&gt;AssembleCategoryProviders&lt;/code&gt;方法，与其直接关联的是&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;2个 redis 相关的方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;1个叫&lt;code&gt;assembleUrlWeight&lt;/code&gt;的方法&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稍微解释下，AssembleCategoryProviders 方法是构造返回 Dubbo provider 的 url，由于会在返回 url 时对其做一些处理（比如调整权重等），会涉及到对这个 Dubbo url 的解析。又由于推拉结合的模式，线上服务使用方越多，这个处理的 QPS 就越大，所以它占用了大部分 CPU 一点也不奇怪。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个 redis 操作可能是序列化占用了 CPU，更大头在 assembleUrlWeight，有点琢磨不透。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们就分析下 assembleUrlWeight 如何优化，因为他占用 CPU 最多，优化效果肯定最好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是 assembleUrlWeight 的伪代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;AssembleUrlWeight&lt;/span&gt;&lt;span&gt;(rawurl &lt;span&gt;string&lt;/span&gt;, lidcWeight &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; u, err := url.Parse(rawurl)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; rawurl&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; values, err := url.ParseQuery(u.RawQuery)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; rawurl&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; values.Get(&lt;span&gt;&quot;lidc_weight&quot;&lt;/span&gt;) != &lt;span&gt;&quot;&quot;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; rawurl&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; endpointWeight := &lt;span&gt;100&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; values.Get(&lt;span&gt;&quot;weight&quot;&lt;/span&gt;) != &lt;span&gt;&quot;&quot;&lt;/span&gt; {&lt;br/&gt;  endpointWeight, err = strconv.Atoi(values.Get(&lt;span&gt;&quot;weight&quot;&lt;/span&gt;))&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   endpointWeight = &lt;span&gt;100&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; values.Set(&lt;span&gt;&quot;weight&quot;&lt;/span&gt;, strconv.Itoa(lidcWeight*endpointWeight))&lt;br/&gt;&lt;br/&gt; u.RawQuery = values.Encode()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; u.String()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传参 rawurl 是 Dubbo provider 的url，lidcWeight 是机房权重。根据配置的机房权重，将 url 中的 weight 进行重新计算，实现多机房流量按权重的分配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个过程涉及到 url 参数的解析，再进行 weight 的计算，最后再还原为一个 url&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Dubbo 的 url 结构和普通 url 结构一致，其特点是参数可能比较多，没有 &lt;code&gt;#&lt;/code&gt;后面的片段部分。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3757183908045977&quot; data-type=&quot;png&quot; data-w=&quot;2784&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0QgpiaicmhQxRaYqQKBF1WHRwh63ghoibeQnVWiaKiaibpwNPXohpaOLrFfYV6SzObZkCuaeR9DricByLhDQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU 主要就消耗在这两次解析和最后的还原中，我们看这两次解析的目的就是为了拿到 url 中的 &lt;code&gt;lidc_weight&lt;/code&gt; 和 &lt;code&gt;weight&lt;/code&gt; 参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;url.Parse 和 url.ParseQuery 都是 Go 官方提供的库，各个语言也都有实现，其核心是解析 url 为一个对象，方便地获取 url 的各个部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果了解信息熵这个概念，其实你就大概知道这里面一定是可以优化的。&lt;code&gt;Shannon（香农）&lt;/code&gt; 借鉴了热力学的概念，把信息中排除了冗余后的平均信息量称为&lt;code&gt;信息熵&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7171875&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/xacdaKuBM0QgpiaicmhQxRaYqQKBF1WHRwWoFWXTeOVujGjv6N0EicGodM046BqFibiaNJpT476Rxhgq6QLkxHA1lQA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;url.Parse 和 url.ParseQuery 在这个场景下解析肯定存在冗余，冗余意味着 CPU 在做多余的事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为一个 Dubbo url 参数通常是很多的，我们只需要拿这两个参数，而 url.Parse 解析了所有的参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，给定一个数组，求其中的最大值，如果先对数组进行排序，再取最大值显然是存在冗余操作的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;排序后的数组不仅能取最大值，还能取第二大值、第三大值...最小值，信息存在冗余了，所以先排序肯定不是求最大值的最优解。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;优化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;优化获取 url 参数性能&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一想法是，不要解析全部 url，只拿相应的参数，这就很像我们写的算法题，比如获取 weight 参数，它只可能是这两种情况（不存在 #，所以简单很多）：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;dubbo://127.0.0.1:20880/org.newboo.basic.MyDemoService?weight=100&amp;amp;...&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;dubbo://127.0.0.1:20880/org.newboo.basic.MyDemoService?xx=yy&amp;amp;weight=100&amp;amp;...&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要么是 &lt;code&gt;&amp;amp;weight=&lt;/code&gt;，要么是 &lt;code&gt;?weight=&lt;/code&gt;，结束要么是&lt;code&gt;&amp;amp;&lt;/code&gt;，要么直接到字符串尾，代码就很好写了，先手写个解析参数的算法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;GetUrlQueryParam&lt;/span&gt;&lt;span&gt;(u &lt;span&gt;string&lt;/span&gt;, key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;string&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; sb := strings.Builder{}&lt;br/&gt; sb.WriteString(key)&lt;br/&gt; sb.WriteString(&lt;span&gt;&quot;=&quot;&lt;/span&gt;)&lt;br/&gt; index := strings.Index(u, sb.String())&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (index == &lt;span&gt;-1&lt;/span&gt;) || (index+&lt;span&gt;len&lt;/span&gt;(key)+&lt;span&gt;1&lt;/span&gt; &amp;gt; &lt;span&gt;len&lt;/span&gt;(u)) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;, UrlParamNotExist&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; value = strings.Builder{}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := index + &lt;span&gt;len&lt;/span&gt;(key) + &lt;span&gt;1&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(u); i++ {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; i+&lt;span&gt;1&lt;/span&gt; &amp;gt; &lt;span&gt;len&lt;/span&gt;(u) {&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; u[i:i+&lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;&quot;&amp;amp;&quot;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  value.WriteString(u[i : i+&lt;span&gt;1&lt;/span&gt;])&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; value.String(), &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原先获取参数的方法可以摘出来：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;getParamByUrlParse&lt;/span&gt;&lt;span&gt;(ur &lt;span&gt;string&lt;/span&gt;, key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; u, err := url.Parse(ur)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; values, err := url.ParseQuery(u.RawQuery)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; values.Get(key)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先对这两个函数进行 benchmark：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkGetQueryParam&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  getParamByUrlParse(u, &lt;span&gt;&quot;anyhost&quot;&lt;/span&gt;)&lt;br/&gt;  getParamByUrlParse(u, &lt;span&gt;&quot;version&quot;&lt;/span&gt;)&lt;br/&gt;  getParamByUrlParse(u, &lt;span&gt;&quot;not_exist&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkGetQueryParamNew&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  GetUrlQueryParam(u, &lt;span&gt;&quot;anyhost&quot;&lt;/span&gt;)&lt;br/&gt;  GetUrlQueryParam(u, &lt;span&gt;&quot;version&quot;&lt;/span&gt;)&lt;br/&gt;  GetUrlQueryParam(u, &lt;span&gt;&quot;not_exist&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Benchmark 结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BenchmarkGetQueryParam-4          103412              9708 ns/op&lt;br/&gt;BenchmarkGetQueryParam-4          111794              9685 ns/op&lt;br/&gt;BenchmarkGetQueryParam-4          115699              9818 ns/op&lt;br/&gt;BenchmarkGetQueryParamNew-4      2961254               409 ns/op&lt;br/&gt;BenchmarkGetQueryParamNew-4      2944274               406 ns/op&lt;br/&gt;BenchmarkGetQueryParamNew-4      2895690               405 ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到性能大概提升了20多倍&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新写的这个方法，有两个小细节，第一是返回值中区分了参数是否存在，这个后面会用到；第二是字符串的操作用到了 &lt;code&gt;strings.Builder&lt;/code&gt;，这也是实际测试的结果，使用 &lt;code&gt;+&lt;/code&gt;或者 &lt;code&gt;fmt.Springf&lt;/code&gt; 性能都没这个好，感兴趣可以测试下看看。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;优化 url 写入参数性能&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算出 weight 后再把 weight 写入 url 中，这里直接给出优化后的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;AssembleUrlWeightNew&lt;/span&gt;&lt;span&gt;(rawurl &lt;span&gt;string&lt;/span&gt;, lidcWeight &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; lidcWeight == &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; rawurl&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; lidcWeightStr, err1 := GetUrlQueryParam(rawurl, &lt;span&gt;&quot;lidc_weight&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err1 == &lt;span&gt;nil&lt;/span&gt; &amp;amp;&amp;amp; lidcWeightStr != &lt;span&gt;&quot;&quot;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; rawurl&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; err error&lt;br/&gt; endpointWeight := &lt;span&gt;100&lt;/span&gt;&lt;br/&gt; weightStr, err2 := GetUrlQueryParam(rawurl, &lt;span&gt;&quot;weight&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; weightStr != &lt;span&gt;&quot;&quot;&lt;/span&gt; {&lt;br/&gt;  endpointWeight, err = strconv.Atoi(weightStr)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   endpointWeight = &lt;span&gt;100&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err2 != &lt;span&gt;nil&lt;/span&gt; { &lt;span&gt;// url中不存在weight&lt;/span&gt;&lt;br/&gt;  finUrl := strings.Builder{}&lt;br/&gt;  finUrl.WriteString(rawurl)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; strings.Contains(rawurl, &lt;span&gt;&quot;?&quot;&lt;/span&gt;) {&lt;br/&gt;   finUrl.WriteString(&lt;span&gt;&quot;&amp;amp;weight=&quot;&lt;/span&gt;)&lt;br/&gt;   finUrl.WriteString(strconv.Itoa(lidcWeight * endpointWeight))&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; finUrl.String()&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   finUrl.WriteString(&lt;span&gt;&quot;?weight=&quot;&lt;/span&gt;)&lt;br/&gt;   finUrl.WriteString(strconv.Itoa(lidcWeight * endpointWeight))&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; finUrl.String()&lt;br/&gt;  }&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;// url中存在weight&lt;/span&gt;&lt;br/&gt;  oldWeightStr := strings.Builder{}&lt;br/&gt;  oldWeightStr.WriteString(&lt;span&gt;&quot;weight=&quot;&lt;/span&gt;)&lt;br/&gt;  oldWeightStr.WriteString(weightStr)&lt;br/&gt;&lt;br/&gt;  newWeightStr := strings.Builder{}&lt;br/&gt;  newWeightStr.WriteString(&lt;span&gt;&quot;weight=&quot;&lt;/span&gt;)&lt;br/&gt;  newWeightStr.WriteString(strconv.Itoa(lidcWeight * endpointWeight))&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; strings.ReplaceAll(rawurl, oldWeightStr.String(), newWeightStr.String())&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要就是分为 url 中是否存在 weight 两种情况来讨论：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;url 本身不存在 weight 参数，则直接在 url 后拼接一个 weight 参数，当然要注意是否存在 &lt;code&gt;?&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;url 本身存在 weight 参数，则直接进行字符串替换&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;细心的你肯定又发现了，当 &lt;code&gt;lidcWeight = 1&lt;/code&gt; 时，直接返回，因为 &lt;code&gt;lidcWeight = 1&lt;/code&gt; 时，后面的计算其实都不起作用（Dubbo 权重默认为100），索性别操作，省点 CPU。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全部优化完，总体做一下 benchmark：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkAssembleUrlWeight&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; _, ut := &lt;span&gt;range&lt;/span&gt; []&lt;span&gt;string&lt;/span&gt;{u, u1, u2, u3} {&lt;br/&gt;   AssembleUrlWeight(ut, &lt;span&gt;60&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkAssembleUrlWeightNew&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; _, ut := &lt;span&gt;range&lt;/span&gt; []&lt;span&gt;string&lt;/span&gt;{u, u1, u2, u3} {&lt;br/&gt;   AssembleUrlWeightNew(ut, &lt;span&gt;60&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BenchmarkAssembleUrlWeight-4               34275             33289 ns/op&lt;br/&gt;BenchmarkAssembleUrlWeight-4               36646             32432 ns/op&lt;br/&gt;BenchmarkAssembleUrlWeight-4               36702             32740 ns/op&lt;br/&gt;BenchmarkAssembleUrlWeightNew-4           573684              1851 ns/op&lt;br/&gt;BenchmarkAssembleUrlWeightNew-4           646952              1832 ns/op&lt;br/&gt;BenchmarkAssembleUrlWeightNew-4           563392              1896 ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大概提升 18 倍性能，而且这可能还是比较差的情况，如果传入 lidcWeight = 1，效果更好。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;效果&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优化完，对改动方法写了相应的单元测试，确认没问题后，上线进行观察，CPU Idle（空闲率） 提升了10%以上&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4010462074978204&quot; data-type=&quot;png&quot; data-w=&quot;2294&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0QgpiaicmhQxRaYqQKBF1WHRwzoiah70K1suL53yME4CMCBAllBMOEIWCvkjsh7eoPfXOfZuU1RcickdA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实本文展示的是一个 Go 程序非常常规的性能优化，也是相对来说比较简单，看完后，大家可能还有疑问：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为什么要在推送和拉取的时候去解析 url 呢？不能事先算好存起来吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么只优化了这点，其他的点是否也可以优化呢？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对第一个问题，其实这是个历史问题，当你接手系统时他就是这样，如果程序出问题，你去改整个机制，可能周期比较长，而且容易出问题&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.899505766062603&quot; data-type=&quot;png&quot; data-w=&quot;607&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0QgpiaicmhQxRaYqQKBF1WHRwVzynLxUgaqUIaEqCbKmst6Lsicjkhpfs6muLLLtOjcvLFiaxQ4g3BBKA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个问题，其实刚也顺带回答了，这样优化，改动最小，收益最大，别的点没这么好改，短期来说，拿收益最重要。当然我们后续也打算对这个系统进行重构，但重构之前，这样优化，足以解决问题。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;搜索关注微信公众号&quot;捉虫大师&quot;，后端技术分享，架构设计、性能优化、源码阅读、问题排查、踩坑实践。也欢迎加我个人微信&lt;code&gt;MrRoshi&lt;/code&gt;，围观朋友圈。&lt;/p&gt;&lt;/blockquote&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>90c1875bc766ae847d4b1e9734f37ac1</guid>
<title>TypeScript 枚举指南</title>
<link>https://toutiao.io/k/igslp5z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;p/&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-01d5f70c6b2a607aca37ef1e22cb34b7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;512&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-01d5f70c6b2a607aca37ef1e22cb34b7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;512&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-01d5f70c6b2a607aca37ef1e22cb34b7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-01d5f70c6b2a607aca37ef1e22cb34b7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;9_T75Xhi&quot;&gt;枚举是受 TypeScript 支持的数据类型。枚举允许您定义一组命名常量。使用它们可以更轻松地记录意图或创建一组不同的案例。枚举大多数用于面向对象的编程语言（如 Java 和 C#）中，现在也可以 TypeScript 中使用。它们是 TypeScript 的少数功能之一，它不是 JavaScript 的类型级扩展。接下来我将要演示 TypeScript 枚举的基础知识以及用例，各种枚举类型和学习的后续步骤。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;TypeScript 中的枚举是什么&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;WmLWirgv&quot;&gt;许多编程语言（例如 C，C#和 Java）都具有enum数据类型，而 JavaScript 没有。但是 TypeScript 可以，TypeScript 具有基于数字和基于字符串的枚举。TypeScript 枚举允许开发人员定义一组命名常量。使用它们可以更轻松地记录意图或创建一组不同的案例。&lt;/p&gt;&lt;p data-pid=&quot;_f7JRRvv&quot;&gt;枚举的语法如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;enum States {
    Apple,
    Orange，
    Banana，
    Watermelon
}
// 使用
var fruit = States.Watermelon;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;在 TypeScript 中使用枚举需要注意什么&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;_vBaQOn0&quot;&gt;首先枚举中的值是常量，即枚举是类型安全的，在重新分配值时会返回编译错误。其次枚举应该是有限的，有助于用户创建一个自定义的常量系统。枚举在被编译后是一个对象：在 JavaScript 中创建内存有效的自定义常量，使用灵活易于表达记录意图方便作为判断用例。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;enum requestStatus {
    success = 200
    error = 400
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;let requestStatus;
(function (requestStatus) {
    requestStatus[requestStatus[&quot;success&quot;] = 200] = &quot;success&quot;
    requestStatus[requestStatus[&quot;error&quot;] = 400] = &quot;error&quot;
})(requestStatus || (requestStatus = {}));

// requestStatus:
// { &#x27;200&#x27;: &#x27;success&#x27;, &#x27;400&#x27;: &#x27;error&#x27;, error: 400, success: 200 }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;常见枚举的类型&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;Oq5YcwWn&quot;&gt;&lt;b&gt;数值枚举&lt;/b&gt;和&lt;b&gt;字符串枚举&lt;/b&gt;是我们在 TypeScript 中最常用的枚举类型，下面我将用例子向你们介绍它们的特点以及如何使用它们。&lt;/p&gt;&lt;p data-pid=&quot;quxXZSER&quot;&gt;&lt;b&gt;数字枚举&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;ppO0Z2M-&quot;&gt;数字枚举&lt;b&gt;以字符串存储数字值。&lt;/b&gt;让我们使用 enum 关键字定义它们。下面我将用存储一组不同类型汽车的示例展示 TypeScript 中的数字枚举：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;enum CarType {
    Honda,
    Toyota,
    Subaru,
    Hyundai
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;RNEHZc63&quot;&gt;枚举值 CarType 有四个值：本田，丰田，斯巴鲁和现代。枚举值从 0 开始，并且每个成员的值递增 1 ，如下所示：&lt;/p&gt;&lt;p data-pid=&quot;T29GcpQN&quot;&gt;Honda = 0&lt;/p&gt;&lt;p data-pid=&quot;HjFGsMUF&quot;&gt;Toyota = 1&lt;/p&gt;&lt;p data-pid=&quot;PSQiX9ca&quot;&gt;Subaru = 2&lt;/p&gt;&lt;p data-pid=&quot;dyOkmXsF&quot;&gt;Hyundai = 3&lt;/p&gt;&lt;p data-pid=&quot;c_qAi7L-&quot;&gt;如果需要你可以自己初始化第一个数值，如下所示：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;enum CarType {
    Honda = 1,
    Toyota,
    Subaru,
    Hyundai
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;_D6SgiDf&quot;&gt;在上面的示例中，Honda 使用数值 1 初始化了第一个成员。剩余的数字将加一。&lt;/p&gt;&lt;p data-pid=&quot;vhGp9cD6&quot;&gt;你可能会想，如果我更改最后一个值，之前的值会根据最后定义的数值递减吗？让我们来试试：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;enum CarType {
    Honda,
    Toyota,
    Subaru,
    Hyundai = 100
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;CvFgo3y9&quot;&gt;遗憾的是这是行不通的，当前例子的数值是：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;enum CarType {
    Honda,  // 1
    Toyota, // 2
    Subaru, // 3
    Hyundai // 100
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;OLAyJEi6&quot;&gt;注意：不必为枚举成员分配顺序值。你可以为其分配任何所需的值&lt;/p&gt;&lt;p data-pid=&quot;J7384xQn&quot;&gt;&lt;b&gt;字符串枚举&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;nuZTmC0b&quot;&gt;字符串枚举类似于数字枚举，但是它们的&lt;b&gt;枚举值是使用字符串值而不是数字值初始化的。&lt;/b&gt;字符串枚举比数字枚举具有&lt;b&gt;更好的可读性&lt;/b&gt;，从而更容易调试程序。&lt;/p&gt;&lt;p data-pid=&quot;wYUKxvRf&quot;&gt;以下示例使用与数值枚举示例相同的信息，但以字符串枚举表示：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;enum CarType {
    Honda = &quot;HONDA&quot;,
    Toyota = &quot;TOYOTA&quot;,
    Subaru = &quot;SUBARU&quot;,
    Hyundai = &quot;HYUNDAI&quot;
}

// 访问字符串枚举
CarType.Toyota; //return TOYOTA&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;2DjNs3UB&quot;&gt;注意：字符串枚举值需要单独初始化。&lt;/p&gt;&lt;p data-pid=&quot;McRE9P03&quot;&gt;&lt;b&gt;枚举反向映射&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;U8Q9AnJ2&quot;&gt;枚举可以使用其相对应的枚举成员值检索 num 值。使用反向映射，可以访问成员值和成员值的名称，请看下面的例子：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;enum CarType {
    Honda = 1,
    Toyota,
    Subaru,
    Hyundai
}
CarType.Subaru; //return 3
CarType.[&quot;Subaru&quot;]; //return 3
CarType[3]; //return Subaru&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;VwpkY_or&quot;&gt;CarType[3] 由于反向映射，返回其成员名称“ Subaru”。让我们看另一个例子：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;enum CarType {
    Honda = 1,
    Toyota,
    Subaru,
    Hyundai
}
console.log(CarType)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;dFr--HYu&quot;&gt;在浏览器的控制台中将看到以下输出：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;{ 
    &#x27;1&#x27;：&#x27;Honda&#x27;，
    &#x27;2&#x27;：&#x27;Toyota&#x27;，
    &#x27;3&#x27;：&#x27;Subaru&#x27;，
    &#x27;4&#x27;：&#x27;Hyundai&#x27;，
    Honda：1，
    Toyota：2，
    Subaru：3，
    Hyundai：4 
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;biJx0b0o&quot;&gt;枚举的每个值在内部存储的枚举对象中出现两次。&lt;/p&gt;&lt;p data-pid=&quot;ykAEMvd8&quot;&gt;&lt;b&gt;计算枚举&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;_znZm4Mm&quot;&gt;枚举成员的值可以是常量值或计算值。请看下面的示例：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;enum CarType {
    Honda = 1,
    Toyota = getCarTypeCode(&#x27;toyota&#x27;),
    Subaru = Toyota * 3,
    Hyundai = 10
}

function getCarTypeCode(carName: string): number {
    if (carName === &#x27;toyota&#x27;) {
        return 5;
    }
}

CarType.Toyota; // returns 5
CarType.Subaru; // returns 15&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;-J0I7ccN&quot;&gt;如果枚举既包含计算成员又包含常量成员，则未初始化的枚举成员将首先出现，也可能在其他带有数字常量的初始化成员之后。下一个示例将显示错误：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;enum CarType {
    Toyota = getCarTypeCode(&#x27;toyota&#x27;),
    Honda, // Error: Enum member must have initializer
    Subaru,
    Hyundai = Toyota * 3,
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;ZUEzCCJq&quot;&gt;你可以这样声明上述枚举：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;enum CarType {
    Honda,
    Hyundai,
    Toyota = getCarTypeCode(&#x27;toyota&#x27;),
    Subaru = Toyota * 3&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;ZZfyB9dj&quot;&gt;以上就是本文的全部内容，通过讲解什么是枚举，我们在使用枚举的时候应该注意什么。到我们常用的枚举类型（数值枚举，字符串枚举），枚举反向映射，计算枚举。相信你对枚举已经有了一定的了解，如果文章有什么没有讲明白的或是有什么错误的地方欢迎指正，感激不尽。&lt;/p&gt;&lt;p data-pid=&quot;Vt1spzWo&quot;&gt;&lt;b&gt;推荐阅读：&lt;/b&gt;&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/668/%25E4%25BA%25BF%25E7%25BA%25A7%25E6%25B5%2581%25E9%2587%258F%25E7%25B3%25BB%25E7%25BB%259F%25E6%259E%25B6%25E6%259E%2584%25E6%25BC%2594%25E8%25BF%259B%25E4%25B9%258B%25E8%25B7%25AF.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic1.zhimg.com/v2-e106515130f484c08c6e14bb762d074c_180x120.jpg&quot; data-image-width=&quot;1092&quot; data-image-height=&quot;687&quot; data-text=&quot;亿级流量系统架构演进之路&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/650/%25E7%25A7%2581%25E6%259C%2589%25E5%258C%2596%25E4%25BB%2593%25E5%25BA%2593%25E7%259A%2584%2520GO%2520%25E6%25A8%25A1%25E5%259D%2597%25E4%25BD%25BF%25E7%2594%25A8%25E5%25AE%259E%25E8%25B7%25B5.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic4.zhimg.com/v2-2b8c596b85073408346e12f2225395d7_180x120.jpg&quot; data-image-width=&quot;922&quot; data-image-height=&quot;273&quot; data-text=&quot;私有化仓库的 GO 模块使用实践&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f0435d669e21466c7ffcaba0b65a6942</guid>
<title>Math.abs 竟然返回了负数？？</title>
<link>https://toutiao.io/k/vhxhvjx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事情是这样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某一天扯扯群里发来一段代码：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3142597638510445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFWTFrjic5hv3VXiaicOsVnCJKcw5r02wqMZYxjVJjuicSrywcDv6Ock6aU3jHM2vVibusZ2lPoOsGBEiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1101&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读者提问道，为啥这个 pos 还要判断一下？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这代码一看我就熟悉，RocketMQ 的源码，如果你看过源码你会发现到处都有这样的判断。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想着已经取绝对值了，然后再取余，肯定是正数啊，这 &lt;code&gt;if(pos&amp;lt;0)&lt;/code&gt; 不就是多余的判断吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们先看一下 &lt;code&gt;Math.abs&lt;/code&gt; 的源码:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2701863354037267&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFWTFrjic5hv3VXiaicOsVnCJKoBpjJ3wRMcgwBia3icqNDj98zIOaCjiaofGotO0btFzLqF4C8s1LRrLkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;322&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，十分简单粗暴，再结合一下 int ，不知道大家是否已经发现了问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不卖关子了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;int 的最大值是(2^31) -1，而最小值是-2^31，所以按照 abs 的逻辑，如果a是最小值，则最小值前面加个负数就变成了 2^31，而 int 所能表示的最大值是 (2^31) -1，这比最大值还大了个 1，导致向上溢出，所以此时得到的结果还是最小值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3813559322033898&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFWTFrjic5hv3VXiaicOsVnCJKaFErFrUtvDibH2U0QWo754t5M6X179UQpo5IiaaC1IxddTTkurkgt5og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;472&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以试着运行一下上面的结果，所以说 Math.abs 得到的不一定是正数！所以 RocketMQ 的这个判断是有必要滴。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;再解释一下为什么 int 最小值取绝对值还是等于它本身。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;int 是 32 位，为了便于演示，我就拿 8 位来举例子，反正道理是一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Java 中的数字的实现都是有符号位的，不像 C 有个 unsigned 来表示无符号，有符号的数字实现是用最高位来表示符号位，1表示负数，0表示正数。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3828032979976443&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFWTFrjic5hv3VXiaicOsVnCJKYfeWaiaGM5CnKEhGf5Fbib6Xj0coYFOwLdjpVPibpGqOIicoKKEB8Vbr4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;849&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到上面的例子，要表示的正数比最大值还大1，那就把最大值加个1呗。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.44237485448195574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFWTFrjic5hv3VXiaicOsVnCJKib7kv0U9EvoJaM2zWRMhoOamxkr9W2sFoc7a3PDZJib60XmFcQltvBRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;859&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图中就是向上溢出得到了最小值，所以最小值取绝对值得到的值比最大值大一，导致向上溢出，又变成了最小值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此 &lt;code&gt;Math.abs(Integer.MIN_VALUE) = Integer.MIN_VALUE&lt;/code&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那为什么 8 位表示的是-128到127而不是-127到128?&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;8位二进制，一共有&lt;code&gt;2^8=256&lt;/code&gt;个坑位，所以能表示 256 个数字，理论上随便怎么表示都ok，你表示-254~1都行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是我们规定无符号数是 0~255，有符号数规定是-128 ~ 127。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有符号数要规定成-127到128并不是不行，但是这样就比较麻烦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照-128 ~ 127这样的实现，&lt;span&gt;我们只要通过最高位就可以判断一个数的正负&lt;/span&gt;，而-127~128就需要排除128这个特例，也就是之前只需要判断最高位，现在变成需要判断最高位为 1 且其它位不全是 0 才是负数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样电路设计也要变复杂了，所以我们规定是 -128到127，32位也同理。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Math.absExact&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种出错了但是没有提示的 Math.abs 肯定是不好的，所以在 JDK 15 出了个  &lt;code&gt;Math.absExact&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4750830564784053&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFWTFrjic5hv3VXiaicOsVnCJKarKZpJ7hXOEaDkXVVB9icU09FaX1zbe2vbHE5ylHtiaPJqkOnCOxCRkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1204&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是会抛错，而不是返回个错误的结果。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有位群友还说面百度的时候被问过。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5460526315789473&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFWTFrjic5hv3VXiaicOsVnCJKyRWPiac5SI7YicZCqSibEfr2Bobusv8FiaPHicAXqntVnmlwrrdB4o2GiaCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;304&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试题是真的多，防不胜防，所以要抓清源头和本质，以不变应万变。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，今天的分享到此结束，&lt;span&gt;如果觉得文章不错。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;来个点赞、在看、分享三连哟！&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是 yes，从一点点到亿点点，我们下篇见。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;：&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkxNTE3NjQ3MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEf5LN3Y4UErfNUkiaMseJPkdXA4xPD6Uicl8EqAJAEKVIKalU19xS41TO3aPmHK5bqbzGTwu3z92Kg/0?wx_fmt=png&quot; data-nickname=&quot;yes的练级攻略&quot; data-alias=&quot;yes_java&quot; data-signature=&quot;用接地气的话来分享一些后端技术或写一些想写的。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>