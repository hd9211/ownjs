<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1966d65802fa6daa9995219e3b80bb7a</guid>
<title>用户画像从 0 到 100 的构建思路</title>
<link>https://toutiao.io/k/wbatwrb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NjIyNjQwMg==&amp;amp;mid=2247501049&amp;amp;idx=1&amp;amp;sn=8dbb36f03b5f834de296a79cd90560ec&amp;amp;chksm=cf37f6f4f8407fe23c245da101d4cfcc5c1bc28cc872d40d2f0730265d32b1e1b551f287b02c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1OYP1AZw0W2IMiaCFatibtuvqoxGBjcqpr0BNGHYEmJYOXRMzyBNQKcib2OK7tCOOgbEZiaRZqDh1oxg5eWYPHT4DA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在介绍画像构建时，我们把工作分为两步。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一步：介绍从0到1的构建思路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二步：介绍从1到100的构建思路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NjIyNjQwMg==&amp;amp;mid=2247501043&amp;amp;idx=1&amp;amp;sn=47e0059494d2aea0f248abcdf038db9a&amp;amp;chksm=cf37f6fef8407fe86e0749cb9e869cc5ecf6345401c20e35a2e8824ce3aafa24f4a7550dc188&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qrlXAFW0OmHM11P9UO6zVMDV0quS7bCu6d27BDEy7WA8DntdpibIw1rLmNIicKBVJicJ6GkccT8I5TQGNQ7CfuMxA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;38806&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;38806&quot;&gt;&lt;section hm_fix=&quot;247:418&quot;&gt;&lt;section data-bcless=&quot;darken&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;用户画像从0到1的构建思路&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;一个比较成熟的画像系统会有成百上千的&lt;/span&gt;&lt;span&gt;&lt;strong&gt;标签&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，这些标签的生产不是一次完成的，而是随着业务的发展需要，逐步补充完善，最终呈现在大家眼前的就是一棵庞大的标签树。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;跟自然界的树木一样，标签树要想长得茁壮参天，也必须有一个稳定的根基和合理的结构。在用户画像的构建前期，最重要的是搭好&lt;/span&gt;&lt;span&gt;&lt;strong&gt;画像骨架&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，确保后续的发展过程中，依然保持清晰的结构和高延展性。相反，如果一开始为了抢时间，将大量标签无序地堆在线上，后期管理和使用的难度会迅速凸显出来，重构的代价巨大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面说到，一个好的标签树结构要满足两个条件：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;高概括性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;&lt;strong&gt;强延展性&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。高概括性意味着结构体系能够很好地包含一个用户的基本属性和产品交互的相关行为，同时对于业务重点单独强调，没有遗漏；强延展性意味着结构全面的同时也有一定的抽象概括能力，保证新增的标签可以很好地找到对应的分类，整个体系不会过于收敛局限。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;按照这个原则，画像通常从8个维度组织标签，分别为&lt;/span&gt;&lt;span&gt;&lt;strong&gt;基本属性&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;&lt;strong&gt;平台属性&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;&lt;strong&gt;行为属&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;&lt;strong&gt;产品偏好&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;&lt;strong&gt;兴趣偏好&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;&lt;strong&gt;敏感度&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;&lt;strong&gt;消费属性&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;strong&gt;&lt;span&gt;用户生命周期及用户价值&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图11-2所示为用户画像整体架构示例，下面来具体介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.3808777429467085&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qrlXAFW0OmHM11P9UO6zVMDV0quS7bCuibiaQBY9frv2SeC6xxmcOvicVDxhgMTWYJiaCWvKvcOuRY294F3S5Ckyag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;638&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;99660&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot;&gt;1&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;327:354&quot;&gt;基本属性&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;38%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;基本属性&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;是指一个用户的基本社会属性和变更频率低的平台特征，例如真实社会年龄、性别、婚姻状况、昵称、号码、账号、IBS等标签。这些标签类型多为直采型，可从用户基本信息表中直接获取，不需要统计或者算法挖掘。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;示例：社会性别_女。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;99660&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot;&gt;2&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;327:354&quot;&gt;平台属性&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;38%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;平台属性&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;是用户在平台上表现出的基本属性特征，是利用用户行为进行算法挖掘，标识用户真实属性的标签。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;典型的平台属性标签有平台年龄标签，这里你可能有个疑问，为什么在用户的基础属性中已经有年龄标签，但在平台属性中又有一个呢？这就涉及两者之间的差别。设想一个真实的场景，一个用户的社会年龄为20岁，但他喜欢中年人的穿衣风格，在使用&lt;span&gt;App&lt;/span&gt;购物的时候，表现出的真实偏好是&lt;span&gt;30~40&lt;/span&gt;岁的。对于这类使用产品时表现出的用户心智和真实年龄不相符合的用户，如果只采用用户上传的基本属性来为其推荐产品，是不是很难命中个体用户的兴趣呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;两种不同的标签，本质上是用户自己上传信息的随意性和挖掘信息的权威性差异，是用户社会属性和真实属性差异。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们仔细分析一下两者在数据源、计算逻辑、标签格式、标签值和应用场景等方面的差异，如下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（1）数据源与计算逻辑方面&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基本属性直接利用用户自行上传的、存储在用户基本信息表里的数据，平台属性则利用客户端或者服务端埋点上报采集的用户行为数据进行挖掘计算生成。基本属性是典型的直采型标签，平台属性是典型的算法挖掘型标签。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（2）末级标签和输出标签值方面&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以性别为例，基本属性代表用户真实的社会身份，是确定的事实，典型标签形式为“性别&lt;span&gt;_&lt;/span&gt;女”，而平台属性则代表用户在性别维度的偏好概率，典型形式为“性别&lt;span&gt;_&lt;/span&gt;女&lt;span&gt;_0.80&lt;/span&gt;”，其中“女”为末级标签，“&lt;span&gt;0.80&lt;/span&gt;”则代表用户在平台的女性身份上表现出的倾向程度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（3）应用场景方面&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;平台属性通过用户行为进行挖掘，更能代表用户的真实倾向，输出结果比基本属性准确率高，在定向营销和算法里，年龄、性别等通常采用平台属性。而社会属性中电话、身份证、账号、昵称等使用较多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;99660&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot;&gt;3&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;327:354&quot;&gt;行为属性&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;38%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;行为属性&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;记录的是用户的全部单点行为。用户的单点行为有很多，包括启动、登录、浏览、点击、加车、下单等，而且结合不同的产品、不同的模块交互、不同的时间窗选取，行为就更加复杂了，要想全面梳理，可以按照“产品×功能模块×用户单点行为×时间”四大要素来组织。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里“产品×功能模块×用户单点行为×时间”的意思是，一个完整的行为应该包含“哪个产品”“哪个功能模块”“哪个行为”“哪些时间要求”四大要素，例如某浏览器体育频道最近一次访问时间。按照这四大要素组织行为，不容易发生遗漏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;示例：初次登录产品时间，最后一次启动距今时间，30天内搜索行为频次，一个月内闪屏访问次数等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;99660&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot;&gt;4&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;327:354&quot;&gt;产品偏好&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;38%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;产品偏好&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;是对用户使用某些产品、产品核心功能或者其他渠道的偏好程度的刻画，属于挖掘型标签，其中产品的选取可以包括自家产品、竞品；功能和渠道既包括站内产品功能，也包括push、短信、开屏、弹窗等几大运营和产品法宝。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;示例：搜索模块偏好、直接竞品_京东偏好、短信偏好。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;99660&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot;&gt;5&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;327:354&quot;&gt;兴趣偏好&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;38%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;兴趣偏好&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;是用户画像内非常重要的维度，以电商产品为例，用户对商品的喜爱程度是用户最终的信息之一，兴趣偏好是对用户和物品之间的关系进行深度刻画的重要标签，其中最典型的是品牌偏好、类目偏好和标签偏好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;示例：品牌偏好_优衣库&lt;span&gt;_0.91&lt;/span&gt;、类目偏好&lt;span&gt;_&lt;/span&gt;美妆&lt;span&gt;_0.80&lt;/span&gt;、标签偏好&lt;span&gt;_&lt;/span&gt;红色&lt;span&gt;_0.70&lt;/span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;99660&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot;&gt;6&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;327:354&quot;&gt;敏感度&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;38%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在做营销活动时，我们留意到有些用户不需要优惠也会下单，而有些用户一定要有优惠券刺激才会下单，而且优惠券的额度会影响其下单的金额。这种情况下，如何识别出对优惠敏感的用户并为其发放合理券额的优惠券，保证优惠券不浪费，从而使促销活动的ROI最大？其中一个很重要的标签就是用户的敏感度标签。敏感度代表用户对平台活动或者优惠的敏感程度，也是典型的挖掘类标签。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;示例：热点敏感度、折扣敏感度。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;99660&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot;&gt;7&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;327:354&quot;&gt;消费属性&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;38%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;无论是电商、内容还是其他领域，公司的目标最终都是收益，所以消费属性往往作为一个单独的维度重点刻画。消费属性既包括统计型标签—消费频次、消费金额、最近一次消费时间等，也包括挖掘型标签—消费能力和消费意愿，还包括敏感度标签—优惠促销敏感度、活动敏感度、新品敏感度、爆款敏感度等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;99660&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot;&gt;8&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;327:354&quot;&gt;用户生命周期及用户价值&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;38%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户生命周期是用户运营的重要法典，一个用户从进入产品到离开，通常会经历“新手”“成长”“成熟”“衰退”“流失”这&lt;span&gt;5&lt;/span&gt;个典型阶段，每个阶段对用户的运营都存在策略差异，画像在其中的作用是明确标记用户所处生命周期的阶段，便于后续业务人员落地。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户价值是体现用户为产品贡献价值高低的标签，最经典的是通过RFM模型获得交易维度标签，此外，也应该看到用户的其他价值，例如为产品贡献活跃度，通过裂变拉来新用户，这些都可设计相应的标签。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;示例：新手、成长、成熟、衰退、流失、高价值用户、VIP等级等。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qrlXAFW0OmHM11P9UO6zVMDV0quS7bCuIQHeGvyP4QmlWmM6Gk95YUf9dQvrZlQogXWgmDTy8FGQicprFibjd7uA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;38806&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;38806&quot;&gt;&lt;section hm_fix=&quot;247:418&quot;&gt;&lt;section data-bcless=&quot;darken&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;用户画像从1到100的构建思路&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面我们介绍了如何搭建用户画像的基础框架，这一节讨论一下，有了基础框架，到底应该如何着手一步步完善画像标签树，如何从一个基于业务的需求落地为标签的设计，如何将标签应用到具体的业务中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要解决“如何做”和“如何用”这两大问题，要从问题的根本开始思考，也就是我们为什么要做用户画像，用户画像的作用是什么。了解了这些问题，便能水到渠成，根据用途合理地设计方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户画像的主要目的有以下3个：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;标签的完善也可以按照这3个维度不断丰富，以下分别举例说明标签建设的思路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;99660&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;1&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;用于统计，对产品、用户的基本认知&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;38%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;每个产品功能策略的完善，都需要建立在对产品、对用户的充分认知基础上，也就是说，用户是谁，有何特点，基本情况如何，这些是用户画像需要回答的重要问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;思路拆解：既然要了解用户的基础信息，就需要将用户基本属性进行拆解，包括年龄、性别、居住城市（几线）、家庭结构（婚否、孩否）等。为了盈利考虑，还需要了解基本的收入水平、消费能力等。将拆解的维度抽象，构建对应标签，然后进行分布统计，便能生成一份基本的用户认知报告。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;标签结果：年龄、性别等。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;99660&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;2&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;用于定向营销和精细化运营&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;38%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;运营人员作为画像的重要业务使用方，每天都会通过标签圈选人群，做定向的用户、活动、内容精细化运营，以及各App每天都在进行的促销活动。这些运营和活动的场景分布在产品的各个渠道和各个资源位，对场景和人群的精细程度要求都很高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举一个日常工作中最常见的需求，通过一次数据分析发现，产品的流失用户占比提升，经过讨论，大家认为一次结合利益点的push推送是召回流失用户的有效且快速的手段；同时&lt;span&gt;push&lt;/span&gt;作为各个业务都在争取的有限资源，希望可以提高使用效率，确保&lt;span&gt;push&lt;/span&gt;这个资源渠道的整体&lt;span&gt;ROI&lt;/span&gt;。以上需求希望画像可以支持。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;思路拆解：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;从这个需求背景中，我们做一次关键词提取，不难发现，关键词是&lt;/span&gt;“流失用户”“利益点”“&lt;span&gt;push&lt;/span&gt;&lt;span&gt;”“效率”。其中“流失用户”是用户身份识别，“利益点”是用户优惠敏感度，“&lt;/span&gt;&lt;span&gt;push&lt;/span&gt;&lt;span&gt;”是产品渠道资源，“效率”意味着要尽可能确保全选人群精准，不能为了覆盖率牺牲准确率。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;思路拆解完毕，具体落地就简单多了，参考步骤如下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第一步，确定流失用户的口径和标签。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;这里需要用到用户生命周期的划分，从中识别并标识出流失用户。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第二步，分析对流失用户拉回效果最好的利益点，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;例如优惠券、折扣、礼品或其他内容。这一步需要运营和数据开发人员根据日常经验和数据分析完成，对于画像的要求是基于分析结论，挖掘不同用户对于优惠折扣的敏感程度，这一点在前面介绍敏感度标签时有论述，最终目的是确保将每一分钱都花在刀刃上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第三步，确定拉回的明确目标，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是拉回规模还是准确率。通过需求分析可以确定，本次拉回在资源有限的情况下，需要提升人群识别的准确率。画像实现准确率的方法有两个，一是提升画像算法的准确率，这部分主要依赖算法本身，无法一蹴而就，因此这里选择第二个方法，即增加人群全选的条件，也就是新增标签，供圈选求交。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据背景分析，我们可以增加流失用户关于push渠道打开意愿的标签，提高&lt;span&gt;push&lt;/span&gt;资源的使用效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过上述分析，需要生产的标签如下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;条件为“最近&lt;span&gt;3&lt;/span&gt;天，最近&lt;span&gt;7&lt;/span&gt;天”；也可用综合的算法挖掘型标签，即&lt;span&gt;push&lt;/span&gt;渠道偏好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过以上需求分析和思路拆解，画像的建设过程应该比较明确了，这里再留一个思考的案例，可以尝试分析如何落地：平台新上一款商品，初期需要在某模块展示给目标用户做推广，同时尽量不打扰非目标用户，且不降低该资源位的整体转化效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;思路拆解：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;商品的目标用户&lt;/span&gt;—商品可以按照哪些维度拆分关键信息？模块位置—用户的模块功能使用偏好是什么？准确率的要求—如何提升画像应用的准确率？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回答好以上问题，这个需求的标签便能顺利获得。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;99660&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;3&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;用于算法&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;38%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用于算法，主要应用于搜索推荐、风控广告等策略方向。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;标签除了用于基本的用户群体描述、定向营销和精细化运营，还有一个相对来说新颖又广泛的用途：用于各算法的各个环节。在召回和排序两大经典策略流程中，都可以用到用户画像，这里我们举一个画像在推荐系统召回层的应用案例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;需求背景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;&lt;span&gt;推荐系统的本质是从海量信息中计算用户最感兴趣的部分，对应推荐系统的&lt;/span&gt;“召回—粗排—精排”，是一个“层层精选”的过程。其中召回层是精选的第一道流程，为后续计算打分准备初步的兴趣候选集，这里候选集的生成方法之一就是用户画像法。下面仍然以电商业务为例，讲述如何用用户画像做兴趣召回。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;思路拆解：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;&lt;span&gt;召回的作用是粗筛，帮助推荐系统计算第一道用户兴趣池。这里用户对物品的兴趣可拆解为对商品品牌、类目和商品标签的兴趣，这就转化为前面介绍的内容了，用户标签中有品牌偏好标签、类目偏好标签和标签偏好标签，只需要在所有品牌、类目、标签下维护一个按照商品质量或者热度降序排列的列表，这样只要获取到用户标识，便能从用户画像中获取偏好的品牌、类目和标签。再从品牌、类目和标签下的商品列表中召回相应的商品，根据候选集大小的设计，做&lt;/span&gt;top k&lt;span&gt;截断召回。这样，这部分商品就完成初步的召回，为进入下一个流程进行粗排和精排做好了准备。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;文章来源：《数据产品经理：实战进阶》 机械工业出版社 2020年&lt;span&gt;9&lt;/span&gt;月出版&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qrlXAFW0OmHM11P9UO6zVMDV0quS7bCuE3MeytIpNLkHYRfyWpLH5QzOfAvCib3Efu7AmDhtpAicwoeYXiaCFOmIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;mpcps frameborder=&quot;0&quot; class=&quot;js_editor_cps&quot; data-datakey=&quot;1599458390740_0.6482239327883992&quot; data-uid=&quot;1599458390737&quot; data-type=&quot;1&quot; data-product=&quot;&quot; data-templateid=&quot;list&quot; data-pid=&quot;29118440&quot; data-packid=&quot;&quot; data-smartnum=&quot;&quot; data-categoryid=&quot;3&quot; data-appid=&quot;wx831660fe3ded4389&quot; data-report=&quot;s0%3D3%26s1%3D0%26s2%3D0%26s3%3D%25E6%2595%25B0%25E6%258D%25AE%25E4%25BA%25A7%25E5%2593%2581%25E7%25BB%258F%25E7%2590%2586%25EF%25BC%259A%25E5%25AE%259E%25E6%2588%2598%25E8%25BF%259B%25E9%2598%25B6%26s4%3D0%26s5%3D10%26s6%3Did_1599459459042_86895%26s7%3D%26s8%3D%26s9%3D%26s10%3D%26pid%3Dwx831660fe3ded4389_29118440%26uuid%3D23981671601917372027%26title%3D%25E6%2595%25B0%25E6%258D%25AE%25E4%25BA%25A7%25E5%2593%2581%25E7%25BB%258F%25E7%2590%2586%25EF%25BC%259A%25E5%25AE%259E%25E6%2588%2598%25E8%25BF%259B%25E9%2598%25B6%26sid%3D3%26cid%3D3%26ratio%3D17.00%2525%26price%3D61.40%26&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;点击链接了解详情并购买&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;section data-id=&quot;97603&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.3111111111111111&quot; data-type=&quot;gif&quot; data-w=&quot;180&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/7QRTvkK2qC6D2OhibHUMz1XiaC7v0RcUA1icaxROuwbvf2Nqmcz53iat2YiaGq0ibvOsA2KakWoa80iahsYGXhDHFMiaxw/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-id=&quot;90215&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot; data-brushtype=&quot;text&quot;&gt;&lt;span&gt;更多&lt;/span&gt;&lt;span&gt;精彩&lt;/span&gt;&lt;span&gt;回顾&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-bdopacity=&quot;50%&quot; data-bdlessp=&quot;280&quot; data-bdless=&quot;spin&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend-list&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;1&quot; data-recommend-article-id=&quot;2247501049_1&quot; data-recommend-article-time=&quot;1612596849&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/1OYP1AZw0W1qEkYolnWziaHxU3zqfSnWGKhsEvt3Un1YhPAzRxGsOhWuicYRxw3l6vT5bYOy0qppCmWj9kQibD6IA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;干货 | 五千字长文带你快速入门FlinkSQL&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NjIyNjQwMg==&amp;amp;mid=2247501049&amp;amp;idx=1&amp;amp;sn=8dbb36f03b5f834de296a79cd90560ec&amp;amp;chksm=cf37f6f4f8407fe23c245da101d4cfcc5c1bc28cc872d40d2f0730265d32b1e1b551f287b02c#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NjIyNjQwMg==&amp;amp;mid=2247501049&amp;amp;idx=1&amp;amp;sn=8dbb36f03b5f834de296a79cd90560ec&amp;amp;chksm=cf37f6f4f8407fe23c245da101d4cfcc5c1bc28cc872d40d2f0730265d32b1e1b551f287b02c&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-type=&quot;normal&quot; data-recommend-tid=&quot;1&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;0.4261744966442953&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1OYP1AZw0W1qEkYolnWziaHxU3zqfSnWGKhsEvt3Un1YhPAzRxGsOhWuicYRxw3l6vT5bYOy0qppCmWj9kQibD6IA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;894&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;干货 | 五千字长文带你快速入门FlinkSQL&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;br/&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;1&quot; data-recommend-article-id=&quot;2247501043_1&quot; data-recommend-article-time=&quot;1612484160&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/1OYP1AZw0W2ibZNPKIDw1sngh9RqkVvlRJALqu9WyqQygeJBZBaIBVSq7vg8mO8IPn5Xh5hibwpCficpLs5vl82Kg/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;震惊！这篇文章解读数据仓库、数据湖、数据中台等概念，竟然写了4万字！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NjIyNjQwMg==&amp;amp;mid=2247501043&amp;amp;idx=1&amp;amp;sn=47e0059494d2aea0f248abcdf038db9a&amp;amp;chksm=cf37f6fef8407fe86e0749cb9e869cc5ecf6345401c20e35a2e8824ce3aafa24f4a7550dc188#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NjIyNjQwMg==&amp;amp;mid=2247501043&amp;amp;idx=1&amp;amp;sn=47e0059494d2aea0f248abcdf038db9a&amp;amp;chksm=cf37f6fef8407fe86e0749cb9e869cc5ecf6345401c20e35a2e8824ce3aafa24f4a7550dc188&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-type=&quot;normal&quot; data-recommend-tid=&quot;1&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;0.4261744966442953&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1OYP1AZw0W2ibZNPKIDw1sngh9RqkVvlRJALqu9WyqQygeJBZBaIBVSq7vg8mO8IPn5Xh5hibwpCficpLs5vl82Kg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;894&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;震惊！这篇文章解读数据仓库、数据湖、数据中台等概念，竟然写了4万字！&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;br/&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;1&quot; data-recommend-article-id=&quot;2247501043_2&quot; data-recommend-article-time=&quot;1612484160&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/1OYP1AZw0W2ibZNPKIDw1sngh9RqkVvlRVLia8cymA7ZkB44KT3YiclfdkHJRibSt8iagKAghPMssIO56zMKbyLcibyQ/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;Flink Client 实现原理与源码解析&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NjIyNjQwMg==&amp;amp;mid=2247501043&amp;amp;idx=2&amp;amp;sn=c61470a64c1ae41af5740828943d2abd&amp;amp;chksm=cf37f6fef8407fe8db7d457a02ea5d6046a09af81948687430dd81e7e6ade61d7640f1d09dc7#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NjIyNjQwMg==&amp;amp;mid=2247501043&amp;amp;idx=2&amp;amp;sn=c61470a64c1ae41af5740828943d2abd&amp;amp;chksm=cf37f6fef8407fe8db7d457a02ea5d6046a09af81948687430dd81e7e6ade61d7640f1d09dc7&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-type=&quot;normal&quot; data-recommend-tid=&quot;1&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;0.9917695473251029&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1OYP1AZw0W2ibZNPKIDw1sngh9RqkVvlRVLia8cymA7ZkB44KT3YiclfdkHJRibSt8iagKAghPMssIO56zMKbyLcibyQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;243&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;Flink Client 实现原理与源码解析&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;br/&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;1&quot; data-recommend-article-id=&quot;2247501043_3&quot; data-recommend-article-time=&quot;1612484160&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/1OYP1AZw0W2ibZNPKIDw1sngh9RqkVvlRBzZtBm0baL6rHxZrBCA7763Z9ib08TTGzcYXbnyOnO8Yvr8t1Q5COdw/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;大数据文章合集NO.2（第二期）&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NjIyNjQwMg==&amp;amp;mid=2247501043&amp;amp;idx=3&amp;amp;sn=1d6c39597413bcd4d9e4042b8da4a5d3&amp;amp;chksm=cf37f6fef8407fe829a0e5177217b07a88051c86b4459bc31aabed1dc384594ff934d19f8652#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NjIyNjQwMg==&amp;amp;mid=2247501043&amp;amp;idx=3&amp;amp;sn=1d6c39597413bcd4d9e4042b8da4a5d3&amp;amp;chksm=cf37f6fef8407fe829a0e5177217b07a88051c86b4459bc31aabed1dc384594ff934d19f8652&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-type=&quot;normal&quot; data-recommend-tid=&quot;1&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;0.9967213114754099&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1OYP1AZw0W2ibZNPKIDw1sngh9RqkVvlRBzZtBm0baL6rHxZrBCA7763Z9ib08TTGzcYXbnyOnO8Yvr8t1Q5COdw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;305&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;大数据文章合集NO.2（第二期）&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;br/&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;1&quot; data-recommend-article-id=&quot;2247500969_2&quot; data-recommend-article-time=&quot;1612397760&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/1OYP1AZw0W13jbB0aNgezXggb71qJv9De0qBpfAOvJ2ibbrPibIWpYdkby4xjyySFB1rWhxicicfRICGMHy1OgMVEQ/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;分析 BAT 互联网巨头在大数据方向布局及大数据未来发展趋势&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NjIyNjQwMg==&amp;amp;mid=2247500969&amp;amp;idx=2&amp;amp;sn=5320af66acc752ecbc569649eef0b8b7&amp;amp;chksm=cf37f6a4f8407fb28e9a64d3afb38de9bbd6d9087e64e502cf2e59f6e9761877b79c97f999a6#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NjIyNjQwMg==&amp;amp;mid=2247500969&amp;amp;idx=2&amp;amp;sn=5320af66acc752ecbc569649eef0b8b7&amp;amp;chksm=cf37f6a4f8407fb28e9a64d3afb38de9bbd6d9087e64e502cf2e59f6e9761877b79c97f999a6&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-type=&quot;normal&quot; data-recommend-tid=&quot;1&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;0.9937694704049844&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1OYP1AZw0W13jbB0aNgezXggb71qJv9De0qBpfAOvJ2ibbrPibIWpYdkby4xjyySFB1rWhxicicfRICGMHy1OgMVEQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;321&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;分析 BAT 互联网巨头在大数据方向布局及大数据未来发展趋势&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;br/&gt;&lt;/section&gt;&lt;center data-tool=&quot;mdnice编辑器&quot;&gt;&lt;center data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;下载资料：长按扫码回复 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;数仓&lt;/strong&gt;&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;/p&gt;&lt;center data-tool=&quot;mdnice编辑器&quot;&gt;&lt;pre&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2714223575467595&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2299&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1OYP1AZw0W2IMiaCFatibtuvqoxGBjcqprAruMlHJTVc1uxuPNfXGicUX3HU1k51icPToQQptTbjgbB7mOUg7zUGKA/640?wx_fmt=png&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/center&gt;&lt;/center&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;希望这篇文章可以帮到你~&lt;br/&gt;&lt;/span&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;欢迎大家点个&lt;/span&gt;&lt;span&gt;在看&lt;/span&gt;&lt;span&gt;，分享至朋友圈&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;分享、收藏、赞、在看，&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;四连击！&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>405f3c9c27cb44e0f9ad2c75c771c3a8</guid>
<title>互联网基建成果，快速实现一个 Clubhouse 要多久</title>
<link>https://toutiao.io/k/1u192lr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近国外的一款基于语音的社交软件clubhouse掀起了一股热潮，尤其是在Eleon Musk的带动下，整个互联网圈内人都在第一时间抢先体验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管它为什么会火，肯定不是技术上有什么特别的优势。随着整个互联网技术生态的不断发展，互联网基础建设的不断完善，想快速实现一个产品，还是有很多的方案可以选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而今天给大家带来的是Github上的一个clubhouse的开源实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wokNJRf0ytqHoQSU39OwGcLQcOBAfn2alicxKP0qiceP1X6bV4xjMkgZGvOeocgRqvYX2Nrrog6oOwhuzjkozrNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;372&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;NesHouse 是一个基于 Agora、LeanCloud 服务，使用 Alpine.js 、Bulma Css、NES.css 构建的前端项目，这个项目实现了一套基于 NES 风格的 clubhouse，你可以使用 NESHouse 来创建自己的线上直播间，也可以将其分享出去，邀请别人一起参与讨论。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;特性&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;多聊天直播间支持&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;管理员权限&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多主播同时发言&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;观众申请发言&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;管理员禁言主播&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生成分享链接&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;界面&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7507163323782235&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wokNJRf0ytqHoQSU39OwGcLQcOBAfn2aIv1WaxUYYW0LsuI34NsBPaLEHJX4ye8lGwK7R0zdO4NGg98g1Q1C6A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3490&quot;/&gt;&lt;img data-ratio=&quot;0.9211663066954644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wokNJRf0ytqHoQSU39OwGcLQcOBAfn2aVaUfDWzrhcFad5WUh9OyLx73z020lon9SZ2icwArzwe80Gtrdg9vfIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1852&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;依赖服务&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LeanCloud 国际版&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Agora.io 声网 +（非必需）Vercel&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;如何使用&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;使用流程&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;注册一个 LeanCloud 国际账户，并创建一个项目，用于后续的项目配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注册一个 Agora 声网账号，并创建一个项目，获取 AppID。&lt;strong&gt;创建项目时请选择调试模式，仅 APPID 鉴权&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 LeanCloud 的&lt;strong&gt;应用后台&lt;/strong&gt; - &lt;strong&gt;你使用的应用&lt;/strong&gt; - &lt;strong&gt;设置&lt;/strong&gt; - &lt;strong&gt;应用 Keys&lt;/strong&gt; 中找到 &lt;strong&gt;AppID&lt;/strong&gt; 和 &lt;strong&gt;AppKey&lt;/strong&gt;，将其记录下来，以备后用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 LeanCloud 的&lt;strong&gt;应用后台&lt;/strong&gt; - &lt;strong&gt;你使用的应用&lt;/strong&gt; - &lt;strong&gt;存储&lt;/strong&gt; - &lt;strong&gt;服务设置&lt;/strong&gt; 中启用 &lt;strong&gt;Live Query&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 LeanCloud 的&lt;strong&gt;应用后台&lt;/strong&gt; - &lt;strong&gt;你使用的应用&lt;/strong&gt; - &lt;strong&gt;存储&lt;/strong&gt; - &lt;strong&gt;结构化数据&lt;/strong&gt; ，并创建一个名为 &lt;strong&gt;RoomUser&lt;/strong&gt; 的 Class。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将上面记录的声网的应用 AppID 和 LeanCloud 的 AppID 和 APPkey 填写到 &lt;code&gt;js/config.js&lt;/code&gt; 顶部的配置中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将修改好的文件部署到你自己的服务器上，并配置域名指向。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;配置说明&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;js/config.js&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const AVAPPID = &lt;span&gt;&quot;&quot;&lt;/span&gt; // LeanCloud AppID&lt;br/&gt;const AVAPPKEY = &lt;span&gt;&quot;&quot;&lt;/span&gt; // LeanCloud AppKey&lt;br/&gt;const BASEURL = &lt;span&gt;&quot;&quot;&lt;/span&gt; // 最终网页所在的路径，生成的分享链接会基于这个地址产生&lt;br/&gt;const DEFAULT_TEXT = &lt;span&gt;&quot;Please contact &amp;lt;a href=&#x27;mailto:bestony@linux.com&#x27;&amp;gt;bestony@linux.com&amp;lt;/a&amp;gt; to Learn more&quot;&lt;/span&gt; // 页面顶部展示的文字&lt;br/&gt;const AGORAAPPID = &lt;span&gt;&quot;&quot;&lt;/span&gt; // 声网服务的 AppID&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Demo&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;创建房间: https://neshouse.com/admin.html&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;默认主页: https://neshouse.com/admin.html&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;Demo 使用流程&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在 域名/admin.html 中输入房间名 &amp;amp; 用户昵称，创建一个新的房间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;点击下方的 &lt;strong&gt;Log in to chat room as Administrator&lt;/strong&gt; 以管理员身份登陆房间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;复制输入框内的链接，分享给你的朋友，邀请他们加入房间。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c51a771581260fcf09a94aac5b353cac</guid>
<title>小步发布、验收测试和完整团队</title>
<link>https://toutiao.io/k/2z99lmo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;main class=&quot;post-styles_main__2vaxQ&quot;&gt;&lt;p class=&quot;zh-cn&quot;&gt;在&lt;a href=&quot;https://teobler.com/posts/20210201-agile-business-practice-planning-games&quot;&gt;上一篇文章&lt;/a&gt;中我们花比较大的篇幅介绍了敏捷业务实践中的计划游戏，在这篇文章中我们将介绍介绍生命之环中外围剩下的三个业务实践。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;img src=&quot;https://teobler-image.s3-us-west-1.amazonaws.com/142240.png&quot; alt=&quot;life-cycle&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;小步发布&quot;&gt;小步发布&lt;/h2&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;img src=&quot;https://teobler-image.s3-us-west-1.amazonaws.com/101624.png&quot; alt=&quot;ci_cd_circle&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;小步发布这一业务实践&lt;strong&gt;建议开发团队应该尽可能频繁地发布软件&lt;/strong&gt;。在敏捷早期，这个时间节点大概是“一到两个月”。现如今，发布周期的目标是无限短，即&lt;strong&gt;持续交付&lt;/strong&gt;：每次代码更改后就将代码发布到生产环境中。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;虽然缩短的是发布周期，但其实小步发布这个实践的&lt;strong&gt;真正目的在于缩短所有周期&lt;/strong&gt;。但是由于源代码管理的历史原因，缩短周期这件事情从根本上就会面临很大的历史惯性。这一切要从软件行业早期开始讲起。&lt;/p&gt;
&lt;h3 id=&quot;纸带打孔时期&quot;&gt;纸带打孔时期&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;在软件行业刚刚兴起的时候，所有的”代码“是储存在打孔纸卡上的。一张纸带可以容纳 80 个字符，代表一行程序。程序本身由这样一张张的纸卡组成，最终整个程序将是一大箱成捆的纸卡。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;img src=&quot;https://teobler-image.s3-us-west-1.amazonaws.com/110932.jpg&quot; alt=&quot;dakong&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这些纸卡被存放在柜子里，如果有人想修改代码，这需要签出源代码，在获得所有者的许可后，便可以从柜子里清点出要修改的那部分代码 - 这是真正的签出源代码。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这时由于你从物理角度获得了源代码，意味着只有你有资格修改这部分代码，其他人都碰不到它。只有等你完成了修改，将源代码存回柜子里，其他人才有机会修改。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这个时间周期不固定，可能是几天、几周甚至是几个月。&lt;/p&gt;
&lt;h3 id=&quot;磁带时期&quot;&gt;磁带时期&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;img src=&quot;https://teobler-image.s3-us-west-1.amazonaws.com/111316.jpg&quot; alt=&quot;tape_storage&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;后来随着科技的发展，代码开始存储在磁带上，除了容量更大，也更容易被复制了。此时修改代码变成了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从母带架上取出母带。&lt;/li&gt;
&lt;li&gt;将要编辑的代码从母带上复制到你自己的工作磁带。&lt;/li&gt;
&lt;li&gt;放回母带，其他人可以继续复制。&lt;/li&gt;
&lt;li&gt;将彩色大头钉固定在你正在编辑的模块旁边的签出板上，一个人使用一种单独的颜色(然后人多就会用完所有颜色)。&lt;/li&gt;
&lt;li&gt;在你自己的工作磁带上进行编辑、编译和测试。&lt;/li&gt;
&lt;li&gt;再次取出母带。&lt;/li&gt;
&lt;li&gt;将更改完成的模块从工作磁带赋值回母带中。&lt;/li&gt;
&lt;li&gt;将新的母带放到母带架上。&lt;/li&gt;
&lt;li&gt;从签出板上取回你的大头钉。&lt;/li&gt;
&lt;/ol&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这时的好处是你不再在物理上拥有源代码，这代表着别人可以同时修改不同的模块，但这也就意味着别人可以不遵守约定，偷偷修改你正在修改的模块。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这时的工作周期有一定的缩短，变成了几个小时、几天或者是几周。&lt;/p&gt;
&lt;h3 id=&quot;磁盘和源代码管理系统的出现&quot;&gt;磁盘和源代码管理系统的出现&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;再后来源代码的存储介质变成了磁盘，但是仍然使用大头钉的方式来标记谁在修改哪一模块的代码。然后真正的源代码管理工具出现了。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;早期的其中一个源代码管理系统 Source Code Control System(SCCS)。SCCS 的行为与签出板一样，将模块以悲观锁(Pessimistic Lock)的方式锁定在磁盘上，防止别人编辑。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;后来 SCCS 被 版本控制系统 RCS(Revision Control System) 取代，然后 RCS 又被并发版本系统 CVS(Concurrent Version System) 所取代。这些工具在进行微小改良的同时本质都没有改变 - 都是使用悲观锁来控制相应模块不发生冲突。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;虽然此时的周期还是不短，但是磁盘允许我们极大地缩小模块的规模。&lt;strong&gt;模块的小型化有效地缩短了周期时间，因为模块越小，保持签出状态进行修改完成的时间就越短。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;subversion&quot;&gt;Subversion&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;Subversion(SVN) 与上述工具不同，其提供了乐观锁。这使得多个开发人员可以同时签出一个模块。SVN 工具会对此进行追踪，并自动将多人的更改合并到模块中。如果有冲突，则要求先解决冲突才允许签入代码。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这样的流程会大大缩短周期时间，使其缩短至编辑、编译和测试一系列小更改所需的时间。&lt;strong&gt;此时签出时间不在是制约周期时间的因素，主要因素变成了修改紧耦合代码所产生的冲突。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;git&quot;&gt;Git&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;如今我们使用 Git，此时已经没有签出时间这个概念了(当然，除了那些超大型的代码库)。程序员可以在任何时间提交对模块的任何修改。如果这些模块出现了冲突，程序员可以在任何时候来解决冲突。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;充分解耦的小模块和快速的小步提交共同作用，使得周期时间可以缩短至几分钟。在此基础上覆盖以全面、运行快捷、几乎可以测试任何功能的自动化套件，你就具备了持续交付(Continuous Delivery, CD)的条件。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;**小步发布的目的不仅仅是为了缩短发布周期。**为了实现缩短发布周期这个目的，大家就必须使自己的代码充分解耦，同时采用小步快速提交的策略，将自己的修改快速提交到代码库。而为了使得自己的小步修改是可工作的，又要求有一系列的测试套件来保证代码质量。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;而为了缩短发布周期，组织需要打破发布和部署之间的耦合。最终，&lt;strong&gt;“是否要部署”只是一个业务决策，每一次决定部署，都已经变成了一次发布。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;验收测试&quot;&gt;验收测试&lt;/h2&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;img src=&quot;https://teobler-image.s3-us-west-1.amazonaws.com/111608.jpg&quot; alt=&quot;atdd&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;最令人困惑的实践&quot;&gt;最令人困惑的实践&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;验收测试这一敏捷实践的基本思想是：**应该由业务方负责说明需求的规格。**而问题恰恰出在&lt;em&gt;规格说明&lt;/em&gt;上。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;许多业务方认为这个词的意思是：我只需要随便比划两下，用几句含糊不清的话来描述我的需求，开发人员就应该自己能够找到所有的细节。而程序员们又希望业务方能够精确定义系统应该做什么，最好能够描述清楚每一个细节。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;而我们所需要的其实是介于这两个极端之间的关系。规格说明从某种意义上来讲，本质是一种测试，比如：&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;em&gt;当用户输入有效的用户名和密码，点击登录按钮，系统将跳转到欢迎界面。&lt;/em&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这就是一个标准的规格说明，但仔细想想，这也是一个标准的测试用例，并且这个测试用例是可以被自动化的。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;其实这个实践指的是：**只要可行，系统的需求就应该写成自动化测试。**虽然看起来简单，但这个实践是所有敏捷实践中最不被理解、使用最少，也最混乱的实践。下面这几个问题将为你揭晓为什么会有这样的情况：&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;首先是，谁来写这些测试呢？如果按照本节第一句话描述的基本思想来说，既然规格说明是业务方提出来的，那么是不是应该由业务方来写这些测试呢？&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;下一个问题是，大部分业务方其实并不具备编写代码的能力，编写代码不应该是程序员的工作吗？&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;但是如果是程序员来写这些测试的话，他们会以以技术的思维来写，并不会以业务的思维来写。这意味着这些测试除了他们自己谁也看不懂，因为里面充满了技术细节。所以这个问题还是推回给了业务方，应该由他们来编写。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;但是如果由业务方来编写，他们可能采用与团队完全不相符的技术栈，这意味着我们得重写这些测试以符合我们的技术栈。&lt;/p&gt;
&lt;h3 id=&quot;尝试解决&quot;&gt;尝试解决&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;实践混乱，就会催生出一系列尝试解决混乱的工具和方法论。FitNesse、JBehave、SpecFlow 和 Cucumber 等工具就是程序员们开发出来为了解决这些问题的工具。它们尝试将这些自动化测试的技术面和业务面分开。由业务方编写测试的业务端，程序员编写粘合代码将这些测试和被测系统绑定起来。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;虽然梦想是美好的，但是业务方很是不愿意参与进来，比起形式化的语言，他们更希望用人类的语言，来编写这些规格说明。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;于是程序员又做了一步妥协，他们编写测试但希望业务方至少能够去阅读代码形式化的文档，并验证测试是否正确，但业务方更想吧这样的工作交给 QA。&lt;/p&gt;
&lt;h3 id=&quot;行为驱动开发&quot;&gt;行为驱动开发&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;img src=&quot;https://teobler-image.s3-us-west-1.amazonaws.com/111935.png&quot; alt=&quot;BDD&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;在千禧年之后，丹·诺斯(Dan North) &lt;a href=&quot;https://dannorth.net/introducing-bdd/&quot;&gt;尝试重新定义 TDD&lt;/a&gt;，他称之为 &lt;a href=&quot;https://en.wikipedia.org/wiki/Behavior-driven_development&quot;&gt;BDD&lt;/a&gt;(Behavior-Driven Development, 行为驱动开发)。他的目标是从测试中去掉技术术语，使测试让业务方看起来更讨喜。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;BDD 的支持者建议，业务方可以不写测试，但是希望他们能够以一种形式化的、基于场景的语言(比如 Given-When-Then)来详细描述他们的系统，这样的语言对程序员编写测试也有巨大的价值。&lt;/p&gt;
&lt;h3 id=&quot;合作与实践&quot;&gt;合作与实践&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;既然大家都不愿意一个人完成所有的事情，那如果大家一起来呢？实践的目的没有改变，还是&lt;strong&gt;只要可行，系统的需求就应该写成自动化测试&lt;/strong&gt;。但是方式应该是&lt;strong&gt;业务方编写形式化的测试来描述每个用户故事的行为，开发人员将这些测试自动化。&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;回到最开始的问题，谁来写？答案是业务分析师(BA)和 QA，至于为什么，我们会在稍后解释。他们需要在迭代的前半部分之前完成测试的编写，然后程序员完成故事的开发并将这些测试集成到持续构建(CI)中。只有完成了测试的编写并且代码通过了所有测试，故事才算完成。&lt;/p&gt;
&lt;h4 id=&quot;业务分析师和-qa&quot;&gt;业务分析师和 QA&lt;/h4&gt;
&lt;p class=&quot;zh-cn&quot;&gt;业务分析师负责澄清和理解需求方的需求，然后负责说明功能的乐观途径(happy path)，因为他们需要作为中间人在需求方和程序员之间做大量沟通，没有精力描述所有悲观途径(unhappy path)。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;而 QA 的工作是写出所有悲观途径，他们是既了解业务又拥有很强技术的人。他们能够站在业务和用户的角度找出如何破坏系统的方法，同时他们还能了解程序员的思路，戳穿他们的“偷工减料”。&lt;/p&gt;
&lt;h4 id=&quot;qa&quot;&gt;QA&lt;/h4&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这个实践完全改变了传统 QA 的工作职责，他们不再作为测试人员在项目末期把关，而是在前期定义规格；他们也不再在项目晚期提出关于错漏的反馈，而是提早给开发团队提供输入，预防错漏的发生。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这意味着 QA 需要承担相对于传统项目更大的压力。为了确保产品的质量，QA 需要在每一个迭代的全期做不同的工作，而不是仅仅在结尾进行测试，他们是系统是否可部署的“批准者”。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这样做有什么好处呢？&lt;/p&gt;
&lt;h5 id=&quot;减少遗漏测试的可能性&quot;&gt;减少遗漏测试的可能性&lt;/h5&gt;
&lt;p class=&quot;zh-cn&quot;&gt;传统测试人员会在项目尾声才开始测试，这意味着他们会成为项目部署的瓶颈，为了部署，他们需要尽快完成测试工作。同时这样的工作方式会让上游所有的日期推迟都堆到测试身上，假如程序员的工作延迟了一周，测试的工作就就少了一周，因为管理者不会因为程序员的推迟交付多给测试时间，上线日期是几乎不会改变的。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;那么在这样的情况下，QA 会如何测试呢？很简单，加速，不测所有功能，只测试新的需求或者那些改变了的功能，放弃测试没有改变的功能。于是&lt;strong&gt;遗漏开始了&lt;/strong&gt;，全量回归被放弃，期许下次能有时间全量测试，可是&lt;strong&gt;下次往往意味着永不&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&quot;bug数即api&quot;&gt;bug数即API&lt;/h5&gt;
&lt;p class=&quot;zh-cn&quot;&gt;上述问题至少还有补救的办法，另一个将测试工作放在项目尾声的致命问题是，&lt;strong&gt;组织应该如何判断他们做好了自己的工作&lt;/strong&gt;？很简单，发现的bug越多，他们做的就越好。以发现的bug数量来作为QA团队尽职尽责的证据。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;em&gt;于是，发现 bug 被认为是好事，且在一些偏激的组织内成为了 QA 团队的 kpi。&lt;/em&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这样的问题或许在短期内不会致命，但是长此以往，组织内部一定会逐渐虚弱。&lt;/p&gt;
&lt;h4 id=&quot;程序员&quot;&gt;程序员&lt;/h4&gt;
&lt;p class=&quot;zh-cn&quot;&gt;业务分析师和 QA 完成了测试的编写，但是他们并不运行这些测试。这个任务交给了程序员，程序员需要确保它们的代码通过所有的测试。此时形成了一种&lt;strong&gt;开发即测试&lt;/strong&gt;的有趣局面。换句话说，程序员虽然在做开发的工作，其实他们也在做测试的工作，因为他们的代码通过了测试，这些刚实现的功能已经被测试过了。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这些测试会和开发过程中编写的单元测试一起被加入到持续构建中。每当一个程序员加入了新的模块，服务器会自动运行所有测试，而团队中的所有人都会关注这些运行，我们会在稍后的文章中有更详细的讨论。&lt;/p&gt;
&lt;h2 id=&quot;完整团队&quot;&gt;完整团队&lt;/h2&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;img src=&quot;https://teobler-image.s3-us-west-1.amazonaws.com/112756.jpg&quot; alt=&quot;scrum_team&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;完整团队的事件最初被称为&lt;em&gt;现场客户(On-Site Customer)&lt;/em&gt;。其理念是：&lt;strong&gt;用户和程序员之间的距离越短，交流就越好，开发就越快、越准确&lt;/strong&gt;。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这里的客户是一个隐喻，指的是理解用户需求并与开发团队共同工作的某个人或团队。在 Scrum 里这个人或团队被称为 产品负责人(Product Owner, PO)，他负责选择故事、设置优先级并及时提供反馈。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;后来这个实践被改名为&lt;strong&gt;完整团队&lt;/strong&gt;。这是为了强调一个团队里不是只有客户和程序员。开发团队不应该由一个个职能部门组成，同一个团队中应该有客户、业务分析师、程序员、测试人员、经理等等。同时这些所有角色应该尽量处于同一个房间中。&lt;strong&gt;这个实践的目的是无限缩短这些角色之间的物理距离，打破只能壁垒。&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这样可以极大地提高团队效率，消息不用层层传递，有相应的问题直接能够找到对应的角色进行解决，从问题发生、提出到开始讨论只有短短几秒钟。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;而且团队坐在一起总会触发神秘力量。客户可以无意从程序员或测试人员屏幕上立马发现不对的东西；一场激烈讨论中，可能坐在旁边的另外一个角色本来就有正确答案；两个程序员对需求的描述被业务分析师发现与自己的想法不符......&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;需要注意的是，虽然这个实践一直在描述团队的行为，但这的确是一个业务实践，因为这个实践受益最大的是业务，当团队在同一地点时，业务运行会更加流畅。&lt;/p&gt;
&lt;h3 id=&quot;远程办公的今天&quot;&gt;远程办公的今天&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;在今天，日新月异的技术已经让远程办公成为了可能，特别是视频会议的兴起一定程度上弥补了物理上无法坐在一起办公的遗憾，甚至编译器已经让远程结对做到毫无延迟。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;敏捷团队可以分散在各处吗？在之前这个答案是未知的，但经历了2020年的疫情，这个答案大概是肯定的。至少我们团队和我们各个办公室的团队做的都挺好，但这的确&lt;strong&gt;需要付出更多的精力和拿出更多的纪律和规则&lt;/strong&gt;。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;可以肯定的是，这是可行的，但是如果大家都在同一个房间，我们可以做的更好。&lt;/p&gt;
&lt;/main&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c4c5b7b012a1a403bf1539cb446459e2</guid>
<title>领域驱动设计 (DDD) 在百度爱番番的实践</title>
<link>https://toutiao.io/k/djhtzln</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;全文约9500字，预计阅读时间25分钟&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;导读&lt;/span&gt;&lt;/h2&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;领域驱动设计（Domain Driven Design - DDD）起源于2004年Eric Evans出版《领域驱动设计》，相比于在国外IT圈享有盛誉且行之有效不同，国内IT圈了解DDD的人很少，落地实践的少之又少。最近几年随着微服务架构的普及和中台的兴起，DDD也成了各大技术论坛和微信公众号文章里经常谈起的话题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DDD的热度是起来了，但业界介绍DDD的资料大多偏理论，缺乏生产项目可借鉴的实践经验。因此大多人读了很多DDD材料后还是一脸懵，怎么衡量DDD带来的价值？老板能同意搞DDD吗？什么样的业务和团队适合DDD？DDD跟互联网强调的小步快跑快速迭代能搭吗？如果要实践DDD产研团队都要做些啥？研发写代码跟平时有什么不一样？本文结合百度爱番番产研团队在过去一年多经历的从探索、推广到全面落地DDD的过程，尝试回答上述问题，力求给大家带来一些借鉴意义。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1. 初心：以客户为中心，产研团队如何高效交付需求&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;百度爱番番围绕营销拓客和销售提效帮助企业收集、扩充、清洗、培养、跟进和转化线索。一方面爱番番的业务特点是典型的企业级（ToB）业务，具有一定的复杂度。业务对象多，单个业务对象提供的功能多，单个功能面向的场景多，业务对象之间组合出来的业务流程多。并且会随着交付的功能越多而变的越复杂。另一方面产品处于爬坡阶段，功能需要快速迭代交付到客户，从而快速获得客户的反馈。产研团队在资源一定的情况下如何高效交付更复杂的需求成为了主要矛盾。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分析当前阶段需求迭代过程中的问题，可以总结为以下几类问题：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务逻辑不能从产品团队精准传递到研发团队，有时研发进行了一段时间开发才发现需求理解有偏差，导致需要重新跟产品经理讨论需求。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;产品团队和研发团队对于业务复杂度没有的认识不统一，产品经理认为一个需求的开发不难，理应在较少时间内开发完毕。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;研发团队面对需求增长和变化时，缺乏对业务逻辑的抽象，往往开发一个需要点需要改动多处，容易出错且开发效率低，代码维护性差。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;需求文档和代码逻辑不匹配，线上功能的业务逻辑为什么实现成那样没有依据可查，领域知识得不到沉淀，团队得不到可持续成长。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;2. 探索：找到适合的开发模式&lt;/span&gt;&lt;/h2&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;上述问题集中体现在两个方面，一是产品属于企业应用类，功能本身复杂，如何让产研团队快速理解业务，快速交付。二是如何让领域知识能够比较准确的得到开发实现，让代码有比较好的可维护性。借鉴业内处理复杂企业级软件的开发经验，加上部分团队成员曾经有过DDD使用的经验，团队决定尝试运用DDD设计思想来指导产研团队的日常需求迭代。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;2.1 DDD是啥？&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;DDD是一种围绕领域建模来解决复杂业务交付的设计思想。读者不妨自问几个问题，什么是复杂？什么是领域建模？&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;什么是复杂？如何理解复杂？复杂可能是现状业务就复杂，也可能是业务日渐演变成复杂。复杂来自规模在变，比如几个业务对象的逻辑不复杂，几十上百个业务对象就会变得错综复杂。复杂来自结构化不足，比如下图所示，结构化的中国结比非结构化的意大利面更有序、易于大脑理解。此外，一旦协同方多了，如何协同不同团队完成软件交付也是一种复杂。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibvMESYPPdbrLnQ09VJL3VWrhZicsChOVtQZQ4LAw6MQszSm6Mf8dzUu64WruQB2sPFcU4DLqpfDFAPYzZWVZ7rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;什么是领域建模？领域模型跟技术毫无关系，而是为了更有结构化的拆解和表达业务逻辑。业务逻辑来自现实世界里的具体场景，涉及可视画面、操作动作和流程。要准确表达业务逻辑需要先讲清楚每个概念是什么，再建立概念之间的联系，基于这些关系再组合出更多的流程。概念、联系、流程就是领域模型。围绕领域模型去表达业务时也自然而然地把技术实现细节分离出去了。后续代码实现就是将业务架构映射到系统架构的过程，以后业务架构调整了能快速的调整技术架构。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DDD中的领域如何理解？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DDD中表示业务逻辑的领域概念是：实体、值对象、领域服务、领域事件。这意味着所有领域逻辑都应该在这四种对象里，统一称为领域模型对象，这将极大减少业务逻辑的蔓延。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;引入聚合进一步封装实体和值对象，让领域逻辑更内聚，起到边界保护的作用。聚合的引入使得业务对象间的关联变少。如何设计聚合见下面实践部分。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;围绕聚合的操作引入工厂和资源库。工厂负责复杂聚合的创建，资源库负责聚合的加载、添加、修改、删除。聚合内的实体状态变更通过领域事件来推动。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;引入应用服务，对领域逻辑编排、封装。供上层接口层调用。一个应用服务就是一次编排，一次编排就是一个用户用例。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DDD领域概念详细解释和举例&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;名称&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;定义&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;举例&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;实体&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;实体一般对应业务对象，具有业务属性和业务行为&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;线索是个实体，线索的状态会随着跟进活动的推进随时变化，需要根据唯一标识来追踪变化&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;值对象&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;值对象主要是属性集合，对实体的状态、特征进行业务语义的描述&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;线索上的联系方式信息是值对象，包含联系方式类型和联系方式内容，不需要唯一标识去追踪联系方式的变化过程，整体替换新联系方式&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;聚合&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;聚合是由业务和逻辑紧密关联的实体和值对象组成的，是数据修改和持久化的基本单元&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;线索是个聚合，线索实体是该聚合的根实体，状态信息、联系方式信息等是附属聚合的值对象&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;资源库&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;资源库是对资源访问的抽象。不局限于数据库、文件、网络存储。接口需要不依赖于具体的数据存储和ORM实现框架&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;线索这个聚合的访问通过线索资源库提供，资源库的实现因技术选型不同而不同，可以是数据库、文件等&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;领域事件&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;表示领域中所发生的重要事件，事件发生后通常会导致进一步的业务操作，或者在系统其他地方引起反应&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;线索创建后会产生线索已创建领域事件，后续的线索分配服务、打标签服务可以监听该事件启动相应操作&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;领域服务&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;领域服务没有任何属性或数据，只是一个领域行为或动作，不适合放在任何聚合内的逻辑行为&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;线索的查重行为属于领域服务，单个线索自身没法完成查重行为&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;应用服务&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;应用服务对应到一个具体业务场景，通过编排聚合、资源库、领域事件、外部适配接口、领域服务来完成&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;线索创建这个场景对应线索创建应用服务，该服务会编排线索查重、线索聚合创建、线索资源库创建、线索已创建领域事件发送等&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;&lt;h3&gt;&lt;span&gt;2.2 DDD如何开展？&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;DDD包含战略设计、战术设计、技术实现三个部分。战略设计侧重于高层次、宏观上去划分限界上下文，而战术设计则关注使用建模工具来细化上下文，通过领域模型来表达业务。技术实现主要通过分层架构来隔离领域模型代表的业务逻辑和技术细节。一个整体过程大致包括：宏观划分各领域 → 领域内划分限界上下文，定义上下文之间的关系 → 上下文内分析业务，识别领域概念，定义合适的领域概念 → 通过分层架构实现编码，并验证领域模型的合理性，必要时重新回到前面步骤重构领域模型。&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span data-mce-style=&quot;color: #121212;&quot;&gt;战略设计&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span data-mce-style=&quot;color: #121212;&quot;/&gt;&lt;br/&gt;&lt;span data-mce-style=&quot;color: #121212;&quot;&gt;战略设计是团队领导层或业务负责人关心的，该步骤需要针对产品愿景、业务要解决的问题域，规划核心域、通用域、支撑域，做合适的资源投入。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;什么是领域和限界上下文？领域代表现实世界的特定问题和解决方案的集合，比如销售领域、营销领域。DDD里的限界上下文（Bouded Context）是对领域的软件实现，比如线索系统、商机系统就是销售领域内的限界上下文。限界上下文定义了解决方案的明显边界，边界里的每一个领域概念，包括领域概念内的属性和行为都有特殊含义。出了限界上下文这个边界这层含义就不复存在。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span data-mce-style=&quot;color: #121212;&quot;&gt;如何划分限界上下文？#1.&lt;/span&gt;根据相关性做归类。一般是优先考虑功能相关性而不是语义相关性，比如创建订单和支付订单都是订单语义，但功能相差比较大，应该划分为两个限界上下文。#2.根据团队粒度做裁剪、根据技术特点做裁剪。一些通用的技术功能应该尽可能归拢到一个限界上下文，比如每个业务限界上下文都有监控，但监控能力应该归拢到监控限界上下文。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;BC与微服务什么关系？微服务是包含高度相关功能的一个开发部署单元，有自己的技术自治性包括技术选型、弹性扩缩容、发布上线频率等，有自己的业务演变自治性。BC是根据领域逻辑的内聚情况形成的一个整体。一个微服务可以包含一个或多个BC，到底包含几个？需要根据团队大小、BC复杂度和技术特性来定。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span data-mce-style=&quot;color: #121212;&quot;&gt;战术设计&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span data-mce-style=&quot;color: #121212;&quot;/&gt;&lt;br/&gt;&lt;span data-mce-style=&quot;color: #121212;&quot;&gt;DDD设计思想里领域建模是最核心的一步，该阶段主要目标是提炼和定义出领域模型和之间的关系。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span data-mce-style=&quot;color: #121212;&quot;&gt;领域建模：建模就是设计的过程，&lt;/span&gt;建模的过程就是梳理、走查业务逻辑，拆解为&lt;span data-mce-style=&quot;color: #121212;&quot;&gt;要解决的问题和涉及的业务场景、业务流程、业务概念，在这个过程中形成对应的领域概念。如果团队对于业务比较陌生适合采用事件风暴方法进行梳理。如果团队对业务比较熟悉，如果业务流程相对简单，则可以采用四色建模法进行业务梳理。采用这些分析业务的方法可以保证产研团队对业务逻辑的理解在一个水平上。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务逻辑的显性表达：在完成了实体和值对象的设计后，有的时候会发现有些概念其实在领域上是存在的，但设计和代码里没有Class来体现，可能仅仅是一个基本类型参数加上散落的对该参数的判断检验逻辑，这个时候还需要思考应该把这个概念显性化，定义专门的Class并包含相应逻辑，入出参以相应Class为类型。但凡业务代码逻辑包含了一堆if-else，这时候需要考虑尽可能给这段逻辑建模成一个领域概念。比如CRM系统里判断一条线索是否为推广线索需要看线索的渠道属性是否来自推广平台，那么比较好的方式是这段逻辑用&quot;推广线索&quot;这个概念来显性表达，而不是淹没在代码里不容易理解和维护。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span data-mce-style=&quot;color: #121212;&quot;&gt;统一语言：&lt;/span&gt;为了解决业务逻辑衔接的问题引入了统一语言。每个业务名词的含义具有明确的定义，产品和研发都统一认识。没有统一语言的沟通严重缺乏效率。比如CRM线索的概念，没有统一语言的时候每个人的理解不一样，有的人理解为有过咨询记录的访客是线索，有的人理解为留下过联系方式的访客是线索，有的人理解为有购买意愿的访客是线索等等。有了统一语言描述，每个概念就有了明确定义，可以节省非常大的沟通交流成本。并且这个概念也同样应用在相关的需求文档、设计文档、代码编写中。每个概念从引入到日常交流，从需求文档到代码实现都有了一致的表达，代码实现和需求描述的真实度高，可理解性和可维护性就变好了。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;技术实现&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分层架构：为了让代码实现围绕领域模型开展，尽量降低业务代码和纯技术选型代码的耦合，DDD引入了分层架构。确保了最&lt;span data-mce-style=&quot;color: #121212;&quot;&gt;核心的领域层不依赖其他层，反过来让领域之外的代码依赖领域代码，降低了技术升级带来的影响。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DDD框架：框架内定义不同领域概念需要实现的接口，比如实现了聚合根接口的实体类就成为了聚合的根实体。定义了异常管理规范，不同的分层应该抛出什么类型的异常。定义了数据访问的资源库接口等等。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;领域事件：领域事件是对领域内发生的活动进行的建模，即聚合内的实体状态变化的一个载体。DDD提倡限界上下文间尽量解耦，尽可能使用发布订阅领域事件的协作模式进行上下游解耦。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h3&gt;&lt;span&gt;2.3 DDD vs 数据模型驱动&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;传统的业务开发模式里，研发受到关系型数据库设计范式、ER图等影响深远，在做软件详细设计过程中往往先想到如何设计对应的表结构，由此倒推出业务逻辑代码该如何组织。这就是典型的数据模型驱动设计，或者叫面向数据表设计编程。数据模型设计关注的是数据存储，数据尽量不要冗余，控制表数量不膨胀。更多考虑数据的扩展性，比如新加一个字段尽量不要在几张表都加，能用一个字段表达就不用两个字段。这样的思维跟DDD是相反的，DDD优先考虑领域概念的业务语义表达，具有独立业务概念的东西会尽量抽象成一个内聚的领域对象。领域对象不仅仅有属性，还有该有的行为。因此基于数据模型驱动的设计结果往往是：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务逻辑代码非常过程式，领域实体只包含一堆属性，只是数据表的映射，没有业务行为。也就是常说的只有getter和setter方法的贫血对象。非常缺乏领域概念的表达，业务逻辑散乱。比如值对象的设计在DDD里是一个类，在数据模型设计里往往是其他类的几个属性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span data-mce-style=&quot;color: #171b1f;&quot;&gt;聚合是DDD最小的复用单元，粒度更粗。数据模型设计里&lt;/span&gt;领域实体的数量跟表数量一一对应，&lt;span data-mce-style=&quot;color: #171b1f;&quot;&gt;数据表是最小的复用单元，粒度太细。&lt;/span&gt;导致业务逻辑对应的实现类需要访问很多的领域实体，实现类之间的调用关系发散而错综复杂。下图是贫血模型和DDD富血模型的区别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibvMESYPPdbrLnQ09VJL3VWrhZicsChOVt1EZNGgMopg0LYfMDzuOBOKK8zdt974wLXw4bn2zop2rJKzvF1qLbZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据表的关系表达很受限，具有主从关系的表之间很难看出主从。在DDD里聚合和聚合内的实体、值对象之间的关系在代码层面有显示的表达。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;当然，DDD思想里不是说不用考虑数据表设计，而是要优先考虑领域概念的识别和建模。表设计需要服务于领域模型的设计，是技术实现的细节。因此明白DDD和数据模型驱动设计的区别反过来能更好地理解DDD。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3. 实践：案列分析&lt;/span&gt;&lt;/h2&gt;&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;3.1 业务背景&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;以爱番番业务中&quot;线索&quot;功能举例，线索管理功能特别多，有创建、清洗、分配、打标签、跟进、回收、退回和转化等十几个管理动作。仅线索创建就分为手工录入创建、文件导入创建、营销系统的后台自动创建、开放平台创建，创建还分为单个创建和批量创建等等。线索这个对象跟其他对象比如客户、商机等联动组合出来很多场景和流程。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;3.2 规划阶段&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;规划阶段需要考虑产品愿景和服务蓝图，需要划分出产品的核心领域，支撑领域，通用领域。如果从0到1开发产品的话规划阶段需要做很多的工作，比如开发一个CRM产品需要考虑产品愿景和服务蓝图，需要聚焦到哪些业务领域，是售前、售中还是售后？售前还可以细分为营销领域还是销售领域等等。百度爱番番致力打造易用的、灵活可配的线索管家功能。因此销售领域的线索功能自然是核心模块。需要提供什么线索功能？需要通过分析阶段来拆解。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;3.3 分析阶段&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;分析阶段是基于业务流程和功能分析出具体的业务对象，不同的业务对象归属划分到限界上下文。因为线索功能复杂，团队对于线索功能认知不一，有必要让相关人员一起采用事件风暴方法来分析和梳理业务。事件风暴认为事件流很⼤程度上反映了现实业务逻辑，参与人员基于领域事件发生的时间线，把事件的前因后果逐步挖掘出来。整个过程包含识别领域事件、决策命令、领域名词三个步骤。通过尝试回答这几个问题：这个业务涉及的系统产生了什么变化？变化由哪个角色通过什么方式触发的？系统变化产生了哪些结果？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于上述步骤，领域专家和相关人员针对线索业务进行事件风暴的结果为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibvMESYPPdbrLnQ09VJL3VWrhZicsChOVtpmtLrNHRHJljFLhDyGpKYibD59ULB1whxdxC1MtPLay65O4PPDauJ0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事件风暴关键图例：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1527777777777778&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibvMESYPPdbrLnQ09VJL3VWrhZicsChOVt6ibbQvTliaUvK8jCVaf8FA2y8AKkInfAHibKV1BB9K6My9X9ibuewCq69w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1008&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事件风暴实践过程的几点tips：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;事件流几乎等同业务逻辑，以此来推敲业务逻辑的严密性，有果必有因。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;紧扣事件要素：事件、规则、名词、命令、角色。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;命名：紧扣业务，不参杂技术元素，警惕使用泛泛的词汇，尽可能地消除命名的⼆义性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;优先关注happy-path即正常路径，聚焦核心领域里的路径。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;事件风暴不是一蹴而就，保持迭代更新。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;基于事件风暴的结果，需要把领域名词和规则等划分到合适的限界上下文。根据前面介绍的如何划分限界上下文的方法，线索相关功能划分为几个限界上下文合适呢？这个时候需要看业务逻辑的复杂程度，还要结合团队规模大小。由于线索功能包含很多业务逻辑，线索归集和创建、线索的分配、线索的跟进等都可以成为一个独立的限界上下文。定义好限界上下文后还需要定义不同限界上下文的协作关系。一般情况下如果业务允许的情况尽量选择通过领域事件来协作。根据《领域驱动设计》所述常见的协作关系还包括开放主机服务（即通过暴露接口）、共享内核、防腐层等9种。微服务架构下的限界上下文之间的关系比较常见的有领域事件、开放主机服务、防腐层等。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;3.4 设计阶段&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;设计阶段就是把分析阶段产出的领域名词，领域事件，决策命令用DDD领域概念来承接，并细化每个领域概念的数据和行为。这也是一种领域建模的过程。建议的建模过程是：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务需求的分析过程自上而下，由业务流程，到用户用例，到领域模型。而设计过程是自下而上的。从领域元素设计开始，最后才是应用服务的编排。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;建议设计优先级是先值对象 → 再实体 → 再聚合 → 再领域服务→ 最后是应用服务，优先考虑领域是否应该为值对象，其次是否为实体，划分出聚合。不属于实体或值对象中的领域行为放到领域服务，需要协调聚合的领域行为设计为领域服务或者应用服务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;任何业务代码逻辑优先映射到原子性的领域模型，比如值对象、实体、领域事件、资源库接口、外部适配接口，其次再映射到组合性领域模型，比如领域服务、应用服务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;建模过程中经常会被问到的问题有：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;值对象可以定义自己的行为吗？【答】可以，尽可能把属于值对象自己的行为放到值对象里。比如联系方式定义成一个值对象，如果它的校验只依赖自身数据，那校验行为应该属于在联系方式这个值对象。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;聚合该设计为多大粒度？【答】&lt;span data-mce-style=&quot;color: #171b1f;&quot;&gt;聚合设计要尽量小，如果一个实体不是根实体，但同时需要被外界直接访问到，那么这个实体不应该在这个聚合中，应该独立成新的聚合。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一个聚合如何访问另外一个聚合？【答】&lt;span data-mce-style=&quot;color: #171b1f;&quot;&gt;只有聚合根才是访问聚合边界的唯一入口，因此一个聚合需要通过另一个的聚合的聚合根来访问它，聚合根可以理解为聚合的根实体的Id。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;应用服务与领域服务的区别？【答】领域服务处在分层架构的领域层，是领域逻辑的一部分。应用服务处在应用层，负责领域模型的编排。当业务逻辑不属于任何聚合时，应该考虑用领域服务来封装这些逻辑。比如判定订单是否重复，应该属于订单限界上下文的一种业务逻辑，订单聚合本身不能判断是否重复，因此订单判重应该定义为领域服务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;应用服务可以直接调用聚合和资源库吗？&lt;span&gt;【答】&lt;/span&gt;可以，可被应用服务编排的对象包括聚合、资源库、领域服务和适配接口。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;领域事件内容是包含整个聚合里的信息，还是身份标识信息(订阅方再通过单独接口根据&lt;span&gt;标识&lt;/span&gt;进行查询)，还是只包含聚合中一些特定的信息？【答】领域事件是用于跟其他聚合协作，事件内容不应是整个聚合，而是经过裁剪的特定信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;根据分析阶段的产出结果，需要把领域名词、规则映射到领域模型。主要几个线索相关领域对象如下图示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibvMESYPPdbrLnQ09VJL3VWrhZicsChOVtraTELBibuuRqpwmPRbELnNv9TomNs8nS18PRibHEhjXCpgZ0icTKqcZ0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;3.5 实现阶段&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;传统的接口-逻辑-数据访问三层架构里，业务逻辑层的XxxServiceImpl类是个上帝类，往往通过过程式业务逻辑实现。&lt;span data-mce-style=&quot;color: #4d4d4d;&quot;&gt;前几行代码做校验，接下来做数据类型转换，然后是业务处理逻辑的代码，中间穿插着通过接口或者dao获取更多的数据，拿到数据后，又是类型转换代码，然后接着一段业务逻辑代码，最后可能还要落库，发布消息等等。这样的代码参杂了太多不同的代码，非常难以维护。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业界自从DDD的分层架构提出后陆续出现过洋葱架构、六边形架构、整洁架构等，其目标都是为了分离业务和技术，保证领域模型的纯粹性。下图是结合业界架构实践后定制的分层架构，具有以下几个特点：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接口层负责对外暴露各种协议的接口比如http、tcp，&lt;span data-mce-style=&quot;color: #262626;&quot;&gt;转换成应用服务能认识的协议。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span data-mce-style=&quot;color: #4d4d4d;&quot;&gt;核心的领域层不依赖其他层，通过资源库包下的接口定义做到依赖倒置，接口参数不能体现具体技术实现细节，领域模型里的实现逻辑只依赖接口。这样做到对领域逻辑的一层防腐。本&lt;/span&gt;层里以聚合为单位放置代码，便于以后系统拆分，以聚合为单位。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;应用层定义应用服务，一个接口对应业务&lt;span data-mce-style=&quot;color: #1a1a1a;&quot;&gt;场景的一个用例&lt;/span&gt;。此外应用层还可以处理横切面事务比如启动数据库事务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;基础设施层完成资源库的实际实现，以及领域层定义的其他接口的实现如对外部服务的访问，领域事件发布到消息队列中间件等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分层架构还定义了每层的项目包结构，不同的领域概念和数据对象相应的命名规范。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8736196319018404&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibvMESYPPdbrLnQ09VJL3VWrhZicsChOVtcPzkTZ8PhmzsDyE3OiawdTUhb8xSDfk16oiccLepPjDA3QfyDTwOwI8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;815&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实现阶段经常会被问到的问题有：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每层应该用什么类型数据对象承载和传递数据？【答】如上面分层架构图所示，接口层和应用服务层用DTO对象传递数据，领域层只能见到领域对象即聚合、实体Entity和值对象VO。应用服务层负责把DTO对象转换成领域对象传输到领域层。基础设施层用PO表示数据表，跟领域层调用时需要把PO和领域对象相互做转换。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;repository和dao的区别？【答】都能访问数据，区别在于访问粒度或边界。repository有边界控制作用，比如不能直接操作值对象对应的表。dao没有边界，想操作哪张表就哪张表。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;领域事件的发布应该在领域层还是应用层？【答】只要不会破坏各层的依赖顺序，在哪发布都行。取决于领域事件定义在哪层？一般推荐定义在领域层的聚合内。当然即便在应用层发布事件也不会破坏依赖方向。因此聚合、领域服务、应用服务都可以发布事件。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;span&gt;3.6 代码示例&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;以java代码为例，DDD骨架代码包含了分层架构，每层就是一个maven pom项目，根据用途定义好了多层包结构，每个领域对象和数据传输对象都有具体的命名方式。基于自研的ddd-framework规范了不同领域对象需要实现的接口或继承于特定的基类。总之尽可能做到了能根据需求文档里的业务逻辑很快找到代码所在之处，让不同的代码待在应该待的分层和包下面。团队成员开玩笑说，现在开发业务代码就像在做填空题，简单直白。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibvMESYPPdbrLnQ09VJL3VWrhZicsChOVtyWvxdFMviawrk2ibJlLOhA1A9vWhaddIaufWPqpEGmosWlKUIicQOcvng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;3.7 收益&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;目前百度爱番番的新服务默认都会在符合DDD架构的骨架代码基础上开发，存量的核心模块也进行过DDD改造。全面实施DDD后产研团队目标更对齐，协作效率更高，收获了很多收益，包括但不限于以下几点：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;产研团队协同成本降低，领域知识得到积累和沉淀。统一语言的使用和维护极大提高了大家对齐的成本。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;业务语义得到显性表达&lt;/span&gt;，业务逻辑内聚可复用程度提高，避免了很多散弹式修改和发散式修改。一个需求不用改多个地方，多个需求也不用几个研发集中改同一个地方。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;限界上下文的划分从业务合理性出发，进而微服务的划分会更合理，减少了团队间的耦合和不必要的协同代价。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接口数量精简、可控。由于业务代码聚焦领域模型，逻辑内聚，复用性高，急剧减少了接口数量，降低接口维护成本。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过预定义好的脚手架创建符合DDD规范的代码骨架，提高了新服务开发的效率。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码可读性高，不是代码作者也能快速定位到代码位置，代码设计能够得到传承，可维护性也提高了。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;新人熟悉新业务和新代码的速度极大提高，业务和技术知识的转移代价减低。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;span&gt;3.8 实践总结&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;从需求到交付的一次典型软件开发流程包括收集提炼需求、需求分析、业务&amp;amp;技术设计、代码实现、测试上线等环节。如何结合软件开发流程，每个流程阶段具体要做什么，怎么做，特别在编码落地阶段该有什么保障措施？爱番番产研团队在落地过程中逐步总结出了一套行之有效的DDD实施指南。包括规划、分析、设计到实现四个阶段对应的方法和产出等实施要点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibvMESYPPdbrLnQ09VJL3VWrhZicsChOVtK6D5ibzPM72b07d7hu129vIkKoR4PXH5On74cpriaSoia4eqbgbQ308OA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;4. 结语：殊途同归、没有银弹&lt;/span&gt;&lt;/h2&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;DDD一方面使用分而治之的思想，引入划分领域、限界上下文、模块分层、划分聚合在不同层次、不同粒度来降低问题的复杂度。另一方主张聚焦领域逻辑，通过不同手段来减少业务和技术的耦合。因此DDD只是大部分软件设计思想一种，软件设计的本质都是为了高内聚低耦合。但是DDD并不是万能的，不是所有业务开发场景都适合用DDD。有些简单业务场景不使用DDD反而更恰当。因为DDD有较高的学习门槛，需要整个团队形成统一认识和协同，需要相应的编码规范和架构落地。因此学习和落地DDD时要时刻记住自己的出发点是为了应对现在或者将来的复杂业务领域而来。不必太拘泥于某些点是否遵守了DDD原则，如果觉得用了DDD会比没有用好一点点，也值得迈出这一步。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;爱番番产研团队始终秉持“以客户为中心”的理念，运用DDD设计思想构建统一的业务模型，实现业务功能的复用和融合。随着爱番番业务的发展，我们相信DDD带来的收益会更大。今后我们会从产品、技术、流程和组织方面持续关注能有效解决软件工程复杂性问题的方法。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;5. 作者介绍&lt;/span&gt;&lt;/h2&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;飞邪，在百度爱番番主要负责销售域和连通域的技术，长期关注技术团队如何高效服务产品团队等研发效能话题，擅长ToB&lt;span&gt;企业级应用&lt;/span&gt;的规划和落地。&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>34cfdde4e985712faee9520465e0d36d</guid>
<title>源码剖析 sync.WaitGroup</title>
<link>https://toutiao.io/k/nqxco3o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;哈喽，大家好，我是&lt;code&gt;asong&lt;/code&gt;，这是我并发编程系列的第三篇文章，上一篇我们一起分析了&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzMDU0MTA3Nw==&amp;amp;mid=2247484505&amp;amp;idx=1&amp;amp;sn=73ab61b21574d6ed1c11b6a5516888b0&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;code&gt;sync.once&lt;/code&gt;的使用与实现&lt;/a&gt;，今天我们一起来看一看&lt;code&gt;sync.WaitGroup&lt;/code&gt;的使用与实现.&lt;/p&gt;&lt;p&gt;快过年了，这是年前最后一篇推文了，待我积累一下，年后加大力度写干货，在这里先预祝大家新春快乐，身体健康，万事如意！&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是&lt;code&gt;sync.WaitGroup&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方文档对&lt;code&gt;sync.WatiGroup&lt;/code&gt;的描述是：一个&lt;code&gt;waitGroup&lt;/code&gt;对象可以等待一组协程结束，也就等待一组&lt;code&gt;goroutine&lt;/code&gt;返回。有了&lt;code&gt;sync.Waitgroup&lt;/code&gt;我们可以将原本顺序执行的代码在多个&lt;code&gt;Goroutine&lt;/code&gt;中并发执行，加快程序处理的速度。其实他与&lt;code&gt;java&lt;/code&gt;中的&lt;code&gt;CountdownLatch&lt;/code&gt;，阻塞等待所有任务完成之后再继续执行。我们来看官网给的一个例子，这个例子使用&lt;code&gt;waitGroup&lt;/code&gt;阻塞主进程，并发获取多个&lt;code&gt;URL&lt;/code&gt;，直到完成所有获取：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; httpPkg &lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(httpPkg)&lt;/span&gt; &lt;span&gt;Get&lt;/span&gt;&lt;span&gt;(url &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; http httpPkg&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; urls = []&lt;span&gt;string&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;&quot;http://www.golang.org/&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;http://www.google.com/&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;http://www.somestupidname.com/&quot;&lt;/span&gt;,&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, url := &lt;span&gt;range&lt;/span&gt; urls {&lt;br/&gt;  &lt;span&gt;// Increment the WaitGroup counter.&lt;/span&gt;&lt;br/&gt;  wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;// Launch a goroutine to fetch the URL.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(url &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// Decrement the counter when the goroutine completes.&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;   &lt;span&gt;// Fetch the URL.&lt;/span&gt;&lt;br/&gt;   http.Get(url)&lt;br/&gt;  }(url)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// Wait for all HTTP fetches to complete.&lt;/span&gt;&lt;br/&gt; wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们需要声明一个&lt;code&gt;sync.WaitGroup&lt;/code&gt;对象，在主&lt;code&gt;gorourine&lt;/code&gt;调用&lt;code&gt;Add()&lt;/code&gt;方法设置要等待的&lt;code&gt;goroutine&lt;/code&gt;数量，每一个&lt;code&gt;Goroutine&lt;/code&gt;在运行结束时要调用&lt;code&gt;Done()&lt;/code&gt;方法，同时使用&lt;code&gt;Wait()&lt;/code&gt;方法进行阻塞直到所有的&lt;code&gt;goroutine&lt;/code&gt;完成。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么要用&lt;code&gt;sync.waitGroup&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在日常开发中为了提高接口响应时间，有一些场景需要在多个&lt;code&gt;goroutine&lt;/code&gt;中做一些互不影响的业务，这样可以节省不少时间，但是需要协调多个&lt;code&gt;goroutine&lt;/code&gt;，没有&lt;code&gt;sync.WaitGroup&lt;/code&gt;的时候，我们可以使用通道来解决这个问题，我们把主&lt;code&gt;Goroutine&lt;/code&gt;当成铜锣扛把子a song，把每一个&lt;code&gt;Goroutine&lt;/code&gt;当成一个马仔，&lt;code&gt;asong&lt;/code&gt;管理这些马仔，让这些马仔去收保护费，我今天派10个马仔去收保护费，每一个马仔收好了保护费就在账本上打一个✅，当所有马仔都收好了保护费，账本上就被打满了✅，活全被干完了，很出色，然后酒吧走起，浪一浪，全场的消费松公子买单，写成代码可以这样表示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;exampleImplWaitGroup&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; done := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{}) &lt;span&gt;// 收10份保护费&lt;/span&gt;&lt;br/&gt; count := &lt;span&gt;10&lt;/span&gt; &lt;span&gt;// 10个马仔&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i:=&lt;span&gt;0&lt;/span&gt;;i &amp;lt; count;i++{&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    done &amp;lt;- &lt;span&gt;struct&lt;/span&gt; {}{}&lt;br/&gt;   }()&lt;br/&gt;   fmt.Printf(&lt;span&gt;&quot;马仔%d号收保护费\n&quot;&lt;/span&gt;,i)&lt;br/&gt;  }(i)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i:=&lt;span&gt;0&lt;/span&gt;;i&amp;lt; count;i++{&lt;br/&gt;  &amp;lt;- done&lt;br/&gt;  fmt.Printf(&lt;span&gt;&quot;马仔%d号已经收完保护费\n&quot;&lt;/span&gt;,i)&lt;br/&gt; }&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;所有马仔已经干完活了，开始酒吧消费～&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然这样可以实现，但是我们每次使用都要保证主&lt;code&gt;Goroutine&lt;/code&gt;最后从通道接收的次数需要与之前其他的&lt;code&gt;Goroutine&lt;/code&gt;发送元素的次数相同，实现起来不够优雅，在这种场景下我们就可以选用&lt;code&gt;sync.WaitGroup&lt;/code&gt;来帮助我们实现同步。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;源码剖析&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们已经知道&lt;code&gt;sync.waitGroup&lt;/code&gt;的基本使用了，接下来我们就一起看看他是怎样实现的～，只有知其所以然，才能写出更健壮的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go version: 1.15.3&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们看一下&lt;code&gt;sync.WaitGroup&lt;/code&gt;的结构：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// A WaitGroup must not be copied after first use.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; WaitGroup &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; noCopy noCopy&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// 64-bit atomic operations require 64-bit alignment, but 32-bit&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// compilers do not ensure it. So we allocate 12 bytes and then use&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// the aligned 8 bytes in them as state, and the other 4 as storage&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// for the sema.&lt;/span&gt;&lt;br/&gt; state1 [&lt;span&gt;3&lt;/span&gt;]&lt;span&gt;uint32&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总共就有两个字段，&lt;code&gt;nocopy&lt;/code&gt;是为了保证该结构不会被进行拷贝，这是一种保护机制，会在后面进行介绍；&lt;code&gt;state1&lt;/code&gt;主要是存储着状态和信号量，这里使用的8字节对齐处理的方式很有意思，我先来一起看看这种处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;state1&lt;/code&gt;状态和信号量处理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;state1&lt;/code&gt;这里总共被分配了&lt;code&gt;12&lt;/code&gt;个字节，这里被设计了三种状态：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;其中对齐的&lt;code&gt;8&lt;/code&gt;个字节作为状态，高&lt;code&gt;32&lt;/code&gt;位为计数的数量，低&lt;code&gt;32&lt;/code&gt;位为等待的&lt;code&gt;goroutine&lt;/code&gt;数量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其中的&lt;code&gt;4&lt;/code&gt;个字节作为信号量存储&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提供了&lt;code&gt;(wg *WaitGroup) state() (statep *uint64, semap *uint32)&lt;/code&gt;帮助我们从&lt;code&gt;state1&lt;/code&gt;字段中取出他的状态和信号量，为什么要这样设计呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在分析&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzMDU0MTA3Nw==&amp;amp;mid=2247484475&amp;amp;idx=1&amp;amp;sn=f470d42fee8b9b65fad7b43e57518cfc&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt;和&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzMDU0MTA3Nw==&amp;amp;mid=2247484529&amp;amp;idx=1&amp;amp;sn=8653947ab70f4d73ff6260965be32460&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Go看源码必会知识之unsafe包&lt;/a&gt;有说到过，64位原子操作需要64位对齐，但是32位编译器不能保证这一点，所以为了保证&lt;code&gt;waitGroup&lt;/code&gt;在&lt;code&gt;32&lt;/code&gt;位平台上使用的话，就必须保证在任何时候，&lt;code&gt;64位&lt;/code&gt;操作不会报错。所以也就不能分成两个字段来写，考虑到字段顺序不同、平台不同，内存对齐也就不同。因此这里采用动态识别当前我们操作的&lt;code&gt;64&lt;/code&gt;位数到底是不是在&lt;code&gt;8&lt;/code&gt;字节对齐的位置上面，我们来分析一下&lt;code&gt;state&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// state returns pointers to the state and sema fields stored within wg.state1.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(wg *WaitGroup)&lt;/span&gt; &lt;span&gt;state&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(statep *&lt;span&gt;uint64&lt;/span&gt;, semap *&lt;span&gt;uint32&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;uintptr&lt;/span&gt;(unsafe.Pointer(&amp;amp;wg.state1))%&lt;span&gt;8&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (*&lt;span&gt;uint64&lt;/span&gt;)(unsafe.Pointer(&amp;amp;wg.state1)), &amp;amp;wg.state1[&lt;span&gt;2&lt;/span&gt;]&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (*&lt;span&gt;uint64&lt;/span&gt;)(unsafe.Pointer(&amp;amp;wg.state1[&lt;span&gt;1&lt;/span&gt;])), &amp;amp;wg.state1[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当数组的首地址是处于一个&lt;code&gt;8&lt;/code&gt;字节对齐的位置上时，那么就将这个数组的前&lt;code&gt;8&lt;/code&gt;个字节作为&lt;code&gt;64&lt;/code&gt;位值使用表示状态，后&lt;code&gt;4&lt;/code&gt;个字节作为&lt;code&gt;32&lt;/code&gt;位值表示信号量(&lt;code&gt;semaphore&lt;/code&gt;)。同理如果首地址没有处于&lt;code&gt;8&lt;/code&gt;字节对齐的位置上时，那么就将前&lt;code&gt;4&lt;/code&gt;个字节作为&lt;code&gt;semaphore&lt;/code&gt;，后&lt;code&gt;8&lt;/code&gt;个字节作为&lt;code&gt;64&lt;/code&gt;位数值。画个图表示一下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5035335689045937&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/k5430ljpYPMTBgLCzxHx0PE85G9T929DUa2Yq3kjHDj18c6VH0UyZsuXp8ia6aQHdbtTuffCfeNlOTRmFicqnDqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;566&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;Add()&lt;/code&gt;、&lt;code&gt;Done()&lt;/code&gt;方法&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sync.WaitGroup&lt;/code&gt;提供了&lt;code&gt;Add()&lt;/code&gt;方法增加一个计数器，&lt;code&gt;Done()&lt;/code&gt;方法减掉一个计数，&lt;code&gt;Done()&lt;/code&gt;方法实现比较简单，内部调用的&lt;code&gt;Add()&lt;/code&gt;方法实现的计数器减一操作，也就是增减逻辑都在&lt;code&gt;Add()&lt;/code&gt;方法中，所以我们重点看一下&lt;code&gt;Add()&lt;/code&gt;是如何实现的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(wg *WaitGroup)&lt;/span&gt; &lt;span&gt;Add&lt;/span&gt;&lt;span&gt;(delta &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 获取状态(Goroutine Counter 和 Waiter Counter)和信号量&lt;/span&gt;&lt;br/&gt; statep, semap := wg.state()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; race.Enabled {&lt;br/&gt;  _ = *statep &lt;span&gt;// trigger nil deref early&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; delta &amp;lt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// Synchronize decrements with Wait.&lt;/span&gt;&lt;br/&gt;   race.ReleaseMerge(unsafe.Pointer(wg))&lt;br/&gt;  }&lt;br/&gt;  race.Disable()&lt;br/&gt;  &lt;span&gt;defer&lt;/span&gt; race.Enable()&lt;br/&gt; }&lt;br/&gt;  &lt;span&gt;// 原子操作，goroutine counter累加delta&lt;/span&gt;&lt;br/&gt; state := atomic.AddUint64(statep, &lt;span&gt;uint64&lt;/span&gt;(delta)&amp;lt;&amp;lt;&lt;span&gt;32&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;// 获取当前goroutine counter的值(高32位)&lt;/span&gt;&lt;br/&gt; v := &lt;span&gt;int32&lt;/span&gt;(state &amp;gt;&amp;gt; &lt;span&gt;32&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;// 获取当前waiter counter的值(低32位)&lt;/span&gt;&lt;br/&gt; w := &lt;span&gt;uint32&lt;/span&gt;(state)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; race.Enabled &amp;amp;&amp;amp; delta &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; v == &lt;span&gt;int32&lt;/span&gt;(delta) {&lt;br/&gt;  &lt;span&gt;// The first increment must be synchronized with Wait.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// Need to model this as a read, because there can be&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// several concurrent wg.counter transitions from 0.&lt;/span&gt;&lt;br/&gt;  race.Read(unsafe.Pointer(semap))&lt;br/&gt; }&lt;br/&gt;  &lt;span&gt;// Goroutine counter是不允许为负数的，否则会发生panic&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; v &amp;lt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;panic&lt;/span&gt;(&lt;span&gt;&quot;sync: negative WaitGroup counter&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;  &lt;span&gt;// 当wait的Goroutine不为0时，累加后的counter值和delta相等,说明Add()和Wait()同时调用了,所以发生panic,因为正确的做法是先Add()后Wait()，也就是已经调用了wait()就不允许再添加任务了&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; w != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; delta &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; v == &lt;span&gt;int32&lt;/span&gt;(delta) {&lt;br/&gt;  &lt;span&gt;panic&lt;/span&gt;(&lt;span&gt;&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;  &lt;span&gt;// 正常`Add()`方法后，`goroutine Counter`计数器大于0或者`waiter Counter`计数器等于0时，不需要释放信号量&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; v &amp;gt; &lt;span&gt;0&lt;/span&gt; || w == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 能走到这里说明当前Goroutine Counter计数器为0，Waiter Counter计数器大于0, 到这里数据也就是允许发生变动了，如果发生变动了，则出发panic&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; *statep != state {&lt;br/&gt;  &lt;span&gt;panic&lt;/span&gt;(&lt;span&gt;&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 重置状态，并发出信号量告诉wait所有任务已经完成&lt;/span&gt;&lt;br/&gt; *statep = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; ; w != &lt;span&gt;0&lt;/span&gt;; w-- {&lt;br/&gt;  runtime_Semrelease(semap, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码有一部分是&lt;code&gt;race&lt;/code&gt;静态检测，下面的分析会省略这一部分，因为它并不是本文的重点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注释我都添加到对应的代码行上了，你是否都看懂了，没看懂不要紧，因为&lt;code&gt;Add()&lt;/code&gt;是与&lt;code&gt;Wait()&lt;/code&gt;方法一块使用的，所以有些逻辑与&lt;code&gt;wait()&lt;/code&gt;里的逻辑是相互照应的，所以当我们看完&lt;code&gt;wait()&lt;/code&gt;方法的实现在总结一下你们就明白了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;Wait()&lt;/code&gt;方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sync.Wait()&lt;/code&gt;方法会阻塞主&lt;code&gt;Goroutine&lt;/code&gt;直到&lt;code&gt;WaitGroup&lt;/code&gt;计数器变为0。我们一起来看一下&lt;code&gt;Wait()&lt;/code&gt;方法的源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Wait blocks until the WaitGroup counter is zero.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(wg *WaitGroup)&lt;/span&gt; &lt;span&gt;Wait&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 获取状态(Goroutine Counter 和 Waiter Counter)和信号量&lt;/span&gt;&lt;br/&gt; statep, semap := wg.state()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; race.Enabled {&lt;br/&gt;  _ = *statep &lt;span&gt;// trigger nil deref early&lt;/span&gt;&lt;br/&gt;  race.Disable()&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 使用原子操作读取state，是为了保证Add中的写入操作已经完成&lt;/span&gt;&lt;br/&gt;  state := atomic.LoadUint64(statep)&lt;br/&gt;    &lt;span&gt;// 获取当前goroutine counter的值(高32位)&lt;/span&gt;&lt;br/&gt;  v := &lt;span&gt;int32&lt;/span&gt;(state &amp;gt;&amp;gt; &lt;span&gt;32&lt;/span&gt;)&lt;br/&gt;     &lt;span&gt;// 获取当前waiter counter的值(低32位)&lt;/span&gt;&lt;br/&gt;  w := &lt;span&gt;uint32&lt;/span&gt;(state)&lt;br/&gt;    &lt;span&gt;// 如果没有任务，或者任务已经在调用`wait`方法前已经执行完成了，就不用阻塞了&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; v == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// Counter is 0, no need to wait.&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; race.Enabled {&lt;br/&gt;    race.Enable()&lt;br/&gt;    race.Acquire(unsafe.Pointer(wg))&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 使用CAS操作对`waiter Counter`计数器进行+1操作，外面有for循环保证这里可以进行重试操作&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; atomic.CompareAndSwapUint64(statep, state, state+&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; race.Enabled &amp;amp;&amp;amp; w == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// Wait must be synchronized with the first Add.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Need to model this is as a write to race with the read in Add.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// As a consequence, can do the write only for the first waiter,&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// otherwise concurrent Waits will race with each other.&lt;/span&gt;&lt;br/&gt;    race.Write(unsafe.Pointer(semap))&lt;br/&gt;   }&lt;br/&gt;      &lt;span&gt;// 在这里获取信号量，使线程进入睡眠状态，与Add方法中最后的增加信号量相对应，也就是当最后一个任务调用Done方法&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// 后会调用Add方法对goroutine counter的值减到0，就会走到最后的增加信号量&lt;/span&gt;&lt;br/&gt;   runtime_Semacquire(semap)&lt;br/&gt;      &lt;span&gt;// 在Add方法中增加信号量时已经将statep的值设为0了，如果这里不是0，说明在wait之后又调用了Add方法，使用时机不对，触发panic&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; *statep != &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;panic&lt;/span&gt;(&lt;span&gt;&quot;sync: WaitGroup is reused before previous Wait has returned&quot;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; race.Enabled {&lt;br/&gt;    race.Enable()&lt;br/&gt;    race.Acquire(unsafe.Pointer(wg))&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;源码总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分了源码，我们可以总结如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Add&lt;/code&gt;方法与&lt;code&gt;wait&lt;/code&gt;方法不可以并发同时调用，&lt;code&gt;Add&lt;/code&gt;方法要在&lt;code&gt;wait&lt;/code&gt;方法之前调用.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Add()&lt;/code&gt;设置的值必须与实际等待的&lt;code&gt;goroutine&lt;/code&gt;个数一致，否则会&lt;code&gt;panic&lt;/code&gt;.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用了&lt;code&gt;wait&lt;/code&gt;方法后，必须要在&lt;code&gt;wait&lt;/code&gt;方法返回以后才能再次重新使用&lt;code&gt;waitGroup&lt;/code&gt;，也就是&lt;code&gt;Wait&lt;/code&gt;没有返回之前不要在调用&lt;code&gt;Add&lt;/code&gt;方法，否则会发生&lt;code&gt;Panic&lt;/code&gt;.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Done&lt;/code&gt; 只是对&lt;code&gt;Add&lt;/code&gt; 方法的简单封装，我们可以向 &lt;code&gt;Add&lt;/code&gt;方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒等待的 &lt;code&gt;Goroutine&lt;/code&gt;.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;waitGroup&lt;/code&gt;对象只能有一份，不可以拷贝给其他变量，否则会造成意想不到的&lt;code&gt;Bug&lt;/code&gt;.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;no copy&lt;/code&gt;机制&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前文看&lt;code&gt;waitGroup&lt;/code&gt;结构时，有一个&lt;code&gt;nocopy&lt;/code&gt;字段，为什么要有&lt;code&gt;nocopy&lt;/code&gt;呢？我们先看这样一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; User &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Name &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; Info *Info&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Info &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Age &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; Number &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; u := User{&lt;br/&gt;  Name: &lt;span&gt;&quot;asong&quot;&lt;/span&gt;,&lt;br/&gt;  Info: &amp;amp;Info{&lt;br/&gt;   Age: &lt;span&gt;10&lt;/span&gt;,&lt;br/&gt;   Number: &lt;span&gt;24&lt;/span&gt;,&lt;br/&gt;  },&lt;br/&gt; }&lt;br/&gt; u1 := u&lt;br/&gt; u1.Name = &lt;span&gt;&quot;Golang梦工厂&quot;&lt;/span&gt;&lt;br/&gt; u1.Info.Age = &lt;span&gt;30&lt;/span&gt;&lt;br/&gt; fmt.Println(u.Info.Age,u.Name)&lt;br/&gt; fmt.Println(u1.Info.Age,u1.Name)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;30&lt;/span&gt; asong&lt;br/&gt;&lt;span&gt;30&lt;/span&gt; Golang梦工厂&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结构体&lt;code&gt;User&lt;/code&gt;中有两个字段&lt;code&gt;Name&lt;/code&gt;和&lt;code&gt;Info&lt;/code&gt;，&lt;code&gt;Name&lt;/code&gt;是&lt;code&gt;String&lt;/code&gt;类型，&lt;code&gt;Info&lt;/code&gt;是指向结构体&lt;code&gt;Info&lt;/code&gt;的指针类型，我们首先声明了一个&lt;code&gt;u&lt;/code&gt;变量，对他进行复制拷贝得到变量&lt;code&gt;u1&lt;/code&gt;，在&lt;code&gt;u1&lt;/code&gt;中对两个字段进行改变，可以看到&lt;code&gt;Info&lt;/code&gt;字段发生了更改，而&lt;code&gt;Name&lt;/code&gt;就没发生更改，这就引发了安全问题，如果结构体对象包含指针字段，当该对象被拷贝时，会使得两个对象中的指针字段变得不再安全。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Go&lt;/code&gt;语言中提供了两种&lt;code&gt;copy&lt;/code&gt;检查，一种是在运行时进行检查，一种是通过静态检查。不过运行检查是比较影响程序的执行性能的，Go官方目前只提供了strings.Builder和sync.Cond的runtime拷贝检查机制，对于其他需要nocopy对象类型来说，使用go vet工具来做静态编译检查。运行检查的实现可以通过比较所属对象是否发生变更&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.525&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/k5430ljpYPMTBgLCzxHx0PE85G9T929DPqcYAibk3gOaZtOr2TI55gVia1KCHlBgrvre0ytHe4j9wBwgEGgia9lJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就可以判断，而静态检查是提供了一个&lt;code&gt;nocopy&lt;/code&gt;对象，只要是该对象或对象中存在&lt;code&gt;nocopy&lt;/code&gt;字段，他就实现了&lt;code&gt;sync.Locker&lt;/code&gt;接口, 它拥有Lock()和Unlock()方法，之后，可以通过go vet功能，来检查代码中该对象是否有被copy。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;踩坑事项&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在文章的最后总结一下使用&lt;code&gt;waitGroup&lt;/code&gt;易错的知识点，防止大家再次犯错。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;waitGroup&lt;/code&gt;中计数器的值是不能小于0的，源码中我们就可以看到，一旦小于0就会引发panic。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一定要住注意调用&lt;code&gt;Add&lt;/code&gt;方法与&lt;code&gt;Wait&lt;/code&gt;方法的顺序，不可并发同时调用这两个方法，否则就会引发panic，同时在调用了&lt;code&gt;wait&lt;/code&gt;方法在其没有释放前不要再次调用&lt;code&gt;Add&lt;/code&gt;方法，这样也会引发&lt;code&gt;panic&lt;/code&gt;，&lt;code&gt;waitGroup&lt;/code&gt;是可以复用的，但是需要保证其计数周期的完整性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;WaitGroup&lt;/code&gt;对象不是一个引用类型，通过函数传值的时候需要使用地址，因为&lt;code&gt;Go&lt;/code&gt;语言只有值传递，传递&lt;code&gt;WaitGroup&lt;/code&gt;是值的话，就会导致会发生&lt;code&gt;panic&lt;/code&gt;，看这样一个例子：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; wg := sync.WaitGroup{}&lt;br/&gt; wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt; doDeadLock(wg)&lt;br/&gt; wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;doDeadLock&lt;/span&gt;&lt;span&gt;(wg sync.WaitGroup)&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;do something&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//运行结果：panic: sync: negative WaitGroup counter&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发生这个问题的原因就是在&lt;code&gt;doDeadLock()&lt;/code&gt;方法中&lt;code&gt;wg&lt;/code&gt;是一个新对象，直接调用&lt;code&gt;Done&lt;/code&gt;方法，计数器就会出现负数，所以引发&lt;code&gt;panic&lt;/code&gt;，为了安全起见，对于这种传结构体的场景一般建议都传指针就好了，基本可以避免一些问题。&lt;/p&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Add()设置的值必须与实际等待的goroutine个数一致，否则会&lt;code&gt;panic&lt;/code&gt;，很重要的一点，也是很容易出错的地方。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;思考题&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后给大家出一个思考题，下面这段代码会不会发生&lt;code&gt;panic&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; wg := sync.WaitGroup{}&lt;br/&gt; wg.Add(&lt;span&gt;100&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++ {&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;   fmt.Println(i)&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt; wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结尾&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在最后，祝大家新年快乐，心想事成，万事如意～～～&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;好啦，这篇文章就到这里啦，素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：加我vx拉你入群，或者公众号获取入群二维码&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我是asong，一名普普通通的程序猿，让我们一起慢慢变强吧。欢迎各位的关注，我们下期见~~~&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/k5430ljpYPMTBgLCzxHx0PE85G9T929DWhOUXLOSKsqZcdFwSGPia5tZRIHg8uticVPY9lJTI82Cl23W1EPkhLHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐往期文章：&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>