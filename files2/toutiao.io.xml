<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2b2e79f82840def05f6cf5466b4f2abd</guid>
<title>读者诉苦：Redis 宕机，数据丢了，老板要辞退我</title>
<link>https://toutiao.io/k/xa7jahy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是Tom哥~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近跟一位读者聊天，小哥非常郁闷，公司的Redis宕机了，线上业务受到了影响，老板非常愤怒，小哥担心会不会被辞退！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我也很好奇，问小哥Redis主节点挂了，还有备机啊。怎么会影响到业务呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小哥说，他们的系统架构只部署一个Redis单实例。节点挂了，数据也丢了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9Yshwd3OukgnlK7bFxjfRyqeUbh7ZuYw10eCACPJ8Ikuibe3R1vCQgJXZ9aITaUDpdE4shXKjjb8ZMpXfw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;225&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好吧，既然提到了备份，那今天，我们就来聊下 Redis的主从同步&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;首先，什么是主从？&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主从也称主从集群，部署了多个Redis实例，如下图所示：&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8604651162790697&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9Yshwd3OukgnlK7bFxjfRyqeUbhRtbSrB1Yj0LlJ0LhbVTA9YjHicicEqiatCUy2OcTqGVq1hrEd2eool9aw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;688&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，每个实例又有自己的专属职责&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;主库：负责接收读操作、写操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从库：定期同步主库的数据，对外提供读操作&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;好奇的宝宝可能要问了，为什么从库不能写？&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考虑到数据合并的复杂性，假如一个key，多次更新，每次操作在不同的实例上执行，为了保证数据的全局一致性，势必要加全局锁，保证在集群范围上串行化操作且在最新的数据基础上更新，这个成本还是很大的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了降低系统复杂度，节约成本。主从同步架构方案一般都是在主库上写，在从库上读。分工明确，职责单一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能有同学会提到 Redis Cluster 模式，这个是另一种设计方案。采用水平分割方式，通过CRC16（key）算法，将数据拆分到若干个实例中，每个实例只对自己负责的槽位的数据读、写，从而分摊集群压力。这个属于另一种玩法，本期就不深入展开了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为了保证数据不丢失，Redis提供两种数据同步方式&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、RDB，全量数据同步&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、AOF，增量数据同步，回放日志&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两者有什么区别？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么时候采用 RDB ? 什么时候采用 AOF ?&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们逐步分析展开&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;建立主从关系&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，启动两个redis 实例，IP地址分别是 &lt;code&gt;192.168.0.1&lt;/code&gt; 和 &lt;code&gt;192.168.0.2&lt;/code&gt; ，开始时，他们之间没有任何关联。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过终端命令，登录 &lt;code&gt;192.168.0.2&lt;/code&gt; 机器，执行命令&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;replicaof 192.168.0.1 6379&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时 &lt;code&gt;192.168.0.2&lt;/code&gt; 实例就成了  &lt;code&gt;192.168.0.1&lt;/code&gt;  的从库。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.5804878048780489&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9Yshwd3OukgnlK7bFxjfRyqeUbhSDic3NicyUKICzzlLyWx63mgvMTaGQ9rmwDLsEy0wNZh6ic6R4SRQOPDQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;410&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当主从实例建立好关联后，接下来，就开始进入数据同步环节&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主从同步&lt;/strong&gt;&lt;/h3&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7664783427495292&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9Yshwd3OukgnlK7bFxjfRyqeUbhTfxrVSf2vXcoate8uLqDQ9xJwoEDM4645PNL8GxRzCllXNm4d8MSzA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1062&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;strong&gt;主从库数据同步分为三步：&lt;/strong&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1、第一步&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从库（192.1768.0.2）向主库（192.168.0.1）发送 psync 命令，带了两个参数（主库的runID和同步进度offset）。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一次建立连接时，从库并不知道主库的runID，所以会设置为 ？。offset = -1，表示第一次复制。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;说明：每个 Redis 实例初始启动时，会自动生成一个随机ID，用来标识当前实例。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主库接收到psync请求后，会响应 FULLRESYNC ，带有两个参数（主库的runID和同步进度offset）&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;说明：FULLRESYNC 表示采用全量复制&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2、第二步&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;主库fork子进程，执行 &lt;code&gt;bgsave&lt;/code&gt; 命令，生成 RDB 文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主库将 RDB 文件发给从库&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从库接到响应后，会先清空当前数据库，然后加载 RDB 文件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;说明：主库在生成RDB文件时，主线程是阻塞的，对外不提供服务。一旦RDB文件生成，在数据同步过程中，不受影响，主库可以对外服务。后续的写命令数据会存到 replication buffer&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3、第三步&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主库将增量写命令发送给从库，从库放映式执行这些命令，从而实现了主从同步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，主从的核心逻辑基本讲完了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但生产环境，通常是一主多从，每个从库初始同步时，都要主库生成RDB文件，显然开销很大。有什么解决方案？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一主多从，主库减压&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当从节点存在多个时，主库的压力显著增加，具体体现在两个方面：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、当从库同步主库时，要fork子进程，有多少个从节点，就要fork多少个子进程，每个子进程都要生成RDB。导致主库系统压力过大&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、生成的RDB要同步给从库，占用网络带宽&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于上面的困境，演化出新的模式，“主--从--从”模式，具体玩法如下图：&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8278829604130808&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9Yshwd3OukgnlK7bFxjfRyqeUbhCgbznqzqtP1C9WLbC1tOcTf4BKn0LIxKBrD5cYyhUicE5CuxQQTJIJw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1162&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现有虽然有四个从库，但直接跟主库关联同步数据的只有 &lt;code&gt;192.168.0.2&lt;/code&gt; 和 &lt;code&gt;192.168.0.3&lt;/code&gt; 两个实例，大大减轻了主库的压力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任何事情都不是一成不变的，网络传输就存在很大的风险，网络闪断了怎么办？对主从同步有什么影响？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;网络闪断对主从同步的影响&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道主从实例间同步数据主要有两种方式：&lt;code&gt;全量同步&lt;/code&gt; 和 &lt;code&gt;增量同步&lt;/code&gt; 。 全量同步就是同步RDB文件，那增量同步是如何实现的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里要引入一个缓冲区，&lt;code&gt;repl_backlog_buffer&lt;/code&gt;，它是一个环形设计，增量命令都是先存入这个缓冲区的。主库有生产位移，称之为&lt;code&gt;master_repl_offset&lt;/code&gt; 。从库有拉取位移，称之为&lt;code&gt;slave_repl_offset&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.56796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9Yshwd3OukgnlK7bFxjfRyqeUbhKRjXG3VTRxgeZTAzHOBwdHiakxLRsruaUoXkmSggUPcN9fv3HHrNEqA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常情况下，&lt;code&gt;master_repl_offset&lt;/code&gt; 和 &lt;code&gt;slave_repl_offset&lt;/code&gt; 大小是接近的，也就是说主从库两者间的数据近乎同步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次同步数据时，从库向主库发送 psync 命令，把自己的 &lt;code&gt;slave_repl_offset&lt;/code&gt; 发给主库，主库基于此偏移位置，向从库发送增量数据。这个很容易理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是就万无一失了呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于采用了环形结构，如果主库的生产速度比从库的拉取速度快很多时，就会出现套圈现象。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;为什么采用环形？主要为了让空间循环使用，像市场的行车记录仪、监控设备等，大多都是采用循环覆盖式存储。如果空间满了，将之前最老的数据覆盖掉。虽然可能丢失了部分数据，但是性价比高。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到上面的问题，如果被套圈了怎么办？&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.58828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9Yshwd3OukgnlK7bFxjfRyqeUbhCtywZ8LVEcp11eMcXlnObattJriba7skL6s6MibRqVJyiap32rv96wdkQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，从库 psync 命令，请求的offset 是 4，但是主节点已经生产到了 15 ，将之前的 1、2、3、4、5 全部覆盖掉了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这下傻眼了，需要同步的数据被覆盖了，惹大麻烦了....&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9Yshwd3OukgnlK7bFxjfRyqeUbhRANcZaeKlcOLaof69Taq5IDX2AnnfrjibDT3PtN6BhQEibCyUdzQm79Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;225&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;有两个解决方案：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、调大 &lt;code&gt;repl_backlog_buffer&lt;/code&gt; 缓冲区大小，该值是由 &lt;code&gt;repl_backlog_size&lt;/code&gt;参数控制&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;缓冲空间大小 = 主库写入速度 * 操作大小 - 从库拉取速度 * 操作大小&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是我们能主观控制的。比如担心大促带来的流量高峰，可以将这个值调大2倍、3倍、4倍，大家可以根据自己的业务情况自由设置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、还有一种方式是Redis 自身提供的解决方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时会触发&lt;code&gt;全量复制&lt;/code&gt;，跟第一次建立主从关系同步数据一样。通过全量方式，一次性弥补主从间的数据大缺口。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主节&lt;/strong&gt;&lt;strong&gt;点挂了怎么办&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只是传统意义上的主从模式，主节点挂了，通常要手工完成切换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;效率不言而喻了，尤其是线上生产系统，根本没法接受这种方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，要引入哨兵机制了，哨兵机制可以实现主从库的自动切换，有效解决了故障转移。整个过程分为三个阶段：监控、选主、通知。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、监控。哨兵进程会周期给所有的主库、从库发送 PING 命令，检测机器是否处于服务状态。如果没有在设置时间内收到回复，则判定为下线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;当然，网络抖动，也会存在误判可能，如何避免？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入哨兵集群，多个哨兵实例一起判断，降低误判率。判断标准就是，假如 n 个哨兵实例，至少有 n/2+1 个判定一致，才可以定论。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、选主。主要是看各个节点的打分情况，打分规则分为 &lt;code&gt;从库优先级&lt;/code&gt;、&lt;code&gt;从库复制进度&lt;/code&gt;、&lt;code&gt;从库ID号&lt;/code&gt;。只要有一轮，某个从库得分最高，则选举它为主库。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从库优先级，主要是考虑到不同的机器可能配置不一样，配置高的机器，优先级高一些，通过&lt;code&gt;slave-priority&lt;/code&gt; 来配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从库复制进度，主要是看&lt;code&gt;slave_repl_offset&lt;/code&gt; 的值大小，值越大表示已经同步的数据越多，得分越高。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从库ID号，每个Redis 实例启动时，都会生成一个 ID，在优先级和复制进度相同的条件下，ID号最小的从库分数最高，会被选为新主库。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、通知。把选举后的新主库发送给所有节点，让所有的从库执行 &lt;code&gt;replicaof&lt;/code&gt; 命令，和master建立主从关系、数据同步复制。另外，也会把最新的主库信息同步给客户端。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于我：Tom哥，前阿里P7技术专家，出过专利，多年大厂实战经验。欢迎关注，我会持续输出更多经典原创文章，为你大厂助力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;欢迎小伙伴找Tom哥唠嗑聊天， 技术交流，围观朋友圈，人生&lt;span&gt;打怪&lt;/span&gt;不再寂寞。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100003916&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.069090909090909&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwcdJhGaQRdAk0VWLIAIU548z3Izf6mwqwwUX9X86hvNHZq158VYMEaxegjfRg8ic02O0HeWD4xIsiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247487139&amp;amp;idx=1&amp;amp;sn=4ae53bf8e20aab324f58e85deedff42a&amp;amp;chksm=ceb9f208f9ce7b1e5d2882601ff2890ae9bef5584b6730c2b0b30c527340b4529b85cc636954&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;团队管理那点破事！OKR绩效、核心人才、面试、技术分享、研发流程....&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247486515&amp;amp;idx=1&amp;amp;sn=62a75d90d76a7f0c4cb01a64db8f4e2e&amp;amp;chksm=ceb9f098f9ce798eafec5c1e01aaeaedc00163e5c4925931da7a1b6184365d474fb1562cb664&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Redis缓存那点破事 | 绝杀面试官 25 问！&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247486281&amp;amp;idx=1&amp;amp;sn=2c0fc614dd94c93aa1172413fb340c6d&amp;amp;chksm=ceb9f7e2f9ce7ef46b0832f69b2e6e6e66d1d10c6db94fedb381da886894a1a622086e64f68a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;MYSQL 那点破事！索引、SQL调优、事务、B+树、分表 ....&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247485888&amp;amp;idx=1&amp;amp;sn=60304679c226fb6b2ebaba5bb6ad5485&amp;amp;chksm=ceb9f56bf9ce7c7d7c87fa4aa7cb70aba7af6b4aefbf1f8b3e331d5a443ccc91b3ba2fb95b9e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;TCP网络那点破事！三次握手、四次挥手、TIME-WAIT ....&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原创不易，看到这里，还请点个&lt;/span&gt;&lt;span&gt;「赞」&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;「在看」&lt;/span&gt;&lt;span&gt;，谢谢大家支持&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1e463d15a0d4b3657d7ffb494e66c31b</guid>
<title>GitHub上有不错的 C 开源项目？</title>
<link>https://toutiao.io/k/ijt6ncp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;

                

                
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fcf2c8f3d5b3fc1c9b8e911fcb9f79e2</guid>
<title>云原生 Spring Boot 应用配置 Prometheus + Grafana 监控（保姆级）</title>
<link>https://toutiao.io/k/d24s5yw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;markdown编辑器&quot; data-website=&quot;https://markdown.com.cn/editor&quot;&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;最近想要配置Spring Boot应用Prometheus+Grafana监控的demo，发现网上的很多中英文资料，内容过时或者配置不对。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;因此写一个文章来说明整个体系是怎么工作的。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;Demo的源码地址：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;https://github.com/hengyunabc/spring-boot-prometheus-grafana-demo&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;spring boot应用metrics配置&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;首先，我们直接到官网创建一个spring boot demo应用：&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;创建好后，我们在&lt;code&gt;pom.xml&lt;/code&gt;里加入下面的依赖：&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-actuator&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;io.micrometer&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;micrometer-registry-prometheus&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;spring-boot-starter-actuator 支持spring boot暴露http endpoint&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;micrometer-registry-prometheus 支持prometheus endpoint，这个暴露的是&lt;code&gt;OpenMetrics&lt;/code&gt;的格式，prometheus从这里采集数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;再看下 &lt;code&gt;application.properties&lt;/code&gt;文件：&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;spring.application.name=expose-prometheus-demo&lt;br/&gt;server.port=8080&lt;br/&gt;&lt;br/&gt;management.endpoints.web.exposure.include=*&lt;br/&gt;management.server.port=8090&lt;br/&gt;management.metrics.tags.application=${spring.application.name}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;management.server.port&lt;/code&gt;配置endpoint为独立端口，和应用混用同一端口容易有安全问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;management.metrics.tags.application&lt;/code&gt;配置metric里&lt;code&gt;application&lt;/code&gt;的tag&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;本地启动应用之后，访问 http://localhost:8090/actuator/prometheus ，可以看到metrics数据里带上了&lt;code&gt;application&lt;/code&gt;的tag：&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;# TYPE jvm_classes_unloaded_classes_total counter&lt;br/&gt;jvm_classes_unloaded_classes_total{application=&quot;expose-prometheus-demo&quot;,} 0.0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置k8s环境&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;启动minikube k8s集群&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;minikube start --image-mirror-country=&#x27;cn&#x27; --nodes 2 --kubernetes-version=v1.18.3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;$ kubectl get nodes&lt;br/&gt;NAME           STATUS     ROLES    AGE   VERSION&lt;br/&gt;minikube       Ready      master   65s   v1.18.3&lt;br/&gt;minikube-m02   NotReady   &amp;lt;none&amp;gt;   30s   v1.18.3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;构建docker镜像&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;打包spring boot fat jar：&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;./mvnw clean package -DskipTests&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;docker build . -t hengyunabc/expose-prometheus-demo:0.0.1-SNAPSHOT&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;本地启动测试：&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;docker run -it -p8080:8080 -p8090:8090 hengyunabc/expose-prometheus-demo:0.0.1-SNAPSHOT&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;访问：http://localhost:8090/actuator/prometheus&lt;/p&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;安装prometheus&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;helm repo add prometheus-community https://prometheus-community.github.io/helm-charts&lt;br/&gt;helm repo update&lt;br/&gt;helm install prometheus prometheus-community/kube-prometheus-stack&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;开启Prometheus UI端口转发：&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;kubectl port-forward $(kubectl get pods --selector &quot;app.kubernetes.io/name=prometheus&quot; --output=name) 9090&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;开启grafana UI端口转发：&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;kubectl port-forward $(kubectl get pods --selector &quot;app.kubernetes.io/name=grafana&quot; --output=name) 3000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;发布spring boot应用到k8s&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;kubectl apply -f ./servicemonitor-deployment.yaml&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;在&lt;code&gt;servicemonitor-deployment.yaml&lt;/code&gt;里定义了三个东东。要注意的是&lt;code&gt;Service&lt;/code&gt;和&lt;code&gt;ServiceMonitor&lt;/code&gt;都要打上label: &lt;code&gt;release: prometheus&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;Deployment&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;apps/v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Deployment&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;expose-prometheus-demo&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;expose-prometheus-demo&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;replicas:&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;selector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;matchLabels:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;expose-prometheus-demo&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;template:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;expose-prometheus-demo&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;containers:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;expose-prometheus-demo&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;hengyunabc/expose-prometheus-demo:0.0.1-SNAPSHOT&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;imagePullPolicy:&lt;/span&gt; &lt;span&gt;Always&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;containerPort:&lt;/span&gt; &lt;span&gt;8080&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;containerPort:&lt;/span&gt; &lt;span&gt;8090&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;Service&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;expose-prometheus-demo-service&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;expose-prometheus-demo&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;release:&lt;/span&gt; &lt;span&gt;prometheus&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;selector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;expose-prometheus-demo&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;protocol:&lt;/span&gt; &lt;span&gt;TCP&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;http-traffic&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;8080&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;targetPort:&lt;/span&gt; &lt;span&gt;8080&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;protocol:&lt;/span&gt; &lt;span&gt;TCP&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;metric-traffic&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;8090&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;targetPort:&lt;/span&gt; &lt;span&gt;8090&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;ServiceMonitor&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;monitoring.coreos.com/v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;ServiceMonitor&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;expose-prometheus-demo-service-monitor&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;expose-prometheus-demo&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;release:&lt;/span&gt; &lt;span&gt;prometheus&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;selector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;matchLabels:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;expose-prometheus-demo&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;endpoints:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;metric-traffic&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;path:&lt;/span&gt; &lt;span&gt;&quot;/actuator/prometheus&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;应用发布到k8s里之后，访问Prometheus UI，可以查看到是否发现了demo的&lt;code&gt;Service Discovery&lt;/code&gt;&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;http://localhost:9090/service-discovery&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.32421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2CINxh93CWSrL4e0XsZg6Iib6iccgw0JzgxMibHXuJR7yk7tIBsLsViciajDZfzUIXCD4eVhd77VficGibeZLpYMwyIEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;工作原理&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;下面分两部分详细解析下整个流程是怎么工作的。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;第一部分：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;spring boot应用通过引入&lt;code&gt;prometheus&lt;/code&gt; endpoint，数据暴露在 http://localhost:8090/actuator/prometheus&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;prometheus已在k8s里部署好，它是一个无情的抓取机器，现在要想办法让它去拉spring boot应用的数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;prometheus的运行里的实际配置，可以访问 http://localhost:9090/config 查看。这里也是校验&lt;code&gt;ServiceMonitor&lt;/code&gt;是否生效的一个地方。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;第二部分：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;部署kind &lt;code&gt;Service&lt;/code&gt;，label带有&lt;code&gt;release: prometheus&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部署kind &lt;code&gt;ServiceMonitor&lt;/code&gt;，label带有&lt;code&gt;release: prometheus&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Prometheus operator会发现新部署的&lt;code&gt;ServiceMonitor&lt;/code&gt;，然后生成新的prometheus配置，保存到k8s的Secrets里，实际保存文件是压缩过的：&lt;code&gt;prometheus.yaml.gz&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;prometheus-config-reloader会把这个&lt;code&gt;prometheus.yaml.gz&lt;/code&gt;解压到&lt;code&gt;/etc/prometheus/config_out/prometheus.env.yaml&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;prometheus&lt;/code&gt;启动时正是以&lt;code&gt;--config.file&lt;/code&gt;参数指定了上面的&lt;code&gt;prometheus.env.yaml&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;可以参考官方的图片：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5419039869812856&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2CINxh93CWSrL4e0XsZg6Iib6iccgw0Jzgsn62cBMxwkviaZAeD79065klwttYicISefJ2EGVyNwd3IwYUyIur5Mzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1229&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置grafana&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;grafana 默认的用户名密码是：&lt;code&gt;admin/prom-operator&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;首先导入下面的开源&lt;code&gt;JVM (Micrometer)&lt;/code&gt; dashboard：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;https://grafana.com/grafana/dashboards/4701&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;在Grafana UI里，在&lt;code&gt;Dashboards&lt;/code&gt;,&lt;code&gt;Manage&lt;/code&gt;,&lt;code&gt;Import&lt;/code&gt;，填入&lt;code&gt;4701&lt;/code&gt;。导入成功之后，就可以在Dashboards里找到&lt;code&gt;JVM (Micrometer)&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.44140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2CINxh93CWSrL4e0XsZg6Iib6iccgw0JzgPdEiavAfwRkodafJoOE7OC0hbeW3Yjtz8aBAvVLCJ0tRibPqW0taCBBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;打开之后可以看到 expose-prometheus-demo的监控信息。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.60859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2CINxh93CWSrL4e0XsZg6Iib6iccgw0JzgfLrKYOiaYbfzamwbcvHbf149oHdMNVgz2AlFwKU80xSrowjo86CjQXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;排查问题方法&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;现在是重点了，为什么按网上的一些资料去配置却不能工作呢？因为Prometheus Operator本身也是在不断更新，所以一些配置过时了。&lt;/p&gt;&lt;ol data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;熟练查看k8s里的各种资源&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;比如查看k8s里Prometheus相关的pod信息：&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;kubectl get pod prometheus-prometheus-kube-prometheus-prometheus-0 -o yaml&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;从结果我们可以知道&lt;code&gt;prometheus-config-reloader&lt;/code&gt;的配置是怎样的：&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;args:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;--listen-address=:8080&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;--reload-url=http://127.0.0.1:9090/-/reload&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;--config-file=/etc/prometheus/config/prometheus.yaml.gz&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;--config-envsubst-file=/etc/prometheus/config_out/prometheus.env.yaml&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;--watched-dir=/etc/prometheus/rules/prometheus-prometheus-kube-prometheus-prometheus-rulefiles-0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;command:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;/bin/prometheus-config-reloader&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;理解&lt;code&gt;ServiceMonitor&lt;/code&gt;是怎么工作的&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;在&lt;code&gt;工作原理&lt;/code&gt;一节里，官方的原理图里有&lt;code&gt;kind&lt;/code&gt;为&lt;code&gt;Prometheus&lt;/code&gt;的资源。因此我们安装好prometheus operator之后，可以查看具体的yaml配置。&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;$ kubectl get Prometheus&lt;br/&gt;NAME                                    VERSION   REPLICAS   AGE&lt;br/&gt;prometheus-kube-prometheus-prometheus   v2.28.1   1          2d23h&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;$ kubectl get Prometheus prometheus-kube-prometheus-prometheus -o yaml&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;在结果的yaml里，我们可以找到&lt;code&gt;serviceMonitorSelector&lt;/code&gt;的配置信息：&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;serviceMonitorSelector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;matchLabels:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;release:&lt;/span&gt; &lt;span&gt;prometheus&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;strong&gt;所以我们要在Demo里的&lt;code&gt;servicemonitor-deployment.yaml&lt;/code&gt;里配置上&lt;code&gt;release: prometheus&lt;/code&gt;，这个是很多教程不工作的原因。&lt;/strong&gt;&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;配置流程是异步触发的&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;从应用deploy，到operator变更，到prometheus reload，再真正抓取到配置，整个过程是异步的。变更之后可能要一两分钟才会生效。&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;k8s的整套监控是很强大的，但也比较复杂，在原来的组件上套了一层Operator，从而实现自动发现，自动更新。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于用户来说，Operator既是蜜糖也是砒霜，虽然简化了使用，但要理解更多的概念。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e1e3cc3ab6476445c12957da98416601</guid>
<title>代码精准分析在闲鱼接口测试中的应用</title>
<link>https://toutiao.io/k/uwa3xas</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7a3145edffb813d8f2a83e91fc13e352</guid>
<title>图解 Kafka 线程模型及其设计缺陷</title>
<link>https://toutiao.io/k/8t21dzf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNzgyMjYxOQ==&amp;amp;mid=2247486570&amp;amp;idx=1&amp;amp;sn=25afad26c7986aaaf32e0be8de2fc334&amp;amp;chksm=e8c3fb9edfb4728831bd29cbc6b9805baea8b2670401cf54f21f0675c6026811bea511dac811&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100004440&quot; data-ratio=&quot;0.8666666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFtRsQop4YtGM7EiaiaXNibdElEDFKEfJmfXo7yxtC5GRPOJveia0HbBMRAW3NUV8qW77U0B5RF2uoxE8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用何种线程交互模型，如何高效率的提高网络处理能力是面向网络编程中一个非常重要的议题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;深入研究Kafka Broker服务端线程模型也是理解Kafka工作机制必备不可少的一环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文的探讨主要分成如下三个部分：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;网络相关配置参数&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;图解线程模型工作机制&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;对Kafka线程模型的一点思考&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、网络相关的配置参数&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka Broker端与网络相关的线程主要被分成network、IO两类线程，与之对应的是Kafka分别提供了两个参数用来设置其线程个数，分别如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;num.network.threads
网络线程的个数，默认值为3。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;num.io.threads
IO线程的个数，默认值为8。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那什么是网络线程，什么又是IO线程呢？请带着上述疑问，进入本文的学习交流中来。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、线程模型探究&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;笔者崇尚“眼见为实”，故喜欢对其源码进行分析，从而提炼总结，故本文的探究手段还是以源码阅读为主，同时为了提高可读性，将提炼各种流程图。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解上述几个参数的含义，通常运用的手段是查看这些参数的调用链，根据上下文进行理解与分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;num.io.threads参数的使用调用链如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2815384615384615&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Wkp2azia4QFuBKjt7ibHKROldeWKoBRibCznrnHACVc4wibBYDuf0JKicfu4ibsYialEwp6yCR5pNNEtvcia1J4BezJarQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2600&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;num.network.threads参数的调用链如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2588575560375994&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Wkp2azia4QFuBKjt7ibHKROldeWKoBRibCzUGtC7U1l67PnXEXJF3icHjc4ydAW8n6tvsAXfRKAtwqHjJL0jzRbohg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2766&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这里我们可以得出如下两个重要的推断：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Network、IO线程相关的参数支持动态修改&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Network、IO线程相关参数使用者是KafkaServer。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来将目光锁定在KafkaServer上。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 IO线程工作机制&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上文的调用栈，我们不难找到使用num.io.threads的具体使用代码如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Wkp2azia4QFuBKjt7ibHKROldeWKoBRibCzIItXpqcwhZ6OGWyYT3X2FGib5icd1pCe5wiaT4Ip9TibUAjwOicv8gOE1rQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2500&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心实现要点总结如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;KafkaApis主要定义各个请求的处理逻辑，例如消息发送、消息拉取、位点提交等具体实现逻辑，其具体可以参考如下代码：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9285714285714286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Wkp2azia4QFuBKjt7ibHKROldeWKoBRibCzPQ8a9op8oMDhTsDic3A9rkRvsqsh9qdk9icnU60t4c6XW0X7UDvsd2kg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1960&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;引入KafkaRequestHandlerPool(IO线程池)，里面持有的线程个数由&lt;strong&gt;num.io.threads&lt;/strong&gt;决定。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;KafkaRequestHandlerPool内部持有一个线程池，每一个线程的行为由KafkaRequestHandler类定义，即可以称KafkaRequestHandler为IO线程，并且由KafkaRequestHandler来调用KafkaApis中的具体实现，其代码如下所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.101522842639594&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Wkp2azia4QFuBKjt7ibHKROldeWKoBRibCzL9huHkxsEPFt2iaoOhSYWd4Qbkj7ZYOJV7OGS8Tf7L0JkcrQmbWmvuA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1576&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;温馨提示：KafkaRequestHandler的实现非常简单，主要是从RequestChannel(处理队列中)获取请求并执行之，这里在稍后会重点介绍关于IO线程执行相关的&lt;strong&gt;监控指标(IO线程空闲率)&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;一个KafkaRequestHandlerPool线程池拥有一个RequestChannel**(请求待处理队列)**，并创建KafkaRequestHandler,代码如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Wkp2azia4QFuBKjt7ibHKROldeWKoBRibCz6Uicvkh1hlEpqvrktkU4GvX8el4WqmicwNB7DA8iaDLdsibob393lCg3SQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1760&quot;/&gt;指的注意的是在Kafka中，IO线程名的命名规则：“data-plane-kafka-request-handler-” + {brokerId} + &quot;-&quot; + 序号。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Kafka在2.2版本开始引入了控制面与数据面概念，用以区分不同的请求,稍后在第三部分还会重点介绍。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过对上述代码进行解读，我想不难得出如下时序图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4909819639278557&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Wkp2azia4QFuBKjt7ibHKROldeWKoBRibCzm2uV8DY7qzoUNoicZ2ej7Rs2icFnreSnh6KQAehKtqVgR5ddV1kFGLpw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2994&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那RequestChannel中的待处理请求从哪来呢？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 NetWork线程工作机制&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;network线程的初始化代码在SocketServer的createDataPlaneAcceptorsAndProcessors方法，详情如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18653250773993807&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Wkp2azia4QFuBKjt7ibHKROldeWKoBRibCzxsfptibb516nLLoXJ452SvJX4kIAhB0juibzW9NNyk1qiaDiape793806w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2584&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其核心要点如下所示：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;介绍该方法之前先介绍该方法的两个参数的含义：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;int dataProcessorsPerListener
网络处理线程的个数，取自 num.network.threads。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Seq[EndPoint] endpoints
kafka设置的endpoint，其实就配置在Kafka server中的listeners，如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2811881188118812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuBKjt7ibHKROldeWKoBRibCzicicKdnCt1E2O5JA3tcvz18JvSdTDEcibY3JWDvkLHkHNicdDFaD9N0Fvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1010&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据kafka endpoint创建Acceptor。所谓的Kafka endpoint指的就是配置的listeners，即监听的端口与协议，Kafka支持多协议多端口监听，可充分利用宿主机的网卡进行分流，&lt;strong&gt;Kafka的网络模型是真正的主从多Reactor模型，支持多个Acceptor&lt;/strong&gt;。Acceptor线程的命名规则：data-plane-kafka-socket-acceptor-{listeners-name}-{securityProtocol}-port，其中securityProtocol指的是url冒号之前的字符串，例如 PLAINTEXT。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5428388746803069&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Wkp2azia4QFuBKjt7ibHKROldeWKoBRibCztm0oJmiaNciaVQjEwHAbnYb22bribvKmsDMt2eU2kkbhfZKcOgDPU6Uwg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3128&quot;/&gt;&lt;/p&gt;&lt;p&gt;Acceptor的主要职责：监听OP_ACCEPT事件，接受链接并将其转发给NetWork线程处理。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过调用addDataPlaneProcessors方法为每一个Acceptor创建num.network.threads个处理线程，用来处理网络的读写事件，即负责从网络中解码出Request、将响应结果写入到客户端，每一个网络线程的命名规则为：data-plane(数据面)||control-plane(控制面)&quot;--kafka-network-thread-{brokerId}-{endPoint.listenerName}-{endPoint.securityProtocol}-{processor.id}。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每一个NetWork线程对应一个Processor对象，其核心代码示例如下：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3505747126436782&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Wkp2azia4QFuBKjt7ibHKROldeWKoBRibCzfadVUYjrsXkAOtvAtNnNaPMibmhyxL5w2axn9FBAr2czuMqMba1Y8NQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3132&quot;/&gt;&lt;/p&gt;&lt;p&gt;网络线程从网络中解析到请求后放入RequestChannel,从而供IO线程获取并处理。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了方便大家理解，同样给出工作的顺序图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5950207468879668&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Wkp2azia4QFuBKjt7ibHKROldeWKoBRibCzzr8ZbLZkOhnnH0CcxIHJFxoLZuwPP3vG9GMlkf3DDxFedAubiaMJErw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2410&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 图解Kafka线程模型&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码讲解确实比较抽象，接下来结合笔者对源码的阅读，总结提炼出Kafka线程模型如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40068661108386466&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuBKjt7ibHKROldeWKoBRibCzA4vq6ianO9dtDj5E6rickvv3hcIxcGC8fzcukBaDtzUwptvP5AUkicXAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;4078&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结要点如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Kafka可以根据listener的数量，创建对应的Acceptor，实现多Acceptor。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Acceptor的职责就是处理OP_ACCEPT事件，即接受客户端的连接，连接建立成功后将其转发给Procesor线程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Processor线程，在Kafka中称之为网络线程(network)，主要负责网络的读写。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;network需要处理OP_READ、OP_WRITE事件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;OP_READ事件主要是将从客户端发送端服务端的二进制流解码成一个个独立的请求，丢到&lt;strong&gt;全局请求队列(RequestChannel)&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当Kafka的IO线程处理完一个请求后，会将该请求转发到解码这个请求的Processor(network)线程中去返回给客户端。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;Kafka IO线程从全局请求队列中获取任务，并调用KafkaApis中相关的方法完成对应的逻辑处理，并将响应结果发送给Netwok线程，从而完成一次任务的执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、关于线程模型的一点思考&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再次来总结一下Kafka线程模型中的几类线程(类比主从多Reactor模型)：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;kafka-socket-acceptor
对标主从多Reactor模型中的Main-Reactor，主要负责连接事件的建立(OP_ACCEPT)。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;kafka-network-thread
对比主从多Reactor模型中的Sub-Reactor，主要负责网络的读写。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;备注：如果大家看过我以前分析RocketMQ、Netty等框架的网络模型，他们对这类线程的称呼为IO线程，我也倾向于这种称呼，因为它是调用底层的IO API进行网络的读写。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;kafka-request-handler
类比主从多Reactor模型中的&lt;strong&gt;业务线程池&lt;/strong&gt;，因为该线程池的职责也是对每一个具体的请求进行逻辑响应，但在Kafka中被称之为IO线程。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;备注：命名本身没有对错，但让我们容易想当然的认为Kafka的IO线程是处理网络读写的，如果我们要深入了解一款开源框架底层的运作机制，&lt;strong&gt;阅读源码是一个非常不错的方式，因为眼见为实&lt;/strong&gt;嘛。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka的线程模型毫无疑问采取的是网络编程领域最经典的&lt;strong&gt;主从多Reactor模型&lt;/strong&gt;，但&lt;strong&gt;个人觉得上述实现存在一个比较大的缺陷：业务线程隔离性不足，换句话说就是请求无优先级，容易相互影响&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后值得关注的是在Kafka2.2版本中引入来数据面、控制面的概念，用来隔离kafka内部的控制命令与数据命令：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;控制面
kafka集群内部的controller发送给Broker节点的命令，主要包含如下几个命令：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LEADER_AND_ISR
分区Leader发生和ISR发生变化。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;STOP_REPLICA
停止复制。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;UPDATE_METADATA&lt;/p&gt;&lt;p&gt;向从各个Broker同步元数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;数据面
除上述3个命令之外的其他命令。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但笔者觉得上述&lt;strong&gt;隔离程度远远不够&lt;/strong&gt;，就拿客户端心跳包请求、数据拉取请求来说，如果多个消费组都去消费过早的数据，导致pagecache未命中，需要从磁盘加载数据，读磁盘如果出现瓶颈，会导致客户端端心跳请求无法及时处理，Broker在&lt;strong&gt;10s&lt;/strong&gt;内没有收到(准确来讲是10s内没有触发心跳包处理流程)，将导致消费组由于心跳超时而被Broker标记为宕机，从而触发重平衡，导致消费组无法消费，并且容易造成雪崩，该&lt;strong&gt;集群中所有消费组全部不可消费&lt;/strong&gt;，其影响可想而知。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里不得不和RocketMQ来做一个横向对比，RocketMQ的线程处理模型就支持不同的命令类型使用不同的线程池，消息发送处理线程池、消息拉取线程池就分别拥有独立的线程池，起到了线程资源隔离的效果，不至于由于一类请求处理缓慢而导致其他更加重要的命令处于饥饿停滞不前，造成不可估量的后果。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>