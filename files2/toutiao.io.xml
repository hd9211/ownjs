<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3d118c2e31438a47014e34138dfd3c44</guid>
<title>精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期</title>
<link>https://toutiao.io/k/3ininot</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第324期（2020-11-11）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;双十一，买它买它买它！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_324.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;基于 Kubernetes 的云原生批量计算平台&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;对以 Transformer 为基础的序列特征提取器 (Encoder) 和自回归的序列解码器 (Decoder) 做了深度优化&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;技术雷达是 ThoughtWorks 每半年发布一次的技术趋势报告&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;这是德勤第 11 年发布技术趋势年度报告&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;个人经历&lt;/p&gt;
        
        &lt;p&gt;你知道吗？&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验总结&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;适合入门&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;深入探讨&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;基于 Swift 推出的函数响应框架&lt;/p&gt;
        
        &lt;p&gt;使用 JavaScript 来自动化 iOS&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;实践总结&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;细致讲解&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;7年工作经验，技术总监&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 451915 即可&lt;/p&gt;
        
        &lt;p&gt;坚持原创，持续分享技术，包括但不限于：分布式、微服务架构，spring cloud、Dubbo微服务框架，Java核心技术，Redis缓存、Kafka消息队列中间件等。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 450130 即可&lt;/p&gt;
        
        &lt;p&gt;一个工作10年的程序猿，分享技术干货及内心的声音。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 413084 即可&lt;/p&gt;
        
        &lt;p&gt;详解数据结构与算法&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 142771 即可&lt;/p&gt;
        
        &lt;p&gt;Web前端、服务端、小程序、App、学习资料、工具、资讯&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 125297 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=20115&amp;amp;url=http%3A%2F%2Fproduct.dangdang.com%2F29132383.html&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/book_324.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;一个技术总监的忠告&lt;/p&gt;
        
        &lt;p&gt;写作不易&lt;/p&gt;
        
        &lt;p&gt;同理心&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2dbe2bbce25d2e272509fee0f92abdc7</guid>
<title>我用 Python 找出了删除我微信的所有人并将他们自动化删除了</title>
<link>https://toutiao.io/k/km6796s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;概述&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知你是否遇到过在微信上给通讯录中的某个人发消息，结果出现了这一幕：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5393442622950819&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUEofIiaJOoFnzPxNQISYMianWC7URLglsC5kG8ww0zRGSpiaSJMu0fDCag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;610&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;平时一直认为自己的心里素质过硬，不过遇到这种情况 ...&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUmegARtxyFceBDF1IybLjfuMia8jQQAicK76QBwSU15iaFe8A0ib4DThvQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我缓了半个钟头（半分钟&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUA5AXj0kKLmjia6S76ez1XDOCd3hC6rfG5lFKcGGmo42FQ19uc9UaFVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;）之后，缓缓拿出了手机，打开微信，找到通讯录中的 &lt;code&gt;ABC&lt;/code&gt;，默默地按下了删除按钮，此刻的我心如止水 ...&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUEz2cg23CJj4kuFTLiaVl68QVrXLgpZzWGqRs1y5icHYFGjO0NfSzDXQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，我们回到正题，为了避免再次出现上述情况，我决定把微信通讯录中删除了自己的人全部找出来并且删除，之前我已经在网上了解到检查自己的微信是否被删比较好的方式就是转账，通过转账我们可以实现无痕检测。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUmJP38Ax2oy5VXhVvgWHoeo23gsDd2DC7XrIP3ibicQEzxmaQcyHhN3og/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们通过两张图片直观的看一下微信被删前后给别人转账的效果：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.231696014828545&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUWWUteBlBtP9qt6IzaicsrCQBjpia279uZtOcRiasGlk7ttGJFuZ9dNRZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1079&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.4308263695450325&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUyicAh82FR82iaqDgGXwcXJzpyH2DbasUagtuDuYibSORFNfILNccNYRvw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1077&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在已经知道了检测方式，正在我准备挨个检测时，无意识的滑动了微信通讯录列表，100、200 ... 500 ...&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUVTtnU04L7DEGLeOQ6GLCr6fQLTTKFI9Zrow84rbTjnsBd7TonWnnSA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我去！什么时候加了这么多人，滑动列表的同时我顺势扫了一眼微信名字：A卖保险、B办理信用卡、C游泳健身、D卖保健品 ... 此刻我知道了微信通讯录中有这么多人的玄机，但是有个问题，这么多人我挨个手动执行转账还不累屎了 ...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果手动执行的方式行不通，那么可以通过编程的方式自动化执行吗？想到这里我陷入了沉思 ...&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUqU2ibC4Bbv2tWmTBRe603cFjEjUQ1hLlHLD7qSxvQpEViczZicNjfFqvw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;突然我脑中闪了一下（不是抽筋哈&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUA5AXj0kKLmjia6S76ez1XDOCd3hC6rfG5lFKcGGmo42FQ19uc9UaFVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;），思绪渐明，前几天我不是写了一篇&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3Mzk1ODA5OQ==&amp;amp;mid=2247495223&amp;amp;idx=1&amp;amp;sn=3d81982be5f081daa0dab83be7167dc2&amp;amp;chksm=fd3b1c8bca4c959d4a4230bdf4a909905b0516ba64a56d5c2ff2072bbd3760fef2b1893956f0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;Python + Appium 自动化操作微信入门&lt;/strong&gt;&lt;/a&gt;吗？用这个应该就可以实现，编程实现的基本思路如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;获取微信通讯录列表中每个人的名字（备注）并记录，这个是不会有重复的，因为即使在之前加好友时有重复的，自己也会在备注时给改了&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;遍历获取到的通讯录列表，分别对每一个人执行转账操作，如果检测到是删除自己的人就对其执行删除操作，如果检测到不是删除自己的人则继续检测下一个人，依次往复循环&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;环境&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因之前在模拟器上测试 Appium 模拟微信转账可能有点问题，因此本文使用真机实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先简单介绍一下真机环境，下面一起来看一下相应步骤。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;从桌角下取出我的小米5s手机（MIUI10.2、Android8.0.0），擦擦灰尘后用数据线将其连到自己的电脑上&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;手机充了一会电之后开机，打开微信登录自己的微信号&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在手机中依次执行（点击）：设置-&amp;gt;我的设备-&amp;gt;全部参数-&amp;gt;MIUI版本（多次点击，开启开发者模式）-&amp;gt;返回设置列表-&amp;gt;更多设置-&amp;gt;开发者选项-&amp;gt;开启开发者选项并分别开启：USB调试、USB安装、USB调试（安全设置）选项，如图所示：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.32&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUeBJd34FS9A2Ld3nASuuEucwRm4EOLpRG66qyiaMrODu4xIG7v2J3ibuQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1075&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;此时手机上会弹出USB的用途弹框，我们选择传输文件（MTP）即可，如图所示：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7477656405163853&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUoyfUXCwQtW63uNHuMibBAicv2pllDZEk7b5b023b89uVCrcGH3OOvpLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1007&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在电脑 CMD 中执行 &lt;code&gt;adb devices&lt;/code&gt; 命令，看是否能找到自己的手机，比如下图所示就是成功的结果了&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.32605042016806723&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUSpJibeO78zk01dzoJCLibbX8DcDCQWFwSxsP8bV1PV5aPNjT02TKqcvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;595&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在上面步骤中你可能出现找不到手机的情况，通常这种情况是驱动问题，这里介绍一种简单的处理方式：下载一个驱动精灵，安装启动之后点击驱动管理，之后安装相应驱动即可解决，如图所示：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUicMaWJkWvkdN86ODfoTgVrviao9Xdz6ibib86iaDnHsQPsM0zylLKGNvsdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.396875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUB1HibicYTzhoZYELcS5zVaJbDbGL6wVkbCV7uNLp6lPt9ibVrmXGRU4uQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的一系列操作，我们已经处理好了真机环境了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Appium 的环境本文就不说了，如果不清楚的话，可以看一下：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3Mzk1ODA5OQ==&amp;amp;mid=2247495223&amp;amp;idx=1&amp;amp;sn=3d81982be5f081daa0dab83be7167dc2&amp;amp;chksm=fd3b1c8bca4c959d4a4230bdf4a909905b0516ba64a56d5c2ff2072bbd3760fef2b1893956f0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;Python + Appium 自动化操作微信入门&lt;/strong&gt;&lt;/a&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们开始手动敲代码，如果对 Appium 基本代码操作不了解的话，还是可以去看一下我之前写的这篇：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3Mzk1ODA5OQ==&amp;amp;mid=2247495223&amp;amp;idx=1&amp;amp;sn=3d81982be5f081daa0dab83be7167dc2&amp;amp;chksm=fd3b1c8bca4c959d4a4230bdf4a909905b0516ba64a56d5c2ff2072bbd3760fef2b1893956f0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;Python + Appium 自动化操作微信入门&lt;/strong&gt;&lt;/a&gt;，真机与模拟器的使用基本一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先看一下相应参数配置，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;desired_caps = {&lt;br/&gt;    &lt;span&gt;&quot;platformName&quot;&lt;/span&gt;: &lt;span&gt;&quot;Android&quot;&lt;/span&gt;, &lt;span&gt;# 系统&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;platformVersion&quot;&lt;/span&gt;: &lt;span&gt;&quot;8.0.0&quot;&lt;/span&gt;, &lt;span&gt;# 系统本号&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;deviceName&quot;&lt;/span&gt;: &lt;span&gt;&quot;m5s&quot;&lt;/span&gt;, &lt;span&gt;# 设备名&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;appPackage&quot;&lt;/span&gt;: &lt;span&gt;&quot;com.tencent.mm&quot;&lt;/span&gt;, &lt;span&gt;# 包名&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;appActivity&quot;&lt;/span&gt;: &lt;span&gt;&quot;.ui.LauncherUI&quot;&lt;/span&gt;, &lt;span&gt;# app 启动时主 Activity&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&#x27;unicodeKeyboard&#x27;&lt;/span&gt;: &lt;span&gt;True&lt;/span&gt;, &lt;span&gt;# 使用自带输入法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&#x27;noReset&#x27;&lt;/span&gt;: &lt;span&gt;True&lt;/span&gt; &lt;span&gt;# 保留 session 信息，可以避免重新登录&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着看一下如何获取微信通讯录名字（备注）列表？代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 获取通讯录列表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;get_address_list&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    driver.find_elements_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/cn_&#x27;&lt;/span&gt;)[&lt;span&gt;1&lt;/span&gt;].click()&lt;br/&gt;    &lt;span&gt;# 获取昵称（备注）&lt;/span&gt;&lt;br/&gt;    address_list = driver.find_elements_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/dy5&#x27;&lt;/span&gt;)&lt;br/&gt;    remarks = []&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; address &lt;span&gt;in&lt;/span&gt; address_list:&lt;br/&gt;        remark = address.get_attribute(&lt;span&gt;&quot;content-desc&quot;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# 排除自己和微信官方号&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; remark != &lt;span&gt;&quot;自己的微信名&quot;&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;&quot;微信&quot;&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; remark:&lt;br/&gt;            remarks.append(remark)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; remarks&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;取到了微信通讯录列表之后，我们就可以对其进行遍历检测了，下面看一下如何实现检测自己的微信是否被删，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 判断是否被删&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;is_delete&lt;/span&gt;&lt;span&gt;(remark, count)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; count == &lt;span&gt;&quot;1&quot;&lt;/span&gt;:&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        print(&lt;span&gt;&#x27;点击微信搜索框&#x27;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/cn1&#x27;&lt;/span&gt;).click()&lt;br/&gt;    time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    print(&lt;span&gt;&#x27;在搜索框输入搜索信息&#x27;&lt;/span&gt;)&lt;br/&gt;    driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/bhn&#x27;&lt;/span&gt;).send_keys(remark)&lt;br/&gt;    time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    print(&lt;span&gt;&#x27;点击搜索到的好友&#x27;&lt;/span&gt;)&lt;br/&gt;    driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/tm&#x27;&lt;/span&gt;).click()&lt;br/&gt;    time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;# 转账&lt;/span&gt;&lt;br/&gt;    driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/aks&#x27;&lt;/span&gt;).click()&lt;br/&gt;    time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    driver.find_elements_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/pa&#x27;&lt;/span&gt;)[&lt;span&gt;5&lt;/span&gt;].click()&lt;br/&gt;    time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/cx_&#x27;&lt;/span&gt;).click()&lt;br/&gt;    time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/cxi&#x27;&lt;/span&gt;).click()&lt;br/&gt;    time.sleep(&lt;span&gt;5&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;# 判断是否被删&lt;/span&gt;&lt;br/&gt;    is_exist = is_element_exist(&lt;span&gt;&#x27;com.tencent.mm:id/jh&#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; is_exist &lt;span&gt;is&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; remark&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述方法中，如果检测到是删了自己微信的人就返回那个人的微信名（备注），然后我们将这些人记录起来；如果检测到不是删除自己微信的人就返回 False。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述过程执行完了之后，我们就可以获取到所有删了自己微信的人了，接下来我们就可以将这些人都从自己微信通讯录中删除了，删除实现的代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 删除把自己删除的人&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;del_person&lt;/span&gt;&lt;span&gt;(nicks)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; inx, val &lt;span&gt;in&lt;/span&gt; enumerate(nicks):&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; inx == &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;            print(&lt;span&gt;&#x27;在搜索框输入搜索信息&#x27;&lt;/span&gt;)&lt;br/&gt;            driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/bhn&#x27;&lt;/span&gt;).send_keys(val)&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;            time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;            print(&lt;span&gt;&#x27;点击微信搜索框&#x27;&lt;/span&gt;)&lt;br/&gt;            driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/cn1&#x27;&lt;/span&gt;).click()&lt;br/&gt;            print(&lt;span&gt;&#x27;在搜索框输入搜索信息&#x27;&lt;/span&gt;)&lt;br/&gt;            time.sleep(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;            driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/bhn&#x27;&lt;/span&gt;).send_keys(val)&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        print(&lt;span&gt;&#x27;点击搜索到的人&#x27;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/tm&#x27;&lt;/span&gt;).click()&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        print(&lt;span&gt;&#x27;点击聊天对话框右上角...&#x27;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/cj&#x27;&lt;/span&gt;).click()&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        print(&lt;span&gt;&#x27;点击头像&#x27;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/f3y&#x27;&lt;/span&gt;).click()&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        print(&lt;span&gt;&#x27;点击联系人右上角...&#x27;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/cj&#x27;&lt;/span&gt;).click()&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        print(&lt;span&gt;&#x27;点击删除按钮&#x27;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/g6f&#x27;&lt;/span&gt;).click()&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        print(&lt;span&gt;&#x27;点击弹出框中的删除&#x27;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/doz&#x27;&lt;/span&gt;).click()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，我们就利用 Python + Appium 实现了自动化找出微信中删除自己的人并将其删除的工作了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码在公号 &lt;span&gt;Python小二&lt;/span&gt; 后台回复 &lt;span&gt;201108&lt;/span&gt; 获取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原创不易，如果觉得有一些帮助，希望大家给个在看或转发。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>574bc471af56d4ad463856ccd92b64bb</guid>
<title>Go 设计模式（二十四）：总结</title>
<link>https://toutiao.io/k/ch4mr21</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;markdown-body&quot; id=&quot;post-body&quot;&gt;&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;/&gt;序&lt;/h2&gt;&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;/&gt;总结&lt;/h2&gt;&lt;p&gt;原本预计是在十月底更新完毕这个系列，到今天是 11-05，晚了几天，不过也还好，这是第一次这么密集的去更新博客上的内容，更多的是以笔记的形式来呈现，加上这篇一共 24 篇文章差不多两个半月的时间，平均每周输出两篇，感觉还是不错。后续可能会视情况不定期的更新一些实战内容，也有可能没有。接下来下一个系列应该是数据结构与算法，包含对 Go 中一些底层数据和标准库包的学习，例如 slice, sort 等等。&lt;/p&gt;&lt;p&gt;话说回来，回头再看学习设计模式我们究竟需要学习一些什么？&lt;/p&gt;&lt;ul&gt;&lt;li&gt;写 Go 需要使用到设计模式么？&lt;ul&gt;&lt;li&gt;需要，但是切记请勿使用其他语言的方式来写 Go&lt;/li&gt;&lt;li&gt;如果看过之前的一些文章，就会发现类似 JAVA 的这些面向对象语言中的某些设计模式的写法在 Go 中会十分的别扭&lt;/li&gt;&lt;li&gt;但是 Go 不需要设计模式么？不是的，设计模式的思想是想通的，并且我们一直都在使用，例如我们常见的对象创建方式 &lt;code&gt;NewXXX&lt;/code&gt; 这其实就是一个简单工厂&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;设计模式学习的重点是什么？&lt;ul&gt;&lt;li&gt;设计原则，以及设计模式的使用场景和优缺点，实现相对来说还没有那么重要&lt;/li&gt;&lt;li&gt;如果是常见的设计模式是武术招式，那么设计原则就是内功心法，没有内功心法那么招式套路也就是花架子&lt;/li&gt;&lt;li&gt;熟练掌握不同设计模式的使用场景可以帮助我们学会见招拆招，灵活应用而不是只会套路&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;最后设计模式不是银弹，不要拿着 🔨 就觉得哪里都像是钉子，不要过早优化，持续重构才是正道&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;设计原则&quot;&gt;&lt;a href=&quot;#设计原则&quot; class=&quot;headerlink&quot; title=&quot;设计原则&quot;/&gt;设计原则&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;同时这也是 Code Review 的重要标准之一&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://lailin.xyz/images/1604555465270-6b839dae-3cc4-43e8-bcad-b46ee314f0f7.png&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;h3 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;/&gt;设计模式&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://lailin.xyz/images/1604555469082-5a1887e1-5640-4895-a018-8541ba78139e.png&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;Go-设计模式&quot;&gt;&lt;a href=&quot;#Go-设计模式&quot; class=&quot;headerlink&quot; title=&quot;Go 设计模式&quot;/&gt;Go 设计模式&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;单例模式包含饿汉式和懒汉式两种实现&lt;/li&gt;&lt;li&gt;工厂模式包含简单工厂、工厂方法、抽象工厂、DI 容器&lt;/li&gt;&lt;li&gt;代理模式包含静态代理、动态代理（采用 go generate 模拟）&lt;/li&gt;&lt;li&gt;观察者模式包含观察者模式、eventbus&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7aa41646c166b0f7c5ef5981733e54c2</guid>
<title>深入理解 Java 线程池</title>
<link>https://toutiao.io/k/dwlr0t4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;在开发过程中，合理地使用线程池能够带来至少以下几个好处。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;降低资源消耗&lt;/strong&gt;：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;提高响应速度&lt;/strong&gt;：当任务到达时，任务可以不需要等到线程创建就能立即执行。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;提高线程的可管理性&lt;/strong&gt;：线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须了解其实现原理。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;代码解耦&lt;/strong&gt;：比如生产者消费者模式。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;线程池实现原理&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;当提交一个新任务到线程池时，线程池的处理流程如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤也需要获取全局锁）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果创建新线程将使当前运行的线程数超出maximumPoolSize，该任务将被拒绝，并调用相应的拒绝策略来处理（RejectedExecutionHandler.rejectedExecution()方法，线程池默认的饱和策略是AbortPolicy，也就是抛异常）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;线程池任务 拒绝策略包括 &lt;strong&gt;抛异常&lt;/strong&gt;、&lt;strong&gt;直接丢弃&lt;/strong&gt;、&lt;strong&gt;丢弃队列中最老的任务&lt;/strong&gt;、&lt;strong&gt;将任务分发给调用线程处理&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;线程池的创建&lt;/strong&gt;：通过ThreadPoolExecutor来创建一个线程池。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, timeUnit, runnableTaskQueue, handler);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;创建一个线程池时需要输入以下几个参数：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到线程池的线程数等于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;- ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;PriorityBlockingQueue：一个具有优先级的无界阻塞队列。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;线程的状态&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;在HotSpot VM线程模型中，Java线程被一对一映射到本地系统线程，Java线程启动时会创建一个本地系统线程；当Java线程终止时，这个本地系统线程也会被回收。操作系统调度所有线程并把它们分配给可用的CPU。&lt;/p&gt;&lt;p&gt;thread运行周期中，有以下6种状态，在 java.lang.Thread.State 中有详细定义和说明：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// Thread类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; State {&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 刚创建尚未运行&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    NEW,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 可运行状态，该状态表示正在JVM中处于运行状态，不过有可能是在等待其他资源，比如CPU时间片，IO等待&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    RUNNABLE,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 阻塞状态表示等待monitor锁（阻塞在等待monitor锁或者在调用Object.wait方法后重新进入synchronized块时阻塞）&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    BLOCKED,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 等待状态，发生在调用Object.wait、Thread.join (with no timeout)、LockSupport.park&lt;br/&gt;     * 表示当前线程在等待另一个线程执行某种动作，比如Object.notify()、Object.notifyAll()，Thread.join表示等待线程执行完成&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    WAITING,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 超时等待，发生在调用Thread.sleep、Object.wait、Thread.join (in timeout)、LockSupport.parkNanos、LockSupport.parkUntil&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    TIMED_WAITING,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     *线程已执行完成，终止状态&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    TERMINATED;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;线程池操作&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;向线程池提交任务，可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;threadsPool.execute(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// TODO Auto-generated method stub&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，通过future的get()方法来获取返回值，future的get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务还没有执行完。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Future&amp;lt;Object&amp;gt; future = executor.submit(harReturnValuetask);&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    Object s = future.get();&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;    &lt;span&gt;// 处理中断异常&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (ExecutionException e) {&lt;br/&gt;    &lt;span&gt;// 处理无法执行任务异常&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 关闭线程池&lt;/span&gt;&lt;br/&gt;    executor.shutdown();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;合理配置线程池&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;要想合理配置线程池，必须先分析任务的特点，可以从以下几个角度分析：&lt;/p&gt;&lt;p&gt;性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽可能少的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置多一点线程，如2*Ncpu。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。&lt;/p&gt;&lt;p&gt;优先级不同的任务可以使用优先级队列&lt;strong&gt;PriorityBlockingQueue&lt;/strong&gt;来处理。它可以让优先级高的任务先执行。执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;线程池中线程数量未达到coreSize时，这些线程处于什么状态？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这些线程处于RUNNING或者WAITING，RUNNING表示线程处于运行当中，WAITING表示线程阻塞等待在阻塞队列上。当一个task submit给线程池时，如果当前线程池线程数量还未达到coreSize时，会创建线程执行task，否则将任务提交给阻塞队列，然后触发线程执行。（从submit内部调用的代码也可以看出来）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6526548672566371&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibMoBzhvMx0xbu7cXpjyWBXMuep0rdzx1icxm1xSShebibnUTtV5vgZuDcGZPI1YGmJ4pRibHzPACoAQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;452&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;ScheduledThreadPoolExecutor&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的延迟之后运行任务，或者定期执行任务。ScheduledThreadPoolExecutor的功能与Timer类似，但ScheduledThreadPoolExecutor功能更强大、更灵活。Timer对应的是单个后台线程，而ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9209932279909706&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibMoBzhvMx0xbu7cXpjyWBXMuiaHusXfjPicW0JIqs8xkXp0evETFvalz2o8LAEw4C67LfNA5HXWP78A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;443&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，ScheduledThreadPoolExecutor和ThreadPoolExecutor的区别是，ThreadPoolExecutor获取任务时是从BlockingQueue中获取的，而ScheduledThreadPoolExecutor是从DelayedWorkQueue中获取的（注意，DelayedWorkQueue是BlockingQueue的实现类）。&lt;/p&gt;&lt;p&gt;ScheduledThreadPoolExecutor把待调度的任务（ScheduledFutureTask）放到一个DelayQueue中，其中ScheduledFutureTask主要包含3个成员变量：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4896810506566604&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibMoBzhvMx0xbu7cXpjyWBXMHvAQwOJa0NIatEG7QhsuroP3iaEnEKosbM0QCywCibaK5u60obbsaQCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;533&quot;/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;sequenceNumber：任务被添加到ScheduledThreadPoolExecutor中的序号；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;time：任务将要被执行的具体时间；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;period：任务执行的间隔周期。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;ScheduledThreadPoolExecutor会把待执行的任务放到工作队列DelayQueue中，DelayQueue封装了一个PriorityQueue，PriorityQueue会对队列中的ScheduledFutureTask进行排序，具体的排序比较算法实现如下：&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.604989604989605&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibMoBzhvMx0xbu7cXpjyWBXMiaqBRgmib83YVl2NFUic1MrlqhH62Ds6TMzpHric45AGc9DGJCV8JsYZxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;481&quot;/&gt;&lt;/p&gt;&lt;p&gt;ScheduledFutureTask在DelayQueue中被保存在一个PriorityQueue（基于数组实现的优先队列，类似于堆排序中的优先队列）中，在往数组中添加/移除元素时，会调用siftDown/siftUp来进行元素的重排序，保证元素的优先级顺序。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DelayedWorkQueue&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractQueue&lt;/span&gt;&amp;lt;&lt;span&gt;Runnable&lt;/span&gt;&amp;gt;&lt;br/&gt;    &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BlockingQueue&lt;/span&gt;&amp;lt;&lt;span&gt;Runnable&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; INITIAL_CAPACITY = &lt;span&gt;16&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RunnableScheduledFuture&amp;lt;?&amp;gt;[] queue =&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; RunnableScheduledFuture&amp;lt;?&amp;gt;[INITIAL_CAPACITY];&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ReentrantLock lock = &lt;span&gt;new&lt;/span&gt; ReentrantLock();&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Thread leader = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Condition available = lock.newCondition();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从DelayQueue获取任务的主要逻辑就在take()方法中，首选获取lock，然后获取queue[0]，如果为null则await等待任务的来临，如果非null查看任务是否到期，是的话就执行该任务，否则再次await等待。这里有一个leader变量，用来表示当前进行awaitNanos等待的线程，如果leader非null，表示已经有其他线程在进行awaitNanos等待，自己await等待，否则自己进行awaitNanos等待。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// DelayedWorkQueue&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; RunnableScheduledFuture&amp;lt;?&amp;gt; take() &lt;span&gt;throws&lt;/span&gt; InterruptedException {&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; ReentrantLock lock = &lt;span&gt;this&lt;/span&gt;.lock;&lt;br/&gt;    lock.lockInterruptibly();&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            RunnableScheduledFuture&amp;lt;?&amp;gt; first = queue[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (first == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;                available.await();&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;long&lt;/span&gt; delay = first.getDelay(NANOSECONDS);&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (delay &amp;lt;= &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; finishPoll(first);&lt;br/&gt;                first = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;// don&#x27;t retain ref while waiting&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (leader != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;                    available.await();&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                    Thread thisThread = Thread.currentThread();&lt;br/&gt;                    leader = thisThread;&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        available.awaitNanos(delay);&lt;br/&gt;                    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (leader == thisThread)&lt;br/&gt;                            leader = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (leader == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; queue[&lt;span&gt;0&lt;/span&gt;] != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            available.signal();&lt;br/&gt;        lock.unlock();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;获取到任务之后，就会执行task的run()方法了，即ScheduledFutureTask.run()：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; periodic = isPeriodic();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!canRunInCurrentRunState(periodic))&lt;br/&gt;        cancel(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!periodic)&lt;br/&gt;        ScheduledFutureTask.&lt;span&gt;super&lt;/span&gt;.run();&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ScheduledFutureTask.&lt;span&gt;super&lt;/span&gt;.runAndReset()) {&lt;br/&gt;        setNextRunTime();&lt;br/&gt;        reExecutePeriodic(outerTask);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8da2a8df84a6b9b9002f8b56da3b568f</guid>
<title>Hugo 之旅</title>
<link>https://toutiao.io/k/5ubz2q0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;cont&quot;&gt;&lt;p&gt;&lt;img src=&quot;https://p2.ssl.qhimg.com/t013d5132596de74ff5.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之前写了篇文章&lt;a href=&quot;https://imnerd.org/blog-migrate-to-hugo.html&quot;&gt;《博客迁移至 Hugo》&lt;/a&gt;，提了下使用 Typecho 多年后越发感受到运维的成本之高后，将博客迁移到了静态博客程序 Hugo 下。使用 &lt;a href=&quot;https://vercel.com&quot;&gt;Vercel&lt;/a&gt; + &lt;a href=&quot;https://github.com&quot;&gt;Github&lt;/a&gt; 可以免费搭建高性能博客，绑定域名还能自动帮忙创建 SSL 证书。当然偷懒的话也可以直接使用默认分配的二级域名。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;toc-475&quot; class=&quot;anchor&quot; href=&quot;#toc-475&quot;/&gt;搭建&lt;/h2&gt;
&lt;a href=&quot;https://vercel.com/import/select-scope?s=https%3A%2F%2Fgithub.com%2Fvercel%2Fvercel%2Ftree%2Fmaster%2Fexamples%2Fhugo&amp;amp;template=hugo&amp;amp;id=67753070&quot; target=&quot;_vercel&quot;&gt;
  &lt;img src=&quot;https://vercel.com/button&quot; alt=&quot;创建 Hugo 博客&quot;/&gt;
&lt;/a&gt;

&lt;p&gt;点击上面的按钮快速抵达创建页面，未登录的会需要登录，这块直接使用 Github 登录即可。登录后第一步会让你选择 Vercel 账号，这里直接选择 &lt;code&gt;Personal Account&lt;/code&gt; 即可。之后会让你输入仓库名称，Vercel 会自动帮你创建并初始化该仓库。如果你的仓库不想让其它人看的话，这里可以勾选 &lt;code&gt;Private Git Repository&lt;/code&gt; 创建私有仓库。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://p3.ssl.qhimg.com/t010f5f1b79795f0eea.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下一步这块会让你输入 Vercel 中项目的名称和一些配置。这里需要注意一下，官方提供的默认 Hugo 编译命令会把草稿文章也生成出来。需要在 &lt;code&gt;BUILD COMMAND&lt;/code&gt; 那打开 OVERRIDE 按钮后输入 &lt;code&gt;hugo --gc&lt;/code&gt; 进行覆盖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p0.ssl.qhimg.com/t0192e198b383471a87.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;稍等片刻之后，你就可以看到飘着满屏的彩带庆祝你创建博客成功叻！点击 &lt;code&gt;Visit&lt;/code&gt; 按钮你就可以看到你的博客的样子了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p5.ssl.qhimg.com/t01672bbd54b1afc7f5.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于是静态博客，你所有的文章都会存储在你刚才新建的仓库中。你可以选择将仓库下来修改后提交，也可以利用 Github 的在线编辑功能在线修改提交。提交之后 Vercel 会自动触发更新，重新构建并更新你的博客。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;toc-224&quot; class=&quot;anchor&quot; href=&quot;#toc-224&quot;/&gt;配置&lt;/h2&gt;
&lt;p&gt;默认每次提交 Vercel 构建完成之后都会把构建后的地址评论在你的 Github 提交下。你可以通过设置关闭该功能。另外默认 Vercel 指定的 Hugo 版本比较老了，在 Markdown 编译过程中会发生一些异常的行为。我们可以通过配置指定最新的 Hugo 版本进行编译。在项目根目录下新建 &lt;code&gt;vercel.json&lt;/code&gt; 文件，并加入以下内容。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;github&quot;: {
    &quot;silent&quot;: true
  },
  &quot;build&quot;: {
    &quot;env&quot;: {
      &quot;HUGO_VERSION&quot;: &quot;0.78.1&quot;
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hugo 博客本身的配置都在 &lt;code&gt;config.toml&lt;/code&gt; 下。默认情况下 Hugo 生成的 URL 都是 &lt;code&gt;/posts/hello-world/&lt;/code&gt; 这种格式，不过之前做动态博客为了做伪静态，一般都将路由设置成了 &lt;code&gt;/hello-world.html&lt;/code&gt; 这种格式。这种时候就需要在 &lt;code&gt;config.toml&lt;/code&gt; 中增加 &lt;a href=&quot;https://gohugo.io/content-management/urls/#ugly-urls&quot;&gt;uglyurls&lt;/a&gt; 配置。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;uglyurls = true
[permalinks]
  posts = &quot;:slug&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后面的 &lt;code&gt;permalinks&lt;/code&gt; 配置主要是用来去除文章的 &lt;code&gt;/posts&lt;/code&gt; 前缀的。除此之外，默认的配置文章中的 HTML 是会被转义的，对于我这种偶尔会在 Markdown 中写 HTML 的人来说操作有点多余。这时候可以在配置中定义它不转义。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[markup.goldmark.renderer]
  unsafe= true&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a id=&quot;toc-190&quot; class=&quot;anchor&quot; href=&quot;#toc-190&quot;/&gt;域名&lt;/h2&gt;
&lt;p&gt;使用 Vercel 搭建的网站，它会默认提供一个 &lt;code&gt;*.vercel.app&lt;/code&gt; 的二级域名，你可以直接使用这个域名访问网站。如果你想要绑定自己的域名，也可以在后台设置。进入网站后选择自己的项目，选择 &lt;kbd&gt;Settings&lt;/kbd&gt; - &lt;kbd&gt;Domains&lt;/kbd&gt; 进入域名配置界面，在输入框中添加自己的域名。它会提示你需要给域名增加 A 记录或者是 CNAME 解析。按照提示添加后后台会自动检测是否生效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3.ssl.qhimg.com/t01c2a5a632902bd5fe.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生效的时间视 DNS 服务器的生效时间而定，我这边使用 DNSPod 还挺快的，大概 30 秒之内就生效了。生效后 Vercel 会自动帮我们申请配置 SSL 证书，我们全然不用操心证书的问题。等待片刻之后我们就能直接使用新域名进行访问了。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;toc-20d&quot; class=&quot;anchor&quot; href=&quot;#toc-20d&quot;/&gt;图片&lt;/h2&gt;
&lt;p&gt;默认所有的静态资源都放在 &lt;code&gt;static/&lt;/code&gt; 目录下。你可以将图片放在该目录下，例如 &lt;code&gt;static/hello-world.jpg&lt;/code&gt;。在文章中则直接使用 &lt;code&gt;/hello-world.jpg&lt;/code&gt; 地址引用即可。&lt;/p&gt;
&lt;p&gt;由于 Github 仅有单文件小于 100M 的&lt;a href=&quot;https://docs.github.com/en/free-pro-team@latest/github/managing-large-files/what-is-my-disk-quota#file-and-repository-size-limitations&quot;&gt;限制&lt;/a&gt;，Vercel 会将所有的资源部署到自己服务器上。所以使用仓库存储的方式会非常方便和安全，而且还不损失速度。唯一美中不足的是，由于是 HTTP 路径，在本地编写文章的时候会不方便。如果是使用 Typora 的话可以点击标签栏 &lt;kbd&gt;格式&lt;/kbd&gt; - &lt;kbd&gt;图像&lt;/kbd&gt; - &lt;kbd&gt;设置图片根目录&lt;/kbd&gt; 将目录指定到 &lt;code&gt;static/&lt;/code&gt; 目录解决。VSCode 的话暂时没有倒腾出来。&lt;/p&gt;
&lt;p&gt;其实比较好的方案是建议大家创建一个文件夹，将该篇文章和它所用到的图片都归置到一块。使用类似组件化的思路管理内容，会更加方便后续的修改。&lt;/p&gt;
&lt;p&gt;除了使用本地存储之外，你也可以选择使用第三方的存储服务。免费服务的话可以试试 &lt;a href=&quot;https://www.upyun.com/league&quot;&gt;又拍云&lt;/a&gt; 提供的联盟计划，按照要求申请下即可。其他家的存储服务要么免费时间有限，要么有部分收费功能。第三方存储的好处在于带有 CDN 加速，在速度上会很方便。但目前 Vercel 的速度我觉得还挺不错的，所以最终还是选择了直接存仓库。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;toc-553&quot; class=&quot;anchor&quot; href=&quot;#toc-553&quot;/&gt;评论&lt;/h2&gt;
&lt;p&gt;使用静态博客之后，评论则只能选择第三方评论系统了。鉴于国情，国内的第三方评论服务都已名存实亡。目前比较知名的 &lt;a href=&quot;https://disqus.com/&quot;&gt;Disqus&lt;/a&gt; , &lt;a href=&quot;https://www.hypercomments.com/&quot;&gt;HyperComments&lt;/a&gt; 以及 &lt;a href=&quot;https://www.livere.com/&quot;&gt;来必力&lt;/a&gt; 都是国外的服务。HyperComments 是付费的服务就不多做讨论，Disqus 是老牌服务，提供了强大的 API 对开发者较为友好。来必力则是对国内用户友好，集成了很多国内的社交账号登录。&lt;/p&gt;
&lt;p&gt;除了专门提供评论的第三方服务之外，也有一部分是选择自建评论服务。其中比较知名的是 &lt;a href=&quot;https://valine.js.org/&quot;&gt;Valine&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/gitalk/gitalk&quot;&gt;Gitalk&lt;/a&gt; 以及 &lt;a href=&quot;https://staticman.net/&quot;&gt;Staticman&lt;/a&gt;，&lt;a href=&quot;https://posativ.org/isso/&quot;&gt;isso&lt;/a&gt;。Staticman 提供了强大的 API 但是缺少界面，isso 则是需要服务器部署，偏离了我使用静态博客的初衷就是不想维护服务器的目的，所以这两者都不多做讨论。Gitalk 是使用 Github issue 进行评论数据存储的评论脚本，适合纯技术博客和极客使用。Valine 则是基于&lt;a href=&quot;https://leancloud.app/&quot;&gt;LeanCloud&lt;/a&gt; Serverless 云存储进行评论数据存储的评论脚本，同时它还带有漂亮的外观，适合各类人群使用。&lt;/p&gt;
&lt;p&gt;博客站点上与评论相关的地方一般有三个地方：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首页显示最近评论&lt;/li&gt;
&lt;li&gt;文章下显示当前文章评论数&lt;/li&gt;
&lt;li&gt;文章底部显示该文章的评论列表以及输入框&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最开始我选择了 Disqus 作为本站的评论系统。但是它有个问题国内正常无法访问。后来我发现 Hugo 的模板中是可以使用 &lt;code&gt;getJSON&lt;/code&gt; 方法调取接口的。而 Vercel 的机器本身就在海外，那我实际上可以在博客编译阶段就获取到输入写到页面中。最近评论和评论数的显示还是比较简单的，而评论列表的显示则需要折腾一下了。不过 Disqus API 的使用频率是 1000 次/小时，当短时间部署频繁的话可能会有超过的风险。而且发布评论的接口没办法走该逻辑，还是需要一个代理服务。&lt;/p&gt;
&lt;p&gt;最终让我决定不使用 Disqus 的原因是它的评论没办法让评论者输入网站地址，评论列表中的评论者昵称点击也无法跳转到用户输入的网站中。这对于有着大量的老式评论数据的我来说是不太能接受的。所以基于这些种种原因，我最后又将评论迁移到了 Valine 下。&lt;/p&gt;
&lt;p&gt;我对 Valine 的主要问题在于两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;早前使用 Valine 的时候发现了大量的 XSS 漏洞&lt;/li&gt;
&lt;li&gt;荒野无灯大大反馈的“&lt;a href=&quot;https://ttys3.net/post/hugo/please-stop-using-valine-js-comment-system-until-it-fixed-the-privacy-leaking-problem/&quot;&gt;泄露用户隐私问题&lt;/a&gt;”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上两个是非常重要的安全问题，不过我看 XSS 的问题作者已经修复，实际上对用户输入的所有 HTML 内容进行转义可以规避该问题。而灯大反馈的 IP 泄露的问题，作者也通过不记录 IP 来规避该问题。这两个问题造成的原因其实还是因为 &lt;strong&gt;Serverless&lt;/strong&gt; 。因为我想直接在编译的时候将相关数据静态化，所以我势必是需要增加一个服务端来帮我进行接口的封装，最后也能规避这些问题。&lt;/p&gt;
&lt;p&gt;不过 Valine 不知因为什么原因不开放源码，只在 Github 提供编译后代码，这点除了让我比较无语之外，改造工作也比较慢。本来我只需要将它 UI 中调用 LeanCloud API 的逻辑替换成我的接口逻辑即可。但是因为没有源码，只能自己重新制作 UI 了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;更新：基于 Valine 衍生的带后端评论系统已经完成 &lt;a href=&quot;https://github.com/lizheming/waline&quot;&gt;https://github.com/lizheming/waline&lt;/a&gt; 已切换至该评论系统。2020/11/08&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a id=&quot;toc-e5f&quot; class=&quot;anchor&quot; href=&quot;#toc-e5f&quot;/&gt;搜索&lt;/h2&gt;
&lt;p&gt;缺少服务端之后，静态博客的搜索功能也无法自己完成。目前比较知名的是第三方搜索服务 &lt;a href=&quot;https://www.algolia.com/&quot;&gt;Agolia&lt;/a&gt;，提供了免费的文章索引和搜索的功能。除了使用第三方服务之外，还发现有一种比较简单的做法就是将所有数据生成到一个文件中，前端下载该文件进行搜索结果展示。这里头比较知名的是 &lt;a href=&quot;https://www.npmjs.com/package/fuse&quot;&gt;fuse&lt;/a&gt;，它是一个 JS 模块，将输入传入之后它能帮我们快速的匹配到命中结果。&lt;/p&gt;
&lt;p&gt;目前本站使用的是后一种方法，该方法的优点是不依赖第三方服务，自己就能完成搜索功能。缺点是第一次搜索的时候需要下载完整的数据，对文章比较多的网站用户鸭梨会比较大。使用第二种方法第一步是需要先创建全量的数据索引，通过以下配置告知 Hugo 编译时创建 &lt;code&gt;index.json&lt;/code&gt; 索引文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[outputs]
  home = [&quot;HTML&quot;, &quot;RSS&quot;, &quot;JSON&quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然我们还需要为新的数据编写生成的模板文件，在 &lt;code&gt;layouts/&lt;/code&gt; 下增加 &lt;code&gt;index.json&lt;/code&gt; 文件，并加入以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs lang-clojure&quot;&gt;{{- $.Scratch.Add &lt;span class=&quot;hljs-string&quot;&gt;&quot;index&quot;&lt;/span&gt; slice -}}
{{- range .Site.RegularPages -}}
    {{- $.Scratch.Add &lt;span class=&quot;hljs-string&quot;&gt;&quot;index&quot;&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;dict&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;title&quot;&lt;/span&gt; .Title &lt;span class=&quot;hljs-string&quot;&gt;&quot;contents&quot;&lt;/span&gt; .Plain  &lt;span class=&quot;hljs-string&quot;&gt;&quot;summary&quot;&lt;/span&gt; .Summary &lt;span class=&quot;hljs-string&quot;&gt;&quot;permalink&quot;&lt;/span&gt; .Permalink &lt;span class=&quot;hljs-string&quot;&gt;&quot;date&quot;&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;.Date.Format&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;2006年01月02日&quot;&lt;/span&gt;)) -}}
{{- end -}}
{{- $.Scratch.Get &lt;span class=&quot;hljs-string&quot;&gt;&quot;index&quot;&lt;/span&gt; | jsonify -}}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中 &lt;code&gt;dict&lt;/code&gt;后的字典可以添加多个字段，视你 JS 渲染脚本中需要的字段而定。完成这些之后 Hugo 编译就会生成 &lt;code&gt;index.json&lt;/code&gt; 文件了。&lt;/p&gt;
&lt;p&gt;最后我们需要增加一个搜索页面，该页面会先加载 &lt;code&gt;index.json&lt;/code&gt; 然后使用 &lt;code&gt;fuse&lt;/code&gt; 进行数据查找，最后渲染成 HTML 输出搜索结果。具体的代码可以直接查看源码 &lt;a href=&quot;https://imnerd.org/search.html?q=hugo&quot;&gt;https://imnerd.org/search.html?q=hugo&lt;/a&gt; 参考本站的搜索页。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;//以下为示例代码
let fuse;
async function search(text) {
  if(!fuse) {
    const indexData = await fetch(&#x27;/index.json&#x27;, {method: &#x27;GET&#x27;}).then(resp =&amp;gt; resp.json());
    fuse = new Fuse(indexData, {...});
  }
  const result = fuse.search(text);
  renderHTML(result, &#x27;#app&#x27;);
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a id=&quot;toc-5a0&quot; class=&quot;anchor&quot; href=&quot;#toc-5a0&quot;/&gt;其它&lt;/h2&gt;
&lt;p&gt;Hugo 静态博客能提供给我们发挥的空间非常多，比如说我参考 &lt;a href=&quot;https://imququ.com&quot;&gt;屈屈的博客&lt;/a&gt; 增加了一个博客文章发布 &amp;gt;180 天的话，就在文章详情页黄条提醒：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;提醒：本文最后更新于 313 天前，文中所描述的信息可能已发生改变，请谨慎使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正常来说由于我没有服务端，所以只能使用前端来计算当前时间与发布时间的时间差。但其实转念一想，编译时也是可以拿到时间差的，只是这个时间差无法随着时间的变化而变化。不过我只要每天编译一次，就能解决变化的问题了。在 Vercel 项目 &lt;kbd&gt;Settings&lt;/kbd&gt; - &lt;kbd&gt;Git&lt;/kbd&gt; - &lt;kbd&gt;Deploy Hooks&lt;/kbd&gt; 中你可以输入 Hook 名称和触发分支创建一个 Hook URL。只要访问该 URL 就可以触发 Vercel 更新博客。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;{{ if eq .Type &quot;posts&quot; -}}
    {{ $ageDays := div (sub now.Unix .Date.Unix) 86400 }}
    {{ if gt $ageDays 180 }}
        &amp;lt;p class=&quot;expired-tips&quot;&amp;gt; 提醒：本文最后更新于&amp;amp;nbsp;{{$ageDays}}&amp;amp;nbsp;天前，文中所描述的信息可能已发生改变，请谨慎使用。&amp;lt;/p&amp;gt;
    {{ end }}
{{ end }}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而在 Vercel 的 Marketplace 中，有一个 &lt;a href=&quot;https://easycron.com/&quot;&gt;EasyCron&lt;/a&gt; 的服务提供了定时任务的功能。我在上面设置了每天零点访问 Hook URL 触发博客更新，就这样解决每天需要更新时间的问题。&lt;/p&gt;
&lt;p&gt;另外屈屈博客中的“查看本文Markdown版本”也是个不错的功能，在 Hugo 中也可以实现，本质是在编译的时候顺便生成一份 &lt;code&gt;.md&lt;/code&gt; 的 Markdown 文件即可。&lt;/p&gt;
&lt;p&gt;首先我们需要在 &lt;code&gt;layouts/&lt;/code&gt; 下增加 &lt;code&gt;single.md&lt;/code&gt; 文件，表示的是当文章页（Single）需要导出 &lt;code&gt;.md&lt;/code&gt; 的数据的时候使用该模板。模板内容不用填写，为空即可。然后在 &lt;code&gt;config.toml&lt;/code&gt; 中新增 &lt;code&gt;.md&lt;/code&gt; 文件类型，并告知 Hugo 文章需要增加编译 Markdown 文件类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[mediaTypes]
  [mediaTypes.&quot;text/plain&quot;]
    suffixes = [&quot;md&quot;]

[outputFormats.MarkDown]
  mediaType = &quot;text/plain&quot;
  isPlainText = true
  isHTML = false

[outputs]
  page = [&quot;HTML&quot;, &quot;MarkDown&quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>