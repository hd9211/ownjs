<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0a84402385f13817982978ace28e0e6b</guid>
<title>利用 Redsocks 解决透明代理的远程抓包问题</title>
<link>https://toutiao.io/k/xdc60me</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;toc-content post no-image&quot;&gt;
      &lt;h2 id=&quot;%E8%83%8C%E6%99%AF&quot;&gt;背景&lt;/h2&gt;&lt;p&gt;最近在做一些远程设备的抓包能力建设。具体来说是设备（基于 Docker 的 Redroid 云手机）在服务器上，抓包工具在本地（ Mitmproxy , Charles, Fiddler 等类似工具），希望通过某种方法将远程设备上的流量打到本地的抓包工具上，并且流量通过本地的 IP 出到公网。&lt;/p&gt;&lt;p&gt;这样做的目的主要有两个：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;可以做到抓包工具和待抓包设备的分离。既能利用上强大的第三方抓包工具，又无需本地部署待抓包的设备。毕竟如果在远程服务器上部署抓包工具，操作起来就不那么方便，甚至可能还需要自行开发管控界面；如果在本地部署待抓包设备，很可能会遇到例如芯片架构、操作系统、环境依赖、系统资源消耗等问题。&lt;/li&gt;&lt;li&gt;可以方便进行 IP 出口的调整。在调试一些不可言说的功能时，服务器上部署的设备很可能是走一些代理 IP 池，有时候这些 IP 池本身可能有点问题，导致远程设备被封。这时候如果我们能够将设备的流量导到本地的正常 IP 出公网，可能会更方便我们验证是 IP 问题还是其他的设备问题。&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;%E8%AE%A1%E5%88%92&quot;&gt;计划&lt;/h2&gt;&lt;p&gt;为了打通远程设备本地抓包的这套链路，我们需要考虑如下技术点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;远程设备需要能够安装本地抓包工具的证书。&lt;/li&gt;&lt;li&gt;远程设备的流量需要通过某种内网穿透能力打到本地的代理工具上。&lt;/li&gt;&lt;li&gt;远程设备的流量需要保证不遗漏地进行转发。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;由于我们的远程设备是有 root 权限的云手机，因此证书安装并不难。只要将本地的证书通过 openssl 命令转换成指定格式的证书文件，传到服务器上，在云手机启动时 bind 到 &lt;code&gt;/system/etc/security/cacerts/&lt;/code&gt;  目录下即可。&lt;/p&gt;&lt;p&gt;同理，由于远程设备是云手机，通过暴露 adb 的 tcpip 端口，我们可以用本地的 adb 客户端进行连接，再通过 adb reverse 就可以构建一个云手机访问本机代理端口的信道。&lt;/p&gt;&lt;p&gt;而要保证云手机的流量（这里特指 HTTP/HTTPS 流量）不遗漏的进行转发，我们就不能采用配置全局正向代理的方法（ &lt;code&gt;adb shell settings put global http_proxy xxxx&lt;/code&gt;  ），因为个别 app 可以配置强制 NO_PROXY 不走系统代理。一个简单的方法是通过云手机自带的 iptables 工具进行转发，将云手机中所有目的端口为 80/443 的流量转发到 adb reverse 命令转发过来的、映射到本地抓包工具的代理端口即可。&lt;/p&gt;&lt;p&gt;理想的架构图如下：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2022/05/---.excalidraw.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot; srcset=&quot;https://blog.mythsman.com/content/images/size/w600/2022/05/---.excalidraw.png 600w, https://blog.mythsman.com/content/images/size/w1000/2022/05/---.excalidraw.png 1000w, https://blog.mythsman.com/content/images/2022/05/---.excalidraw.png 1079w&quot; sizes=&quot;(min-width: 720px) 720px&quot;/&gt;&lt;/figure&gt;&lt;h2 id=&quot;%E9%97%AE%E9%A2%98&quot;&gt;问题&lt;/h2&gt;&lt;p&gt;架构图谁都会画，但是真正实操起来才发现有一堆坑。这套流程对 HTTP 请求的确是有用的，透明代理的工具无论是使用 Charles 还是 Mitmproxy 等中间人代理工具都能正常抓到包。但是对与 HTTPS 的流量则都出现了问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Charles 会报 &lt;code&gt;invalid first line in request&lt;/code&gt; 的错。&lt;/li&gt;&lt;li&gt;Mitmproxy 会报 &lt;code&gt;Could not resolve original destination&lt;/code&gt; 的错。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;当然，个别代理工具可能不支持解 HTTPS ，出现问题可以理解。但是各种代理工具都不能抓，那显然应当是流程上出了问题。经过实验我们发现，使用正向代理或非 HTTPS 的透明代理再加上端口转发都是能通的，唯一不能通的是 HTTPS 的透明代理模式。那么我们就需要先辨析一下这些模式的区别。&lt;/p&gt;&lt;h2 id=&quot;%E5%88%86%E6%9E%90&quot;&gt;分析&lt;/h2&gt;&lt;h3 id=&quot;%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86&quot;&gt;正向代理&lt;/h3&gt;&lt;p&gt;正向代理是由客户端主动发起，主动将流量打给一个代理服务器，由代理服务器代替请求的过程。下图主要展示正向代理过程中 IP 报文的变化：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2022/05/-------.excalidraw.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot; srcset=&quot;https://blog.mythsman.com/content/images/size/w600/2022/05/-------.excalidraw.png 600w, https://blog.mythsman.com/content/images/size/w1000/2022/05/-------.excalidraw.png 1000w, https://blog.mythsman.com/content/images/2022/05/-------.excalidraw.png 1265w&quot; sizes=&quot;(min-width: 720px) 720px&quot;/&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;Alice 代表发起请求的客户端&lt;/li&gt;&lt;li&gt;Flank 代表代理服务器（Forward Proxy）&lt;/li&gt;&lt;li&gt;Bob 代表客户端需要请求到的服务器&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86&quot;&gt;透明代理&lt;/h3&gt;&lt;p&gt;透明代理是客户端本身无感知的，由路由转发工具强行进行流量转发（Linux 下可以用 iptables ，Windows 下可以用 netsh ，Mac 下可以用 pfctl）。下图主要展示透明代理过程中 IP 报文的变化：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2022/05/------.excalidraw.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot; srcset=&quot;https://blog.mythsman.com/content/images/size/w600/2022/05/------.excalidraw.png 600w, https://blog.mythsman.com/content/images/size/w1000/2022/05/------.excalidraw.png 1000w, https://blog.mythsman.com/content/images/size/w1600/2022/05/------.excalidraw.png 1600w, https://blog.mythsman.com/content/images/2022/05/------.excalidraw.png 2266w&quot; sizes=&quot;(min-width: 720px) 720px&quot;/&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;Alice 代表发起请求的客户端&lt;/li&gt;&lt;li&gt;Ivan 代表转发流量的路由工具（Iptables之类的工具）&lt;/li&gt;&lt;li&gt;Tom 代表透明代理服务器（Transparent Proxy）&lt;/li&gt;&lt;li&gt;Bob 代表客户端需要请求到的服务器&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在透明代理模式下，路由工具会非常暴力地将客户端发来的包的目的地址直接改为透明代理服务器，这会导致当数据包到了透明代理服务器中时，代理服务器是无法直接获取客户端真正想要到达的服务器地址。而正向代理服务器则不同，客户端会明确告知代理服务器他想访问谁。&lt;/p&gt;&lt;p&gt;那么透明代理服务器要如何在报文中获得真实的目的地址呢？这时候就需要分情况讨论了。&lt;/p&gt;&lt;h4 id=&quot;http&quot;&gt;HTTP&lt;/h4&gt;&lt;p&gt;我们知道 HTTP 报文是纯明文，就像一个没有封口的信封。只要打开来看就会发现，HTTP 请求报文会在 Header 中带上一个 Host 头表明当前的信期望到达的地方。透明代理服务器可以非常方便地解析到这个信息，从而知道报文需要被发送到的目的地址（Bob）。&lt;/p&gt;&lt;h4 id=&quot;https&quot;&gt;HTTPS&lt;/h4&gt;&lt;p&gt;HTTPS 这里就比较尴尬了。我们知道 HTTPS 在第四层有一个 TLS 加密层，如果想和 HTTP 一样从 Header 中获取 Host 头的话，则需要先进行 TLS 解密；但是，如果想进行 TLS 解密，则必须和实际的服务器进行 TLS 握手；可是你都不知道实际的服务器在哪，如果握手呢？这竟然变成了一个鸡生蛋还是蛋生鸡的问题。&lt;/p&gt;&lt;p&gt;那么问题最终会怎么解决呢？目光还得回到路由工具。&lt;/p&gt;&lt;p&gt;既然报文是你路由工具传给透明代理的，那显然路由工具这边是记录了报文原先实际需要访问的目的地址的，我直接请求你不就好了么？在 Linux 下，我们有一个用户工具 conntrack 可以展示当前网络连接的链路追踪信息：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sudo conntrack -L
tcp      6 60 TIME_WAIT src=192.168.32.1 dst=192.168.32.3 sport=40298 dport=8080 src=192.168.32.3 dst=192.168.32.1 sport=8080 dport=40298 [ASSURED] mark=0 use=1
tcp      6 56 TIME_WAIT src=192.168.32.1 dst=192.168.32.7 sport=54398 dport=2368 src=192.168.32.7 dst=192.168.32.1 sport=2368 dport=54398 [ASSURED] mark=0 use=1
tcp      6 60 TIME_WAIT src=192.168.32.5 dst=172.17.0.1 sport=52992 dport=5001 src=172.17.0.1 dst=192.168.32.5 sport=5001 dport=52992 [ASSURED] mark=0 use=1
tcp      6 79 TIME_WAIT src=10.0.0.4 dst=168.63.129.16 sport=39414 dport=80 src=168.63.129.16 dst=10.0.0.4 sport=80 dport=39414 [ASSURED] mark=0 use=1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而透明代理程序则可以通过 getsockopt 等方法直接向内核查询 socket 的链路信息：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;static int getdestaddr(int fd, struct sockaddr_storage *destaddr)
{
    socklen_t socklen = sizeof(*destaddr);
    int error         = 0;

    error = getsockopt(fd, SOL_IPV6, IP6T_SO_ORIGINAL_DST, destaddr, &amp;amp;socklen);
    if (error) { // Didn&#x27;t find a proper way to detect IP version.
        error = getsockopt(fd, SOL_IP, SO_ORIGINAL_DST, destaddr, &amp;amp;socklen);
        if (error) {
            return -1;
        }
    }
    return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样一来，透明代理服务就能在 TLS 握手前就能拿到真实的目的 IP 了。&lt;/p&gt;&lt;p&gt;然而有了 IP 就够了么？并不是。路由工具中我们只能拿到目的 IP ，但是并没有域名！现代服务端的网关层基本都需要通过域名来进行转发。如何解决这个问题呢？这就引入了 SNI （&lt;strong&gt;Server Name Indication&lt;/strong&gt;）头。在 TLS 握手阶段，客户端会在握手报文里额外增加 SNI 信息（这个已经是TLS标准了，但是有些客户端可能没有加），这样服务端或者透明代理服务器就能获取到实际的域名了。&lt;/p&gt;&lt;p&gt;最后我们再来看下 Mitmproxy 文档中提供的透明代理的流程图：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2022/05/image-1.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;&lt;h2 id=&quot;%E8%A7%A3%E5%86%B3&quot;&gt;解决&lt;/h2&gt;&lt;p&gt;了解了代理服务器的工作细节，我们再来尝试回答下开头的问题。为什么把远端的 HTTPS 流量通过路由工具+端口映射转发到本地的透明代理服务器中会报错呢？&lt;/p&gt;&lt;p&gt;答案已经很明显了，那就是&lt;strong&gt;本地的透明代理工具无法查询到远端服务器中的路由链路信息，导致无法获取真实的目的地址&lt;/strong&gt;。（也就是为什么 mitmproxy 会报 &lt;code&gt;Could not resolve original destination&lt;/code&gt;的原因。&lt;/p&gt;&lt;p&gt;解决这个问题的思路也很清晰，&lt;strong&gt;既然希望走透明代理的流量无法跨主机，那我们就将透明代理服务部署在本机，然后转换成正向代理出去即可&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;具体操作中，由于 mitmproxy 默认不支持在透明代理模式下再配置一个上游正向代理，因此我们可以选择简单魔改一下代码，在透明代理模式下的出口处请求另一个正向代理。&lt;/p&gt;&lt;p&gt;如果懒得改代码，我找到了一个 &lt;a href=&quot;https://github.com/darkk/redsocks&quot;&gt;Redsocks&lt;/a&gt; 工具。这个工具可以直接作为透明代理服务器，并将流量转发给一个上游的正向代理。Ubuntu 下可以直接用 apt 安装，配置一下 /etc/redsocks.conf 就能直接使用。&lt;/p&gt;&lt;p&gt;如此，架构图修改成下图即可：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2022/05/---2.excalidraw.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot; srcset=&quot;https://blog.mythsman.com/content/images/size/w600/2022/05/---2.excalidraw.png 600w, https://blog.mythsman.com/content/images/size/w1000/2022/05/---2.excalidraw.png 1000w, https://blog.mythsman.com/content/images/2022/05/---2.excalidraw.png 1237w&quot; sizes=&quot;(min-width: 720px) 720px&quot;/&gt;&lt;/figure&gt;&lt;h2 id=&quot;%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99&quot;&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.mitmproxy.org/stable/concepts-howmitmproxyworks/#transparent-https&quot;&gt;Mitmproxy Docs - Transparent HTTPS&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://yemablog.com/posts/transparent-proxy&quot;&gt;如何使用透明代理抓 HTTPS&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.ichenfu.com/2019/04/09/istio-inbond-interception-and-linux-transparent-proxy/&quot;&gt;Istio的流量劫持和Linux下透明代理实现&lt;/a&gt;&lt;/p&gt;
    &lt;/section&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4f771bf62e553be1c95997fd8746bd7c</guid>
<title>JVM 类加载器与双亲委派模型</title>
<link>https://toutiao.io/k/f1pa9jb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 类加载器&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，虚拟机在加载类的过程中需要使用类加载器进行加载，而在 Java 中，类加载器有很多，那么当 JVM 想要加载一个 &lt;code&gt;.class&lt;/code&gt; 文件的时候，到底应该由哪个类加载器加载呢？这时候就需要双亲委派机制来告诉 JVM 使用哪个类加载器加载。在讲解什么是双亲委派机制之前，我们先看一下有哪些加载器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 Java 虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器 Bootstrap ClassLoader，这个类加载器使用 C++ 语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。从 Java 开发人员的角度来看，类加载器还可以划分得更细致一些，分为用户级别和系统级别类加载器。用户级别的类加载器我们统一称为自定义类加载器，而系统级别的类加载器有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;启动类加载器：Bootstrap ClassLoader&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扩展类加载器：Extention ClassLoader&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用程序类加载器：Application ClassLoader&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 启动类加载器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动类加载器 Bootstrap ClassLoader 使用 C/C++ 语言实现，负责将存放在 &lt;code&gt;&amp;lt;JAVA_HOME&amp;gt;\lib&lt;/code&gt; 目录中的，或者被 &lt;code&gt;-Xbootclasspath&lt;/code&gt; 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用 null 代替即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过如下代码查看启动类加载器可以加载哪些路径的 jar：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String bootStrapPath = System.getProperty(&lt;span&gt;&quot;sun.boot.class.path&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(&lt;span&gt;&quot;启动类加载器加载的路径: &quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (String paths : bootStrapPath.split(&lt;span&gt;&quot;;&quot;&lt;/span&gt;)){&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (String path : paths.split(&lt;span&gt;&quot;:&quot;&lt;/span&gt;)) {&lt;br/&gt;        System.out.println(path);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 扩展类加载器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩展类加载器 Extension ClassLoader 由 Java 语言编写，并由 &lt;code&gt;sun.misc.Launcher$ExtClassLoader&lt;/code&gt; 实现，父类加载器为启动类加载器。负责加载 &lt;code&gt;&amp;lt;JAVA_HOME&amp;gt;\lib\ext&lt;/code&gt; 目录中的，或者被 &lt;code&gt;java.ext.dirs&lt;/code&gt; 系统变量所指定的路径中的所有类库。开发者可以直接使用扩展类加载器，如果用户创建的 JAR 放在扩展目录下，也会自动由扩展类加载器加载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过如下代码查看扩展类加载器可以加载哪些路径的 jar：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String extClassLoaderPath = System.getProperty(&lt;span&gt;&quot;java.ext.dirs&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(&lt;span&gt;&quot;拓展类加载器加载的路径: &quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (String paths : extClassLoaderPath.split(&lt;span&gt;&quot;;&quot;&lt;/span&gt;)){&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (String path : paths.split(&lt;span&gt;&quot;:&quot;&lt;/span&gt;)) {&lt;br/&gt;        System.out.println(path);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3 应用程序类加载器&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用程序类加载器 Application ClassLoader 由 Java 语言编写，并由 &lt;code&gt;sun.misc.Launcher$App-ClassLoader&lt;/code&gt; 实现，父类加载器为扩展类加载器。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径 ClassPath 或系统属性 &lt;code&gt;java.class.path&lt;/code&gt; 指定路径下的类库。开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过如下代码查看应用程序类加载器可以加载哪些路径的 jar：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String appClassLoaderPath = System.getProperty(&lt;span&gt;&quot;java.class.path&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (String paths : appClassLoaderPath.split(&lt;span&gt;&quot;;&quot;&lt;/span&gt;)){&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;应用程序类加载器加载的路径: &quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (String path : paths.split(&lt;span&gt;&quot;:&quot;&lt;/span&gt;)) {&lt;br/&gt;        System.out.println(path);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.4 自定义类加载器&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Java 的日常应用程序开发中，类的加载几乎是由上述 3 种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。那么什么场景下需要自定义类加载器呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发人员可以通过继承抽象类 java.lang.ClassLoader 类的方式，实现自己的类加载器，以满足一些特殊的需求。在 JDK 1.2 之前，在自定义类加载器时，总会去继承 ClassLoader 类并重写 loadClass() 方法，从而实现自定义的类加载类，但是在 JDK 1.2 之后已不再建议用户去覆盖 loadClass() 方法，而是建议把自定义的类加载逻辑写在 findclass() 方法中。下面我们来实现一个自定义类加载器并演示如何使用。第一步自定义一个实体类 Car.java：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 测试对象 Car&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Car&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Car&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;welcome you&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;this is a car&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步自定义一个类加载器，我们定义的 CustomClassLoader 继承自 java.lang.ClassLoader，且只实现 findClass 方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 自定义加载器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CustomClassLoader&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ClassLoader&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String path;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;CustomClassLoader&lt;/span&gt;&lt;span&gt;(String path)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.path = path;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt; findClass(String name) &lt;span&gt;throws&lt;/span&gt; ClassNotFoundException {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;CustomClassLoader: &quot;&lt;/span&gt; + name);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            String fileName = path + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + name.substring(name.lastIndexOf(&lt;span&gt;&quot;.&quot;&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;) + &lt;span&gt;&quot;.class&quot;&lt;/span&gt;;&lt;br/&gt;            FileInputStream inputStream = &lt;span&gt;new&lt;/span&gt; FileInputStream(fileName);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (inputStream == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.findClass(name);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[inputStream.available()];&lt;br/&gt;            inputStream.read(bytes);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; defineClass(name, bytes, &lt;span&gt;0&lt;/span&gt;, bytes.length);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException ex) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ClassNotFoundException(name, ex);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三步演示自定义类加载器如何使用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CustomClassLoader myClassLoader = &lt;span&gt;new&lt;/span&gt; CustomClassLoader(&lt;span&gt;&quot;/opt/data&quot;&lt;/span&gt;);&lt;br/&gt;Class&amp;lt;?&amp;gt; myClass = myClassLoader.loadClass(&lt;span&gt;&quot;com.common.example.bean.Car&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 创建对象实例&lt;/span&gt;&lt;br/&gt;Object o = myClass.newInstance();&lt;br/&gt;&lt;span&gt;// 调用方法&lt;/span&gt;&lt;br/&gt;Method print = myClass.getDeclaredMethod(&lt;span&gt;&quot;print&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;print.invoke(o, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 输出类加载器&lt;/span&gt;&lt;br/&gt;System.out.println(&lt;span&gt;&quot;ClassLoader: &quot;&lt;/span&gt; + o.getClass().getClassLoader());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接运行上述代码，会输出如下结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;welcome you&lt;br/&gt;this is a car&lt;br/&gt;ClassLoader: sun.misc.Launcher&lt;span&gt;$AppClassLoader&lt;/span&gt;@49476842&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面看到输出结果并不符合我们的预期，Car 类使用的应用程序类加载器加载的，并不是我们自定义的类加载器。这个问题主要是因为 Idea 编译后会存放在 target/classes 目录下&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8093994778067886&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6LrrHRRxT1xEvMEVoibekmGq1x9s6vKCEflPfTTnKDaA7ZZO63BKmtD5TDrpEN9qdve8Eqiceuib7sejqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;383&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这个目录正好是应用程序类加载的路径，可以使用ClassLoaderPathExample代码验证。为了解决这个问题，我们可以把 Car.class 手动移动到 /opt/data 目录下（删除 target/classes 目录下的 Car.class 文件，避免由应用程序类加载器加载）。再次运行输出如下结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CustomClassLoader: com.common.example.bean.Car&lt;br/&gt;welcome you&lt;br/&gt;this is a car&lt;br/&gt;ClassLoader: com.common.example.jvm.classLoader.CustomClassLoader@4617c264&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样 Car 类就使用我们自定义的类加载器加载了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 什么是双亲委派模型&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述四种类加载器之间存在着一种层次关系，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.978494623655914&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6LrrHRRxT1xEvMEVoibekmGq1xIKpFeYaVibn3NgVGTzJZBv7WCibs8XVlAib2w8LgOnKhsLiaIYmfoNx2jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般认为上一层加载器是下一层加载器的父类加载器，除了启动类加载器 BootstrapClassLoader 之外，所有的加载器都是有父类加载器。我们可以先通过如下代码来看一下类加载器的层级结构：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 应用程序类加载器(系统类加载器)&lt;/span&gt;&lt;br/&gt;ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();&lt;br/&gt;System.out.println(systemClassLoader); &lt;span&gt;// sun.misc.Launcher$AppClassLoader@49476842&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 获取上层加载器:扩展类加载器&lt;/span&gt;&lt;br/&gt;ClassLoader extClassLoader = systemClassLoader.getParent();&lt;br/&gt;System.out.println(extClassLoader); &lt;span&gt;// sun.misc.Launcher$ExtClassLoader@5acf9800&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 获取上层加载器:启动类加载器&lt;/span&gt;&lt;br/&gt;ClassLoader bootstrapClassLoader = extClassLoader.getParent();&lt;br/&gt;System.out.println(bootstrapClassLoader); &lt;span&gt;// null&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上述代码中依次输出当前类的类加载器，父类加载器以及父类的父类加载器。可以看到当前类的加载器是应用程序类加载器，它的父类亲加载器是扩展类加载器，扩展类加载器的父类输出了一个 null，这个 null 会去调用启动类加载器。后续通过 ClassLoader 类的源码我们可以知道这一点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那到底什么是双亲委派模型呢？其实我们把上述类加载器之间的这种层次关系，我们称为类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类加载器的双亲委派模型是在 JDK 1.2 期间被引入并被广泛应用于之后几乎所有的 Java 程序中。但它并不是一个强制性的约束模型，而是 Java 设计者推荐给开发者的一种类加载器实现方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们从概念上知道了什么是双亲委派模型，那它到底是如何工作的呢？双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都委派到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 为什么需要双亲委派模型&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上面我们提到的，因为类加载器之间有严格的层次关系，那么也就使得 Java 类也随之具备了一种带有优先级的层次关系。例如类 java.lang.Object，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，但最终都委派给最顶层的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面我们可以知道双亲委派模型的核心是保障类加载的唯一性和安全性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;唯一性：可以避免类的重复加载，当父类加载器已经加载过某一个类时，子加载器就不会再重新加载这个类。例如上述提及的 java.lang.Object 类，最终都委派给最顶层的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安全性：保证了 Java 的核心 API 不被篡改。因为启动类加载器 Bootstrap ClassLoader 在加载的时候，只会加载 JAVA_HOME 中的 jar 包里面的类，如 java.lang.Object，那么就可以避免加载自定义的有破坏能力的 java.lang.Object。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 双亲委派模型是怎么实现的&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型对于保证 Java 程序的稳定运作很重要，但它的实现却非常简单，实现双亲委派的代码都集中在 java.lang.ClassLoader 的 loadClass() 方法之中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt; loadClass(String name, &lt;span&gt;boolean&lt;/span&gt; resolve) &lt;span&gt;throws&lt;/span&gt; ClassNotFoundException {&lt;br/&gt;    &lt;span&gt;synchronized&lt;/span&gt; (getClassLoadingLock(name)) {&lt;br/&gt;        &lt;span&gt;// 首先检查类是否已经被加载过&lt;/span&gt;&lt;br/&gt;        Class&amp;lt;?&amp;gt; c = findLoadedClass(name);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;long&lt;/span&gt; t0 = System.nanoTime();&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (parent != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;// 若没有加载过并且有父类加载器则调用父类加载器的 loadClass() 方法&lt;/span&gt;&lt;br/&gt;                    c = parent.loadClass(name, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;                } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;// 调用启动类加载器&lt;/span&gt;&lt;br/&gt;                    c = findBootstrapClassOrNull(name);&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (ClassNotFoundException e) {&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;// 如果仍未找到，则调用 findClass 以查找该类。&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;long&lt;/span&gt; t1 = System.nanoTime();&lt;br/&gt;                c = findClass(name);&lt;br/&gt;                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);&lt;br/&gt;                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);&lt;br/&gt;                sun.misc.PerfCounter.getFindClasses().increment();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (resolve) {&lt;br/&gt;            resolveClass(c);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; c;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先检查类是否已经被加载过，若没有加载过并且有父类加载器则调用父类加载器的 loadClass() 方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出 ClassNotFoundException 异常后，再调用自己的 findClass() 方法进行加载。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 如何破坏双亲委派模型&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型并不是一个强制性的约束模型，而是 Java 设计者推荐给开发者的类加载器实现方式。在 Java 的世界中大部分的类加载器都遵循这个模型，但也有例外，到目前为止，双亲委派模型主要出现过 3 较大规模的&#x27;被破坏&#x27;情况。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 JDK 1.2 历史原因&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的第一次&#x27;被破坏&#x27;其实发生在双亲委派模型出现之前，即 JDK 1.2 发布之前。由于双亲委派模型在 JDK 1.2 之后才被引入，而类加载器和抽象类 java.lang.ClassLoader 则在 JDK 1.0 时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java 设计者引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK 1.2 之后的 java.lang.ClassLoader 添加了一个新的 protected 方法 findClass()，在此之前，用户去继承 java. lang.ClassLoader 的唯一目的就是为了重写 loadClass() 方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法 loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的 loadClass()。上一节我们已经看过 loadClass() 方法的代码，双亲委派的具体逻辑就实现在这个方法之中，JDK 1.2之 后已不提倡用户再去覆盖 loadClass() 方法，而应当把自己的类加载逻辑写到 findClass() 方法中，在 loadClass() 方法的逻辑里如果父类加载失败，则会调用自己的 findClass() 方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 SPI&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的第二次&#x27;被破坏&#x27;是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的 API，但世事往往没有绝对的完美，如果基础类又要调用回用户的代码，那该怎么办？这并非是不可能的事情，一个典型的例子便是 JNDI 服务，JNDI 现在已经是 Java 的标准服务，它的代码由启动类加载器去加载（在 JDK 1.3 时放进去的 rt.jar 中），但 JNDI 的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序 ClassPath 下的 JNDI 接口提供者（SPI，Service Provider Interface）的代码，但启动类加载器不可能&#x27;认识&#x27;这些代码。为了解决这个问题，Java 设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoaser() 方法进行设置，如果创建线程时还未设置，将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。有了线程上下文类加载器，就可以做一些&#x27;舞弊&#x27;的事情了，JNDI 服务使用这个线程上下文类加载器去加载所需要的 SPI 代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java 中所有涉及 SPI 的加载动作基本上都采用这种方式，例如 JNDI、JDBC、JCE、JAXB和JBI等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 模块化&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的第三次&#x27;被破坏&#x27;是由于用户对程序动态性的追求而导致的，这里所说的&#x27;动态性&#x27;指的是当前一些非常&#x27;热门&#x27;的名词：代码热替换（HotSwap）、模块热部署（Hot Deployment）等。Sun 公司所提出的JSR-294、JSR-277 规范在与 JCP 组织的模块化规范之争中落败给 JSR-291（即OSGi R4.2），虽然 Sun 不甘失去 Java 模块化的主导权，独立在发展 Jigsaw 项目，但目前 OSGi 已经成为了业界事实上的 Java 模块化标准，而 OSGi 实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考：&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>65fadeac3f79be26212bb9458eb084f5</guid>
<title>万字长文详解携程酒店订单缓存 &amp;amp; 存储系统升级实践</title>
<link>https://toutiao.io/k/eybtbwc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:0.title1&quot;&gt;&lt;p&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;荣&lt;/span&gt;&lt;span&gt;华&lt;/span&gt;&lt;span&gt;，携&lt;/span&gt;&lt;span&gt;程&lt;/span&gt;&lt;span&gt;高&lt;/span&gt;&lt;span&gt;级研发经理，专注于后&lt;/span&gt;&lt;span&gt;端技术项目研发&lt;/span&gt;&lt;span&gt;管理&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;军威，携程&lt;/span&gt;&lt;span&gt;软件技&lt;/span&gt;&lt;span&gt;术&lt;/span&gt;&lt;span&gt;专家，&lt;/span&gt;&lt;span&gt;负责分布式缓存系&lt;/span&gt;&lt;span&gt;统开发 &amp;amp; 存储架构迁移项目。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;金永，携程资深软件工程师，专注于实时计算，数据分析工程。&lt;/p&gt;&lt;p&gt;俊强，携程高级后端开发工程师，拥有丰富SQLServer使用经验&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;前&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;言&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程酒店订单系统的存储设计从1999年收录第一单以来，已经完成了从单一SQLServer数据库到多IDC容灾、完成分库分表等多个阶段，在见证了大量业务奇迹的同时，也开始逐渐暴露出老骥伏枥的心有余而力不足之态。基于更高稳定性与高效成本控制而设计的订单存储系统，已经是携程在疫情后恢复业务的必然诉求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前携程酒店订单系统正面临着在业务高增长的同时信息读写管理能力受制于数据库自身性能与稳定性的窘境。综合分析，一则为携程服役了十多年的SQLServer服务器集群的磁盘容量设计，已经跟不上时下新增订单量的空间诉求；二则在系统能力提升上造成了各大业务系统巨大的底层瓶颈与风险，同时又相比业界主流已基于MySQL架构设计存储系统而言，我们的订单存储系统仍基于SQLServer构建也整体推高了运营成本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了支撑未来每日千万级订单的业务增长目标，同时满足高可用、高性能、高可扩展的高效成本控制期望，我们为酒店部门的订单DB所有访问开发并落地了一套稳定且可靠的统一中间件封装方案，对现状收敛并提供了全局统一的热点缓存系统，彻底解决了当下订单上层应用与数据库间直连的方案缺陷。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;新系统由中间件服务统一实现了对上层应用提供数据链服务，并达成了为现有依赖订单库的应用以及其他直接或间接的数据应用无感的实现存储底层由SQLServer向MySQL技术架构迁移的目标。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;一、架构综述&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过对现有系统瓶颈的分析，我们发现核心缺陷集中在订单数据缓存分散导致数据各端不一致，各订单应用则与数据库直连又造成可扩展性差。通过实践我们编写中间件抽象并统一了数据访问层，以及基于数据库部署架构镜像构建了订单缓存统一管理热点数据，解决了各端差异。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.41875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1eq3axNnoFTPLWbhRyhKWFib2NCR8EmEgl2aXJT8syHLiap3c5Mv4KeBefGF4XgpgE2uTXX7ibXytygg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;480&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1.1  存储系统架构图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;二、应用场景&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;2.1  新单秒级各端同步&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从订单的提交到各端可见的速度为存储服务的核心指标之一，我们对数据链的主要环节进行了优化，覆盖了新单同步、消息实时推送、查询索引构建以及数据平台离线归档等主要环节，使大系统内数据到达速度在3秒以内，即用户刚下完单即可跳转我携列表可见。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当新用户创单时，同步服务作为数据链入口将用户订单数据通过中间件写入订单库，此时中间件同时完成订单缓存的构建；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当订单完成入库行为和热点数据构建后抛订单消息，实时输出给各子系统；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当新单入库完毕即刻构建订单明细信息的ES索引，为第三方提供检索支持；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最后数据平台T+1实施当日数据的归档供BI等各类离线业务使用；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5074626865671642&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1eq3axNnoFTPLWbhRyhKWFibFQa7bcFiczYgic1WILp1gzunRUt7ucZQDwapa7ybSiaj49ib3eClKvWibBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;737&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2.1 数据链&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;2.2  自动发单与工作台&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对客、商、员工工作台三端的支持是订单存储系统的基本角色，图2.1数据链在新单提交后为自动发单与工作台起到的衔接作用功不可没。自动发单即在客人提交订单后，以最快的响应速度向商户发送订单明细信息进行核实货位、确认订单等流程。工作台则协助员工介入流程及时获取订单处理人工事件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6992574257425742&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1eq3axNnoFTPLWbhRyhKWFibTpVOw3BiceYiafhWN1VxRt8qoynXZRQXOJP0lNx335Z76GW1KJ1IYSeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;808&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2.2 基于存储系统的发单与工作台关系（缩略细节）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;2.3  查询与数据分析&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于订单数据为核心的主要分为在线查询和数据分析两条业务线，以对详情查询为例，访问QPS终年保持在高位，每逢假期高峰则容易造成查询瓶颈，根因复盘后在本次架构升级中我们做了调整来优化相关场景的高可用性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如此以上，我们将订单主库的访问保护在订单缓存、实时消息、Hive数仓三架马车之后，与业务尽最大可能的解耦。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;三、系统升级实践&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在对携程核心存储系统进行更新换代的过程中，贯穿全程需要做到的是热迁移，并达成所有操作对数据链路上的各应用透明无损的目标。我们的设计通盘分析了集团数据链路的特性，由订单缓存系统提供数据库镜像降低应用与数据库的直连耦合，继而再通过中间件对应用透明掉数据源于SQLServer / MySQL的物理关系，提供底层热迁移的操作空间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;结合无损迁移的工艺设计，注重对每一笔数据库流量的可见及可控，支持全库、Shard级、表级、CRUD操作级的流量分配策略，提供了底层数据迁移足够的实施手段。数仓衔接设计则侧重于解决数据平台百亿级离线数据与双库在线期间的同步问题，以及解决全量接入MySQL期间产生的数据问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下将分三个部分分享我们在这一过程中学到的经验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3.1  分布式订单缓存&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;随着业务发展，用户数和访问量越来越大，订单系统应用和服务器的压力也与日俱增。在没有引入订单缓存之前，每个应用独立连接数据库，造成查询出来的数据无法在应用间共享，并且DB每秒查询量和连接数都有上限，而酒店核心交易链路基于DB存储，存在单点故障风险。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过埋点数据分析，订单系统是典型的读多写少，为了共享热点查询数据以及降低DB负载，一个有效的办法就是引入缓存，如图3.1，用户的请求过来时，优先查询缓存，如果存在缓存数据，则直接返回结果；缓存没有命中，则去查询DB，根据配置策略校验DB结果数据，校验通过则将DB数据写入缓存留作后续查询使用，否则不写入缓存，最后返回DB查询结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8543307086614174&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1eq3axNnoFTPLWbhRyhKWFibtyjHbTt862QGzs2nWVOsxn9CG24Byq8icJHRYgWK53yGsokstibAy91w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1016&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3.1 订单缓存基本设计&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于引入新的缓存组件后的硬件开销，可通过收敛原来各应用分散的硬件资源来降低总成本，但还会因为中心化管理带来可用性挑战以及数据一致性等问题，故需要充分对现有系统进行容量评估、流量估算和缓存表价值分析&lt;/span&gt;&lt;span&gt;。只缓存访问量&lt;/span&gt;&lt;span&gt;高的热点数据表，通过恰当的缓存结构设计、数据压缩和缓存淘汰策略，最大程度提高缓存命中率，在缓存容量、硬件成本和可用性之间做好权衡。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;传统的缓存设计，是一条数据库表记录对应一条缓存数据。而在订单系统中，一个订单查询多表的场景很常见，如果采用传统设计，在一次用户查询中，Redis的访问次数是随着表数量增加的，这种设计网络IO较大并且耗时较长。在盘点表维度流量数据时，我们发现有些表经常一起查询，不到30%的表其查询流量超过90%，在业务上完全可以划分为同一个抽象领域模型，然后基于hash结构进行存储，如图3.2，以订单号作为key，领域名称作为field，领域数据作为value。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样无论是单表还是多表查询，每个订单都只需要访问一次Redis，即减少了key，又减少了多表查询次数，提升了性能。同时value基于protostuff进行压缩，还减少了Redis的存储空间，以及随之而来的网络流量开销。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7232227488151659&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1eq3axNnoFTPLWbhRyhKWFib2iaAhwk4kiaYXwf0scTGjOqGuPAPiaSyrvt8UdY92NSqXStxbS8Wo4Tlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1055&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3.2 基于domain的存储结构简述&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3.2  无损迁移工艺&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何做到无损热迁移是整个项目最具挑战性的地方。在工艺设计之前我们的前置工作首先完成了中间件的开发，通过中间件将数据库与业务层应用一分为二。其次抽&lt;/span&gt;&lt;span&gt;象Dao层实现领域化，&lt;/span&gt;&lt;span&gt;并由数据领域层向应用提供数据服务，领域之下适配SQLServer和MySQL两种数据库并统一封装&lt;/span&gt;&lt;span&gt;。以此为基础才能委以&lt;/span&gt;&lt;span&gt;下述工艺设计实施无损热迁移。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;SQLServer和MySQL双库在线，实施双写，主写SQLServer，同步副写MySQL，如果SQLServer操作失败则整体失败，回滚双写事务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;SQLServer和MySQL之间增加一路同步Job，实时查询SQLServer最近时间窗口变更的数据进行一致性校验MySQL中的条目，差异点追齐，可以确保双写期间不可预期的两边不一致，特别是&lt;/span&gt;&lt;span&gt;还残有直连写&lt;/span&gt;&lt;span&gt;SQLServer应用的阶段特别有用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;中间件设计有配置系统，支持任一主要查询维度可按配置精准的将数据源定向到SQLServer或MySQL，并可控制是否读取后加载到订单缓存。初期设定只加载SQLServer数据源，避免因双库间的数据不一致而造成缓存数据跳跃&lt;/span&gt;&lt;span&gt;。并在初期可设&lt;/span&gt;&lt;span&gt;置灰度，将小批量非核心表直连MySQL验证可靠性。后期数据一致性达成预期后，订单缓存也可自由按指定数据库加载缓存。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;解决了查询场景下的数据一致性问题后，流量策略支持图3.2中任一可调控维度进行数据库单写。实际项目中以表维度实施单写为主，当指定表被配置单写MySQL后，所有涉及该表的CRUD行为全部定向MySQL，包括缓存加载源。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最后通过中间件统一收口对外发送的订单消息，所有消息基于中间件的CUD操作发送与物理数据库无关，这样实现消息的数据源透明，且可联动以上所有工艺操作，数据链保持一致。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5613660618996799&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1eq3axNnoFTPLWbhRyhKWFibN5k3PiayFKDQ2ibKLzT88bBJAe97yXZWqKYK3T3QP8Aubq5exyO5Aa7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;937&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3.2  操作工艺简介&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3.3  数仓衔接&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了方便理解生产数据到数据仓库ODS层数据的迁移，做到对下游透明，这里简单介绍一下常规数据仓库的分层体系。通常数据仓库主要分为五层：ODS(原始数据层)、DIM(维度)、EDW(企业数仓)、CDM(通用模型层)、ADM(应用模型层)，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8161350844277674&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1eq3axNnoFTPLWbhRyhKWFibYrPDEzd5PibMHQ9ELFNKSxJt9rTVtQMPFIeYhSso6s5Sticd3hrryVxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;533&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3.3.1  数据仓库分层结构&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从图3.3.1上可以看出，数据仓库各层都依赖ODS层的数据，为了不影响数据平台所有应用，我们只需要将原来订单库ODS层数据源从SQLServer迁移到MySQL库即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从图上很直观的看出，迁移只需换个数据源不是很麻烦，但是为了保证数据质量，我们做了很多的前置工作，比如：DBA预先将生产数据同步到生产MySQL库、MySQL数据实时同步、生产两侧数据一致性校验、MySQL侧数据同步到ODS层、ODS层数据一致性校验及原有ODS层同步Job数据源切换等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中，生产两侧数据一致性校验和数据仓库ODS层数据一致性校验最为复杂，耗时也最长，要确保每张表、每个字段都要一致时才能切换数据源。但是，从实际操作过程中，却做不到完全一致。根据实际情况，适当处理时间类型、浮点值精度及小数位等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面介绍一下整体流程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，对于线上数据一致校验，我们开发了在线同步Job，将SQLServer的数据和MySQL数据进行比较，发现不一致时，就将MySQL的数据以SQLServer数据为基准更新掉，确保两边数据的一致性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次，对于离线数据一致性校验，我们和数据仓库同事合作把MySQL侧数据同步到ODS层(以库名区分是SQLServer还是MySQL的表)，并且将定时跑的任务和SQLServer侧任务在时间上尽量一致。两侧数据都准备好后，我们开发了离线数据校验脚本生成器，根据数据仓库元数据，为每张表生成一个同步Job，将其部署到调度平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同步任务会依赖两侧ODS层同步数据，T+1数据同步完成后，执行一致性校验，将不一致的订单号记录到不一致明细表中，并统计不一致的数据量，将结果保存到统计表中。然后在自助报表平台制作一个报表，将每天统计的不一致的表及不一致量发送到邮箱，我们每天对不一致的表进行排查找出问题，调整比较策略，更新比较Job。大致流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.12753858651502845&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1eq3axNnoFTPLWbhRyhKWFibnW2BUwzV3I0ZCBS5ibc0SwP2JT8sDqHVmYdaAwbzNJZBia0xX9M6terw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1231&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3.3.2  一致性校验整体流程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，随着线上和离线数据逐步趋于一致后，我们将原先SQLServer同步到ODS层Job的数据源切换到MySQL。这里可能有同学会有疑问：为什么不直接使用MySQL侧ODS层的表呢？&lt;/span&gt;&lt;span&gt;原因是，经过统计，依赖原先ODS层表的Job有上千个之多，如果让依赖Job切换到MySQL侧ODS表，修改工作量非常大，所以我们直接将原来的ODS层同步数据源直接切换成MySQL。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;实际操作中，切数据源并不能一次全部切完，我们分三批进行，先找十几个不那么重要的表作为第一批，切完后运行两周，并收集下游数据问题的反馈。&lt;/span&gt;&lt;span&gt;第一批表顺利切完两周后，我们没收到下游报数据问题，说明数据质量没问题。&lt;/span&gt;&lt;span&gt;然后再将剩余的几百张表按重要程度分两批继续切，直到切完。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;至此，我们完成了订单库从SQLServer迁移到MySQL在数据仓库层的迁移工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;四、核心问题精编&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际上再周密的分析与设计，总是难免遇到执行过程中的各种挑战。我们总结了一些经典问题，虽然通过技术手段最终解决了这些大大小小问题并达成了目标，但是相信各位看官必定还有更好的解决方案，我们乐见共同学习与进步。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;4.1  SQLServer &amp;amp; MySQL 流量迁移如何细粒度监控&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;订单系统涉及到的应用和表数量众多，一个应用对应1到n张表，一张表又对应1到n个应用，是典型的多对多关系。如图4.1，对于上层应用来说，从一个SQLServer数据库，切换到另一个MySQL数据库，其基本流程参照操作工艺章节至少分为以下几步：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1eq3axNnoFTPLWbhRyhKWFibL4nWotqNn4Iy0CNPyvLFlePJm5O7NJkygLlyKAK1kXOKNgc6TvGDIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4.1 应用和数据库以及表的关系图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在生产环境更换数据库系统，就像在高速公路上不停车换轮胎，需要维持原有的车速不变，且对用户无感，否则后果不敢设想。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在切换工艺中双写、单读和单写流程，环环相扣，步步相依，作为配套设计监控手段必须确认上一个操作达到预期效果才能进行下一个。如果跳过或者没有切换干净就贸然进行下一步，比如还没有双写完全一致，就开始读MySQL数据，可能造成查无此数据或者查到脏数据！那么就需要对每一个CRUD操作的读写进行监控，在迁移过程中做到360度无死角可视化流量细分控制，所见即所得。具体的做法如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;所有应用接入中间件，CRUD由中间件根据配置控制读写哪个DB的哪张表；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每一个读写操作的详细信息均写入ES，在Kibana和Grafana上可视化展示，并且通过DBTrace，可以知道每条SQL是在哪个DB上执行；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;按照应用级别逐步配置双写DB，通过同步Job实时比对、修复和记录两侧DB差异，再通过离线T+1校验双写中出现的最终不一致，如此往复直到双写一致；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;双写一致之后，就开始逐步将读SQLServer切换到读MySQL，通过ES监控和DBTrace确认完全没有SQLServer读，则表明单读MySQL完成，考虑到自增主键情况，我们采取按照表维度，按批次断写SQLServer，直至所有表都单写MySQL。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综上所述，基本方案为通过中间件为管道为所有接入的应用统一埋点，通过实时展示应用层的行为观察流量分布，并结合公司数据库侧Trace的可视化工具核实应用的流量切换行为与数据库实际QPS及负载浮动保持一致来监督迁移任务。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;4.2  如何解决双写期间DB一致性问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;酒店的订单库有着二十年左右历史，经年累积，跨部门和酒店内部多个团队直接或间接依赖订单库SQLServer，要想切换到MySQL，就得先解决双写DB一致性问题，不一致主要体现在以下两点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于双写数据一致性的保证，我们基于同步Job将SQLServer数据为准线，根据最后更新时间，拉取两侧DB数据进行比对，如果不一致则修复MySQL的数据并将不一致信息写入ES，供后续排查根因。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但也因为引入了额外的Job操作MySQL数据，带来了新的问题，那就是多表双写时，因为耗时翻倍，Job发现SQLServer有数据而MySQL没有，就立即修复了MySQL数据，造成双写失败。所以双写部分失败又加上了Failover机制，通过抛送消息，触发新一轮的比对和修复工作，直到两侧DB数据完全一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同步Job和Failover消息机制虽然可以让数据最终一致，但毕竟有秒级的间隔，两侧数据是不一致的，并且对于众多应用的各种场景，难免会有遗漏时单写SQLServer。对于这些漏写MySQL的地方，通过DBTrace是无法找到的，因为无法确定一个CUD操作只写入SQLServer，而未写入MySQL。那么有没有办法事前就能找出漏写MySQL的场景呢，确实被我们找出来一点，那就是更换数据库连接串，接入中间件的应用使用新连接串，然后找出所有使用旧连接串操作SQLServer的SQL，就能准确定位出漏写MySQL的流量了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终，我们将双写DB不一致率从十万分之二逐步降低到了几乎为0，为什么是几乎呢，因为DB的一些特性差异问题，会天然的导致数据无法完全一致，这个在后续内容会有详细的论述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;4.3  引入订单缓存后导致的数据不同步问题处理&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;引入缓存之后，就涉及到对缓存进行写入或者更新，业界常见的做法分为以下几种：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;先写DB再写缓存&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;先写缓存再写DB&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;先删缓存再写DB&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;先写DB再删缓存&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在具体实施上还会进行双删缓存或者延迟双删缓存，此处不再比较各种做法的优劣。我们采用的是先写DB再删缓存方案，对于数据敏感表，会进行延迟双删，后台的同步Job定时比对、修复和记录数据库数据与Redis数据的差异，虽然设计上已经能保证最终一致性，但是在前期还是出现过大量的数据不一致。主要体现在以下几个方面：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;应用有场景未接入中间件，对DB进行CUD操作之后，漏删除缓存；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;写DB后删除缓存延迟导致读取到缓存脏数据，比如不可靠网络、GC等造成删缓存延迟；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;写DB后删除缓存失败导致读取到缓存脏数据，比如Redis主从切换期间，只能读不可写；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而为了解决缓存一致性问题，如图4.3，我们在原有的缓存和DB基础上，增加了乐观锁和CUD施工标记，来限制并发情况下同时存在加载数据到缓存相互覆盖的行为，以及对当前被查数据正在进行CUD操作的感知。在此两种场景未结束期间可以做到Query流量直连DB，通过基于乐观锁的最后写入者获胜机制解决竞争问题。最终我们的缓存不一致率从百万分之二控制到了千万分之三。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.86484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1eq3axNnoFTPLWbhRyhKWFibPFI7gtia2I6B9CLelbVvbAo6DArPVHIys7wRB5sSib32GR49BF2F1ejw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4.3 缓存一致性解决&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注：图4.3当查询未命中缓存，或当前存在该数据的乐观锁或施工标记时，当次查询直连DB，直至相关事务完成后放开缓存数据自动加载功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;4.4  存量订单数据如何一次性校准&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;项目启动初期我们对MySQL进行了最近N年数据的一次性铺底，这就产生了在双写阶段无法校准的如下两个场景的数据：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对第一点，我们开发了MySQL数据专项清理Job，由于订单数据库是多Shard的，Job内部根据实际Shard数设置核心线程总量，每个线程分别负责对应Shard中的指定表进行清理，并行开多台服务器分发任务进行清理，通过速度控制既保证&lt;/span&gt;&lt;span&gt;了效率又&lt;/span&gt;&lt;span&gt;不影响生产上数据库的负载。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对第二点，在所有应用接中间件和所&lt;/span&gt;&lt;span&gt;有表实现双写后，通过调&lt;/span&gt;&lt;span&gt;整线上同步Job扫描的开始时间戳，对存量订单数据进行修复。修复时特别注意的是，扫描数据要按时间段分片处理，防止加载数据太多导致订单库服务器CPU太高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;4.5  一些数据库特性差异问题&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在如此庞大的系统下进行数据库热迁移，我们就必须了解不同数据库之间的差异与不同，做到知己知彼，对症下药。MySQL与SQLServer虽同为时下流行的关系型数据库，均支持标准化SQL查询，但在细枝末节上还是有些许差异。下面我们通过迁移中所面临的问题来具体分析一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;自增键问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，为保证数据自增序号一致，不能让两个数据库各自去进行自增，否则一旦不一致就要面临修数据甚至更大风险。因此，在数据双写时，我们将SQLServer写入后生成的自增id，回写入MySQL自增列，在数据单写MySQL时直接使用MySQL生成自增id值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;日期精度问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，双写后为了保证数据一致性，要对两侧数据进行一致性校验，类型为Date、DateTime、Timestamp的字段，由于保存精度不一致，在对比时就需要做特殊处理，截取到秒进行比较。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;XML字段问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，SQLServer中支持XML数据类型，而MySQL 5.7不支持XML类型。在使用varchar(4000)代替后，遇到MySQL数据写入失败，但同步Job将SQLServer数据回写MySQL时又能正常写入的案例。经过分析，程序在写入时会将未压缩的XML字符串写入，SQLServer XML类型会自动压缩并存储，但MySQL并不会，导致长度超过4000的写入操作失败，SQLServer压缩后长度小于4000，又能够正常回写MySQL。为此我们提出应对措施，写入前压缩并校验长度，非重要字段截取后再存储，重要字段优化存储结构或更换字段类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面列举一些迁移过程中常见的注意点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;SQLServer&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;对应MySQL&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;使用IDENTITY自增&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;使用AUTO_INCREMENT自增&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;MONEY、SMALL MONEY类型&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;DECIMAL(19,4)、DECIMAL(10,4)类型&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;UNIQUEIDENTIFIER类型&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;BINARY(16)类型&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;串联运算符+或||&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;CONCAT(&#x27;string1&#x27;, &#x27;string2&#x27;)函数&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;日期函数GETDATE()&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;NOW()、CURRENT_TIMESTAMP()&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;日期函数DATEADD()&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;ADDDATE()&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;Top子句&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;使用Limit&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;VARCHAR(n)可存储n/2个汉字&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;VARCHAR(n)可存储n个汉字&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;五、预警实践&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们的预警实践并不局限于项目推进期间的监控诉求，如何在百亿级数据中周期扫描数据写入的异常，完成项目期间双写数据一致率的复核，如何实时监控与预警订单库每个分片上订单写入量的正常趋势，如何定期验收/核验整套系统的高可用性将在以下篇幅中描述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;5.1  百亿级数据差异校验预警&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;   &lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;要满足订单数据SQLServer迁移到MySQL库，数据质量是迁移的必要条件，数据一致性达不到要求就无法透明迁移，所以设计合理的校验方案，关乎迁移的进度。针对数据校验，我们分为线上和线下两种：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;线上数据校验和预警&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：迁移期间我们通过同步Job，在计算出不一致数据后，将不一致的表及字段写入ElasticSearch，再用Kibana制作出不一致数据量及不一致表所占比例的监控看板，通过监控看板，我们就可以实时监控哪些表数据不一致量比较高，再根据表名称通过DBA工具排查出哪些应用对表进行了CUD操作，进一步定位漏接中间件的应用和代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在实际操作中，我们确实找出了大量未接中间的应用并对其改造，随着接入中间件的应用越来越多，数据一致性逐渐提高，从监控看板上看到不一致的量也慢慢降低。但是一致性始终没有降低到零，原因是应用和同步Job并发导致的，这个也是最令人头疼的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;或许有同学会疑问，既然双写了为什么不停止掉同步Job呢？原因是双写以SQLServer为主写，以受中间件覆盖的CUD范围为基准，除了不能保证写入MySQL的数据百分百成功外也不能保证两库的数据量相等，所以需要一致性Job兜底。由于并发的存在，虽然做不到数据百分百一致，但是可以进一步降低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们的做法是，一致性Job比较时设置一个5秒的稳定线（即距离当前时间5秒内的数据视为不稳定数据），订单数据时间戳在稳定线内的不进行比较，稳定线外的比较时，会再一次计算订单数据是否在稳定线内，如果确认全部数据在稳定线外，就进行比较操作，否则放弃本次比较，由下一次调度执行一致性校验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;离线数据校验和预警&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：订单库迁移涉及到几百张表，离线数据比较多，一年的订单相关数据就有上百亿了，对于离线数据校验比较有挑战。我们编写了数据一致性脚本生成器，为每张表生成一个比较脚本并部署到调度平台，比较脚本依赖上游SQLServer和MySQL两侧的同步Job，上游Job执行完毕后自动执行数据比较，将不一致数据的订单号写到明细表中，并根据明细表统计出不一致量，以日报的形式发出，每天对数据不一致比较高的表排查并解决。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常一是能修复对比脚本的瑕疵，二是发现离线数据问题，就这样反复摸排解决不一致问题。对于离线数据每张表每个字段的校验是非常复杂的，我们编写UDF函数进行比较，UDF函数功能也很简单，就是将每张表的非主键字段进行拼接生成一个新字段，两侧表进行全外连接，主键或者逻辑主键相等的记录，生成新字段也应该一样，只要不一样就视为不一致数据。这里要注意日期字段截取、数据精度及末尾为零的小数处理问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过三个多月的努力，我们排查出所有未接中间件的应用，并将其CUD操作全部接入中间件，开启双写后线上线下数据一致性逐步提高，达到了迁移数据的目标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;5.2 ALL Shard 实时订单总量监控  &lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个公司对于订单量的监控是不可或缺的，携程有一个统一预警平台Sitemon，它主要监控各类订单告警，包括酒店，机票，无线，高铁，度假。并能按照online/offline，国内/国际，或者支付方式单独搜索和展现，并对各类订单做了告警。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;订单数据从SQLServer迁移到MySQL期间，我们梳理出来依赖订单库的预警策略近两百个，负责监控的相关同事对SQL Server数据源的预警策略原样复制一份连接MySQL数据源。以MySQL为数据源监控告警都添加完成后，开启报警策略，一旦订单量异常报警，NOC会收到两条通知，一条来源于SQLServer数据告警，一条来源于MySQL告警，如果两边一致，说明灰度验证通过。否则，不通过，需排查MySQL 监控问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过一段时间的灰度验证，两边报警数据一致，随着SQLServer数据表下线（即单写MySQL数据），以SQLServer为数据源的预警策略也跟着及时下线。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.3  “流浪地球”实操&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了做好系统安全保障工作，提高应对突发事件的能力，必要的演练压测等是少不了的。为此，我们制定了完备的应急预案并定期组织开展应急演练——流浪地球。演练项目包括核心/非核心应用熔断、DB熔断、Redis熔断、核心防火墙、交换机应急切换等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以缓存为例，为了保证缓存服务的高可用，我们在演练时会下线部分节点或机器甚至切断整个Redis服务，模拟缓存雪崩、缓存击穿等场景。按照计划，在熔断前我们会先切断应用的Redis访问，一步步降低Redis负载，然后熔断Redis，以此检验在无Redis的情况下各应用系统是否能够正常运转。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但在首次演练中，熔断Redis后应用报错量就急剧上升，果断停止演练回退并查找原因。经过分析，部分应用Redis操作未统一收口，不受中间件统一控制，Redis熔断后应用随即出现异常。针对这一情况，我们分析后一方面将报错应用的订单缓存访问收口接入中间件，另一方面强化了中间件与Redis的弱依赖关系，支持一键断开Redis操作，并完善了各项指标监控。最终在第二次演练中顺利完成Redis熔断，各业务系统在全流量打入MySQL的状态下的正常运行。在最近一次的流浪地球演练中，机房网络阻断、非核心应用阻断等一轮轮故障注入后，我们的系统更是取得了很好的预期效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;就这样，在一次次的演练中，我们发现问题，总结经验，优化系统，完善应急预案，一步步提升系统应对突发故障的能力，保证业务的连续性以及数据的完整性。做好底层数据支撑，为整个酒店订单系统保驾护航。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;六、未来规划&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;6.1  订单缓存手工调控台&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然我们有完善的监控看板与预警系统，但对于像熔断演练、自动化故障演练、硬件故障和维护以及不可提前预知的问题，若刚好核心开发人员未能及时在现场响应操作，系统尚不能完全自主降级可能导致部分性能有所下降，比如响应耗时增加等。在将来计划增加手工调控看板，授权后可以让NOC或者TS进行针对性操作，比如Redis全部或者部分集群宕机，可以一键切割故障Redis分片，或者根据Redis已计划中的不可用时间段来提前设置切割时间，可以最大程度保证系统的可控性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;6.2  中间件自动降级&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;既然可以手工进行调控，那么我们也考虑后续可以通过一些核心指标的监控，比如Redis主从切换期间，正常情况是秒级，但是我们也出现过部分Redis 10秒以上不可写的情况，此时可以监控缓存与数据库不一致的脏数据量，也可以在Redis发生故障时通过监控响应耗时异常的阀值来应用一些策略，让中间件自动降级切割掉这些故障主机保证服务的基本稳定，然后在探测到集群指标稳定后再逐步尝试恢复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;6.3  中间件接&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;入Service Mesh&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当前订单团队内部是以JAR的方式使用中间件，由中间件来屏蔽数据库底层差异和操作Redis以实现更复杂的功能，天然具备接&lt;/span&gt;&lt;span&gt;入Service Mesh能力&lt;/span&gt;&lt;span&gt;，接入后底层升级更加快速和无感、调用更加轻量化、更好与框架进行网格化集成以及上云更加方便，能够更好的支撑携程的国际化战略目标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;【推荐阅读】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1e6A9vSrEj2brdswgl1bNg2ahAemw7dmvib0LzoF8VdGoLzGQPYypibSfMyTwibGibnvqZic7XJS0icpIHA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; “携程技术”公众号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;  分享，交流，成长&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b235eff711a5c82a16c9999d6d9a3f21</guid>
<title>继Python之后，Go也顺利在浏览器上运行</title>
<link>https://toutiao.io/k/oqes14y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;文 | 局长&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;出品 | OSC开源社区（ID：oschina2013)&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;Anaconda 开发商最近发布了 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzM0MjcyMQ==&amp;amp;mid=2650144570&amp;amp;idx=1&amp;amp;sn=e0bce6b9f78f6b24418aba0b5cdd4c8f&amp;amp;chksm=beda245489adad42c2f53106e9c949f033ccddfdeeccabf9db9534a6774cbe338175c15d4505&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;PyScript&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;PyScript&lt;/a&gt;，这是一个可以让开发者在 HTML 中混写 Python 代码的框架，有人将其称为 “Python 版 JSP”。事实上，PyScript 底层采用了 WebAssembly， 因为它基于 Pyodide 构建，Pyodide 由编译成 WebAssembly 的 CPython 3.8 解释器组成，允许在网页浏览器中运行 Python。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.640074211502783&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKic7joUkwHYuRwcgZCsxZpsGwib8MwCzBxtV5JSriaiaRDu0uyGoEUJLweBTtJF29CRcNb7ISZmFqUfww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1078&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;无独有偶，开发者采用相同的思路让 Go 也顺利在浏览器上运行。&lt;span&gt;https://goscript.dev&lt;/span&gt; 网站支持在浏览器端直接运行 Go 代码，这是一个 Go playground，底层采用 Goscript，通过 WASM 实现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKic7joUkwHYuRwcgZCsxZpsGiaGianNlew710qm0JC2y4UOLvvrVumE24RbcorXwQjMuqtNibeBHYkNOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;875&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Goscript 是 Go 语言规范的非官方实现，&lt;span&gt;用于 Rust 项目的内嵌或封装&lt;/span&gt;，提供了更简单的方式封装和调用底层的 Rust 代码。&lt;span&gt;就像 Lua 之于 Redis/WoW，或者 Python 之于 NumPy。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Goscript 包含六个项目：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;parser&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;把源代码变成 AST，移植自 Go 官方代码。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;type checker&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;基于 AST 做类型推倒和类型检查，也移植自 Go 官方代码。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;codegen&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;基于 AST 和类型信息生成字节码。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;vm&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;运行字节码。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;std&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;官方库，移植自 Go 官方库。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;engine&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;包含官方库的 native 部分，再加上简单封装。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;Goscript 实现了 Go 的几乎所有特性（pre 1.18，因此不包括泛型），并移植了部分官方库，已通过的相关测试用例查看 https://github.com/oxfeeefeee/goscript/tree/master/engine/tests。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Goscript 项目代码：https://github.com/oxfeeefeee/goscript&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86032&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span data-brushtype=&quot;text&quot;&gt;推荐阅读&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9574468085106383&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZP3JEv2BgJ7cx4oxeYNNqh2oytepen4zyw43jGnqXCiaAYWgK59RF4HTukPFrHF7FJarvFzETH87kr3It44zLmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;94&quot;/&gt;&lt;span&gt;觉得不错，请点个&lt;/span&gt;&lt;span&gt;在看&lt;/span&gt;&lt;span&gt;呀&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>926ccff739bdfa49382ccf10673bc743</guid>
<title>了解虚拟列表背后原理，轻松实现虚拟列表</title>
<link>https://toutiao.io/k/swzlkyj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;比如&lt;code&gt;umy-ui&lt;/code&gt;(ux-table)虚拟列表table组件，&lt;code&gt;vue-virtual-scroller&lt;/code&gt;以及&lt;code&gt;react-virtualized &lt;/code&gt;这些优秀的插件快速满足业务需要。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了理解插件背后的原理机制，我们实现一个自己简易版的虚拟列表，希望在实际业务项目中能带来一些思考和帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正文开始...&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.0970873786407767&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/njBmfXMicXibpcniaFhJ3vTjribkSkMu9jFxmIa8sYfuq3whdj7pljwic7FibucLWTNq8ibmoiay1pjKGMuLl4soNj3kicQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;103&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;虚拟列表是什么&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在大数据渲染中，选择一段可视区域显示对应数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先初步看一个图&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5363881401617251&quot; data-type=&quot;png&quot; data-w=&quot;2226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0jXCeiaibicNx4aU4a0Hm8CA4pUueuQo51exUIHhAUq5SFk19F29OQKbmCIp5LNXXaAQAo4mIAO6IOgJZfia9ev5LQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这张展示图中，我们可以看到我们展示的始终是&lt;code&gt;红色线虚线&lt;/code&gt;展示的部分，每一个元素固定高度，被一个&lt;code&gt;很大高度的元素&lt;/code&gt;包裹着，并且&lt;code&gt;最外层&lt;/code&gt;有一个固定的高度容器，并且设置可以滚动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新建一个&lt;code&gt;index.html&lt;/code&gt;对应结构如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;vitual-list-wrap&quot;&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;listWrap&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;content&quot;&lt;/span&gt; &lt;span&gt;:style&lt;/span&gt;=&lt;span&gt;&quot;contentStyle&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;item&quot;&lt;/span&gt; &lt;span&gt;v-for&lt;/span&gt;=&lt;span&gt;&quot;(item, index) in list&quot;&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;:key&lt;/span&gt;=&lt;span&gt;&quot;index&quot;&lt;/span&gt; &lt;span&gt;:style&lt;/span&gt;=&lt;span&gt;&quot;item.style&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        {{item.content}}&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应的&lt;code&gt;css&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;*{&lt;br/&gt;  &lt;span&gt;padding&lt;/span&gt;:&lt;span&gt;0px&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;margin&lt;/span&gt;: &lt;span&gt;0px&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;#app&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;width&lt;/span&gt;:&lt;span&gt;300px&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;border&lt;/span&gt;: &lt;span&gt;1px&lt;/span&gt; solid &lt;span&gt;#e5e5e5&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/*外部容器给一个固定的可视高度，并且设置可以滚动*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;.vitual-list-wrap&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;position&lt;/span&gt;: relative;&lt;br/&gt;  &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;800px&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;overflow-y&lt;/span&gt;: auto;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/*真实容器的区域*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;.content&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;position&lt;/span&gt;: relative;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/*固定高度的每个元素*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;.item&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;60px&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;padding&lt;/span&gt;: &lt;span&gt;10px&lt;/span&gt; &lt;span&gt;5px&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;border-bottom&lt;/span&gt;: &lt;span&gt;1px&lt;/span&gt; solid &lt;span&gt;#111&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;position&lt;/span&gt;: absolute;&lt;br/&gt;  &lt;span&gt;left&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;right&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;line-height&lt;/span&gt;: &lt;span&gt;60px&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从对应页面结构与&lt;code&gt;css&lt;/code&gt;中我们的思路大致是这样&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;确定外层固定的高度，并且设置纵向滚动条&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;真实容器设置相对定位，并且根据显示总数动态设置一个装载容器的高度&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个元素设置绝对定位，且是固定高度&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了对应设置的结构，因为我们每个元素是绝对定位的，所以我们现在的思路就是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、确定可视区域&lt;code&gt;item&lt;/code&gt;显示的条数&lt;code&gt;limit&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、向上滑动的当前位置&lt;code&gt;起始位&lt;/code&gt;与&lt;code&gt;最后位置&lt;/code&gt;，确定显示元素范围&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、确定每个元素的&lt;code&gt;top&lt;/code&gt;，当向上滑动时，确定当前的位置与最后元素的位置索引，根据当前位置与最后元素位置，渲染&lt;code&gt;可视区域&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体逻辑代码如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;app&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;h3&lt;/span&gt;&amp;gt;&lt;/span&gt;虚拟列表&lt;span&gt;&amp;lt;/&lt;span&gt;h3&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;vitual-list-wrap&quot;&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;list-wrap&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;content&quot;&lt;/span&gt; &lt;span&gt;:style&lt;/span&gt;=&lt;span&gt;&quot;contentStyle&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;item&quot;&lt;/span&gt; &lt;span&gt;v-for&lt;/span&gt;=&lt;span&gt;&quot;(item, index) in list&quot;&lt;/span&gt; &lt;br/&gt;                  &lt;span&gt;:key&lt;/span&gt;=&lt;span&gt;&quot;index&quot;&lt;/span&gt; &lt;span&gt;:style&lt;/span&gt;=&lt;span&gt;&quot;item.style&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                    {{item.content}}&lt;br/&gt;                &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;!--引入vue3组件库--&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;&quot;https://cdn.bootcdn.net/ajax/libs/vue/3.2.33/vue.global.min.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;&quot;./index.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们具体看下&lt;code&gt;index.js&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;// index.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { createApp, reactive, toRefs, computed, onMounted, ref } = Vue;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; vm = createApp({&lt;br/&gt;  setup() {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; listWrap = ref(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; viewData = reactive({&lt;br/&gt;        &lt;span&gt;list&lt;/span&gt;: [],&lt;br/&gt;        &lt;span&gt;total&lt;/span&gt;: &lt;span&gt;1000&lt;/span&gt;, &lt;span&gt;// 数据总条数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;600&lt;/span&gt;, &lt;span&gt;// 可视区域的高度&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;rowHeight&lt;/span&gt;: &lt;span&gt;60&lt;/span&gt;, &lt;span&gt;// 每条item的高度&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;startIndex&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;// 初始位置&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;endIndex&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;// 结束位置&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;timer&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;bufferSize&lt;/span&gt;: &lt;span&gt;5&lt;/span&gt; &lt;span&gt;// 做一个缓冲&lt;/span&gt;&lt;br/&gt;        &lt;br/&gt;      });&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; contentStyle = computed(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;`&lt;span&gt;${viewData.total * viewData.rowHeight}&lt;/span&gt;px`&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;position&lt;/span&gt;: &lt;span&gt;&#x27;relative&#x27;&lt;/span&gt;,&lt;br/&gt;        }&lt;br/&gt;      });&lt;br/&gt;      &lt;span&gt;// todo 设置数据&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; renderData = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        viewData.list = [];&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; {rowHeight, height, startIndex, total, bufferSize} = viewData;&lt;br/&gt;        &lt;span&gt;// 当前可视区域的row条数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; limit = &lt;span&gt;Math&lt;/span&gt;.ceil(height/rowHeight);&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(limit, &lt;span&gt;&#x27;=limit&#x27;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 可视区域的最后一个位置&lt;/span&gt;&lt;br/&gt;        viewData.endIndex = &lt;span&gt;Math&lt;/span&gt;.min(startIndex + limit + bufferSize, total &lt;span&gt;-1&lt;/span&gt;);&lt;br/&gt;          &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i=startIndex; i&amp;lt;viewData.endIndex; i++) {&lt;br/&gt;            viewData.list.push({&lt;br/&gt;            &lt;span&gt;content&lt;/span&gt;: i,&lt;br/&gt;            &lt;span&gt;style&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;top&lt;/span&gt;: &lt;span&gt;`&lt;span&gt;${i * rowHeight}&lt;/span&gt;px`&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;          })&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;// todo 监听滚动，设置statIndex与endIndex&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; handleScroll = &lt;span&gt;(&lt;span&gt;callback&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// console.log(listWrap.value)&lt;/span&gt;&lt;br/&gt;        listWrap.value &amp;amp;&amp;amp; listWrap.value.addEventListener(&lt;span&gt;&#x27;scroll&#x27;&lt;/span&gt;, (e) =&amp;gt; {&lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.timer) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;          }&lt;br/&gt;          &lt;span&gt;const&lt;/span&gt; { rowHeight, startIndex, bufferSize } = viewData;&lt;br/&gt;          &lt;span&gt;const&lt;/span&gt; { scrollTop } = e.target;&lt;br/&gt;          &lt;span&gt;// 计算当前滚动的位置，获取当前开始的起始位置&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;const&lt;/span&gt; currentIndex = &lt;span&gt;Math&lt;/span&gt;.floor(scrollTop / rowHeight); &lt;br/&gt;          viewData.timer = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;          &lt;span&gt;// console.log(startIndex, currentIndex);&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;// 做一个简单的节流处理&lt;/span&gt;&lt;br/&gt;          setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            viewData.timer = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;               &lt;span&gt;// 如果滑动的位置不是当前位置&lt;/span&gt;&lt;br/&gt;               &lt;span&gt;if&lt;/span&gt; (currentIndex !== startIndex) {&lt;br/&gt;                viewData.startIndex = &lt;span&gt;Math&lt;/span&gt;.max(currentIndex - bufferSize, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;                callback();&lt;br/&gt;               }&lt;br/&gt;            }, &lt;span&gt;500&lt;/span&gt;)&lt;br/&gt;        })&lt;br/&gt;      }&lt;br/&gt;      onMounted(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        renderData();&lt;br/&gt;        handleScroll(renderData);&lt;br/&gt;      })&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;        ...toRefs(viewData),&lt;br/&gt;        contentStyle,&lt;br/&gt;        renderData,&lt;br/&gt;        listWrap&lt;br/&gt;      }&lt;br/&gt;  },&lt;br/&gt;})&lt;br/&gt;vm.mount(&lt;span&gt;&#x27;#app&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下页面，已经ok了，每次上滑都只会固定高度加载对应的数据&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45582047685834504&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0jXCeiaibicNx4aU4a0Hm8CA4pUueuQo51eDyJ78MatXdPHDicsMr451AdtUTu2Qz8zdB2xnhdaTSIubFod2BcS1eA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2852&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意我们在&lt;code&gt;css&lt;/code&gt;中有一段这样的代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#app&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;width&lt;/span&gt;:&lt;span&gt;300px&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;border&lt;/span&gt;: &lt;span&gt;1px&lt;/span&gt; solid &lt;span&gt;#e5e5e5&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;...&lt;br/&gt;&lt;span&gt;[data-v-app]&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt; &lt;span&gt;!important&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样处理主要是为了插值表达式在未渲染的时候，让用户看不到未渲染前的模版内容。如果不先隐藏，那么会打开页面的时候会有插值表达式，&lt;code&gt;vue&lt;/code&gt;中提供了一个&lt;code&gt;v-cloak&lt;/code&gt;,但是貌似这里不管用，在&lt;code&gt;vue2&lt;/code&gt;中是可以的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇是非常简易的虚拟列表实现，了解虚拟列表背后的实现思想，更多可以参考&lt;span&gt;vue-virtual-scroller&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;与&lt;span&gt;react-virtualized&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;源码的实现，具体应用示例可以查看之前写的一篇偏应用的文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzk0ODMxODIzNw==&amp;amp;mid=2247486014&amp;amp;idx=1&amp;amp;sn=4fb22eb3cc18b08d5d7ec8ffeed63587&amp;amp;chksm=c368334cf41fba5ab89d61af3ae16d7753c3ebb61aa6a7720fb6e78a29c080a7e8841da8db02&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;测试脚本把页面搞崩了 &lt;/a&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;了解虚拟列表到底是什么，在大数据渲染中，选择一段可视区域显示对应数据&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;实现虚拟列表的背后原理，最外层给定一个固定的高度，然后设置纵向&lt;code&gt;Y轴&lt;/code&gt;滚动，然后每个元素的父级设置相对定位，设置真实展示数据的高度，根据&lt;code&gt;item&lt;/code&gt;固定高度(&lt;code&gt;rowHeight&lt;/code&gt;)，根据可视区域和&lt;code&gt;rowHeight&lt;/code&gt;计算可显示的&lt;code&gt;limit&lt;/code&gt;数目。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当滚动条上滑时，计算出滚动的距离&lt;code&gt;scrollTop&lt;/code&gt;，通过&lt;code&gt;currentIndex = Math.floor(scrollTop/rowHeight)&lt;/code&gt;计算出当前起始索引&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;endIndex = Math.min(currentIndex+limit, total-1)&lt;/code&gt;计算出最后可显示的索引&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;最后根据&lt;code&gt;startIndex&lt;/code&gt;与结束位置&lt;code&gt;endIndex&lt;/code&gt;，根据&lt;code&gt;startIndex&lt;/code&gt;与&lt;code&gt;endIndex&lt;/code&gt;渲染可视区域&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;本文示例代码&lt;span&gt;code example&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;本文参考相关文章&lt;span&gt;如何实现一个高度自适应的虚拟列表&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;,这是&lt;code&gt;react&lt;/code&gt;版本的&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;vue-virtual-scroller: &lt;em&gt;https://github.com/Akryum/vue-virtual-scroller&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;react-virtualized: &lt;em&gt;https://github.com/bvaughn/react-virtualized&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;code example: &lt;em&gt;https://github.com/maicFir/lessonNote/tree/master/javascript/08-%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;如何实现一个高度自适应的虚拟列表: &lt;em&gt;https://juejin.cn/post/6948011958075392036&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>