<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d71d362553620e32edfb1168c47a934c</guid>
<title>数据调度组件：基于 Azkaban 协调时序任务执行</title>
<link>https://toutiao.io/k/a7u76ek</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1&gt;&lt;span&gt;一、Azkaban概述&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、任务时序&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在数据服务的业务场景中，很常见的业务流程就是日志文件经过大数据分析，再向业务输出结果数据；在该过程中会有很多任务需要执行，并且很难精准把握任务执行的结束时间，但是又希望整个任务链尽快结束释放资源。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5691609977324263&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBpL0RQrpchicHgBOt8XFmjEl6u9lS40picmjveysllOVg6sLic4ibicmwN4Gll3Y5IM7EMu9BOR9ibjdYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;882&quot;/&gt;&lt;/p&gt;&lt;p&gt;大致执行顺序如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务日志文件同步到HDFS文件系统；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;经过Hadoop执行分析计算过程；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;结果数据在导入数仓进行存储；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最终需要把数仓内数据同步到业务库；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这样的流程不必业务中任务调度，时间基本是可预估的，只要把握留足任务间隔时间即可，大数据的任务链路通常需要一个结束直接启动另一个，以此降低时间成本，初入数据服务公司时，就发生过因为同步任务执行结束但是最后的个别CSV数据文件未生成结束的案例，导致近百万的分析数据同步更新业务库失败。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、Azkaban简介&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Azkaban是由Linkedin公司推出的可以管理批量工作流任务的调度器，用于在一个工作流内以一个特定的顺序运行一组工作和流程。Azkaban使用job配置文件建立任务之间的依赖关系，并提供一个易于使用的web用户界面维护和跟踪你的工作流。&lt;/p&gt;&lt;p&gt;Azkaban特点和优势&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;提供功能清晰，简单易用的 Web UI 界面；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;作业配置简单，任务作业依赖关系清晰；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;提供可扩展的组件；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;基于Java语言开发，易于二次开发；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;相比较于Oozie配置工作流的过程是编写大量的XML配置，并且其代码复杂度比较高，不易于二次开发，Azkaban则显得轻量级，功能和用法相对简单和容易使用。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、服务安装&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、核心包&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Web服务&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;azkaban-web-server-2&lt;/span&gt;&lt;span&gt;.5&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.tar&lt;/span&gt;&lt;span&gt;.gz&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;执行服务&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;azkaban-executor-server-2&lt;/span&gt;&lt;span&gt;.5&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.tar&lt;/span&gt;&lt;span&gt;.gz&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;SQL脚本&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;azkaban-sql-script-2&lt;/span&gt;&lt;span&gt;.5&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.tar&lt;/span&gt;&lt;span&gt;.gz&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;2、安装路径&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;上传上面三个安装包，并解压操作。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 azkaban]&lt;span&gt;# pwd&lt;/span&gt;&lt;br/&gt;/opt/azkaban&lt;br/&gt;[root@hop01 azkaban]&lt;span&gt;# tar -zxvf azkaban-web-server-2.5.0.tar.gz&lt;/span&gt;&lt;br/&gt;[root@hop01 azkaban]&lt;span&gt;# tar -zxvf azkaban-executor-server-2.5.0.tar.gz&lt;/span&gt;&lt;br/&gt;[root@hop01 azkaban]&lt;span&gt;# tar -zxvf azkaban-sql-script-2.5.0.tar.gz&lt;/span&gt;&lt;br/&gt;[root@hop01 azkaban]&lt;span&gt;# mv azkaban-web-2.5.0/ server&lt;/span&gt;&lt;br/&gt;[root@hop01 azkaban]&lt;span&gt;# mv azkaban-executor-2.5.0/ executor&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;3、MySQL导入脚本&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 ~]&lt;span&gt;# mysql -uroot -p123456&lt;/span&gt;&lt;br/&gt;mysql&amp;gt; &lt;span&gt;create&lt;/span&gt; &lt;span&gt;database&lt;/span&gt; azkaban_test;&lt;br/&gt;mysql&amp;gt; &lt;span&gt;use&lt;/span&gt; azkaban_test;&lt;br/&gt;mysql&amp;gt; source /opt/azkaban/azkaban-2.5.0/&lt;span&gt;create&lt;/span&gt;-all-&lt;span&gt;sql&lt;/span&gt;&lt;span&gt;-2.5&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;.sql&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看表&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.4827586206896552&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBpL0RQrpchicHgBOt8XFmjElN31HQ5Y6vqX5iaEQwQ18dbmMP3yGGeL9dSFc0QEdHFVZibk87Xr7VEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;464&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;4、SSL配置&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 opt]&lt;span&gt;# keytool -keystore keystore -alias jetty -genkey -keyalg RSA&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;生成文件：&lt;code&gt;keystore&lt;/code&gt;&lt;/p&gt;&lt;p&gt;拷贝&lt;span&gt;到AzkabanWeb服务器目录下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 opt]&lt;span&gt;# mv keystore /opt/azkaban/server/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;5、Web服务配置&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;基础配置&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 conf]&lt;span&gt;# pwd&lt;/span&gt;&lt;br/&gt;/opt/azkaban/server/conf&lt;br/&gt;[root@hop01 conf]&lt;span&gt;# vim azkaban.properties&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;核心修改内容：MySQL和Jetty。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;default&lt;/span&gt;.timezone.id=Asia/Shanghai&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Azkaban MySQL server properties.&lt;/span&gt;&lt;br/&gt;database.type=mysql&lt;br/&gt;mysql.port=&lt;span&gt;3306&lt;/span&gt;&lt;br/&gt;mysql.host=localhost&lt;br/&gt;mysql.database=azkaban_test&lt;br/&gt;mysql.user=root&lt;br/&gt;mysql.password=&lt;span&gt;123456&lt;/span&gt;&lt;br/&gt;mysql.numconnections=&lt;span&gt;100&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Azkaban Jetty server properties.&lt;/span&gt;&lt;br/&gt;jetty.maxThreads=&lt;span&gt;25&lt;/span&gt;&lt;br/&gt;jetty.ssl.port=&lt;span&gt;8443&lt;/span&gt;&lt;br/&gt;jetty.port=&lt;span&gt;8081&lt;/span&gt;&lt;br/&gt;jetty.keystore=keystore&lt;br/&gt;jetty.password=&lt;span&gt;123456&lt;/span&gt;&lt;br/&gt;jetty.keypassword=&lt;span&gt;123456&lt;/span&gt;&lt;br/&gt;jetty.truststore=keystore&lt;br/&gt;jetty.trustpassword=&lt;span&gt;123456&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里配置符合本地配置参数即可。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;用户配置&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 conf]&lt;span&gt;# vim azkaban-users.xml&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;增加一个管理员用户：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;azkaban-users&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;user&lt;/span&gt; &lt;span&gt;username&lt;/span&gt;=&lt;span&gt;&quot;admin&quot;&lt;/span&gt; &lt;span&gt;password&lt;/span&gt;=&lt;span&gt;&quot;admin&quot;&lt;/span&gt; &lt;span&gt;roles&lt;/span&gt;=&lt;span&gt;&quot;admin,metrics&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;azkaban-users&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.23671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBpL0RQrpchicHgBOt8XFmjEzTkIovzo5WicQnKtd32kXs55VV4T9tL5IzFP31z6NnJfo3YqmO680NQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;6、Executor服务配置&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 conf]&lt;span&gt;# pwd&lt;/span&gt;&lt;br/&gt;/opt/azkaban/executor/conf&lt;br/&gt;[root@hop01 conf]&lt;span&gt;# vim azkaban.properties&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;核心修改内容：MySQL和时区。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;default&lt;/span&gt;.timezone.id=Asia/Shanghai&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Azkaban MySQL server properties.&lt;/span&gt;&lt;br/&gt;database.type=mysql&lt;br/&gt;mysql.port=&lt;span&gt;3306&lt;/span&gt;&lt;br/&gt;mysql.host=localhost&lt;br/&gt;mysql.database=azkaban_test&lt;br/&gt;mysql.user=root&lt;br/&gt;mysql.password=&lt;span&gt;123456&lt;/span&gt;&lt;br/&gt;mysql.numconnections=&lt;span&gt;100&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;7、启动服务器&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Web服务&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 bin]&lt;span&gt;# pwd&lt;/span&gt;&lt;br/&gt;/opt/azkaban/server/bin&lt;br/&gt;[root@hop01 bin]&lt;span&gt;# ll&lt;/span&gt;&lt;br/&gt;total &lt;span&gt;16&lt;/span&gt;&lt;br/&gt;-rwxr-xr-x &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;161&lt;/span&gt; Apr &lt;span&gt;21&lt;/span&gt;  &lt;span&gt;2014&lt;/span&gt; azkaban-web-shutdown.sh&lt;br/&gt;-rwxr-xr-x &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;1275&lt;/span&gt; Apr &lt;span&gt;21&lt;/span&gt;  &lt;span&gt;2014&lt;/span&gt; azkaban-web-start.sh&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里分别是启动和关闭的脚本。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 bin]&lt;span&gt;# /opt/azkaban/server/bin/azkaban-web-start.sh&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Executor服务&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 bin]&lt;span&gt;# /opt/azkaban/executor/bin/azkaban-executor-start.sh&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;启动日志&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;两个服务的关键尾行日志：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Azkaban &lt;span&gt;Server&lt;/span&gt; running &lt;span&gt;on&lt;/span&gt; ssl port &lt;span&gt;8443.&lt;/span&gt;&lt;br/&gt;Azkaban Executor &lt;span&gt;Server&lt;/span&gt; started &lt;span&gt;on&lt;/span&gt; port &lt;span&gt;12321&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;登录界面&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;注意这里是基于https协议：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;https:&lt;span&gt;//hop01:8443/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.43203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBpL0RQrpchicHgBOt8XFmjEnfTeEnLlEk5gGFDUib6bmTWorw734w9Nib4wCtEBMFG2prJEs2V5bwCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、操作案例&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、入门案例&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;创建command类型job&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 flow_01]&lt;span&gt;# pwd&lt;/span&gt;&lt;br/&gt;/opt/azkaban/testJob/flow_01&lt;br/&gt;[root@hop01 flow_01]&lt;span&gt;# vim simple.job&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt;=&lt;span&gt;command&lt;/span&gt;&lt;br/&gt;&lt;span&gt;command&lt;/span&gt;=&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&#x27;mySimpleJob&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;打成zip包&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;[root@hop01 flow_01]&lt;/span&gt;# &lt;span&gt;zip&lt;/span&gt; &lt;span&gt;-q&lt;/span&gt; &lt;span&gt;-r&lt;/span&gt; &lt;span&gt;simpleJob&lt;/span&gt;&lt;span&gt;.zip&lt;/span&gt; &lt;span&gt;simple&lt;/span&gt;&lt;span&gt;.job&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;创建项目&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBpL0RQrpchicHgBOt8XFmjEGmODPViauC7Yd2WLIjab8lP5acSYITPVJDKHHat9p7pyLQzHSCXJQicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;上传任务包&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBpL0RQrpchicHgBOt8XFmjEK2xavosyffsQWtc7SCmib1QqxAkYicKUWhTeVhHSGgqB4RHWdhjLEvRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;执行任务&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBpL0RQrpchicHgBOt8XFmjEfgicXOnibmPpSYm02GBsgNIict6VUzCW5cN7PmmWhOMbcc6cjEIjNN0icA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、任务顺序执行&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;创建任务A&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;[root@hop01 flow_02]&lt;/span&gt;&lt;span&gt;# vim simpleA.job&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt;=command&lt;br/&gt;&lt;span&gt;command&lt;/span&gt;=echo &lt;span&gt;&#x27;simplejobA&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;创建任务B&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;[root@hop01 flow_02]&lt;/span&gt;&lt;span&gt;# vim simpleB.job&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt;=command&lt;br/&gt;&lt;span&gt;dependencies&lt;/span&gt;=simpleA&lt;br/&gt;&lt;span&gt;command&lt;/span&gt;=echo &lt;span&gt;&#x27;simplejobB&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;打包任务&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;[root@hop01 flow_02]&lt;/span&gt;# &lt;span&gt;zip&lt;/span&gt; &lt;span&gt;-q&lt;/span&gt; &lt;span&gt;-r&lt;/span&gt; &lt;span&gt;simpleTwoJob&lt;/span&gt;&lt;span&gt;.zip&lt;/span&gt; &lt;span&gt;simpleA&lt;/span&gt;&lt;span&gt;.job&lt;/span&gt; &lt;span&gt;simpleB&lt;/span&gt;&lt;span&gt;.job&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBpL0RQrpchicHgBOt8XFmjEBicWnhRnVfLeicuyIGdarVHZvVgt6kia6NRjl9FSwdKESkdUEFa2icrsiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;同样的操作方式，两个任务放在zip包中，通过Web服务上传，观察执行效果即可。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、源代码地址&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https:&lt;span&gt;//github.com/cicadasmile/big-data-parent&lt;/span&gt;&lt;br/&gt;GitEE·地址&lt;br/&gt;https:&lt;span&gt;//gitee.com/cicadasmile/big-data-parent&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBCuF3zfJnqPKpUia4wfn1FUtTHpxxkR5HvbicPgOjibPicX0goMOkny1NdkLAJvBaqrYh3UdwMjiaDQMA/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累是一个孤独且枯燥的过程&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>76fd19fb3db4954176f67d98fcadc23d</guid>
<title>Redis 入门：Redis 概念和基础</title>
<link>https://toutiao.io/k/47fg3nq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。&lt;/p&gt;
&lt;/blockquote&gt;



&lt;h2&gt;什么是Redis&lt;/h2&gt;

&lt;p&gt;Redis是一款内存高速缓存数据库。Redis全称为：&lt;strong&gt;Remote Dictionary Server&lt;/strong&gt;（远程数据服务），使用C语言编写，Redis是一个key-value存储系统（键值存储系统），支持丰富的数据类型，如：String、list、set、zset、hash。&lt;/p&gt;

&lt;p&gt;Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。&lt;/p&gt;

&lt;h3&gt;官方资料&lt;/h3&gt;

&lt;p&gt;Redis官网:&lt;a href=&quot;http://redis.io/&quot;&gt;http://redis.io/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Redis官方文档:&lt;a href=&quot;http://redis.io/documentation&quot;&gt;http://redis.io/documentation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Redis教程:&lt;a href=&quot;http://www.w3cschool.cn/redis/redis-intro.html&quot;&gt;http://www.w3cschool.cn/redis/redis-intro.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Redis下载:&lt;a href=&quot;http://redis.io/download&quot;&gt;http://redis.io/download&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;为什么要使用Redis&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;一个产品的使用场景肯定是需要根据产品的特性，先列举一下Redis的特点：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;读写性能优异&lt;/strong&gt;&lt;br/&gt;

&lt;ul&gt;
&lt;li&gt;Redis能读的速度是110000次/s,写的速度是81000次/s （测试条件见下一节）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据类型丰富&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原子性&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;丰富的特性&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Redis支持 publish/subscribe, 通知, key 过期等特性。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持久化&lt;/strong&gt;

&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;发布订阅&lt;/strong&gt;

&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式&lt;/strong&gt;

&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（PS: 具体再结合下面的使用场景理解下）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;下面是官方的bench-mark根据如下条件获得的性能测试（&lt;strong&gt;读的速度是110000次/s,写的速度是81000次/s&lt;/strong&gt;）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;测试完成了50个并发执行100000个请求。&lt;/li&gt;
&lt;li&gt;设置和获取的值是一个256字节字符串。&lt;/li&gt;
&lt;li&gt;Linux box是运行Linux 2.6,这是X3320 Xeon 2.5 ghz。&lt;/li&gt;
&lt;li&gt;文本执行使用loopback接口(127.0.0.1)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2&gt;Redis的使用场景&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;redis应用场景总结redis平时我们用到的地方蛮多的，下面就了解的应用场景做个总结：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;热点数据的缓存&lt;/h3&gt;

&lt;p&gt;缓存是Redis最常见的应用场景，之所有这么使用，主要是因为Redis读写性能优异。而且逐渐有取代memcached，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。 &lt;/p&gt;

&lt;p&gt;作为缓存使用时，一般有两种方式保存数据：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;读取前，先去读Redis，如果没有数据，读取数据库，将数据拉入Redis。&lt;/li&gt;
&lt;li&gt;插入数据时，同时写入Redis。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;方案一：实施起来简单，但是有两个需要注意的地方：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;避免缓存击穿。（数据库没有就需要命中的数据，导致Redis一直没有数据，而一直命中数据库。）&lt;/li&gt;
&lt;li&gt;数据的实时性相对会差一点。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;方案二：数据实时性强，但是开发时不便于统一处理。&lt;/p&gt;

&lt;p&gt;当然，两种方式根据实际情况来适用。如：方案一适用于对于数据实时性要求不是特别高的场景。方案二适用于字典表、数据量不大的数据存储。&lt;/p&gt;

&lt;h3&gt;限时业务的运用&lt;/h3&gt;

&lt;p&gt;redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。&lt;/p&gt;

&lt;h3&gt;计数器相关问题&lt;/h3&gt;

&lt;p&gt;redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。&lt;/p&gt;

&lt;h3&gt;分布式锁&lt;/h3&gt;

&lt;p&gt;这个主要利用redis的setnx命令进行，setnx：&quot;set if not exists&quot;就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在俞你奔远方的后台中有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock，
如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。&lt;/p&gt;

&lt;p&gt;在分布式锁的场景中，主要用在比如秒杀系统等。&lt;/p&gt;

&lt;h3&gt;延时操作&lt;/h3&gt;

&lt;p&gt;比如在订单生产后我们占用了库存，10分钟后去检验用户是够真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub/Sub频道，以便以某种方式接收影响Redis数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期， 我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。 &lt;/p&gt;

&lt;p&gt;当然我们也可以利用rabbitmq、activemq等消息中间件的延迟队列服务实现该需求。&lt;/p&gt;

&lt;h3&gt;排行榜相关问题&lt;/h3&gt;

&lt;p&gt;关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。&lt;/p&gt;

&lt;p&gt;比如点赞排行榜，做一个SortedSet, 然后以用户的openid作为上面的username, 以用户的点赞数作为上面的score, 然后针对每个用户做一个hash, 通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息，这个当时在实际运用中性能体验也蛮不错的。&lt;/p&gt;

&lt;h3&gt;点赞、好友等相互关系的存储&lt;/h3&gt;

&lt;p&gt;Redis 利用集合的一些命令，比如求交集、并集、差集等。&lt;/p&gt;

&lt;p&gt;在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。&lt;/p&gt;

&lt;h3&gt;简单队列&lt;/h3&gt;

&lt;p&gt;由于Redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。&lt;/p&gt;

&lt;h2&gt;参考文章&lt;/h2&gt;



&lt;h2&gt;知识体系&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;知识体系&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://pdai.tech/_images/db/redis/db-redis-overview.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;相关文章&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;首先，我们通过学习Redis的概念基础，了解它适用的场景。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://pdai.tech/md/db/nosql-redis/db-redis-introduce.html&quot;&gt;Redis入门 - Redis概念和基础&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;其次，这些适用场景都是基于Redis支持的数据类型的，所以我们需要学习它支持的数据类型；同时在redis优化中还需要对底层数据结构了解，所以也需要了解一些底层数据结构的设计和实现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://pdai.tech/_images/db/redis/db-redis-object-2-2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;blockquote&gt;
&lt;p&gt;再者，需要学习Redis支持的核心功能，包括持久化，消息，事务，高可用；高可用方面包括，主从，哨兵等；高可拓展方面，比如 分片机制等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://pdai.tech/md/db/nosql-redis/db-redis-x-rdb-aof.html&quot;&gt;Redis进阶 - 持久化：RDB和AOF机制详解&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;为了防止数据丢失以及服务重启时能够恢复数据，Redis支持数据的持久化，主要分为两种方式，分别是RDB和AOF; 当然实际场景下还会使用这两种的混合模式。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pdai.tech/md/db/nosql-redis/db-redis-x-pub-sub.html&quot;&gt;Redis进阶 - 消息传递：发布订阅模式详解&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pdai.tech/md/db/nosql-redis/db-redis-x-event.html&quot;&gt;Redis进阶 - 事件：Redis事件机制详解&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Redis 采用事件驱动机制来处理大量的网络IO。它并没有使用 libevent 或者 libev 这样的成熟开源方案，而是自己实现一个非常简洁的事件驱动库 ae_event。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pdai.tech/md/db/nosql-redis/db-redis-x-trans.html&quot;&gt;Redis进阶 - 事务：Redis事务详解&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pdai.tech/md/db/nosql-redis/db-redis-x-copy.html&quot;&gt;Redis进阶 - 高可用：主从复制详解&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;我们知道要避免单点故障，即保证高可用，便需要冗余（副本）方式提供集群服务。而Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。本文主要阐述Redis的主从复制。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pdai.tech/md/db/nosql-redis/db-redis-x-sentinel.html&quot;&gt;Redis进阶 - 高可用：哨兵机制（Redis Sentinel）详解&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;在上文主从复制的基础上，如果注节点出现故障该怎么办呢？ 在 Redis 主从集群中，哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制模式下故障转移的问题。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pdai.tech/md/db/nosql-redis/db-redis-x-cluster.html&quot;&gt;Redis进阶 - 高可拓展：分片技术（Redis Cluster）详解&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;前面两篇文章，主从复制和哨兵机制保障了高可用，就读写分离而言虽然slave节点来扩展主从的读并发能力，但是写能力和存储能力是无法进行扩展的，就只能是master节点能够承载的上限。如果面对海量数据那么必然需要构建master（主节点分片)之间的集群，同时必然需要吸收高可用（主从复制和哨兵机制）能力，即每个master分片节点还需要有slave节点，这是分布式系统中典型的纵向扩展（集群的分片技术）的体现；所以在Redis 3.0版本中对应的设计就是Redis Cluster。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;最后，就是具体的实践以及实践中遇到的问题和解决方法了：在不同版本中有不同特性，所以还需要了解版本；以及性能优化，大厂实践等。&lt;/p&gt;
&lt;/blockquote&gt;



&lt;h2&gt;学习资料&lt;/h2&gt;



&lt;p&gt;除此之外，我还推荐你看下 极客时间 《Redis核心技术与实战》（作者：蒋德钧）的相关内容，它是我看到的为数不多的含有实战经验比较多的专栏，部分文章中图片也来源于这个系列。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ce3c8b118dafe61e2adebad2f3b938cf</guid>
<title>详解 Go 程序的启动流程，你知道 g0，m0 是什么吗？</title>
<link>https://toutiao.io/k/twm9mo2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自古应用程序均从 Hello World 开始，你我所写的 Go 语言亦然：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;hello world.&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段程序的输出结果为 &lt;code&gt;hello world.&lt;/code&gt;，就是这么的简单又直接。但这时候又不禁思考了起来，这个 &lt;code&gt;hello world.&lt;/code&gt; 是怎么输出来，经历了什么过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;真是非常的好奇，今天我们就一起来探一探 Go 程序的启动流程。其中涉及到 Go Runtime 的调度器启动，g0，m0 又是什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;车门焊死，正式开始吸鱼之路。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Go 引导阶段&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;查找入口&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先编译上文提到的示例程序：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; GOFLAGS=&lt;span&gt;&quot;-ldflags=-compressdwarf=false&quot;&lt;/span&gt; go build &lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在命令中指定了 GOFLAGS 参数，这是因为在 Go1.11 起，为了减少二进制文件大小，调试信息会被压缩。导致在 MacOS 上使用 gdb 时无法理解压缩的 DWARF 的含义是什么（而我恰恰就是用的 MacOS）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此需要在本次调试中将其关闭，再使用 gdb 进行调试，以此达到观察的目的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; gdb awesomeProject &lt;/span&gt;&lt;br/&gt;(gdb) info files&lt;br/&gt;Symbols from &quot;/Users/eddycjy/go-application/awesomeProject/awesomeProject&quot;.&lt;br/&gt;Local exec file:&lt;br/&gt; `/Users/eddycjy/go-application/awesomeProject/awesomeProject&#x27;, file type mach-o-x86-64.&lt;br/&gt; Entry point: 0x1063c80&lt;br/&gt; 0x0000000001001000 - 0x00000000010a6aca is .text&lt;br/&gt; ...&lt;br/&gt;(gdb) b *0x1063c80&lt;br/&gt;Breakpoint 1 at 0x1063c80: file /usr/local/Cellar/go/1.15/libexec/src/runtime/rt0_darwin_amd64.s, line 8.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 Entry point 的调试，可看到真正的程序入口在 runtime 包中，不同的计算机架构指向不同。例如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;MacOS 在 &lt;code&gt;src/runtime/rt0_darwin_amd64.s&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Linux 在 &lt;code&gt;src/runtime/rt0_linux_amd64.s&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其最终指向了 rt0_darwin_amd64.s 文件，这个文件名称非常的直观：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Breakpoint 1 at 0x1063c80: file /usr/&lt;span&gt;local&lt;/span&gt;/Cellar/go/1.15/libexec/src/runtime/rt0_darwin_amd64.s, line 8.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rt0 代表 runtime0 的缩写，指代运行时的创世，超级奶爸：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;darwin 代表目标操作系统（GOOS）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;amd64 代表目标操作系统架构（GOHOSTARCH）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时 Go 语言还支持更多的目标系统架构，例如：AMD64、AMR、MIPS、WASM 等：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6489675516224189&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4iaFHVjJib9IKxJ0wgOXOaibgztHVcvJn9ms2tUj3liagxicSqORVBdjksupFXNB7gxVedvtjicYAOLEOIw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;678&quot;/&gt;&lt;figcaption&gt;源码目录&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若有兴趣可到 &lt;code&gt;src/runtime&lt;/code&gt; 目录下进一步查看，这里就不一一介绍了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;入口方法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 rt0_linux_amd64.s 文件中，可发现 &lt;code&gt;_rt0_amd64_darwin&lt;/code&gt; JMP 跳转到了 &lt;code&gt;_rt0_amd64&lt;/code&gt; 方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;TEXT _rt0_amd64_darwin(SB),NOSPLIT,$-8&lt;br/&gt; JMP _rt0_amd64(SB)&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;紧接着又跳转到 &lt;code&gt;runtime·rt0_go&lt;/code&gt; 方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;TEXT _rt0_amd64(SB),NOSPLIT,$-8&lt;br/&gt; MOVQ 0(SP), DI // argc&lt;br/&gt; LEAQ 8(SP), SI // argv&lt;br/&gt; JMP runtime·rt0_go(SB)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法将程序输入的 argc 和 argv 从内存移动到寄存器中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;栈指针（SP）的前两个值分别是 argc 和 argv，其对应参数的数量和具体各参数的值。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;开启主线&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序参数准备就绪后，正式初始化的方法落在 &lt;code&gt;runtime·rt0_go&lt;/code&gt; 方法中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;TEXT runtime·rt0_go(SB),NOSPLIT,&lt;span&gt;$0&lt;/span&gt;&lt;br/&gt; ...&lt;br/&gt; CALL runtime·check(SB)&lt;br/&gt; MOVL 16(SP), AX  // copy argc&lt;br/&gt; MOVL AX, 0(SP)&lt;br/&gt; MOVQ 24(SP), AX  // copy argv&lt;br/&gt; MOVQ AX, 8(SP)&lt;br/&gt; CALL runtime·args(SB)&lt;br/&gt; CALL runtime·osinit(SB)&lt;br/&gt; CALL runtime·schedinit(SB)&lt;br/&gt;&lt;br/&gt; // create a new goroutine to start program&lt;br/&gt; MOVQ &lt;span&gt;$runtime&lt;/span&gt;·mainPC(SB), AX  // entry&lt;br/&gt; PUSHQ AX&lt;br/&gt; PUSHQ &lt;span&gt;$0&lt;/span&gt;   // arg size&lt;br/&gt; CALL runtime·newproc(SB)&lt;br/&gt; POPQ AX&lt;br/&gt; POPQ AX&lt;br/&gt;&lt;br/&gt; // start this M&lt;br/&gt; CALL runtime·mstart(SB)&lt;br/&gt; ...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;runtime.check：运行时类型检查，主要是校验编译器的翻译工作是否正确，是否有 “坑”。基本代码均为检查 &lt;code&gt;int8&lt;/code&gt; 在 &lt;code&gt;unsafe.Sizeof&lt;/code&gt; 方法下是否等于 1 这类动作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;runtime.args：系统参数传递，主要是将系统参数转换传递给程序使用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;runtime.osinit：系统基本参数设置，主要是获取 CPU 核心数和内存物理页大小。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;runtime.schedinit：进行各种运行时组件的初始化，包含调度器、内存分配器、堆、栈、GC 等一大堆初始化工作。会进行 p 的初始化，并将 m0 和某一个 p 进行绑定。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;runtime.main：主要工作是运行 main goroutine，虽然在&lt;code&gt;runtime·rt0_go&lt;/code&gt; 中指向的是&lt;code&gt;$runtime·mainPC&lt;/code&gt;，但实质指向的是 &lt;code&gt;runtime.main&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;runtime.newproc：创建一个新的 goroutine，且绑定 &lt;code&gt;runtime.main&lt;/code&gt; 方法（也就是应用程序中的入口 main 方法）。并将其放入 m0 绑定的p的本地队列中去，以便后续调度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;runtime.mstart：启动 m，调度器开始进行循环调度。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;runtime·rt0_go&lt;/code&gt; 方法中，其主要是完成各类运行时的检查，系统参数设置和获取，并进行大量的 Go 基础组件初始化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始化完毕后进行主协程（main goroutine）的运行，并放入等待队列（GMP 模型），最后调度器开始进行循环调度。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据上述源码剖析，可以得出如下 Go 应用程序引导的流程图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5568039950062422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4iaFHVjJib9IKxJ0wgOXOaibgzYOFibkXganwxcXUhQiaiasNa7k5FXKr7AfzPdN6uFHqibbA7QEjtib9ceXA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1602&quot;/&gt;&lt;figcaption&gt;Go 程序引导过程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 语言中，实际的运行入口并不是用户日常所写的 &lt;code&gt;main func&lt;/code&gt;，更不是 &lt;code&gt;runtime.main&lt;/code&gt; 方法，而是从 &lt;code&gt;rt0_*_amd64.s&lt;/code&gt; 开始，最终再一路 JMP 到 &lt;code&gt;runtime·rt0_go&lt;/code&gt; 里去，再在该方法里完成一系列 Go 自身所需要完成的绝大部分初始化动作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中整体包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;运行时类型检查、系统参数传递、CPU 核数获取及设置、运行时组件的初始化（调度器、内存分配器、堆、栈、GC 等）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;运行 main goroutine。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;运行相应的 GMP 等大量缺省行为。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;涉及到调度器相关的大量知识。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续将会继续剖析将进一步剖析 &lt;code&gt;runtime·rt0_go&lt;/code&gt; 里的爱与恨，尤其像是 &lt;code&gt;runtime.main&lt;/code&gt;、&lt;code&gt;runtime.schedinit&lt;/code&gt; 等调度方法，都有非常大的学习价值，有兴趣的小伙伴可以持续关注。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Go 调度器初始化&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道了 Go 程序是怎么引导起来的之后，我们需要了解 Go Runtime 中调度器是怎么流转的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;runtime.mstart&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要关注 &lt;code&gt;runtime.mstart&lt;/code&gt; 方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;mstart&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 获取 g0&lt;/span&gt;&lt;br/&gt; _g_ := getg()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 确定栈边界&lt;/span&gt;&lt;br/&gt; osStack := _g_.stack.lo == &lt;span&gt;0&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; osStack {&lt;br/&gt;  size := _g_.stack.hi&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; size == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   size = &lt;span&gt;8192&lt;/span&gt; * sys.StackGuardMultiplier&lt;br/&gt;  }&lt;br/&gt;  _g_.stack.hi = &lt;span&gt;uintptr&lt;/span&gt;(noescape(unsafe.Pointer(&amp;amp;size)))&lt;br/&gt;  _g_.stack.lo = _g_.stack.hi - size + &lt;span&gt;1024&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; _g_.stackguard0 = _g_.stack.lo + _StackGuard&lt;br/&gt; _g_.stackguard1 = _g_.stackguard0&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;// 启动 m，进行调度器循环调度&lt;/span&gt;&lt;br/&gt; mstart1()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 退出线程&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; mStackIsSystemAllocated() {&lt;br/&gt;  osStack = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; mexit(osStack)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;getg&lt;/code&gt; 方法获取 GMP 模型中的 g，此处获取的是 g0。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过检查 g 的执行栈 &lt;code&gt;_g_.stack&lt;/code&gt; 的边界（堆栈的边界正好是 lo, hi）来确定是否为系统栈。若是，则根据系统栈初始化 g 执行栈的边界。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;mstart1&lt;/code&gt; 方法启动系统线程 m，进行调度器循环调度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;mexit&lt;/code&gt; 方法退出系统线程 m。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;runtime.mstart1&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么看来其实质逻辑在 &lt;code&gt;mstart1&lt;/code&gt; 方法，我们继续往下剖析：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;mstart1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 获取 g，并判断是否为 g0&lt;/span&gt;&lt;br/&gt; _g_ := getg()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; _g_ != _g_.m.g0 {&lt;br/&gt;  throw(&lt;span&gt;&quot;bad runtime·mstart&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 初始化 m 并记录调用方 pc、sp&lt;/span&gt;&lt;br/&gt; save(getcallerpc(), getcallersp())&lt;br/&gt; asminit()&lt;br/&gt; minit()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 设置信号 handler&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; _g_.m == &amp;amp;m0 {&lt;br/&gt;  mstartm0()&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 运行启动函数&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; fn := _g_.m.mstartfn; fn != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  fn()&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; _g_.m != &amp;amp;m0 {&lt;br/&gt;  acquirep(_g_.m.nextp.ptr())&lt;br/&gt;  _g_.m.nextp = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; schedule()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;getg&lt;/code&gt; 方法获取 g。并且通过前面绑定的 &lt;code&gt;_g_.m.g0&lt;/code&gt; 判断所获取的 g 是否 g0。若不是，则直接抛出致命错误。因为调度器仅在 g0 上运行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;minit&lt;/code&gt; 方法初始化 m，并记录调用方的 PC、SP，便于后续 schedule 阶段时的复用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若确定当前的 g 所绑定的 m 是 m0，则调用 &lt;code&gt;mstartm0&lt;/code&gt; 方法，设置信号 handler。该动作必须在 &lt;code&gt;minit&lt;/code&gt; 方法之后，这样 &lt;code&gt;minit&lt;/code&gt; 方法可以提前准备好线程，以便能够处理信号。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若当前 g 所绑定的 m 有启动函数，则运行。否则跳过。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若当前 g 所绑定的 m 不是 m0，则需要调用 &lt;code&gt;acquirep&lt;/code&gt; 方法获取并绑定 p，也就是 m 与 p 绑定。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;schedule&lt;/code&gt; 方法进行正式调度。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;忙活了一大圈，终于进入到开题的主菜了，原来潜伏的很深的 &lt;code&gt;schedule&lt;/code&gt; 方法才是真正做调度的方法，其他都是前置处理和准备数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于篇幅问题，&lt;code&gt;schedule&lt;/code&gt; 方法会放到下篇再继续剖析，我们先聚焦本篇的一些细节点。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;问题深剖&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过到这里篇幅也已经比较长了，积累了不少问题。我们针对在 Runtime 中出镜率最高的两个元素进行剖析：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;m0&lt;/code&gt; 是什么，作用是？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;g0&lt;/code&gt; 是什么，作用是？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;m0&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;m0 是 Go Runtime 所创建的第一个系统线程，一个 Go 进程只有一个 m0，也叫主线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从多个方面来看：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据结构：m0 和其他创建的 m 没有任何区别。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建过程：m0 是进程在启动时应该汇编直接复制给 m0 的，其他后续的 m 则都是 Go Runtime 内自行创建的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;变量声明：m0 和常规 m 一样，m0 的定义就是 &lt;code&gt;var m0 m&lt;/code&gt;，没什么特别之处。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;g0&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;g 一般分为三种，分别是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;执行用户任务的叫做 g。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行 &lt;code&gt;runtime.main&lt;/code&gt; 的 main goroutine。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行调度任务的叫 g0。。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;g0 比较特殊，每一个 m 都只有一个 g0（仅此只有一个 g0），且每个 m 都只会绑定一个 g0。在 g0 的赋值上也是通过汇编赋值的，其余后续所创建的都是常规的 g。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从多个方面来看：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据结构：g0 和其他创建的 g 在数据结构上是一样的，但是存在栈的差别。在 g0 上的栈分配的是系统栈，在 Linux 上栈大小默认固定 8MB，不能扩缩容。而常规的 g 起始只有 2KB，可扩容。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;运行状态：g0 和常规的 g 不一样，没有那么多种运行状态，也不会被调度程序抢占，调度本身就是在 g0 上运行的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;变量声明：g0 和常规 g，g0 的定义就是 &lt;code&gt;var g0 g&lt;/code&gt;，没什么特别之处。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本章节中我们讲解了 Go 调度器初始化的一个过程，分别涉及：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;runtime.mstart。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;runtime.mstart1。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于此也了解到了在调度器初始化过程中，需要准备什么，初始化什么。另外针对调度过程中最常提到的 m0、g0 的概念我们进行了梳理和说明。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在今天这篇文章中，我们详细的介绍了 Go 语言的引导启动过程中的所有流程和初始化动作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时针对调度器的初始化进行了初步分析，详细介绍了 m0、g0 的用途和区别。在下一篇文章中我们将进一步对真正调度的 &lt;code&gt;schedule&lt;/code&gt; 方法进行详解，这块也是个硬骨头了。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>af350e79258e5af0dde91e2768107ea1</guid>
<title>软件配置管理实践：基于 Ansible 和 Nacos</title>
<link>https://toutiao.io/k/mo14ttn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.400437636761488&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FBPFm28kpSwicmV09Jn62iaCJicJRMMQQkGmqX9FfMUGjHlPgIKXepk87O5cCiahYnmmwHprciaRcm8tzYAlz5T2s4A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;457&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU1Njk2NjkxNA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSylnVQR07iciae4vSLoFOz9MZFeicgVPZOAHAroeCXOc1J0UQOuBVuUcChJ8TBAePia5SWE2unpwoa09Q/0?wx_fmt=png&quot; data-nickname=&quot;老翟杂谈&quot; data-alias=&quot;&quot; data-signature=&quot;分享持续交付的实践经验、软件工程感悟&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;配置管理的预备知识&lt;/h2&gt;&lt;p&gt;在《持续交付》第二章的小结中，作者写道：配置管理是本书其他内容的基础。没有配置管理，根本谈不上持续集成、发布管理以及部署流水线。&lt;/p&gt;&lt;p&gt;可以看出，配置的管理是多么的重要。在小结中，作者使用以下几个问题来判断你的配置管理做得是否好：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;是否仅依靠保存于版本控制系统的数据（除了生产数据），就可以从无到有重建生产系统？&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;是否可以将应用程序回滚到以前某个正确的状态？&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;是否确保在测试、试运行和正式上线时以同样的方式创建部署环境？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;如果你的配置管理流程比较好的话，所有的问题都应该是肯定的。&lt;/p&gt;&lt;p&gt;经过笔者长时间的一线配置管理的经验，要想更好实践《持续交付》中的配置管理，笔者认为配置管理中心应该能做到：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;配置项的定义与配置的存储的解耦。比如应用可能会从Nacos中读取，也可以从环境变量里读取。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;配置项之间的相互引用：消除重复配置项。比如MySQL的连接字符串，可能同时在应用a的配置和应用b的配置中出现。&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;配置项版本化：配置项变更跟踪；&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;配置项的定义与配置的格式的解耦。比如同一个配置项在应用a使用的是XML格式，但是应用b使用的是YAML格式。&lt;/span&gt;&lt;span&gt;&lt;span&gt;5.&lt;/span&gt;配置项的自动化校验：当用户引入一个错误的配置项时，我们应该可以知道。&lt;/span&gt;&lt;span&gt;&lt;span&gt;6.&lt;/span&gt;配置项的作用域功能。&lt;/span&gt;&lt;span&gt;&lt;span&gt;7.&lt;/span&gt;配置项分组功能：比如按环境对配置项进行分组。&lt;/span&gt;&lt;span&gt;&lt;span&gt;8.&lt;/span&gt;配置项加密功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;目前没有一个配置中心能实现以上所有的功能。但是，基于Ansible再配合其它工具，我们可以很低成本地实现以上大部分功能，虽然有些粗糙。&lt;/p&gt;&lt;h2&gt;基于Ansible和Nacos的实践&lt;/h2&gt;&lt;p&gt;本文以Ansible结合Nacos为例介绍如何更好的进行配置管理。&lt;/p&gt;&lt;p&gt;在本案例中，Ansible担任了配置中心的角色，实现配置项的定义，描述配置项与配置格式（XML、YAML、Properties）之间关系，描述配置项与配置存储（Nacos）之间的关系。Nacos纯粹只是一个存储配置的角色。&lt;/p&gt;&lt;h3&gt;Ansible介绍&lt;/h3&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9603658536585366&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSwicmV09Jn62iaCJicJRMMQQkGwggW5ZhM7Pm4BeIHFh7jBfXicU7sS2HIp9oFRQf3rcegqb5YpTuPnHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;328&quot; title=&quot;null&quot;/&gt;Ansible通常被认为是一款自动化运维工具。用户通过YAML文件描述机器或者应用的最终状态，Ansible负责实现该状态。它通过Python技术栈的Jinja2模板引擎实现了我们所需要的绝大部分配置管理功能。所以，基于它结合Jenkins这类自动化平台即可实现一个低成本的灵活的配置管理中心。&lt;/p&gt;&lt;p&gt;&lt;span&gt;说回来，配置中心的实现的核心其实是文本模板引擎。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;ansible.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;Nacos介绍&lt;/h3&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.19516129032258064&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSwicmV09Jn62iaCJicJRMMQQkGgmQ03jLXvkib67lVyibDWyUQwiaKISj876LX30XMmftyxWQf1YNRXJ0kA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;nacos.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Nacos是阿里巴巴开源的一个动态服务发现、配置管理和服务管理平台。不过，它的配置管理功能离上文谈到的配置中心还差太远。但是至少作为配置存储的实现，还是可以的。&lt;/p&gt;&lt;p&gt;说回来，由于我们的配置管理是基于Ansible的，所以，按道理，我们是可以很容易切换配置中心的。&lt;/p&gt;&lt;h3&gt;整体架构&lt;/h3&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.21285140562248997&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSwicmV09Jn62iaCJicJRMMQQkGOZGOCUrA1S2hDsl9Cc9gj8NkblhjRmhpJHrxY5libr8htj5N76SJzog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;996&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;art.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;通过Ansible的配置功能，我能实现大部分配置中心应该实现的功能。但是，我们的应用程序不会直接读取Ansible工程中的配置，而是从Nacos中读，所以，我们通过一个Ansible任务自动化将配置发布到Nacos中。最后，再结合Jenkins实现流水线。&lt;/p&gt;&lt;h3&gt;Ansible工程的准备&lt;/h3&gt;&lt;p&gt;实际工作中，我们会为每个环境创建一个Git工程项目。这个Git工程项目是一个典型的Ansible工程结构，如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;├──&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Jenkinsfile&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;groovy&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;├──&lt;/span&gt;&lt;span&gt; README&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;md&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;├──&lt;/span&gt;&lt;span&gt; group_vars&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;├──&lt;/span&gt;&lt;span&gt; all&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;├──&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;01.all&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;yaml&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;├──&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;02.nacos&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;yaml&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;└──&lt;/span&gt;&lt;span&gt; app&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;├──&lt;/span&gt;&lt;span&gt; demo&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;yaml&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;├──&lt;/span&gt;&lt;span&gt; application&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;yaml&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;yaml&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;├──&lt;/span&gt;&lt;span&gt; demo&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;yaml&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;├──&lt;/span&gt;&lt;span&gt; host_vars&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;├──&lt;/span&gt;&lt;span&gt; hosts&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;└──&lt;/span&gt;&lt;span&gt; playbook&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;nacos&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;yaml&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;如果我们要对比不同环境的配置，只需要通过Beyond compare这类工具就可以实现。就这样可以低成本的实现了一个大的配置管理平台应该有的功能。&lt;/p&gt;&lt;p&gt;以下是各个文件的介绍：&lt;/p&gt;&lt;p&gt;group_vars目录是Ansible的约定目录，用于存放组级别的配置变量及全局配置变量。我们在group_vars目录下建立一个all/app-config子目录，子目录中存储各种类型配置，是为了人类能更好查找到自己的配置。all/app-config子目录下，每一个YAML文件中只定义一个全局配置。这里实现了配置格式与配置项定义的解耦。这是整个方案中，最难理解的地方。&lt;/p&gt;&lt;p&gt;group_vars/all目录下的文件示例：&lt;/p&gt;&lt;p&gt;demo.json.yaml&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;yaml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;domo_json_nacos_config&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&quot;message&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;hello json&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;application.yaml.yaml&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;yaml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;application_yaml_nacos_config&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;---&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    server&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        port&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;8080&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;demo.properties.yaml&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;yaml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;demo_properties_nacos_config&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    spring&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;datasource&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;={{&lt;/span&gt;&lt;span&gt; global_db&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;url &lt;/span&gt;&lt;span&gt;}}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;注意，global_db.url是全局级别的配置项，它的值可以被多个配置文件引用。&lt;/p&gt;&lt;p&gt;02.nacos_config.yaml&lt;/p&gt;&lt;p&gt;此文件用于定义Nacos中的配置文件与我们的Ansible之间的关系。&lt;code&gt;nacos_config&lt;/code&gt;配置项列表中的每一项都是一个Nacos更新配置的REST API的一次请求。只不过，我们通过YAML实现声明式了。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;yaml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;nacos_config&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; dataId&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; demo&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;group&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; demoGroup&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    type&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; json&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    content&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;{{ demo_json_nacos_config | from_json | to_nice_json(indent=2) }}&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    tenant&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;{{ nacos_namespace }}&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; dataId&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; application&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;yaml&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;yaml&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;group&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; demoGroup&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    type&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; yaml&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    content&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;{{ application_yaml_nacos_config}}&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    tenant&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;{{ nacos_namespace }}&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; dataId&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; demo&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;group&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; demoGroup&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    type&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; properties&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    content&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;{{ demo_properties_nacos_config }}&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    tenant&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;{{ nacos_namespace }}&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;Nacos提供了更新配置的REST API如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;jsx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;curl &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;X POST &lt;/span&gt;&lt;span&gt;&#x27;http://127.0.0.1:8848/nacos/v1/cs/configs&#x27;&lt;/span&gt;&lt;span&gt; \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;d &lt;/span&gt;&lt;span&gt;&#x27;dataId=nacos.example&amp;amp;group=com.alibaba.nacos&amp;amp;content=contentTest&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;我们现在的问题就是如何将nacos_config.yaml中的配置变成请求Nacos REST API。有两个方案：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;方案一：在Jenkins pipeline中，使用groovy语言读取nacos_config.yaml文件，然后拼装REST请求。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;方案二：写一个Ansible任务，它会读取nacos_config.yaml的变量，然后通过Ansible的uri模块发起REST请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我们选择了方案二。因为方案二能做到与Jenkins的解耦。将来，我们切换到其它的自动化平台，难度不会太大。而且方案二能让我们脱离自动化平台，在本地手工执行。&lt;/p&gt;&lt;p&gt;以下就是我们的Ansible任务的写法：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;yaml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;---&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;nacos config deploy&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  uri&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    url&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;http://{{nacos_server_addr}}/nacos/v1/cs/configs&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    method&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; POST&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    body_format&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;raw&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    return_content&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; yes&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    body&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      tenant&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;{{item.tenant | urlencode}}&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;group&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;{{item.group|urlencode}}&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      dataId&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;{{item.dataId | urlencode}}&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      type&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;{{item.type | urlencode}}&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      content&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;{{item.content | urlencode}}&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    status_code&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    headers&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      content_type&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;Content-Type:application/x-www-form-urlencoded; charset=UTF-8&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  with_items&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;{{nacos_config}}&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;when&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; nacos_config &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;defined&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  no_log&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;{{ansible_global_no_log | default(True)}}&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;这里有一个Nacos的坑，1.x的版本下，它只支持urlencode的方式。如果配置文件太大，会请求失败。简单看了下Nacos2.x，REST API似乎没什么变化。&lt;/p&gt;&lt;h3&gt;结合Jenkins的流水线&lt;/h3&gt;&lt;p&gt;当Ansible工程准备好之后，剩下的问题就是如何自动化执行Ansible。这是Jenkins的强项，就很容易做到了。以下是核心代码：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;groovy&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;container&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&#x27;ansible&#x27;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    withCredentials&lt;/span&gt;&lt;span&gt;([&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;credentialsId&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;ansible-vault&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; variable&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&#x27;vaultFile&#x27;&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                     sshUserPrivateKey&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;credentialsId&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;ssh-keyfile&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; keyFileVariable&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&#x27;keyfile&#x27;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;])&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        sh &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            ansible&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;playbook &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;i &lt;/span&gt;&lt;span&gt;./&lt;/span&gt;&lt;span&gt;hosts \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;vault&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;file $&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;env&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;vaultFile&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt; \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;extra&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;vars &lt;/span&gt;&lt;span&gt;&#x27;ansible_ssh_private_key_file=${keyfile}&#x27;&lt;/span&gt;&lt;span&gt; \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            $&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;WORKSPACE&lt;/span&gt;&lt;span&gt;}/&lt;/span&gt;&lt;span&gt;playbook&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;yaml&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;//end container&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;至此，只要提交配置仓库代码，就可以自动化发布配置到Nacos中。&lt;/p&gt;&lt;h2&gt;后记&lt;/h2&gt;&lt;p&gt;以上实践，在我们项目组已经运行1年多，目前运行良好。除了基础设施，我们已经做到了《持续交付》中的：仅依靠保存于版本控制系统的数据，就能重建系统；能快速的回滚到某个正确的版本；在多个环境中以同样的方式部署环境。&lt;/p&gt;&lt;p&gt;本文虽然介绍的是基于Nacos，但是其思想也适用于行业中的其它的“配置中心”。希望能对你有帮助。如果你有什么疑问，可以留言。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU1Njk2NjkxNA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSylnVQR07iciae4vSLoFOz9MZFeicgVPZOAHAroeCXOc1J0UQOuBVuUcChJ8TBAePia5SWE2unpwoa09Q/0?wx_fmt=png&quot; data-nickname=&quot;老翟杂谈&quot; data-alias=&quot;&quot; data-signature=&quot;分享持续交付的实践经验、软件工程感悟&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7810b0925be3ee9a9bf2530c05a2b703</guid>
<title>ElasticSearch 如何使用 ik 进行中文分词？</title>
<link>https://toutiao.io/k/ehhe1vm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4665856622114216&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtdSwxzhzKhU2ficeWt3mz3w2syXPdV6mJ2htEbb2LElyJF8H2tVQbhS314bglIpMEKFWo63rtEzGcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;823&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;大家好，我是历小冰。在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NjE5NDQyOA==&amp;amp;mid=2247484616&amp;amp;idx=1&amp;amp;sn=e1b30eff9aee62bc232ef2800534a3dd&amp;amp;chksm=ce4fc25bf9384b4d7b2c63821d441a3b6ef74513c6bb143c1461e23c4c8c7283270d449b8869&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《为什么 ElasticSearch 比 MySQL 更适合复杂条件搜索》 &quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《为什么 ElasticSearch 比 MySQL 更适合复杂条件搜索》 &lt;/a&gt;一文中，我们讲解了 ElasticSearch 如何在数据存储方面支持全文搜索和复杂条件查询，本篇文章则着重分析 ElasticSearch 在全文搜索前如何使用 ik 进行分词，让大家对 ElasticSearch 的全文搜索和 ik 中文分词原理有一个全面且深入的了解。&lt;/p&gt;&lt;h3 data-id=&quot;heading0&quot; data-type=&quot;heading&quot; top=&quot;324&quot;&gt;&lt;span&gt;全文搜索和精确匹配&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p data-type=&quot;paragraph&quot;&gt;ElasticSearch 支持对文本类型数据进行全文搜索和精确搜索，但是必须提前为其设置对应的类型：&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;比如，创建名为 &lt;code data-type=&quot;codeinline&quot;&gt;article&lt;/code&gt; 的索引（Index），并为其两个字段（Filed）配置映射（Mapping），文章内容设置为 text 类型，而文章标题设置为 keyword 类型。&lt;/p&gt;&lt;pre data-origin=&quot;pm_code_preview&quot; lang=&quot;shell&quot;&gt;&lt;code data-type=&quot;codeline&quot;&gt;&lt;br/&gt;&lt;/code&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.39086294416243655&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtdSwxzhzKhU2ficeWt3mz3w2Dwl9WpjsmIPriaoOsINKy275TEEicj26ibiaqVW7KauJ1QEk086XPibZ55A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;788&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;Elasticsearch 在进行存储时，会对文章内容字段进行分词，获取并保存分词后的词元（tokens）；对文章标题则是不进行分词处理，直接保存原值。&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6118299445471349&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtdSwxzhzKhU2ficeWt3mz3w2HeyibFzy47Wh5uL9egjrw66WHKBBd6H3W3cbicCTicrwLsdotxe4ZiaT2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;541&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图的右半边展示了 keyword 和 text 两种类型的不同存储处理过程。&lt;/span&gt;&lt;span&gt;而左半边则展示了 ElasticSearch 相对应的两种查询方式：&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;举个例子，有两篇文章，一篇的标题和内容都是“程序员”，另外一篇的标题和内容都是“程序”，那么二者在 ElasticSearch 中的倒排索引存储如下所示（假设使用特殊分词器）。&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4151593453919035&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtdSwxzhzKhU2ficeWt3mz3w2BGgiblGqPUnQ3opHw872g516IWz3H4nqTfSNb5eibiaMmNGzNaxDMPQfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1161&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;这时，分别使用 term 和 match 查询对两个字段进行查询，就会得出如图右侧的结果。&lt;/p&gt;&lt;h3 data-id=&quot;heading1&quot; data-type=&quot;heading&quot; top=&quot;1501&quot;&gt;&lt;span&gt;Analyzer 处理过程&lt;/span&gt;&lt;/h3&gt;&lt;p data-type=&quot;paragraph&quot;&gt;可见，keyword 与 text 类型， term 与 match 查询方式之间不同就在于是否进行了分词。在 ElasticSearch 中将这个分词的过程统称了 Text analysis，也就是将字段从非结构化字符串（text）转化为结构化字符串（keyword）的过程。&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;Text analysis 不仅仅只进行分词操作，而是包含如下流程：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;使用字符过滤器（Character filters），对原始的文本进行一些处理，例如去掉空白字符等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;使用分词器（Tokenizer），对原始的文本进行分词处理，得到一些词元（tokens）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;使用词元过滤器（Token filters），对上一步得到的词元继续进行处理，例如改变词元（小写化），删除词元（删除量词）或增加词元（增加同义词），合并同义词等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.06482465462274177&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtdSwxzhzKhU2ficeWt3mz3w2tqO5SmWXXeZxpMyCjveCdIUYtWLsBgndtYT2icTPjyvu8PhdibtQjsJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;941&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;ElasticSearch 中处理 Text analysis 的组件被称为 Analyzer。相应地，Analyzer 也由三部分组成，character filters、tokenizers 和 token filters。&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;Elasticsearch 内置了 3 种字符过滤器、10 种分词器和 31 种词元过滤器。此外，还可以通过插件机制获取第三方实现的相应组件。开发者可以按照自身需求定制 Analyzer 的组成部分。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;analyzer&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;my_analyzer&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;type&quot;&lt;/span&gt;:           &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;custom&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;char_filter&quot;&lt;/span&gt;:  [ &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;html_strip&quot;&lt;/span&gt;],&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;tokenizer&quot;&lt;/span&gt;:      &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;standard&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;filter&quot;&lt;/span&gt;:       [ &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;lowercase&quot;&lt;/span&gt;,]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-origin=&quot;pm_code_preview&quot; lang=&quot;html&quot;&gt;&lt;code data-type=&quot;codeline&quot;&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;按照上述配置，&lt;code data-type=&quot;codeinline&quot;&gt;my_analyzer&lt;/code&gt; 分析器的功能大致如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;字符过滤器是 &lt;/span&gt;&lt;code data-type=&quot;codeinline&quot;&gt;html_strip&lt;/code&gt;&lt;span&gt;，会去掉 HTML 标记相关的字符；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;分词器是 ElasticSearch 默认的标准分词器 &lt;/span&gt;&lt;code data-type=&quot;codeinline&quot;&gt;standard&lt;/code&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;词元过滤器是小写化 &lt;/span&gt;&lt;code data-type=&quot;codeinline&quot;&gt;lowercase&lt;/code&gt;&lt;span&gt; 处理器，将英语单词小写化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;一般来说，Analyzer 中最为重要的就是分词器，分词结果的好坏会直接影响到搜索的准确度和满意度。ElasticSearch 默认的分词器并不是处理中文分词的最优选择，目前业界主要使用 ik 进行中文分词。&lt;/p&gt;&lt;h3 data-id=&quot;heading2&quot; data-type=&quot;heading&quot; top=&quot;2584&quot;&gt;&lt;span&gt;ik 分词原理&lt;/span&gt;&lt;/h3&gt;&lt;p data-type=&quot;paragraph&quot;&gt;ik 是目前较为主流的 ElasticSearch 开源中文分词组件，它内置了基础的中文词库和分词算法帮忙开发者快速构建中文分词和搜索功能，它还提供了扩展词库字典和远程字典等功能，方便开发者扩充网络新词或流行语。&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;ik 提供了三种内置词典，分别是：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;main.dic：&lt;/span&gt;&lt;span&gt;主词典，包括日常的通用词语，比如程序员和编程等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;quantifier.dic：&lt;/span&gt;&lt;span&gt;量词词典，包括日常的量词，比如米、公顷和小时等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;stopword.dic：&lt;/span&gt;&lt;span&gt;停用词，主要指英语的停用词，比如 a、such、that 等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;此外，开发者可以通过配置扩展词库字典和远程字典对上述词典进行扩展。&lt;/p&gt;&lt;pre data-origin=&quot;pm_code_preview&quot; lang=&quot;html&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4967741935483871&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtdSwxzhzKhU2ficeWt3mz3w2GTzAV4qHm0PoqWR1AicLPV3wSrOanmCx6mR3TbVsrazElM8lNVzsElA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;620&quot;/&gt;&lt;/p&gt;&lt;code data-type=&quot;codeline&quot;&gt;&lt;span data-type=&quot;markclass&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-type=&quot;paragraph&quot;&gt;ik 跟随 ElasticSearch 启动时，会将默认词典和扩展词典读取并加载到内存，并使用字典树 tire tree （也叫前缀树）数据结构进行存储，方便后续分词时使用。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8726114649681529&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtdSwxzhzKhU2ficeWt3mz3w2EoiaMSlJUPVtVI6jodSfrjEQgwyrPI4tDwZ3ntkf5XdYbt5Z05omRog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;471&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;字典树的典型结构如上图所示，每个节点是一个字，从根节点到叶节点，路径上经过的字符连接起来，为该节点对应的词。所以上图中的词包括：程序员、程门立雪、编织、编码和工作。&lt;/p&gt;&lt;h4 data-id=&quot;heading3&quot; data-type=&quot;heading&quot; top=&quot;3493&quot;&gt;一、加载字典&lt;/h4&gt;&lt;p data-type=&quot;paragraph&quot;&gt;ik 的 &lt;code data-type=&quot;codeinline&quot;&gt;Dictionary&lt;/code&gt; 单例对象会在初始化时，调用对应的 load 函数读取字典文件，构造三个由 &lt;code data-type=&quot;codeinline&quot;&gt;DictSegment&lt;/code&gt; 组成的字典树，分别是 &lt;code data-type=&quot;codeinline&quot;&gt;MainDict&lt;/code&gt;、&lt;code data-type=&quot;codeinline&quot;&gt;QuantifierDict&lt;/code&gt; 和 &lt;code data-type=&quot;codeinline&quot;&gt;StopWords&lt;/code&gt;。我们下面就来看一下其主词典的加载和构造过程。&lt;code data-type=&quot;codeinline&quot;&gt;loadMainDict&lt;/code&gt; 函数较为简单，它会首先创建一个 &lt;code data-type=&quot;codeinline&quot;&gt;DictSegment&lt;/code&gt; 对象作为字典树的根节点，然后分别去加载默认主字典，扩展主字典和远程主字典来填充字典树。&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;pre data-origin=&quot;pm_code_preview&quot; lang=&quot;text&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4559748427672956&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtdSwxzhzKhU2ficeWt3mz3w2ibGiaF39jpM572zQibn6jTK8ricGCia3PZyia5bNYTGiaWeKyuTDNWibPR7iaQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;636&quot;/&gt;&lt;/p&gt;&lt;code data-type=&quot;codeline&quot;/&gt;&lt;code data-type=&quot;codeline&quot;&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;复制代码&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;在 &lt;code data-type=&quot;codeinline&quot;&gt;loadDictFile&lt;/code&gt; 函数执行过程中，会从词典文件读取一行一行的词，交给 &lt;code data-type=&quot;codeinline&quot;&gt;DictSegment&lt;/code&gt; 的&lt;code data-type=&quot;codeinline&quot;&gt;fillSegment&lt;/code&gt; 函数处理。&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;code data-type=&quot;codeinline&quot;&gt;fillSegment&lt;/code&gt; 是构建字典树的核心函数，具体实现如下所示，处理逻辑大致有如下几个步骤：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;一、按照索引，获取词中的一个字；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;二、检查当前节点的子节点中是否有该字，如果没有，则将其加入到 &lt;/span&gt;&lt;code data-type=&quot;codeinline&quot;&gt;charMap&lt;/code&gt;&lt;span&gt;中；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;三、调用 &lt;/span&gt;&lt;code data-type=&quot;codeinline&quot;&gt;lookforSegment&lt;/code&gt;&lt;span&gt; 函数在字典树中寻找代表该字的节点，如果没有则插入一个新的；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;四、递归调用 &lt;/span&gt;&lt;code data-type=&quot;codeinline&quot;&gt;fillSegment&lt;/code&gt;&lt;span&gt;  函数处理下一个字。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6030989272943981&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtdSwxzhzKhU2ficeWt3mz3w23Ml0KHibJhe7vh8vAcsOr7G1vDDfnj5HskvCkbug1S34V1A3IJUv3mQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;839&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;ik 初始化过程大致如此，再进一步详细的逻辑大家可以直接去看源码，中间都是中文注释，相对来说较为容易阅读。&lt;/p&gt;&lt;h4 data-id=&quot;heading4&quot; data-type=&quot;heading&quot; top=&quot;4951&quot;&gt;二、分词逻辑&lt;/h4&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;ik 中实现了 ElasticSearch 相关的抽象类，来提供自身的分词逻辑实现：&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;code data-type=&quot;codeinline&quot;&gt;incrementToken&lt;/code&gt; 函数会调用 &lt;code data-type=&quot;codeinline&quot;&gt;IKSegmenter&lt;/code&gt; 的 &lt;code data-type=&quot;codeinline&quot;&gt;next&lt;/code&gt;方法，来获取分词结果，它是 ik 分词的核心方法。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6169630642954856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtdSwxzhzKhU2ficeWt3mz3w2Xf72INW0Ne3TzIKwJYI8AxibY4w2v9LdLycWF9cMzyXMlOWVIdhuU1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;731&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，&lt;/span&gt;&lt;code data-type=&quot;codeinline&quot;&gt;IKSegmenter&lt;/code&gt;&lt;span&gt; 中有三个分词器，在进行分词时会遍历词中的所有字，然后将单字按照顺序，让三个分词器进行处理：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code data-type=&quot;codeinline&quot;&gt;LetterSegmenter&lt;/code&gt;&lt;span&gt;，英文分词器比较简单，就是把连续的英文字符进行分词;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code data-type=&quot;codeinline&quot;&gt;CN_QuantifierSegmenter&lt;/code&gt;&lt;span&gt;，中文量词分词器，判断当前的字符是否是数词和量词，会把连起来的数词和量词分成一个词；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code data-type=&quot;codeinline&quot;&gt;CJKSegmenter&lt;/code&gt;&lt;span&gt;，核心分词器，基于前文的字典树进行分词。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;我们只讲解一下 &lt;code data-type=&quot;codeinline&quot;&gt;CJKSegmenter&lt;/code&gt; 的实现，其 &lt;code data-type=&quot;codeinline&quot;&gt;analyze&lt;/code&gt; 函数大致分为两个逻辑:&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;pre data-origin=&quot;pm_code_preview&quot; lang=&quot;text&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtdSwxzhzKhU2ficeWt3mz3w2XqAZbLaO7lSicrG0TMDWiaia81LR2QyfS45N7C8icdYnT593IiayBmsaWKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;code data-type=&quot;codeline&quot;&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-type=&quot;paragraph&quot;&gt;具体的代码逻辑，如上所示。为了方便大家理解，举个例子，比如输入的词是 &lt;code data-type=&quot;codeinline&quot;&gt;编码工作&lt;/code&gt;：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;首先处理&lt;/span&gt;&lt;code data-type=&quot;codeinline&quot;&gt;编&lt;/code&gt;&lt;span&gt;字；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span/&gt;&lt;span&gt;接着处理 &lt;/span&gt;&lt;code data-type=&quot;codeinline&quot;&gt;码&lt;/code&gt;&lt;span&gt; 字；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;依次类推，将所有字处理完。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-id=&quot;heading5&quot; data-type=&quot;heading&quot; top=&quot;6824&quot;&gt;三、消除歧义和结果输出&lt;/h4&gt;&lt;p data-type=&quot;paragraph&quot;&gt;通过上述步骤，有时候会生成很多分词结果集合，比如说，&lt;code data-type=&quot;codeinline&quot;&gt;程序员爱编程&lt;/code&gt; 会被分成 &lt;code data-type=&quot;codeinline&quot;&gt;程序员&lt;/code&gt;、&lt;code data-type=&quot;codeinline&quot;&gt;程序&lt;/code&gt;、&lt;code data-type=&quot;codeinline&quot;&gt;员&lt;/code&gt;、&lt;code data-type=&quot;codeinline&quot;&gt;爱&lt;/code&gt; 和 &lt;code data-type=&quot;codeinline&quot;&gt;编程&lt;/code&gt; 五个结果。这也是 ik 的 ik_max_word 模式的输出结果。但是有些场景，开发者希望只有 &lt;code data-type=&quot;codeinline&quot;&gt;程序员&lt;/code&gt;、&lt;code data-type=&quot;codeinline&quot;&gt;爱&lt;/code&gt; 和 &lt;code data-type=&quot;codeinline&quot;&gt;编程&lt;/code&gt; 三个分词结果，这时就需要使用 ik 的 ik_smart 模式，也就是进行消除歧义处理。&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;ik 使用 &lt;code data-type=&quot;codeinline&quot;&gt;IKArbitrator&lt;/code&gt; 进行消除歧义处理，主要使用组合遍历的方式进行处理。从上一阶段的分词结果中取出不相交的分词集合，所谓相交，就是其在文本中出现的位置是否重合。比如 &lt;code data-type=&quot;codeinline&quot;&gt;程序员&lt;/code&gt;、&lt;code data-type=&quot;codeinline&quot;&gt;程序&lt;/code&gt; 和 &lt;code data-type=&quot;codeinline&quot;&gt;员&lt;/code&gt; 三个分词结果是相交的，但是 &lt;code data-type=&quot;codeinline&quot;&gt;爱&lt;/code&gt; 和 &lt;code data-type=&quot;codeinline&quot;&gt;编程&lt;/code&gt; 是不相交的。所以分歧处理时会将 &lt;code data-type=&quot;codeinline&quot;&gt;程序员&lt;/code&gt;、&lt;code data-type=&quot;codeinline&quot;&gt;程序&lt;/code&gt; 和 &lt;code data-type=&quot;codeinline&quot;&gt;员&lt;/code&gt; 作为一个集合，&lt;code data-type=&quot;codeinline&quot;&gt;爱&lt;/code&gt; 作为一个集合，&lt;code data-type=&quot;codeinline&quot;&gt;编码&lt;/code&gt; 作为一个集合，分别进行处理，将集合中按照规则优先级最高的分词结果集选出来，具体规则如下所示：&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;根据上述规则，在第一个集合中，&lt;code data-type=&quot;codeinline&quot;&gt;程序员&lt;/code&gt; 明显要比 &lt;code data-type=&quot;codeinline&quot;&gt;程序&lt;/code&gt; 和 &lt;code data-type=&quot;codeinline&quot;&gt;员&lt;/code&gt; 要更符合规则，所以消除歧义的结果就是输出 &lt;code data-type=&quot;codeinline&quot;&gt;程序员&lt;/code&gt;，而不是 &lt;code data-type=&quot;codeinline&quot;&gt;程序&lt;/code&gt; 和 &lt;code data-type=&quot;codeinline&quot;&gt;员&lt;/code&gt;。&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;最后，对于输入字来说，有些位置可能并不在输出结果中，所以会以单字的方式作为词元直接输出（详见&lt;code data-type=&quot;codeinline&quot;&gt;AnalyzeContext&lt;/code&gt; 的 &lt;code data-type=&quot;codeinline&quot;&gt;outputToResult&lt;/code&gt; 函数）。比如 &lt;code data-type=&quot;codeinline&quot;&gt;程序员是职业&lt;/code&gt;，&lt;code data-type=&quot;codeinline&quot;&gt;是&lt;/code&gt; 字是不会被分词出来的，但是在最终输出结果时，要将其作为单字输出。&lt;/p&gt;&lt;h3 data-id=&quot;heading6&quot; data-type=&quot;heading&quot; top=&quot;7499&quot;&gt;后记&lt;/h3&gt;&lt;p data-type=&quot;paragraph&quot;&gt;ElasticSearch 和 ik 组合是目前较为主流的中文搜索技术方案，理解其搜索和分词的基础流程和原理，有利于开发者更快地构建中文搜索功能，或基于自身需求，特殊定制搜索分词策略。&lt;/p&gt;&lt;p&gt;&lt;span&gt;-关注我&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5075921908893709&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtehL5KdOC0Uib7CdHkxwGibQdibjs4kC3FpEO9ehCCjHwFa1ZSS8QoEgb9AtomP8cDZmz8jC1gR8qvzg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;922&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;amp;mid=2247483766&amp;amp;idx=1&amp;amp;sn=3d5a23891a03c7394493d52adda2fdaf&amp;amp;chksm=fc04c516cb734c00e9412cc9f5d580dba45c08980c31e8bed305292dbe7781a7c4ac083f5f09&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;TCP/IP的底层队列&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;amp;mid=2247483788&amp;amp;idx=1&amp;amp;sn=e47726a14f622fc0015d9628838ad2fe&amp;amp;chksm=fc04c5eccb734cfad8de3b624e2e26f2ac6a6790508b212146ff9e1d97d5026870b1e5af021a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;基于Redis和Lua的分布式限流&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;amp;mid=2247483716&amp;amp;idx=1&amp;amp;sn=22e5160b1fb1068b262d1b0f4fcfc0a0&amp;amp;chksm=fc04c524cb734c327b823acd2cc3ea3ef8620ab2c6c0c1dc1ac6545904f1c3259afd4f2e7450&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;AbstractQueuedSynchronizer超详细原理解析&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>