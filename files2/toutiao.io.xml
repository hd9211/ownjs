<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>bb73838b8993b5616875182294f4d7d7</guid>
<title>新生代农民工，必读！</title>
<link>https://toutiao.io/k/wswq9zl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;昨天，人社部发布了《2020 年北京市外来新生代农民工监测报告》，引发网民热议。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6028084252758275&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MjrqyjUCqickLUYno7Qn1LicPXNe9ZV3HFUYEGptZq1a6rmYx5Ynj9vGvk8II5NSRn8sqsAuF9vPoddKl8BGCGTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;997&quot;/&gt;&lt;span&gt;之所以引发网民热议，是在于软件和信息技术服务业一直是个备受青睐的行业，和传统认知中的农民工似乎完全不搭边。&lt;span&gt;但该报告似乎让 “码农” 这一称呼从软件和信息技术服务业从业者的自我调侃变为官方认证。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;报告指出，北京新生代农民工占比达到 50.1%，男性占比高于女性。其中，就业集中于劳动密集型行业，从事信息传输、软件和信息技术服务业的新生代农民工占比大幅提高。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;既然官宣了，那&lt;span&gt;属于咱 “新生代农民工” 的《码农周刊》&lt;/span&gt;，自然要推荐下哦～&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;34&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8Byw4xNoV6O2YGutfKmQLKuMZEIhBJF6MrQvoShfIAT6u3dXs6VZRzwSa2eT9jcekfaYuaOD6Hhw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bfce744668f80a48f4f7aefed0178cab</guid>
<title>阿里二面：什么是 mmap？</title>
<link>https://toutiao.io/k/qsuypsu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;平时在面试中你肯定会经常碰见的问题就是：RocketMQ为什么快？Kafka为什么快？什么是mmap？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一类的问题都逃不过的一个点就是&lt;strong&gt;零拷贝&lt;/strong&gt;，虽然还有一些其他的原因，但是今天我们的话题主要就是零拷贝。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;传统IO&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开始谈零拷贝之前，首先要对传统的IO方式有一个概念。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于传统的IO方式，底层实际上通过调用&lt;code&gt;read()&lt;/code&gt;和&lt;code&gt;write()&lt;/code&gt;来实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;code&gt;read()&lt;/code&gt;把数据从硬盘读取到内核缓冲区，再复制到用户缓冲区；然后再通过&lt;code&gt;write()&lt;/code&gt;写入到&lt;code&gt;socket缓冲区&lt;/code&gt;，最后写入网卡设备。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3918918918918919&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUnVmOVDTlSicmTLLZ82HtKeZxMVCAtvqB7vjPIJneciauiaqibxcMblRMQoDmgMWB1dEVuNI4URSIbKUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;592&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个过程发生了&lt;strong&gt;4次用户态和内核态的上下文切换&lt;/strong&gt;和&lt;strong&gt;4次拷贝&lt;/strong&gt;，具体流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户进程通过&lt;code&gt;read()&lt;/code&gt;方法向操作系统发起调用，此时上下文从用户态转向内核态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMA控制器把数据从硬盘中拷贝到读缓冲区&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CPU把读缓冲区数据拷贝到应用缓冲区，上下文从内核态转为用户态，&lt;code&gt;read()&lt;/code&gt;返回&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户进程通过&lt;code&gt;write()&lt;/code&gt;方法发起调用，上下文从用户态转为内核态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CPU将应用缓冲区中数据拷贝到socket缓冲区&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，&lt;code&gt;write()&lt;/code&gt;返回&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5401785714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUnVmOVDTlSicmTLLZ82HtKeZxcm1fbqD965WCQRm9yiayVyMheVyRFHXo19M0pfeomCaH8O2OBicpicgA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;672&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这里指的&lt;strong&gt;用户态&lt;/strong&gt;、&lt;strong&gt;内核态&lt;/strong&gt;指的是什么？上下文切换又是什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说，用户空间指的就是用户进程的运行空间，内核空间就是内核的运行空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果进程运行在内核空间就是内核态，运行在用户空间就是用户态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了安全起见，他们之间是互相隔离的，而在用户态和内核态之间的上下文切换也是比较耗时的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面我们可以看到，一次简单的IO过程产生了4次上下文切换，这个无疑在高并发场景下会对性能产生较大的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么什么又是&lt;strong&gt;DMA&lt;/strong&gt;拷贝呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为对于一个IO操作而言，都是通过CPU发出对应的指令来完成，但是相比CPU来说，IO的速度太慢了，CPU有大量的时间处于等待IO的状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此就产生了DMA（Direct Memory Access）直接内存访问技术，本质上来说他就是一块主板上独立的芯片，通过它来进行内存和IO设备的数据传输，从而减少CPU的等待时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是无论谁来拷贝，频繁的拷贝耗时也是对性能的影响。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;零拷贝&lt;/h1&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;零拷贝技术是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域，这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么对于零拷贝而言，并非真的是完全没有数据拷贝的过程，只不过是减少用户态和内核态的切换次数以及CPU拷贝的次数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里，仅仅有针对性的来谈谈几种常见的零拷贝技术。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;mmap+write&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mmap+write简单来说就是使用&lt;code&gt;mmap&lt;/code&gt;替换了read+write中的read操作，减少了一次CPU的拷贝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;mmap&lt;/code&gt;主要实现方式是将读缓冲区的地址和用户缓冲区的地址进行映射，内核缓冲区和应用缓冲区共享，从而减少了从读缓冲区到用户缓冲区的一次CPU拷贝。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5401785714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUnVmOVDTlSicmTLLZ82HtKeZ9veTtLOR5gXvOpfiaf5P2SS40KOOm3rKvAsdzRSnHOKVpia2iaeNdO8KA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;672&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个过程发生了&lt;strong&gt;4次用户态和内核态的上下文切换&lt;/strong&gt;和&lt;strong&gt;3次拷贝&lt;/strong&gt;，具体流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户进程通过&lt;code&gt;mmap()&lt;/code&gt;方法向操作系统发起调用，上下文从用户态转向内核态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMA控制器把数据从硬盘中拷贝到读缓冲区&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;上下文从内核态转为用户态，mmap调用返回&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户进程通过&lt;code&gt;write()&lt;/code&gt;方法发起调用，上下文从用户态转为内核态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;CPU将读缓冲区中数据拷贝到socket缓冲区&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，&lt;code&gt;write()&lt;/code&gt;返回&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;mmap&lt;/code&gt;的方式节省了一次CPU拷贝，同时由于用户进程中的内存是虚拟的，只是映射到内核的读缓冲区，所以可以节省一半的内存空间，比较适合大文件的传输。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;sendfile&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比&lt;code&gt;mmap&lt;/code&gt;来说，&lt;code&gt;sendfile&lt;/code&gt;同样减少了一次CPU拷贝，而且还减少了2次上下文切换。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21642969984202212&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUnVmOVDTlSicmTLLZ82HtKeZ35y5xMiciby5MnjNGlic8OTDphZOvHsiaGcFH7SQhjB2Afy5AgcuoHolrw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1266&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sendfile&lt;/code&gt;是Linux2.1内核版本后引入的一个系统调用函数，通过使用&lt;code&gt;sendfile&lt;/code&gt;数据可以直接在内核空间进行传输，因此避免了用户空间和内核空间的拷贝，同时由于使用&lt;code&gt;sendfile&lt;/code&gt;替代了&lt;code&gt;read+write&lt;/code&gt;从而节省了一次系统调用，也就是2次上下文切换。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5338235294117647&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUnVmOVDTlSicmTLLZ82HtKeZibzJ5E3HGYYh1MYJp2Qog7fyXwYjXkqNKkDWO94rZMbAp2MOSPpUj1g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;680&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个过程发生了&lt;strong&gt;2次用户态和内核态的上下文切换&lt;/strong&gt;和&lt;strong&gt;3次拷贝&lt;/strong&gt;，具体流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户进程通过&lt;code&gt;sendfile()&lt;/code&gt;方法向操作系统发起调用，上下文从用户态转向内核态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMA控制器把数据从硬盘中拷贝到读缓冲区&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CPU将读缓冲区中数据拷贝到socket缓冲区&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，&lt;code&gt;sendfile&lt;/code&gt;调用返回&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sendfile&lt;/code&gt;方法IO数据对用户空间完全不可见，所以只能适用于完全不需要用户空间处理的情况，比如静态文件服务器。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;sendfile+DMA Scatter/Gather&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux2.4内核版本之后对&lt;code&gt;sendfile&lt;/code&gt;做了进一步优化，通过引入新的硬件支持，这个方式叫做DMA Scatter/Gather 分散/收集功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它将读缓冲区中的数据描述信息--内存地址和偏移量记录到socket缓冲区，由 DMA 根据这些将数据从读缓冲区拷贝到网卡，相比之前版本减少了一次CPU拷贝的过程&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5338235294117647&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUnVmOVDTlSicmTLLZ82HtKeZmMb5P3kcAF4oa244rgSpks8tSLKicDE5U0v7Kice2aLxQUUm1dCyCvxg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;680&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个过程发生了&lt;strong&gt;2次用户态和内核态的上下文切换&lt;/strong&gt;和&lt;strong&gt;2次拷贝&lt;/strong&gt;，其中更重要的是完全没有CPU拷贝，具体流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户进程通过&lt;code&gt;sendfile()&lt;/code&gt;方法向操作系统发起调用，上下文从用户态转向内核态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMA控制器利用scatter把数据从硬盘中拷贝到读缓冲区离散存储&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CPU把读缓冲区中的文件描述符和数据长度发送到socket缓冲区&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMA控制器根据文件描述符和数据长度，使用scatter/gather把数据从内核缓冲区拷贝到网卡&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;sendfile()&lt;/code&gt;调用返回，上下文从内核态切换回用户态&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;DMA gather&lt;/code&gt;和&lt;code&gt;sendfile&lt;/code&gt;一样数据对用户空间不可见，而且需要硬件支持，同时输入文件描述符只能是文件，但是过程中完全没有CPU拷贝过程，极大提升了性能。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;应用场景&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于文章开头说的两个场景：RocketMQ和Kafka都使用到了零拷贝的技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于MQ而言，无非就是生产者发送数据到MQ然后持久化到磁盘，之后消费者从MQ读取数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于RocketMQ来说这两个步骤使用的是&lt;code&gt;mmap+write&lt;/code&gt;，而Kafka则是使用&lt;code&gt;mmap+write&lt;/code&gt;持久化数据，发送数据使用&lt;code&gt;sendfile&lt;/code&gt;。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于CPU和IO速度的差异问题，产生了DMA技术，通过DMA搬运来减少CPU的等待时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传统的IO&lt;code&gt;read+write&lt;/code&gt;方式会产生2次DMA拷贝+2次CPU拷贝，同时有4次上下文切换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而通过&lt;code&gt;mmap+write&lt;/code&gt;方式则产生2次DMA拷贝+1次CPU拷贝，4次上下文切换，通过内存映射减少了一次CPU拷贝，可以减少内存使用，适合大文件的传输。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sendfile&lt;/code&gt;方式是新增的一个系统调用函数，产生2次DMA拷贝+1次CPU拷贝，但是只有2次上下文切换。因为只有一次调用，减少了上下文的切换，但是用户空间对IO数据不可见，适用于静态文件服务器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sendfile+DMA gather&lt;/code&gt;方式产生2次DMA拷贝，没有CPU拷贝，而且也只有2次上下文切换。虽然极大地提升了性能，但是需要依赖新的硬件设备支持。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://juejin.cn/post/6844903949359644680#heading-19&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.cnblogs.com/xiaolincoding/p/13719610.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://time.geekbang.org/column/article/118657&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.toutiao.com/i6898240850917114380/&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>75243f0bec6344a0dc025214a0931220</guid>
<title>分布式事务之最终一致性实现方案</title>
<link>https://toutiao.io/k/1gsejz4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;文章目录：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;前言&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;什么是最终一致性？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;实现方案&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;代码实现&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;小结&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;推荐阅读&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这篇文章是&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;amp;mid=2448836321&amp;amp;idx=1&amp;amp;sn=7c4993c3b499625d14fe9449ff91529c&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《关于分布式事务的理解》&lt;/a&gt;&lt;span&gt;的后续篇：&lt;/span&gt;&lt;span&gt;分布式事务之最终一致性实现方案。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是那个电商需求，一个订单支付完成后的业务场景，有如下操作：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;415&quot; data-backw=&quot;558&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7435897435897436&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/go9jpG3BuhSicnpicn59dDtibyCkEYjl8kFGibfrKlju6bASkjocu56fhYqiaHDib2jTH99b1NyeQia0XT8mthaib3lEMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;更改订单的状态为 “已支付”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扣减商品库存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;给会员增加积分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建出库单通知仓库发货&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;咱们使用 &lt;strong&gt;最终一致性方案&lt;/strong&gt; 去实现它。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是最终一致性？&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从字面上看就是 &lt;strong&gt;保证数据最后的一致性&lt;/strong&gt; 就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了减少系统代价，如果中间节点处理失败，其他节点一般不会自动回滚，而是通过重试机制和人工参与的方式对失败数据进行处理，从而来保证数据最后的一致性。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现方案&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用 本地消息表 + 后台任务 + 消息队列 + 接口幂等性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本地消息表&lt;/strong&gt;：在对应业务数据库中增加的本地消息表，这张表存储业务产生的消息，通过 &lt;strong&gt;本地事务&lt;/strong&gt; 保证业务数据和消息数据的一致性，比如：&lt;code&gt;msg_published&lt;/code&gt; 和 &lt;code&gt;msg_received&lt;/code&gt; 表示发布消息表和接收消息表，在消息表中会有一个状态来标识业务是否执行成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;后台任务&lt;/strong&gt;：当消息表中有执行失败的业务信息时，后台任务就会按照配置的重试策略进行重试，例如重试策略为当发送和消费消息的过程中失败会立即重试 3 次，在 3 次以后将进入重试轮询；重试将在发送和消费消息失败的 4分钟后 开始，这是为了避免设置消息状态延迟导致可能出现的问题；后续就会每隔 1 分钟之后重试一次，默认的最高重试次数为 50 次，当达到 50 次时，就不会重试了，通过发邮件/微信/钉钉/短信的方式通知人工去处理，通知时需要考虑消息降噪。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;消息队列&lt;/strong&gt;：跨服务之间的调用使用消息队列，来实现服务解耦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;接口幂等性&lt;/strong&gt;：接口需要保证同一操作发起的一次请求或者多次请求的结果必须是一致的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;代码实现&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐一个 &lt;code&gt;C#&lt;/code&gt; 开源项目 &lt;span&gt;CAP&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;，大家可以参考一下。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;213&quot; data-backw=&quot;542&quot; data-ratio=&quot;0.3929219600725953&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/go9jpG3BuhQ9NSDpYsicicjlMwJWiaSmNxxjTNb4TCTHggibrf32wDRecNCUoItibm6cvw2zUOEK8nLJh4XpibYfte8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1102&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个项目只支持 &lt;code&gt;C#&lt;/code&gt; 代码去集成，如果是其他语言可以参考其设计思路，然后进行一个简单的实现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文纯属抛砖引玉，有问题，欢迎批评指正。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你有更好的实现方案吗？欢迎留言~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;推荐阅读&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;CAP: &lt;em&gt;https://github.com/dotnetcore/CAP&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NDM4MDIwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/go9jpG3BuhQHrM0sshKxdaibyDNjXooZvnwwy0yRjdhlXrtVUkJSvQib4Ppwib1v5HucaRc8WPtgvhPBicMeiadAv9Q/0?wx_fmt=png&quot; data-nickname=&quot;新亮笔记&quot; data-alias=&quot;XinLiangTalk&quot; data-signature=&quot;程序猿的打怪升级之路。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;184&quot; data-backw=&quot;334&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/go9jpG3BuhSP7wibS4BHtlu4hduFYq8VbSAgRic8ib6hdd6qTRGxYSic7UFF9yPyGd4pGUw1XicibFRlGHBe9RJ09Smw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>94c9ea5d903ff02a3142cf6036a58e58</guid>
<title>写一个 CRUD 还挺难的</title>
<link>https://toutiao.io/k/78ckm65</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot;&gt;

&lt;p&gt;让我们只从后端角度出发，考虑写一个简单的博客系统会有哪些问题。这篇文章谈论的并不是某个 Web 框架的 TODO list demo 之类的东西，那都是玩具性质的，而是会谈一谈生产环境中的要考虑的一些实际问题。本文中，我们也不会涉及到像是 MySQL 的几种隔离模式或者是 Kafka 是不是 Exactly Once 这种后端面试常问的八股文，而是从全局考虑一些简单但是又避不开的繁琐问题。&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;ez-toc-section&quot; id=&quot;%E6%95%B0%E6%8D%AE%E5%BA%93&quot;/&gt;数据库&lt;span class=&quot;ez-toc-section-end&quot;/&gt;&lt;/h2&gt;
&lt;p&gt;首先，需要定义一下数据库的表吧。在博客中，我们至少需要两个表：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;articles&lt;/li&gt;
&lt;li&gt;users&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中 articles 表中应该有一个 author_id 字段关联到 users 表中。那么问题来了，要不要在数据库层面定义物理外键呢？还是仅仅从逻辑上把两者关联起来。&lt;/p&gt;
&lt;p&gt;使用物理外键的好处是可以少处理很多异常情况，因为数据库层面已经帮你解决了。但是在开发阶段，当需要删除数据的时候会有很繁琐的依赖问题。在生产环境中，外键也可能带来一些写入的性能问题。&lt;/p&gt;
&lt;p&gt;如果只使用逻辑外键呢？那么就需要经常考虑有非法外键的情况，代码中要做好处理，不然就异常满天飞了。&lt;/p&gt;
&lt;p&gt;关于数据库的第二个问题，要不要使用 ORM 呢？或许你已经习惯了使用 SQLAlchemy 或是 Hibernate 这类 ORM，并且认为这就是最佳实践。实际上，ORM 并不一定是最好的选择，选择 ORM 可能会有三个缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;意味着你在 SQL 语法之外还要另外学习一门 ORM 中包含的 DSL；&lt;/li&gt;
&lt;li&gt;ORM 也不能覆盖所有的 SQL 语句，很多时候你还是得手写 SQL；&lt;/li&gt;
&lt;li&gt;ORM 生成的 SQL 经常性能有问题，比如说经常就不小心 N+1 问题或者 &lt;code&gt;select *&lt;/code&gt; 了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;甚至于，有的人认为 ORM 技术就是一团泥潭，&lt;a href=&quot;http://blogs.tedneward.com/post/the-vietnam-of-computer-science/&quot;&gt;堪比计算机界的越南战争（美国视角）&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;当然，不用 ORM 问题也很多，手工拼接 SQL 非常恶心不说，还容易出现 SQL 注入攻击的漏洞。&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;ez-toc-section&quot; id=&quot;%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E&quot;/&gt;安全漏洞&lt;span class=&quot;ez-toc-section-end&quot;/&gt;&lt;/h2&gt;
&lt;p&gt;正如刚刚提到的 SQL 注入攻击一样，作为一个生产环境的应用，面向大众开放，自然要考虑一些恶意攻击者的访问。&lt;/p&gt;
&lt;p&gt;举个例子，你为了方便前端调用，在 API 中留下了一个 &lt;code&gt;order_by=xxx&lt;/code&gt; 的参数，为了开发更灵活，这个参数直接对应到了数据库的字段而没有过滤。正常情况下，在你的客户端或者前端代码中，只是简单调用了一下 &lt;code&gt;order_by=create_time&lt;/code&gt;，而这个字段是加了索引的，那么皆大欢喜。但是，恶意攻击者可不是这么想的，『我干嘛不调用一下没有索引的字段呢？』。比如说，发送大量的攻击请求到 &lt;code&gt;order_by=first_name&lt;/code&gt; 上，那么很快你的数据库就可能被慢查询拖垮了。&lt;/p&gt;
&lt;p&gt;这个例子蕴含了一个普遍的道理：灵活和安全不可得兼，你必须针对你的应用，选择一个恰当的地方做好折中。&lt;/p&gt;
&lt;p&gt;上面的例子还没有涉及到数据，只是把网站搞挂了而已。另一个容易产生漏洞的地方，就是权限管理了。&lt;/p&gt;
&lt;p&gt;假设你有一个用户更新自己文章的 API。那么就应该在其中校验用户传过来的 article_id 是不是他自己的文章。前端校验是不够的，假如恶意用户构造一个请求呢？如果不校验，就可能导致任意修改他人文章的漏洞。再比如，文章状态可能包含草稿和已发布，那么应该只有已发布的文章才可以浏览，但是用户也应该能预览和编辑自己未发布的草稿，你都需要判断是否有适当的权限。问题还可以变得更复杂一点，用户可能分为普通用户和管理员用户，管理员用户又可以查看所有的文章。在稍微大型一点的应用中，文章可能有不同的属性分类，用户更是可能有不同的角色，比如编辑、审核、管理员等等，文章的展现形式也可能多种多样，比如说是完全不可见，还是仅列表隐藏，还是仅列表可见标题，实际访问才会提示不可见/付费内容呢？&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;ez-toc-section&quot; id=&quot;%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F&quot;/&gt;后台系统&lt;span class=&quot;ez-toc-section-end&quot;/&gt;&lt;/h2&gt;
&lt;p&gt;前面提到了管理员用户，那么就引入了又一个问题——后台管理系统。对于一个博客系统的普通浏览者，看到的可能就是一篇篇的博客，但是对于博客的作者或者管理员来说，一定还有一个后台管理系统来写博客。后台管理系统需要有权限控制，对普通作者，需要限制访问后台的权限，比如说只能访问写作模块，对于管理员，则可以访问用户管理模块。一般来说，后台系统是一个复杂度不亚于前台的部分，这工作量一下就 double 了。现实中的应用，比如说新浪博客，可能还要复杂一些，至少分为三个部分。普通用户看到的博客页面，这部分在水面上，大家都能看到；博主撰写文章，管理自己文章的个人后台；而在新浪博客内部，一定还有一个审核文章，管理用户的内部后台，这工作量一下子就 triple 了。&lt;/p&gt;
&lt;p&gt;你可能会说，django admin 这种自动生成的后台系统它不香么？等你尝试着添加一些 JS/CSS 或者是更改一下权限系统就知道了。有人专程写文章批判过：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/251118463&quot;&gt;CRUD 代码生成的反模式典范：django admin&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;ez-toc-section&quot; id=&quot;%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98&quot;/&gt;性能问题&lt;span class=&quot;ez-toc-section-end&quot;/&gt;&lt;/h2&gt;
&lt;p&gt;等你把一切业务功能性的开发都搞定了，是时候考虑性能了。还是以博客系统为例，假如你有一个点赞的功能，那么根据学校里面教的数据库范式，这是一个典型的多对多关系啊，应该弄一个关联表，大概像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;users(n) &amp;lt;-&amp;gt; user_liked_articles &amp;lt;-&amp;gt; articles(n)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;问题来了，如果首页要展现一个用户最喜欢的文章列表怎么办？在首页上有一个三个表的 join 操作对性能的影响是可想而知的。这时候至少有两种思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;放弃正交化，在 article 表中增加一个 num_likes 字段，这样直接只查一个表就出来结果啦。缺点是要在代码中做好冗余信息的同步。&lt;/li&gt;
&lt;li&gt;增加一个缓存，可以缓存整个首页，也可以缓存这条 SQL 的查询结果。缺点是你又得多一个组件，而且查询结果是有延迟的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这已经是简单到不能再简单的一个小小性能问题了，真正的性能瓶颈可能需要通过使用 profile 工具或者是 wrk 这类的压测工具才能找出并修复。&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;ez-toc-section&quot; id=&quot;%E9%83%A8%E7%BD%B2&quot;/&gt;部署&lt;span class=&quot;ez-toc-section-end&quot;/&gt;&lt;/h2&gt;
&lt;p&gt;当你把性能问题也解决差不多的时候，终于到部署了。相对来说，部署还算中规中矩，没有多少幺蛾子。但是至少也要涉及到配置 nginx，申请 SSL 证书这些方面。&lt;/p&gt;
&lt;p&gt;在 2021 年的今天，肯定得上 docker 吧，那还得写 dockerfile。如果进一步，要用 k8s 的话，还得写 deployments。或许你还需要配置一下 Jenkins 或者其他 CI 工具……&lt;/p&gt;
&lt;p&gt;另外，静态文件怎么放也得考虑一下，就不说 CDN 或者优化图片大小了。至少开发时候你存放的目录得挪到 nginx 对应的目录吧？都是不疼不痒但是必须考虑的杂活儿。&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;ez-toc-section&quot; id=&quot;%E7%BB%93%E8%AF%AD&quot;/&gt;结语&lt;span class=&quot;ez-toc-section-end&quot;/&gt;&lt;/h2&gt;
&lt;p&gt;大概写到这里吧，还有好多问题没有涉及，包括但不限于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;搜索。总不能用 &lt;code&gt;select * like %keyword%&lt;/code&gt; 吧？如果上 ES 的话，ES 的查询语法大概也得了解吧，还得考虑到配置从 SQL 数据库到 ES 的同步问题。&lt;/li&gt;
&lt;li&gt;监控和日志。从两个方面来说，一是程序的性能监控，服务挂了得即使知道。另一方面是业务数据的监控，比如说 DAU 是多少。&lt;/li&gt;
&lt;li&gt;测试。代码的单元测试，集成测试等等。&lt;/li&gt;
&lt;li&gt;异步消息。比如说刚刚提到的点赞，被点赞的用户要不要收到一个通知呢？是否要发送邮件通知？邮件通知是不是该搞个消息队列异步操作？redis/kafka？又引入了一个新系统。&lt;/li&gt;
&lt;li&gt;反爬。前面提到的恶意攻击都是以破坏数据为目的的。爬虫稍微好点，只是想把你的数据（全部）搞走。或许你会愿意搜索引擎赶紧收录你的博客文章，但是肯定不希望一个竞争对手把你的所有用户信息全都爬走，然后挨个邀请过去。举两个在反爬上很简单的错误：
&lt;ol&gt;
&lt;li&gt;暴露数据库的物理 id。假如你的数据库直接用的自增 id，并且把这个 id 暴露在 API 中，那好了，我直接遍历就完了，所有用户信息拿到。&lt;/li&gt;
&lt;li&gt;没有频控。最起码也要针对 IP 做一个漏桶或者令牌桶的频控吧，不然爬虫流量消耗服务器资源都是很大的问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看到这里，希望你对一个系统的复杂和琐碎性能有一个大体的印象，就不要再问出&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;10 万块钱能不能做个淘宝？&lt;/li&gt;
&lt;li&gt;4 个月能不能山寨个抖音？&lt;/li&gt;
&lt;li&gt;不就是加个字段么，为啥还要排期？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种奇葩问题了。总体来说，以上没有什么技术难点。但是每一个点都需要做出取舍折中，特别琐碎。要把每一个小事都考虑好了，还挺复杂的，工作量也不小，而且也不一定是一个人能搞定的。以上所有的这些还都只是后端的问题，另一半前端的问题还完全没有考虑……&lt;/p&gt;
&lt;p&gt;对于前端，使用 React 还是 Vue。考虑到 SEO 的话，哪些页面还需要做静态化，这些都是需要考虑的众多问题之一……&lt;/p&gt;
&lt;p&gt;最后，或许你还是看不起一个简单的 CRUD 的 web 应用。什么大数据啊、深度学习啊、高并发才是应该掌握的知识嘛！但是，要知道互联网的根基或者说起点从来都是一个简单的后端+前端。你首先做出一个有用的东西，有了用户，慢慢才会产生大数据，才会有高并发的需求。&lt;/p&gt;
&lt;p&gt;本文像之前写的「爬虫思路」那篇文章一样，纯意识流瞎写，没有什么架构图，也没有任何参考文章。或许过几个月，我还会写一篇关于前端或者机器学习的文章吧。&lt;/p&gt;
&lt;div class=&quot;widget_text awac-wrapper&quot;&gt;&lt;div class=&quot;widget_text awac widget custom_html-2&quot;&gt;&lt;div class=&quot;textwidget custom-html-widget&quot;&gt;&lt;p&gt;&amp;#13;
多年大厂求职&amp;amp;面试官经验，简历付费优化，¥ 500/次。&amp;#13;
&lt;/p&gt;&amp;#13;
&lt;img alt=&quot;公众号“爬虫技术学习(spider-learn)”&quot; src=&quot;https://yifei.me/wp-content/uploads/2019/11/qrcode_for_gh_5c700d34e7f1_258.png&quot; data-lazy-src=&quot;https://yifei.me/wp-content/uploads/2019/11/qrcode_for_gh_5c700d34e7f1_258.png?is-pending-load=1&quot; srcset=&quot;data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7&quot; class=&quot; jetpack-lazy-image&quot;/&gt;&lt;noscript&gt;&lt;img alt=&quot;公众号“爬虫技术学习(spider-learn)”&quot; src=&quot;https://yifei.me/wp-content/uploads/2019/11/qrcode_for_gh_5c700d34e7f1_258.png&quot;/&gt;&lt;/noscript&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;

&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6e37f00dd3226f95d1aceed8cc96c77b</guid>
<title>超详细 Java 15 新功能介绍</title>
<link>https://toutiao.io/k/k6zujsr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.446&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4lfok2icUkibTKFUljxMwu3Z5GaOxz5yzbBjWdBJiaudPIvOYdChyHnje5kAwy8MGp6vWvXJSVqYesEeLZYPEnQfg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 15 在 2020 年 9 月发布，虽然不是长久支持版本，但是也带来了 14 个新功能，这些新功能中有不少是十分实用的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 15 官方下载：https://jdk.java.net/archive/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 15 官方文档：https://openjdk.java.net/projects/jdk/15/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 15 新功能：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;JEP&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;JEP 339&lt;/td&gt;&lt;td&gt;爱德华曲线算法（EdDSA）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 360&lt;/td&gt;&lt;td&gt;Sealed Classes（密封类）预览&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 371&lt;/td&gt;&lt;td&gt;Hidden Classes（隐藏类）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 372&lt;/td&gt;&lt;td&gt;移除 Nashorn JavaScript 引擎&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 373&lt;/td&gt;&lt;td&gt;重新实现 DatagramSocket APII&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 374&lt;/td&gt;&lt;td&gt;禁用和废弃偏向锁（Biased Locking）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 375&lt;/td&gt;&lt;td&gt;instanceof 类型匹配  (二次预览)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 377&lt;/td&gt;&lt;td&gt;ZGC: 可扩展低延迟垃圾收集器（正式发布）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 378&lt;/td&gt;&lt;td&gt;文本块&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 379&lt;/td&gt;&lt;td&gt;Shenandoah: 低停顿时间的垃圾收集器&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 381&lt;/td&gt;&lt;td&gt;删除 Solaris 和 SPARC 端口&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 383&lt;/td&gt;&lt;td&gt;外部内存访问 API（第二个孵化器）)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 384&lt;/td&gt;&lt;td&gt;Records (二次预览)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 385&lt;/td&gt;&lt;td&gt;废弃 RMI 激活机制&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JEP339 爱德华曲线算法（EdDSA）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 15 中增加了一个新的密码学算法，爱德华曲线算法（EdDSA）签名算法。它是由 Schnorr 算法发展而来，在 RFC8032 中被定义实现。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.nio.charset.StandardCharsets;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.security.InvalidKeyException;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.security.KeyPair;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.security.KeyPairGenerator;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.security.NoSuchAlgorithmException;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.security.Signature;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.security.SignatureException;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.Base64;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JEP339&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; NoSuchAlgorithmException, InvalidKeyException, SignatureException &lt;/span&gt;{&lt;br/&gt;        KeyPairGenerator kpg = KeyPairGenerator.getInstance(&lt;span&gt;&quot;Ed25519&quot;&lt;/span&gt;);&lt;br/&gt;        KeyPair kp = kpg.generateKeyPair();&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt;[] msg = &lt;span&gt;&quot;www.wdbyte.com&quot;&lt;/span&gt;.getBytes(StandardCharsets.UTF_8);&lt;br/&gt;        Signature sig = Signature.getInstance(&lt;span&gt;&quot;Ed25519&quot;&lt;/span&gt;);&lt;br/&gt;        sig.initSign(kp.getPrivate());&lt;br/&gt;        sig.update(msg);&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt;[] s = sig.sign();&lt;br/&gt;        System.out.println(Base64.getEncoder().encodeToString(s));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;VXlpxapU+LSWjVQ0QNJvdpUh6VI6PjSwOQ2pHu65bCfnLR13OyWKunlc9rc+7SMxCh2Mnqf7TmC/iOG8oimbAw==&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JEP360：Sealed Classes（密封类）预览&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，在 Java 中如果想让一个类不能被继承和修改，这时我们应该使用 &lt;code&gt;final&lt;/code&gt; 关键字对类进行修饰。不过这种要么可以继承，要么不能继承的机制不够灵活，有些时候我们可能想让某个类可以被某些类型继承，但是又不能随意继承，是做不到的。Java 15 尝试解决这个问题，引入了 &lt;code&gt;sealed&lt;/code&gt; 类，被 &lt;code&gt;sealed&lt;/code&gt; 修饰的类可以指定子类。这样这个类就只能被指定的类继承。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且 &lt;code&gt;sealed&lt;/code&gt; 修饰的类的机制具有传递性，它的子类必须使用指定的关键字进行修饰，且只能是 &lt;code&gt;final&lt;/code&gt;、&lt;code&gt;sealed&lt;/code&gt;、&lt;code&gt;non-sealed&lt;/code&gt;  三者之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例：犬类（Dog）只能被牧羊犬（Collie）和田园犬（TuGou）继承，使用 &lt;code&gt;sealed&lt;/code&gt; 关键字。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt;  sealed &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Dog&lt;/span&gt; &lt;span&gt;permits&lt;/span&gt; &lt;span&gt;Collie&lt;/span&gt;, &lt;span&gt;TuGou&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;牧羊犬（Collie）只能被边境牧羊犬（BorderCollie）继承。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 牧羊犬&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; www.wdbyte.com&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; sealed &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Collie&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Dog&lt;/span&gt; &lt;span&gt;permits&lt;/span&gt; &lt;span&gt;BorderCollie&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;边境牧羊犬（BorderCollie）不能被继承，使用 &lt;code&gt;final&lt;/code&gt; 关键字。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; *&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; www.wdbyte.com&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BorderCollie&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Collie&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;田园犬（ToGou）可以被任意继承，使用 &lt;code&gt;non-sealed&lt;/code&gt; 关键字。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; niulang&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; non-sealed &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TuGou&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Dog&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JEP371：Hidden Classes（隐藏类）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个特性让开发者可以引入一个无法被其他地方发现使用，且类的生命周期有限的类。这对运行时动态生成类的使用方式十分有利，可以减少内存占用，下面是一个使用示例。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JEP371Test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String &lt;span&gt;lookup&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;www.wdbyte.com&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把类 &lt;code&gt;JEP371Test&lt;/code&gt; 编译后的 Class 转换成 &lt;code&gt;Base64&lt;/code&gt;，然后使用 Java 15 新特性加载调用类中的 &lt;code&gt;lookup&lt;/code&gt; 方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.lang.invoke.MethodHandle;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.lang.invoke.MethodHandles;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.lang.invoke.MethodType;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.Base64;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; www.wdbyte.com&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JEP371&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String CLASS_INFO = &lt;span&gt;&quot;yv66vgAAADQAFAoAAgADBwAEDAAFAAYBABBqYXZhL2xhbmcvT2JqZWN0AQAGPGluaXQ+AQADKClWCAAIAQAOd3d3LndkYnl0ZS5jb20HAAoBABVjb20vd2RieXRlL0pFUDM3MVRlc3QBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEAF0xjb20vd2RieXRlL0pFUDM3MVRlc3Q7AQAGbG9va3VwAQAUKClMamF2YS9sYW5nL1N0cmluZzsBAApTb3VyY2VGaWxlAQAPSkVQMzcxVGVzdC5qYXZhACEACQACAAAAAAACAAEABQAGAAEACwAAAC8AAQABAAAABSq3AAGxAAAAAgAMAAAABgABAAAAAwANAAAADAABAAAABQAOAA8AAAAJABAAEQABAAsAAAAbAAEAAAAAAAMSB7AAAAABAAwAAAAGAAEAAAAEAAEAEgAAAAIAEw==&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt;[] classInBytes = Base64.getDecoder().decode(CLASS_INFO);&lt;br/&gt;        Class&amp;lt;?&amp;gt; proxy = MethodHandles.lookup()&lt;br/&gt;            .defineHiddenClass(classInBytes, &lt;span&gt;true&lt;/span&gt;, MethodHandles.Lookup.ClassOption.NESTMATE)&lt;br/&gt;            .lookupClass();&lt;br/&gt;&lt;br/&gt;        System.out.println(proxy.getName());&lt;br/&gt;        MethodHandle mh = MethodHandles.lookup().findStatic(proxy, &lt;span&gt;&quot;lookup&quot;&lt;/span&gt;, MethodType.methodType(String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;        String result = (String) mh.invokeExact();&lt;br/&gt;        System.out.println(result);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;com.wdbyte.JEP371Test/0x0000000800c01800&lt;br/&gt;www.wdbyte.com&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JEP372：移除 Nashorn JavaScript 引擎&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nashorn JavaScript 引擎在 Java 8 中被引入，在 Java 11 中被标记为废弃。由于 ECMAScript 语言发展很快，维护  Nashorn JavaScript 的成本过于高昂，在 Java 15 中被彻底删除。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;扩展阅读：Nashorn JavaScript Engine，Deprecate the Nashorn JavaScript Engine&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JEP373：重新实现 DatagramSocket API&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 13 中重新实现了旧的 Socket API，在介绍 Java 13 时还有一部分做了这方面的介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，Java 15 重新实现了遗留的 &lt;code&gt;DatagramSocket&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;扩展阅读：Java 13 新功能介绍&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JEP374：禁用和废弃偏向锁（Biased Locking）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在之前，JVM 在处理同步操作，如使用 &lt;code&gt;synchronized&lt;/code&gt; 同步时，有一套锁的升级机制，其中有一个锁机制就是偏向锁。然而通过目前的 Java 开发环境来看，使用这些被 &lt;code&gt;synchronized&lt;/code&gt; 同步的类的机会并不多，如开发者更喜欢使用 &lt;code&gt;HashMap&lt;/code&gt; 或者 &lt;code&gt;ArrayList&lt;/code&gt; 而非 &lt;code&gt;HashTable&lt;/code&gt; 和 &lt;code&gt;Vector&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使换个角度，当初使用偏向锁是为了提高性能，如今看来性能提升的程度和使用次数都不太有用。而偏向锁的引入增加了 JVM 的复杂性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以现在偏向锁被默认禁用，在不久的将来将会彻底删除，对于 Java 15，我们仍然可以使用&lt;code&gt;-XX:+UseBiasedLocking&lt;/code&gt;  启用偏向锁定，但它会提示 这是一个已弃用的 API。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JEP375：instanceof 类型匹配  (二次预览)&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;instanceof&lt;/code&gt; 类型匹配在 Java 14 中已经改进，这次仅仅再次预览，没有任何改动，用于接受更多的使用反馈。这个特性在 Java 16 中成为正式特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在之前，使用 &lt;code&gt;instanceof&lt;/code&gt; 进行类型判断之后，需要进行对象类型转换后才能使用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.ArrayList;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.List;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Java14BeaforInstanceof&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Object obj = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (obj &lt;span&gt;instanceof&lt;/span&gt; ArrayList) {&lt;br/&gt;            ArrayList list = (ArrayList)obj;&lt;br/&gt;            list.add(&lt;span&gt;&quot;www.wdbyte.com&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        System.out.println(obj);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在 Java 14 中，可以在判断类型时指定变量名称进行类型转换，方便了使用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.ArrayList;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Java14Instanceof&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Object obj = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (obj &lt;span&gt;instanceof&lt;/span&gt; ArrayList list) {&lt;br/&gt;            list.add(&lt;span&gt;&quot;www.wdbyte.com&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        System.out.println(obj);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在使用 &lt;code&gt;instanceof&lt;/code&gt; 判断类型成立后，会自动强制转换类型为指定类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;[www.wdbyte.com]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;扩展阅读：Java 14 新功能介绍&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JEP377：ZGC: 可扩展低延迟垃圾收集器（正式发布）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZGC 垃圾收集器在 Java 11 中被引入，但是因为收集器的复杂性，当初决定逐渐引入。然后不断的听取用户的反馈建议修复问题。而现在，已经很久没有收到用户的问题反馈了，ZGC 是时候投入正式使用阶段了。所以在 Java 15 中 ZGC 正式发布，可以使用下面的参数启用 ZGC。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; java -XX:+UseZGC className&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JEP378：文本块&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文本块在 Java 12 JEP 326 原始字符串文字 中引入，在 Java 13 JEP 355：文本块（预览） 中开始预览，在 Java 14 JEP 368：文本块（第二次预览），而现在，在 Java 15 ，文本块是正式的功能特性了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String content = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;br/&gt;        {&lt;br/&gt;            &quot;&lt;/span&gt;upperSummary&lt;span&gt;&quot;: null,\&lt;br/&gt;            &quot;&lt;/span&gt;sensitiveTypeList&lt;span&gt;&quot;: null,&lt;br/&gt;            &quot;&lt;/span&gt;gmtModified&lt;span&gt;&quot;: &quot;&lt;/span&gt;&lt;span&gt;2011&lt;/span&gt;-&lt;span&gt;08&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;\s10:&lt;span&gt;50&lt;/span&gt;:&lt;span&gt;09&lt;/span&gt;&lt;span&gt;&quot;,&lt;br/&gt;        }&lt;br/&gt;         &quot;&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;System.out.println(content);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;扩展阅读：Java 14 新功能介绍- JEP368 文本块&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JEP379：Shenandoah: 低停顿时间的垃圾收集器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Shenandoah 垃圾收集器在 Java 12 中开始引入，Java 15 中成为了正式功能的一部分，可以使用下面的参数启用 Shenandoah 垃圾收集器。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;java -XX:+UseShenandoahGC&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是 openJDK 15 中默认是没有 Shenandoah 收集器，想要使用此功能可以下载 AdoptOpenJDK。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;为什么 openJDK 中没有 Shenandoah 垃圾收集器？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Shenandoah 是一个高性能、低暂停时间的垃圾收集器，它是 Red Hat 主导的项目。当 Red Hat 第一次提议将 Shenandoah 贡献给 OpenJDK 时，Oracle 明确表示不想支持它，OpenJDK 作为一个免费软件，不想支持 Red Hat 的 Shenandoah 完全没有问题。&lt;/p&gt;&lt;p&gt;最后 Red Hat 选择和 Oracle 合作设计一个真正干净的可插拔垃圾收集器接口，允许任何人轻松选择垃圾收集器以包含在他们的构建中。最终 Shenandoah 进入了 JDK 12，但是没有构建进 OpenJDK。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JEP384：Records（二次预览）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Java 14 中引入了 Record 类，Java 15 中对 Record 进行了增强。使它可以支持密封类型、Record 注解以及相关的反射 API 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例：Record 支持密封（sealed）类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; www.wdbyte.com&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; sealed &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;DataBase&lt;/span&gt; &lt;span&gt;permits&lt;/span&gt; &lt;span&gt;DataBaseSelect&lt;/span&gt;, &lt;span&gt;DataBaseUpdate&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; record &lt;span&gt;DataBaseSelect&lt;/span&gt;&lt;span&gt;(@Deprecated String table, String sql)&lt;/span&gt; implements DataBase &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; record &lt;span&gt;DataBaseUpdate&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; implements DataBase &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;java.lang.Class&lt;/code&gt; 增加了两个公共方法用于获取 Record 类信息：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;RecordComponent[] getRecordComponents()&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;boolean isRecord()&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其他更新&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;JEP 381：删除 Solaris 和 SPARC 端口&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 14 JEP 362弃用了 Solaris/SPARC、Solaris/x64 和 Linux/SPARC 端口，现在它在 Java 15 中被正式删除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;JEP 383：外部内存访问 API（第二个孵化器）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;JEP 385：废弃 RMI 激活机制&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只是废弃 RMI 激活机制，不影响 RMI 其他功能。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;https://openjdk.java.net/projects/jdk/15/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://docs.oracle.com/en/java/javase/14/docs/specs/rmi/activation.html&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://mkyong.com/java/what-is-new-in-java-15/&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>