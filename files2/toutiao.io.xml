<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>c316a4c810aa0dcfaf812443d529f43a</guid>
<title>volatile 关键字的原理和要避免的误区</title>
<link>https://toutiao.io/k/eu5utzp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    最近做code review看到有的同学在承载缓存数据的变量里加了volatile关键字。想起来之前项目中也看到有的同学习惯在从配置中心获取的配置数据的变量上加volatile。今天就来探讨一下这个volatile加的有没有必要。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;volatile关键字的作用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1&amp;gt;防止指令重排&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2&amp;gt;禁用工作内存缓冲区，直接使用主内存。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;经典使用场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;场景1&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;public static &lt;/span&gt;Singleton &lt;span&gt;getInstance&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一次&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;检查     &lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;if &lt;/span&gt;(instance == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;synchronized &lt;/span&gt;(Singleton.&lt;span&gt;class&lt;/span&gt;) {    &lt;span&gt;//1     &lt;br/&gt;&lt;/span&gt;&lt;span&gt;            //&lt;/span&gt;&lt;span&gt;第二次&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;检查       &lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;if &lt;/span&gt;(instance == &lt;span&gt;null&lt;/span&gt;) {          &lt;span&gt;//2  &lt;br/&gt;&lt;/span&gt;&lt;span&gt;                &lt;/span&gt;instance = &lt;span&gt;new &lt;/span&gt;Singleton()&lt;span&gt;;&lt;/span&gt;&lt;span&gt;//3  &lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;}&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return &lt;/span&gt;instance&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;/pre&gt;&lt;section&gt;&lt;span&gt;如果不用volatile，则因为内存模型允许所谓的“无序写入”，可能导致失败&lt;/span&gt;。某个线程可能会获得一个未完全初始化的实例。&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;场景2&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;private volatile int &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读&lt;/span&gt;&lt;span&gt;操作，没有&lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;，提高性能&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public int &lt;/span&gt;&lt;span&gt;getValue&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;return &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写操作，必&lt;/span&gt;&lt;span&gt;须&lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;。因&lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt;x++&lt;/span&gt;&lt;span&gt;不是原子操作&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public synchronized int &lt;/span&gt;&lt;span&gt;increment&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;return &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;++&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这段代码，可实现一个线程间安全的计数器。因为加了valatile关键字。每次线程都能取到最新值做加减。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;要避免的误区&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;在代码评审的时候看到volatile被滥用的情况。说说我个人的看法：很少变化，对时间不是特别敏感的情况下不建议用volatile关键字。&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;举个例子：从公司的配置中心取到一个配置数据。不建议用volatile。&lt;/section&gt;&lt;p&gt;一般来说配置中心的架构是下面这个样子&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6354359925788498&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicNcqZhVe4vd5J2Jf0h4jFSfeTE1z4e65EWhF5nK7xeQlIUDo8CqTJlGqVibQ78ziah43dzdmWssD6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1078&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;一条数据从用户变更到集中存储的配置中心，配置中心下发到真正使用的机器上，之前公司是要经过90s(客户端90s为周期定时去配置中心取最新数据)。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;加了volatile关键字在这种场景只是能更快的看到这个最新值而已。下面我们来测试下这个【更快】有多久。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;span&gt;public class &lt;/span&gt;VolatileTest {&lt;br/&gt;    &lt;span&gt;private boolean &lt;/span&gt;&lt;span&gt;endRun &lt;/span&gt;= &lt;span&gt;false;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;@Test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;noVolatile&lt;/span&gt;() &lt;span&gt;throws &lt;/span&gt;Exception {&lt;br/&gt;        Runnable r1 = &lt;span&gt;new &lt;/span&gt;Runnable() {&lt;br/&gt;            &lt;span&gt;public void &lt;/span&gt;&lt;span&gt;run&lt;/span&gt;() {&lt;br/&gt;                &lt;span&gt;int &lt;/span&gt;i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;                while &lt;/span&gt;(!&lt;span&gt;endRun&lt;/span&gt;) {&lt;br/&gt;                    System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;I am still running&quot; &lt;/span&gt;+ i++)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;                &lt;/span&gt;}&lt;br/&gt;            }&lt;br/&gt;        }&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;Runnable r2 = &lt;span&gt;new &lt;/span&gt;Runnable() {&lt;br/&gt;            &lt;span&gt;public void &lt;/span&gt;&lt;span&gt;run&lt;/span&gt;() {&lt;br/&gt;                &lt;span&gt;endRun &lt;/span&gt;= &lt;span&gt;true;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;}&lt;br/&gt;        }&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        new &lt;/span&gt;Thread(r1).start()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        new &lt;/span&gt;Thread(r2).start()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;Thread.&lt;span&gt;sleep&lt;/span&gt;(&lt;span&gt;9000&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;end run&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;section&gt;这个代码里，在第一个线程使用endRun这个变量。第二个线程去改变endRun这个变量的值。一旦第一个线程看到了第二个线程的值的变化，就会马上停止循环。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;运行结果如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4942528735632184&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicNcqZhVe4vd5J2Jf0h4jFSPXLsLhzx9xMulY93Nrc0LKOlcPcJhtkSvMQzkHbzHESqKos95DfMpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;261&quot;/&gt;&lt;/p&gt;&lt;section&gt;说明经过了两个循环的时间，线程就读到了另外一个线程变化的值。对照下面的时间延迟表，我们来计算下：&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7601572739187418&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9RTU7bAofugt8DV5hAXftYHvgaP1abOyv9GdeBicEJTAwvpoTEm4FULj9GmicibBKc0vsLM8ykF9HhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;763&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;平均执行一行简单代码要执行5个指令。如上执行一个指令需要1ns。每次循环执行2行代码，从运行结果来看共执行了2次。共5*1*2*2=20ns。实际数据应该不是如此，而且是变化的。但是应该都是ns级别的。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;相比较90s的可见性延迟，ns级别可以忽略不计。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;再看看为了早ns级看到结果，所花费的开销：volatile关键字本质是让L1缓存、L2缓存这种cpu缓存失效了，直接主存访问。如果要访问的字段在L1缓存里，从配置中心取的数据1天变化一次。以字段放在L2缓存为例。加了volatile关键字，访问时间要从4ns上升到100ns，如果这个变量每个请求都要访问，每秒QPS是1000。则1天为了取这个数据将多花1*24*3600*1000*(100-4)ns约等于8300ms。&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;相比获得的收益来讲，代价要大出好几个数量级。但是本身的时间开销本来就很小，坦白说一般的系统一天多花个8.3s也是可以接受的。但是这样的变量多了，也是个不小的负担。而且这个负担会随着系统压力增加而加重。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;定时将缓存加载到内存原理相同，不建议使用volatile。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;其他引申思考&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;上面结论是在对时间敏感度不高的情况下不建议用volatile，但是对于一般的系统，用了对系统的影响也还好。最怕的事情是做了一个实际上意义并不大，却引入系统风险的优化。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;上周我review同学的代码，这个同学是个有技术追求的同学。喜欢写代码的时候进行些小优化。这是个好习惯。但是对review代码的人要求很高。因为普通的业务逻辑影响的就是那么一块范围内的。但是优化却可能会影响其他部分。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;这次他在好几处，把原来打印更新缓存的日志里，原来只打印：【更新缓存成功】的地方加了个【更新缓存成功，影响数据XX条】。这个XX取的是guava Cache的.size()方法。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;这段代码我仔细看了guava cache的初始化方法，这个初始化方法非常复杂，里面用了几处断言(不能为空)。这个初始化方法没有统一的try catch捕获异常，一旦有地方抛出异常。有可能会没有完全实例化。我把自己的这个想法提了出来。他通过代码走查梳理向我证明了，确实不会有空指针的情况。我同意他是对的。但是这整个过程说明了我对这件事情的谨慎。如果我们上线了一个功能，功能有问题，新功能上线会有灰度、观察期慢慢上量的过程，影响不会多大。但是改了其他部分，特别是感觉绝对不会有问题的部分。如果出现问题了，自己团队的信任分一下子就会降下来了。以后再进行变更，需要反复证明影响，非常被动。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6ab82a662f2cb596f7412260281c5ee4</guid>
<title>浅析构建 SQL-to-SQL 的翻译器</title>
<link>https://toutiao.io/k/vipitc2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;em&gt;如果你爱一个人，就让他写SQL，因为那是天堂。&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;如果你恨一个人，就让他写SQL，因为那是地狱。&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;天堂，是因为他如此简单，又功能强大，可以极大简化你的程序。&lt;/p&gt;&lt;p&gt;地狱，是因为他如此纷繁，复杂，还有各种方言标准，而且不通用，当你试图切换数据库产品的时候，什么叫生不如死 ......&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那我们就不能构建一个统一的数据库语言么？这个真不能，不是技术上不能，而是利益趋势，大家坚守自己的方言堡垒，而且越建越高。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ORM或许是解决这个问题的一个途径，正如其名，既然是对象关系映射，未免就会是一套机械、呆板的程序，我们只能将关系和实体映射出来，所以，这并非是解决问题的根本途径，但不能否认它确实是最受欢迎，使用最广泛，代价最小的方案，没有之一。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那我们是不是能从SQL语言翻译的角度来解决这个问题呢？即在将SQL抛给数据库执行之前，进行一次翻译工作？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们可以对SQL进行语法分析，形成一颗AST（抽象语法树），然后遍历解析&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6798917944093779&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag8WFes5ptLubrlibNBgHnACbsatGAQibib0kelGGZJR1qMDrdibaPoQrGPSOiaxUfdKeKZs6zXVIiagLeyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1109&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们在遍历语法树的时候，就进行一次翻译转换，形成其他方言的SQL。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6798917944093779&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag8WFes5ptLubrlibNBgHnACbkR13ic13ibXMpZft9icXkuViczZwsib0QDfhHoUQUprjSWwPmSiaxLjhXT7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1109&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个方案也许不尽善尽美，但是至少解决了一个类似“同声传译”的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对上述模型进一步演化，在AST层面进行双向转化，那这个实现是不是就看起来非常优雅了？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6798917944093779&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag8WFes5ptLubrlibNBgHnACbeYVCia2lzjOKxA8YXygVrtibTebuegPcolYLapkRmTl8JgIIibtibgibmaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1109&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们已经定制了一条看似合理的Roadmap，那么如何将其实现落地呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下表，是我对可完成上述任务的框架进行的一些总结&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.46796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag8WFes5ptLubrlibNBgHnACb80WUNrpoR2sFgPucjDG5Ww7z71aQMQyDiaUmgNfRVbjAticJdZqRMXdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;个人是十分推崇Calcite的，因为其本身更像是一个没有物理引擎的数据库引擎，这可能听起来有点滑稽，但是确实，他可以很好的解析SQL，并生成执行计划，如果你想，也可以针对其进行你希望的优化，这就让我们的控制力大大加强了，至少在数据库之上，就可以“为所欲为”了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Durid提供的方言包，比较多，上手比较容易（文末附录里，贴出了一个查询的AST，结构还是挺清晰的），不过如果想达到AST层面的转换，对整套API需要进行一定的手术才行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Antlr 可以说是非常强大的，他是单纯的语法解析工具，但是其语法文件比起javacc来，何止是平易近人，简直就是平易近人... 而且，shardingsphere，presto都是基于其开发的。在代码仓库里，也有很多线程的语法文件，可以使用，不过要达到上述目的，也需要走很长的路。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;好了，今天就先扯到这，感谢大家的阅读，如果对你有些帮助，那将是我莫大的荣幸，也期待你能关注我，和我交流。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;附录：以durid为例，下图展示了一条查询语句的AST&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.44453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag8WFes5ptLubrlibNBgHnACbPm6uzoIGMqVFXia9ib5nwg7viaWI1RTT1lPPg0kPT4T5GOXjCWZv7ehqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关注 【&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;麒思妙想&lt;/span&gt;&lt;span&gt;】解锁更多硬核。&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;历史文章导读&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果文章对您有那么一点点帮助，我将倍感荣幸&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;欢迎  &lt;span&gt;&lt;strong&gt;关注、在看、点赞、转发 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8uJ0ic6nAag8EItgzqIEhe3GbK3ibibrSC3kGNLaCYoEXEEEV8vatdHqibkazrs7oLJERAG1cldW9pbVmcTKvXL3fA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fa820b31fcae6d2b121d38fdad76e437</guid>
<title>性能优化：线程资源回收</title>
<link>https://toutiao.io/k/wllqesw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;src-views-article-detail-main-module__content--2qOBd markdown-body&quot;&gt;&lt;h2&gt;一、问题&lt;/h2&gt;
&lt;p&gt;模型服务平台的排序请求出现较多超时情况，且不定时伴随空指针异常。&lt;/p&gt;
&lt;h2&gt;二、问题发生前后的改动&lt;/h2&gt;
&lt;p&gt;召回引擎扩大了召回量，导致排序请求的item数量增加了。&lt;/p&gt;
&lt;h2&gt;三、出问题的模型&lt;/h2&gt;
&lt;p&gt;基于XGBoost预测的全排序模型。&lt;/p&gt;
&lt;h2&gt;四、项目介绍&lt;/h2&gt;
&lt;p&gt;web-rec-model：模型服务平台。用于管理排序模型：XGBoost、TensorFlow、pmml…召回模型：item2item，key2item，vec2item…等模型的上下线、测试模型一致性、模型服务等。&lt;/p&gt;
&lt;h2&gt;五、一次排序请求流程&lt;/h2&gt;
&lt;p&gt;1、如下图所示，一次排序请求流程包含：特征获取、向量获取、数据处理及预测。以上提到的三个步骤均采用多线程并行处理，均以子任务形式执行。每个阶段中间夹杂这数据处理的流程，由主线程进行处理，且每个阶段的执行任务均为超时返回，主线程等待子线程任务时，也采用超时等待的策略。（同事实现的一个树形任务执行，超时等待的线程框架）&lt;/p&gt;
&lt;p&gt;2、特征数据闭环：该步骤为异步执行，将排序计算使用到的特征及分数，模型版本等信息记录。后续作为模型的训练样本，达到特征闭环。&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/2019036&quot; alt=&quot;模型请求流程.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、一次排序请求中，&lt;em&gt;&lt;strong&gt;特征获取及向量获取&lt;/strong&gt;&lt;/em&gt;为网络IO（IO密集型任务），超时可直接响应中断，线程可快速返回。&lt;em&gt;&lt;strong&gt;数据处理及模型&lt;/strong&gt;&lt;/em&gt;为计算步骤（CPU密集型任务）。&lt;/p&gt;
&lt;p&gt;4、当前请求耗时情况：特征与向量的获取阶段耗时均为5-8ms，数据处理及模型预测阶段耗时平均在10ms左右。&lt;/p&gt;
&lt;h2&gt;六、问题发生现象&lt;/h2&gt;
&lt;p&gt;1、首先是调用方：推荐策略平台，监控报警排序请求的超时数量变多（调用方超时时间为300ms），且从监控上看发现排序服务的耗时明显变长：50ms+。正常高峰期的期望值为50ms以下。&lt;/p&gt;
&lt;p&gt;2、其次排序服务告警出现大量超时错误。&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/2019007&quot; alt=&quot;超时错误.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、第三根据错误信息定位到该错误信息来自于&lt;strong&gt;数据处理及模型预测&lt;/strong&gt;阶段。&lt;/p&gt;
&lt;p&gt;4、除了超时变多以外，服务中会出现偶发性的空指针异常。&lt;/p&gt;
&lt;h2&gt;七、问题排查&lt;/h2&gt;
&lt;p&gt;1、首先解决空指针这类低级错误。&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/2019061&quot; alt=&quot;空指针错误.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、根据错误提示找到对应的代码，此处就不粘贴代码了，做一个简单的代码解释。代码逻辑为：从Map&amp;lt;String,Object&amp;gt;中根据特征key获取特征值进行计算。&lt;/p&gt;
&lt;p&gt;3、疑惑点出现，首先该Map&amp;lt;String,Object&amp;gt;用于存放特征及向量键值对，且key均做了空值计算兼容。特征或者向量在查询到空值时，会在Map&amp;lt;String,Object&amp;gt;中放入一个对应的默认值。经过反复的代码确认，报错信息对应的代码不可能出现漏放默认值的情况。&lt;/p&gt;
&lt;p&gt;4、借助Arthas的watch命令，监控空指针异常的入参。方便后面做模拟请求还原现场。&lt;/p&gt;
&lt;p&gt;5、根据报错时的信息进行模拟请求。尝试N次，且使用不同的报错数据进行尝试，均未重现事故。&lt;/p&gt;
&lt;p&gt;6、此时怀疑是多线程并发进行&lt;strong&gt;数据处理及预测&lt;/strong&gt;时，发生对Map&amp;lt;String,Object&amp;gt;进行修改的动作，导致部分键值对丢失。&lt;/p&gt;
&lt;p&gt;7、反复检查代码，确定&lt;strong&gt;数据处理及预测&lt;/strong&gt;均为只读动作，不会对Map&amp;lt;String,Object&amp;gt;进行任何键值对的删改。&lt;/p&gt;
&lt;p&gt;8、线索中断，排查一度搁置。&lt;/p&gt;
&lt;h2&gt;八、豁然开朗&lt;/h2&gt;
&lt;p&gt;1、借用Arthas进行报错观察：使用watch命令，依靠-e参数（指定报错触发打印）以及-x n 参数（打印方法入参及返回值数据层数）&lt;/p&gt;
&lt;p&gt;2、根据观察，发现Map&amp;lt;String,Object&amp;gt;中丢失的均为&lt;strong&gt;向量&lt;/strong&gt;键值对。&lt;/p&gt;
&lt;p&gt;3、找到问题：在排序请求流程图中，在主线程进行&lt;strong&gt;分数归一化&lt;/strong&gt;时，会fork子线程异步做特征数据进行压缩写入kafka。由于Map&amp;lt;String,Object&amp;gt;中存在大量的向量数据，导致保存数据过冗余的情况。此处的做法是先去除所有的&lt;strong&gt;向量&lt;/strong&gt;数据，再进行保存。&lt;/p&gt;
&lt;p&gt;4、但是该动作是发生在&lt;strong&gt;数据处理及模型预测&lt;/strong&gt;后的，为何还会因为Map&amp;lt;String,Object&amp;gt;中删除键值对导致空指针异常呢。&lt;/p&gt;
&lt;p&gt;5、此时怀疑是&lt;strong&gt;数据处理及模型预测&lt;/strong&gt;阶段，多线程任务还没完成时，主线程已经等候超时返回了。&lt;/p&gt;
&lt;h2&gt;九、验证想法&lt;/h2&gt;
&lt;p&gt;1、还是观察超时日志。&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/2019068&quot; alt=&quot;超时请求.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/2019094&quot; alt=&quot;空指针数据.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、发现请求已经返回后，才出现空指针异常。那基本就可以验证以上的想法了。&lt;/p&gt;
&lt;h2&gt;十、问题解决&lt;/h2&gt;
&lt;p&gt;1、翻看使用的多线程框架（同事实现），主线程超时等待子线程任务。主线程超时返回后，没有通知子线程任务取消。所以才发生请求已返回，特征数据异步落地后，偶发性出现晚到的空指针异常的情况。如下图，主线程超时返回后，只取消主线程任务。&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/2019819&quot; alt=&quot;主线程超时等待.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、解决思路：主线程超时返回后，中断子任务（取消子任务）。由于java的中断机制为软中断，一般是通过中断标志位进行线程中断协作的。当然IO或者sleep的中断由系统帮我们做了中断可以快速返回。对于CPU密集型的任务，是需要使用者在&lt;strong&gt;合适&lt;/strong&gt;的计算点上做标志位判断，确定是否已中断结束任务。以这种协作的方式达到中断。（此处可能有部分理解不当）&lt;/p&gt;
&lt;p&gt;3、修改多线程框架，在主线程超时返回后，修改子线程中断标志位。&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/2019106&quot; alt=&quot;取消子线程.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、在计算流程中加入线程中断检查，如果被中断则提前结束计算。&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/2019131&quot; alt=&quot;响应中断.png&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;十一、效果检查&lt;/h2&gt;
&lt;p&gt;1、修改发版后，空指针没再出现。（其实该空指针是不影响排序结果，因为结果已经是错的，该异常只是附带的虫子而已）&lt;br/&gt;
2、超时请求减少，高峰期的超时数据减少三分之一，50ms+的排序请求有明显减少。&lt;/p&gt;
&lt;h2&gt;十二、复盘&lt;/h2&gt;
&lt;p&gt;1、主线程等待子任务的场景下，如果主线程超时返回了。需通知子线程结束执行的任务。首先，主线程返回了，表示子任务已被丢弃。继续执行都是在做无用的计算，占用计算机资源。也不是说占着茅坑不拉屎，而是拉了没人要。应该尽量减少服务器资源用在没必要的消耗上。&lt;/p&gt;
&lt;p&gt;2、该服务在&lt;strong&gt;数据处理及预测&lt;/strong&gt;阶段使用的线程池队列为SynchronousQueue，如果不了解SynchronousQueue的话可以简单理解为一个0长度的队列。任务进池子时必须要有线程进行对接。与常规的BlockingQueue不同的是，任务在池子中不会堆积，对于任务的快速响应比较友好。但是也因为如果没有空闲的线程，则会不停创建线程直到&lt;strong&gt;最高线程数&lt;/strong&gt;限制而触发丢弃策略。在该项目问题中，由于部分子任务在主线程返回后仍然在执行。新的请求进来后，会出现没有空闲线程的情况，导致池子创建新线程接任务。对于CPU密集型任务来说，过多的线程数对服务来说是另一种负担，毕竟线程切换的代价还是比较大的。这就套入死循环了。（个人理解，如表述有误，还望指正）&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bbcd57c58c301d89ce3b4195d32f6d39</guid>
<title>Spring 早期类型转换，基于 PropertyEditor 实现</title>
<link>https://toutiao.io/k/cu2qab9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4255555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/crPesQVeyKIfkw5sPANc1t7iaBFqSrFtNRsV7cWIFqicseupFlGTEe4J72pba1djskK5we4GAC7gGqGg96oiaRXcA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;点击上方“&lt;/span&gt;&lt;span&gt;BAT的乌托邦&lt;/span&gt;&lt;span&gt;”，选择“&lt;/span&gt;&lt;span&gt;设为星标&lt;/span&gt;&lt;span&gt;”&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;后台回复“&lt;/span&gt;&lt;span&gt;专栏&lt;/span&gt;&lt;span&gt;”，开启&lt;strong mpa-from-tpl=&quot;t&quot;&gt;专栏模式&lt;/strong&gt;学习&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;✍前言&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，我是YourBatman。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring早在1.0（2004年发布，2003年孵化中）的时候，就有了类型转换功能模块。此模块存在的必要性不必多说，相信每个同学都可理解。最初，Spring做类型转换器是基于Java标准的&lt;code&gt;java.beans.PropertyEditor&lt;/code&gt;这个API去扩展实现的，直到Spring 3.0后才得以出现更好替代方案（Spring 3.0发布于2009 年12月）。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;提示：文章末尾附有Spring主要版本的发布时间和以及主要特性，感兴趣者可文末查看&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽说Spring自3.0就提出了更为灵活、优秀的类型转换接口/服务，但是早期基于&lt;code&gt;PropertyEditor&lt;/code&gt;实现的转换器并未废弃且还在发挥余热中，因此本文就针对其早期类型转换实现做出专文讲解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;版本约定&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Spring Framework：5.3.1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Boot：2.4.0&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;说明：版本均于2020-11发布，且版本号均不带有&lt;code&gt;.RELEASE&lt;/code&gt;后缀，这和之前是不一样的。具体原因请参考：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0MTUwOTgyOQ==&amp;amp;mid=2247490521&amp;amp;idx=1&amp;amp;sn=7eaa0ace090023715926cd02e0bfc188&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Spring改变版本号命名规则：此举对非英语国家很友好&lt;/a&gt;&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;✍正文&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若你用当下的眼光去看Spring基于&lt;code&gt;PropertyEditor&lt;/code&gt;的类型转换实现，会发现这么搞是存在一些设计缺陷的。当然并不能这么去看，毕竟现在都2020年了，那会才哪跟哪呢。既然Spring里的&lt;code&gt;PropertyEditor&lt;/code&gt;现如今依然健在，那咱就会会它呗。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;PropertyEditor是什么？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;PropertyEditor&lt;/code&gt;位于java.beans包中，要知道这个包里面的类都是设计为Java GUI程序（AWT）服务的，所以你看官方javadoc对&lt;code&gt;PropertyEditor&lt;/code&gt;的介绍也无出其右：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;A PropertyEditor &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;provides&lt;/span&gt; &lt;span&gt;support&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;GUIs&lt;/span&gt; &lt;span&gt;that&lt;/span&gt; &lt;span&gt;want&lt;/span&gt; &lt;span&gt;to&lt;/span&gt; &lt;span&gt;allow&lt;/span&gt; &lt;span&gt;users&lt;/span&gt; &lt;span&gt;to&lt;/span&gt; &lt;span&gt;edit&lt;/span&gt; &lt;span&gt;a&lt;/span&gt; &lt;span&gt;property&lt;/span&gt; &lt;span&gt;value&lt;/span&gt; &lt;span&gt;of&lt;/span&gt; &lt;span&gt;a&lt;/span&gt; &lt;span&gt;given&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;.&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为GUI程序提供支持，允许你对给定的value进行编辑，作用类似于一个转换器：GUI上你可以输入、编辑某个属性然后经过它转换成合适的类型。&lt;img data-ratio=&quot;0.5895833333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKIfkw5sPANc1t7iaBFqSrFtNrlNItG9ytlqRl8EvLpgo3JWWL6OYIA7mOQMuZDdCS6iaYNAxD6PTfQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;480&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此接口提供的方法挺多的，和本文类型转换有关的最多只有4个：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;void setValue(Object value)&lt;/code&gt;：设置属性值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Object getValue()&lt;/code&gt;：获取属性值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;String getAsText()&lt;/code&gt;：输出。把属性值转换成String输出&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;void setAsText(String text)&lt;/code&gt;：输入。将String转换为属性值类型输入&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK对PropertyEditor接口提供了一个默认实现&lt;code&gt;java.beans.PropertyEditorSupport&lt;/code&gt;，因此我们若需扩展此接口，仅需继承此类，根据需要复写&lt;code&gt;getAsText/setAsText&lt;/code&gt;这两个方法即可，Spring无一例外都是这么做的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PropertyEditor作为一个JDK原生接口，内置了一些基本实现来服务于GUI程序，如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;BooleanEditor&lt;/code&gt;：将true/false字符串转换为Boolean类型&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;IntegerEditor&lt;/code&gt;：将字符串转换为Integer类型&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;同类别的还有LongEditor、FloatEditor...&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK内置的实现比较少（如上），功能简陋，但对于服务GUI程序来说已经够用，毕竟界面输入的只可能是字符串，并且还均是基础类型。但这对于复杂的Spring环境、以及富文本的web环境来说就不够用了，所以Spring在此基础上有所扩展，因此才有了本文来讨论。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;注意：PropertyEditorSupport线程不安全&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;PropertyEditor&lt;/code&gt;实现的是双向类型转换：String和Object互转。调用&lt;code&gt;setValue()&lt;/code&gt;方法后，需要先“缓存”起来后续才能够使用（输出）。&lt;code&gt;PropertyEditorSupport&lt;/code&gt;为此提供了一个成员属性来做：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;PropertyEditorSupport：&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 调用setValue()方法对此属性赋值   getValue()方法取值&lt;/span&gt;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; Object value;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么一来&lt;code&gt;PropertyEditorSupport&lt;/code&gt;就是有状态的了，因此是线程不安全的。在使用过程中需要特别注意，避免出现并发风险。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;说明：Support类里还看到属性监听器&lt;code&gt;PropertyChangeListener&lt;/code&gt;，因它属于GUI程序使用的组件，与我们无关，所以后续丝毫不会提及哦&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring内置的&lt;strong&gt;「所有扩展」&lt;/strong&gt;均是基于PropertyEditorSupport来实现的，因此也&lt;strong&gt;「都是」&lt;/strong&gt;线程不安全的哦~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Spring为何基于它扩展？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方的javadoc都说得很清楚：PropertyEditor设计是为GUI程序服务的，那么Spring为何看上它了呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;试想一下：那会的Spring只能支持xml方式配置，而XML属于文本类型配置，因此在给某个属性设定值的时候，书写上去的**100%**是个字符串，但是此属性对应的类型却不一定是字符串，可能是任意类型。你思考下，这种场景是不是跟GUI程序（AWT）一毛一样：输入字符串，对应任意类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了实现这种需求，在&lt;code&gt;PropertyEditorSupport&lt;/code&gt;的基础上只需要复写&lt;code&gt;setAsText&lt;/code&gt;和&lt;code&gt;getAsText&lt;/code&gt;这两个方法就行，然后Spring就这么干了。我&lt;code&gt;个人yy&lt;/code&gt;一下，当初Spring选择这么干而没自己另起炉灶的原因可能有这么几个：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;本着不重复发明轮子的原则，有得用就直接用呗，况且是100%满足要求的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;示好Java EE技术。毕竟那会Spring地位还并不稳，有大腿就先榜上&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2003年左右，Java GUI程序还并未退出历史舞台，Spring为了通用性就选择基于它扩展喽&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;说明：那会的通用性可能和现在通用性含义上是不一样的，需要稍作区别&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Spring内建扩展实现有哪些？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring为了扩展自身功能，提高配置灵活性，扩展出了非常非常多的&lt;code&gt;PropertyEditor&lt;/code&gt;实现，共计40余个，部分截图如下：&lt;img data-ratio=&quot;0.7818181818181819&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKIfkw5sPANc1t7iaBFqSrFtNtqsvsECk6JcEH6WpE1loMaGcUuicbC53mzosJslBJGvric0ricjYhICiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;770&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;PropertyEditor&lt;/th&gt;&lt;th&gt;功能&lt;/th&gt;&lt;th&gt;举例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;ZoneIdEditor&lt;/td&gt;&lt;td&gt;转为java.time.ZoneId&lt;/td&gt;&lt;td&gt;Asia/Shanghai&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;URLEditor&lt;/td&gt;&lt;td&gt;转为URL，支持传统方式&lt;code&gt;file:,http:&lt;/code&gt;，也支持Spring风格：&lt;code&gt;classpath:,context上下文相对路径&lt;/code&gt;等等&lt;/td&gt;&lt;td&gt;http://www.baidu.com&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;StringTrimmerEditor&lt;/td&gt;&lt;td&gt;trim()字符串，也可删除指定字符char&lt;/td&gt;&lt;td&gt;任意字符串&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;StringArrayPropertyEditor&lt;/td&gt;&lt;td&gt;转为字符串数组&lt;/td&gt;&lt;td&gt;A,B,C&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PropertiesEditor&lt;/td&gt;&lt;td&gt;转为Properties&lt;/td&gt;&lt;td&gt;name = YourBatman&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PatternEditor&lt;/td&gt;&lt;td&gt;转为Pattern&lt;/td&gt;&lt;td&gt;(\D*)(\d+)(.*)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PathEditor&lt;/td&gt;&lt;td&gt;转为java.nio.file.Path。支持传统URL和Spring风格的url&lt;/td&gt;&lt;td&gt;classpath:xxx&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ClassEditor&lt;/td&gt;&lt;td&gt;转为Class&lt;/td&gt;&lt;td&gt;全类名&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CustomBooleanEditor&lt;/td&gt;&lt;td&gt;转为Boolean&lt;/td&gt;&lt;td&gt;见示例&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CharsetEditor&lt;/td&gt;&lt;td&gt;转为Charset&lt;/td&gt;&lt;td&gt;见示例&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CustomDateEditor&lt;/td&gt;&lt;td&gt;转为java.util.Date&lt;/td&gt;&lt;td&gt;见示例&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring把实现基本(大多数)都放在&lt;code&gt;org.springframework.beans.propertyeditors&lt;/code&gt;包下，接下来我挑选几个代表性API举例说明。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;标准实现示例&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    PropertyEditor editor = &lt;span&gt;new&lt;/span&gt; CustomBooleanEditor(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 这些都是true，不区分大小写&lt;/span&gt;&lt;br/&gt;    editor.setAsText(&lt;span&gt;&quot;trUe&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(editor.getAsText());&lt;br/&gt;    editor.setAsText(&lt;span&gt;&quot;on&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(editor.getAsText());&lt;br/&gt;    editor.setAsText(&lt;span&gt;&quot;yes&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(editor.getAsText());&lt;br/&gt;    editor.setAsText(&lt;span&gt;&quot;1&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(editor.getAsText());&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 这些都是false（注意：null并不会输出为false，而是输出空串）&lt;/span&gt;&lt;br/&gt;    editor.setAsText(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;    System.out.println(editor.getAsText());&lt;br/&gt;    editor.setAsText(&lt;span&gt;&quot;fAlse&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(editor.getAsText());&lt;br/&gt;    editor.setAsText(&lt;span&gt;&quot;off&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(editor.getAsText());&lt;br/&gt;    editor.setAsText(&lt;span&gt;&quot;no&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(editor.getAsText());&lt;br/&gt;    editor.setAsText(&lt;span&gt;&quot;0&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(editor.getAsText());&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;    editor.setAsText(&lt;span&gt;&quot;2&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(editor.getAsText());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关注点：对于Spring来说，传入的&lt;strong&gt;「true、on、yes、1」&lt;/strong&gt;等都会被“翻译”成true（字母不区分大小写），大大提高兼容性。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;现在知道为啥你用Postman传个1，用Bool值也能正常封装进去了吧，就是它的功劳。此效果等同于转换器&lt;code&gt;StringToBooleanConverter&lt;/code&gt;，将在后面进行讲述对比&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 虽然都行，但建议你规范书写：UTF-8&lt;/span&gt;&lt;br/&gt;    PropertyEditor editor = &lt;span&gt;new&lt;/span&gt; CharsetEditor();&lt;br/&gt;    editor.setAsText(&lt;span&gt;&quot;UtF-8&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(editor.getAsText()); &lt;span&gt;// UTF-8&lt;/span&gt;&lt;br/&gt;    editor.setAsText(&lt;span&gt;&quot;utF8&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(editor.getAsText()); &lt;span&gt;// UTF-8&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关注点：utf-8中间的横杠可要可不要，但建议加上使用标准写法，另外字母也是不区分大小写的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    PropertyEditor editor = &lt;span&gt;new&lt;/span&gt; CustomDateEditor(&lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;),&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;    editor.setAsText(&lt;span&gt;&quot;2020-11-30 09:10:10&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(editor.getAsText()); &lt;span&gt;// 2020-11-30 09:10:10&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// null输出空串&lt;/span&gt;&lt;br/&gt;    editor.setAsText(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;    System.out.println(editor.getAsText());&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;    editor.setAsText(&lt;span&gt;&quot;2020-11-30&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(editor.getAsText());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关注点：这个时间/日期转换器很不好用，构造时就必须指定一个&lt;code&gt;SimpleDateFormat&lt;/code&gt;格式化器。在实际应用中，Spring并没有使用到它，而是用后面会说到的替代方案。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;特殊实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把没有放在&lt;code&gt;org.springframework.beans.propertyeditors&lt;/code&gt;包下的实现称作特殊实现（前者称为标准实现）。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「MediaTypeEditor」&lt;/strong&gt;：位于org.springframework.http。依赖的核心API是&lt;code&gt;MediaType.parseMediaType(text)&lt;/code&gt;，可以把诸如text/html、application/json转为MediaType对象&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;显然它属于spring-web包，使用在web环境下&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「FormatterPropertyEditorAdapter」&lt;/strong&gt;：位于org.springframework.format.support。将3.0新增的Formatter接口适配为一个PropertyEditor：setAsText这种转换操作委托给&lt;code&gt;formatter.parse()&lt;/code&gt;去完成，反向委托给&lt;code&gt;formatter.print()&lt;/code&gt;去完成。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;此适配器在&lt;code&gt;DataBinder#addCustomFormatter()&lt;/code&gt;得到应用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「PropertyValuesEditor」&lt;/strong&gt;：位于org.springframework.beans。将k-v字符串（Properties格式）转换为一个PropertyValues，从而方便放进Environment里&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「ResourceEditor」&lt;/strong&gt;：位于org.springframework.core.io。此转换器将String转换为&lt;code&gt;Resource&lt;/code&gt;资源，特别实用。作为基础设施，广泛被用到Spring的很多地方&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;像什么标准的&lt;code&gt;FileEditor、InputSourceEditor、InputStreamEditor、URLEditor&lt;/code&gt;等等与资源相关的转换器，均依赖它而实现&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test4&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 支持标准URL如file:C:/myfile.txt，也支持classpath:myfile.txt&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 同时还支持占位符形式&lt;/span&gt;&lt;br/&gt;    PropertyEditor editor = &lt;span&gt;new&lt;/span&gt; ResourceEditor(&lt;span&gt;new&lt;/span&gt; DefaultResourceLoader(), &lt;span&gt;new&lt;/span&gt; StandardEnvironment(), &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// file:形式本处略&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// editor.setAsText(&quot;file:...&quot;);&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// System.out.println(editor.getAsText());&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// classpath形式（注意：若文件不存在不会报错，而是输出null）&lt;/span&gt;&lt;br/&gt;    editor.setAsText(&lt;span&gt;&quot;classpath:app.properties&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(editor.getAsText()); &lt;span&gt;// 输出带盘符的全路径&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    System.setProperty(&lt;span&gt;&quot;myFile.name&quot;&lt;/span&gt;, &lt;span&gt;&quot;app.properties&quot;&lt;/span&gt;);&lt;br/&gt;    editor.setAsText(&lt;span&gt;&quot;classpath:${myFile.name}&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(editor.getAsText()); &lt;span&gt;// 结果同上&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关注点：Spring扩展出来的Resource不仅自持常规&lt;code&gt;file:&lt;/code&gt;资源协议，还支持平时使用最多的&lt;code&gt;classpath:&lt;/code&gt;协议，可谓非常好用。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「ConvertingPropertyEditorAdapter」&lt;/strong&gt;：位于org.springframework.core.convert.support。将3.0新增的&lt;code&gt;ConversionService&lt;/code&gt;转换服务适配为一个&lt;code&gt;PropertyEditor&lt;/code&gt;，内部转换动作都委托给前者去完成。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;AbstractPropertyBindingResult#findEditor()&lt;/code&gt;为属性寻找合适PropertyEditor的时候，若ConversionService能支持就包装为ConvertingPropertyEditorAdapter供以使用，这是适配器模式的典型应用场景。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;“谁”在使用ProertyEditor&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;PropertyEditor自动发现机制&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;PropertyEditor存在的缺陷&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考虑到阅读的舒适性，单篇文章不宜太长，因此涉及到&lt;code&gt;PropertyEditor&lt;/code&gt;的这几个问题，放在下篇文章单独列出。这几个问题明显比本文更深入，欢迎保持持续关注，peace！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;✍总结&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要介绍了三点内容：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;PropertyEditor是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring为何选择基于PropertyEditor？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring内建的那些PropertyEditor都有哪些，各自什么作用？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PropertyEditor虽然已经很古老，不适合当下复杂环境。但不可否认它依旧有存在的价值，Spring内部也大量的仍在使用，因此&lt;strong&gt;「不容忽视」&lt;/strong&gt;。下篇文章将深度探讨Spring内部是如何使用PropertyEditor的，赋予了它哪些机制，以及最终为何还是决定自己另起炉灶搞一套呢？欢迎对本系列保持持续关注~&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;附：Spring主要版本发布时间和特性&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「2002-02」&lt;/strong&gt;，开始开发孵化此项目，项目名叫：&lt;code&gt;interface21&lt;/code&gt;，它便就是Spring的前身&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「2004-03」&lt;/strong&gt;，1.0版发布。进入迅速发展期&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「2006-10」&lt;/strong&gt;，2.0版发布。支持可扩展的xml配置功能、支持Java5、支持动态语言、支持更多扩展点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「2007-11」&lt;/strong&gt;，2.5版发布。项目名从此改为Spring Source，支持Java 6，支持注解配置（部分）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「2009-12」&lt;/strong&gt;，3.0版发布。这是非常非常重要的一个版本，支持了模块驱动、支持SpEL、支持Java Bean配置、支持嵌入式数据库......&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「2011和2012」&lt;/strong&gt;，这两年发布了非常多的3.x系列小版本，带来了很多惊喜，同时也让Spring更加扎实&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「2013-12」&lt;/strong&gt;，4.0版发布。这是有一次进步，提供了对Java 8的全面支持，支持Java EE 7、支持websocket、泛型依赖注入......&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「2017-09」&lt;/strong&gt;，5.0版发布。最低JDK版本要求是Java 8，同时支持Servlet 3.1。当然最为重要的是引入了全新模块：WebFlux&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;截止到当前，Spring Framework的最新版本是&lt;code&gt;5.3.x&lt;/code&gt;版本，此版本是5.x的最后一个主要功能分支，下个版本将是6.x喽，咱们拭目以待。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;✔推荐阅读：&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.2703125&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot; data-width=&quot;100%&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Dlhic9h0DHMOr30sOVWhxhAMKXRPGZmIicY6BBS5uM1S75OdWp1WPw5Rkvht8Q0bibKpFbgu3CicBOWF9rSkx469Hw/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot; data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt; 关注A哥，开启专栏式学习&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;185&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;185&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;301&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/crPesQVeyKKzF7W9LLXyXXibBoEp14SdzRicx2f4R35VL5kHQiam1pSKtBm4Tibb2icAfl1fOStzHfZhwgtxiak8sKiaQ/640?wx_fmt=jpeg&quot;/&gt; &lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;156&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;156&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKKXtKvE4xWZMBts71H1XtIib6pgq4Qdbs5ZVy7NoTds6SzDCpWRib7yy9qlYwn1v1T2OeSXwLYS7xibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;378&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;扫码关注后，回复“专栏”进入更多Spring专栏学习&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;右侧为私人微信(加好友备注:Java入群)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;个人站点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;(本文已收录)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;：https://www.yourbatman.cn&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0MTUwOTgyOQ==&amp;amp;mid=2247483765&amp;amp;idx=1&amp;amp;sn=591d5e6503aed1af1eb5ed8a053aea7c&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7d79f91c9f612a95ad15aff37d1f18ff</guid>
<title>ssh 偶发性登录卡死之谜</title>
<link>https://toutiao.io/k/0iuneb6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;outline-text-2&quot; id=&quot;text-orgda455a4&quot;&gt;
&lt;p&gt;
今天遇到一个非常诡异的 ssh 登陆失败的情况，：
&lt;/p&gt;

&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;通过 ssh 登陆某主机（假设为user@Server）经常卡死，但经过多次尝试偶尔会出现登陆成功的情况。&lt;/li&gt;
&lt;li&gt;尝试用 ssh 登陆该主机的其他用户（tmpusr@Server），经常能成功，但是多次尝试会出现偶尔登陆卡死的情况。&lt;/li&gt;
&lt;li&gt;使用 ssh -vvv user@Server 尝试调试，发现能够正常登陆，而且每次都能登陆成功。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>