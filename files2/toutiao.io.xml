<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ad5745381a9c1b7947750066369392e2</guid>
<title>困在内卷里的工程师 | 码农周刊第 322 期</title>
<link>https://toutiao.io/k/mb7u8g0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;困在内卷里的工程师 | 码农周刊第 322 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第322期（2020-10-21）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=322&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3220&quot; target=&quot;_blank&quot;&gt;薪资翻番如何实现？程序员的涨薪秘诀&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=322&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3220&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_321.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=322&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;实战经验&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;功能强大、配置简单、完全开源。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;第三代 AI 发展的思路是把第一代的知识驱动和第二代的数据驱动结合起来，通过利用知识、数据、算法和算力等 4 个要素，构造更强大的 AI……&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;斯坦福教授、Tcl 语言发明者 John Ousterhout 的著作《A Philosophy of Software Design》，自出版以来，好评如潮。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;实战经验&lt;/p&gt;
        
        &lt;p&gt;适合新手&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;实用&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;一步步教你&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 448635 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 429587 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 412364 即可&lt;/p&gt;
        
        &lt;p&gt;编程、成长、正能量！&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 381811 即可&lt;/p&gt;
        
        &lt;p&gt;分享Go语言相关内容&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 133906 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=322&amp;amp;aid=20030&amp;amp;url=https%3A%2F%2Fitem.jd.com%2F12972072.html&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/book_322.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;欢迎讨论&lt;/p&gt;
        
        &lt;p&gt;部分适用于百度&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>27c4c24bc532e901e21b4a7f2b9cfc59</guid>
<title>Redis + Nginx + 设计模式 + Spring 全家桶 + Dubbo + 阿里技术精选文档</title>
<link>https://toutiao.io/k/zp8ncvc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;最近有一些粉丝私聊我，有没有技术文档，然后我这边经过一段时间收集，终于整理好了这套技术文档，里面包含了Redis、Nginx、设计模式、spring全家桶、Dubbo等关于Java架构方面的资料，一并分享给大家。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;img data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5625&quot; data-type=&quot;jpeg&quot; data-w=&quot;1600&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/C5z5LG0MRMlzpTnynVCNP80picCNY1NZQ5ju9yDdp28GWPMKnntibNibTZQU2EHdem8LBibbrX5T5MDlmqckN54euw/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;技术文档已经整理好储存在网盘里面&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;这份资料包括：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;193&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;IDEA、Java语法、面向对象、异常、常用类、集合、IO流、多线程、网络编程、JUnit、枚举、注解、反射机制、CSS、HTML、JavaScript、JQuery、ajax、Javaweb、MySQL、JavaEE、SSM框架、springboot、算法、Git、maven、Linux、设计模式、多线程与高并发、视频教程、视频源码、实战项目、电子书、简历模板、高频面试题等等资源。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;资料目录&lt;/span&gt;&lt;/strong&gt; &lt;/span&gt;&lt;br/&gt;—————————————————————————————&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;开发手册系列：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Java核心知识点整理手册&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;阿里巴巴开发手册（汇总）&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;....&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;268&quot; data-backw=&quot;552&quot; data-ratio=&quot;0.4849673202614379&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;765&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/V0Q3M5IicQd4sBhcWKe8Zzd1ov8HtEnRsPgorJprjswKPglXLDlko2VP6mn56PCFKXaAvv2nal1vZ1JGO0KTn8A/640?wx_fmt=png&quot;/&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;300&quot; data-backw=&quot;552&quot; data-ratio=&quot;0.5425925925925926&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9cHGeGOCicSFG95YMCAm0DxqStrgwpSwwRbvAC3BSqOtibd0hdYqzA5gxOUCykqD7MibkDu02pziaqys7HL2zeB5LA/640?wx_fmt=png&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;面试系列：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;PDF文档&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;系列&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;87&lt;/span&gt;页的Spring+Boot核心笔记&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;17页的Mybatis面试专题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;43页的多线程专题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;22页的数据库专题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;86页的JVM专题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;13页的设计模式专题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;473页的&lt;span&gt;&lt;span&gt;Spring&lt;/span&gt;专题&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;127页的大厂面试题库&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.42891278375149344&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;837&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/V0Q3M5IicQd5kLCxLZQWoLOlCBOen6HetwxGFujCNEJwWfoaMHicibiaFRViac2FPTRFoln62cHoaAMDKvJh7jnzXPw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（这些PDF文档都是非常不错的，&lt;/span&gt;&lt;span&gt;值得大家研读，也可结合思维导图找到学习的方向&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;针对这些技术我已经整理好了相关的文档以及资料，如果感兴趣的话可以扫码获取&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;资料获取方法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长按扫码，领取资料&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;遇到扫码频繁，请再次识别&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/V0Q3M5IicQd6Xccib24AI1GARdeCBNnE8EJiaHPbNHNoJ52kRM1Jls8DDY2Op8JMkMduuWmp7Q1FMYOzguWLJwSWg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;br/&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;所有资料扫码免费领取！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;Java精品技术教程&lt;/span&gt;&lt;/strong&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6113033448673587&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;867&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/V0Q3M5IicQd5kLCxLZQWoLOlCBOen6Hetcr4COQK415rtXGLNFqrJnm7hQsEmOuge3uSibDiaZic409LnGwDe0wBEQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;互联网企业面试真题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;243&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.4353932584269663&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1068&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/V0Q3M5IicQd4sBhcWKe8Zzd1ov8HtEnRsib3S39RCbOOYpiacxH2J4XsQGicXTwvxOhgYWYbicIvGaKKY9xlUl3baIQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;Java核心技术总结（283页）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5416666666666666&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/V0Q3M5IicQd5kLCxLZQWoLOlCBOen6HetMH5MibEcQrHM6h3Wiazspg6QztNzlicRSMFfQ6dOA32rJ5eel4hsXYw4A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;已经将所有资料整理好（源码，笔记，PPT，学习视频）&lt;/span&gt;&lt;strong&gt;&lt;span&gt;免费领取&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;资料获取方法&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长按扫码，领取资料&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;遇到扫码频繁，请再次识别&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/V0Q3M5IicQd6Xccib24AI1GARdeCBNnE8EJiaHPbNHNoJ52kRM1Jls8DDY2Op8JMkMduuWmp7Q1FMYOzguWLJwSWg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;所有资料扫码免费领取！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>39f706138a23ae3c629d3fdd25c5d309</guid>
<title>[译] 何时使用 Rust 和何时使用 Golang？</title>
<link>https://toutiao.io/k/z6p6anw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6671232876712329&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMqm2lSGu3l8woJasfoSWefXzWUb2qTiaX8WcYsNsx4F7qza5oHcHhXsgQhIp1ht8Ih1ldzkgaKuUeTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;730&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Golang 和 Rust 之间有明显的区别。Golang 更加注重构建可以无限扩展的 Web API 和小型服务，尤其是在 goroutine 的强大支持下。Rust 也可以用于小型服务，但是从开发人员的经验来看，事情要困难得多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Rust 非常适合处理大量数据和其他 CPU 密集型操作，例如执行算法。这是 Rust 超过 Golang 的最大优势。要求高性能的项目通常更适合 Rust。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本教程中，我们将就 Golang 和 Rust 进行比较和对比，评估这两种编程语言的性能，并发性，内存管理和整体开发人员体验。我们还将概述这些元素，以帮助您一目了然地为项目选择正确的语言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您刚开始使用 Rust，那么在继续阅读之前，最好先阅读一下&lt;span&gt;初学者指南&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您全都都准备好了，那就让我们开始吧！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;性能&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Golang 最初是由 Google 的工程师设计的，于 2009 年向公众推出。它的创建是为 C++提供替代方案，该替代方案易于学习和编码，并且经过优化可在多核 CPU 上运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从那时起，Golang 对于希望利用该语言提供的并发性的开发人员来说非常有用。该语言提供了 goroutine，使您可以将函数作为 goroutine 运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Golang 的一大优势是您可以轻松使用 goroutines。只需将&lt;code&gt;go&lt;/code&gt;添加到函数前即可使其作为 goroutine 运行。Golang 的并发模型允许您跨多个 CPU 内核部署工作负载，从而使其成为一种非常有效的语言。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(from &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;3&lt;/span&gt;; i++ {&lt;br/&gt;        fmt.Println(from, &lt;span&gt;&quot;:&quot;&lt;/span&gt;, i)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;    f(&lt;span&gt;&quot;direct&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; f(&lt;span&gt;&quot;goroutine&quot;&lt;/span&gt;)&lt;br/&gt;    time.Sleep(time.Second)&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;done&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管有多核 CPU 支持，Rust 仍然跑赢 Golang。Rust 在执行算法和资源密集型操作方面效率更高。该&lt;span&gt;基准测试游戏&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;比较了 rust 和 golang 的不同算法，如二叉树。对于所有经过测试的算法，Rust 至少快 30％；在二叉树计算的情况下，最高可达 1,000％。&lt;span&gt;Bitbucket 的&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;一项研究表明，Rust 与 C++的性能相似。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6680555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMqm2lSGu3l8woJasfoSWefXz3Z8x7jFeiaHleFQBURFps0bFfArzvohAtf5AmK6uibNxyfK3tLhHl5Wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;（来源：&lt;span&gt;基准测试游戏&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;）&lt;/em&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;并发&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上所述，Golang 支持并发。例如，假设您正在运行一个处理 API 请求的 Web 服务器。您可以使用 Golang 的 goroutine 程序将每个请求作为 goroutine 运行，通过将任务分发到所有可用的 CPU 内核来最大程度地提高效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Goroutines 是 Golang 内置功能的一部分，而 Rust 仅支持本地 async/await 语法来支持并发。因此，在并发方面，Golang 的开发人员有经验优势。但是，Rust 在保证内存安全方面要好得多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是 Rust 的简化线程的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;use&lt;/span&gt; std::thread;&lt;br/&gt;&lt;span&gt;use&lt;/span&gt; std::time::Duration;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;   &lt;span&gt;// 1. create a new thread&lt;/span&gt;&lt;br/&gt;   thread::spawn(|| {&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;..&lt;span&gt;10&lt;/span&gt; {&lt;br/&gt;         &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;thread: number {}!&quot;&lt;/span&gt;, i);&lt;br/&gt;         thread::sleep(Duration::from_millis(&lt;span&gt;100&lt;/span&gt;));&lt;br/&gt;      }&lt;br/&gt;   });&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;hi from the main thread!&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发一直是开发人员的棘手问题。在不影响开发人员体验的情况下保证内存安全的并发性并不是一项容易的任务。但是，这种极端的安全重点导致创建了&lt;span&gt;可证明正确的并发&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;。Rust 尝试使用所有权概念来防止未经请求的资源访问，以防止出现内存安全错误。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Rust 提供了四种不同的并发范例，以帮助您避免常见的内存安全陷阱。我们将仔细研究两个常见的范例：channel 和锁。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Channel&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;channel&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt; 有助于从一个线程传送消息到另一个。虽然 Golang 也存在此概念，但 Rust 允许您将&lt;span&gt;指针&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;从一个线程转移到另一个线程，以避免争用资源。通过传递指针，Rust 可以对 channel 强制执行线程隔离。同样，Rust 在并发模型方面表现出对内存安全的痴迷。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;锁&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仅当持有&lt;span&gt;锁&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;时才能访问数据。Rust 依赖于锁定数据而不是 cod 的原理，而 cod 经常在诸如 Java 之类的编程语言中找到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有关所有权和所有并发范例的更多详细信息，请查看“&lt;span&gt;使用 Rust 进行无所畏惧的并发&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;”。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;内存安全&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;较早的所有权概念是 Rust 的主要卖点之一。Rust 将&lt;span&gt;类型安全&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;提升到了新的水平，这对于实现内存安全的并发性也很重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据&lt;span&gt;Bitbucket 博客&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;，“ Rust 非常严格和繁琐的编译器会检查您使用的每个变量以及您引用的每个内存地址。它避免了可能发生的数据争用情况，并通知您未定义的行为。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这意味着由于 Rust 对内存安全性的极度痴迷，您最终不会出现缓冲区溢出或争用情况。但是，这也有其缺点。例如，您在编写代码时必须非常了解内存分配原则。始终保持您的内存安全防护并不容易。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开发人员体验&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，让我们看一下每种语言的学习曲线。Golang 在设计时考虑了简单性。开发人员经常将其称为“无聊”语言，也就是说，其有限的内置功能集使 Golang 易于学习、使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，Golang 提供了比 C++更简单的替代方案，隐藏了诸如内存安全性和内存分配等方面的内容。Rust 采用了另一种方法，迫使您考虑诸如内存安全性的概念。所有权的概念和传递指针的能力使 Rust 失去了学习的吸引力。当您不断考虑内存安全性时，您的工作效率就会降低，并且您的代码注定会变得更加复杂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与 Golang 相比，Rust 的学习曲线非常陡峭。值得一提的是，与 Python 和 JavaScript 等动态语言相比，Golang 的学习曲线较为陡峭。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;何时使用 Golang&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 在各种用例中都能很好地工作，使其成为创建 Web API 的 Node.js 的绝佳替代品。正如&lt;span&gt;Loris Cro&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;指出的那样，“ Go 的并发模型非常适合必须处理多个独立请求的服务器端应用程序”。这正是 Golang 提供 goroutines 的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，Golang 内置了对 HTTP Web 协议的支持。您可以使用内置的 HTTP 支持快速设计一个小型 API，并将其作为微服务运行。因此，Golang 非常适合微服务架构并满足 API 开发人员的需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简而言之，如果您重视开发速度并且更喜欢语法简单而不是性能，那么 Golang 是一个很好的选择。最重要的是，Golang 提供了更好的代码可读性，这对于大型开发团队而言是一个重要标准。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以下情况下选择 Golang：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;您关心简单性和可读性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;您需要一种简单的语法来快速编写代码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;您想使用支持 Web 开发的更灵活的语言&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;何时使用 Rust&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当性能很重要时，例如在处理大量数据时，Rust 是一个不错的选择。此外，Rust 为您提供了对线程行为以及线程之间资源共享方式的细粒度控制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一方面，Rust 具有陡峭的学习曲线，并且由于内存安全性的额外复杂性而减慢了开发速度。这并不一定是不利的。Rust 还保证当编译器检查每个数据指针时，您不会遇到内存安全性错误。对于复杂的系统，此保证会派上用场。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以下情况下选择 Rust：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;您关心性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;您想要对线程进行细粒度的控制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;您重视内存安全而不是简单性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go vs. Rust：我的大实话&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们从突出相似之处开始。Go 和 Rust 都是开源的，旨在支持微服务架构和并行计算环境。两者都通过并发优化了可用 CPU 内核的利用率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但归根结底，哪种语言是最好的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有很多方法可以解决这个问题。我建议考虑要构建哪种类型的应用程序。Golang 可很好地用于创建 Web 应用程序和 API，这些应用程序和 API 利用其内置的并发功能，同时支持微服务体系结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;您还可以使用 Rust 来开发 Web API，但并不是在设计时考虑到此用例。Rust 对内存安全性的关注增加了复杂性和开发时间，尤其是对于相当简单的 Web API。但是，对代码的大量控制使您可以编写更优化，内存效率更高且性能更高的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简而言之，Golang 与 Rust 的争论实际上是一个简单与安全的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有关更多观点，请查看“&lt;span&gt;在 Go 和 Rust 之间选择&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt;”。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;LogRocket：全面了解线上 Rust 应用程序&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调试 Rust 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪 Rust 应用程序的性能，自动显示错误以及跟踪缓慢的网络请求和加载时间感兴趣，请&lt;span&gt;尝试 LogRocket&lt;/span&gt;&lt;sup&gt;[14]&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5641666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMqm2lSGu3l8woJasfoSWefXzicMmuvXWfZBD6vwrFFqvVWQBhs8NY0G1DCqbicVkYrrBWviaY3uFMnx9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LogRocket&lt;/span&gt;&lt;sup&gt;[15]&lt;/sup&gt;就像 Web 应用程序的 DVR，实际上记录了 Rust 应用程序中发生的所有事情。您可以汇总并报告问题发生时应用程序所处的状态，而不用猜测为什么会发生问题。LogRocket 还监视您的应用程序的性能，报告诸如客户端 CPU 负载，客户端内存使用情况等指标。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文链接：https://blog.logrocket.com/when-to-use-rust-and-when-to-use-golang/&lt;/p&gt;&lt;p&gt;原文作者：Michiel Mulders&lt;/p&gt;&lt;p&gt;译者：polarisxu&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;初学者指南: &lt;em&gt;https://blog.logrocket.com/getting-up-to-speed-with-rust/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;基准测试游戏: &lt;em&gt;https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust-go.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Bitbucket 的: &lt;em&gt;https://bitbucket.org/blog/why-rust&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;基准测试游戏: &lt;em&gt;https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust-go.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;可证明正确的并发: &lt;em&gt;https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;channel: &lt;em&gt;https://doc.rust-lang.org/stable/rust-by-example/std_misc/channels.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;指针: &lt;em&gt;https://doc.rust-lang.org/std/primitive.pointer.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;锁: &lt;em&gt;https://doc.rust-lang.org/std/sync/struct.Mutex.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;使用 Rust 进行无所畏惧的并发: &lt;em&gt;https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;类型安全: &lt;em&gt;https://en.wikipedia.org/wiki/Type_safety&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;Bitbucket 博客: &lt;em&gt;https://bitbucket.org/blog/why-rust&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;Loris Cro: &lt;em&gt;https://kristoff.it/blog/why-go-and-not-rust/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[13]&lt;/span&gt;&lt;p&gt;在 Go 和 Rust 之间选择: &lt;em&gt;https://sdtimes.com/softwaredev/the-developers-dilemma-choosing-between-go-and-rust/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[14]&lt;/span&gt;&lt;p&gt;尝试 LogRocket: &lt;em&gt;https://logrocket.com/signup&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[15]&lt;/span&gt;&lt;p&gt;LogRocket: &lt;em&gt;https://logrocket.com/signup&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c977179f100b1173d5470874f42c622a</guid>
<title>想自己写框架？不会写 Java 注解可不行</title>
<link>https://toutiao.io/k/9j801i6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;img data-ratio=&quot;0.5107066381156317&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoF5meUibw0yzDr8WJvWZZdqOIIwTs8SQTGtujhpO4wUf2bPiaCMDMfPJBydvqLFYSAFEHHOLekPcIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1868&quot;/&gt;&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;用注解一时爽，一直用一直爽&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java后端开发进入spring全家桶时代后，开发一个微服务提供简单的增删改查接口跟玩泥巴似的非常简单，一顿操作猛如虎，回头一看代码加了一堆注解：@Controller @Autowired @Value，面向注解编程变成了大家不可缺少的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想象一下如果没有注解Java程序员可以要哭瞎😭&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然注解（annotation）这么重要，用的这么爽，那注解的实现原理你知道么？我猜你只会用注解不会自己写注解（手动滑稽）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，下面的内容带大家从零开始写一个注解，揭开注解神秘的面纱。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;原来注解不神秘&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注解用大白话来说就是一个标记或者说是特殊的注释，如果没有解析这些标记的操作那它啥也不是。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注解的格式如同类或者方法一样有自己特殊的语法，这个语法下文会详细介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那如何去解析注解呢？这就要用到Java强大的反射功能了。反射大家应该都用过，可以通过类对象获取到这个类的各种信息比如成员变量、方法等，那注解标记能不能通过反射获取呢？当然可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以注解的原理其实很简单，本质上是通过反射功能动态获取注解标记，然后按照不同的注解执行不同的操作，比如@Autowired可以注入一个对象给变量赋值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里是不是很躁动啊，来吧自己也撸一个注解。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;造火箭啦，自己动手写一个注解&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;便于大家理解，这里先引入一个场景：在线教育火了，经理让我写一个模块实现学生信息管理功能，考虑到分布式并发问题，经理让我务必加上分布式锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经理问我几天能搞定？我说至少3天。如是脑补了以下代码：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6792452830188679&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoF5meUibw0yzDr8WJvWZZdqqlLKjLNNCtPCHibIuk1mn2diaf8Klgconujc6bl0oUkt0LnwnBZkFiarQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot;/&gt;&lt;figcaption&gt;未使用注解前&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经理走后我在思考，我能不能只花一天时间写完，剩下两天时间用来写博客划水呢？突然灵感来了，我可以把重复的代码逻辑抽出来用注解实现不就节省代码了，哈哈，赶紧写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用注解之后整个方法清爽了很多，HR小姐姐都夸我写的好呢。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34057971014492755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoF5meUibw0yzDr8WJvWZZdqEmXvlkS1Os6hgkYAP7icgjSbNhw9dZY3kANTX6G2rGklJibFJDEkPE1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1104&quot;/&gt;&lt;figcaption&gt;使用注解后&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码已经写完上库了，现在我在划水写博客呢。是不是很简洁很优雅很牛逼，怎么做到的呢，主要分为三步：&lt;span&gt;1打开冰箱门，2把大象放进去，3把冰箱门关好&lt;/span&gt;。好了，扯远了，大家接着往下看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第一步定义一个注解&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5019455252918288&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoF5meUibw0yzDr8WJvWZZdqMZ5FFRhuPEK5IFahHnN9HVuDN0Fg8g5dHTct84u3q32SWqVUl9hMWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1028&quot;/&gt;&lt;figcaption&gt;注解的三大组成部分&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个注解可以简单拆解为三个部分：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一部分：注解体&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注解的定义有点类似于接口（interface），只不过前面一个加了一个@符号，这个千万不能省。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二部分：注解变量&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注解变量的语法有点类似于接口里面定义的方法，变量名后面带一对括号，不同的是注解变量后面可以有默认值。另外返回值只能是Java基本类型、String类型或者枚举类，不可以是对象类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三部分：元注解&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;元注解（meta-annotation）说白了就是给注解加注解的注解，是不是有点晕了，这种注解是JDK提前内置好的，可以直接拿来用的。不太懂也没有关系反正数量也不多，总共就4个，我们背下来吧：@Target @Retention @Documented @Inherited&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用来描述注解的使用范围，即被修饰的注解可以用在什么地方 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了@Target 能够更加清晰的知道它能够被用来修饰哪些对象，具体的取值范围定义在ElementType.java 枚举类中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如上面我们写的Redis锁的注解就只能用于方法上了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用来描述注解保留的时间范围，即注解的生命周期。在 RetentionPolicy 枚举类中定义了三个周期：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; RetentionPolicy {&lt;br/&gt;    SOURCE, &lt;span&gt;// 源文件保留&lt;/span&gt;&lt;br/&gt;    CLASS,  &lt;span&gt;// 编译期保留，默认值&lt;/span&gt;&lt;br/&gt;    RUNTIME &lt;span&gt;// 运行期保留，可通过反射去获取注解信息&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像我们熟知的@Override注解就只能保留在源文件中，代码编译后注解就消失了。比如上面我们写的Redis锁的注解就保留到了运行期，运行的时候可以通过反射获取信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用来描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息，很简单不多解释了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;被Inherited注解修饰的注解具有继承性，如果父类使用了被@Inherited修饰的注解，则其子类将自动继承该注解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，这一步我们已经将注解定义好了，但是这个注解如何工作呢？接着看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第二步实现注解的业务逻辑&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在第一步中我们发现定义的注解（@EnableRedisLock）中没有业务逻辑，只有一些变量，别忘了我们的注解是要使能Redis分布式锁的功能，那这个注解到底是怎么实现加锁和释放锁的功能呢？这个就需要我们借助反射的强大功能了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8320987654320988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoF5meUibw0yzDr8WJvWZZdqUn3Q8519JibztRk3QLv37icMBdN7k9bGpbUSHaa1aWTxXc2Vv8z8JHXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1620&quot;/&gt;&lt;figcaption&gt;注解的操作&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里借助了切面的功能，将EnableRedisLock注解作为一个切点，只要方法上标注了这个注解就会自动执行这里的代码逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过反射机制拿到注解对象后就可以执行加锁解锁的常用逻辑啦。Redis实现分布式锁相信大家已经很熟悉了，这里就不在啰嗦了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第三步在业务代码中尽情的使用注解&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@EnableRedisLock&lt;/span&gt;(lockKey = &lt;span&gt;&quot;student&quot;&lt;/span&gt;, expireTime = &lt;span&gt;10&lt;/span&gt;, timeUnit = TimeUnit.SECONDS, retryTimes = &lt;span&gt;5&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;method1&lt;/span&gt;&lt;span&gt;(Student student)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 这里写业务逻辑&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在需要加锁的方法上直接加上注解就可以啦，怎么样是不是很简单呀，赶紧在你的项目中运用起来吧。 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，自己写一个注解的内容就介绍到这里了，学会了吗？&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>281d0254bb881e10d61851a4af1a0752</guid>
<title>后分布式时代：多数派读写的 “少数派” 实现</title>
<link>https://toutiao.io/k/pih6nsy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section itemprop=&quot;text&quot;&gt;&lt;p&gt;本文链接: [&lt;span&gt;https&lt;/span&gt;&lt;span&gt;://&lt;/span&gt;&lt;span&gt;blog&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;openacid&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;algo&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;quorum&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;]&lt;/p&gt;&lt;span&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ziaRl59xuuYibDH4CABo9riaI6mS6cJc5FxFcQdeYic8vnN2Pt0TAqhA3l6Wc6aNe94w4cVIYzpbQo7UdI12pEuOtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.42592592592592593&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;h1&gt;前言&lt;/h1&gt;&lt;p&gt;paxos可以看做是2次 [多数派读写] 完成一次强一致读写. 多数派要求半数以上的参与者(paxos中的Acceptor)接受某笔操作. 但 [多数派读写] 并不一定需要多于半数的参与者, 分布式系统中某些场合的优化, 可以通过减少参与者数量来完成的.&lt;/p&gt;&lt;h1&gt;多数派读写:分布式系统的基础&lt;/h1&gt;&lt;p&gt;分布式系统中, 其中一个基础的问题是如何在不可靠硬件(低可用性)基础上构建可靠(高可用性)的服务, 要达成这个目标, 核心的手段就是复制(例如一份数据存3个副本). 而复制过程中的一致性问题, 最后都归结为paxos的解决方案. 这些我们在 [paxos的直观解释] 中做了详细的介绍.&lt;/p&gt;&lt;p&gt;在 [paxos的直观解释] slide-20 中, 我们了解到, paxos是通过2次 [多数派读写] 来完成强一致的读写:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;这个方法之所以能工作也是因为多数派写中, 一个系统最多只能允许一个多数派写成功. paxos也是通过2次多数派读写来实现的强一致.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;也就是说, [多数派读写] 在分布式领域是一个更基础的问题. 在 [paxos的直观解释] 中也简单介绍了一下 [多数派读写]:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;slide-10&lt;/strong&gt; 为了解决半同步复制中数据不一致的问题, 可以将这个复制策略再做一改进: &lt;strong&gt;多数派读写&lt;/strong&gt;: 每条数据必须写入到&lt;strong&gt;半数以上&lt;/strong&gt;的机器上. 每次读取数据都必须检查&lt;strong&gt;半数以上&lt;/strong&gt;的机器上是否有这条数据.&lt;/p&gt;&lt;p&gt;在这种策略下, 数据可靠性足够, 宕机容忍足够, 任一机器故障也能读到全部数据.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ziaRl59xuuYibDH4CABo9riaI6mS6cJc5FxB6YmAtUPpwyodIRXZxTDgAKAEz0CB2PBibz4tt27nPKbY4Nh0ABTXLQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.75&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p&gt;[多数派读写], 也可称作 quorum-rw, wikipedia上的描述如下:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在有冗余数据的分布式存储系统当中，冗余数据对象会在不同的机器之间存放多份拷贝。但是同一时刻一个数据对象的多份拷贝只能用于读或者用于写。&lt;/p&gt;&lt;p&gt;算法来源于Gifford, 1979。分布式系统中的每一份数据拷贝对象都被赋予一票。每一个读操作获得的票数必须大于最小读票数（read quorum）（Vr），每个写操作获得的票数必须大于最小写票数（write quorum）(Vw）才能读或者写。如果系统有V票（意味着一个数据对象有V份冗余拷贝），那么最小读写票数(quorum)应满足如下限制：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Vr + Vw &amp;gt; V&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Vw &amp;gt; V/2&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p&gt;🌰 举个例子, 如果有5个存储节点&lt;code&gt;{a, b, c, d, e}&lt;/code&gt;, 一笔操作给x赋值为3(x=3) 成功写入了abc 3个节点, 那么另外一个读, 只要联系到任意3个节点, 就一定能读到x=3 这就是安全的.&lt;/p&gt;&lt;p&gt;要联系到至少3个节点, 在某些场景下仍然是昂贵的, 例如一个全球分布的DB, 2个机房之间延迟可能达到上百毫秒. 我们有时希望通过减少必须参与的节点数量, 从而提升系统的性能. 于是我们先从概念开始, 看看quorum-rw中的quorum是什么:&lt;/p&gt;&lt;h2&gt;Quorum vs Majority&lt;/h2&gt;&lt;p&gt;在很多paper中, 是不区分quorum和majority的差别的:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;majority就是”多数派”的意思(也就是&lt;strong&gt;多于半数&lt;/strong&gt;, &lt;code&gt;≥⌊n/2⌋+1&lt;/code&gt;), 例如5节点中选3个;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;quorum, 翻译为”法定人数”( 🤔 WT…? ), 它不一定是多数, 但需要满足一个条件, 就是任意2个quorum必须有交集(majority已经满足了这个要求). 所以在本文中, &lt;strong&gt;我们将quorum看做majority概念的一个推广; majority是quorum的一个特例&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;一般我们提到quorum(或majority)时, 都是指一个节点集合Q, 本文中我们把一个系统中所有quorum的集合记为ℚ: &lt;code&gt;ℚ = {Q₁, Q₂...}&lt;/code&gt;, 其中&lt;code&gt;Qₓ = {aᵢ, aⱼ...}&lt;/code&gt; 是一个节点(paxos中的Acceptor)的集合, 例如一个三节点系统&lt;code&gt;{a, b, c}&lt;/code&gt;, 它的majority的quorum集合 &lt;code&gt;ℚ = { {a, b}, {b, c}, {c, a}, {a, b, c} }&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;现在再回到问题, 要保证quorum-rw的正确性, 就要求一次成功的写入, 必须能成功读取, 从这点看, 过半数这个要求是可以放宽的:&lt;/p&gt;&lt;p&gt;只需要quorum保证&lt;strong&gt;任意2个quorum有交集&lt;/strong&gt;就可以.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在[paxos made simple]中, 也就是classic paxos的paper中, [Leslie Lamport] 还在使用majority这个名称来表示多数派, 在后面的paper, fast-paxos, generalized paxos中,都换成了quorum这个名词.&lt;/p&gt;&lt;p&gt;虽然在paper中都是”majority”的意思, 但quorum的适用范围更广.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我们看几个非majority的quorum的例子, 这些quorum都不是传统意义上的majority, 但都可以实现majority同样的功能, 为quorum-rw或paxos提供正确性保证:&lt;/p&gt;&lt;h1&gt;不是majority的quorum们&lt;/h1&gt;&lt;h2&gt;带权重的quorum&lt;/h2&gt;&lt;p&gt;&lt;code&gt;{a, b, c, d, e}&lt;/code&gt; 5个节点中, 把a, b, c三个节点部署到一起: &lt;code&gt;{ abc, d, e}&lt;/code&gt;(abc必须同时选). 如果选abc, 就记3票, d, e只记一票.&lt;/p&gt;&lt;p&gt;3个成员一共5票, 所有票数过半的集合都是quorum: &lt;code&gt;{abc}&lt;/code&gt;, &lt;code&gt;{abc, d}&lt;/code&gt;, &lt;code&gt;{abc, e}&lt;/code&gt;, &lt;code&gt;{abc, d, e}&lt;/code&gt;. 但&lt;code&gt;{d, e}&lt;/code&gt; 不是一个quorum, 因为根据我们的定义, 只有2票没有过半.&lt;/p&gt;&lt;p&gt;这样, 任意2个quorum都有交集&lt;code&gt;{abc}&lt;/code&gt;. 那么quorum-rw算法, 如果选择任意一个quorum写, 另一个进程选择任意一个quorum读, 都可以实现安全的读写.&lt;/p&gt;&lt;h2&gt;包含特定元素的quorum&lt;/h2&gt;&lt;p&gt;从上面的例子, 可以直接去掉majority的概念, 就是一类特殊的quorum集合: &lt;strong&gt;ℚ 中每个quorum都必须包含某个特定元素&lt;/strong&gt;:&lt;/p&gt;&lt;p&gt;如果集群是3个节点&lt;code&gt;{a,b,c}&lt;/code&gt;, 定义每个quorum都必须包含a, 那么: &lt;code&gt;ℚ = { {a}, {a,b}, {a,c}, {a,b,c} }&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;任意2个quorum都有交集&lt;code&gt;{a}&lt;/code&gt;, 用这个quorum定义来运行paxos, 仍然是正确的. (可以试试跑一个之前 [paxos的直观解释] 中的例子里的paxos)&lt;/p&gt;&lt;h2&gt;4/5 加 2/5的quorum&lt;/h2&gt;&lt;p&gt;在一个5节点集群&lt;code&gt;{a,b,c,d,e}&lt;/code&gt; 中, quorum定义为:至少包含4个元素, 或是&lt;code&gt;{a,b}&lt;/code&gt; 那么ℚ 就是:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{a, b, c, d}&lt;br/&gt;{a, b, c, e}&lt;br/&gt;{a, b, d, e}&lt;br/&gt;{a, c, d, e}&lt;br/&gt;{b, c, d, e}&lt;br/&gt;{a, b}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;任一4个元素的quorum都有交集, 任一4元素的quorum也和&lt;code&gt;{a,b}&lt;/code&gt;有交集. 能用来跑paxos.&lt;/p&gt;&lt;h2&gt;Hierarchical quorum 3x3&lt;/h2&gt;&lt;p&gt;[hierarchical quorum] 是一个分层的quorum定义, 假设集群有9个节点, 排列成3x3的矩阵, 这里quorum的定义为: &lt;strong&gt;至少包括2行, 每行中至少包含2个节点&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;容易看出任意2个quorum必有交集, 例如 &lt;code&gt;{a1, a2, b1, b2}&lt;/code&gt; 和 &lt;code&gt;{b2, b3, c2, c3}&lt;/code&gt; 有一个交集&lt;code&gt;{b2}&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;.------.&lt;br/&gt;|a1  a2| a3&lt;br/&gt;|   .--|---.&lt;br/&gt;|b1 |b2| b3|&lt;br/&gt;&#x27;------&#x27;   |&lt;br/&gt;c1  |c2  c3|&lt;br/&gt;    &#x27;------&#x27;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以此quorum定义替代majority, 运行多数派读写或paxos一样是正确的.&lt;/p&gt;&lt;h2&gt;Hierarchical quorum 2xn&lt;/h2&gt;&lt;p&gt;继续沿用hierarchical quorum 的定义, 但只选2行. 因为一个2节点的系统&lt;code&gt;{x, y}&lt;/code&gt;, quorum集合可以是 &lt;code&gt;ℚ = { {x}, {x, y} }&lt;/code&gt;(或 &lt;code&gt;ℚ = { {x, y}, {y} }&lt;/code&gt;), (这里x, y代表一行).&lt;/p&gt;&lt;p&gt;于是这个场景中的quorum 可以描述为: &lt;strong&gt;包含第一行的majority, 或在每一行都包含一个majority&lt;/strong&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;a1 a2 a3&lt;br/&gt;b1 b2 b3 b4 b5&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;容易看出按照这个规则选出的quorum, 任意2个都有交集. 例如:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{a1, a3}&lt;br/&gt;{&lt;br/&gt;  a1, a2,&lt;br/&gt;  b1, b2, b3,&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有交集&lt;code&gt;{a1}&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;[raft] 使用了这种quorum定义来完成集群变更, 基于hierarchical quorum的选主在raft中叫做[joint consensus].&lt;/p&gt;&lt;h1&gt;通过设计 quorum 降低延迟&lt;/h1&gt;&lt;p&gt;任何一种quorum的定义, 都可以用来替代majority来实现quorum-rw, 或paxos, 并严格保证正确性. 但是, 选择一种quorum, 将直接影响系统的性能和可用性.&lt;/p&gt;&lt;p&gt;首先最直观的结论是, quorum定义中所需的节点个数越少, 完成一次quorum-rw或paxos的消息量就越少, 如果可以选择到更近的节点, 那么整个系统的延迟就有可能会降低.&lt;/p&gt;&lt;h1&gt;quorum 决定了系统的可用性&lt;/h1&gt;&lt;p&gt;另一方面, 不同的quorum的选择, 会直接影响系统的可用性:&lt;/p&gt;&lt;p&gt;&lt;strong&gt;任何一种quorum的选择, 可用性都低于majority的quorum&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;非majority的quorum, 允许更少的可用节点, 以3x3的hierarchical quorum存储为例, 一次写入如果选择了左上的4个节点, 就达到了quorum要求, 只需要不到半数的节点参与. 看似容忍了更多(5个)故障, 但它整体的可用性要低于majority的quorum.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;.-----.&lt;br/&gt;|a1 a2| a3&lt;br/&gt;|b1 b2| b3&lt;br/&gt;&#x27;-----&#x27;&lt;br/&gt;c1  c2  c3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;系统可用性的 quorum 定义&lt;/h2&gt;&lt;p&gt;&lt;span&gt;一个分布式系统的可用性, 可以从&lt;/span&gt;以&lt;span&gt;下几方面去考虑, 假设:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;某个时刻, &lt;strong&gt;如果在线的节点集合是一个quorum, 那系统就可用, 可以通过在线节点集合这个quorum完成多数派读写或paxos; 否则就是系统不可用&lt;/strong&gt;.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;🌰 例如 &lt;code&gt;{a, b, c}&lt;/code&gt; 三个节点, 选择majority的quorum,&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;a, b 在线, c停机时, &lt;code&gt;{a, b}&lt;/code&gt; 是一个quorum 所以系统可以正常运行.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果a在线, b, c都停机, &lt;code&gt;{a}&lt;/code&gt; 不是一个quorum, 所以系统这时就不可用了.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;因此整个系统的可用性可以定义为: &lt;strong&gt;每个quorum出现的概率之和: &lt;code&gt;P(ℚ) = ΣP(Qᵢ), for every Qᵢ ∈ ℚ&lt;/code&gt;. quorum出现的概率是: P(Qᵢ) = (1-p)ˣpⁿ⁻ˣ, 其中x是一个quorum包含的节点个数: x = |Qᵢ|&lt;/strong&gt;.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;🌰 对一个三节点的系统 &lt;code&gt;{a, b, c}&lt;/code&gt; majority 的quorum集合&lt;code&gt;𝕄 = { {a, b}, {b, c}, {c, a}, {a, b, c} }&lt;/code&gt;, 那么3个节点可能出现的所有状态, 以及对应的整个系统是否可用如就如下展示:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;0)  {}        (1-p)⁰p³    // unavailable&lt;br/&gt;1)  {a}       (1-p)¹p²    // unavailable&lt;br/&gt;2)  {b}       (1-p)¹p²    // unavailable&lt;br/&gt;3)  {c}       (1-p)¹p²    // unavailable&lt;br/&gt;4)  {a, b}    (1-p)²p¹    // available&lt;br/&gt;5)  {b, c}    (1-p)²p¹    // available&lt;br/&gt;6)  {c, a}    (1-p)²p¹    // available&lt;br/&gt;7)  {a, b, c} (1-p)³p⁰    // available&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果选择majority的quorum来构建系统, 那系统可用的概率是后4行状态概率相加: C(3, 2)(1-p)²p¹ + C(3, 3)(1-p)³p⁰ ~= 1-4p² ~= 0.9996, 大约3个9&lt;/p&gt;&lt;p&gt;如果选择另一种quorum, 例如去掉&lt;code&gt;{a, b}&lt;/code&gt;, 加入&lt;code&gt;{c}&lt;/code&gt;, 那这时可用性是第3, 5, 6, 7行相加: (1-p)¹p² + 2 (1-p)²p¹ + (1-p)³p⁰ = 1-p, 大约2个9, 此时系统中每个quorum都包含c, c在线或停机直接决定了系统的可用性, 所以系统可用性也就是直接等于了c节点的可用性.&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;quorum 的可用性分析&lt;/h2&gt;&lt;p&gt;然后我们来看看为什么非majority的quorum 会降低系统的可用性:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;假设majority quorum的集合为&lt;code&gt;𝕄&lt;/code&gt;, 也就是所有大小过半的节点集合;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对某一个quorum集合&lt;code&gt;ℚ = {Q₁, Q₂...}&lt;/code&gt;, 其中 &lt;code&gt;Qₓ = {aᵢ, aⱼ...}&lt;/code&gt; 是一个节点集合, Qₓ满足对quorum的定义: 任意2个Qᵢ, Qⱼ交集都不为空: &lt;code&gt;Qᵢ ∩ Qⱼ ≠ ø&lt;/code&gt;;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;单机停机几率 p = 0.01;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们可以对ℚ 做一个变换&lt;code&gt;f(ℚ)&lt;/code&gt;:&lt;/p&gt;&lt;p&gt;从ℚ 中选择最小的一个Qᵢ: Qᵢ满足&lt;code&gt;∀Qⱼ: |Qᵢ| ≤ |Qⱼ|&lt;/code&gt; (如果有多个最小的, 选任意一个), 从ℚ 中去掉Qᵢ, 再把Qᵢ的补集加入:&lt;/p&gt;&lt;p&gt;&lt;code&gt;ℚ&#x27; = ℚ \ {Qᵢ} ∪ {~Qᵢ}&lt;/code&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;ℚ’也还是一个合法quorum集合&lt;/strong&gt;: 因为对任意一个Qⱼ, 如果&lt;code&gt;|Qⱼ| ≥ |Qᵢ|&lt;/code&gt; 且&lt;code&gt;Qⱼ ≠ Qᵢ&lt;/code&gt;, 那么Qⱼ一定包含一个不在Qᵢ中的节点, 所以 ~Qᵢ 和 Qⱼ一定有交集.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;重复这个步骤直到ℚ 中所有quorum的大小都大于半数. 最后ℚ 就变成了一个𝕄 的子集: &lt;code&gt;f(ℚ) ⊆ M&lt;/code&gt;&lt;/p&gt;&lt;p&gt;这样, &lt;strong&gt;任何一个ℚ 都可以跟 𝕄 的一个子集建立一个一一映射. 而𝕄 的子集的可用性一定不大于𝕄 的可用性&lt;/strong&gt;: &lt;code&gt;P(subset(𝕄)) ≤ P(𝕄)&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;而且, &lt;strong&gt;对一个不大于半数的Qᵢ(&lt;code&gt;x = |Qᵢ| ≤ ⌊n⌋/2&lt;/code&gt;), 它的补集在随机停机过程中出现的几率更大&lt;/strong&gt;:&lt;/p&gt;&lt;p&gt;&lt;code&gt;(1-p)ˣpⁿ⁻ˣ ≤ (1-p)ⁿ⁻ˣpˣ&lt;/code&gt; ⇒ &lt;code&gt;P(Qᵢ) ≤ P(~Qᵢ) &lt;/code&gt; ⇒ &lt;code&gt;P(ℚ) ≤ P(f(Q))&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;∴ &lt;code&gt;P(ℚ) ≤ P(f(ℚ)) ≤ P(𝕄)&lt;/code&gt;, 即 majority 的 quorum 可靠性最高. 其他任何一种quorum的选择, 即使它允许更多的节点停机, 也只能提供较低的可用性.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;🌰 例如我们算下, 3x3 的 hierarchical quoru m的可用性:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;majority 3 节点的停机概率是: &lt;code&gt;Pm3 = C(3, 2)(1-p)²p + C(3, 3)(1-p)³&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Pm3也就是每个机房的停机概率, 把每个机房看做一个大的节点, 因此3个机房组成的majority quorum的不在线几率是: &lt;code&gt;Ph9 = C(3, 2)(1-Pm3)²Pm3 + C(3, 3)(1-Pm3)³&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们用 [hierarchical-quorum.py] 这个小程序计算如下:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;failure-rate:&lt;br/&gt;  majority of 3 nodes:        2.98e-04&lt;br/&gt;  majority of 7 nodes:        3.42e-07&lt;br/&gt;  majority of 9 nodes:        1.22e-08&lt;br/&gt;  hierarchical quorum of 3x3: 2.66e-07&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到hierarchical 3x3 的可用性比majority 9节点的可用性要低1个9. 差不多相当于7节点的majority 可用性.&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;应用场景&lt;/h1&gt;&lt;h2&gt;zookeeper 使用 hierarchical quorum 的例子&lt;/h2&gt;&lt;p&gt;🌰 [zookeeper] 的配置允许分组的概念, 就是使用了这种quorum定义, 它允许多于半数(5个/9个)节点停机. 例如在我们之前实现的3机房部署中, 就使用了3个机房(DC), 每个机房3个zookeeper实例的配置:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;            zookeeper&lt;br/&gt;                |&lt;br/&gt;    .-----------+----------.&lt;br/&gt;   /            |           \&lt;br/&gt;  DC-1         DC-2         DC-3&lt;br/&gt; / | \        / | \        / | \&lt;br/&gt;a1 a2 a3     b1 b2 b3     c1 c2 c3&lt;br/&gt;--------     --------     --------&lt;br/&gt;   | `- 30ms -&#x27;    `- 30ms -&#x27; |&lt;br/&gt;   `---------- 60ms ----------&#x27;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[hierarchical quorum] 的一个优势在于在系统可用的状态下, &lt;strong&gt;只需要联系2个机房就可以完成一次读写&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;我们假设一个接近现实场景:&lt;/p&gt;&lt;p&gt;那么选择 hierarchical quorum 所产生的延迟就在一定概率上比majority quorum的延迟低.&lt;/p&gt;&lt;p&gt;例如, 现在只观察DC-1的写入请求, 最优情况下它只需联系最近的机房(DC-2)来完成一次paxos. 如果宕机2个节点:&lt;/p&gt;&lt;p&gt;在宕机2个节点时, hierarchical 只有 majority 40% 的几率延迟达到 60ms; 如果假设单个节点停机几率是p=0.01(1年有3, 4天不在线), 那么9节点宕机2个节点的几率大约是0.0033, 差不多在99分位上, 延迟可以从60ms降低到30ms.&lt;/p&gt;&lt;h2&gt;用 quorum 来优化链路选择: 边缘存储场景&lt;/h2&gt;&lt;p&gt;🌰 传统的存储+CDN架构是用户传输到中心, 之后在下载时, 再通过边缘机房访问, 边缘机房没有则回中心拉取. 且边缘机房之间没有架构级别的关联, 各自在设计上是独立的:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Center Storage + CDN:&lt;br/&gt;            client&lt;br/&gt;            |  ↑&lt;br/&gt;            |  |&lt;br/&gt;  edge DCs  |  e₁   e₂   e₃&lt;br/&gt;            |    ↖  ↑  ↗&lt;br/&gt;center DC   `-----→ c&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假设我们现在有一个边缘存储的系统: 3个分布在各地的边缘机房eᵢ, 和一个中心机房c.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Edge Storage:&lt;br/&gt;               client&lt;br/&gt;               ↑&lt;br/&gt;               ↓&lt;br/&gt;  edge DCs     e₁ - e₂ - e₃   // weight = 1&lt;br/&gt;                 \  |  /&lt;br/&gt;center DC           c         // weight = 2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;边缘存储的特点是, 一个中心机房c, 一般包含全量数据, 做数据的集中处理, 归档等. 写入一般分散在各个边缘机房, 方便就近接入用户请求. 可以把边缘存储想象成支持本地就近上传的CDN.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;边缘跟中心的链路一般很好. 但也会有故障, 边缘跟边缘之间链路质量一般. 因此在处理用户写请求时, 尽可能让边缘机房eᵢ优先选择跟中心机房c同步, 当联系不到中心机房时, fallback到几个边缘机房之间达成一致完成一笔写入.&lt;/p&gt;&lt;p&gt;边缘存储的架构相比传统存储+CDN的模式, 可以让写入直接落在边缘机房, 省去了一次不必要的带宽.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在这个例子中, 我们设置中心机房c权重为2; 3个边缘机房, 权重各为1, quorum定义成带权重的quorum: 一个quorum所包含的节点权重之和至少为3.&lt;/p&gt;&lt;p&gt;假设有1笔写入出现在e₁, 如果它跟中心机房c可以直接通信, 那就通过quorum &lt;code&gt;{e₁, c}&lt;/code&gt; 直接完成一次多数派写入. 或者当时跟中心连接抖动, 那么它也可以联系e₂, e₃, 通过quorum &lt;code&gt;{e₁, e₂, e₃}&lt;/code&gt;完成一次多数派写入.&lt;/p&gt;&lt;h1&gt;总结: quorum 在分布式系统中的意义&lt;/h1&gt;&lt;p&gt;几年前在一个机房里用paxos协同起来的分布式系统, 可以看做是分布式的从0到1的一步, 解决了&lt;strong&gt;分布&lt;/strong&gt;问题.&lt;/p&gt;&lt;p&gt;分布式系统近年的发展越来越倾向于异构, 非对等, 大规模的架构共存于一个系统内. 这就对一致性算法提出了新的要求, 现代分布式系统都在尝试解决从1到100的问题: 将可用的系统打造成适应各种复杂场景的可靠系统(而不是简单的单机房几个服务器的单一场景): 系统在节点延迟/故障率/性能等变得越来越复杂的情况下, 系统设计的重心从正确性转移到调优方面, 例如如何让读写倾向于集中在高性能或更稳定的节点上, 或者让读写的流量优先最近的.&lt;/p&gt;&lt;p&gt;通过选择合适的quorum, 我们可以在这些&lt;strong&gt;复杂一些&lt;/strong&gt;的系统中, 允许业务在可用性, 延迟, 性能之间做一个权衡:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;减少消息数量/延迟, 例如像&lt;strong&gt;zookeeper&lt;/strong&gt; hierarchical quorum中的异地多活的例子, 可用性从8个9降低到7个9(假设7个9够用了:D), 换来更稳定的写入延迟: P99 延迟可以从60ms降低到30ms.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用加权重的quorum, 来实现&lt;strong&gt;边缘存储&lt;/strong&gt;这种非对等系统中的链路选择和fallback机制.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;或实现更灵活的配置变化, 例如[raft] 的成员变更算法.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;本文链接: [&lt;span&gt;https&lt;/span&gt;&lt;span&gt;://&lt;/span&gt;&lt;span&gt;blog&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;openacid&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;algo&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;quorum&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;]&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;[raft]: &lt;span&gt;https&lt;/span&gt;&lt;span&gt;://&lt;/span&gt;&lt;span&gt;raft&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;github&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;io&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;[joint consensus]: &lt;span&gt;https&lt;/span&gt;&lt;span&gt;://&lt;/span&gt;&lt;span&gt;github&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;peterbourgon&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;raft&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;blob&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;JOINT&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;CONSENSUS&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;md&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;[Classic Paxos]: &lt;span&gt;http&lt;/span&gt;&lt;span&gt;://&lt;/span&gt;&lt;span&gt;lamport&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;azurewebsites&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;net&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;pubs&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;pubs&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;paxos&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;simple&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;[Fast Paxos]: &lt;span&gt;http&lt;/span&gt;&lt;span&gt;://&lt;/span&gt;&lt;span&gt;lamport&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;azurewebsites&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;net&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;pubs&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;pubs&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;fast&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;paxos&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;[paxos的直观解释]: &lt;span&gt;https&lt;/span&gt;&lt;span&gt;://&lt;/span&gt;&lt;span&gt;blog&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;openacid&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;algo&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;paxos&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;[Leslie Lamport]: &lt;span&gt;http&lt;/span&gt;&lt;span&gt;://&lt;/span&gt;&lt;span&gt;www&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;lamport&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;org&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;[多数派读写]: &lt;span&gt;https&lt;/span&gt;&lt;span&gt;://&lt;/span&gt;&lt;span&gt;zh&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;wikipedia&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;org&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;wiki&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;Quorum&lt;/span&gt;&lt;span&gt;_(分布式系统)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;[paxos made simple]: &lt;span&gt;http&lt;/span&gt;&lt;span&gt;://&lt;/span&gt;&lt;span&gt;lamport&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;azurewebsites&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;net&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;pubs&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;pubs&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;paxos&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;simple&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;[hierarchical quorum]: &lt;span&gt;https&lt;/span&gt;&lt;span&gt;://&lt;/span&gt;&lt;span&gt;zookeeper&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;apache&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;org&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;doc&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;r3&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;zookeeperHierarchicalQuorums&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;[hierarchical-quorum.py]: /post-res/quorum/hierarchical-quorum.py&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;[zookeeper]: &lt;span&gt;https&lt;/span&gt;&lt;span&gt;://&lt;/span&gt;&lt;span&gt;zookeeper&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;apache&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;org&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ziaRl59xuuYibDH4CABo9riaI6mS6cJc5FxoFibbLMuVdYxhgqW4YuhOnJBMIUMcJczVMT7LQncf6YAWwwC6Ic0rJg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.4125&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;本文链接: [&lt;/span&gt;&lt;span&gt;https&lt;/span&gt;&lt;span&gt;://&lt;/span&gt;&lt;span&gt;blog&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;openacid&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;algo&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;quorum&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>