<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3cf12a636de5a263b8fb5d6e19b354dc</guid>
<title>Redis 技术专题系列之数据同步持久化机制</title>
<link>https://toutiao.io/k/5wy35j7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                                        &lt;h1&gt;📚背景介绍&lt;/h1&gt; 
&lt;h4&gt;✒️ Redis数据恢复的介绍&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;通常情况下redis的数据全部存储在内存中，数据库一旦故障发生重启数据会全部丢失&lt;/strong&gt;，&lt;strong&gt;持久化功能在于能够有效地避免因进程退出造成的数据丢失问题&lt;/strong&gt;，&lt;strong&gt;在下次重启时利用之前持久化的文件即可实现数据恢复。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;✒️ Redis高可用的功能基础&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;即使是在redis cluster或者redis sentinel模式下主从同步数据的恢复仍然需要一段时间。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;✒️ Redis实际场景的分析&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;开启Redis持久化之后，数据将存放到磁盘中，数据库执行增量同步的时间要远小于全量同步&lt;/strong&gt;。&lt;strong&gt;在生产环境下故障的数据恢复有着非常重要的作用！&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-7747c7fe4ca5a234bc0b46a05d1af84a955.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h1&gt;📚前提概要&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;Redis是出了名的速度快，那是因为在内存中进行数据存储和操作；如果仅仅是在内存中进行数据存储，那就会导致以下问题&lt;/strong&gt;：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;数据随进程退出而消失&lt;/strong&gt;：&lt;strong&gt;当服务器断电或Redis Server进程退出时，内存肯定随之释放，最后数据也会丢失&lt;/strong&gt;；&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;有些小伙伴认为只是作为缓存，数据没有了，重新从数据库中读取放在里面即可，试想，如果是高并发场景，数据库岂不是压力很大；&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;重要数据无法恢复：数据丢失之后无法进行恢复，对于一些重要的数据，只是存在Redis中，而没有存在关系型数据库，如果数据丢失便不可恢复；比如刷礼品排行榜，如果数据丢失，用户肯定不愿意的&lt;/strong&gt;；&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;对于Redis持久化在工作中和面试过程中是一个很重要的技术点，必用必考，接下来详细说说Redis持久化；&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;h1&gt;📚 基本介绍&lt;/h1&gt; 
&lt;h2&gt;✒️ Redis持久化有两种方案&lt;/h2&gt; 
 
&lt;h2&gt;✒️ Redis持久化机制实现&lt;/h2&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;strong&gt;Redis是基于内存进行操作运算，如果不持久化数据再重启服务时会导致数据丢失&lt;/strong&gt;。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;开启Redis持久化功能后，数据会保存到磁盘中。当redis重启后，可以从磁盘中恢复数据。&lt;/strong&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;h3&gt;✒️ RDB快照（snapshot）&lt;/h3&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-d31583957047ebabeb0f96fcd2e348d13ae.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h3&gt;✒️ RDB持久化方式&lt;/h3&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;RDB持久化把当前进程数据生成快照（.rdb）文件保存到硬盘的过程，有手动触发和自动触发。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;✒️ RDB手动触发&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;手动触发有save和bgsave两命令&lt;/strong&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h5&gt;✒️ save命令&lt;/h5&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;执行完成时候如果存在老的RDB文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-a08822d0dbe6a331cfa1f573c50e1251760.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;在执行redis-cli shutdown关闭redis服务时，如果没有开启AOF持久化，自动执行save&lt;/strong&gt;。&lt;/p&gt; 
&lt;h5&gt;✒️ bgsave命令&lt;/h5&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Redis主进程fork一个子进程来创建临时RDB存储文件&lt;/strong&gt;，&lt;strong&gt;创建文件完成后对这个临时文件rename替换原先的RDB文件&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;RDB文件是一个单文件很适合数据的容灾备份与恢复&lt;/strong&gt;，&lt;strong&gt;通过RDB文件恢复数据库耗时较短&lt;/strong&gt;，&lt;strong&gt;通常1G的快照文件载入内存只需20s左右&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-4487fc30e2f75205c44b70c718137d07cca.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h5&gt;✒️ bgsave命令和save命令&lt;/h5&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th&gt;命令名称&lt;/th&gt; 
   &lt;th&gt;save&lt;/th&gt; 
   &lt;th&gt;bgsave&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt;IO类型&lt;/td&gt; 
   &lt;td&gt;同步&lt;/td&gt; 
   &lt;td&gt;异步&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;是否阻塞&lt;/td&gt; 
   &lt;td&gt;是&lt;/td&gt; 
   &lt;td&gt;否&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;复杂度&lt;/td&gt; 
   &lt;td&gt;O(n)&lt;/td&gt; 
   &lt;td&gt;O(n)&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;优点&lt;/td&gt; 
   &lt;td&gt;不会耗费额外内存&lt;/td&gt; 
   &lt;td&gt;不阻塞客户端访问&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;缺点&lt;/td&gt; 
   &lt;td&gt;阻塞客户端访问&lt;/td&gt; 
   &lt;td&gt;耗费多余客户端&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p&gt;&lt;strong&gt;在指定时间间隔内将内存中的数据库记录集dump到磁盘上&lt;/strong&gt;，RDB是默认的持久化方式，&lt;strong&gt;这种方式是就是将内存中数据以快照的方式写入到二进制文件中&lt;/strong&gt;,&lt;strong&gt;默认的文件名为dump.rdb&lt;/strong&gt;。&lt;/p&gt; 
&lt;h4&gt;✒️ RDB自动触发&lt;/h4&gt; 
&lt;p&gt;自动触发是由我们的配置文件来完成的，自动触发bgsave。&lt;/p&gt; 
&lt;h5&gt;✒️ 配置方法&lt;/h5&gt; 
 
&lt;h6&gt;✒️ 60秒内至少有10000个键被修改&lt;/h6&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;save 900 1&lt;/strong&gt; #在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;save 300 10&lt;/strong&gt; #在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;save 60 10000&lt;/strong&gt; #在60秒(1分钟)之后，如果至少有10000个key发生变化，dump内存快照。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;关闭RDB方式持久化只需要将所有save保存策略注释掉即可&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h5&gt;✒️ RDB持久化命令&lt;/h5&gt; 
&lt;ul&gt; 
 &lt;li&gt;命令：&lt;strong&gt;config set dir /usr/local&lt;/strong&gt; //设置rdb文件保存路径&lt;/li&gt; 
 &lt;li&gt;备份：&lt;strong&gt;bgsave&lt;/strong&gt; //将dump.rdb保存到usr/local下&lt;/li&gt; 
 &lt;li&gt;恢复：&lt;strong&gt;将dump.rdb放到redis安装目录与redis.conf同级目录，重启redis即可&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;save命令是同步命令，bgsave命令是异步命令，会从redis主进程fork出一个子进程去处理，每次命令执行后会新生成一个rdb文件并覆盖原来的文件。&lt;/strong&gt;&lt;/p&gt; 
&lt;h3&gt;✒️ 修改配置&lt;/h3&gt; 
 
&lt;h2&gt;✒️ RDB的优缺点&lt;/h2&gt; 
&lt;h3&gt;✒️ 优点&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;（恢复速度快，适合大数量恢复机制）&lt;strong&gt;RDB保存的是某一个时间点的内存快照，非常适合灾难恢复。在恢复大数据集时速度快，1G的RDB数据恢复耗时大概20s，比AOF要快的多&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;✒️ 缺点&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;（间隔时间大并且丢失数据较为多）&lt;strong&gt;RDB通过触发某个时间点条件生成快照文件，如果5分钟保存一次的话，一旦发生故障会丢失好几分钟的数据&lt;/strong&gt;，&lt;strong&gt;配置不同的保存点让RDB至少可以保存5分钟的数据&lt;/strong&gt;。因此，如果Redis由于任何原因没有正确关闭而停止工作，你应该做好好丢失最近几分钟的数据&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;（CPU资源占用过大、内存资源占用过多）&lt;strong&gt;fork子进程消耗内存和CPU&lt;/strong&gt;，RDB经常需要 &lt;strong&gt;fork()&lt;/strong&gt; 才能使用子进程在磁盘上持久化。如果数据集很大，&lt;strong&gt;fork()可能很耗时，如果数据集非常大，CPU性能不好&lt;/strong&gt;，&lt;strong&gt;可能会导致Redis停止为客户机服务几毫秒甚至一秒钟。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;✒️ AOF(append-only file)&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-dff29886ab8ab80fa9edd079cb360ff1ac1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;由于RDB快照方式的缺点，如果redis由于某些原因导致机器故障时，则会丢失最近几分钟写入的数据，而AOF持久化方式&lt;/strong&gt;，则通过追加的方式将操作命令添加到&lt;strong&gt;appendonly.aof&lt;/strong&gt;文件中，存储的文件是RESP协议指令文件。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-b17e8e5cb10a3fb9b41fd53b2e809e896c2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h3&gt;✒️ 配置方法&lt;/h3&gt; 
 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;配置好后，redis每次修改操作的命令会追加到AOF末尾，当redis重启后会重新执行AOF里的命令达到重建缓存数据集的目的，配置刷命令的频率&lt;/strong&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;appendfsync always&lt;/strong&gt; ：&lt;strong&gt;每次有新命令追加到AOF文件时就执行一次fsync&lt;/strong&gt;，非常慢但最安全。服务器在每执行一个事件就把AOF缓冲区的内容强制性的写入硬盘上的AOF文件里，保证了数据持久化的完整性，效率是最慢的但最安全的；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;appendfsync everysec&lt;/strong&gt; # &lt;strong&gt;服务端每隔一秒才会进行一次文件同步把内存缓冲区里的AOF缓存数据真正写入AOF文件里，兼顾了效率和完整性，极端情况服务器宕机只会丢失一秒内对Redis数据库的写操作；默认方式&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;appendfsync no&lt;/strong&gt; # &lt;strong&gt;从不fsync&lt;/strong&gt;，&lt;strong&gt;交由操作系统处理，速度快，表示默认系统的缓存区写入磁盘的机制，不做程序强制，数据安全性和完整性差一些。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;hr/&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;bgrewriteaof：后台运作重写机制&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;auto-aof-rewrite-min-size 64mb&lt;/strong&gt; # &lt;strong&gt;aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;auto-aof-rewrite-percentage 100&lt;/strong&gt; # &lt;strong&gt;aof文件自上一次重写后文件大小增长了100%，则再次触发重写执行bgrewriteaof命令可以手动重写aof文件，AOF重写redis会fork出一个子进程去做，不会对redis正常命令处理有太多影响。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;hr/&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;redis启动时如果既有rdb文件又有aof文件则优先选择aof文件恢复数据，因为aof一般来说数据更全一点。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;全量同步(RDB)：每天定时（避开高峰期）或者采用一个周期实现将数据拷贝到一个地方&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;增量同步(AOF)：比如采用对行为的操作实现对数据的同步。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;增量同步比全量同步更加消耗服务器的内存，但是能够更加的保证数据的同步&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;📚 AOF的优缺点&lt;/h1&gt; 
&lt;h2&gt;✒️ 优点&lt;/h2&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;AOF是通过保存Redis写操作的命令来实现持久化，使用AOF来持久化，Redis数据的安全性将大幅提高，异常宕机情况下最多丢失1s的数据。AOF文件记录了redis的写操作，格式清晰，易于理解和修改，利于数据的重建。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;AOF日志是一个只附加的日志，因此如果断电，就不会出现查找或损坏问题。即使日志由于某种原因（磁盘已满或其他原因）以半写的命令结束，redis check aof工具也可以轻松地修复它。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;当AOF太大时，Redis能够在后台自动重写AOF。重写是完全安全的，因为当Redis继续附加到旧文件时，一个全新的文件会生成，只需创建当前数据集所需的最少操作集，一旦第二个文件就绪，Redis就会切换这两个文件并开始附加到新文件中。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;AOF以易于理解和解析的格式包含所有操作的日志。你甚至可以轻松导出AOF文件。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h2&gt;✒️ 缺点&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;AOF文件通常比相同数据集的等效RDB文件大&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;根据具体的fsync策略，AOF可能比RDB慢。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;使用建议&lt;/h3&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;Redis默认开启了持久化功能，而且是全量RDB的，缺点是服务器宕机后可能会造成数据丢失。 建议最好还是搭配使用aof的everysec，&lt;strong&gt;既能够保证数据的同步,效率也还可以，但是会存在丢失一秒数据的可能性，就算丢失也关系不大&lt;/strong&gt;，因为数据库中已经存在了数据。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h2&gt;混合持久化&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-51c15feb96051f9791369fc4aec0c0515d6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;如果开启了混合持久化，AOF在重写时，不再是单纯将内存数据转换为RESP命令写入AOF文件，而是将重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容和增量的AOF修改内存数据的命令存在一起，都写入新的AOF文件，新的AOF文件会原子覆盖掉原来的AOF文件&lt;/strong&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h3&gt;开启混合持久化命令&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;aof-use-rdb-preamble yes # 开启混合持久化&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;appendonly.aof文件中同时保存着RDB和AOF两种格式的数据&lt;/strong&gt;&lt;/p&gt; 
&lt;h4&gt;RDB、AOF、混合持久化对比&lt;/h4&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-8937fc5d21bbb6eac0d3905d3a66005e120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ee329d904956a6586a61b8632b65d874</guid>
<title>实时计算框架：Flink 集群搭建与运行机制</title>
<link>https://toutiao.io/k/qf07xgk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1&gt;&lt;span&gt;一、Flink概述&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、基础简介&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Flink是一个框架和分布式处理引擎，用于对无界和有界数据流进行有状态计算。Flink被设计在所有常见的集群环境中运行，以内存执行速度和任意规模来执行计算。主要特性包括：批流一体化、精密的状态管理、事件时间支持以及精确一次的状态一致性保障等。Flink不仅可以运行在包括YARN、Mesos、Kubernetes在内的多种资源管理框架上，还支持在裸机集群上独立部署。在启用高可用选项的情况下，它不存在单点失效问题。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBJkwQfW06UITaIeUib3yy1nlcHibGnUbq5VIqSAPm7N7GB7RLEZkmELZ0k6rl8MpLCENQFnmEsJvzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里要说明两个概念：&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、应用场景&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Data Driven&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.29375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBJkwQfW06UITaIeUib3yy1nMGCKSuWgIZJY0lb0zHMGdIcSjXxSEhEPULCcJMCibzwmqKibJa4Ub8dQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;事件驱动型应用无须查询远程数据库，本地数据访问使得它具有更高的吞吐和更低的延迟，以反欺诈案例来看，DataDriven把处理的规则模型写到DatastreamAPI中，然后将整个逻辑抽象到Flink引擎，当事件或者数据流入就会触发相应的规则模型，一旦触发规则中的条件后，DataDriven会快速处理并对业务应用进行通知。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Data Analytics&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBJkwQfW06UITaIeUib3yy1nPh29LjWATr5mVamMl1kUFicZhvznOdp9OBLSYb98XM9wlBGykuhEcPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;和批量分析相比，由于流式分析省掉了周期性的数据导入和查询过程，因此从事件中获取指标的延迟更低。不仅如此，批量查询必须处理那些由定期导入和输入有界性导致的人工数据边界，而流式查询则无须考虑该问题，Flink为持续流式分析和批量分析都提供了良好的支持，实时处理分析数据，应用较多的场景如实时大屏、实时报表。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Data Pipeline&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBJkwQfW06UITaIeUib3yy1ngXfIESX1UGZBYHQFv7oMfec2YwwgJ2cZ3Okwe14j7O332IY1ic2aSIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;与周期性的ETL作业任务相比，持续数据管道可以明显降低将数据移动到目的端的延迟，例如基于上游的StreamETL进行实时清洗或扩展数据，可以在下游构建实时数仓，确保数据查询的时效性，形成高时效的数据查询链路，这种场景在媒体流的推荐或者搜索引擎中十分常见。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、环境部署&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、安装包管理&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;[root@hop01 opt]&lt;/span&gt;# &lt;span&gt;tar&lt;/span&gt; &lt;span&gt;-zxvf&lt;/span&gt; &lt;span&gt;flink-1&lt;/span&gt;&lt;span&gt;.7&lt;/span&gt;&lt;span&gt;.0-bin-hadoop27-scala_2&lt;/span&gt;&lt;span&gt;.11&lt;/span&gt;&lt;span&gt;.tgz&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[root@hop02 opt]&lt;/span&gt;# &lt;span&gt;mv&lt;/span&gt; &lt;span&gt;flink-1&lt;/span&gt;&lt;span&gt;.7&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt; &lt;span&gt;flink1&lt;/span&gt;&lt;span&gt;.7&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;2、集群配置&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;管理节点&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 opt]&lt;span&gt;# cd /opt/flink1.7/conf&lt;/span&gt;&lt;br/&gt;[root@hop01 conf]&lt;span&gt;# vim flink-conf.yaml&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;jobmanager.rpc.address: hop01&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;分布节点&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 conf]&lt;span&gt;# vim slaves&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;hop02&lt;br/&gt;hop03&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;两个配置同步到所有集群节点下面。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、启动与停止&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/opt/flink1.7/bin/&lt;span&gt;start&lt;/span&gt;-cluster.sh&lt;br/&gt;/opt/flink1&lt;span&gt;.7&lt;/span&gt;/&lt;span&gt;bin&lt;/span&gt;/&lt;span&gt;stop&lt;/span&gt;-cluster.sh&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动日志：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 conf]&lt;span&gt;# /opt/flink1.7/bin/start-cluster.sh&lt;/span&gt;&lt;br/&gt;Starting cluster.&lt;br/&gt;Starting standalonesession daemon &lt;span&gt;on&lt;/span&gt; host hop01.&lt;br/&gt;Starting taskexecutor daemon &lt;span&gt;on&lt;/span&gt; host hop02.&lt;br/&gt;Starting taskexecutor daemon &lt;span&gt;on&lt;/span&gt; host hop03.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;4、Web界面&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;访问：&lt;code&gt;http://hop01:8081/&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBJkwQfW06UITaIeUib3yy1nH54vjEkicM2IC2icxFIAyd3wFdBic71icjUicMprymSoFcpjVj0POnicVZDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、开发入门案例&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、数据脚本&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;分发一个数据脚本到各个节点：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;/var/flink/&lt;span&gt;test&lt;/span&gt;/word.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;2、引入基础依赖&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;这里基于Java写的基础案例。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.flink&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;flink-java&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.7.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.flink&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;flink-streaming-java_2.11&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.7.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;3、读取文件数据&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;这里直接读取文件中的数据，经过程序流程分析出每个单词出现的次数。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WordCount&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 读取文件数据&lt;/span&gt;&lt;br/&gt;        readFile () ;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;readFile&lt;/span&gt; &lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 1、执行环境创建&lt;/span&gt;&lt;br/&gt;        ExecutionEnvironment environment = ExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 2、读取数据文件&lt;/span&gt;&lt;br/&gt;        String filePath = &lt;span&gt;&quot;/var/flink/test/word.txt&quot;&lt;/span&gt; ;&lt;br/&gt;        DataSet&amp;lt;String&amp;gt; inputFile = environment.readTextFile(filePath);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 3、分组并求和&lt;/span&gt;&lt;br/&gt;        DataSet&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; wordDataSet = inputFile.flatMap(&lt;span&gt;new&lt;/span&gt; WordFlatMapFunction(&lt;br/&gt;        )).groupBy(&lt;span&gt;0&lt;/span&gt;).sum(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 4、打印处理结果&lt;/span&gt;&lt;br/&gt;        wordDataSet.print();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 数据读取个切割方式&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WordFlatMapFunction&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;FlatMapFunction&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Tuple2&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Integer&lt;/span&gt;&amp;gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;flatMap&lt;/span&gt;&lt;span&gt;(String input, Collector&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; collector)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;            String[] wordArr = input.split(&lt;span&gt;&quot;,&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (String word : wordArr) {&lt;br/&gt;                collector.collect(&lt;span&gt;new&lt;/span&gt; Tuple2&amp;lt;&amp;gt;(word, &lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4806201550387597&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBJkwQfW06UITaIeUib3yy1n0fOJ6MU6WJAt47WiaNeJTwRibUUvCSnuu4UaWW8v1BJniaiaMckYQ6nMEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;774&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;4、读取端口数据&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在hop01服务上创建一个端口，并模拟一些数据发送到该端口：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 ~]&lt;span&gt;# nc -lk 5566&lt;/span&gt;&lt;br/&gt;c++,java&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过Flink程序读取并分析该端口的数据内容：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WordCount&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 读取端口数据&lt;/span&gt;&lt;br/&gt;        readPort ();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;readPort&lt;/span&gt; &lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 1、执行环境创建&lt;/span&gt;&lt;br/&gt;        StreamExecutionEnvironment environment = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 2、读取Socket数据端口&lt;/span&gt;&lt;br/&gt;        DataStreamSource&amp;lt;String&amp;gt; inputStream = environment.socketTextStream(&lt;span&gt;&quot;hop01&quot;&lt;/span&gt;, &lt;span&gt;5566&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 3、数据读取个切割方式&lt;/span&gt;&lt;br/&gt;        SingleOutputStreamOperator&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; resultDataStream = inputStream.flatMap(&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; FlatMapFunction&amp;lt;String, Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt;()&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;flatMap&lt;/span&gt;&lt;span&gt;(String input, Collector&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; collector)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                String[] wordArr = input.split(&lt;span&gt;&quot;,&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; (String word : wordArr) {&lt;br/&gt;                    collector.collect(&lt;span&gt;new&lt;/span&gt; Tuple2&amp;lt;&amp;gt;(word, &lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }).keyBy(&lt;span&gt;0&lt;/span&gt;).sum(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 4、打印分析结果&lt;/span&gt;&lt;br/&gt;        resultDataStream.print();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 5、环境启动&lt;/span&gt;&lt;br/&gt;        environment.execute();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;&lt;span&gt;四、运行机制&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.57890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBJkwQfW06UITaIeUib3yy1nt4DVlGFdZjnwnOOp2WKHGaNic26HSvYAgQiboXp43vQ2krznubQyKjuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;FlinkClient&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;客户端用来准备和发送数据流到JobManager节点，之后根据具体需求，客户端可以直接断开连接，或者维持连接状态等待任务处理结果。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;JobManager&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在Flink集群中，会启动一个JobManger节点和至少一个TaskManager节点，JobManager收到客户端提交的任务后，JobManager会把任务协调下发到具体的TaskManager节点去执行，TaskManager节点将心跳和处理信息发送给JobManager。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;TaskManager&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;任务槽（slot）是TaskManager中最小的资源调度单位，在启动的时候就设置好了槽位数，每个槽位能启动一个Task，接收JobManager节点部署的任务，并进行具体的分析处理。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;五、源代码地址&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https:&lt;span&gt;//github.com/cicadasmile/big-data-parent&lt;/span&gt;&lt;br/&gt;GitEE·地址&lt;br/&gt;https:&lt;span&gt;//gitee.com/cicadasmile/big-data-parent&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBCuF3zfJnqPKpUia4wfn1FUtTHpxxkR5HvbicPgOjibPicX0goMOkny1NdkLAJvBaqrYh3UdwMjiaDQMA/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累是一个孤独且枯燥的过程&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>798a3c075d50adb791b541e23e944d48</guid>
<title>为什么 Go map 和 slice 是非线性安全的？</title>
<link>https://toutiao.io/k/euwldfo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初入 Go 语言的大门，有不少的小伙伴会快速的 3 天精通 Go，5 天上手项目，14 天上线业务迭代，21 天排查、定位问题，顺带捎个反省报告。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中最常见的初级错误，Go 面试较最爱问的问题之一：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1726315789473684&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4jmWIKV9zRh7fFAeicnSpYHljzkK4qPzpxlYcPZBWLAQGskD5DIba8PDQgAOiaH4Pol3uVZjkgYJdqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;950&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么在 Go 语言里，map 和 slice 不支持并发读写，也就是是非线性安全的，为什么不支持？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;见招拆招后，紧接着就会开始讨论如何让他们俩 ”冤家“ 支持并发读写？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们这篇文章就来理一理，了解其前因后果，一起吸鱼学懂 Go 语言。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;非线性安全的例子&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;slice&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用多个 goroutine 对类型为 slice 的变量进行操作，看看结果会变的怎么样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; s []&lt;span&gt;string&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;9999&lt;/span&gt;; i++ {&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   s = &lt;span&gt;append&lt;/span&gt;(s, &lt;span&gt;&quot;脑子进煎鱼了&quot;&lt;/span&gt;)&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;进了 %d 只煎鱼&quot;&lt;/span&gt;, &lt;span&gt;len&lt;/span&gt;(s))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 第一次执行&lt;br/&gt;进了 5790 只煎鱼&lt;br/&gt;// 第二次执行&lt;br/&gt;进了 7370 只煎鱼&lt;br/&gt;// 第三次执行&lt;br/&gt;进了 6792 只煎鱼&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你会发现无论你执行多少次，每次输出的值大概率都不会一样。也就是追加进 slice 的值，出现了覆盖的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此在循环中所追加的数量，与最终的值并不相等。且这种情况，是不会报错的，是一个出现率不算高的隐式问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个产生的主要原因是程序逻辑本身就有问题，同时读取到相同索引位，自然也就会产生覆盖的写入了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;map&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样针对 map 也如法炮制一下。重复针对类型为 map 的变量进行写入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;99&lt;/span&gt;; i++ {&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   s[&lt;span&gt;&quot;煎鱼&quot;&lt;/span&gt;] = &lt;span&gt;&quot;吸鱼&quot;&lt;/span&gt;&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;进了 %d 只煎鱼&quot;&lt;/span&gt;, &lt;span&gt;len&lt;/span&gt;(s))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;fatal error: concurrent map writes&lt;br/&gt;&lt;br/&gt;goroutine 18 [running]:&lt;br/&gt;runtime.throw(0x10cb861, 0x15)&lt;br/&gt;        /usr/&lt;span&gt;local&lt;/span&gt;/Cellar/go/1.16.2/libexec/src/runtime/panic.go:1117 +0x72 fp=0xc00002e738 sp=0xc00002e708 pc=0x1032472&lt;br/&gt;runtime.mapassign_faststr(0x10b3360, 0xc0000a2180, 0x10c91da, 0x6, 0x0)&lt;br/&gt;        /usr/&lt;span&gt;local&lt;/span&gt;/Cellar/go/1.16.2/libexec/src/runtime/map_faststr.go:211 +0x3f1 fp=0xc00002e7a0 sp=0xc00002e738 pc=0x1011a71&lt;br/&gt;main.main.func1(0xc0000a2180)&lt;br/&gt;        /Users/eddycjy/go-application/awesomeProject/main.go:9 +0x4c fp=0xc00002e7d8 sp=0xc00002e7a0 pc=0x10a474c&lt;br/&gt;runtime.goexit()&lt;br/&gt;        /usr/&lt;span&gt;local&lt;/span&gt;/Cellar/go/1.16.2/libexec/src/runtime/asm_amd64.s:1371 +0x1 fp=0xc00002e7e0 sp=0xc00002e7d8 pc=0x1063fe1&lt;br/&gt;created by main.main&lt;br/&gt;        /Users/eddycjy/go-application/awesomeProject/main.go:8 +0x55&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好家伙，程序运行会直接报错。并且是 Go 源码调用 &lt;code&gt;throw&lt;/code&gt; 方法所导致的致命错误，也就是说 Go 进程会中断。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不得不说，这个并发写 map 导致的 &lt;code&gt;fatal error: concurrent map writes&lt;/code&gt; 错误提示。我有一个朋友，已经看过少说几十次了，不同组，不同人...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是个日经的隐式问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;如何支持并发读写&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;对 map 上锁&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上我们仍然存在并发读写 map 的诉求（程序逻辑决定），因为 Go 语言中的 goroutine 实在是太方便了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像是一般写爬虫任务时，基本会用到多个 goroutine，获取到数据后再写入到 map 或者 slice 中去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 官方在 Go maps in action 中提供了一种简单又便利的方式来实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; counter = &lt;span&gt;struct&lt;/span&gt;{&lt;br/&gt;    sync.RWMutex&lt;br/&gt;    m &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;br/&gt;}{m: &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;)}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这条语句声明了一个变量，它是一个匿名结构（struct）体，包含一个原生和一个嵌入读写锁 &lt;code&gt;sync.RWMutex&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要想从变量中中读出数据，则调用读锁：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;counter.RLock()&lt;br/&gt;n := counter.m[&lt;span&gt;&quot;煎鱼&quot;&lt;/span&gt;]&lt;br/&gt;counter.RUnlock()&lt;br/&gt;fmt.Println(&lt;span&gt;&quot;煎鱼:&quot;&lt;/span&gt;, n)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要往变量中写数据，则调用写锁：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;counter.Lock()&lt;br/&gt;counter.m[&lt;span&gt;&quot;煎鱼&quot;&lt;/span&gt;]++&lt;br/&gt;counter.Unlock()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是一个最常见的 Map 支持并发读写的方式了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;sync.Map&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然有了 Map+Mutex 的极简方案，但是也仍然存在一定问题。那就是在 map 的数据量非常大时，只有一把锁（Mutex）就非常可怕了，一把锁会导致大量的争夺锁，导致各种冲突和性能低下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的解决方案是分片化，将一个大 map 分成多个区间，各区间使用多个锁，这样子锁的粒度就大大降低了。不过该方案实现起来很复杂，很容易出错。因此 Go 团队到比较为止暂无推荐，而是采取了其他方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方案就是在 Go1.9 起支持的 &lt;code&gt;sync.Map&lt;/code&gt;，其支持并发读写 map，起到一个补充的作用。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;具体介绍&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言的 &lt;code&gt;sync.Map&lt;/code&gt; 支持并发读写 map，采取了 “空间换时间” 的机制，冗余了两个数据结构，分别是：read 和 dirty，减少加锁对性能的影响：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Map &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; mu Mutex&lt;br/&gt; read atomic.Value &lt;span&gt;// readOnly&lt;/span&gt;&lt;br/&gt; dirty &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;interface&lt;/span&gt;{}]*entry&lt;br/&gt; misses &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其是专门为 &lt;code&gt;append-only&lt;/code&gt; 场景设计的，也就是适合读多写少的场景。这是他的优点之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若出现写多/并发多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降。这是他的重大缺点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提供了以下常用方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *Map)&lt;/span&gt; &lt;span&gt;Delete&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *Map)&lt;/span&gt; &lt;span&gt;Load&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;(value &lt;span&gt;interface&lt;/span&gt;{}, ok &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *Map)&lt;/span&gt; &lt;span&gt;LoadAndDelete&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;(value &lt;span&gt;interface&lt;/span&gt;{}, loaded &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *Map)&lt;/span&gt; &lt;span&gt;LoadOrStore&lt;/span&gt;&lt;span&gt;(key, value &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;(actual &lt;span&gt;interface&lt;/span&gt;{}, loaded &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *Map)&lt;/span&gt; &lt;span&gt;Range&lt;/span&gt;&lt;span&gt;(f &lt;span&gt;func&lt;/span&gt;(key, value &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *Map)&lt;/span&gt; &lt;span&gt;Store&lt;/span&gt;&lt;span&gt;(key, value &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Delete：删除某一个键的值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Load：返回存储在 map 中的键的值，如果没有值，则返回 nil。ok 结果表示是否在 map 中找到了值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LoadAndDelete：删除一个键的值，如果有的话返回之前的值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LoadOrStore：如果存在的话，则返回键的现有值。否则，它存储并返回给定的值。如果值被加载，加载的结果为 true，如果被存储，则为 false。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Range：递归调用，对 map 中存在的每个键和值依次调用闭包函数 &lt;code&gt;f&lt;/code&gt;。如果 &lt;code&gt;f&lt;/code&gt; 返回 false 就停止迭代。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Store：存储并设置一个键的值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际运行例子如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; m sync.Map&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;//写入&lt;/span&gt;&lt;br/&gt; data := []&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;煎鱼&quot;&lt;/span&gt;, &lt;span&gt;&quot;咸鱼&quot;&lt;/span&gt;, &lt;span&gt;&quot;烤鱼&quot;&lt;/span&gt;, &lt;span&gt;&quot;蒸鱼&quot;&lt;/span&gt;}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; i++ {&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   m.Store(i, data[i])&lt;br/&gt;  }(i)&lt;br/&gt; }&lt;br/&gt; time.Sleep(time.Second)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//读取&lt;/span&gt;&lt;br/&gt; v, ok := m.Load(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;Load: %v, %v\n&quot;&lt;/span&gt;, v, ok)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//删除&lt;/span&gt;&lt;br/&gt; m.Delete(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//读或写&lt;/span&gt;&lt;br/&gt; v, ok = m.LoadOrStore(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;吸鱼&quot;&lt;/span&gt;)&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;LoadOrStore: %v, %v\n&quot;&lt;/span&gt;, v, ok)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//遍历&lt;/span&gt;&lt;br/&gt; m.Range(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(key, value &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  fmt.Printf(&lt;span&gt;&quot;Range: %v, %v\n&quot;&lt;/span&gt;, key, value)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; })&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Load: 煎鱼, &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;LoadOrStore: 吸鱼, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;Range: 0, 煎鱼&lt;br/&gt;Range: 1, 吸鱼&lt;br/&gt;Range: 3, 蒸鱼&lt;br/&gt;Range: 2, 烤鱼&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么不支持&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go Slice 的话，主要还是索引位覆写问题，这个就不需要纠结了，势必是程序逻辑在编写上有明显缺陷，自行改之就好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但 Go map 就不大一样了，很多人以为是默认支持的，一个不小心就翻车，这么的常见。那凭什么 Go 官方还不支持，难不成太复杂了，性能太差了，到底是为什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因如下（via @go faq）：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;典型使用场景：map 的典型使用场景是不需要从多个 goroutine 中进行安全访问。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非典型场景（需要原子操作）：map 可能是一些更大的数据结构或已经同步的计算的一部分。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能场景考虑：若是只是为少数程序增加安全性，导致 map 所有的操作都要处理 mutex，将会降低大多数程序的性能。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;汇总来讲，就是 Go 官方在经过了长时间的讨论后，认为 Go map 更应适配典型使用场景，而不是为了小部分情况，导致大部分程序付出代价（性能），决定了不支持。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在今天这篇文章中，我们针对 Go 语言中的 map 和 slice 进行了基本的介绍，也对不支持并发读者的场景进行了模拟展示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时也针对业内常见的支持并发读写的方式进行了讲述，最后分析了不支持的原因，让我们对整个前因后果有了一个完整的了解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你&lt;strong&gt;在日常是否有遇到过 Go 语言中非线性安全的问题呢，欢迎你在评论区留言和大家一起交流&lt;/strong&gt;！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bef0e5c59ffb5a771398e00c9f78808d</guid>
<title>硬着头皮写，硬着头皮搞：一个服务一个数据库模式（下）</title>
<link>https://toutiao.io/k/ur8a54x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;这个标题是不是很拗口？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个服务一个数据库的(上)和(中)翻车了，既然开了头，硬着头皮也得把(下)写完。这是第一个硬着头皮。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我和团队搞微服务比较早，当了小白鼠，一路坎坷，可以说是硬着头皮坚持下来的。这是第二个硬着头皮。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;闲话少叙，正文开始。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在我最初接触微服务的很长一段时间里，有两类问题都困扰着我和团队，这是让我印象最深的两类问题：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;没有配合微服务理念的团队&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;没有配合微服务理念的基础设施&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;后来，在和一些搞了微服务的同行多次交流后，发现他们当初也面临和我类似的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这次就写写我最早搞微服务遇到的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有些问题放到现在来说，已经有解决办法了，已经算不上问题了。但是无论怎样，这些问题如果能提前意识到，早做准备，会为将来搞微服务的同行们省下许多的力气。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，这篇文章我会着重谈下这两类问题。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、没有配合微服务理念的团队&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;当年，我还是一个小开发团队的组长，组里将近 10 个程序员，维护着一个庞大的单体系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那时微服务刚出来不久，各种评估后，我们认为把系统拆分成微服务可以带来更大的好处。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，对于微服务中提到的团队自治这点，由于当时的职位和经验限制，也无法贯彻这一理念，结果，最后就是把自己折腾了底儿掉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在谈团队自治的问题之前，我先说说拆分微服务的时候，我们当时的整体交付流程是什么样的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整体流程很简单，业务提需求给我们开发团队，然后开发团队收到业务需求后开发、测试，最后上线。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们上线流程也比较传统，先是开发人员把应用打包然后上传到一个运维团队规定的路径，然后才由运维团队发布到生产服务器上。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38275193798449614&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KTHZsotDic1AOEcTxNSucuj5L1Vviaf8acktOOErrMJ8vrKOsca9Uice0Zjokguw80e2ylMTGthJYKQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2064&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;这种模式开始没什么大问题，可是随着我们拆分服务越拆越多，问题出现了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们负责的系统很重要，本身上线比较频繁。再搞了微服务之后，因为服务多了，服务器也多了，使得上线部署变得更繁琐。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这逐渐导致运维团队本就不富余的人手更加捉襟见肘，他们只能加班。结果就是，996 成了家常便饭，运维人员对此颇有怨言。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;频繁上线不但连累了运维兄弟，还拖累了其他团队——由于运维人手不足，又导致了我们团队和其他团队项目上线经常出现冲突。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;冲突发生后，因为我们的项目是公司核心项目，很自然的，优先级我们会占一些便宜。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其他团队的上线只能不断的调整去和我们错开，或者加班等我们上线后，再由运维安排他们的项目上线。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可见，在我搞微服务初期，微服务划分的快速迭代始终因为团队划分和微服务本身的理念不匹配，导致处处受挫。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你要全权负责一套微服务项目的时候，一定要万分注意。因为你本身的团队和微服务理念中的团队自治是不匹配的，这会导致你自己微服务项目的维护出现各种各样问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于这类问题，我建议在初期你就要有所考虑。因为这个风险，或许是技术人员不可控的。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二、没有配合微服务理念的基础设施&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;在一开始，由于我们的微服务是从单体项目逐渐剥离开来的，所以，在这个时候，服务只有 3、4 个。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是随着对业务理解越来越深入，开发人员也对服务落地越来越熟悉，服务划分的速度也越来越快了。在很短的时间内，服务一下子从三四个，猛增为了近二十个&lt;/span&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5216251638269986&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KTHZsotDic1AOEcTxNSucuj5Lgw2MgbAicrOiaxOtRDIkGYiapPJJK4vuMeDMaVBl6Yy2via9OYGwmKo7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;763&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;这时候，面对猛然暴增的服务，我一下子不知所措了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了上面说到的运维上线的问题，还出现了很多我从未经历过的问题。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 定位问题成了一件很奢侈的事&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;通过采用上线模板和其他工具，好不容易缓解了运维问题。还没轻松几天，紧接着，故障处理又出现问题了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开始的时候，服务数量少，定位问题，大概稍微琢磨下，就能判断出来。但是，随着服务越分越多，定位问题就很麻烦了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如出问题后查日志，原来的服务数量少，查日志直接上服务器就查了。但是，现在服务有接近二十个，还没算集群。挨个服务器查日志定位问题，那几乎不可能。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 不能再这样了，不然失败就在眼前&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;后来，我下了决心，在解决这些问题之前，坚决不能再拆新的服务了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我主动去和领导沟通了这些问题，得到了领导的支持。然后，又拉着领导和业务团队磨了好几次，终于也让他们同意暂时降低一段时间提需求的频率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总算能腾出精力解决问题了。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 关于问题的思考&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;这些问题，我统统归类为基础设施的问题。其实，那时候虽然微服务生态还没有完全清晰，但是，我本身大概也总结出了一些套路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我把需要的基础设施分成了两个类别:&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;部署发布&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;日常运维&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;然后，我分别对这两类基础设施的需求又做了进一步的细化。下面把当时我做的最紧急的一些基础设施需求列了出来:&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.581081081081081&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KTHZsotDic1AOEcTxNSucuj58jBfeMOSPlUHkXHd2VJyskZJOwiaF40Sm3AHdnkMNUfzPEMzIURMYPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;592&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. 我控制不了这些问题……&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;但是，这里依然还有问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如，这些工具理论上是属于基础设施，是不是需要运维团队来维护？可是运维团队已经对我们的各种上线需求不胜其烦了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;又比如，这些工具当时不成熟，我们还得自己开发改进，而这又要靠谁呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当时没有办法，我只能咬牙自己带了几个人，把这些额外的工作承担了下来，由我们几个人专门开发和维护这些工具。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一直到后来，市面上有了成熟的工具链，我本身也升职，可以对技术团队整体去贯彻 DevOps 理念了，才真的从这些任务中解脱开来。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5. 基础设施决定上层建筑啊，同志们&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;我知道很多公司是技术自己提出来微服务的，提出来的时候，你一定要清楚，微服务这套体系本身，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;把以前单体系统的复杂度转移到了技术基础设施上。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多工作其实是需要自动化的。在踏进微服务这个神坑前，一定要考虑清楚：公司有没有合适的基础设施？&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、落地需要妥协的其他的一些细节问题&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;微服务理论看上去是很完美的，但是，在现实落地，其实还会有许许多多不太可能马上完美贴合微服务理论的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我大概列举几个重要的:&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 数据库划分的问题&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;老实讲，咱们这篇文章本来就是在说一个服务一个数据库的模式。那么按理来讲，严格符合这个模式是最好的。但是，实际落地来讲，中间有太多的弯弯绕绕了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如，我们的服务需要划分成四五十个服务，这个时候，数据库划分成同样的四五十个库就不合适了。因为这会引入如下的三个问题:&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据库管理过于复杂&lt;/strong&gt;——这个是很显然的问题，管理几个数据库和管理几十个数据库，需要投入的人力物力是完全不一样的。每一台数据库本身就是个很复杂的系统，数量越多，出问题的几率也越大，监控难度也越大。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;分布式一致性实现太过复杂&lt;/strong&gt;——数据库数量上来了，因为业务需要，协调数据一致性从原先需要协调几个数据库的状态变成了需要同时协调几十个。复杂度一下子上去了，这也会造成很多不必要的技术问题。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;跨库查询相当不方便&lt;/strong&gt;——这个问题也是一样的，当我们服务划分后，数据库如果也划分的过细，那么以前需要跨几个库查询的业务，就可能变成需要跨十几个库查询。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;所以，就落地的时候来讲，还是需要有个业务域的概念。这也是为什么微服务总和领域驱动设计绑定在一起，因为人家天然有个业务域的概念。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这时候，就可以考虑某些业务域，共享一些数据库。比如，订单业务域可以每个服务对应一台数据库，但是，用户业务域可能就可以共享那么一台数据库。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.620817843866171&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KTHZsotDic1AOEcTxNSucuj5ZUDE0VpibKKEEB88Zc69U7Aw0q14M39Ws7Qm7KwCbqwbCaYGFp0U1zg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;807&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 开发框架的问题&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;我搞微服务比较早，所以，开始做的时候，就是用了 Spring 的框架，然后每个 Tomcat 后面放个服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那时候，维护起来真麻烦。因为 Tomcat 本身多了，又和应用不是一体的，同时维护 Tomcat 和应用，非常难受。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;后来有了 SpringBoot，情况好了很多。再后来，我们也尝试使用了一阵子 Dubbo。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实各有自己的不足。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SpringBoot 的不足主要是，用了 SpringBoot，很多时候就不得不用更多的 Spring 其他组件，哪怕它的一些组件很不让人满意。感觉项目中处处 Spring，非得走 Spring 那套规则不可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Dubbo 的不足主要是能配合的组件很少，我们用 Dubbo 其实很早，但是为了和 Dubbo 配合，有些时候还得做很多额外的开发。比如，当时 Dubbo 本身服务跟踪，也没有通过 RabbitMQ 通信的组件，我们都需要自己开发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，当你要选框架的时候，要考虑清楚，因为微服务本身是一大套生态。如果框架本身选用不合适，后期就得靠自己的技术能力去做硬调整。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 一些关键技术何时引入的问题&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;有些关键技术，我们是逐渐引入的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为，引入一个新技术，对我们无论是开发还是维护，引入便利性的同时可能也会引入复杂性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如容器技术，我们就是搞了很久了才慢慢引入的。引入容器技术后，很多问题（例如网络、内存）我们就要多想一层，看看是不是因为容器导致了其他问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总之，对于一个正在运营的系统，我个人认为引入新技术需要谨慎评估。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;以上写的主要是我和团队的经历，可能你会觉得是一家之言。没关系，说的不对的，欢迎指正，虚心接受；说的对的，希望能让给大家一些借鉴&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于一个服务一个数据库说到现在，我说了为什么要分服务，以及如何落地还有带来的一些问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于这种模式，它引入的问题其实非常多，一本书可能都说不完，这里只是举了一些我遇到的一些我记忆里很深刻的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，把一套系统改造成一套微服务就需要分服务和分库就完了吗？解决分服务和分库带来的一些问题就完了吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那可不是，因为有些问题非得引入一些新的模式才能最好最省心的解决，只有把多种微服务的模式配合起来，才能让微服务这个生态完全的运转起来去替代以前的单体项目生态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在后面的文章里，我会讲解该怎么用模式去解决一些棘手的性能问题，怎么用模式去平衡读写负载失衡的问题等等。只有通过模式把分服务引起的各种开发问题解决了，一套微服务系统我们才能说架构完全成功了，所以，我会以我的架构经验去把整套微服务架构通过模式去讲清楚一套微服务到底应该如何架构。&lt;/span&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p&gt;&lt;span&gt;你好，我是四猿外。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一家上市公司的技术总监，管理的技术团队一百余人。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我从一名非计算机专业的毕业生，转行到程序员，一路打拼，一路成长。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我会通过公众号，
把自己的成长故事写成文章，
把枯燥的技术文章写成故事。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我建了一个读者交流群，里面大部分是程序员，一起聊技术、工作、八卦。欢迎加我微信，拉你入群。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9852216748768473&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6nbNnibOq5KQibCDibpTo0kqofPehQvDDibibcb3bQUELdY3Knsl4r0RcgsV9l4icr3icmZQfaBXtSFNTxmdQlAZT1OQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;609&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247485243&amp;amp;idx=1&amp;amp;sn=01c52fa742b7baadb688429c4056ee43&amp;amp;chksm=fcd8cb7acbaf426cc0c1108198f8b32a33d04742d54a26f7156ad4c2385dfd11dc69196422da&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;“一学就会”微服务的架构模式：一个服务一个数据库模式（上）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247485296&amp;amp;idx=1&amp;amp;sn=31a32a3275fb581dfdc6ee3504cad3a4&amp;amp;chksm=fcd8cb31cbaf42274d5ea0281f093bfe2f10a343f437b060eaa24255c50df8d1670e7b198278&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;我是如何把微服务的这个模式落地的：一个服务一个数据库模式（中）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247484971&amp;amp;idx=1&amp;amp;sn=f6708bd5ca27540806c0dab8d926b97d&amp;amp;chksm=fcd8ca6acbaf437c7d1a85d997fdf79dec93bf468764d389ceea767d2f2172dd353aff677c92&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;最终一致性，一致只会迟到，但绝不会缺席&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0baf183864ce091273c574f0fa4b43e0</guid>
<title>Go 实现一个 JS 解释器</title>
<link>https://toutiao.io/k/4c58qqk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;豆皮粉儿们，大家好呀。愉快的五一节就这么过去了，假期有没有好好游玩一番呢。今天给大家由 给大家讲解，如何用go实现一个js解释器。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;作者：&lt;span&gt;清风慕竹&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;背景&lt;/h1&gt;&lt;p&gt;前段时间在开发版本发布系统过程中，为了追求系统的灵活性，我们允许用户通过写js的方式生成json配置，业务上有定制的需求可以通过js代码来实现，这样在不调整底层系统的情况下可以尽可能的支持业务中的个性化需求。由于发布系统是用golang开发的，所以这里需要一个go版本的js解释器（不需要考虑gc、jit、inline-cache等复杂内容，只是一个简单的解释器的实现，可以解析并执行js即可），能够在golang应用中安全的运行&lt;code&gt;js&lt;/code&gt;代码。&lt;/p&gt;&lt;h1&gt;实现思路&lt;/h1&gt;&lt;p&gt;关于js解释器的实现其实已经有很多版本了，比如tinyjs(c++版本的实现)、tinyjs.py(py版本的实现)、还有若干用js自举实现的版本，比如eval5 。这些解释器实现思路大致如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6050283860502839&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/mkcv1AwSman8kXP3siaS08yumOfzjBXjy7HtlrSAxlXVib30VtPCDXlEL8ur3eF0fMclN5lm4IwD4pHqYQE17qMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2466&quot;/&gt;&lt;/p&gt;&lt;p&gt;其中转换步骤是可选的，这一步主要工作是将语法树上的节点转换成目标语言可执行的节点，对于eval5这种js-in-js的实现，这一步就不需要实现了。但是对js-in-x(x可能是go、c++、py)这种情况则需要增加转换的步骤。关于词法分析、语法解析这两块实现资料比较多，这里不再赘述，熟悉js的同学可以参考acorn、babel-parser、espree等实现，这里重点讲下转换和遍历执行的过程。&lt;/p&gt;&lt;h1&gt;go与js数据交换&lt;/h1&gt;&lt;p&gt;在转换、执行之前需要先解决go和js数据交换的问题，需要考虑 js&amp;lt; --- &amp;gt;go 双向的场景。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;go代码访问js变量 js代码在ast语法树转换的过程中，对应的ast节点转换的过程中被转换成expression节点，基本的值被装箱成Value类型，golang访问js变量实际上访问的是变量对应的ast节点转换后生成的expression节点。比如在js中定义如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; a &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  console&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&#x27;hello &#x27;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;变量定义转换如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4396355353075171&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/mkcv1AwSman8kXP3siaS08yumOfzjBXjyI1hWJfBrfU8L67vE76mZ98p4k1Tia5I0S1IlIPrh6brGfId7Qx2NVVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2634&quot;/&gt;&lt;/p&gt;&lt;p&gt;函数定义转换如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5731280615815255&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/mkcv1AwSman8kXP3siaS08yumOfzjBXjy66STuYBrEAgEhJtqQ0s1VOO9lggx53D4Dryfic3ZhrT17wZG4hHSGUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2858&quot;/&gt;&lt;/p&gt;&lt;p&gt;golang在执行前会处理变量定义，处理之后会在对应作用域对象上生成key（变量名or函数名）到expression的binding:&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7800224466891134&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/mkcv1AwSman8kXP3siaS08yumOfzjBXjyzRcxvEKia9A3JyPHLb0UxWSPU9H27Yo55B1OSulI6T4Qibqg04AyjhFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1782&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;go里面并不会直接访问js变量，而是访问js变量对应的expression。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;js代码访问go变量 假定go提前注册了变量x和函数twoPlus：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;vm &lt;/span&gt;&lt;span&gt;:=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;New&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;vm&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;x&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;vm&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;twoPlus&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; func&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;call &lt;/span&gt;&lt;span&gt;FunctionCall&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; _ &lt;/span&gt;&lt;span&gt;:=&lt;/span&gt;&lt;span&gt; call&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Argument&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;).&lt;/span&gt;&lt;span&gt;ToInteger&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; _ &lt;/span&gt;&lt;span&gt;:=&lt;/span&gt;&lt;span&gt; vm&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;ToValue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; right&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;})&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;js访问golang中变量x、函数twoPlus：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; a &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; x &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; b &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; twoPlus&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;console&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&#x27;twoPlus(a): &#x27;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; b&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;js代码并没有直接执行，真正执行的是js代码对应的ast转换后的结果，golang侧注册变量实际上是把变量注册到了当前作用域的property上了：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5724770642201835&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/mkcv1AwSman8kXP3siaS08yumOfzjBXjyo2g2QGjSHYymaf8eUzMqlmXPHicIs6FbXAvtib4xia5LBM4GibJwl7jgzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1090&quot;/&gt;&lt;/p&gt;&lt;p&gt;执行ast转换后的节点时发现需要获取identifier x对应值的时候，会从property对应的map上拿到x对应的值。函数也是如此。&lt;/p&gt;&lt;h1&gt;转换&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;从ast树的body节点开始遍历，依次执行statement转换的过程比如上图中 &lt;code&gt;1+1&lt;/code&gt;在ast树上对应的节点是ExpressionStatement，对应的会依次调用parseStatement：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.776796973518285&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/mkcv1AwSman8kXP3siaS08yumOfzjBXjyMQsfPwEjWWpTInjpbchMr4Au5ibOHNGw8Qkk7FRckibXC5F7knXHj9Iw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1586&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;parseExpression：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8540925266903915&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/mkcv1AwSman8kXP3siaS08yumOfzjBXjynCGiciaYsrehdzwf8pj72gNCIZIibPytmC9vNWLEBGpdiaV0wSWdZjeaYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1686&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;ExpressionStatement内部的expression是BinaryExpression,最终会转换成如下结构&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;_nodeBinaryExpression {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  operator:   token.PLUS,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  comparison: false, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  left: &amp;amp;_nodeLiteral{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    value: Value{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      kind:  valueNumber,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      value: 1, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  },    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  right: &amp;amp;_nodeLiteral{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    value: Value{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      kind:  valueNumber, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      value: 1,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;处理变量声明情况处理变量声明和js的变量提升相关，在遍历完ast树之后，对于树上的变量、函数的定义，会保存到varList、functionList数组中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4684354986276304&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/mkcv1AwSman8kXP3siaS08yumOfzjBXjyWez5nibXKXib0WGYQ3l9R3Pq8cZqkiao2CicNhlU2fCUEFCZ17PmJTFmdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2186&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;遍历、执行&lt;/h1&gt;&lt;p&gt;&lt;code&gt;1+1&lt;/code&gt; 为例：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5752840909090909&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/mkcv1AwSman8kXP3siaS08yumOfzjBXjyl9nEKCeCiaDicV4EmKI7l1KIz8TGbEf2xBIoic2Mbgo9TzbxibjbLdXT3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1408&quot;/&gt;&lt;/p&gt;&lt;p&gt;遍历ast执行对应的节点时需要注意，js存在作用域的区别（全局作用域、函数作用域）。在上面的代码执行的时候，默认将代码放在全局作用域执行：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3177570093457944&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/mkcv1AwSman8kXP3siaS08yumOfzjBXjykwy8TpoYXFYmV2Voap2wLkU08FaGia41k17xgTkuWOicHicuAaH38eKuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1712&quot;/&gt;&lt;/p&gt;&lt;p&gt;enterGlobalScope和leaveScope对应实现如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.41834862385321103&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/mkcv1AwSman8kXP3siaS08yumOfzjBXjyFiaiaMlUtGgQCW0Bv0NysazSQWicxOeyia3dpeSDO03oCXvSrgaAjUqZDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1090&quot;/&gt;&lt;/p&gt;&lt;p&gt;进入globalScope的时候会把当前runtime的scope暂存在_scope.outer字段上，defer对应的匿名函数在函数执行完毕之后执行，当函数执行完之后，再把scope.outers上暂存的scope恢复回来。globalScope和functionScope的scope对象是隔离的，在非严格模式下，functionScope会是一个从globalScope深拷贝的对象。&lt;/p&gt;&lt;p&gt;接下来处理变量定义，比如&lt;code&gt;var a = 1&lt;/code&gt;变量定义 或者&lt;code&gt;function f(){}&lt;/code&gt; 函数定义，变量和函数存放的地方在当前作用域scope对象上的variable.object.property字段上，这个字段其实类型就是一个巨型map，存储的时候key为变量名，值为js对应值的包装类型。完成变量、函数定义后，遍历program下的body节点，并根据节点类型执行对应的操作：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4392605633802817&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/mkcv1AwSman8kXP3siaS08yumOfzjBXjyxWddpiaMG2ny1DvTcQMWykFIGcw14aavtHfiaeTnGNHsIvBTFnOpiaQWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2272&quot;/&gt;&lt;/p&gt;&lt;p&gt;接着执行ExpressionStatement中的expression，对应类型是BinaryExpression：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.38950892857142855&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/mkcv1AwSman8kXP3siaS08yumOfzjBXjyD2aWds8a4N3gvcYEHaFIDxtw5aPXOWfYymBILoELWFf3ReOt01LO9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1792&quot;/&gt;&lt;/p&gt;&lt;p&gt;BinaryExpression需要计算左值和右值，先计算node.left:&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.25965250965250963&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/mkcv1AwSman8kXP3siaS08yumOfzjBXjyOicWXME1d4ExLSp4JEOKOfr9jaznSbmT1DHxgC1Gg4qfQdiavQ9icqhJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2072&quot;/&gt;&lt;/p&gt;&lt;p&gt;再进入cmp_evaluate_nodeExpression时，此时expression类型为nodeLiteral， 直接返回node.value即可。下面根据node.operator执行对应的计算逻辑（参与的时候先对Value类型执行拆箱，获取基本类型的值后转换成float64类型参与计算，计算的结果以Value的包装类型返回）：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4697986577181208&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/mkcv1AwSman8kXP3siaS08yumOfzjBXjyCJ4emP27zoW05uokD4HQiclsVLa4r2hOq2zJGiaRTIrnofKibWkxHLV7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1788&quot;/&gt;&lt;/p&gt;&lt;p&gt;到这里就完成了&lt;code&gt;1+1&lt;/code&gt;的计算。&lt;/p&gt;&lt;h1&gt;总结&lt;/h1&gt;&lt;p&gt;借助现有的js代码解析库可以相对容易的实现一个js的解释器，实现思路比较明确，但是对于新语法规范支持度还是比较差，后面可以进一步扩充语法。除了本文介绍的js-in-go的实现之外，js-in-js也有一些比较有意思的玩法，比如借助js-in-js的实现，可以在js引擎屏蔽了eval、new Function情况下实现js代码的热更新。&lt;/p&gt;&lt;p&gt;福利时间&lt;/p&gt;&lt;h3&gt;字节跳动9周年徽章&lt;span&gt;2枚&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.5005861664712778&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/mkcv1AwSman8kXP3siaS08yumOfzjBXjyGPtHRtCd5HKz1dddgqAOAaB372x5mqxblfOjMaWcSibxIv2Srme4icHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;853&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.5005861664712778&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/mkcv1AwSmamSxricJW6lXOkTfB721D5FNacujDWkuaSZng8ibNDrialJtZoGP5CnuDdw4wMlkvticiaEJNMRSXEicd1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;853&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;strong&gt;&lt;span&gt;那么如何获奖呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;获奖分为以下3步&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;第1步：关注本公众号「豆皮范儿」&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;第2步：转发本文到朋友圈并截图。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;第3步：在本公众号「豆皮范儿」下回复你的截图&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;抽奖和领取奖品等其他事项：&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•  &lt;/span&gt;「豆皮范儿」公众号后台回复「&lt;span&gt;加群&lt;/span&gt;」，&lt;/span&gt;&lt;span&gt;&lt;span&gt;•  &lt;/span&gt;&lt;span&gt;会在粉丝群公开抽奖过程，抽奖结果会单独发文章出来。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;The     End&lt;/p&gt;&lt;p&gt;如果你觉得这篇文章对你有帮助，有启发，我想请你帮我2个小忙：&lt;/p&gt;&lt;p&gt;1、点个「&lt;span&gt;在看&lt;/span&gt;」，让更多的人也能看到这篇文章内容；&lt;/p&gt;&lt;p&gt;2、关注公众号「&lt;span&gt;豆皮范儿&lt;/span&gt;」，公众号后台回复「&lt;span&gt;加群&lt;/span&gt;」 加入我们一起学习；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;关注公众号的福利&lt;strong&gt;持续更新&lt;/strong&gt;，公众号后台送学习资料：&lt;/p&gt;&lt;p&gt;1、&lt;span&gt;豆皮范儿后台&lt;/span&gt;回复「&lt;span&gt;vis&lt;/span&gt;」，还可以获取更多可视化免费学习资料。&lt;/p&gt;&lt;p&gt;2、&lt;span&gt;豆皮范儿后台&lt;/span&gt;回复「&lt;span&gt;webgl&lt;/span&gt;」，还可以获取webgl免费学习资料。&lt;/p&gt;&lt;p&gt;3、&lt;span&gt;豆皮范儿后台&lt;/span&gt;回复「&lt;span&gt;算法&lt;/span&gt;」，还可以获取算法的学习资料。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4、豆皮范儿后台回复「&lt;span&gt;招聘&lt;/span&gt;」，获取各种内推。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-height=&quot;NaN&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/mkcv1AwSmanPu7ZJA5vgiawicnlyTTd7zicAy0ToQfIX8sIe2IicdGPTuYurQI5f1ia64sx4FGlUibpXvgOMdYTMJpZQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;516&quot; data-width=&quot;578&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg5NDUzMDY3Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/mkcv1AwSmanVPr3iacbXXyDy2icV4ekTV1n2FAvsNXyNIicsNEDDIibg3F6csvwjmYt6GlV0QglaBic7icfxzQHFl6hw/0?wx_fmt=png&quot; data-nickname=&quot;豆皮范儿&quot; data-alias=&quot;&quot; data-signature=&quot;小豆皮的前端范儿&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>