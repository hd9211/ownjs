<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>02bc1d4ca6fa73bed7fcbc2d64eea12b</guid>
<title>Hive 系统函数一览</title>
<link>https://toutiao.io/k/ned9psx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- 1、字符串长度函数：length&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select length(&#x27;abcedfg&#x27;) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;-- 2、字符串反转函数：reverse&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select reverse(abcedfg’) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;gfdecba&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;-- 3、字符串连接函数：concat&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select concat(‘abc’,&#x27;def’,&#x27;gh’) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;abcdefgh&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;-- 4、带分隔符字符串连接函数：concat_ws&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select concat_ws(&#x27;,&#x27;,&#x27;abc&#x27;,&#x27;def&#x27;,&#x27;gh&#x27;) from iteblog;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;abc,def,gh&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;-- 5、字符串截取函数：substr,substring&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select substr(&#x27;abcde&#x27;,3) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;cde&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select substring(&#x27;abcde&#x27;,3) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;cde&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt;  select substr(&#x27;abcde&#x27;,-1) from tableName;  （和ORACLE相同）&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;e&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;-- 6、字符串截取函数：substr,substring&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select substr(&#x27;abcde&#x27;,3,2) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;cd&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select substring(&#x27;abcde&#x27;,3,2) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;cd&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt;select substring(&#x27;abcde&#x27;,-2,2) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;de&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;-- 7、字符串转大写函数：upper,ucase&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select upper(&#x27;abSEd&#x27;) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;ABSED&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select ucase(&#x27;abSEd&#x27;) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;ABSED&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;-- 8、字符串转小写函数：lower,lcase&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select lower(&#x27;abSEd&#x27;) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;absed&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select lcase(&#x27;abSEd&#x27;) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;absed&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;-- 9、去空格函数：trim&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select trim(&#x27; abc &#x27;) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;abc&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;-- 10、左边去空格函数：ltrim&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select ltrim(&#x27; abc &#x27;) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;abc&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;-- 11、右边去空格函数：rtrim&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select rtrim(&#x27; abc &#x27;) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;abc&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;-- 12、正则表达式替换函数：regexp_replace&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select regexp_replace(&#x27;foobar&#x27;, &#x27;oo|ar&#x27;, &#x27;&#x27;) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;fb&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;-- 13、正则表达式解析函数：regexp_extract&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select regexp_extract(&#x27;foothebar&#x27;, &#x27;foo(.*?)(bar)&#x27;, 1) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;the&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select regexp_extract(&#x27;foothebar&#x27;, &#x27;foo(.*?)(bar)&#x27;, 2) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;bar&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select regexp_extract(&#x27;foothebar&#x27;, &#x27;foo(.*?)(bar)&#x27;, 0) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;foothebar&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;-- 14、URL解析函数：parse_url&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select parse_url(&#x27;https://www.iteblog.com/path1/p.php?k1=v1&amp;amp;k2=v2#Ref1&#x27;, &#x27;HOST&#x27;) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;facebook.com&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select parse_url(&#x27;https://www.iteblog.com/path1/p.php?k1=v1&amp;amp;k2=v2#Ref1&#x27;, &#x27;QUERY&#x27;, &#x27;k1&#x27;) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;v1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;-- 15、json解析函数：get_json_object&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select  get_json_object(&#x27;{&quot;store&quot;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;   {&quot;fruit&quot;:\[{&quot;weight&quot;:8,&quot;type&quot;:&quot;apple&quot;},{&quot;weight&quot;:9,&quot;type&quot;:&quot;pear&quot;}],&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;    &quot;bicycle&quot;:{&quot;price&quot;:19.95,&quot;color&quot;:&quot;red&quot;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;   },&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;  &quot;email&quot;:&quot;amy@only_for_json_udf_test.net&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;  &quot;owner&quot;:&quot;amy&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; &#x27;,&#x27;$.owner&#x27;) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;amy&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;-- 16、空格字符串函数：space&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select space(10) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select length(space(10)) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;-- 17、重复字符串函数：repeat&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select repeat(&#x27;abc&#x27;,5) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;abcabcabcabcabc&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;-- 18、分割字符串函数: split&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select split(&#x27;abtcdtef&#x27;,&#x27;t&#x27;) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;[&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;-- 19、集合查找函数: find_in_set&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select find_in_set(&#x27;ab&#x27;,&#x27;ef,ab,de&#x27;) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select find_in_set(&#x27;at&#x27;,&#x27;ef,ab,de&#x27;) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;-- 20、千分位转换函数：format_number&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;hive&amp;gt; select format_number(21312442.12345, 3) from tableName;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21,312,442.123&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>10b4d4668d2b7a6864798dfa27346525</guid>
<title>基于 Codis 的冷热缓存优化</title>
<link>https://toutiao.io/k/u9kv0o0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;/p&gt;&lt;h1&gt;基于Codis的冷热缓存优化&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;热数据运维挑战：缓存存储分别有memcache,redis,redis cluster,codis等缓存对维护和运维带来很大的挑战。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;冷数据成本挑战: 部分单服务内存超过500G根据三地两中心三副本部署共需要1.5T内存，未来随着用户增加内存不断的增加。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;方案选择&lt;/h2&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;针对热数据运维挑战：统一为codis方面集群的扩缩，自动负载，数据迁移和监控等&lt;/p&gt;&lt;br/&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7048748353096179&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtnuXLctZicloI3Mmm7q9EeV13cKegQNAyopSQVyjRVwCuDFicXSUOCbaU6ZCTRq83vvOA29ROV9zqkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;759&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;冷数据成本挑战：兼容codis协议使用磁盘存储kvrocks替换内存存储redis&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6966145833333334&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtnuXLctZicloI3Mmm7q9EeV1ibteMHibGAPiaUaXfNWDRv1lZeuicl3DFJ8NeibnUl3wUL4icDSOW426Jaxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;768&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;性能及问题&lt;/h2&gt;&lt;h3&gt;codis-redis内存存储问题&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;不支持多网卡造成codis-proxy添加集群auth认证失败&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;缺少监控耗时：仅仅有codis-redis实例耗时没有codis-proxy监控耗时，造成业务反馈超时codis本身没有超时&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;懒惰删除不及时造成集群空间浪费比较大&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;codis-kvrocks磁盘存储问题&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;不支持codis协议，不支持水平扩缩容，不支持读写分离&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;读耗时较高&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;解决方案&lt;/h2&gt;&lt;h3&gt;codis-redis内存存储问题&lt;/h3&gt;&lt;p&gt;1: 针对多网卡仅获取具有广播地址ip：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    var broadcaseAddrs []string&lt;br/&gt;    interfaces, err := net.Interfaces()&lt;br/&gt;    if err != nil {&lt;br/&gt;        log.WarnErrorf(err, &quot;Can not get local interface info&quot;)&lt;br/&gt;    }&lt;br/&gt;    for _, inter := range interfaces {&lt;br/&gt;        flags := inter.Flags.String()&lt;br/&gt;        if strings.Contains(flags, &quot;up&quot;) &amp;amp;&amp;amp; strings.Contains(flags, &quot;broadcast&quot;) {&lt;br/&gt;            addrs,err := inter.Addrs()&lt;br/&gt;            if err!=nil {&lt;br/&gt;                log.WarnErrorf( err,&quot;Can not get inter.Addrs&quot;)&lt;br/&gt;            }else {&lt;br/&gt;                for _,value :=range addrs {&lt;br/&gt;                    broadcaseAddrs = append (broadcaseAddrs,value.String())&lt;br/&gt;                }&lt;br/&gt;                log.Infof(&quot;broadcaseAddrs %s &quot;, broadcaseAddrs)&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2: 针对耗时无监控添加耗时超时100ms日志（请求ip，redis ip，redis命令，命令长度等维度）,Filebeat采集日志针对耗时高请求进行监控报警：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;func (s *Session) loopWriter(tasks *RequestChan) (err error) {&lt;br/&gt;&lt;/code&gt;&lt;code&gt;    p := s.Conn.FlushEncoder()&lt;br/&gt;    p.MaxInterval = time.Millisecond&lt;br/&gt;    p.MaxBuffered = maxPipelineLen / 2&lt;br/&gt;&lt;br/&gt;    return tasks.PopFrontAll(func(r *Request) error {&lt;br/&gt;        resp, err := s.handleResponse(r)&lt;br/&gt;        if err != nil {&lt;br/&gt;            resp = redis.NewErrorf(&quot;ERR loopWriter handle response, %s&quot;, err)&lt;br/&gt;            if s.Conn!=nil {&lt;br/&gt;                log.Errorf(&quot;ERR loopWriter handle response err=%s,remotip=%s&quot;, err.Error() ,s.Conn.RemoteAddr())&lt;br/&gt;            }else{&lt;br/&gt;                log.Errorf(&quot;ERR loopWriter handle response err=%s&quot;, err.Error())&lt;br/&gt;            }&lt;br/&gt;            return s.incrOpFails(r, err)&lt;br/&gt;        }&lt;br/&gt;        fflush := tasks.IsEmpty()&lt;br/&gt;        if err := p.Flush(fflush); err != nil {&lt;br/&gt;            return s.incrOpFails(r, err)&lt;br/&gt;        } else {&lt;br/&gt;            s.incrOpStats(r, resp.Type)&lt;br/&gt;            cost:= time.Now().UnixNano() - r.UnixNano&lt;br/&gt;            if s.config.SessionSlowlogTime &amp;gt; 0 &amp;amp;&amp;amp; cost &amp;gt; s.config.SessionSlowlogTime*1000000 {&lt;br/&gt;                log.Warnf(&quot;cmd=%s, resType=%s,resLen=%d,cost=%d,forward addr=%s,req key=%s, reqip=%s&quot;,r.OpStr, r.Resp.Type.String(),len(r.Resp.Value),cost/1000000,r.addr,r.key,s.Conn.RemoteAddr())&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        if fflush {&lt;br/&gt;            s.flushOpStats(false)&lt;br/&gt;        }&lt;br/&gt;        return nil&lt;br/&gt;    })&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3: 针对懒惰删除机制慢，加大低峰期删除key个数和频率,上线后删除过期的key加大10倍，节省内存资源。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;br/&gt;void activeExpireCycle(int type) {&lt;br/&gt;    time_t tmpcal_ptr;&lt;br/&gt;    struct tm *tmp_ptr = NULL;&lt;br/&gt;    time(&amp;amp;tmpcal_ptr);&lt;br/&gt;    tmp_ptr = localtime(&amp;amp;tmpcal_ptr);&lt;br/&gt;    if (tmp_ptr-&amp;gt;tm_hour &amp;gt;3 &amp;amp;&amp;amp; tmp_ptr-&amp;gt;tm_hour&amp;lt;=6 ){&lt;br/&gt;        timelimit = 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/100;&lt;br/&gt;    }else{&lt;br/&gt;        timelimit = 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100;&lt;br/&gt;    }&lt;br/&gt;    for (j = 0; j &amp;lt; dbs_per_call; j++) {&lt;br/&gt;        int expired,lookup_num;&lt;br/&gt;        redisDb *db = server.db+(current_db % server.dbnum);&lt;br/&gt;        do {&lt;br/&gt;            slots = dictSlots(db-&amp;gt;expires);&lt;br/&gt;            now = mstime();&lt;br/&gt;            if (num &amp;amp;&amp;amp; slots &amp;gt; DICT_HT_INITIAL_SIZE &amp;amp;&amp;amp;&lt;br/&gt;                (num*100/slots &amp;lt; 1)) break;&lt;br/&gt;            expired = 0;&lt;br/&gt;            ttl_sum = 0;&lt;br/&gt;            ttl_samples = 0;&lt;br/&gt;            if (tmp_ptr-&amp;gt;tm_hour &amp;gt;=3 &amp;amp;&amp;amp; tmp_ptr-&amp;gt;tm_hour&amp;lt;=6 ){&lt;br/&gt;                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP*10;&lt;br/&gt;            }else {&lt;br/&gt;                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;&lt;br/&gt;            }&lt;br/&gt;            lookup_num = num;&lt;br/&gt;&lt;br/&gt;            while (num--) {&lt;br/&gt;                dictEntry *de;&lt;br/&gt;                long long ttl;&lt;br/&gt;&lt;br/&gt;                if ((de = dictGetRandomKey(db-&amp;gt;expires)) == NULL) break;&lt;br/&gt;                ttl = dictGetSignedIntegerVal(de)-now;&lt;br/&gt;                if (activeExpireCycleTryExpire(db,de,now)) expired++;&lt;br/&gt;                if (ttl &amp;gt; 0) {&lt;br/&gt;                    /* We want the average TTL of keys yet not expired. */&lt;br/&gt;                    ttl_sum += ttl;&lt;br/&gt;                    ttl_samples++;&lt;br/&gt;                }&lt;br/&gt;            }&lt;/code&gt;&lt;code&gt;&lt;br/&gt;        } while (expired &amp;gt; lookup_num/4);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;codis-kvrocks&lt;/h3&gt;&lt;h4&gt;性能数据（第三方数据显示qps可以和redis媲美，耗时较高）&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtnuXLctZicloI3Mmm7q9EeV1ybyVqvToq813I8Fku9T5rNY4lQU25POBmorw34SlGqVIKGPzMW8xdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;整体架构&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;1.0227272727272727&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtnuXLctZicloI3Mmm7q9EeV14Jc9ZFUr4sy7IbN2NzpJFGMRqps672645vpzJHZ0kFxhZiak20KDicfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;748&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;问题&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;针对不支持codis增加对codis slot命令支持：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;    ADD_CMD(&quot;slotsscan&quot;,              CommandSlotsScan),&lt;br/&gt;    ADD_CMD(&quot;slotsdel&quot;,               CommandSlotsDel),&lt;br/&gt;    ADD_CMD(&quot;slotsmgrtslot&quot;,          CommandSlotsMgrtSlot),&lt;br/&gt;    ADD_CMD(&quot;slotsmgrtone&quot;,           CommandSlotsMgrtOne),&lt;br/&gt;    ADD_CMD(&quot;slotsmgrttagslot&quot;,       CommandSlotsMgrtTagSlot),&lt;br/&gt;    ADD_CMD(&quot;slotsmgrttagone&quot;,        CommandSlotsMgrtTagOne),&lt;br/&gt;    ADD_CMD(&quot;slotsrestore&quot;,           CommandSlotsRestore),&lt;br/&gt;    ADD_CMD(&quot;slotshashkey&quot;,           CommandSlotsHashKey),&lt;br/&gt;    ADD_CMD(&quot;slotscheck&quot;,             CommandSlotsCheck),&lt;br/&gt;    ADD_CMD(&quot;slotsmgrtslot-async&quot;,    CommandSlotsMgrtSlotAsync),&lt;br/&gt;    ADD_CMD(&quot;slotsmgrttagslot-async&quot;, CommandSlotsMgrtTagSlotAsync),&lt;br/&gt;    ADD_CMD(&quot;slotsmgrt-exec-wrapper&quot;, CommandSlotsMgrtExecWrapper),&lt;br/&gt;    ADD_CMD(&quot;slotsmgrt-async-status&quot;, CommandSlotsMgrtAsyncStatus),&lt;br/&gt;    ADD_CMD(&quot;slotsmgrt-async-cancel&quot;, CommandSlotsMgrtAsyncCancel),&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   如果codis扩容实例需要迁移slot中keys代码如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;br/&gt;void SlotsMgrtSenderThread::loop() {&lt;br/&gt;  Redis::Slot slot_db(storage_);&lt;br/&gt;  while (!IsStopped()) {&lt;br/&gt;    auto s = Util::SockConnect(dest_ip_, dest_port_, &amp;amp;sock_fd, timeout_ms_, timeout_ms_);&lt;br/&gt;    moved_keys_all_ = 0;&lt;br/&gt;    while (is_migrating_) {&lt;br/&gt;      if (keys_num_ &amp;lt;= 0) {&lt;br/&gt;        sleep(1);&lt;br/&gt;        continue;&lt;br/&gt;      }&lt;br/&gt;      std::vector&amp;lt;std::string&amp;gt; migrate_batch_keys;&lt;br/&gt;      auto s = ElectMigrateKeys(&amp;amp;migrate_batch_keys);&lt;br/&gt;      std::lock_guard&amp;lt;std::mutex&amp;gt; ones_guard(ones_mu_);&lt;br/&gt;      std::copy(migrating_ones_.begin(), migrating_ones_.end(), std::back_inserter(migrate_batch_keys));&lt;br/&gt;      if (migrate_batch_keys.size() != 0) {&lt;br/&gt;          moved_keys_num_ = 0;&lt;br/&gt;      }&lt;br/&gt;      std::vector&amp;lt;std::string&amp;gt;().swap(migrating_ones_);&lt;br/&gt;      for (auto const &amp;amp;key : migrate_batch_keys) {&lt;br/&gt;        auto s = slot_db.MigrateOneKey(sock_fd, key);&lt;br/&gt;        moved_keys_num_++;&lt;br/&gt;        moved_keys_all_++;&lt;br/&gt;        remained_keys_num_--;&lt;br/&gt;      }&lt;br/&gt;      if (error_) {&lt;br/&gt;        break;&lt;br/&gt;&lt;/code&gt;&lt;p&gt;&lt;code&gt;      }&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;      if (remained_keys_num_ == 0) {&lt;/code&gt;&lt;/p&gt;&lt;code&gt;        LOG(INFO) &amp;lt;&amp;lt; &quot;[slots-mgrt-sender-thread] Migrate slot: &quot; &amp;lt;&amp;lt; slot_num_ &amp;lt;&amp;lt; &quot; finished&quot;;&lt;br/&gt;        slotsmgrt_cond_.Signal();&lt;br/&gt;        StopMigrateSlot();&lt;br/&gt;        break;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;}  // namespace Redis&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;    2. 读耗时优化&lt;/p&gt;&lt;p&gt;RocksDB 的全量 Compact 导致磁盘 IO 从而造成业务访问的毛刺点问题，之前策略是每天凌晨低峰时段进行一次，过于频繁会导致访问毛刺点，频率过低会导致磁盘空间回收不及时。所以增加另外一种部分 Compact 策略，优先对那些比较老以及无效 KV 比较多的 SST进行 Compact。开启只需要在配置文件里面增加一行，那么则会在凌晨 3 到 7 点之间去检查这些 SST 文件并做Compact。&lt;/p&gt;&lt;p&gt;另外由于RocksDB定时Compact sst文件造成大量磁盘IO，而像SATA磁盘IO瓶颈最大200M/s超过这个阀值读写都要等待，所以还需要设置磁盘Compact最大磁盘IO阀值小于磁盘IO的瓶颈。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# The maximum allowed aggregated write rate of flush and compaction (in MB/s).&lt;br/&gt;# If the rate exceeds max-io-mb, io will slow down.&lt;br/&gt;# 0 is no limit&lt;br/&gt;# Default: 500&lt;br/&gt;max-io-mb 150&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7dbbe2be80e8dd1ecf6f3c2b61a27942</guid>
<title>创业公司团队管理的四大挑战（裁人篇）</title>
<link>https://toutiao.io/k/awjoph0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;card-body markdown markdown-toc&quot;&gt;
        
        &lt;p&gt;&lt;img src=&quot;https://l.ruby-china.com/photo/jasonliu/dea41fc3-1286-44b6-a035-0e405041e078.jpeg!large&quot; title=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一天早上，我步入办公室刚走到办公桌前，主管就匆匆地把我叫入了一间会议室，他的表情显得很凝重，眼中血丝清晰可见，我有一种不好的预感。“你需要给我一份名单，我们要裁掉你团队中一半的开发人员......” 主管用疲惫且无奈的口吻对我说道。我并没有显得过于震惊，因为最近公司的扩张速度太快了，而业绩显然没有跟上这种扩张速度，裁员也只是时间问题。确认一些问题后，我深吸一口气，调整了一下表情，起身走出了会议室。来到办公桌前，我看到一些伙伴在埋头工作，一些伙伴还在和产品激烈的争论需求方案，他们朝气蓬勃，充满干劲，但一场暴风雨即将来临......我坐在椅子上显得有些恍惚，各种名字在我脑海中闪过，我知道我将经历职业生涯中最艰难的一天！&lt;/p&gt;

&lt;p&gt;这次裁员的结果很糟糕，公司不仅损失了一批忠诚的员工，良好的声誉也遭受打击，各种负面的报道充斥在新闻媒体、知乎、微博......连我自己都没有预想到结果是如此之糟糕，外界的负面报道、被裁员工的愤怒是意料之中，但留下来的员工所展现出来的失望情绪是如此的强烈让我们始料未及，由此引发了我持续的反思：公司的裁员过程到底哪里做错了？如果重来一次，我们是否会处理的更好？以下是我一年多来的思考和总结，希望这些经验你永远都用不到。&lt;/p&gt;
&lt;h2 id=&quot;裁人篇&quot;&gt;裁人篇&lt;/h2&gt;&lt;h2 id=&quot;承认管理的失败&quot;&gt;承认管理的失败&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;万亿美金教练比尔·坎贝尔曾说过：&quot;裁员说明了公司管理的失败，而不是任何被解雇的人的失败&quot;&lt;/strong&gt;。但往往实际传递给被裁员工的信息就像是言情剧的陈词滥调：&quot;不是你人不好，只是我们不合适&quot;。承认失败是很丢脸的事情，是需要勇气的事情，但这是凝聚团队的有效手段。就像是部队打了一场败仗，指挥官应该负首要责任，而不能责怪士兵无能。&lt;/p&gt;

&lt;p&gt;但不得不说，当今时代让我们对创业公司的 CEO 有着近乎苛刻的期待，睿智、聪明、勇气、魅力都成了基本标配，还希望 CEO 们能力挽狂澜、让公司起死回生，高速增长，直到上市才能彰显成功，修成正果。但实际上乔布斯、马云之辈只是稀有物种，更多数的 CEO 只是比大众在某些方面更强而已，他们也是普通人。因为背负了太多，让 CEO 亲自说出自己的失败是很困难的一件事情，但我还是建议面对裁员的时候，公司的 CEO 能当着所有人说出是因为自己的管理失败导致这样的结果。&lt;strong&gt;投身创业公司的员工也需要理解，你们的老板是人而不是神，不要抱有过分的期待&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;自己的员工要自己亲自辞退&quot;&gt;自己的员工要自己亲自辞退&lt;/h2&gt;
&lt;p&gt;&quot;没有辞退过人的管理者不是一个好的管理者&quot;，这是一句有道理又有些残酷的话，但我并不喜欢这样的表达，在这句话的背后隐藏着一些管理者要承担的责任，这个才是你应该去了解的。我曾经辞退过团队中的一个高级开发，说实话，辞退他以后，我整个人都轻松了好多，再也不用为了让他准时参加早会而绞尽脑汁，也不用为了他引发的团队矛盾而忧心忡忡，但过程是很痛苦的，对方会辱骂你，甚至要状告公司。那段时间，我晚上都没法安然入睡，你会自责给主管和公司带来麻烦，你会质疑自己的决定：是不是大家相安无事就不会落到今天找个地步？现在回想起来，这次的经历让我成长了很多。&lt;strong&gt;识别团队中不合适的成员是简单的，但有勇气辞退对方才是巨大的挑战&lt;/strong&gt;，很多管理者都会选择忍受，付出的代价不仅是自己痛苦，还会毁掉你的团队，如果你连一个人按时参加早会都做不到，如何让团队和主管认可你的管理能力？正如本·霍洛维茨在《创业维艰》这本书中提到：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&quot;对管理人员的培训需遵循一条黄金法则：自己的员工要自己亲自辞退，不能将这项工作推卸给人力资源部门或某个更严厉的同事，不能像电影《在云端》中那样雇用一家外包公司来完成。&quot;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;如果你已经决定辞退团队中的某一个成员，你应该寻求你的主管以及 HR 部门的支持，让他们提前做好准备，随时应对可能出现的意料之外的状况&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;不要上交管理责任&quot;&gt;不要上交管理责任&lt;/h2&gt;
&lt;p&gt;很多管理者在辞退人的过程中会犯一个很多人都会犯的错误叫：&lt;strong&gt;管理责任上交&lt;/strong&gt;，就是你把自己的应该肩负的责任推给你的主管。&quot;不是我不给你涨薪，是领导不批准&quot;, &quot;不是我要辞退你，这是领导的决定&quot;，是不是听着很耳熟？如果你只是作为员工和上级之间的传话筒，那么你作为管理者的价值在哪里呢？&lt;strong&gt;管理者要做的事情就是处理这些困难的事情，如果你只是当个传话筒，拖拖 Jira 的卡片，盯着任务的进度，这样的事情任何人都可以做，你要经常思考：我带这个团队和其他人带有什么不同么？&lt;/strong&gt;。我所面试的很多所谓有 “团队管理” 经验的人，做的都是他的团队成员都可以去做的事情。这也是目前很多公司的优秀开发人员不愿意去做团队 leader 的原因，他们认为 leader 的主要工作就是拖下任务卡片。&lt;/p&gt;
&lt;h2 id=&quot;不要制造惊吓&quot;&gt;不要制造惊吓&lt;/h2&gt;
&lt;p&gt;我想谁都不会期望突然被叫到办公室被告知：你被辞退了。但 “裁人要快” 这句话已经被各大公司的管理者奉为圭臬，但实际取得好的效果的少之又少，那到底要多快呢？我在一天之内就辞掉了团队的成员，过程异常顺利，但我非常的难受，我宁愿大家当面骂我一顿，但是每个人都抱着理解的心态，我感受得到他们内心的失落和愤怒，只是他们刻意压制住了，不想在我的面前展现出来。我想问题的关键不在于到底有多快，而是在于我们是否提前给大家传递了一些信息。&lt;strong&gt;对于裁员，公司之前是否已经将业绩不佳的情况如实告知所有人，还是只是少数的几个高管知道。对于辞退不合适的员工，你是否提前和他沟通了对于他的要求和没有达到预期的点在哪里。如果没有提前告知这些信息，对于他们来说就是一场 “惊吓”，导致情况失控就不足为奇了&lt;/strong&gt;。隐瞒坏消息的理由有很多，比如不希望竞争对手恶意中伤，不希望媒体过分解读，不希望影响员工士气，不希望投资人因此撤资等等，但最终你会发现：一旦隐瞒，事情的发展会和你的期望背道而驰。&lt;/p&gt;

&lt;p&gt;公司裁员就像一个男人和女朋友说分手，你不能拖着耽误人家青春，也不能像电视剧中的桥段：我们不合适！然后扭头就走。分手肯定不是一时冲动，而是在相处的过程中发现了不合适的地方，你应该平时就说出来，搭建沟通的桥梁，而不是藏在心里在某一刻突然爆发。还要有点人情味，帮对方还清信用卡、清空购物车、行李搬上车，祝福对方找到真爱！&lt;/p&gt;
&lt;h2 id=&quot;谨慎选择你的名单&quot;&gt;谨慎选择你的名单&lt;/h2&gt;
&lt;p&gt;裁员的时候，我被告知要保留核心开发人员，现在回想起来，我在选择名单的时候犯下了巨大的错误：我裁掉了所有的实习生和初级开发人员。我到现在依然后悔不已。一方面这些实习生中不乏基础能力好，对团队认可度高的人，这些人可能是未来公司的核心成员，另一方面我在后面不得不辞退掉团队内的一名高级开发，他的薪水超过了 2 个初级开发的薪水总和了。相当于留下了不合适的人，裁掉了有潜力的人，导致双输的局面。现在我认识到，&lt;strong&gt;对于一个创业公司，裁员只是创业过程中的一个挫折而已，你所面临的挑战远不止此，能陪你走到最后的不一定是专业能力最强的，往往不是，他们反而会去前景更好的公司，那些对公司或团队认可度高的人才能和你一起披荆斩棘，克服各种困难还能留到最后&lt;/strong&gt;。我当时是没有这样的认知的。如果你面临这样的选择，请谨慎填写你的名单，不仅要考虑现在，还要为未来做准备。&lt;/p&gt;
&lt;h2 id=&quot;如何回答：凭什么裁的是我？&quot;&gt;如何回答：凭什么裁的是我？&lt;/h2&gt;
&lt;p&gt;面对裁员，我相信你大概率会遇到这个问题，我没有遇到过，但是我相信大家心里都有这样问过。“这是领导的决定”，上面已经提到过，千万不要这么干。” 可能是你，现在还没有最终决定 “，更不能这么干，你是在给自己挖坑，给对方找不痛快。对于初级的开发，理由会是公司目前没有资源来培养你们；对于高级开发，理由会是你的薪水太高了，公司需要降低成本。这些答案都是合理的，但不一定有效，因为&lt;strong&gt;你面对的不是问题，而是情绪，先解决情绪再解决问题，你表现出的态度比逻辑更重要&lt;/strong&gt;。面对这个问题，我想这不会是一个糟糕的回答：公司目前遇到经营困难，需要裁员才能继续走下去，我不得不让团队中的一部分人离开，这是一个艰难的决定，离开的成员名单里有你，我为此感到非常抱歉，我会帮助你渡过接下来的艰难时刻，如果我能在任何方面帮助到你，请你一定告诉我。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;作为管理者，你的权利就在于你可以做出这个决定，哪怕不是最优的决定，后果是公司来承担，但你不能不做决定，不做决定比错误的决定更糟糕&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;好好说再见&quot;&gt;好好说再见&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;帕蒂·麦考德在《奈飞文化手册》一书中提到的奈飞企业文化准则第八条就是：离开时好好说再见&lt;/strong&gt;。我想如果企业或管理者可以做到这一点，我上面所说的都是废话了。好好说再见的方式有很多，我当时做的是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;拉一个被裁掉同事的微信群，把 HR 也拉进来，给大家推荐工作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;给每一个人写推荐信（在国内这个似乎没什么用）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保持手机畅通，当员工重新加入一家公司需要做背调的时候把情况说清楚&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请大家吃饭，保持私下的联络&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;帮大家搬东西，亲自送大家离开&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;公司的角度可以做到更多，比如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;在力所能及的情况下给一份丰厚的补偿金&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高管可以推荐一些人去认识的公司&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高管给全体员工发一封邮件或者讲一次话，说明公司目前的情况，感谢离开员工过去的付出&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;你不用担下一切“罪责”&quot;&gt;你不用担下一切 “罪责”&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;你不用担下一切罪责，实际上你确实也担不下&lt;/strong&gt;。那段时间我很难走出来，感觉自己很失败，感觉对不起那些离开的人，他们有的都还刚毕业啊，面对人生的第一份工作就要面临被裁，换做是我，我也难以接受。但还是那句话：&lt;strong&gt;这就是作为一个管理者要面对的事情。你能做的就是与离开的人好好说再见，还能和他们成为生活中的朋友，你最应该做的就是整理好自己的心情和思绪，为团队还留下的人负责，你需要带领他们走出当前的阴霾，努力不要让这样的事情再次发生&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;前段时间我请了之前离开的同事一起吃火锅，再次相见，那种团队的感觉依然还在，大家一起说说笑笑，互诉衷肠，那些不愉快的经历似乎都已经远去了，我的内心还带着一些歉意，真的很开心和这些朋友一起共事过，希望我们还有在一起再次共事！&lt;/p&gt;
        
      &lt;/div&gt;
      &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>73962188bd3f7e6a58888aca8e5451ba</guid>
<title>[译] 2021 Web Worker 现状</title>
<link>https://toutiao.io/k/cumvkf3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot; articlelinkcardprops=&quot;[object Object]&quot; usegifprops=&quot;[object Object]&quot;&gt;&lt;blockquote&gt; 本文为翻译&lt;br/&gt; 原文标题：The State Of Web Workers In 2021&lt;br/&gt; 原文作者：Surma&lt;br/&gt; 原文地址：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.smashingmagazine.com/2021/06/web-workers-2021/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;smashingmagazine.com/20&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;21/06/web-workers-2021/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;导读： Web 是单线程的。这让编写流畅又灵敏的应用程序变得越来越困难。Web Worker 的名声很臭，但对 Web 开发者来说，它是解决流畅度问题的 一个非常重要的工具。让我们来了解一下 Web Worker 吧。&lt;br/&gt; &lt;/blockquote&gt;&lt;p&gt;我们总是把 Web 和 所谓的 “Native” 平台（比如 Android 和 iOS）放在一起比较。Web 是流式的，当你第一次打开一个应用程序时，本地是不存在任何可用资源的。这是一个根本的区别，这使得很多在 Native 上可用的架构 无法简单应用到 Web 上。&lt;/p&gt;&lt;p&gt;不过，不管你在关注在什么领域，都一定使用过或了解过 多线程技术。iOS 允许开发者 使用 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.apple.com/documentation/DISPATCH&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Grand Central Dispatch&lt;/a&gt; 简单的并行化代码，而 Android 通过 新的统一任务调度器 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.com/topic/libraries/architecture/workmanager&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;WorkManager&lt;/a&gt; 实现同样的事情，游戏引擎 Unity 则会使用  &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Manual/JobSystemSchedulingJobs.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;job systems&lt;/a&gt; 。我上面列举的这些平台不仅支持了多线程，还让多线程编程变得尽可能简单。&lt;/p&gt;&lt;p&gt;在这篇文章，我将概述为什么我认为多线程在 Web 领域很重要，然后介绍作为开发者的我们能够使用的多线程原语。除此之外，我还会谈论一些有关架构的话题，以此帮助你更轻松的实现多线程编程（甚至可以渐进实现）。&lt;/p&gt;&lt;h2&gt;无法预测的性能问题&lt;/h2&gt;&lt;p&gt;我们的目标是保持应用程序的 流畅（smooth） 和 灵敏（responsive）。流畅 意味着 稳定 且 足够高 的 帧率。灵敏 意味着 UI 以最低的延迟 响应 用户交互。两者是保持应用程序 优雅 和 高质量 的 关键因素。&lt;/p&gt;&lt;p&gt;按照 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//web.dev/rail/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;RAIL 模型&lt;/a&gt;，灵敏 意味着响应用户行为的时间控制在 100ms 内，而 流畅 意味着屏幕上任何元素移动时 稳定在 60 fps。所以，我们作为开发者 拥有 1000ms/60 = 16.6ms 的时间 来生成每一帧，这也被称作 “帧预算”（frame budget）。&lt;/p&gt;&lt;p&gt;我刚刚提到了 “我们”，但实际上是 “浏览器” 需要 16.6ms 的时间 去完成 渲染一帧背后的所有工作。我们开发者仅仅直接负责 浏览器实际工作 的一部分。浏览器的工作包括（但不限于）： &lt;/p&gt;&lt;ul&gt;&lt;li&gt;检测 用户操作的 元素（element）&lt;/li&gt;&lt;li&gt;发出 对应的事件&lt;/li&gt;&lt;li&gt;运行相关的 JavaScript 时间处理程序&lt;/li&gt;&lt;li&gt;计算 样式&lt;/li&gt;&lt;li&gt;进行 布局（layout）&lt;/li&gt;&lt;li&gt;绘制（paint）图层&lt;/li&gt;&lt;li&gt;将这些图层合并成一张 最终用户在屏幕上看到的 图片 &lt;/li&gt;&lt;li&gt;（以及更多…）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;好大的工作量啊。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4e896834d313edfa3acb2704c1097c1c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1905&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-4e896834d313edfa3acb2704c1097c1c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1905&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-4e896834d313edfa3acb2704c1097c1c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-4e896834d313edfa3acb2704c1097c1c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;另一方面，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//infrequently.org/2021/03/the-performance-inequality-gap/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;“性能差距” 在不断扩大&lt;/a&gt;。旗舰手机的性能随着 手机产品的更新换代 变得越来越高。而低端机型正在变得越来越便宜，这使得之前买不起手机的人能够接触到移动互联网了。就性能而言，这些低端手机的性能相当于 2012 年的 iPhone。&lt;/p&gt;&lt;p&gt;为 Web 构建的应用程序会广泛运行在性能差异很大的不同设备上。JavaScript 执行完成的时间取决于 运行代码设备有多快。不光是 JavaScript，浏览器执行的其他任务（如 layout 和 paint）也受制于设备的性能。在一台现代的 iPhone 上运行只需要 0.5ms 的任务 可能 到了 Nokia 2 上需要 10ms。用户设备的性能是完全无法预测的。&lt;/p&gt;&lt;blockquote&gt; 注：RAIL 作为一个指导框架至今已经 6 年了。你需要注意一点，实际上 60fps 只是一个占位值，它表示的是用户的显示设备原生刷新率。例如，新的 Pixel 手机 有 90Hz 的屏幕 而 iPad Pro 的屏幕是 120Hz 的，这会让 帧预算 分别减少到 11.1ms 和 8.3ms。&lt;br/&gt; &lt;/blockquote&gt;&lt;p&gt;更复杂的是，除了测算 &lt;code&gt;requestAnimationFrame()&lt;/code&gt; 回调之间的时间，&lt;b&gt;没有更好的方法来确定运行 app 设备的刷新率&lt;/b&gt; 。&lt;/p&gt;&lt;h2&gt;JavaScript&lt;/h2&gt;&lt;p&gt;JavaScript 被设计成 与浏览器的主渲染循环同步运行。几乎所有的 Web 应用程序都会遵循这种模式。这种设计的缺点是：执行缓慢的 JavaScript 代码会阻塞浏览器渲染循环。JavaScript 与浏览器的主渲染循环 同步运行可以理解为：如果其中一个没有完成，另一个就不能继续。为了让长时间的任务能在 JavaScript中 协调运行，一种基于 回调 以及 后来的 Promise 的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//vimeo.com/254947206%23t%3D2364s&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;异步模型被建立起来&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;为了保持应用程序的 流畅，你需要保证你的 JavaScript 代码运行 连同 浏览器做的其他任务（样式、布局、绘制…）的时间加起来不超出设备的帧预算。为了保持应用程序的 灵敏，你需要确保任何给定的事件处理程序不会花费超过 100ms 的时间，这样才能及时在设备屏幕上展示变化。在开发中，即使用自己的设备实现上面这些已经很困难了，想要在所有的设备都上实现这些几乎是不可能的。&lt;/p&gt;&lt;p&gt;通常的建议是 “做代码分割（chunk your code）”，这种方式也可以被称作 “出让控制权（yield）给浏览器”。其根本的原理是一样的：为了给浏览器一个时机来进入下一帧，你需要将代码分割成大小相似的块（chunk），这样一来，在代码块间切换时 就能将控制权交还给 浏览器 来做渲染。&lt;/p&gt;&lt;p&gt;有很多种“出让控制权（yield）给浏览器” 的方法，但是没有那种特别优雅。最近提出的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//wicg.github.io/scheduling-apis/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;任务调度 API&lt;/a&gt; 旨在直接暴露这种能力。然而，就算我们能够使用 &lt;code&gt;await yieldToBrowser()&lt;/code&gt; （或者类似的其他东西） 这样的 API 来 出让控制权，这种技术本身还是会存在缺陷：为了保证不超出帧预算，你需要在足够小的块（chunk）中完成业务，而且，你的代码每一帧至少要 出让一次控制权。&lt;/p&gt;&lt;p&gt;过于频繁的出让控制权 的 代码 会导致 调度任务的开销过重，以至于对应用程序整体性能产生负面影响。再综合一下我之前提到的 “无法预测的设备性能”，我们就能得出结论 — 没有适合所有设备的块（chunk）大小。当尝试对 UI 业务进行 “代码分割” 时，你就会发现这种方式很成问题，因为通过出让控制权给浏览器来分步渲染完整的 UI 会增加 布局 和 绘制 的总成本。&lt;/p&gt;&lt;h2&gt;Web Workers&lt;/h2&gt;&lt;p&gt;有一种方法可以打破 与浏览器渲染线程同步的 代码执行。我们可以将一些代码挪到另一个不同的线程。一旦进入不同的线程，我们就可以任由 持续运行的 JavaScript 代码 阻塞，而不需要接受 &lt;i&gt;代码分割&lt;/i&gt; 和 &lt;i&gt;出让控制权&lt;/i&gt; 所带来的 复杂度 和 成本。使用这种方法，渲染进程甚至都不会注意到另一个线程在执行阻塞任务。在 Web 上实现这一点的 API就是 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/Worker/Worker&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Web Worker&lt;/a&gt;。通过传入一个独立的 JavaScript 文件路径 就可以 创建一个 Web Worker，而这个文件将在新创建的线程里加载和运行。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;worker&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;./worker.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在我们深入讨论之前，有一点很重要，虽然 Web Workers， Service Worker 和 Worklet  很相似，但是它们完全不是一回事，它们的目的是不同的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在这篇文章中，我只讨论 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Web Workers&lt;/a&gt; （经常简称为 “Worker”）。Worker 就是一个运行在 独立线程里的 JavaScript 作用域。Worker 由一个页面生成（并所有）。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ServiceWorker&lt;/a&gt; 是一个 &lt;i&gt;短期的&lt;/i&gt; ，运行在 独立线程里的 JavaScript 作用域，作为一个 代理（proxy）处理 同源页面中发出的所有网络请求。最重要的一点，你能通过使用 Service Worker 来实现任意的复杂缓存逻辑。除此之外，你也可以利用 Service Worker 进一步实现 后台长请求，消息推送 和 其他那些无需关联特定页面的功能。它挺像 Web Worker 的，但是不同点在于 Service Worker 有一个特定的目的 和 额外的约束。&lt;/li&gt;&lt;li&gt;Worklet 是一个 API 收到严格限制的 独立 JavaScript 作用域，它可以选择是否运行在独立的线程上。Worklet 的重点在于，浏览器可以在线程间移动 Worklet。&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/AudioWorklet&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;AudioWorklet&lt;/a&gt;，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/CSS_Painting_API&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;CSS Painting API&lt;/a&gt; 和 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developers.google.com/Web/updates/2018/10/animation-worklet&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Animation Worklet&lt;/a&gt; 都是 Worklet 应用的例子。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/SharedWorker/SharedWorker&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;SharedWorker&lt;/a&gt; 是特殊的 Web Worker，同源的多个 Tab 和 窗口可以引用同一个 SharedWorker。这个 API 几乎不可能通过 polyfill 的方式使用，而且目前只有 Blink 实现过。所以，我不会在本文中深入介绍。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;JavaScript 被设计为和浏览器同步运行，也就是说没有并发需要处理，这导致很多暴露给 JavaScript 的 API 都不是 线程安全 的。对于一个数据结构来说，线程安全意味着它可以被多个线程并行访问和操作，而它的 状态（state）不会 被破坏（corrupted）。&lt;/p&gt;&lt;p&gt;这一般通过 &lt;b&gt;互斥锁（mutexes）&lt;/b&gt; 实现。当一个线程执行操作时，互斥锁会锁定其他线程。浏览器 和 JavaScript 引擎 因为不处理锁定相关的逻辑，所以能够做更多优化来让代码执行更快。另一方面，没有锁机制 导致 Worker 需要运行在一个完全隔离的 JavaScript 作用域，因为任何形式的数据共享都会 因缺乏线程安全 而产生问题。&lt;/p&gt;&lt;p&gt;虽然 Worker 是 Web 的 &lt;b&gt;“线程”原语&lt;/b&gt; ，但这里的 “线程” 和在 C++，Java 及其他语言中的非常不同。最大的区别在于，依赖于隔离环境 意味着 Worker 没有权限 访问其创建页面中其他变量和代码，反之，后者也无法访问 Worker 中的变量。数据通信的唯一方式就是调用 API &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/Window/postMessage&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;postMessage&lt;/a&gt;，它会将传递信息复制一份，并在接收端 触发 &lt;code&gt;message&lt;/code&gt; 事件。隔离环境也意味着 Worker 无法访问 DOM，在Worker 中也就无法更新 UI — 至少在没有付出巨大努力的情况下（比如 AMP 的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ampproject/worker-dom&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;worker-dom&lt;/a&gt;）。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-60f3709d014a3bb130292e1143bc3913_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1722&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-60f3709d014a3bb130292e1143bc3913_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1722&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-60f3709d014a3bb130292e1143bc3913_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-60f3709d014a3bb130292e1143bc3913_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;浏览器对 Web Worker 的支持可以说是普遍的，即使是 IE10 也支持。但是，Web Worker 的使用率依旧偏低，我认为这很大程度上是由于 Worker API 特殊的设计。&lt;/p&gt;&lt;h2&gt;JavaScript 的并发模型&lt;/h2&gt;&lt;p&gt;想要应用 Worker ，那么就需要对应用程序的架构进行调整。JavaScript 实际上支持两种不同的并发模型，这两种模型通常被归类为 “Off-Main-Thread 架构”（脱离主线程架构）。这两种模型都会使用 Worker，但是有非常不同的使用方式，每种方式都有自己的权衡策略。这两种模型了代表解决问题的两个方向，而任何应用程序都能在两者之间找到一个更合适的。&lt;/p&gt;&lt;h3&gt;并发模型 #1：Actor&lt;/h3&gt;&lt;p&gt;我个人倾向于将 Worker 理解为 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Actor_model&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Actor 模型&lt;/a&gt; 中的 Actor。编程语言 Erlang 中对于 Actor 模型 的实现可以说是最受欢迎的版本。每个 Actor 都可以选择是否运行在独立的线程上，而且完全保有自己操作的数据。没有其他的线程可以访问它，这使得像 互斥锁 这样的渲染同步机制就变得没有必要了。Actor 只会将信息传播给其他 Actor 并 响应它们接收到的信息。&lt;/p&gt;&lt;p&gt;例如，我会把 主线程 想象成 拥有并管理 DOM 或者说是 全部 UI 的 Actor。它负责更新 UI 和 捕获外界输入的事件。还会有一个 Actor 负责管理应用程序的状态。DOM Actor 将低级的输入事件 转换成 应用级的语义化的事件，并将这些事件传递给 &lt;i&gt;状态 Actor&lt;/i&gt; 。状态 Actor 按照接收到的事件 修改 状态对象，可能会使用一个状态机 甚至涉及其他 Actor。一旦状态对象被更新，状态 Actor 就会发送一个 更新后状态对象的拷贝 到 DOM Actor。DOM Actor 就会按照新的状态对象更新 DOM 了。&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DVg60lf92EkM&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Paul Lewis 和 我 曾经在 2018 年的 Chrome 开发峰会上探索过以 Actor 为中心的应用架构&lt;/a&gt; 。&lt;/p&gt;&lt;p&gt;当然，这种模式也不是没有问题的。例如，你发送的每一条消息都需要被拷贝。拷贝所花的时间不仅取决于 消息的大小，还取决于当前应用程序的运行情况。根据我的经验，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//surma.dev/things/is-postmessage-slow/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;postMessage 通常 “足够快”&lt;/a&gt;，但在某些场景确实不太行。另一个问题是，将代码迁移到 Worker 中可以解放 主线程，但同时不得不支付通信的开销，而且 Worker 可能会在响应你的消息之前忙于执行其他代码，我们需要考虑这些问题来做一个平衡。一不小心，Worker 可能会给 UI 响应带来负面影响。&lt;/p&gt;&lt;p&gt;通过 postMessage 可以传递非常复杂的消息。其底层算法（叫做 “结构化克隆”）可以处理 内部带有循环的数据结构 甚至是 &lt;code&gt;Map&lt;/code&gt; 和 &lt;code&gt;Set&lt;/code&gt; 。然而，他不能处理 函数 或者 类，因为这些代码在 JavaScript 中无法跨作用域共享。有点恼人的是，通过 postMessage 传一个 函数 会抛出一个 错误，然而一个类被传递的话，只会被静默的转换为一个普通的 JavaScript 对象，并在此过程中丢失所有方法（这背后的细节是有意义的，但是超出了本文讨论的范围）。&lt;/p&gt;&lt;p&gt;另外，postMessage 是一种 “Fire-and-Forget” 的消息传递机制，没有请求 和 响应 的概念。如果你想使用 请求/响应 机制（根据我的经验，大多数应用程序架构都会最终让你不得不这么做），你必须自己搞定。这就是我写了 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/GoogleChromeLabs/comlink&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Comlink&lt;/a&gt; 的原因，这是一个底层使用 RPC 协议的库，它能帮助实现 主线程 和 Worker 互相访问彼此对象。使用 Comlink 的时候，你完全不用管 postMessage。唯一需要注意的一点是，由于 postMessage 的异步性，函数并不会返回结果，而是会返回一个 promise。在我看来，Comlink 提炼了 Actor 模式 和 共享内存 两种并发模型中优秀的部分 并 提供给用户。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6ff85055e3608eade1b9c2c675a93299_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2000&quot; data-rawheight=&quot;837&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-6ff85055e3608eade1b9c2c675a93299_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2000&quot; data-rawheight=&quot;837&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-6ff85055e3608eade1b9c2c675a93299_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-6ff85055e3608eade1b9c2c675a93299_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;Comlink 并不是魔法，为了使用 RPC 协议 还是需要使用 postMessage。如果你的应用程序最终罕见的由于 postMessage 而产生瓶颈，那么你可以尝试利用 ArrayBuffers 可  &lt;i&gt;被转移（transferred）&lt;/i&gt; 的特性。转移 ArrayBuffer 几乎是即时的，并同时完成所有权的转移：在这个过程中 发送方的 JavaScript 作用域会失去对数据的访问权。当我&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//surma.dev/things/omt-for-three-xr/index.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;实验在主线程之外运行 WebVR 应用程序的物理模拟时&lt;/a&gt;，用到了这个小技巧。&lt;/p&gt;&lt;h3&gt;并发模型 #2：共享内存&lt;/h3&gt;&lt;p&gt;就像我之前提到的，传统的线程处理方式是基于 共享内存 的。这种方式在 JavaScript 中是不可行的，因为几乎所有的 JavaScript API 都是假定没有并发访问对象 来设计的。现在要改变这一点要么会破坏 Web，要么会由于目前同步的必要性导致重大的性能损耗。相反，共享内存 这个概念目前被限制在一个专有类型：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;SharedArrayBuffer&lt;/a&gt; （或简称 SAB）。&lt;/p&gt;&lt;p&gt;SAB 就像 ArrayBuffer，是线性的内存块，可以通过 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Typed Array&lt;/a&gt; 或 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;DataView&lt;/a&gt; 来操作。如果 SAB 通过 postMessage 发送，那么另一端不会接收到数据的拷贝，而是收到完全相同的内存块的句柄。在一个线程上的任何修改 在其他所有线程上都是可见的。为了让你创建自己的 互斥锁 和 其他的并发数据结构，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Atomics&lt;/a&gt; 提供了各种类型的工具 来实现 一些原子操作 和 线程安全的等待机制。&lt;/p&gt;&lt;p&gt;SAB 的 缺点是多方面的。首先，也是最重要的一点，SAB 只是一块内存。SAB 是一个非常低级的原语，以增加 工程复杂度 和 维护复杂度 作为成本，它提供了高灵活度 和 很多能力。而且，你无法按照你熟悉的方式去处理 JavaScript 对象 和 数组。它只是一串字节。&lt;/p&gt;&lt;p&gt;为了提升这方面的工作效率，我实验性的写了一个库  &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/GoogleChromeLabs/buffer-backed-object&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;buffer-backed-object&lt;/a&gt;。它可以合成 JavaScript 对象，将对象的值持久化到一个底层缓冲区中。另外，WebAssembly 利用 Worker 和 SharedArrayBuffer 来支持 C++ 或 其他语言 的线程模型。WebAssembly 目前提供了实现 共享内存并发 最好的方案，但也需要你放弃 JavaScript 的很多好处（和舒适度）转而使用另一种语言，而且通常这都会产出更多的二进制数据。&lt;/p&gt;&lt;h2&gt;案例研究: PROXX&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3Dw8P5HLxcIO4&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;在 2019 年&lt;/a&gt;，我和我的团队发布了 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//proxx.app/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PROXX&lt;/a&gt;，这是一个基于 Web 的 扫雷游戏，专门针对功能机。功能机的分辨率很低，通常没有触摸界面，CPU 性能差劲，也没有凑乎的 GPU。尽管有这么多限制，这些功能机还是很受欢迎，因为他们的售价低的离谱 而且 有一个功能完备的 Web 浏览器。因为功能机的流行，移动互联网得以向那些之前负担不起的人开放。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-702418f1b6d4c5d37f0014d7db1d570c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1688&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-702418f1b6d4c5d37f0014d7db1d570c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1688&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-702418f1b6d4c5d37f0014d7db1d570c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-702418f1b6d4c5d37f0014d7db1d570c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;为了确保这款游戏在这些功能机上灵敏流畅运行，我们使用了一种 类 Actor 的架构。主线程负责渲染 DOM（通过 preact，如果可用的话，还会使用 WebGL）和 捕捉 UI 事件。整个应用程序的状态 和 游戏逻辑 运行在一个 Worker 中，它会确认你是否踩到雷上了，如果没有踩上，在游戏界面上应该如何显示。游戏逻辑甚至会发送中间结果到 UI 线程 来持续为用户提供视觉更新。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-40ce6e1fd8804d059a0daf2b67a229ed_b.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;330&quot; data-rawheight=&quot;532&quot; data-thumbnail=&quot;https://pic2.zhimg.com/v2-40ce6e1fd8804d059a0daf2b67a229ed_b.jpg&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;330&quot; data-rawheight=&quot;532&quot; data-thumbnail=&quot;https://pic2.zhimg.com/v2-40ce6e1fd8804d059a0daf2b67a229ed_b.jpg&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-40ce6e1fd8804d059a0daf2b67a229ed_b.gif&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;其他好处&lt;/h2&gt;&lt;p&gt;我谈论了 流畅度 和 灵敏度 的重要性，以及如何通过 Worker 来更轻松的实现这些目标。另外一个外在的好处就是 Web Worker 能帮助你的应用程序消耗更少的设备电量。通过并行使用更多的 CPU 核心，CPU 会更少的使用 “高性能” 模式，总体来说会让功耗降低。来自微软的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//twitter.com/davrous&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;David Rousset&lt;/a&gt; 对 Web 应用程序的功耗进行了&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//devblogs.microsoft.com/sustainable-software/green-energy-efficient-progressive-Web-apps/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;探索&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;采用 Web Worker&lt;/h2&gt;&lt;p&gt;如果你读到了这里，希望你已经更好的理解了 为什么 Worker 如此有用。那么现在下一个显而易见的问题就是：怎么使用。&lt;/p&gt;&lt;p&gt;目前 Worker 还没有被大规模使用，所以围绕 Worker 也没有太多的实践和架构。提前判断代码的哪些部分值得被迁移到 Worker 中是很困难的。我并不提倡使用某种特定的架构 而抛弃其他的，但我想跟你分享我的做法，我通过这种方式渐进的使用 Worker，并获得了不错的体验：&lt;/p&gt;&lt;p&gt;大多数人都使用过 模块 构建应用程序，因为大多数 打包器 都会依赖 模块 执行 打包 和 代码分割。使用 Web Worker 构建应用程序最主要的技巧就是将 UI 相关 和 纯计算逻辑 的代码 严格分离。这样一来，必须存在于主线程的模块（比如调用了 DOM API 的）数量就能减少，你可以转而在 Worker 中完成这些任务。&lt;/p&gt;&lt;p&gt;此外，尽量少的依靠同步，以便后续采用诸如 回调 和 async/await 等异步模式。如果实现了这一点，你就可以尝试使用 Comlink 来将模块从主线程迁移到 Worker 中，并测算这么做是否能够提升性能。&lt;/p&gt;&lt;p&gt;现有的项目想要使用 Worker 的话，可能会有点棘手。花点时间仔细分析代码中那些部分依赖 DOM 操作 或者 只能在主线程调用的 API。如果可能的话，通过重构删除这些依赖关系，并渐近的使用上面我提出的模型。&lt;/p&gt;&lt;p&gt;无论是哪种情况，一个关键点是，确保 &lt;i&gt; Off-Main-Thread 架构&lt;/i&gt; 带来的影响是可测量的。不要假设（或者估算）使用 Worker 会更快还是更慢。浏览器有时会以一种莫名其妙的方式工作，以至于很多优化会导致反效果。测算出具体的数字很重要，这能帮你做出一个明智的决定！&lt;/p&gt;&lt;h2&gt;Web Worker 和 打包器（Bundler）&lt;/h2&gt;&lt;p&gt;大多数 Web 现代开发环境都会使用打包器来显著的提升加载性能。打包器能够将多个 JavaScript 模块打包到一个文件中。然而，对于 Worker，由于它构造函数的要求，我们需要让文件保持独立。我发现很多人都会将 Worker 的代码分离并编码成 Data URL 或 Blob URL，而不是选择在 打包器 上下功夫来实现需求。Data URL 和 Blob URL 这两种方式都会带来大问题：Data URL 在 Safari 中完全无法工作，Blob URL 虽说可以，但是没有 源（origin） 和 路径 的概念，这意味路径的解析和获取无法正常使用。这是使用 Worker 的另一个障碍，但是最近主流的打包器在处理 Worker 方面都已经加强了不少：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;Webpack&lt;/b&gt; ：对于  Webpack v4，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Webpack-contrib/worker-loader&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;worker-loader&lt;/a&gt; 插件让 Webpack 能够理解 Worker。而从 Webpack v5 开始，Webpack 可以自动理解 Worker 的构造函数，甚至可以在 主线程 和 Worker 之间共享模块 而 避免重复加载。&lt;/li&gt;&lt;li&gt;&lt;b&gt;Rollup&lt;/b&gt; ： 对于 Rollup，我写过 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//npm.im/%40surma/rollup-plugin-off-main-thread&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;rollup-plugin-off-main-thread&lt;/a&gt; ，这个插件能让 Worker 变得开箱即用&lt;/li&gt;&lt;li&gt;&lt;b&gt; Parcel&lt;/b&gt; ： Parcel 值得特别提一下，它的 v1 和 v2 都支持 Worker 的开箱即用，无需额外配置。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在使用这些打包器开发应用程序时，使用 ES Module 是很常见的。然而，这又会带来新问题。&lt;/p&gt;&lt;h2&gt;Web Worker 和 ES Module&lt;/h2&gt;&lt;p&gt;所有的现代浏览器都支持通过 &lt;code&gt;&amp;lt;script type=&quot;module&quot; src=&quot;file.js&quot;&amp;gt;&lt;/code&gt; 来运行 JavaScript 模块。Firefox 之外的所有现代浏览器现在也都支持对应 Worker 的一种写法：&lt;code&gt;new Worker(&quot;./worker.js&quot;, {type: &quot;module&quot;})&lt;/code&gt; 。Safari 最近刚开始支持，所以考虑如何支持稍老一些的浏览器是很重要的。幸运的是，所有的打包器（配合上面提到的插件）都会确保你模块的代码运行在 Worker 中，即使浏览器不支持 Module Worker。从这个意义上来说，使用打包器可以被看作是对 Module Worker 的 polyfill。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-fa6660504bf8213c7f2f1ba3f63b5737_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2000&quot; data-rawheight=&quot;986&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-fa6660504bf8213c7f2f1ba3f63b5737_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2000&quot; data-rawheight=&quot;986&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-fa6660504bf8213c7f2f1ba3f63b5737_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-fa6660504bf8213c7f2f1ba3f63b5737_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;未来&lt;/h2&gt;&lt;p&gt;我喜欢 Actor 模式。但在 JavaScript 中的并发 设计的并不是很好。我们构建了很多的 工具 和 库 来弥补，但终究这是 JavaScript 应该在语言层面上去完成的。一些 TC39 的工程师对这个话题很感兴趣，他们正尝试找到让 JavaScript 更好的支持这两种模式的方式。目前多个相关的提案都在评估中，比如 允许代码被 postMessage 传输，比如 能够使用 高阶的，类似调度器的 API （这在 Nativa 上很常见） 来在线程间共享对象。&lt;/p&gt;&lt;p&gt;这些提案目前没还有在 标准化流程中 取得非常重大的进展，所以我不会在这里花时间深入讨论。如果你很好奇，你可以关注 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tc39/proposals&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TC39 提案&lt;/a&gt; ，看看下一代的 JavaScript 会包含哪些内容。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;Worker 是保证主线程 灵敏 和 流畅 的关键工具，它通过防止长时间运行代码阻塞浏览器渲染来保证这一点。由于和 Worker 通信 存在 内在的异步性，所以采用 Worker 需要对应用程序的架构进行一些调整，但作为回报，你能更轻松的支持各种性能差距巨大的设备来访问。&lt;/p&gt;&lt;p&gt;你应该确保使用一种 方便迁移代码的架构，这样你就能 测算 非主线程架构 带来的性能影响。Web Worker 的设计会导致一定的学习曲线，但是最复杂的部分可以被 Comlink 这样的库抽象出来。&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;FAQ&lt;/h2&gt;&lt;p&gt;总会有人提出一些常见的问题和想法，所以我想先发制人，将我的答案记录在这里。&lt;/p&gt;&lt;h3&gt;&lt;code&gt;postMessage&lt;/code&gt; 不慢吗？&lt;/h3&gt;&lt;p&gt;我针对所有性能问题的核心建议是：先测算！在你测算之前，没有快慢一说。但根据我的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//surma.dev/things/is-postmessage-slow/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;经验&lt;/a&gt;，postMessage 通常已经 “足够快” 了。这是我的一个经验法则：如果 &lt;code&gt;JSON.stringify(messagePayload)&lt;/code&gt; 的参数小于 10kb，即使在速度最慢的手机上，你也不用担心会导致卡帧。如果 postMessage 真的成为了你应用程序中的瓶颈，你可以考虑下面的技巧： &lt;/p&gt;&lt;ul&gt;&lt;li&gt;将你的任务拆分，这样你就可以发送更小的信息&lt;/li&gt;&lt;li&gt;如果消息是一个状态对象，其中只有很小一部分发生改变，那就只发送变更的部分而不是整个对象&lt;/li&gt;&lt;li&gt;如果你发送了很多消息，你可以尝试将多条消息整合成一条&lt;/li&gt;&lt;li&gt;最终手段，你可以尝试将你的信息转化为 数字表示，并转移ArrayBuffers 而不是 基于对象的消息&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;我想从 Worker 中访问 DOM&lt;/h3&gt;&lt;p&gt;我收到了很多类似这样的反馈。然而，在大多数情况下，这只是把问题转移了。你有也许能有效地创建第二个主线程，但你还会遇到相同的问题，区别在于这是在不同的线程中。为了让 DOM 在多线程中安全访问，就需要增加锁，这将导致 DOM 操作的速度降低，还可能会损害很多现有的 Web 应用。&lt;/p&gt;&lt;p&gt;另外，同步模型其实也是有优点的。它给了浏览器一个清晰的信号 — 什么时候 DOM 处于可用状态，能够被渲染到屏幕上。在一个多线程的 DOM 世界，这个信号会丢失，我们就不得不手动处理 部分渲染的逻辑 或是 什么其他的逻辑。&lt;/p&gt;&lt;h3&gt;我真的不喜欢为了使用 Worker 把我的代码拆分成独立的文件&lt;/h3&gt;&lt;p&gt;我同意。TC39 中有一些提案正在被评议，为了能够将一个模块内联到另一个模块中，而不会像  Data URL 和 Blob URL 一样有那么多小问题。虽然目前还没有一个令人满意的解决方案，但是未来 JavaScript 肯定会有一次迭代解决这个问题。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>972124fad91c74379cb8398787eddc32</guid>
<title>go-httpbin：HTTP 请求测试工具推荐</title>
<link>https://toutiao.io/k/i8fnzda</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;httpbin 是什么&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;A simple HTTP Request &amp;amp; Response Service (written in Python + Flask).&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个简单的 HTTP 请求和回复测试服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详见: https://httpbin.org/&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;httpbin 用途&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;http 开发调试&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;httpbin 提供了 &lt;code&gt;GET/PUT/POST/PATCH/DELETET&lt;/code&gt; 常见方法，可以把请求头、参数等返回，类似 Echo 服务。方便调试 http 请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;http 库测试&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用开源或者自己项目封装的 http 请求库，可以把 httpbin 作为服务端，测试各种场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了在线的 https://httpbin.org/，也可以本地部署。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;云原生示例服务&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可作为演示服务，测试平台功能。例如，isito 就有 httpbin sample 服务，用来实验 istio 各种特性&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详见: https://github.com/istio/istio/tree/master/samples/httpbin&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;httpbin 常用接口&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;/get 接口&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;/put, /post, /patch&lt;/code&gt; 还会打印出请求体数据&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;curl &#x27;https://httpbin.org/get?paramA=aa&#x27;&lt;br/&gt;{&lt;br/&gt;  &quot;args&quot;: {&lt;br/&gt;    &quot;paramA&quot;: &quot;aa&quot;&lt;br/&gt;  },&lt;br/&gt;  &quot;headers&quot;: {&lt;br/&gt;    &quot;Accept&quot;: &quot;*/*&quot;,&lt;br/&gt;    &quot;Host&quot;: &quot;httpbin.org&quot;,&lt;br/&gt;    &quot;User-Agent&quot;: &quot;curl/7.64.1&quot;,&lt;br/&gt;    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-6107dcac-1d6d3fb32f67d8184c184992&quot;&lt;br/&gt;  },&lt;br/&gt;  &quot;origin&quot;: &quot;111.207.117.50&quot;,&lt;br/&gt;  &quot;url&quot;: &quot;https://httpbin.org/get?paramA=aa&quot;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;/status/{codes} 接口&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用来返回特定的状态码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;curl &#x27;https://httpbin.org/status/418&#x27;&lt;br/&gt;&lt;br/&gt;    -=[ teapot ]=-&lt;br/&gt;&lt;br/&gt;       _...._&lt;br/&gt;     .&#x27;  _ _ `.&lt;br/&gt;    | .&quot;` ^ `&quot;. _,&lt;br/&gt;    \_;`&quot;---&quot;`|//&lt;br/&gt;      |       ;/&lt;br/&gt;      \_     _/&lt;br/&gt;        `&quot;&quot;&quot;`&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;/ip 接口&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回原始 ip&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;curl &#x27;https://httpbin.org/ip&#x27;&lt;br/&gt;{&lt;br/&gt;  &quot;origin&quot;: &quot;xxx.xxx.xxx.xxx&quot;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;/delay/{delay} 接口&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;延时一定时间返回&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;还有很多测试接口，可在官网查看&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;go-httpbin 优化&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;httpbin 的 github https://github.com/postmanlabs/httpbin 在 2018.11 后就没有更新了，有一些需求和 bug 都没有解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无意将发现了 go-httpbin, 是一个只使用 golang 标准库实现的 httpbin。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我 fork 了 mccutchen/go-httpbin 项目，并添加了一些特性。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;add -response-delay args (more observability, except /delay/{time} api)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;pretty response json (more like httpbin)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;add query param envs (identify httpbin instance, default show HOSTNAME for k8s. eg: curl http://localhost:8080/get?envs=ENV1,ENV2)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;add anything api (show anything request and response)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;详见&lt;/strong&gt;: https://github.com/chinaran/go-httpbin&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以直接使用 docker 尝试运行&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;docker run -p 8080:80 ghcr.io/chinaran/go-httpbin:1.2-alpine3.13&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;示例&lt;/strong&gt;：(请求注入了 sidecar 的 httpbin 服务)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;kubectl -n ran-test &lt;span&gt;exec&lt;/span&gt; -it client-54d574b9b-6w9xc -- curl http://go-httpbin/get&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&quot;envs&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;HOSTNAME&quot;&lt;/span&gt;: &lt;span&gt;&quot;go-httpbin-6f55bbcfcd-skrxl&quot;&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;&quot;args&quot;&lt;/span&gt;: {},&lt;br/&gt;    &lt;span&gt;&quot;headers&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;Accept&quot;&lt;/span&gt;: &lt;span&gt;&quot;*/*&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;Content-Length&quot;&lt;/span&gt;: &lt;span&gt;&quot;0&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;Host&quot;&lt;/span&gt;: &lt;span&gt;&quot;go-httpbin&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;User-Agent&quot;&lt;/span&gt;: &lt;span&gt;&quot;curl/7.76.1&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;X-B3-Parentspanid&quot;&lt;/span&gt;: &lt;span&gt;&quot;d4ae8aad7301da2d&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;X-B3-Sampled&quot;&lt;/span&gt;: &lt;span&gt;&quot;1&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;X-B3-Spanid&quot;&lt;/span&gt;: &lt;span&gt;&quot;68b5055ffd105f5b&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;X-B3-Traceid&quot;&lt;/span&gt;: &lt;span&gt;&quot;26e3ee5a3196b1bcd4ae8aad7301da2d&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;X-Client-Name&quot;&lt;/span&gt;: &lt;span&gt;&quot;client&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;X-Client-Namespace&quot;&lt;/span&gt;: &lt;span&gt;&quot;ran-test&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;X-Envoy-Attempt-Count&quot;&lt;/span&gt;: &lt;span&gt;&quot;1&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;X-Forwarded-Client-Cert&quot;&lt;/span&gt;: &lt;span&gt;&quot;By=spiffe://cluster.local/ns/ran-test/sa/default;Hash=0cb9c538a64d9f747c86731252bd28d6e9121c7cf0be731f2484fd3b4a1af57f;Subject=\&quot;\&quot;;URI=spiffe://cluster.local/ns/ran-test/sa/default&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;X-Forwarded-Proto&quot;&lt;/span&gt;: &lt;span&gt;&quot;http&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;X-Request-Id&quot;&lt;/span&gt;: &lt;span&gt;&quot;1f2a3700-1bdf-9a0a-9091-2c6aba324606&quot;&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;&quot;origin&quot;&lt;/span&gt;: &lt;span&gt;&quot;127.0.0.1:46756&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;url&quot;&lt;/span&gt;: &lt;span&gt;&quot;http://go-httpbin/get&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>