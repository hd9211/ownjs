<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e09eef1e0a612a8364e428d0a38783d4</guid>
<title>浅谈 K8s 网络模型 CNI 协议</title>
<link>https://toutiao.io/k/vyje6t3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：successwang（王成），腾讯 CSIG 研发工程师，Kubernetes member。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 概述&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入 K8s 的世界，会发现有很多方便扩展的 Interface，包括 CNI, CSI, CRI 等，将这些接口抽象出来，是为了更好的提供开放、扩展、规范等能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;K8s 网络模型采用 CNI(Container Network Interface, 容器网络接口) 协议，只要提供一个标准的接口，就能为同样满足该协议的所有容器平台提供网络功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CNI 是 CoreOS 提出的一种容器网络规范，目前已被 Apache Mesos、Cloud Foundry、Kubernetes、Kurma、rkt 等众多开源项目所采用，同时也是一个 CNCF(Cloud Native Computing Foundation) 项目。可以预见，CNI 将会成为未来容器网络的标准。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文将从 kubelet 启动、Pod 创建/删除、Docker 创建/删除 Container、CNI RPC 调用、容器网络配置等核心流程，对 CNI 实现机制进行了解析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流程概览如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8169440242057489&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavO0Bwlpu6gGs5W9pevCZl4IbEDyZYGPkKRDc8G8ibBTwxBVIvVeomh9hjuNGdyC84VhteNtO5LlFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1322&quot;/&gt;&lt;figcaption&gt;K8s-CNI&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文及后续相关文章都基于 K8s v1.22&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 从网络模型说起&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;容器的网络技术日新月异，经过多年发展，业界逐渐聚焦到 Docker 的 CNM(Container Network Model, 容器网络模型) 和 CoreOS 的 CNI(Container Network Interface, 容器网络接口)。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 CNM 模型&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CNM 是一个被 Docker 提出的规范。现在已经被 Cisco Contiv, Kuryr, Open Virtual Networking (OVN), Project Calico, VMware 和 Weave 这些公司和项目所采纳。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Libnetwork 是 CNM 的原生实现。它为 Docker daemon 和网络驱动程序之间提供了接口。网络控制器负责将驱动和一个网络进行对接。每个驱动程序负责管理它所拥有的网络以及为该网络提供的各种服务，例如 IPAM 等等。由多个驱动支撑的多个网络可以同时并存。原生驱动包括 none, bridge, overlay 以及 MACvlan。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，container runtime 会在不同情况下使用到不同的插件，这带来了复杂性。另外，CNM 需要使用分布式存储系统来保存网络配置信息，例如 etcd。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6458467482292337&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavO0Bwlpu6gGs5W9pevCZl4J8A7afYBL6vWGpI6BFrIYXNlr3fzXeHYZoCOxMg4pqQPIk6azFXybQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1553&quot;/&gt;&lt;figcaption&gt;CNM-model&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Network Sandbox：容器内部的网络栈，包括网络接口、路由表、DNS 等配置的管理。Sandbox 可用 Linux 网络命名空间、FreeBSD Jail 等机制进行实现。一个 Sandbox 可以包含多个 Endpoint。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Endpoint：用于将容器内的 Sandbox 与外部网络相连的网络接口。可以使用 veth pair、Open vSwitch 的内部 port 等技术进行实现。一个 Endpoint 仅能够加入一个 Network。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Network：可以直接互连的 Endpoint 的集合。可以通过 Linux bridge、VLAN 等技术进行实现。一个 Network 包含多个 Endpoint。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 CNI 模型&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CNI 是由 CoreOS 提出的一个容器网络规范。已采纳改规范的包括 Apache Mesos, Cloud Foundry, Kubernetes, Kurma 和 rkt。另外 Contiv Networking, Project Calico 和 Weave 这些项目也为 CNI 提供插件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CNI 对外暴露了从一个网络里面添加和剔除容器的接口。CNI 使用一个 json 配置文件保存网络配置信息。和 CNM 不一样，CNI 不需要一个额外的分布式存储引擎。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个容器可以被加入到被不同插件所驱动的多个网络之中。一个网络有自己对应的插件和唯一的名称。CNI 插件需要提供两个命令：ADD 用来将网络接口加入到指定网络，DEL 用来将其移除。这两个接口分别在容器被创建和销毁的时候被调用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6107862248213125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavO0Bwlpu6gGs5W9pevCZl41f0IWw6UAYxXmgQkAFm9Ox24xfsUolltc5LXGgCRftXYlhZIVEn0eQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1539&quot;/&gt;&lt;figcaption&gt;CNI-model&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CNI 支持与第三方 IPAM 的集成，可以用于任何容器 runtime。CNM 从设计上就仅仅支持 Docker。由于 CNI 简单的设计，许多人认为编写 CNI 插件会比编写 CNM 插件来得简单。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. CNI 插件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CNI 插件是二进制可执行文件，会被 kubelet 调用。启动 kubelet --network-plugin=cni, --cni-conf-dir 指定 networkconfig 配置，默认路径是：/etc/cni/net.d。另外，--cni-bin-dir 指定 plugin 可执行文件路径，默认路径是：/opt/cni/bin。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一个 CNI Demo：在默认网络配置目录，配置两个 xxx.conf：一个 type: &quot;bridge&quot; 网桥，另一个 type: &quot;loopback&quot; 回环网卡。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ mkdir -p /etc/cni/net.d&lt;br/&gt;$ cat &amp;gt;/etc/cni/net.d/10-mynet.conf &amp;lt;&amp;lt;EOF&lt;br/&gt;{&lt;br/&gt; &lt;span&gt;&quot;cniVersion&quot;&lt;/span&gt;: &lt;span&gt;&quot;0.2.0&quot;&lt;/span&gt;, // CNI Spec 版本&lt;br/&gt; &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;mynet&quot;&lt;/span&gt;, // 自定义名称&lt;br/&gt; &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;bridge&quot;&lt;/span&gt;, // 插件类型 bridge&lt;br/&gt; &lt;span&gt;&quot;bridge&quot;&lt;/span&gt;: &lt;span&gt;&quot;cni0&quot;&lt;/span&gt;, // 网桥名称&lt;br/&gt; &lt;span&gt;&quot;isGateway&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;, // 是否作为网关&lt;br/&gt; &lt;span&gt;&quot;ipMasq&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;, // 是否设置 IP 伪装&lt;br/&gt; &lt;span&gt;&quot;ipam&quot;&lt;/span&gt;: {&lt;br/&gt;  &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;host-local&quot;&lt;/span&gt;, // IPAM 类型 host-local&lt;br/&gt;  &lt;span&gt;&quot;subnet&quot;&lt;/span&gt;: &lt;span&gt;&quot;10.22.0.0/16&quot;&lt;/span&gt;, // 子网段&lt;br/&gt;  &lt;span&gt;&quot;routes&quot;&lt;/span&gt;: [&lt;br/&gt;   { &lt;span&gt;&quot;dst&quot;&lt;/span&gt;: &lt;span&gt;&quot;0.0.0.0/0&quot;&lt;/span&gt; } // 目标路由段&lt;br/&gt;  ]&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;EOF&lt;br/&gt;$ cat &amp;gt;/etc/cni/net.d/99-loopback.conf &amp;lt;&amp;lt;EOF&lt;br/&gt;{&lt;br/&gt; &lt;span&gt;&quot;cniVersion&quot;&lt;/span&gt;: &lt;span&gt;&quot;0.2.0&quot;&lt;/span&gt;, // CNI Spec 版本&lt;br/&gt; &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;lo&quot;&lt;/span&gt;, // 自定义名称&lt;br/&gt; &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;loopback&quot;&lt;/span&gt; // 插件类型 loopback&lt;br/&gt;}&lt;br/&gt;EOF&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CNI 插件可分为三类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Main 插件：用来创建具体网络设备的二进制文件。比如，bridge、ipvlan、loopback、macvlan、ptp(point-to-point, Veth Pair 设备)，以及 vlan。如开源的 Flannel、Weave 等项目，都属于 bridge 类型的 CNI 插件，在具体的实现中，它们往往会调用 bridge 这个二进制文件。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Meta 插件：由 CNI 社区维护的内置 CNI 插件，不能作为独立的插件使用，需要调用其他插件。tuning，是一个通过 sysctl 调整网络设备参数的二进制文件；portmap，是一个通过 iptables 配置端口映射的二进制文件；bandwidth，是一个使用 Token Bucket Filter (TBF) 来进行限流的二进制文件。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;IPAM 插件：IP Address Management，它是负责分配 IP 地址的二进制文件。比如，dhcp，这个文件会向 DHCP 服务器发起请求；host-local，则会使用预先配置的 IP 地址段来进行分配。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9606164383561644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavO0Bwlpu6gGs5W9pevCZl4NibBG2hrBUianWErd5UrAVNHGbNZgnWzSRUUwd4SoDWDQA60uSytls2Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;584&quot;/&gt;&lt;figcaption&gt;K8s-CNI-plugins&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. kubelet 启动&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kubelet 在 Node 节点上负责 Pod 的创建、销毁、监控上报等核心流程，通过 Cobra 命令行解析参数启动二进制可执行文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动入口如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// kubernetes/cmd/kubelet/kubelet.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; command := app.NewKubeletCommand()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// kubelet uses a config file and does its own special&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// parsing of flags and that config file. It initializes&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// logging after it is done with that. Therefore it does&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// not use cli.Run like other, simpler commands.&lt;/span&gt;&lt;br/&gt; code := run(command)&lt;br/&gt; os.Exit(code)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着，一路往下进行初始化：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;cmd -&amp;gt; Run -&amp;gt; PreInitRuntimeService -&amp;gt; RunKubelet -&amp;gt; createAndInitKubelet -&amp;gt; startKubelet -&amp;gt; Run&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 PreInitRuntimeService 会进一步初始化 dockershim，一方面探测环境中的网络配置文件(默认路径为：/etc/cni/net.d/*.conf/.conflist/.json)，进行 CNI 网络配置；另一方面启动 gRPC docker server 监听 client 请求，进行具体的操作如 PodSandbox、Container 创建与删除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当监听到 Pod 事件时，进行对应 Pod 的创建或删除，流程如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Run -&amp;gt; syncLoop -&amp;gt; SyncPodCreate/Kill -&amp;gt; UpdatePod -&amp;gt; syncPod/syncTerminatingPod -&amp;gt; dockershim gRPC -&amp;gt; Pod running/teminated&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. Pod 创建/删除&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;K8s 中 Pod 的调谐采用 channel 生产者-消费者模型实现，具体通过 PLEG(Pod Lifecycle Event Generator) 进行 Pod 生命周期事件管理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// kubernetes/pkg/kubelet/pleg/pleg.go&lt;br/&gt;// 通过 PLEG 进行 Pod 生命周期事件管理&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; PodLifecycleEventGenerator interface {&lt;br/&gt; Start() // 通过 relist 获取所有 Pods 并计算事件类型&lt;br/&gt; Watch() chan *PodLifecycleEvent // 监听 eventChannel，传递给下游消费者&lt;br/&gt; Healthy() (bool, error)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pod 事件生产者 - 相关代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// kubernetes/pkg/kubelet/pleg/generic.go&lt;br/&gt;// 生产者：获取所有 Pods 列表，计算出对应的事件类型，进行 Sync&lt;br/&gt;func (g *GenericPLEG) &lt;span&gt;&lt;span&gt;relist&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; klog.V(5).InfoS(&lt;span&gt;&quot;GenericPLEG: Relisting&quot;&lt;/span&gt;)&lt;br/&gt; ...&lt;br/&gt; // 获取当前所有 Pods 列表&lt;br/&gt; podList, err := g.runtime.GetPods(&lt;span&gt;true&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  klog.ErrorS(err, &lt;span&gt;&quot;GenericPLEG: Unable to retrieve pods&quot;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; pid := range g.podRecords {&lt;br/&gt;  allContainers := getContainersFromPods(oldPod, pod)&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; _, container := range allContainers {&lt;br/&gt;&lt;br/&gt;   // 计算事件类型：running/exited/unknown/non-existent&lt;br/&gt;   events := computeEvents(oldPod, pod, &amp;amp;container.ID)&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; _, e := range events {&lt;br/&gt;    updateEvents(eventsByPodID, e)&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; // 遍历所有事件&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; pid, events := range eventsByPodID {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; i := range events {&lt;br/&gt;   // Filter out events that are not reliable and no other components use yet.&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; events[i].Type == ContainerChanged {&lt;br/&gt;    &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   select {&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; g.eventChannel &amp;lt;- events[i]: // 生产者：发送到事件 channel，对应监听的 goroutine 会消费&lt;br/&gt;   default:&lt;br/&gt;    metrics.PLEGDiscardEvents.Inc()&lt;br/&gt;    klog.ErrorS(nil, &lt;span&gt;&quot;Event channel is full, discard this relist() cycle event&quot;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pod 事件消费者 - 相关代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// kubernetes/pkg/kubelet/kubelet.go&lt;br/&gt;// 消费者：根据 channel 获取的各类事件，进行 Pod Sync&lt;br/&gt;func (kl *Kubelet) syncLoopIteration(configCh &amp;lt;-chan kubetypes.PodUpdate, handler SyncHandler,&lt;br/&gt; syncCh &amp;lt;-chan time.Time, housekeepingCh &amp;lt;-chan time.Time, plegCh &amp;lt;-chan *pleg.PodLifecycleEvent) bool {&lt;br/&gt; select {&lt;br/&gt; ...&lt;br/&gt; // 消费者：监听 plegCh 的事件&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; e := &amp;lt;-plegCh:&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; e.Type == pleg.ContainerStarted {&lt;br/&gt;   // 更新容器的最后启动时间&lt;br/&gt;   kl.lastContainerStartedTime.Add(e.ID, time.Now())&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; isSyncPodWorthy(e) {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; pod, ok := kl.podManager.GetPodByUID(e.ID); ok {&lt;br/&gt;    klog.V(2).InfoS(&lt;span&gt;&quot;SyncLoop (PLEG): event for pod&quot;&lt;/span&gt;, &lt;span&gt;&quot;pod&quot;&lt;/span&gt;, klog.KObj(pod), &lt;span&gt;&quot;event&quot;&lt;/span&gt;, e)&lt;br/&gt;&lt;br/&gt;    // 进行相关 Pod 事件的 Sync&lt;br/&gt;    handler.HandlePodSyncs([]*v1.Pod{pod})&lt;br/&gt;   } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    // If the pod no longer exists, ignore the event.&lt;br/&gt;    klog.V(4).InfoS(&lt;span&gt;&quot;SyncLoop (PLEG): pod does not exist, ignore irrelevant event&quot;&lt;/span&gt;, &lt;span&gt;&quot;event&quot;&lt;/span&gt;, e)&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  // 容器销毁事件处理：清除 Pod 内相关 Container&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; e.Type == pleg.ContainerDied {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; containerID, ok := e.Data.(string); ok {&lt;br/&gt;    kl.cleanUpContainersInPod(e.ID, containerID)&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt;  ...&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. Docker 忙起来&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过上一步 Pod 事件的生产与消费传递，PodWorkers 会将事件转化为 gRPC client 请求，然后调用 dockershim gRPC server，进行 PodSandbox、infra-container(也叫 pause 容器) 的创建。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着，会调用 CNI 接口 SetUpPod 进行相关网络配置与启动，此时建立起来的容器网络，就可以直接用于之后创建的业务容器如 initContainers、containers 进行共享网络。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相关代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// kubernetes/pkg/kubelet/dockershim/docker_sandbox.go&lt;br/&gt;// 启动运行 Pod Sandbox&lt;br/&gt;func (ds *dockerService) RunPodSandbox(ctx context.Context, r *runtimeapi.RunPodSandboxRequest) (*runtimeapi.RunPodSandboxResponse, error) {&lt;br/&gt; config := r.GetConfig()&lt;br/&gt;&lt;br/&gt; // Step 1: 拉取基础镜像(infra-container: k8s.gcr.io/pause:3.6)&lt;br/&gt; image := defaultSandboxImage&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err := ensureSandboxImageExists(ds.client, image); err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil, err&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; // Step 2: 创建 Sandbox 容器&lt;br/&gt; createConfig, err := ds.makeSandboxDockerConfig(config, image)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil, fmt.Errorf(&lt;span&gt;&quot;failed to make sandbox docker config for pod %q: %v&quot;&lt;/span&gt;, config.Metadata.Name, err)&lt;br/&gt; }&lt;br/&gt; createResp, err := ds.client.CreateContainer(*createConfig)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  createResp, err = recoverFromCreationConflictIfNeeded(ds.client, *createConfig, err)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; // Step 3: 创建 Sandbox 检查点(用于记录当前执行到哪一步了)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err = ds.checkpointManager.CreateCheckpoint(createResp.ID, constructPodSandboxCheckpoint(config)); err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil, err&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; // Step 4: 启动 Sandbox 容器&lt;br/&gt; err = ds.client.StartContainer(createResp.ID)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil, fmt.Errorf(&lt;span&gt;&quot;failed to start sandbox container for pod %q: %v&quot;&lt;/span&gt;, config.Metadata.Name, err)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; // Step 5: 对 Sandbox 容器进行网络配置&lt;br/&gt; err = ds.network.SetUpPod(config.GetMetadata().Namespace, config.GetMetadata().Name, cID, config.Annotations, networkOptions)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  // 如果网络配置失败，则回滚：删除建立起来的 Pod 网络&lt;br/&gt;  err = ds.network.TearDownPod(config.GetMetadata().Namespace, config.GetMetadata().Name, cID)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;   errList = append(errList, fmt.Errorf(&lt;span&gt;&quot;failed to clean up sandbox container %q network for pod %q: %v&quot;&lt;/span&gt;, createResp.ID, config.Metadata.Name, err))&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  // 停止容器运行&lt;br/&gt;  err = ds.client.StopContainer(createResp.ID, defaultSandboxGracePeriod)&lt;br/&gt;  ...&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; resp, nil&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流程图小结如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2427184466019416&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavO0Bwlpu6gGs5W9pevCZl4wWrSog5FBic8bGgQic0H08HRygENAjKGGINzmOIVp697n8gwHiclhdicwA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;721&quot;/&gt;&lt;figcaption&gt;K8s-CNI-flow&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;根据社区讨论&lt;a target=&quot;_blank&quot; href=&quot;https://kubernetes.io/blog/2020/12/02/dockershim-faq&quot; textvalue=&quot;‍Dockershim Deprecation FAQ‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;Dockershim Deprecation FAQ&lt;/a&gt;，dockershim 相关代码将会在 2021 底左右移出 K8s 主干代码，之后将统一使用 CRI(Container Runtime Interface, 容器运行时接口) 进行容器生命周期管理。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. CNI RPC 接口&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CNI 标准规范接口，包含了添加、检查、验证、删除网络等接口，并提供了按列表或单个进行网络配置的两组接口，方便用户灵活使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CNI 从容器管理系统(dockershim) 处获取运行时信息(Container Runtime)，包括 network namespace 的路径，容器 ID 以及 network interface name，再从容器网络的配置文件中加载网络配置信息，再将这些信息传递给对应的插件，由插件进行具体的网络配置工作，并将配置的结果再返回到容器管理系统中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.815668202764977&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavO0Bwlpu6gGs5W9pevCZl4SYibzaiaFLJ6Hsia1If3Oqf8v6zHLNJmg2qCpxLgbzFR6kw9KsrHXfGyg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;651&quot;/&gt;&lt;figcaption&gt;K8s-CNI-RPC&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户若要编写自己的 CNI 插件，则可专注于实现图中这些 RPC 接口即可，然后可以与官方维护的三类基础插件自由组合，形成多种多样的容器网络解决方案。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. 小结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文通过分析 K8s 中 kubelet 启动、Pod 创建/删除、Docker 创建/删除 Container、CNI RPC 调用、容器网络配置等核心流程，对 CNI 实现机制进行了解析，通过源码、图文方式说明了相关流程逻辑，以期更好的理解 K8s CNI 运行流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;K8s 网络模型采用 CNI(Container Network Interface, 容器网络接口) 协议，只要提供一个标准的接口，就能为同样满足该协议的所有容器平台提供网络功能。CNI 目前已被众多开源项目所采用，同时也是一个 CNCF(Cloud Native Computing Foundation) 项目。可以预见，CNI 将会成为未来容器网络的标准。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://github.com/containernetworking/cni/blob/master/SPEC.md&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;CNI 规范&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Kubernetes 源码&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://www.cni.dev/plugins/current/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;CNI 插件介绍&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://github.com/containernetworking/plugins&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;CNI 插件源码&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://thenewstack.io/container-networking-landscape-cni-coreos-cnm-docker/&quot; textvalue=&quot;CNI and CNM model&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;&lt;span&gt;CNI and CNM model&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;span/&gt;&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;最近热文：&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649765817&amp;amp;idx=1&amp;amp;sn=2eeb275c0200f6469c0b22c2eca62d08&amp;amp;chksm=becca4c289bb2dd4b3972c3a830c1c76d7b82e1a8d09edb6ce3a7f350d0ab1e663e320765b55&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;提速 30%！腾讯TQUIC 网络传输协议&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;提速 30%！腾讯TQUIC 网络传输协议&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649765666&amp;amp;idx=1&amp;amp;sn=d1e01a47c4b5cd394f76c6fdc2b261f9&amp;amp;chksm=becca45989bb2d4f4a1249d88c4d18d93c84c05bd60e320a77288a221cf56e685e733c324eb7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;大牛书单 | 消息队列方向的好书&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;大牛书单 | 消息队列方向的好书&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649765647&amp;amp;idx=1&amp;amp;sn=633ee3fbe564dfb30bf215c4b56c7288&amp;amp;chksm=becca47489bb2d6225a003f3a8724de976aa72d0ff764328435d42583014bbc2b12228853d19&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;微信 ClickHouse 实时数仓的最佳实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;微信 ClickHouse 实时数仓的最佳实践&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;腾讯程序员视频号直播&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;2.3342592592592593&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasfj9ibmaWydKdiagdarvrzZeabwHsVNNO3iaX4OUib0K4bhfaeqczIDicbzdCTkIANob01n9Os59NZAog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_live_iframe&quot; data-pluginname=&quot;videosnap&quot; data-headimgurl=&quot;https://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;将在12月01日 19:30 直播&quot; data-intro=&quot;对谈鹅厂T10女工程师：从0到1转程序员，兼顾技术和爱好，一直做自己喜欢的事&quot; data-noticeid=&quot;finderlivenotice-v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder-1638242262850720-131098678&quot; data-type=&quot;live&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>345636217150c73471e95635d73ebf49</guid>
<title>大型网站核心架构要素</title>
<link>https://toutiao.io/k/z9bqh7u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;container app-preview post-body&quot;&gt;
  &lt;div class=&quot;preview&quot;&gt;&lt;p&gt;架构一词，通俗的说法是“最高层次的规划，难以改变的决定”，这些规划和决定奠定了事物未来发展的方向和最终的蓝图。&lt;/p&gt;

&lt;p&gt;一般来说，除了系统功能需求外，软件架构还要关注性能、可用性、伸缩性、扩展性和安全性这5个架构要素。&lt;/p&gt;

&lt;p&gt;谈一下两个容易混淆的概念。伸缩性和扩展性。&lt;/p&gt;

&lt;p&gt;伸缩性是指大型网站需要面对大量用户的高并发访问和存储海量数据，不可能只用一台服务器就处理全部用户请求，存储全部数据。网站这集群方式将多台服务器组成一个整体共同提供服务。&lt;/p&gt;

&lt;p&gt;所谓伸缩性是指通过不断向集群中加入服务器的手段来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。举例说明，对于应用服务器集群、数据库集群等。&lt;/p&gt;

&lt;p&gt;扩展性是直接关注网站的功能需求，比如衡量网站架构性能好坏的主要标准就是在网站增加新的业务产品时，是否可以实现对现有产品透明无影响，不需要任何改动或者很少改动既有业务功能&lt;/p&gt;

&lt;p&gt;就可以上线新产品。扩展性的主要手段是事伯驱动架构和分布式服务。事件驱动架构在网站通常利用消息队列实现，将用户请求和其他业务事件构造成消息发布到消息队列，消息处理者作为消费者&lt;/p&gt;

&lt;p&gt;从消息队列中获取消息进行处理。通过这种方式将消息和消息处理分享开来，可以透明地增加新的消息生产者任务或者新的消息消费者任务。&lt;/p&gt;

&lt;p&gt;分布式服务则是将业务和可复用服务分离开来，通过分布式服务框架调用。新增产品可以通过调用可复用的服务实现自身的业务逻辑，而对现有产品没有任何影响。可复用服务升级变更的时候，也可以通过提供&lt;/p&gt;

&lt;p&gt;多版本服务对应用实现透明升级，不需要强制应用同步变更。&lt;/p&gt;

&lt;p&gt;【如果文字看累了，可b站搜索“沙皮狗2021”，用听的方式领略知识的魅力】&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fb6c2215077d81b06cad88bf7c55e5fb</guid>
<title>服务 API 版本控制设计与实践</title>
<link>https://toutiao.io/k/puc84fn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、前言&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;笔者曾负责vivo应用商店服务器开发，有幸见证应用商店从百万日活到几千万日活的发展历程。应用商店客户端经历了大大小小上百个版本迭代后，服务端也在架构上完成了单体到服务集群、微服务升级。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面主要聊一聊在业务快速发展过程中，产品不断迭代，服务端在兼容不同版本客户端的API遇到的问题的一些经验和心得。一方面让团队内童鞋对已有的一些设计思想有一个更彻底的理解，另一方面也是希望能引起一些遇到类似场景同行的共鸣，提供解决思路。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、通用解决方案&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;应用商店客户端迭代非常频繁，发布新的APP版本的时候，势必导致出现多版本，这样服务端就会导致多个不同的客户端请求。强制用户升级APP，可能会导致用户流失，因此采用多版本共存就是必须的。以下是业界讨论过的的一些SOA服务API版本控制方法参考[1]。在实际开发中原则上离不开以下三个方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;243&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;方案一：The Knot 无版本&lt;/strong&gt;——即平台的API永远只有一个版本，所有的用户都必须使用最新的API，任何API的修改都会影响到平台所有的用户。（如下图1）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;方案二：Point-to-Point&lt;/strong&gt;——点对点，即平台的API版本自带版本号，用户根据自己的需求选择使用对应的API，需要使用新的API特性，用户必须自己升级。（如下图2）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;方案三：Compatible Versioning&lt;/strong&gt;——兼容性版本控制，和The Knot一样，平台只有一个版本，但是最新版本需要兼容以前版本的API行为。（如下图3）&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;166&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;166&quot; data-ratio=&quot;0.2872661436330718&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4StAQE0cqsvqC96N4w5IAKDE8a7OhBR3IPV6QibTYmkf7ib5kXgzsNNMzh1WAcrAHazxfpyxjZdDibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1657&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（引用自：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.infoq.com/news/2013/12/api-versioning/&quot; textvalue=&quot;Mark Little&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;The Costs of Versioning an API&lt;/span&gt;&lt;/a&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;简单分析，The Knot只维护最新版本，对服务端而言维护有一定简化了，但是要求服务使用者及时适配最新的版本，这种做法不太适用用户产品，目前内部服务比较适用。Point-Point针对不同客户的版本提供独立的服务，当随着版本的增加开发和运维的维护成本会增加，这种在后面我们面对“协议升级”的时候有使用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;方案三应该是最常用的情况，服务端向后兼容。后面案例也主要采用这种思想，具体的做法也是有很多种，会结合具体的业务场景使用不同策略，这个会是接下来讨论的重点。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、具体业务场景面临的挑战和探索&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.1 The Knot 无版本和Point-to-Point模式的应用场景&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.465625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4StAQE0cqsvqC96N4w5IAKsBnb4hicxwDOs1tXbvVT8ib8f2GgCqa9zEynsv5PQneBUfJCtMrexvgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上图是我们应用商店迭代变化的一个缩影，业务发展到一定阶段面临以下挑战：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;147&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;1）业务发展前期，作为服务提供方，服务端不仅要支撑多个版本应用商店客户端，同时服务于软件侧的PC助手；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2）产品形态变化多样，服务端接口变更和维护面临多版本客户端兼容的挑战；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;3）架构逻辑上，服务端采用早期传统架构，开发和维护成本比较高；服务端与客户端进行交互的协议优化升级；以及服务拆分势在必行。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以服务端协议、框架升级以及公共服务拆分是首要解决的方向。改造经历了两个过程：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;阶段一&lt;/strong&gt;新版本新的接口一律采用新的JSON协议；已有功能接口进行兼容处理，根据客户端版本进行区分，返回不同协议的格式内容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;阶段二&lt;/strong&gt;随着业务迭代，新的版本商店依赖的所有接口都完成了协议升级后，为了提升服务的稳定性，旧的协议性能无法明显提升，一方面升级后端架构和框架，提升开发效率和可维护性。同时拆分和独立新的工程，实现历史工程只提供给历史版本使用。我们针对大流量高并发、以及基础服务场景比如首页、详情、下载进行独立服务独立拆分。同时也提取一些公共的内部RPC服务，比如获取应用详情、过滤服务等。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;272&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.470335339638865&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6AhKPG0LUCZlb3icoD0icLu7q7jesUpNGYWbFyjHUoMe8XyushibiaUm6lWkl5lTibp2aHriaGqKHlfOZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1163&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;经过改造，服务端架构如上图所示。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1）至此Old-Service后续只用进行相应的维护工作即可，对应Point-to-Point版本。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2）内部的RPC服务由于只提供内部服务，服务端和客户端可以随时同步升级，只要维护最新的版本就可以，采用The Knot模式。这里需要注意的是服务的升级需要注意保持向下兼容，在扩展字段或者修改字段的时候需要特别小心，不然可能在服务升级的时候会引起客户端调用的异常。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.2 Compatible Versioning：兼容性版本控制&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;兼容性版本控制应该是最常见的版本控制方式，特别是在C/S架构当中，具体的兼容性版本不同的策略总结有API版本、客户端版本号、功能参数标志等。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;场景一：API版本号控制&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;随着互联网发展的，用户体验要求也是越来越高，产品形式也会随之每年有不一样的变化。除了避免审美疲劳外，也是在不断探索如何提升屏效、点击率和转化。就拿应用商店首页列表举例。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;应用列表在形态上经历过单一的&lt;strong&gt;应用双排 -&amp;gt; 单排  -&amp;gt; 单排+穿插&lt;/strong&gt;的布局。内容上也经历了不同商业化模式、人工排期到算法等演进。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;每个版本接口内部逻辑变化是十分大的，有明显差异。如果只是简单在service层根据版本进行判断处理，会导致处理逻辑会变得异常复杂，并且还可能导致对低版本产生影响。同时商店首页是十分重要的业务场景，结合风险考虑，类似这样对场景，在接口URL上新增版本字段，不同对版本使用不同的值，在控制层根据不同的版本进行不同的处理逻辑会更加合理，简单有效。具体策略也有比如在URL上新增接口版本字段/{version}/index、请求头携带版本参数等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;场景二：客户端版本号控制&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;类似首页列表，商店的穿插Banner也经历了多个版本的迭代。如下图所示。这些穿插样式都是在不同版本下出现的，在样式布局，支持跳转能力等方面各个版本的支持程度不一样，接口返回时需要进行相应的处理适配、过滤等处理。 &lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;340&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5887290167865707&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6AhKPG0LUCZlb3icoD0icLu7eNEKPU1NH0yIrevicsD6prGJ8hhiahOAhYp3YAibiarQiatpLbAKC7JDagg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;834&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这类场景如果采用场景一的方案升级新的接口也能够解决，但是会存在大量重复代码，而且新增接口对于客户端接口改造、特别是一些接口路径会影响到大数据埋点统计，也是有比较高的沟通和维护成本在里面。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了提升代码复用性。使用客户端版本号控制是首选考虑策略。但是需要注意，如果只是简单的在代码层面根据客户端版本号进行判断，会存在以下问题需要考虑：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;132&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;1）代码层面会存在各种判断，造成的代码可读性差，有没有更加优雅的方法；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2）存在一个客观情况。那就是客户端的版本号是存在不确定性的。由于客户端采用火车发布模式 参考[2]，多版本并行开发，导致版本号存在变动、版本跳跃不连续的情况时有发生，也给服务端开发带来了不少困扰。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如何思考解决这些问题呢？其实对于不同的产品形态涉及的一些资源或者产品模块本身出现在不同的迭代周期，可以认为他们具备了版本或者时间的属性。站在程序员视角，把某个资源支持对应的客户端版本作为这个资源对象的一个成员属性。每种资源具有这种属性后，也有相应的逻辑行为来对应成员方法---根据属性进行过滤。这样的设计赋予资源了属性和行为后，资源具备了统一的、灵活的过滤能力，而不再是简单的硬编码根据版本进行if-else判断。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有了方案后，实施起来就比较容易了。开发分配资源ID，并且设置对应支持客户端版本范围。过滤逻辑统一到资源对象。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6971428571428572&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6AhKPG0LUCZlb3icoD0icLu7hjrialHMuogiaVFg3ygmCtBnYmE7w3Tia9IsfbczFewnjSVIQBiaNzxVzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;525&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;代码层面可以将过滤逻辑统一封装到一个工具类（示例代码），在各个业务接口返回进行过滤。更加优雅的方案是建立统一的资源上层类，封装资源过滤方法，所有资源位的资源对象实现该上层类，统一在获取资源逻辑完成过滤能力。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;场景三：新增功能标识参数&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;应用商店业务主要提供用户发现和下载新应用、更新手机已安装的应用。商店有增量更新可以减小更新包体积，因此也叫省流量更新，有效提升用户体验。前期我们使用开源的增量算法，但是发现该算法在部分机器合成拆分包会耗时很长，甚至引起crash。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;于是项目组寻求更加高效拆分算法。类似在这些已有接口的进行功能增强的场景，除了提供新的API或者内部简单通过客户端版本判断进行扩展外，有没有更好的方案呢？因为除了这些方案已知的弊端外，需要从长远考虑，比如前面提到的算法，后续还会不会存在升级的可能，下载接口会不会有更多能力的增强。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;结合上面思考，在原来接口基础上新增&lt;strong&gt;标志参数&lt;/strong&gt;字段，表示该请求发出的客户端支持的能力。为了后续扩展，字段类型为整数值，不只是简单的boolean，服务端通过&lt;strong&gt;位运算完成判断逻辑&lt;/strong&gt;。客户端也摆脱某个功能与版本的强一致性，不用去记录某个版本具有某种能力。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、关于接口设计的更多思考&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;最后补充一些踩过的坑和反思。服务端在提供接口时，不能仅仅关注接口的实现，更多的时候需要关注接口的使用方，他们使用的场景、调用时机等等。否则开发在对接口问题排查、维护花费的时间会比实际开发的耗时要多上好几倍。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;247&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;1）&lt;strong&gt;场景化&lt;/strong&gt;：具体到什么是场景化呢，拿商店客户端的帮助用户检测手机安装的应用版本是否最新的服务举例，检测时机是存在不同的场景的，比如用户启动、用户切换wlan环境、定时检测等。当需要进行精细化分析，哪些请求是有效的，哪些会引起集中请求时，这个时候如果请求上没有场景区分，那么分析将无从下手。所以在与客户端沟通接口设计时，请带上场景这个因素。接口设计上可参考如/app/{scene}/upgrade，定义好各个场景名称，在路径上带上具体的场景，这样对线上不同来源请求量级、问题分析都会有很大好处。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;197&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;2）&lt;strong&gt;鉴权和服务隔离&lt;/strong&gt;：除了场景需要考虑外，接口调用在分配时做好记录和鉴权以及服务隔离。比如商店的部分接口服务不仅提供给客户端，同时也会提供给手机系统应用调用。目前vivo上亿的存量用户体量，这里要十分小心，系统应用的调用量控制不当，并发可比商店本身要大的多。首先前期与服务调用方评估沟通、做好设计，避免出问题。即使在出问题时，也要有机制能够快速发现问题、能够分析出问题的来源，降低问题带来的损失。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;至此上面解决问题的思路，都与具体业务以及背景有一定关系。随着技术不断迭代和发展，在移动端APP页面动态性，目前业界也有了更多高效的技术方案，比如谷歌的Flutter、Weex等。这些技术能够实现灵活扩展，多端统一，性能也能够接近native。不仅减少了客户端发版频次，也减少了服务端兼容性处理成本。目前我们vivo也有团队在使用和实践。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;技术不断更迭，没有最好的方案，只有最适合的方案。开发过程中不仅满足当前实现，更多的是考虑到后续扩展性和可维护性。&lt;strong&gt;开发不能一味追求高端技术，技术最终服务于业务，坚持长期主义，效率至上&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、参考资料&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;1、&lt;/span&gt;&lt;a href=&quot;https://www.infoq.com/news/2013/12/api-versioning/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; data-link-opener-init=&quot;true&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;The Costs of Versioning an API&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;/span&gt;&lt;a href=&quot;https://www.scrumcn.com/agile/scrum/23572.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; data-link-opener-init=&quot;true&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;敏捷开发，火车发布模式&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:49.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>773eee9cd176b1ab0ba832c175086316</guid>
<title>香农和图灵的边界：溯源 DPU 的价值</title>
<link>https://toutiao.io/k/g7cannu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;markdown编辑器&quot; data-website=&quot;https://markdown.com.cn/editor&quot;&gt;&lt;blockquote data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;这是一篇原本给某金融大佬准备的DPU科普资料，起因是该大佬作为投资人问过很多计算方和应用方，大家都觉得DPU可有可无，而去问一些网络和基础架构的团队却是截然相反的答案。表面上DPU厂商都会说省了数据中心税，但是省了多少，增加了多少成本没有人算过&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;于是投资人辗转找到我这种在&lt;em&gt;&lt;span&gt;&lt;strong&gt;计算和通信的边缘反复试探的数学系法外狂徒张三&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;...&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;一个最本质的问题揭开了...&lt;span&gt;计算(CS)和通信(EE)两个专业的差异决定了DPU的价值&lt;/span&gt;，追根溯源，这种差异居然在上溯到两个行业的祖师爷&lt;code&gt;图灵&lt;/code&gt;和&lt;code&gt;香农&lt;/code&gt;时找到了答案. 两位都是最杰出的数学家，但是对于数字的动与静的不同视角带来了差异，这也是我一直在尝试着让大家理解下面这段话的最根本的意义：&lt;/p&gt;&lt;hr data-tool=&quot;markdown.com.cn编辑器&quot;/&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;网络的本质是承载数据流，内存是数据流在某个时刻的快照，而计算是基于快照信息而产生新的数据流。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;对于未来，以应用为中心,并兼顾软硬件一体化的传输协议才是我们最迫切需求。&lt;/p&gt;&lt;hr data-tool=&quot;markdown.com.cn编辑器&quot;/&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;从这个角度来看，市场上的所有的DPU都Over-engineering了，具体的内容在本文后面一些章节会谈到.&lt;/p&gt;&lt;h4 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;计算的本源&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;1936年，图灵向伦敦的数学杂志投了一篇题为《On Computable Numbers, with an Application to the Entscheidungsproblem》的论文。正是在这篇具有重要意义的论文中，图灵开始提出著名的“图灵机”(Turing Machine)的设想，给“可计算性”下了一个严格的数学定义:&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.0463414634146342&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9v5mpBibQrkjd3XfMGoaGRiaYAaaIuP7HZCleTNwrvmibqpxg5feeG0XLa8uQPQvPJJEQxTliauafcIVUhtrf1x5vQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;410&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;图灵机的基本思想是利用机器来模拟人使用纸笔进行数学运算的过程，通过一个机械操作的读写头去模拟笔和眼睛，可以在纸带上写上或者擦除某个符号，也可以像眼一样移动到纸的另一个位置。为了模拟人的这种行为，图灵构造出了这样一台假想的机器:&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;1、&lt;span&gt;一条无限长的纸带 TAPE&lt;/span&gt;。纸带被划分为一个接一个的小格子，每个格子上包含一个来自有限字母表的符号，字母表中有一个特殊的符号 表示空白。纸带上的格子从左到右依此被编号为 0，1，2，... ，纸带的右端可以无限伸展。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;2、&lt;span&gt;一个读写头 HEAD&lt;/span&gt;。该读写头可以在纸带上左右移动，它能读出当前所指的格子上的符号，并能改变当前格子上的符号。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;3、&lt;span&gt;一套控制规则 TABLE&lt;/span&gt;。它根据当前机器所处的状态以及当前读写头所指的格子上的符号来确定读写头下一步的动作，并改变状态寄存器的值，令机器进入一个新的状态。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;4、&lt;span&gt;一个状态寄存器&lt;/span&gt;。它用来保存图灵机当前所处的状态。图灵机的所有可能状态的数目是有限的，并且有一个特殊的状态，称为停机状态。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;注意这个机器的每一部分都是有限的，但它有一个潜在的无限长的纸带，因此这种机器只是一个理想的设备。图灵认为这样的一台机器就能模拟人类所能进行的任何计算过程。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;重要结论&lt;/code&gt; 你可以看到整个计算过程中，&lt;code&gt;运动&lt;/code&gt;的是机器和读写头，而&lt;code&gt;静止&lt;/code&gt;的是这一条&lt;code&gt;纸带&lt;/code&gt;.&lt;/p&gt;&lt;h4 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;通信的本源&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;1948年，香农发表了信息论的奠基性论文《A Mathematical Theory of Communication》,正如文章中一开始讲到的:&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.45625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9v5mpBibQrkjd3XfMGoaGRiaYAaaIuP7HZgicga033cZwNbicVxr49UxEQjFnbYxevhfAvNia07bBLQExIm2IF6iagyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;通信的基本问题就是在一个地方复现在另一个地方选定的消息，这一复现可能是准确的，也可能是近似的。这些消息通常有特定的含义；也就是说，它们会根据某一系统，与特定的物理或概念实体关联在一起。通信的语义与工程问题无关。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;重要结论&lt;/code&gt; 香农通过通信的手段，为图灵机拼凑出了一根&lt;code&gt;无限长&lt;/code&gt;的纸带。而图灵机改写的纸带格子又成了香农通信的信源。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4388349514563107&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9v5mpBibQrkjd3XfMGoaGRiaYAaaIuP7HZFo7bTZiac9tN2tVkpkVMqrSS7BXKwF7Xfbuib1AzryLiaahCmwXp8icZLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;515&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;冯·诺依曼结构&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;而把这一切黏贴起来的就是冯·诺依曼，利用香农发现的布尔代数与开关电路的等价性, 把图灵机的纸带变成了电子化的&lt;code&gt;存储器&lt;/code&gt;，而同样读写头变成了电子的运算器和控制器。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.40234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9v5mpBibQrkjd3XfMGoaGRiaYAaaIuP7HZXib0ibz64MqicffAH3o4xyXC6r3l0Vz2lhyUNELdrjv0sfia3D1lic01yNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;而计算的结果成了输出设备，也就是香农的信源。输入的设备也就成了香农论文中的信宿。而现代电子计算机发明的初期，数据流并不大，甚至到了现在我们考试用的机读卡也还是纸带传递信息。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6020583190394511&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9v5mpBibQrkjd3XfMGoaGRiaYAaaIuP7HZ6aRv6Hgeich3vr7sNX2USt8K2Pl3vVBd24larvn58Yn7pqm8WVMYVaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;583&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;冯·诺依曼瓶颈&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;伴随着过去数十年通信技术的飞速发展，特别是近十年，下图或许更能直观的显示这个问题&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5608695652173913&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9v5mpBibQrkjd3XfMGoaGRiaYAaaIuP7HZXe5tRn6wu6gRVNCfV15ibRuJaWhJgbzcRHPBDXibsZLicpUlcam6ic91vg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;传统的冯诺依曼架构中，计算单元和存储单元是分离的，因此大量的数据流动产生了内存墙和冯诺依曼瓶颈&lt;/p&gt;&lt;figure data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5293185419968305&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9v5mpBibQrkgffMUUxY9egia7fI2mCB7pyAyFpzT5hLaPL8mwDXTgf4ScaoAg3khvfo0FJUxzPVtbJM2OwV7G7vg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;631&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;本质上数据就像是一个大的洪峰(Network)到来时，你却只有一个小池塘(Memory),扩大内存带宽和添加Cache修筑大坝的疏浚工程一直都在做,但是您看看现在CPU周围的线已经密成什么样了？&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.937037037037037&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9v5mpBibQrkiar3ukeSLjicyficb1pMNqOR9NIwhp1hCWd6fdTP9gic7Ul57SLSSEHzEqgrmYBX2xMZjzpogNFkgxsw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;于是内存墙的瓶颈变成了一道难以逾越的天堑，无论是在带宽上或者是在容量上都难以达到要求。&lt;/p&gt;&lt;h4 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;走偏的Offload技术&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;头痛医头、脚痛医脚的思维方式逐渐显现出来，最有代表性的作品就是下面这个图了&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8794788273615635&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1228&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9v5mpBibQrkjd3XfMGoaGRiaYAaaIuP7HZ2SXLY8g5NTET6l3TbW9Ipqzp3zibeU9zIeHMH33TJibwXBhy8FvoWmAQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;一开始是发现，处理的单个请求数据量大了， 超过了一个数据包的长度，无论接收和发送都需要切分成一块块的转发，因此有了Large Segment Offload 和 Large Receive Offload的方式，另一方面是验证消息的完整性需要的Checksum计算。然后发现有多个处理器还有虚拟化的需求，逐渐开始实现SRIOV即虚拟出多块网卡给多个虚拟机用，并且支持多队列给每个核调度，例如RSS&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8256880733944955&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;545&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9v5mpBibQrkjd3XfMGoaGRiaYAaaIuP7HZtuXIDP8nxbIjTwA2p053AaRVzoHiaYkiasMI0EL5icibxDuxkop3KRrQNQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;然后紧接着发现虚拟机之间相同通信的虚拟交换机OVS成了性能瓶颈，于是开始卸载它，先是使用软件DPDK来通过专门使用一个核加速，然后是针对数据面FastPath卸载：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6538461538461539&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;780&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9v5mpBibQrkjd3XfMGoaGRiaYAaaIuP7HZlib5ARVdV9EXwOERfOgeud9CVLIA9T9bKyLl8hTnx8OTkiaGHWkyprpg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;另一个有趣的卸载方式就是瞄准了协议栈，主机的内核协议栈很多数据结构是互联网初期设计的，那个年代的带宽是28.8kbps，RDMA这种Kernel bypass并且可以Offload CPU的技术自然就成了大家追捧的热点，RoCE、TCP offload，当然解决了一个问题又引入了另一个问题，那就是RDMA自身的Go-back-N机制导致了需要无损网络。而这些吹捧无损网络的人真该回去好好看看香农的&amp;lt;通信的数学理论&amp;gt;，算一算信道容量。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5296296296296297&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9v5mpBibQrkiaDMygxuWdjKCsBSycPE9x1SvUoS3UWiaCkx7CskYfpSLfyo6BdZaicmJtYToGOfeIqGFpcf4CM62tQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;紧接着把这个局推向高潮的是两家云计算厂商，AWS Nitro采用了ARM多核RTC架构构建，阿里云神龙采用了FPGA的Pipeline架构。去年神龙的团队还跟我讨论过RTC和Pipeline的取舍，今年早些时候去拜访阿里云VPC团队的时候也谈及过这样的问题，最大的区别在业务需求上导致的Branch stall和相应的Branch Prediction上，RTC的Multi-Thread可以很好的隐藏延迟，而Pipeline架构则非常的难，具体的内容去看下面这个文章吧:&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNzQ5MTExNw==&amp;amp;mid=2247485370&amp;amp;idx=3&amp;amp;sn=b942ece597aaed0023b730dcb0a91a00&amp;amp;chksm=f9961778cee19e6e1a48cbda331a278aec03a9d5c142bb27bb64e83fb41a6351625348bef25b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;包处理的艺术(3)-RTC vs Pipeline&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;包处理的艺术(3)-RTC vs Pipeline&lt;/strong&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;然后大家看到这些云网络管理的软件占用CPU核的成本，于是开始Offload他们&lt;/p&gt;&lt;figure data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3111545988258317&quot; data-type=&quot;png&quot; data-w=&quot;1022&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9v5mpBibQrkjiaDavLAHQ1Rz0DVrHDbgic7qwAmaPATGuKRjlkrF72rLm4QaMhdX9EeAEicwIFlP5UPov9V8fxE6hQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;而这样的结果是，网卡上无论如何都有了一颗RTC的CPU，做OVS控制面的卸载、做安全功能卸载，然后整个行业还在yy疯狂的加功能...&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span&gt;“我们并没有做错什么，但不知道为什么，我们输了。”-诺基亚&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;不知道有多少人听过这句话，并为之黯伤。惯性思维之下的不停做加法便是最后输掉整个赛道的本质。例如直接把Windows系统搬上手机的微软和他的几个队友(多普达、HTC等)&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.96&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1025&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9v5mpBibQrkjd3XfMGoaGRiaYAaaIuP7HZBF4oZW9CGaHRYd0yLfdZTuPic74KyLHiaqq9V3EZlQpa4ZvJQGSBwFnQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;这就是在各种需求下惯性思维做出的东西，很短暂的就退出了历史舞台&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;结论&lt;/code&gt; 基于ARM多核的DPU架构团队基本上工程交付难度比做一颗通用CPU还高，而基于P4 Pipeline的团队在功能上特别是RFP应答上会面临重大的缺陷， 最本源的问题是，我们真的需要Offload这么多功能么？&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;追溯本源&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;工业界大佬里看清楚这个问题的本质的，大概只有两个人，一个是大神金克拉Jim Keller，至于他的光辉历程，下面这张图讲的够清楚了，而说他看清楚了这个问题是因为他最近在Tenstorrent的东西做的非常有趣&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8114186851211073&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9v5mpBibQrkjd3XfMGoaGRiaYAaaIuP7HZYgJJLcoN5pBg0N4cmZDs0PaXzAWXWKmKAVibawsMHsSrUlJJ22YvVlQ/640?wx_fmt=jpeg&quot; data-w=&quot;&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;而另一个人是Victor Peng，Xilinx的CEO在ISSCC 2021的讲稿有这样一页&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.54453125&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9v5mpBibQrkjd3XfMGoaGRiaYAaaIuP7HZU0tTziaXx8fdaxh8z6k0iaB9emtIoLfEOptlnuVNVLhIibpYOMRCHrXaA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;Offload的加法已经过时了，而需要考虑的是如何改变计算的范式。&lt;/p&gt;&lt;h4 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;再谈Offload&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;或许对于Offload怎么错的，工业界在大量的资本压榨下没有人敢发声，毕竟要做减法端掉自己的屁股还是甚少有人有这个勇气的。那么我们再来说一个形象的比喻：早期的汽车制造每装配一辆汽车要728个人工小时,因为车是不动的，由工人去拿各种零件来安装，而工人的熟练度又有所不同，有的人就连材料和工具都不认识，这样既降低了效率，又浪费了人手。而Offload的做法无非就是给工人配螺丝刀、扳手等工具来加速，虽然短期来看解决了工人处理的瓶颈，的确收益大于成本，但时间长了又会发现整个运送原件的效率成了瓶颈，也就是说工人本身移动的速度成为了瓶颈。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;解决问题的关键往往是从最底层的地方去思考，1921年福特决定换一种思路，不是让人适应工作，而是让工作适应人，提供人们简单易学的任务，练一天就能上手，这样就解决了劳动力不足和效率不高的问题，流水线就这样诞生了。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;而DPU需要去做的正是这条流水线，而不是去给工人提供加速工具卸载他们负担。&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;静止的图灵 vs 流动的香农&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;再回到本文的开头，图灵机需要的是一张&lt;strong&gt;&lt;span&gt;静态纸带&lt;/span&gt;&lt;/strong&gt;供它计算，而香农把图灵修改的&lt;strong&gt;&lt;span&gt;纸带流动&lt;/span&gt;&lt;/strong&gt;起来了。动静之间，也就推出分布式系统中最重要的一致性问题，多个图灵机的计算需要达成共识才能满足一致性。动静之间诞生了&lt;code&gt;存内计算&lt;/code&gt;和&lt;code&gt;在网计算&lt;/code&gt;的场景，其实这些都和福特发明流水线的做法是惊人的一致的，只是所有的DPU厂商尚未真正意识到这样的变革，还在学着微软和诺基亚制造着新一代智能手机(不对，智能网卡)&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;而像苹果那样，把手机只是当成一个App的变革也正在发生，下一代DPU内，网卡只是一个非常简单的App，正如前一节Victor Peng的ppt，统一的存内计算才是分布式计算的关键，一条最标准的流水线就是打通各个节点隐藏通信的内存接口。&lt;/p&gt;&lt;figure data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6509259259259259&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9v5mpBibQrkgffMUUxY9egia7fI2mCB7py1vPfzJqKGTGtibY9oHicqwuHDtmNycUImFiaMhj1c2N1ZZic4noyeXgzCg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;动静之间的接口便是一块内存，也就是文章开头那句话:&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span&gt;网络的本质是承载数据流，而内存是数据流在某个时刻的快照，而计算是基于快照信息而产生新的数据流。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;从数据中心到以数据为中心&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;从计算的演进的过程来看，Armin博士在去年SIGCOMM上讲的这张ppt总结的非常好&lt;/p&gt;&lt;figure data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5425925925925926&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9v5mpBibQrkhZjcUIMkzvebLAnFdHZ6rsN26fXGMScdoxOaB0txxRYdUibknXoJibMjdTy7omGMJEIn20qQ3iciauZA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;从早期的人机通信到计算机之间的相互通信，以及传统的机器互通或者业务互通，计算机体系结构的设计主要是以&lt;code&gt;静态数据&lt;/code&gt;和&lt;code&gt;计算逻辑&lt;/code&gt;为主。本质上是撰写代码去处理数据。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;当发展到第三代末期的时候，复杂的应用程序已经无法在单台机器上运行了。阿里巴巴诞生在这个年代，而阿里云的诞生本质也就是第四代分布式计算架构的代表。多核心处理器的出现，Spine-Leaf这样的分布式网络架构，Overlay技术等等。伴随着这些技术人与人的沟通交互变得更加便捷，也没有了难做的生意.&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;但是这一代架构又遇到一些问题，一方面是由于交互产生的&lt;code&gt;数据流动&lt;/code&gt;需要更加实时的计算。从Hadoop到Spark、Flink的转变就可以看出人们对数据交互实时性的需求.另一方面是AI的兴起使得计算范式发生了巨大的变化，人开始向机器寻求洞察力。这种洞察力体现在由机器以数据为中心的计算模式，这种模式并不是简单的去处理数据，而最大的变革是要从数据中抽取能够产生决策的代码。&lt;/p&gt;&lt;h4 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;减法！减法！&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;hr data-tool=&quot;markdown.com.cn编辑器&quot;/&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;Simplicity is a great virtue but it requires hard work to achieve it and education to appreciate it.&lt;/p&gt;&lt;section&gt;-EDSGER W.DIJKSTRA&lt;/section&gt;&lt;hr data-tool=&quot;markdown.com.cn编辑器&quot;/&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;你会发现我们设计的新一代智能网卡像智障一样简单，而这种简单正如福特的那条流水线只有一个轨道和一些托盘一样:&lt;/p&gt;&lt;figure data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.549074074074074&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9v5mpBibQrkgx68ZQMBrvSw1KFmKlia23IRKzxuFXx8hns6z0d9npVD0f0ERngtdzhk9FEywCIlJR0Ah5fhn0ESg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;而这条新的流水线就是上图中的Memory abstraction layer，而网卡自己的结构真的简单到一开始你都看不出它有什么特别的&lt;/p&gt;&lt;figure data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5166666666666667&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9v5mpBibQrkgffMUUxY9egia7fI2mCB7pykumjB7ODnWWfkDo04AIAgA699ZPWgNNROrCs9FoGJJKL7Z2MT0ibmdA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;而艺术的本源就在这里，也就是文章一开头的另一句话:&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span&gt;对于未来，以应用为中心,并兼顾软硬件一体化的传输协议才是我们最迫切需求。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;其实就是一个基于数据包的传输协议，无论在主机内还是在通信中具有相同的格式和相同的范式，把计算的指令射向数据，而不是把数据搬到计算节点,正如福特当年发明流水线，不是让人适应工作，而是让工作适应人。而我们不是让数据进入数据中心，而是以数据为中心，流动着进行计算。&lt;/p&gt;&lt;figure data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9081272084805654&quot; data-type=&quot;png&quot; data-w=&quot;849&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9v5mpBibQrkgffMUUxY9egia7fI2mCB7pyiazKQaukdqOnOfWNyd7WHmMS2mzdsicN7GdzS1G1icAGntcfrJO0DKkrg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;例如zmemif这样的项目，直接给容器提供用户态的内存交付接口，使得go这一类的应用能够轻松应付千万级QPS的需求，话说字节开发cloudwego的同学可以去看看集成到你们的Netpoll中:)&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;通过一个跨越多机的内存抽象层，把繁复的问题都解决了。而Serverless的框架也顺带把虚拟化的问题清理干净了，于是整个网卡非常干净,业务的性能又非常高，在这个流水线上调用专业工人(不对，学名叫DomainSpecific ASIC，DSA)的能力也非常好。&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结论&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;正如福特发明流水线，乔老爷子发明Iphone，抑或是Elon Mask构建SpaceX。很多事情你需要去从问题的最根源的地方考虑，并在那里寻求到自己的答案，技术和艺术的区别就在此。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;图灵和香农都是数学家，但你需要理解他们受人以渔的精髓:&lt;/p&gt;&lt;figure data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5949367088607594&quot; data-type=&quot;jpeg&quot; data-w=&quot;553&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9v5mpBibQrkhvHR3H4solptPzjPJqJRkiaswia8vkemAf4ticJPWaWY7fNWsWsyYF0OxtGdVETty7htZnub9TMsDhQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;也正如乔老爷说:&lt;/p&gt;&lt;hr data-tool=&quot;markdown.com.cn编辑器&quot;/&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;Design is a funny word. Some people think design means how it looks. But of course, if you dig deeper, it&#x27;s really how it works. The design of the Mac wasn&#x27;t what it looked like, although that was part of it. Primarily, it was how it worked. To design something really well, you have to get it. You have to really grok what it&#x27;s all about. It takes a passionate commitment to really thoroughly understand something, chew it up, not just quickly swallow it. Most people don&#x27;t take the time to do that.&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;Simplicity is the ultimate sophistication.&lt;/p&gt;&lt;hr data-tool=&quot;markdown.com.cn编辑器&quot;/&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c5fefeeacedbbd0d993bf6c419c7393e</guid>
<title>属性动画机制原理解析</title>
<link>https://toutiao.io/k/mj4t7l2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;动画的使用是 Android 开发中常用的知识&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可是动画的种类繁多、使用复杂，每当需要采用自定义动画 实现 复杂的动画效果时，很多开发者就显得束手无策；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天我们就来从源码中分析属性动画原理&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、动画简单应用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;ValueAnimator&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;属性动画的最核心的类,原理：控制值的变化，之后手动赋值给对象的属性，从而实现动画;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于控制的值的不同，Android 提供给我们三种构造方法来实例ValueAnimator对象:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ValueAnimator.ofInt(int... values) -- 整型数值&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ValueAnimator.ofFloat(float... values) -- 浮点型数值&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ValueAnimator.ofObject(TypeEvaluator evaluator, Object... values) -- 自定义对象类型&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、java方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                ValueAnimator animator = ValueAnimator.ofInt(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                animator.setDuration(&lt;span class=&quot;code-snippet__number&quot;&gt;5000&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                animator.setStartDelay(&lt;span class=&quot;code-snippet__number&quot;&gt;300&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                animator.setRepeatCount(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                animator.setRepeatMode(ValueAnimator.RESTART);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                animator.addUpdateListener(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ValueAnimator.AnimatorUpdateListener() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;onAnimationUpdate&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ValueAnimator animation)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; currentValue = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;) animation.getAnimatedValue();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        Log.d(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;test&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;onAnimationUpdate: &quot;&lt;/span&gt; + currentValue);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        view.setproperty(currentValue);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        view.requestLayout();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                animator.start();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、 XML 方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在路径 res/animator/ 路径下常见 XML 文件，如 set_animator.xml&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在上述文件中设置动画参数&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// ValueAnimator采用&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;animator&lt;/span&gt;&amp;gt;&lt;/span&gt;  标签&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;animator&lt;/span&gt; &lt;span class=&quot;code-snippet__attr&quot;&gt;xmlns:android&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;android:duration&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;1000&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;android:valueFrom&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;android:valueTo&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;android:valueType&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;floatType&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;android:repeatCount&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;android:repeatMode&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;reverse&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Java代码启动动画&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Animator animator = AnimatorInflater.loadAnimator(context, R.animator.set_animation);  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;animator.setTarget(view);  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;animator.start();  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、原理详解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8393632416787264&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kyDL16ViavhG0lz2qrpJCPMzEhlicV8Vjx2rNrjFWsq7Z7bzWfzzRj8O0UNeVIDKpSqFkeyIAvG3libDWGIEEbuTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;691&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、创建动画&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ObjectAnimator.ofFloat()开始；&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@param&lt;/span&gt; propertyName 属性名称，要求对象须有setXXX() 方法，且是 public 的。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@param&lt;/span&gt; values，属性变化的值，可以设置  1 个或者 多个。当只有 1 个时，起始值为属性值本身。当有 2 个值时，第 1 个为起始值，第 2 个为终止值。当超过 2 个时，首尾值的定义与 2 个时一样，中间值做需要经过的值。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; ObjectAnimator &lt;span class=&quot;code-snippet__title&quot;&gt;ofFloat&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Object target, String propertyName, &lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt;... values)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ObjectAnimator anim = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ObjectAnimator(target, propertyName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        anim.setFloatValues(values);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; anim;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;构造 ObjectaAnimator&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; ObjectAnimator(&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; target, &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; propertyName) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        setTarget(target);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        setPropertyName(propertyName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;分别调用了 setTarget() 方法和setPropertyName()；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、setTarget()&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; setTarget(&lt;span class=&quot;code-snippet__meta&quot;&gt;@Nullable&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; target) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        final &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; oldTarget = getTarget();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (oldTarget != target) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (isStarted()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                cancel();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mTarget = target == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; ? &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; : &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; WeakReference&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt;(target);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// New target should cause re-initialization prior to starting&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mInitialized = &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、setPropertyName()&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; setPropertyName(&lt;span class=&quot;code-snippet__meta&quot;&gt;@NonNull&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; propertyName) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// mValues could be null if this is being constructed piecemeal. Just record the&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// propertyName to be used later when setValues() is called if so.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (mValues != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            PropertyValuesHolder valuesHolder = mValues[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; oldName = valuesHolder.getPropertyName();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            valuesHolder.setPropertyName(propertyName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mValuesMap.remove(oldName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mValuesMap.put(propertyName, valuesHolder);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mPropertyName = propertyName;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// New property/values/target should cause re-initialization prior to starting&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mInitialized = &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;记录下 propertyName 的名字；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;而如果已经有这个 propertyName，则会替换其相应的 PropertyValuesHolder，这里用了一个 HashMap 来保存 propertyName 和 PropertyValuesHolder&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果propertyName 是 &quot;translationX&quot;；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接下来看 setFloatValues() 方法；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、setFloatValues()&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;setFloatValues&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt;... values)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (mValues == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt; || mValues.length == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// 当前还没有任何值&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (mProperty != &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                setValues(PropertyValuesHolder.ofFloat(mProperty, values));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                setValues(PropertyValuesHolder.ofFloat(mPropertyName, values));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// 当前已经有值的情况，调用父类的 setFloatValues（）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;super&lt;/span&gt;.setFloatValues(values);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;父类，即 ValueAnimator ，其方法setFloatValues() 如下；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5、ValueAnimator#setFloatValues()&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;setFloatValues&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt;... values&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (values == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; || values.length == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (mValues == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; || mValues.length == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            setValues(PropertyValuesHolder.ofFloat(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt;, values));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            PropertyValuesHolder valuesHolder = mValues[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            valuesHolder.setFloatValues(values);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// New property/values/target should cause re-initialization prior to starting&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mInitialized = &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不管是否调用父类的 setFloatValues()；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最后都是要将 values 逐个构造成 PropertyValuesHolder，最后存放在前面所说的 HashMap 里面；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当然，如果这里的 hashMap 还没有初始化，则先会将其初始化；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最关键的是要构建出 PropertyValuesHolder 这个对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;那么就继续来看看 PropertyValuesHolder#ofFloat() 方法；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;6、PropertyValuesHolder#ofFloat()&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; PropertyValuesHolder &lt;span class=&quot;code-snippet__title&quot;&gt;ofFloat&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String propertyName, &lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt;... values)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; FloatPropertyValuesHolder(propertyName, values);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;构造 FloatPropertyValuesHolder；&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;FloatPropertyValuesHolder&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;FloatPropertyValuesHolder&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String propertyName, &lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt;... values)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;super&lt;/span&gt;(propertyName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            setFloatValues(values);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;FloatPropertyValuesHolder 构造函数比较简单，调用父类的构造方法并传递了 propertyName；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;关键是进一步 setFloatValues() 方法的调用；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;其又进一步调用了父类的 setFloatValues()，在父类的 setFloatValues() 方法里初始化了动画的关键帧；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;PropertyValuesHolder&lt;span class=&quot;code-snippet__meta&quot;&gt;#setFloatValues()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;setFloatValues&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt;... values&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mValueType = &lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt;.class;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mKeyframes = KeyframeSet.ofFloat(values);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;7、KeyframeSet#ofFloat()&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; KeyframeSet &lt;span class=&quot;code-snippet__title&quot;&gt;ofFloat&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt;... values)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; badValue = &lt;span class=&quot;code-snippet__keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; numKeyframes = values.length;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 至少要 2 帧&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        FloatKeyframe keyframes[] = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; FloatKeyframe[Math.max(numKeyframes,&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;)];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 然后构造出每一帧，每一帧中主要有 2 个重要的参数 fraction 以及 value&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (numKeyframes == &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            keyframes[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;] = (FloatKeyframe) Keyframe.ofFloat(&lt;span class=&quot;code-snippet__number&quot;&gt;0f&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            keyframes[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;] = (FloatKeyframe) Keyframe.ofFloat(&lt;span class=&quot;code-snippet__number&quot;&gt;1f&lt;/span&gt;, values[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (Float.isNaN(values[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;])) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                badValue = &lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            keyframes[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;] = (FloatKeyframe) Keyframe.ofFloat(&lt;span class=&quot;code-snippet__number&quot;&gt;0f&lt;/span&gt;, values[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;; i &amp;lt; numKeyframes; ++i) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                keyframes[i] =&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        (FloatKeyframe) Keyframe.ofFloat((&lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt;) i / (numKeyframes - &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;), values[i]);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (Float.isNaN(values[i])) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    badValue = &lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (badValue) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Log.w(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Animator&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Bad value (NaN) in float animator&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 最后将所有的 关键帧 汇集到一个集合中&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; FloatKeyframeSet(keyframes);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;其主要内容是：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;构造动画的关键帧，且动画里至少要有 2 个关键帧；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;关键帧中有 2 个重要的参数，fraction这个可以看成是关键帧的序号，value 关键帧的值，可能是起始值，也可能是中间的某个值；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最后将关键帧汇集成一个关键帧集返回给 PropertyValuesHolder；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;8、setDuration()&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@NonNull&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; ObjectAnimator &lt;span class=&quot;code-snippet__title&quot;&gt;setDuration&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; duration)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;super&lt;/span&gt;.setDuration(duration);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;调用了父类 ValueAnimator 的 setDuration()；&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ValueAnimator&lt;span class=&quot;code-snippet__meta&quot;&gt;#setDuration()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @&lt;span class=&quot;code-snippet__function&quot;&gt;Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; ValueAnimator &lt;span class=&quot;code-snippet__title&quot;&gt;setDuration&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; duration&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (duration &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Animators cannot have negative duration: &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    duration);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mDuration = duration;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;setDuration() 只是简单的存储下 duration 的值，仅此而已，那么继续分析 setInterpolator()；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;9、setInterpolator()&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@&lt;span class=&quot;code-snippet__function&quot;&gt;Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;setInterpolator&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;TimeInterpolator &lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt; != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mInterpolator = &lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mInterpolator = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; LinearInterpolator();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;10、 LinearInterpolator粗略分析；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt; * 插值器定义了动画变化的频率，其可以是线性的也可以是非线性的，如加速运动或者减速运动；&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;TimeInterpolator&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * 这里传进来的 input 代表当前时间与总时间的比，根据这个时间占比返回当前的变化频率。其输出与输值都在 [0,1] 之间&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getInterpolation&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt; input&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;插值器的关键定义便是实现 getInterpolation() 方法，即根据当前动画运行的时间占比来计算当前动画的变化频率；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么来看看 LinearInterpolator 的 getInterpolation() 实现；&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;LinearInterpolator&lt;span class=&quot;code-snippet__meta&quot;&gt;#getInterpolation()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getInterpolation&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt; input&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; input;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;对，就是返回原值，因为时间的变化肯定始终都是匀速的；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;11、start&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;启动动画从 start() 方法开始&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        AnimationHandler.getInstance().autoCancelBasedOn(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (DBG) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Log.d(LOG_TAG, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Anim target, duration: &quot;&lt;/span&gt; + getTarget() + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;, &quot;&lt;/span&gt; + getDuration());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; mValues.length; ++i) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                PropertyValuesHolder pvh = mValues[i];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                Log.d(LOG_TAG, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;   Values[&quot;&lt;/span&gt; + i + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;]: &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    pvh.getPropertyName() + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;, &quot;&lt;/span&gt; + pvh.mKeyframes.getValue(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;, &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    pvh.mKeyframes.getValue(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;super&lt;/span&gt;.start();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;// 参数 playBackwards 代表动画是否是逆向的&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; playBackwards)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       .....&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mReversing = playBackwards;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 重置脉冲为 &quot;true&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mSelfPulse = !mSuppressSelfPulseRequested;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        .....&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 添加脉冲回调用&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        addAnimationCallback(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (mStartDelay == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; || mSeekFraction &amp;gt;= &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; || mReversing) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// If there&#x27;s no start delay, init the animation and notify start listeners right away&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// to be consistent with the previous behavior. Otherwise, postpone this until the first&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// frame after the start delay.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            startAnimation();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (mSeekFraction == -&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__comment&quot;&gt;// No seek, start at play time 0. Note that the reason we are not using fraction 0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__comment&quot;&gt;// is because for animations with 0 duration, we want to be consistent with pre-N&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__comment&quot;&gt;// behavior: skip to the final value immediately.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                setCurrentPlayTime(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                setCurrentFraction(mSeekFraction);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;其中之一是 addAnimationCallback()，其主要是向 AnimationHander 添加一个回调接口AnimationHandler.AnimationFrameCallback，如下代码；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;addAnimationFrameCallback&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * Register to get a callback on the next frame after the delay.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;addAnimationFrameCallback&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;final AnimationFrameCallback callback, &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; delay&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (mAnimationCallbacks.size() == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            getProvider().postFrameCallback(mFrameCallback);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!mAnimationCallbacks.contains(callback)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mAnimationCallbacks.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(callback);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (delay &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mDelayedCallbackStartTime.put(callback, (SystemClock.uptimeMillis() + delay));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;12、startAnimation()&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;startAnimation&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ......&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mAnimationEndRequested = &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        initAnimation();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mRunning = &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (mSeekFraction &amp;gt;= &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mOverallFraction = mSeekFraction;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mOverallFraction = &lt;span class=&quot;code-snippet__number&quot;&gt;0f&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (mListeners != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// 通过动画监听器动画开始了&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            notifyStartListeners();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关键调用 initAnimation()&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;initAnimation&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!mInitialized) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; numValues = mValues.length;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; numValues; ++i) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                mValues[i].init();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mInitialized = &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;mValues 是 PropertyValuesHolder 数组，这里的目的是初始化 PropertyValuesHolder；&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;void &lt;span class=&quot;code-snippet__keyword&quot;&gt;init&lt;/span&gt;() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (mEvaluator == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// We already handle int and float automatically, but not their Object&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// equivalents&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mEvaluator = (mValueType == Integer.&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt;) ? sIntEvaluator :&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    (mValueType == &lt;span class=&quot;code-snippet__built_in&quot;&gt;Float&lt;/span&gt;.&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt;) ? sFloatEvaluator :&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (mEvaluator != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// KeyframeSet knows how to evaluate the common types - only give it a custom&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// evaluator if one has been set on this class&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mKeyframes.setEvaluator(mEvaluator);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;init() 方法的主要目的是就是给关键帧设置估值器；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;前面调用的是 ObjectAnimator#ofFloat() 方法，所以这里默认给的就是 FloatEvaluator；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接下来就会进一步调用 setCurrentPlayTime() 来开始动画；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;13、setCurrentPlayTime()&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;setCurrentPlayTime&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; playTime&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt; fraction = mDuration &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; ? (&lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt;) playTime / mDuration : &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        setCurrentFraction(fraction);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;14、setCurrentFraction&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;setCurrentFraction&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt; fraction)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 再次调用 initAnimation() ，前面初始化过了，所以这里是无用的&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        initAnimation();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 校准 fraction 为 [0, mRepeatCount + 1]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        fraction = clampFraction(fraction);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mStartTimeCommitted = &lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;; &lt;span class=&quot;code-snippet__comment&quot;&gt;// do not allow start time to be compensated for jank&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (isPulsingInternal()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// 随机时间？&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; seekTime = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt;) (getScaledDuration() * fraction);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// 获取动画的当前运行时间&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; currentTime = AnimationUtils.currentAnimationTimeMillis();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// Only modify the start time when the animation is running. Seek fraction will ensure&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// non-running animations skip to the correct start time.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// 得到开始时间&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mStartTime = currentTime - seekTime;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// If the animation loop hasn&#x27;t started, or during start delay, the startTime will be&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// adjusted once the delay has passed based on seek fraction.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mSeekFraction = fraction;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mOverallFraction = fraction;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt; currentIterationFraction = getCurrentIterationFraction(fraction, mReversing);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 执行动画，注意这里会先调用子类的 animateValue() 方法&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        animateValue(currentIterationFraction);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;前面都是一些时间的计算，得到当前真正的currentIterationFraction，最后会通过调用animateValue() 来执行动画；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;15、 ObjectAnimator#animateValue()&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;animateValue&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt; fraction)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; Object target = getTarget();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (mTarget != &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; target == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// We lost the target reference, cancel and clean up. Note: we allow null target if the&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;/// target has never been set.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            cancel();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 调用父类的 animateValue() ，这个很关键，时间插值与估值器的计算都在父类的 animateValue() 方法中进行的。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;super&lt;/span&gt;.animateValue(fraction);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; numValues = mValues.length;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; numValues; ++i) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// 这里的 mValues 的是PropertyValuesHolder[]，也就是在 PropertyValuesHolder 里面来改变了目标 target 的属性值。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mValues[i].setAnimatedValue(target);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;父类 ValueAnimator#animateValue()&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;animateValue&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt; fraction&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 获取时间插值&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        fraction = mInterpolator.getInterpolation(fraction);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mCurrentFraction = fraction;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; numValues = mValues.length;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 将时间插值送给估值器，计算出 values&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; numValues; ++i) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mValues[i].calculateValue(fraction);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;span class=&quot;code-snippet__comment&quot;&gt;// 发出通知&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (mUpdateListeners != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; numListeners = mUpdateListeners.size();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; numListeners; ++i) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                mUpdateListeners.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(i).onAnimationUpdate(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;animateValue()：&lt;/span&gt;&lt;span&gt; 计算时间插值和估值器、调用 PropertyValuesHolder 来改变属性；&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;setAnimatedValue&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Object target&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (mProperty != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mProperty.&lt;span class=&quot;code-snippet__keyword&quot;&gt;set&lt;/span&gt;(target, getAnimatedValue());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (mSetter != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                mTmpValueArray[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;] = getAnimatedValue();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__comment&quot;&gt;// 通过反射调用来修改属性值&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                mSetter.invoke(target, mTmpValueArray);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (InvocationTargetException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                Log.e(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;PropertyValuesHolder&quot;&lt;/span&gt;, e.toString());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (IllegalAccessException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                Log.e(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;PropertyValuesHolder&quot;&lt;/span&gt;, e.toString());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;这里就是通过属性的 Setter 方法来修改属性的；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分析到这里，就完成了动画的一帧关键帧的执行；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;剩下的帧是怎么驱动的呢？还是得回到 start() 方法里面，在这里最初分析到 addAnimationFrameCallback() 方法；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;这个方法里等于是向AnimationHandler注册了AnimationHandler.AnimationFrameCallback；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;这个 callback 中其中之一的方法是 doAnimationFrame()；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在 &lt;strong&gt;ValueAnimator&lt;/strong&gt; 的实现中如下；&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;doAnimationFrame&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; frameTime)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        .....&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; finished = animateBasedOnTime(currentTime);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (finished) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            endAnimation();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; finished;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这段代码原来也是很长的，我们只看关键调用 animateBasedOnTime()&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;animateBasedOnTime&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; currentTime)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; done = &lt;span class=&quot;code-snippet__keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (mRunning) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            .....&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt; currentIterationFraction = getCurrentIterationFraction(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    mOverallFraction, mReversing);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            animateValue(currentIterationFraction);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; done;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;目的也还是计算出 currentIterationFraction；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过 animateValue() 方法来执行动画；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以看到只要 doAnimationFrame() 被不断的调用，就会产生动画的一个关键帧；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果关键帧是连续的，那么最后也就产生了我们所看到的动画；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;再来分析doAnimationFrame() 是如何被不断调用的；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;这个需要回到 AnimationHandler 中来，在 AnimationHandler 中有一个非常重要的 callback 实现——Choreographer.FrameCallback；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; Choreographer.FrameCallback mFrameCallback = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Choreographer.FrameCallback() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;doFrame&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; frameTimeNanos)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            doAnimationFrame(getProvider().getFrameTime());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (mAnimationCallbacks.size() &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                getProvider().postFrameCallback(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    };&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Andorid 中的重绘就是由Choreographer在 1 秒内产生 60 个 vsync 来通知 view tree 进行 view 的重绘的；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;而 vsync 产生后会调用它的监听者回调接口 Choreographer.FrameCallback，；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;也就是说，只要向Choreographer注册了这个接口，就会每 1 秒里收到 60 次回调；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;因此，在这里就实现了不断地调用 doAnimationFrame() 来驱动动画了；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;16、流程总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;动画是由许多的关键帧组成的；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;属性动画的主要组成是 PropertyValuesHolder，而 PropertyValuesHolder 又封装了关键帧；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;动画开始后，其监听了 Choreographer 的 vsync，使得其可以不断地调用 doAnimationFrame() 来驱动动画执行每一个关键帧；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每一次的 doAnimationFrame() 调用都会去计算时间插值，而通过时间插值器计算得到 fraction 又会传给估值器，使得估值器可以计算出属性的当前值；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最后再通过 PropertyValuesHolder 所记录下的 Setter 方法，以反射的方式来修改目标属性的值；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当属性值一帧一帧的改变后，形成连续后，便是我们所见到的动画；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>