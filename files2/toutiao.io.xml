<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f2714a6e862ac70abccad2990f481e92</guid>
<title>成为更好的开发者！行动起来！</title>
<link>https://toutiao.io/k/bcodelm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>76da670a0e6cbc43c400a48d0b2c2a5d</guid>
<title>阿里巴巴开源的低代码引擎</title>
<link>https://toutiao.io/k/gsosp6w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>97d72055849a1c945d703331855d2615</guid>
<title>程序员必知的分布式容错和降级技术</title>
<link>https://toutiao.io/k/wl65hu4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1379310344827587&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XJlI2e4PlFCAo31qnIMbDbZYjZiaoMc13vKFLjK6kut61aP4k8Uxmzic3FzFMtZapG4jlyBmJMg0UOndMMRWaTLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;58&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;em data-mid=&quot;&quot;/&gt;&lt;p data-mid=&quot;&quot;&gt;可以参与抽奖&lt;/p&gt;&lt;em data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/em&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.2&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibl6u6nJ01g9icia42icDbWWvO2ObicnIUHjwQKVp30YzLS8xSInYupoEXAKjYeYDibY50CgKLz6ViaDjTjuRqUqaae0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;参与方式&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.2&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/K8beZoNWDcUm9I6ia4UU97K1XHrQx2PavruEm3xAL2W3Vd7JxrB8PLXtmT5JkwqpC9Dg9hEmtVZkY2hibnlkib0Qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;关注公众号：35岁程序员那些事，后台回复关键词“参与抽奖”，获取抽奖链接，点击抽奖。 中奖之后，可以联系笔者的微信号或者公众号后台回复关键词“联系笔者”，获取联系方式。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式容错和降级是微服务架构中应对瞬时大流量的最佳解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;推荐使用Spring Cloud Alibaba+Sentinel&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Nginx&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Nginx是一块轻量级的Web服务器/反向代理服务器，目前在github上Star 13.3k Fork 4.9k Watch 951，整体关注度也非常高，最近一次更新是2020年12月5日，最新的版本为release-1.19.6。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么如何使用Nginx进行应用的分布式容错和降级呢？答案就是Nginx+Lua可以实现分布式容错和降级，利用Lua脚本可以实现限流算法，并从应用接入层做容错和降级。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Guava&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Guava是一种基于开源的Java库，其中包含谷歌内部使用的很多核心库。这个库是为了方便编码，并减少编码错误。这个库提供了用于集合、缓存、支持原语、并发性、常见注解、字符串处理、I/O等实用方法API，这些都是谷歌开发者结合自身业务场景的最佳实践，可以说是一块非常优秀的开源中间件框架。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Guava - RateLimiter使用的是一种叫令牌桶的流控算法，RateLimiter会按照一定的频率往桶里扔令牌，线程拿到令牌才能执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Guava目前在github上Star 40k Fork 8.9k Watch 2.5k，最近一次更新是2020年12月15日，最新版本为30.1，无论是开源的关注度和活跃度都非常高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Redis&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis是互联网技术领域使用最为广泛的存储中间件，它是“Remote Dictionary Service”（远程字典服务）的首字母缩写。Redis以其超高的性能、完美的文档、简洁易懂的源码和丰富的客户端库支持在开源中间件领域广受&lt;/span&gt;&lt;span&gt;好评。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis采用C语言开发，目前在github上Star 47k Fork 18.5k Watch 2.7k，关注度也非常高，最近一次更新是2021年1月12日，目前最新版本为6.0.10，社区更新活跃度非常高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Redis中，有5种基础数据结构，分别为：string（字符串）、list（列表）、hash（字典）、set（集合）和zset（有序集合），合理的利用这些数据结构是可以达到分布式限流的效果，比如通过zset数据结构中的score值，来构造一个时间窗口，作为限流的滑动窗口，这样就可以快速的构造一个分布式限流算法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Hystrix&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Hystrix是Netflix公司开源的一款容错框架，包含常用的容错方法：线程池隔离、信号量隔离、熔断和降级回退。在高并发访问下，系统所依赖的服务的稳定性对系统的影响非常大，依赖有很多不可控的因素，比如网络连接变慢、资源突然繁忙、暂时不可用、服务宕机等。我们要构建稳定、可靠的分布式系统，就必须要有一套容错的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Hystrix目前在github上Star 20.9k fork 4.3k Watch 1.7k，可以说关注度非常高，但是最近一次版本更新是2018年11月17日，版本为v1.5.18，已经有两年没更新代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;Resilience4j&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Resilience4j 是一个比较轻量的熔断降级库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，Resilience4j 的模块化做的比较好，将每个功能点（如熔断、限速器、自动重试）都拆成了单独的模块，这样整体结构很清晰，用户也只需要引入相应功能的依赖即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，Resilience4jR是针对 Java 8 和函数式编程设计的，API 比较简洁优雅。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时，与 Hystrix 相比，Resilience4j 增加了简单的限速器和自动重试特性，使用场景更加丰富。Resilience4j 属于一个新兴项目，社区也在蓬勃发展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总的来说，Resilience4j 是比较轻量的库，在较小较新的项目中使用还是比较方便的。但是 Resilience4j 只包含限流降级的基本场景，对于非常复杂的企业级服务架构可能无法很好地 cover 住；同时 Resilience4j 缺乏生产级别的配套设施（如提供规则管理和实时监控能力的控制台）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Resilience4j目前在github上Star 6.4k Fork 857 Watch 215，最近一次版本更新是2020年10月19号，最新的release版本是v1.6.1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Sentinel&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Sentinel 一款面向分布式服务架构的轻量级流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统自适应保护等多个维度来帮助用户保障服务的稳定性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Sentinel 的核心思想：根据对应资源配置的规则来为资源执行相应的流控/降级/系统保护策略。在 Sentinel 中资源定义和规则配置是分离的。用户先通过 Sentinel API 给对应的业务逻辑定义资源，然后可以在需要的时候动态配置规则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Sentinel 的优势和特性：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;轻&lt;/span&gt;&lt;span&gt;量级，核心库无多余依赖，性能损耗小；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;方便接入，开源生态广泛。&lt;/span&gt;&lt;span&gt;Sentine&lt;/span&gt;&lt;span&gt;l &lt;/span&gt;&lt;span&gt;对&lt;/span&gt;&lt;span&gt; Dubbo&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Spring Cloud&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Web Servlet&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;gRPC &lt;/span&gt;&lt;span&gt;等常用框架提供适配模块，只需引入相应依赖并简单配置即可快速接入；&lt;/span&gt;&lt;span&gt;同时针对自定义的场景&lt;/span&gt;&lt;span&gt; Sentinel &lt;/span&gt;&lt;span&gt;还提供低侵入性的注解资源定义方式，方便自定义接入；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;丰富的流量控制场景。&lt;/span&gt;&lt;span&gt;Sentinel &lt;/span&gt;&lt;span&gt;承接了阿里巴巴近&lt;/span&gt;&lt;span&gt; 10 &lt;/span&gt;&lt;span&gt;年的双十一大促流量的核心场景，流控维度包括流控指标、流控效果（塑形）、调用关系、热点、集群等各种维度，针对系统维度也提供自适应的保护机制；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;易用的控制台，提供实时监控、机器发现、规则管理等能力；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;完善的扩展性设计，提供多样化的 SPI 接口，方便用户根据需求给 Sentinel 添加自定义的逻辑。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;对比以上几种解决方案&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Nginx和Redis具备一定的分布式容错和降级能力，但是从功能完整性角度肯定是不如Sentinel、Hystrix和Resilience4j，Guava虽然也具备容错和降级能力，但是不具备分布式能力，它是基于单实例JVM的。基于以上原因，这里就对比下Sentinel、Hystrix和Resilience4j。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Sentinel&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Hystrix&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Resilience4j&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;隔离策略&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;信号量隔离（并发线程数限流）&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;线程池隔离/信号量隔离&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;信号量隔离&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;熔断降级策略&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;基于响应时间、异常比率、异常数&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;基于异常比率&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;基于异常比率、响应时间&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;实时指标实现&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;滑动窗口（LeapArray）&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;滑动窗口（基于RxJava）&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Ring Bit Buffer&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;动态规则配置&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持多种数据源&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持多种数据源&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;有限支持&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;扩展性&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;多个扩展点&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;插件形式&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;SDK形式&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;基于注解的支持&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;限流&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;基于QPS限流和基于调用关系限流&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;有限的支持&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;Rate Limiter&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;流量整形&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持预热模式、匀速器模式和预热排队模式&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;不支持&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;简单的Rate Limiter模式&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;系统自适应保护&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;不支持&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;不支持&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;控制台&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;提供开箱即用的控制台，可配置规则、查看秒级监控、机器治理等。&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;简单的监控查看&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;不提供控制台，可对接其它监控系统。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;常见框架适配&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;Servlet、HttpClient、Dubbo、Spring Web等&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;Servlet、Spring Cloud Netflix&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;部分支持&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐使用Spring Cloud Alibaba+Sentinel，可以从服务治理和流量治理，两重维度去治理微服务，高效、简单并且符合主流。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b56bb29d58b53a1f089c088b27afaade</guid>
<title>91.6K 的 Axios 项目有哪些值得借鉴的地方</title>
<link>https://toutiao.io/k/z9a31ne</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Axios 是一个基于 Promise 的 HTTP 客户端，同时支持浏览器和 Node.js 环境。它是一个优秀的 HTTP 客户端，被广泛地应用在大量的 Web 项目中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阅读完本文，你将了解以下内容：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;HTTP 拦截器的设计与实现；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HTTP 适配器的设计与实现；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何防御 CSRF 攻击。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们从简单的开始，先来了解一下 Axios。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;一、Axios 简介&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Axios 是一个基于 Promise 的 HTTP 客户端，拥有以下特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;支持 Promise API；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;能够拦截请求和响应；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;能够转换请求和响应数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端支持防御 CSRF 攻击；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同时支持浏览器和 Node.js 环境；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;能够取消请求及自动转换 JSON 数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在浏览器端 Axios 支持大多数主流的浏览器，比如 Chrome、Firefox、Safari 和 IE 11。此外，Axios 还拥有自己的生态：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22685185185185186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8RrZlXlKCGTZqlmNMEia7MFJvWsJVq6gzaaTOyTKDxGfXIrhNcY8icO33Ww/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（数据来源 —— https://github.com/axios/axios/blob/master/ECOSYSTEM.md）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单介绍完 Axios，我们来分析一下它提供的一个核心功能 —— 拦截器。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;二、HTTP 拦截器的设计与实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;2.1 拦截器简介&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于大多数 SPA 应用程序来说， 通常会使用 token 进行用户的身份认证。这就要求在认证通过后，我们需要在每个请求上都携带认证信息。针对这个需求，为了避免为每个请求单独处理，我们可以通过封装统一的 &lt;code&gt;request&lt;/code&gt; 函数来为每个请求统一添加 token 信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但后期如果需要为某些 GET 请求设置缓存时间或者控制某些请求的调用频率的话，我们就需要不断修改 &lt;code&gt;request&lt;/code&gt; 函数来扩展对应的功能。此时，如果在考虑对响应进行统一处理的话，我们的 &lt;code&gt;request&lt;/code&gt; 函数将变得越来越庞大，也越来越难维护。那么对于这个问题，该如何解决呢？Axios 为我们提供了解决方案 —— 拦截器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Axios 是一个基于 Promise 的 HTTP 客户端，而 HTTP 协议是基于请求和响应：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.298&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8RrV5Em4ECwHynNEKTibfKiceMTGLfoXfpIuIkR67S4NdHX8YE1BQXFJP0w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 Axios 提供了请求拦截器和响应拦截器来分别处理请求和响应，它们的作用如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;请求拦截器：该类拦截器的作用是在请求发送前统一执行某些操作，比如在请求头中添加 token 字段。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;响应拦截器：该类拦截器的作用是在接收到服务器响应后统一执行某些操作，比如发现响应状态码为 401 时，自动跳转到登录页。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Axios 中设置拦截器很简单，通过 &lt;code&gt;axios.interceptors.request&lt;/code&gt; 和 &lt;code&gt;axios.interceptors.response&lt;/code&gt; 对象提供的 &lt;code&gt;use&lt;/code&gt; 方法，就可以分别设置请求拦截器和响应拦截器：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 添加请求拦截器&lt;/span&gt;&lt;br/&gt;axios.interceptors.request.use(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  config.headers.token = &lt;span&gt;&#x27;added by interceptor&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; config;&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 添加响应拦截器&lt;/span&gt;&lt;br/&gt;axios.interceptors.response.use(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;data&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  data.data = data.data + &lt;span&gt;&#x27; - modified by interceptor&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; data;&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么拦截器是如何工作的呢？在看具体的代码之前，我们先来分析一下它的设计思路。Axios 的作用是用于发送 HTTP 请求，而请求拦截器和响应拦截器的本质都是一个实现特定功能的函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以按照功能把发送 HTTP 请求拆解成不同类型的子任务，比如有用于处理请求配置对象的子任务，用于发送 HTTP 请求的子任务和用于处理响应对象的子任务。当我们按照指定的顺序来执行这些子任务时，就可以完成一次完整的 HTTP 请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解完这些，接下来我们将从 &lt;strong&gt;「任务注册、任务编排和任务调度」&lt;/strong&gt; 三个方面来分析 Axios 拦截器的实现。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;2.2 任务注册&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过前面拦截器的使用示例，我们已经知道如何注册请求拦截器和响应拦截器，其中请求拦截器用于处理请求配置对象的子任务，而响应拦截器用于处理响应对象的子任务。要搞清楚任务是如何注册的，就需要了解 &lt;code&gt;axios&lt;/code&gt; 和 &lt;code&gt;axios.interceptors&lt;/code&gt; 对象。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/axios.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createInstance&lt;/span&gt;(&lt;span&gt;defaultConfig&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt; Axios(defaultConfig);&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; instance = bind(Axios.prototype.request, context);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Copy axios.prototype to instance&lt;/span&gt;&lt;br/&gt;  utils.extend(instance, Axios.prototype, context);&lt;br/&gt;  &lt;span&gt;// Copy context to instance&lt;/span&gt;&lt;br/&gt;  utils.extend(instance, context);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; instance;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Create the default instance to be exported&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; axios = createInstance(defaults);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Axios 的源码中，我们找到了 &lt;code&gt;axios&lt;/code&gt; 对象的定义，很明显默认的 &lt;code&gt;axios&lt;/code&gt; 实例是通过 &lt;code&gt;createInstance&lt;/code&gt; 方法创建的，该方法最终返回的是 &lt;code&gt;Axios.prototype.request&lt;/code&gt; 函数对象。同时，我们发现了 &lt;code&gt;Axios&lt;/code&gt; 的构造函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/core/Axios.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Axios&lt;/span&gt;(&lt;span&gt;instanceConfig&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.defaults = instanceConfig;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.interceptors = {&lt;br/&gt;    &lt;span&gt;request&lt;/span&gt;: &lt;span&gt;new&lt;/span&gt; InterceptorManager(),&lt;br/&gt;    &lt;span&gt;response&lt;/span&gt;: &lt;span&gt;new&lt;/span&gt; InterceptorManager()&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在构造函数中，我们找到了 &lt;code&gt;axios.interceptors&lt;/code&gt; 对象的定义，也知道了 &lt;code&gt;interceptors.request&lt;/code&gt; 和 &lt;code&gt;interceptors.response&lt;/code&gt; 对象都是 &lt;code&gt;InterceptorManager&lt;/code&gt; 类的实例。因此接下来，进一步分析 &lt;code&gt;InterceptorManager&lt;/code&gt; 构造函数及相关的 &lt;code&gt;use&lt;/code&gt; 方法就可以知道任务是如何注册的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/core/InterceptorManager.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;InterceptorManager&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.handlers = [];&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;InterceptorManager.prototype.use = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;use&lt;/span&gt;(&lt;span&gt;fulfilled, rejected&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.handlers.push({&lt;br/&gt;    &lt;span&gt;fulfilled&lt;/span&gt;: fulfilled,&lt;br/&gt;    &lt;span&gt;rejected&lt;/span&gt;: rejected&lt;br/&gt;  });&lt;br/&gt;  &lt;span&gt;// 返回当前的索引，用于移除已注册的拦截器&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.handlers.length - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过观察 &lt;code&gt;use&lt;/code&gt; 方法，我们可知注册的拦截器都会被保存到 &lt;code&gt;InterceptorManager&lt;/code&gt; 对象的 &lt;code&gt;handlers&lt;/code&gt; 属性中。下面我们用一张图来总结一下 &lt;code&gt;Axios&lt;/code&gt; 对象与 &lt;code&gt;InterceptorManager&lt;/code&gt; 对象的内部结构与关系：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36944444444444446&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8Rr6X41s2fQrIMwmnvc2eGgtMgTOYPKcq4Ljibt4hPMZKpgPFHfKYSib4Sg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;2.3 任务编排&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们已经知道如何注册拦截器任务，但仅仅注册任务是不够，我们还需要对已注册的任务进行编排，这样才能确保任务的执行顺序。这里我们把完成一次完整的 HTTP 请求分为处理请求配置对象、发起 HTTP 请求和处理响应对象 3 个阶段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们来看一下 Axios 如何发请求的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;axios({&lt;br/&gt;  &lt;span&gt;url&lt;/span&gt;: &lt;span&gt;&#x27;/hello&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;method&lt;/span&gt;: &lt;span&gt;&#x27;get&#x27;&lt;/span&gt;,&lt;br/&gt;}).then(&lt;span&gt;&lt;span&gt;res&lt;/span&gt; =&amp;gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;axios res: &#x27;&lt;/span&gt;, res)&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;axios res.data: &#x27;&lt;/span&gt;, res.data)&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过前面的分析，我们已经知道 &lt;code&gt;axios&lt;/code&gt; 对象对应的是 &lt;code&gt;Axios.prototype.request&lt;/code&gt; 函数对象，该函数的具体实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/core/Axios.js&lt;/span&gt;&lt;br/&gt;Axios.prototype.request = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;request&lt;/span&gt;(&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  config = mergeConfig(&lt;span&gt;this&lt;/span&gt;.defaults, config);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; chain = [dispatchRequest, &lt;span&gt;undefined&lt;/span&gt;];&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; promise = &lt;span&gt;Promise&lt;/span&gt;.resolve(config);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 任务编排&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.interceptors.request.forEach(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;unshiftRequestInterceptors&lt;/span&gt;(&lt;span&gt;interceptor&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    chain.unshift(interceptor.fulfilled, interceptor.rejected);&lt;br/&gt;  });&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.interceptors.response.forEach(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;pushResponseInterceptors&lt;/span&gt;(&lt;span&gt;interceptor&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    chain.push(interceptor.fulfilled, interceptor.rejected);&lt;br/&gt;  });&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 任务调度&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (chain.length) {&lt;br/&gt;    promise = promise.then(chain.shift(), chain.shift());&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; promise;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任务编排的代码比较简单，我们来看一下任务编排前和任务编排后的对比图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5194805194805194&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8Rrbbd0KNQHAppniblnic3LV8tY3HNr34y3cjVNCiaribABHttdsutYh0fYnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1078&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;2.4 任务调度&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任务编排完成后，要发起 HTTP 请求，我们还需要按编排后的顺序执行任务调度。在 Axios 中具体的调度方式很简单，具体如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; &lt;span&gt;// lib/core/Axios.js&lt;/span&gt;&lt;br/&gt;Axios.prototype.request = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;request&lt;/span&gt;(&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; promise = &lt;span&gt;Promise&lt;/span&gt;.resolve(config);&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (chain.length) {&lt;br/&gt;    promise = promise.then(chain.shift(), chain.shift());&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 chain 是数组，所以通过 while 语句我们就可以不断地取出设置的任务，然后组装成 Promise 调用链从而实现任务调度，对应的处理流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4064272211720227&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8RrGEhJn06UYia59qWyW9WahD8KZ6t4ibshrPKcgg5aia1TO8yHibPJDAxveQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1058&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来回顾一下 Axios 拦截器完整的使用流程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 添加请求拦截器 —— 处理请求配置对象&lt;/span&gt;&lt;br/&gt;axios.interceptors.request.use(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  config.headers.token = &lt;span&gt;&#x27;added by interceptor&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; config;&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 添加响应拦截器 —— 处理响应对象&lt;/span&gt;&lt;br/&gt;axios.interceptors.response.use(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;data&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  data.data = data.data + &lt;span&gt;&#x27; - modified by interceptor&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; data;&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;axios({&lt;br/&gt;  &lt;span&gt;url&lt;/span&gt;: &lt;span&gt;&#x27;/hello&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;method&lt;/span&gt;: &lt;span&gt;&#x27;get&#x27;&lt;/span&gt;,&lt;br/&gt;}).then(&lt;span&gt;&lt;span&gt;res&lt;/span&gt; =&amp;gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;axios res.data: &#x27;&lt;/span&gt;, res.data)&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍完 Axios 的拦截器，我们来总结一下它的优点。Axios 通过提供拦截器机制，让开发者可以很容易在请求的生命周期中自定义不同的处理逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，也可以通过拦截器机制来灵活地扩展 Axios 的功能，比如 Axios 生态中列举的 axios-response-logger 和 axios-debug-log 这两个库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考 Axios 拦截器的设计模型，我们就可以抽出以下通用的任务处理模型：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3054945054945055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8Rroqic2FNRDU5ZGvq9jQ47sxYjCnQ658mM93CSTTc8sfjteQNNoAQqaHg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;910&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;三、HTTP 适配器的设计与实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;3.1 默认 HTTP 适配器&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Axios 同时支持浏览器和 Node.js 环境，对于浏览器环境来说，我们可以通过 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 或 &lt;code&gt;fetch&lt;/code&gt; API 来发送 HTTP 请求，而对于 Node.js 环境来说，我们可以通过 Node.js 内置的 &lt;code&gt;http&lt;/code&gt; 或 &lt;code&gt;https&lt;/code&gt; 模块来发送 HTTP 请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了支持不同的环境，Axios 引入了适配器。在 HTTP 拦截器设计部分，我们看到了一个 &lt;code&gt;dispatchRequest&lt;/code&gt; 方法，该方法用于发送 HTTP 请求，它的具体实现如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/core/dispatchRequest.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;dispatchRequest&lt;/span&gt;(&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; adapter = config.adapter || defaults.adapter;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; adapter(config).then(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;onAdapterResolution&lt;/span&gt;(&lt;span&gt;response&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; response;&lt;br/&gt;  }, &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;onAdapterRejection&lt;/span&gt;(&lt;span&gt;reason&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.reject(reason);&lt;br/&gt;  });&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过查看以上的 &lt;code&gt;dispatchRequest&lt;/code&gt; 方法，我们可知 Axios 支持自定义适配器，同时也提供了默认的适配器。对于大多数场景，我们并不需要自定义适配器，而是直接使用默认的适配器。因此，默认的适配器就会包含浏览器和 Node.js 环境的适配代码，其具体的适配逻辑如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/defaults.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; defaults = {&lt;br/&gt;  &lt;span&gt;adapter&lt;/span&gt;: getDefaultAdapter(),&lt;br/&gt;  &lt;span&gt;xsrfCookieName&lt;/span&gt;: &lt;span&gt;&#x27;XSRF-TOKEN&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;xsrfHeaderName&lt;/span&gt;: &lt;span&gt;&#x27;X-XSRF-TOKEN&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getDefaultAdapter&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; adapter;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; XMLHttpRequest !== &lt;span&gt;&#x27;undefined&#x27;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;// For browsers use XHR adapter&lt;/span&gt;&lt;br/&gt;    adapter = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;./adapters/xhr&#x27;&lt;/span&gt;);&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; process !== &lt;span&gt;&#x27;undefined&#x27;&lt;/span&gt; &amp;amp;&amp;amp; &lt;br/&gt;    &lt;span&gt;Object&lt;/span&gt;.prototype.toString.call(process) === &lt;span&gt;&#x27;[object process]&#x27;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;// For node use HTTP adapter&lt;/span&gt;&lt;br/&gt;    adapter = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;./adapters/http&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; adapter;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;getDefaultAdapter&lt;/code&gt; 方法中，首先通过平台中特定的对象来区分不同的平台，然后再导入不同的适配器，具体的代码比较简单，这里就不展开介绍。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;3.2 自定义适配器&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实除了默认的适配器外，我们还可以自定义适配器。那么如何自定义适配器呢？这里我们可以参考 Axios 提供的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; settle = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;./../core/settle&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;myAdapter&lt;/span&gt;(&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 当前时机点：&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//  - config配置对象已经与默认的请求配置合并&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//  - 请求转换器已经运行&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//  - 请求拦截器已经运行&lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;// 使用提供的config配置对象发起请求&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 根据响应对象处理Promise的状态&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; response = {&lt;br/&gt;      &lt;span&gt;data&lt;/span&gt;: responseData,&lt;br/&gt;      &lt;span&gt;status&lt;/span&gt;: request.status,&lt;br/&gt;      &lt;span&gt;statusText&lt;/span&gt;: request.statusText,&lt;br/&gt;      &lt;span&gt;headers&lt;/span&gt;: responseHeaders,&lt;br/&gt;      &lt;span&gt;config&lt;/span&gt;: config,&lt;br/&gt;      &lt;span&gt;request&lt;/span&gt;: request&lt;br/&gt;    };&lt;br/&gt;&lt;br/&gt;    settle(resolve, reject, response);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 此后:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//  - 响应转换器将会运行&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//  - 响应拦截器将会运行&lt;/span&gt;&lt;br/&gt;  });&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上示例中，我们主要关注转换器、拦截器的运行时机点和适配器的基本要求。比如当调用自定义适配器之后，需要返回 Promise 对象。这是因为 Axios 内部是通过 Promise 链式调用来完成请求调度，不清楚的小伙伴可以重新阅读 “拦截器的设计与实现” 部分的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们已经知道如何自定义适配器了，那么自定义适配器有什么用呢？在 Axios 生态中，阿宝哥发现了 axios-mock-adapter 这个库，该库通过自定义适配器，让开发者可以轻松地模拟请求。对应的使用示例如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; axios = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;axios&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; MockAdapter = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;axios-mock-adapter&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 在默认的Axios实例上设置mock适配器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; mock = &lt;span&gt;new&lt;/span&gt; MockAdapter(axios);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 模拟 GET /users 请求&lt;/span&gt;&lt;br/&gt;mock.onGet(&lt;span&gt;&quot;/users&quot;&lt;/span&gt;).reply(&lt;span&gt;200&lt;/span&gt;, {&lt;br/&gt;  &lt;span&gt;users&lt;/span&gt;: [{ &lt;span&gt;id&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&quot;John Smith&quot;&lt;/span&gt; }],&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;axios.get(&lt;span&gt;&quot;/users&quot;&lt;/span&gt;).then(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;response&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(response.data);&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对 MockAdapter 感兴趣的小伙伴，可以自行了解一下 &lt;strong&gt;axios-mock-adapter&lt;/strong&gt; 这个库。到这里我们已经介绍了 Axios 的拦截器与适配器，下面阿宝哥用一张图来总结一下 Axios 使用请求拦截器和响应拦截器后，请求的处理流程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5703703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8Rr1maSvPU0SEtQ3Zfic9MFuiaSRx6n9G7obyic6fLh5MibuQ1TvENWriarQ1w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;四、CSRF 防御&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;4.1 CSRF 简介&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「跨站请求伪造」&lt;/strong&gt;（Cross-site request forgery），通常缩写为 &lt;strong&gt;「CSRF」&lt;/strong&gt; 或者 &lt;strong&gt;「XSRF」&lt;/strong&gt;， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了让小伙伴更好地理解上述的内容，阿宝哥画了一张跨站请求攻击示例图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;277&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8RrPibSnhKic2Jj4nIV2utblUK6JU3dJ1ZSkKTXWsEJJwwG8OyWRoUJJKtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中攻击者利用了 Web 中用户身份验证的一个漏洞：&lt;strong&gt;「简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的」&lt;/strong&gt;。既然存在以上的漏洞，那么我们应该怎么进行防御呢？接下来我们来介绍一些常见的 CSRF 防御措施。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;4.2 CSRF 防御措施&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.1 检查 Referer 字段&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 头中有一个 Referer 字段，这个字段用以标明请求来源于哪个地址。&lt;strong&gt;「在处理敏感数据请求时，通常来说，Referer 字段应和请求的地址位于同一域名下」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以示例中商城操作为例，Referer 字段地址通常应该是商城所在的网页地址，应该也位于 www.semlinker.com 之下。而如果是 CSRF 攻击传来的请求，Referer 字段会是包含恶意网址的地址，不会位于 www.semlinker.com 之下，这时候服务器就能识别出恶意的访问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种办法简单易行，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.2 同步表单 CSRF 校验&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CSRF 攻击之所以能够成功，是因为服务器无法区分正常请求和攻击请求。针对这个问题我们可以要求所有的用户请求都携带一个 CSRF 攻击者无法获取到的 token。对于 CSRF 示例图中的表单攻击，我们可以使用 &lt;strong&gt;「同步表单 CSRF 校验」&lt;/strong&gt; 的防御措施。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「同步表单 CSRF 校验」&lt;/strong&gt; 就是在返回页面时将 token 渲染到页面上，在 form 表单提交的时候通过隐藏域或者作为查询参数把 CSRF token 提交到服务器。比如，在同步渲染页面时，在表单请求中增加一个 &lt;code&gt;_csrf&lt;/code&gt; 的查询参数，这样当用户在提交这个表单的时候就会将 CSRF token 提交上来：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;form&lt;/span&gt; &lt;span&gt;method&lt;/span&gt;=&lt;span&gt;&quot;POST&quot;&lt;/span&gt; &lt;span&gt;action&lt;/span&gt;=&lt;span&gt;&quot;/upload?_csrf={{由服务端生成}}&quot;&lt;/span&gt; &lt;span&gt;enctype&lt;/span&gt;=&lt;span&gt;&quot;multipart/form-data&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  用户名: &lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;name&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;  选择头像: &lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;file&quot;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;file&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;submit&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;提交&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;form&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.3 双重 Cookie 防御&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「双重 Cookie 防御」&lt;/strong&gt; 就是将 token 设置在 Cookie 中，在提交（POST、PUT、PATCH、DELETE）等请求时提交 Cookie，并通过请求头或请求体带上 Cookie 中已设置的 token，服务端接收到请求后，再进行对比校验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们以 jQuery 为例，来看一下如何设置 CSRF token：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; csrfToken = Cookies.get(&lt;span&gt;&#x27;csrfToken&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;csrfSafeMethod&lt;/span&gt;(&lt;span&gt;method&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 以下HTTP方法不需要进行CSRF防护&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;/^(GET|HEAD|OPTIONS|TRACE)$/&lt;/span&gt;.test(method));&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;$.ajaxSetup({&lt;br/&gt;  &lt;span&gt;beforeSend&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;xhr, settings&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!csrfSafeMethod(settings.type) &amp;amp;&amp;amp; !&lt;span&gt;this&lt;/span&gt;.crossDomain) {&lt;br/&gt;      xhr.setRequestHeader(&lt;span&gt;&#x27;x-csrf-token&#x27;&lt;/span&gt;, csrfToken);&lt;br/&gt;    }&lt;br/&gt;  },&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍完 CSRF 攻击的方式和防御手段，最后我们来看一下 Axios 是如何防御 CSRF 攻击的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;4.3 Axios CSRF 防御&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Axios 提供了 &lt;code&gt;xsrfCookieName&lt;/code&gt; 和 &lt;code&gt;xsrfHeaderName&lt;/code&gt; 两个属性来分别设置 CSRF 的 Cookie 名称和 HTTP 请求头的名称，它们的默认值如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/defaults.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; defaults = {&lt;br/&gt;  &lt;span&gt;adapter&lt;/span&gt;: getDefaultAdapter(),&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;xsrfCookieName&lt;/span&gt;: &lt;span&gt;&#x27;XSRF-TOKEN&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;xsrfHeaderName&lt;/span&gt;: &lt;span&gt;&#x27;X-XSRF-TOKEN&#x27;&lt;/span&gt;,&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们已经知道在不同的平台中，Axios 使用不同的适配器来发送 HTTP 请求，这里我们以浏览器平台为例，来看一下 Axios 如何防御 CSRF 攻击：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/adapters/xhr.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;xhrAdapter&lt;/span&gt;(&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;dispatchXhrRequest&lt;/span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; requestHeaders = config.headers;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; request = &lt;span&gt;new&lt;/span&gt; XMLHttpRequest();&lt;br/&gt;    &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 添加xsrf头部&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (utils.isStandardBrowserEnv()) {&lt;br/&gt;      &lt;span&gt;var&lt;/span&gt; xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) &amp;amp;&amp;amp; config.xsrfCookieName ?&lt;br/&gt;        cookies.read(config.xsrfCookieName) :&lt;br/&gt;        &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (xsrfValue) {&lt;br/&gt;        requestHeaders[config.xsrfHeaderName] = xsrfValue;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    request.send(requestData);&lt;br/&gt;  });&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完以上的代码，相信小伙伴们就已经知道答案了，原来 Axios 内部是使用 &lt;strong&gt;「双重 Cookie 防御」&lt;/strong&gt; 的方案来防御 CSRF 攻击。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的，到这里本文的主要内容都已经介绍完了，其实 Axios 项目还有一些值得我们借鉴的地方，比如 CancelToken 的设计、异常处理机制等，感兴趣的小伙伴可以自行学习一下。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;五、参考资源&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Github - axios&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;维基百科 - 跨站请求伪造&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Egg - 安全威胁 CSRF 的防范&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3913677&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.006666666666666667&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot; data-width=&quot;100%&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCu1rRLicXibOB6jq4wpe7W4Ioibu7XTJR1ABzARKoLxyWEWeIV6HJRII2GK1ntnCkVIqjY852gntBd5Q/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;敬请关注「Nodejs技术栈」微信公众号，&lt;span&gt;期望与志同道合的你一起打造优质 “Nodejs技术栈” 交流群，一起互相学习进步！&lt;/span&gt;&lt;span&gt;可长按下方二维码&lt;/span&gt;&lt;span&gt;添加【五月君】个人微信备注 “Node” 邀请入群。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zPkNS9m6iatLmT5coKbicuqENgoc3Pz4QWwtrEoP2RU2thicCJHaKNmJ23Hh9jYvicpVgiauY6NxNaZ59D6svw1Qskg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7e49b5bbad0108e47269be126b7c4e9a</guid>
<title>设计模式二三事</title>
<link>https://toutiao.io/k/xxsl3zv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;奖励的发放策略&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;任务模型的设计&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;活动的迭代重构&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;结语&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;作者简介&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;话说这是在程序员世界里一对师徒的对话：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“老师，我最近在写代码时总感觉自己的代码很不优雅，有什么办法能优化吗？”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“嗯，可以考虑通过教材系统学习，从注释、命名、方法和异常等多方面实现整洁代码。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“然而，我想说的是，我的代码是符合各种编码规范的，但是从实现上却总是感觉不够简洁，而且总是需要反复修改！”学生小明叹气道。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老师看了看小明的代码说：“我明白了，这是系统设计上的缺陷。总结就是抽象不够、可读性低、不够健壮。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“对对对，那怎么能迅速提高代码的可读性、健壮性、扩展性呢？”小明急不可耐地问道。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老师敲了敲小明的头：“不要太浮躁，没有什么方法能让你立刻成为系统设计专家。但是对于你的问题，我想&lt;strong&gt;设计模式&lt;/strong&gt;可以帮到你。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“设计模式？”小明不解。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“是的。”老师点了点头，“世上本没有路，走的人多了，便变成了路。在程序员的世界中，本没有设计模式，写代码是人多了，他们便总结出了一套能提高开发和维护效率的套路，这就是设计模式。设计模式不是什么教条或者范式，它可以说是一种在特定场景下普适且可复用的解决方案，是一种可以用于提高代码可读性、可扩展性、可维护性和可测性的最佳实践。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“哦哦，我懂了，那我应该如何去学习呢？”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“不急，接下来我来带你慢慢了解设计模式。”&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;奖励的发放策略&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;第一天，老师问小明：“你知道活动营销吗？”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“这我知道，活动营销是指企业通过参与社会关注度高的已有活动，或整合有效的资源自主策划大型活动，从而迅速提高企业及其品牌的知名度、美誉度和影响力，常见的比如有抽奖、红包等。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老师点点头：“是的。我们假设现在就要做一个营销，需要用户参与一个活动，然后完成一系列的任务，最后可以得到一些奖励作为回报。活动的奖励包含美团外卖、酒旅和美食等多种品类券，现在需要你帮忙设计一套奖励发放方案。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因为之前有过类似的开发经验，拿到需求的小明二话不说开始了编写起了代码：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// 奖励服务&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RewardService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 外部服务&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; WaimaiService waimaiService;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; HotelService hotelService;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; FoodService foodService;&lt;br/&gt;    &lt;span&gt;// 使用对入参的条件判断进行发奖&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;issueReward&lt;/span&gt;&lt;span&gt;(String rewardType, Object ... params)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;Waimai&quot;&lt;/span&gt;.equals(rewardType)) {&lt;br/&gt;            WaimaiRequest request = &lt;span&gt;new&lt;/span&gt; WaimaiRequest();&lt;br/&gt;            &lt;span&gt;// 构建入参&lt;/span&gt;&lt;br/&gt;            request.setWaimaiReq(params);&lt;br/&gt;            waimaiService.issueWaimai(request);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;Hotel&quot;&lt;/span&gt;.equals(rewardType)) {&lt;br/&gt;            HotelRequest request = &lt;span&gt;new&lt;/span&gt; HotelRequest();&lt;br/&gt;            request.addHotelReq(params);&lt;br/&gt;            hotelService.sendPrize(request);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;Food&quot;&lt;/span&gt;.equals(rewardType)) {&lt;br/&gt;            FoodRequest request = &lt;span&gt;new&lt;/span&gt; FoodRequest(params);&lt;br/&gt;            foodService.getCoupon(request);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;           &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;&quot;rewardType error!&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;小明很快写好了Demo，然后发给老师看。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“假如我们即将接入新的打车券，这是否意味着你必须要修改这部分代码？”老师问道。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;小明愣了一愣，没等反应过来老师又问：”假如后面美团外卖的发券接口发生了改变或者替换，这段逻辑是否必须要同步进行修改？”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;小明陷入了思考之中，一时间没法回答。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;经验丰富的老师一针见血地指出了这段设计的问题：“你这段代码有两个主要问题，一是不符合&lt;strong&gt;开闭原则&lt;/strong&gt;，&lt;span&gt;可以预见，如果后续新增品类券的话，需要直接修改主干代码&lt;/span&gt;，而我们提倡代码应该是对修改封闭的；二是不符合&lt;strong&gt;迪米特法则&lt;/strong&gt;，发奖逻辑和各个下游接口高度耦合，这导致接口的改变将直接影响到代码的组织，使得代码的可维护性降低。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;小明恍然大悟：“那我将各个同下游接口交互的功能抽象成单独的服务，封装其参数组装及异常处理，使得发奖主逻辑与其解耦，是否就能更具备扩展性和可维护性？”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“这是个不错的思路。之前跟你介绍过设计模式，这个案例就可以使用&lt;strong&gt;策略模式&lt;/strong&gt;和&lt;strong&gt;适配器模式&lt;/strong&gt;来优化。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;小明借此机会学习了这两个设计模式。首先是策略模式：&lt;/span&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;策略模式定义了一系列的算法，并将每一个算法封装起来，使它们可以相互替换。策略模式通常包含以下角色：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;环境（Context）类：持有一个策略类的引用，最终给客户端调用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;然后是适配器模式：&lt;/span&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;适配器模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式包含以下主要角色：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;结合优化思路，小明首先设计出了策略接口，并通过适配器的思想将各个下游接口类适配成策略类：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// 策略接口&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Strategy&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;issue&lt;/span&gt;&lt;span&gt;(Object ... params)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 外卖策略&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Waimai&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Strategy&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; WaimaiService waimaiService;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;issue&lt;/span&gt;&lt;span&gt;(Object... params)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        WaimaiRequest request = &lt;span&gt;new&lt;/span&gt; WaimaiRequest();&lt;br/&gt;        &lt;span&gt;// 构建入参&lt;/span&gt;&lt;br/&gt;        request.setWaimaiReq(params);&lt;br/&gt;        waimaiService.issueWaimai(request);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 酒旅策略&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Hotel&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Strategy&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; HotelService hotelService;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;issue&lt;/span&gt;&lt;span&gt;(Object... params)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        HotelRequest request = &lt;span&gt;new&lt;/span&gt; HotelRequest();&lt;br/&gt;        request.addHotelReq(params);&lt;br/&gt;        hotelService.sendPrize(request);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 美食策略&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Food&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Strategy&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; FoodService foodService;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;issue&lt;/span&gt;&lt;span&gt;(Object... params)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        FoodRequest request = &lt;span&gt;new&lt;/span&gt; FoodRequest(params);&lt;br/&gt;        foodService.payCoupon(request);&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;然后，小明创建策略模式的环境类，并供奖励服务调用：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// 使用分支判断获取的策略上下文&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;StrategyContext&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Strategy &lt;span&gt;getStrategy&lt;/span&gt;&lt;span&gt;(String rewardType)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;switch&lt;/span&gt; (rewardType) {&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;Waimai&quot;&lt;/span&gt;:&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Waimai();&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;Hotel&quot;&lt;/span&gt;:&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Hotel();&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;Food&quot;&lt;/span&gt;:&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Food();&lt;br/&gt;            &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;                &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;&quot;rewardType error!&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 优化后的策略服务&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RewardService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;issueReward&lt;/span&gt;&lt;span&gt;(String rewardType, Object ... params)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Strategy strategy = StrategyContext.getStrategy(rewardType);&lt;br/&gt;        strategy.issue(params);&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;小明的代码经过优化后，虽然结构和设计上比之前要复杂不少，但考虑到健壮性和拓展性，还是非常值得的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“看，我这次优化后的版本是不是很完美？”小明洋洋得意地说。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“耦合度确实降低了，但还能做的更好。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“怎么做？”小明有点疑惑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“我问你，策略类是有状态的模型吗？如果不是是否可以考虑做成单例的？”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“的确如此。”小明似乎明白了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“还有一点，环境类的获取策略方法职责很明确，但是你依然没有做到完全对修改封闭。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;经过老师的点拨，小明很快也领悟到了要点：“那我可以将策略类单例化以减少开销，并实现自注册的功能彻底解决分支判断。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;小明列出单例模式的要点：&lt;/span&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;单例模式设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;最终，小明在策略环境类中使用一个注册表来记录各个策略类的注册信息，并提供接口供策略类调用进行注册。同时使用&lt;strong&gt;饿汉式单例模式&lt;/strong&gt;去优化策略类的设计：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// 策略上下文，用于管理策略的注册和获取&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;StrategyContext&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, Strategy&amp;gt; registerMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;// 注册策略&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;registerStrategy&lt;/span&gt;&lt;span&gt;(String rewardType, Strategy strategy)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        registerMap.putIfAbsent(rewardType, strategy);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 获取策略&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Strategy &lt;span&gt;getStrategy&lt;/span&gt;&lt;span&gt;(String rewardType)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; registerMap.get(rewardType);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 抽象策略类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractStrategy&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Strategy&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 类注册方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;register&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        StrategyContext.registerStrategy(getClass().getSimpleName(), &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 单例外卖策略&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Waimai&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractStrategy&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Strategy&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Waimai instance = &lt;span&gt;new&lt;/span&gt; Waimai();&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; WaimaiService waimaiService;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;Waimai&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        register();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Waimai &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; instance;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;issue&lt;/span&gt;&lt;span&gt;(Object... params)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        WaimaiRequest request = &lt;span&gt;new&lt;/span&gt; WaimaiRequest();&lt;br/&gt;        &lt;span&gt;// 构建入参&lt;/span&gt;&lt;br/&gt;        request.setWaimaiReq(params);&lt;br/&gt;        waimaiService.issueWaimai(request);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 单例酒旅策略&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Hotel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractStrategy&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Strategy&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Hotel instance = &lt;span&gt;new&lt;/span&gt; Hotel();&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; HotelService hotelService;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;Hotel&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        register();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Hotel &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; instance;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;issue&lt;/span&gt;&lt;span&gt;(Object... params)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        HotelRequest request = &lt;span&gt;new&lt;/span&gt; HotelRequest();&lt;br/&gt;        request.addHotelReq(params);&lt;br/&gt;        hotelService.sendPrize(request);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 单例美食策略&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Food&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractStrategy&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Strategy&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Food instance = &lt;span&gt;new&lt;/span&gt; Food();&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; FoodService foodService;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;Food&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        register();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Food &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; instance;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;issue&lt;/span&gt;&lt;span&gt;(Object... params)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        FoodRequest request = &lt;span&gt;new&lt;/span&gt; FoodRequest(params);&lt;br/&gt;        foodService.payCoupon(request);&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;最终，小明设计完成的结构类图如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;1&quot; data-cropselx2=&quot;542&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;369&quot; data-ratio=&quot;0.6820744081172492&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVm2AEU6AQbUAyCqHgKROft5pgQOhtR90ia1fng0MAd8CLhTOWZA1J7SvIAZPTp5azBtREeQJwwrfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;887&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;奖励发放策略_类图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果使用了Spring框架，还可以利用Spring的Bean机制来代替上述的部分设计，直接使用&lt;/span&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;&lt;span&gt;@PostConstruct&lt;/span&gt;&lt;/code&gt;&lt;span&gt;注解即可完成单例的创建和注册，代码会更加简洁。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;至此，经过了多次讨论、反思和优化，小明终于得到了一套低耦合高内聚，同时符合开闭原则的设计。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“老师，我开始学会利用设计模式去解决已发现的问题。这次我做得怎么样？”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“合格。但是，依然要戒骄戒躁。”&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;任务模型的设计&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;“之前让你设计奖励发放策略你还记得吗？”老师忽然问道。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“当然记得。一个好的设计模式，能让工作事半功倍。”小明答道。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“嗯，那会提到了活动营销的组成部分，除了奖励之外，貌似还有任务吧。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;小明点了点头，老师接着说：“现在，我想让你去完成任务模型的设计。你需要重点关注状态的流转变更，以及状态变更后的消息通知。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;小明欣然接下了老师给的难题。他首先定义了一套任务状态的枚举和行为的枚举：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// 任务状态枚举&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@AllArgsConstructor&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Getter&lt;/span&gt;&lt;br/&gt;&lt;span&gt;enum&lt;/span&gt; TaskState {&lt;br/&gt;    INIT(&lt;span&gt;&quot;初始化&quot;&lt;/span&gt;),&lt;br/&gt;    ONGOING( &lt;span&gt;&quot;进行中&quot;&lt;/span&gt;),&lt;br/&gt;    PAUSED(&lt;span&gt;&quot;暂停中&quot;&lt;/span&gt;),&lt;br/&gt;    FINISHED(&lt;span&gt;&quot;已完成&quot;&lt;/span&gt;),&lt;br/&gt;    EXPIRED(&lt;span&gt;&quot;已过期&quot;&lt;/span&gt;)&lt;br/&gt;    ;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String message;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 行为枚举&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@AllArgsConstructor&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Getter&lt;/span&gt;&lt;br/&gt;&lt;span&gt;enum&lt;/span&gt; ActionType {&lt;br/&gt;    START(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;开始&quot;&lt;/span&gt;),&lt;br/&gt;    STOP(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;暂停&quot;&lt;/span&gt;),&lt;br/&gt;    ACHIEVE(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;&quot;完成&quot;&lt;/span&gt;),&lt;br/&gt;    EXPIRE(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;&quot;过期&quot;&lt;/span&gt;)&lt;br/&gt;    ;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; code;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String message;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;然后，小明对开始编写状态变更功能：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Task&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Long taskId;&lt;br/&gt;    &lt;span&gt;// 任务的默认状态为初始化&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TaskState state = TaskState.INIT;&lt;br/&gt;    &lt;span&gt;// 活动服务&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ActivityService activityService;&lt;br/&gt;    &lt;span&gt;// 任务管理器&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TaskManager taskManager;&lt;br/&gt;    &lt;span&gt;// 使用条件分支进行任务更新&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;updateState&lt;/span&gt;&lt;span&gt;(ActionType actionType)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (state == TaskState.INIT) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (actionType == ActionType.START) {&lt;br/&gt;                state = TaskState.ONGOING;&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (state == TaskState.ONGOING) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (actionType == ActionType.ACHIEVE) {&lt;br/&gt;                state = TaskState.FINISHED;&lt;br/&gt;                &lt;span&gt;// 任务完成后进对外部服务进行通知&lt;/span&gt;&lt;br/&gt;                activityService.notifyFinished(taskId);&lt;br/&gt;                taskManager.release(taskId);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (actionType == ActionType.STOP) {&lt;br/&gt;                state = TaskState.PAUSED;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (actionType == ActionType.EXPIRE) {&lt;br/&gt;                state = TaskState.EXPIRED;&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (state == TaskState.PAUSED) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (actionType == ActionType.START) {&lt;br/&gt;                state = TaskState.ONGOING;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (actionType == ActionType.EXPIRE) {&lt;br/&gt;                state = TaskState.EXPIRED;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;在上述的实现中，小明在&lt;/span&gt;&lt;code&gt;&lt;span&gt;updateState&lt;/span&gt;&lt;/code&gt;&lt;span&gt;方法中完成了2个重要的功能：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;接收不同的行为，然后更新当前任务的状态；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当任务过期时，通知任务所属的活动和任务管理器。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;诚然，随着小明的系统开发能力和代码质量意识的提升，他能够认识到这种功能设计存在缺陷。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“老师，我的代码还是和之前说的那样，不够优雅。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“哦，你自己说说看有什么问题？”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“第一，方法中使用条件判断来控制语句，但是当条件复杂或者状态太多时，条件判断语句会过于臃肿，可读性差，且不具备扩展性，维护难度也大。且增加新的状态时要添加新的if-else语句，这违背了开闭原则，不利于程序的扩展。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老师表示同意，小明接着说：“第二，任务类不够高内聚，它在通知实现中感知了其他领域或模块的模型，如活动和任务管理器，这样代码的耦合度太高，不利于扩展。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老师赞赏地说道：“很好，你有意识能够自主发现代码问题所在，已经是很大的进步了。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“那这个问题应该怎么去解决呢？”小明继续发问。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“这个同样可以通过设计模式去优化。首先是状态流转的控制可以使用&lt;strong&gt;状态模式&lt;/strong&gt;，其次，任务完成时的通知可以用到&lt;strong&gt;观察者模式&lt;/strong&gt;。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;收到指示后，小明马上去学习了状态模式的结构：&lt;/span&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;状态模式：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。状态模式包含以下主要角色：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;根据状态模式的定义，小明将TaskState枚举类扩展成多个状态类，并具备完成状态的流转的能力；然后优化了任务类的实现：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// 任务状态抽象接口&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;State&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 默认实现，不做任何处理&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;&lt;span&gt;(Task task, ActionType actionType)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// do nothing&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 任务初始状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TaskInit&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;State&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;&lt;span&gt;(Task task, ActionType actionType)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;  (actionType == ActionType.START) {&lt;br/&gt;            task.setState(&lt;span&gt;new&lt;/span&gt; TaskOngoing());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 任务进行状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TaskOngoing&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;State&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ActivityService activityService;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TaskManager taskManager; &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;&lt;span&gt;(Task task, ActionType actionType)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (actionType == ActionType.ACHIEVE) {&lt;br/&gt;            task.setState(&lt;span&gt;new&lt;/span&gt; TaskFinished());&lt;br/&gt;            &lt;span&gt;// 通知&lt;/span&gt;&lt;br/&gt;            activityService.notifyFinished(taskId);&lt;br/&gt;            taskManager.release(taskId);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (actionType == ActionType.STOP) {&lt;br/&gt;            task.setState(&lt;span&gt;new&lt;/span&gt; TaskPaused());&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (actionType == ActionType.EXPIRE) {&lt;br/&gt;            task.setState(&lt;span&gt;new&lt;/span&gt; TaskExpired());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 任务暂停状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TaskPaused&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;State&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;&lt;span&gt;(Task task, ActionType actionType)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (actionType == ActionType.START) {&lt;br/&gt;            task.setState(&lt;span&gt;new&lt;/span&gt; TaskOngoing());&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (actionType == ActionType.EXPIRE) {&lt;br/&gt;            task.setState(&lt;span&gt;new&lt;/span&gt; TaskExpired());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 任务完成状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TaskFinished&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;State&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 任务过期状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TaskExpired&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;State&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Task&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Long taskId;&lt;br/&gt;    &lt;span&gt;// 初始化为初始态&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; State state = &lt;span&gt;new&lt;/span&gt; TaskInit();&lt;br/&gt;    &lt;span&gt;// 更新状态&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;updateState&lt;/span&gt;&lt;span&gt;(ActionType actionType)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        state.update(&lt;span&gt;this&lt;/span&gt;, actionType);&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;小明欣喜地看到，经过状态模式处理后的任务类的耦合度得到降低，符合开闭原则。状态模式的优点在于符合单一职责原则，状态类职责明确，有利于程序的扩展。但是这样设计的代价是状态类的数目增加了，因此状态流转逻辑越复杂、需要处理的动作越多，越有利于状态模式的应用。除此之外，状态类的自身对于开闭原则的支持并没有足够好，如果状态流转逻辑变化频繁，那么可能要慎重使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;处理完状态后，小明又根据老师的指导使用&lt;strong&gt;观察者模式&lt;/strong&gt;去优化任务完成时的通知：&lt;/span&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;观察者模式：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。观察者模式的主要角色如下。&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;具体主题（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;小明首先设计好抽象目标和抽象观察者，然后将活动和任务管理器的接收通知功能定制成具体观察者：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// 抽象观察者&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Observer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;response&lt;/span&gt;&lt;span&gt;(Long taskId)&lt;/span&gt;&lt;/span&gt;; &lt;span&gt;// 反应&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 抽象目标&lt;/span&gt;&lt;br/&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Subject&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; List&amp;lt;Observer&amp;gt; observers = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Observer&amp;gt;();&lt;br/&gt;    &lt;span&gt;// 增加观察者方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(Observer observer)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        observers.add(observer);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 删除观察者方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(Observer observer)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        observers.remove(observer);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 通知观察者方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;notifyObserver&lt;/span&gt;&lt;span&gt;(Long taskId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (Observer observer : observers) {&lt;br/&gt;            observer.response(taskId);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 活动观察者&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ActivityObserver&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Observer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ActivityService activityService;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;response&lt;/span&gt;&lt;span&gt;(Long taskId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        activityService.notifyFinished(taskId);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 任务管理观察者&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TaskManageObserver&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Observer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TaskManager taskManager;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;response&lt;/span&gt;&lt;span&gt;(Long taskId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        taskManager.release(taskId);&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;最后，小明将任务进行状态类优化成使用通用的通知方法，并在任务初始态执行状态流转时定义任务进行态所需的观察者：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// 任务进行状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TaskOngoing&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Subject&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;State&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;&lt;span&gt;(Task task, ActionType actionType)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (actionType == ActionType.ACHIEVE) {&lt;br/&gt;            task.setState(&lt;span&gt;new&lt;/span&gt; TaskFinished());&lt;br/&gt;            &lt;span&gt;// 通知&lt;/span&gt;&lt;br/&gt;            notifyObserver(task.getTaskId());&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (actionType == ActionType.STOP) {&lt;br/&gt;            task.setState(&lt;span&gt;new&lt;/span&gt; TaskPaused());&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (actionType == ActionType.EXPIRE) {&lt;br/&gt;            task.setState(&lt;span&gt;new&lt;/span&gt; TaskExpired());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 任务初始状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TaskInit&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;State&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;&lt;span&gt;(Task task, ActionType actionType)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;  (actionType == ActionType.START) {&lt;br/&gt;            TaskOngoing taskOngoing = &lt;span&gt;new&lt;/span&gt; TaskOngoing();&lt;br/&gt;            taskOngoing.add(&lt;span&gt;new&lt;/span&gt; ActivityObserver());&lt;br/&gt;            taskOngoing.add(&lt;span&gt;new&lt;/span&gt; TaskManageObserver());&lt;br/&gt;            task.setState(taskOngoing);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;最终，小明设计完成的结构类图如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;1&quot; data-cropselx2=&quot;542&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;218&quot; data-ratio=&quot;0.4028776978417266&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVm2AEU6AQbUAyCqHgKROft0Kw1MaCKWtIGT9nOia4JrfAicRdbLwXicjjnia8IA7YfY8PR2iabI1nbgAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1251&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;任务模型设计_类图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过观察者模式，小明让任务状态和通知方实现松耦合（&lt;/span&gt;&lt;span&gt;实际上观察者模式还没能做到完全的解耦，如果要做进一步的解耦可以考虑学习并使用&lt;strong&gt;发布-订阅模式&lt;/strong&gt;，这里也不再赘述&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;至此，小明成功使用状态模式设计出了高内聚、高扩展性、单一职责的任务的整个状态机实现，以及做到松耦合的、符合依赖倒置原则的任务状态变更通知方式。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“老师，我逐渐能意识到代码的设计缺陷，并学会利用较为复杂的设计模式做优化。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“不错，再接再厉！”&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;活动的迭代重构&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;“小明，这次又有一个新的任务。”老师出现在正在认真阅读《设计模式》的小明的面前。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“好的。刚好我已经学习了设计模式的原理，终于可以派上用场了。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“之前你设计开发了活动模型，现在我们需要在任务型活动的参与方法上增加一层风险控制。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“OK。借此机会，我也想重构一下之前的设计。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;活动模型的特点在于其组成部分较多，小明原先的活动模型的构建方式是这样的：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// 抽象活动接口&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ActivityInterface&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;participate&lt;/span&gt;&lt;span&gt;(Long userId)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 活动类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Activity&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ActivityInterface&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String type;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Long id;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer scene;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String material;&lt;br/&gt;      &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Activity&lt;/span&gt;&lt;span&gt;(String type)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.type = type;&lt;br/&gt;        &lt;span&gt;// id的构建部分依赖于活动的type&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;period&quot;&lt;/span&gt;.equals(type)) {&lt;br/&gt;            id = &lt;span&gt;0L&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Activity&lt;/span&gt;&lt;span&gt;(String type, Long id)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.type = type;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.id = id;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Activity&lt;/span&gt;&lt;span&gt;(String type, Long id, Integer scene)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.type = type;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.id = id;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.scene = scene;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Activity&lt;/span&gt;&lt;span&gt;(String type, String name, Integer scene, String material)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.type = type;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.scene = scene;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.material = material;&lt;br/&gt;        &lt;span&gt;// name的构建完全依赖于活动的type&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;period&quot;&lt;/span&gt;.equals(type)) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.id = &lt;span&gt;0L&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.name = &lt;span&gt;&quot;period&quot;&lt;/span&gt; + name;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.name = &lt;span&gt;&quot;normal&quot;&lt;/span&gt; + name;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 参与活动&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;participate&lt;/span&gt;&lt;span&gt;(Long userId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// do nothing&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 任务型活动&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TaskActivity&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Activity&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Task task;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;TaskActivity&lt;/span&gt;&lt;span&gt;(String type, String name, Integer scene, String material, Task task)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(type, name, scene, material);&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.task = task;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 参与任务型活动&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;participate&lt;/span&gt;&lt;span&gt;(Long userId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 更新任务状态为进行中&lt;/span&gt;&lt;br/&gt;        task.getState().update(task, ActionType.START);&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;经过自主分析，小明发现活动的构造不够合理，主要问题表现在：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;活动的构造组件较多，导致可以组合的构造函数太多，尤其是在模型增加字段时还需要去修改构造函数；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;部分组件的构造存在一定的顺序关系，但是当前的实现没有体现顺序，导致构造逻辑比较混乱，并且存在部分重复的代码。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;发现问题后，小明回忆自己的学习成果，马上想到可以使用创建型模式中的&lt;strong&gt;建造者模式&lt;/strong&gt;去做重构：&lt;/span&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;建造者模式：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。建造者模式的主要角色如下:&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;根据建造者模式的定义，上述活动的每个字段都是一个产品。于是，小明可以通过在活动里面实现静态的建造者类来简易地实现：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// 活动类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Activity&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ActivityInterface&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; String type;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; Long id;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; String name;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; Integer scene;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; String material;&lt;br/&gt;    &lt;span&gt;// 全参构造函数&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Activity&lt;/span&gt;&lt;span&gt;(String type, Long id, String name, Integer scene, String material)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.type = type;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.id = id;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.scene = scene;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.material = material;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;participate&lt;/span&gt;&lt;span&gt;(Long userId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// do nothing&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 静态建造器类，使用奇异递归模板模式允许继承并返回继承建造器类&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Builder&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Builder&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; String type;&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; Long id;&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; String name;&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; Integer scene;&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; String material;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;setType&lt;/span&gt;&lt;span&gt;(String type)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.type = type;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; (T) &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;setId&lt;/span&gt;&lt;span&gt;(Long id)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.id = id;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; (T) &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;setId&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;period&quot;&lt;/span&gt;.equals(&lt;span&gt;this&lt;/span&gt;.type)) {&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.id = &lt;span&gt;0L&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; (T) &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;setScene&lt;/span&gt;&lt;span&gt;(Integer scene)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.scene = scene;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; (T) &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;setMaterial&lt;/span&gt;&lt;span&gt;(String material)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.material = material;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; (T) &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;setName&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;period&quot;&lt;/span&gt;.equals(&lt;span&gt;this&lt;/span&gt;.type)) {&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.name = &lt;span&gt;&quot;period&quot;&lt;/span&gt; + name;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.name = &lt;span&gt;&quot;normal&quot;&lt;/span&gt; + name;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; (T) &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Activity &lt;span&gt;build&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Activity(type, id, name, scene, material);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 任务型活动&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TaskActivity&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Activity&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; Task task;&lt;br/&gt;   &lt;span&gt;// 全参构造函数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;TaskActivity&lt;/span&gt;&lt;span&gt;(String type, Long id, String name, Integer scene, String material, Task task)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(type, id, name, scene, material);&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.task = task;&lt;br/&gt;    }&lt;br/&gt;   &lt;span&gt;// 参与任务型活动&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;participate&lt;/span&gt;&lt;span&gt;(Long userId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 更新任务状态为进行中&lt;/span&gt;&lt;br/&gt;        task.getState().update(task, ActionType.START);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 继承建造器类&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Builder&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Activity&lt;/span&gt;.&lt;span&gt;Builder&lt;/span&gt;&amp;lt;&lt;span&gt;Builder&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; Task task;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Builder &lt;span&gt;setTask&lt;/span&gt;&lt;span&gt;(Task task)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.task = task;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; TaskActivity &lt;span&gt;build&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TaskActivity(type, id, name, scene, material, task);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;小明发现，上面的建造器没有使用诸如抽象建造器类等完整的实现，但是基本是完成了活动各个组件的建造流程。使用建造器的模式下，可以先按顺序构建字段type，然后依次构建其他组件，最后使用build方法获取建造完成的活动。这种设计一方面封装性好，构建和表示分离；另一方面扩展性好，各个具体的建造者相互独立，有利于系统的解耦。可以说是一次比较有价值的重构。在实际的应用中，如果字段类型多，同时各个字段只需要简单的赋值，可以直接引用Lombok的@Builder注解来实现轻量的建造者。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;重构完活动构建的设计后，小明开始对参加活动方法增加风控。最简单的方式肯定是直接修改目标方法：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;participate&lt;/span&gt;&lt;span&gt;(Long userId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 对目标用户做风险控制，失败则抛出异常&lt;/span&gt;&lt;br/&gt;    Risk.doControl(userId);&lt;br/&gt;    &lt;span&gt;// 更新任务状态为进行中&lt;/span&gt;&lt;br/&gt;    task.state.update(task, ActionType.START);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;但是考虑到，最好能尽可能避免对旧方法的直接修改，同时为方法增加风控，也是一类比较常见的功能新增，可能会在多处使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“老师，风险控制会出现在多种活动的参与方法中吗？”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“有这个可能性。有的活动需要风险控制，有的不需要。风控像是在适当的时候对参与这个方法的装饰。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“对了，装饰器模式！”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;小明马上想到用&lt;strong&gt;装饰器模式&lt;/strong&gt;来完成设计：&lt;/span&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;装饰器模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。装饰器模式主要包含以下角色：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;小明使用了装饰器模式后，新的代码就变成了这样：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// 抽象装饰角色&lt;/span&gt;&lt;br/&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ActivityDecorator&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ActivityInterface&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; ActivityInterface activity;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ActivityDecorator&lt;/span&gt;&lt;span&gt;(ActivityInterface activity)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.activity = activity;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;participate&lt;/span&gt;&lt;span&gt;(Long userId)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 能够对活动做风险控制的包装类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RiskControlDecorator&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ActivityDecorator&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;RiskControlDecorator&lt;/span&gt;&lt;span&gt;(ActivityInterface activity)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(activity);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;participate&lt;/span&gt;&lt;span&gt;(Long userId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 对目标用户做风险控制，失败则抛出异常&lt;/span&gt;&lt;br/&gt;       Risk.doControl(userId);&lt;br/&gt;        &lt;span&gt;// 更新任务状态为进行中&lt;/span&gt;&lt;br/&gt;        activity.participate(userId);&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;最终，小明设计完成的结构类图如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;541&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;301&quot; data-ratio=&quot;0.5573440643863179&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVm2AEU6AQbUAyCqHgKROftuibJkJibU5BHr7pHeKicDI6ekm7TWN8eFrGDVpSFD8LLpzCHuibUzqn0UA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;994&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;活动迭代重构_类图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最终，小明通过自己的思考分析，结合学习的设计模式知识，完成了活动模型的重构和迭代。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“老师，我已经能做到自主分析功能特点，并合理应用设计模式去完成程序设计和代码重构了，实在太感谢您了。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“设计模式作为一种软件设计的最佳实践，你已经很好地理解并应用于实践了，非常不错。但学海无涯，还需持续精进！”&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;结语&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;本文以三个实际场景为出发点，借助小明和老师两个虚拟的人物，试图以一种较为诙谐的“对话”方式来讲述设计模式的应用场景、优点和缺点。如果大家想要去系统性地了解设计模式，也可以通过市面上很多的教材进行学习，都介绍了经典的23种设计模式的结构和实现。不过，很多教材的内容即便配合了大量的示例，但有时也会让人感到费解，主要原因在于：一方面，很多案例比较脱离实际的应用场景；另一方面，部分设计模式显然更适用于大型复杂的结构设计，而当其应用到简单的场景时，仿佛让代码变得更加繁琐、冗余。因此，本文希望通过这种“对话+代码展示+结构类图”的方式，以一种更易懂的方式来介绍设计模式。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当然，本文只讲述了部分比较常见的设计模式，还有其他的设计模式，仍然需要同学们去研读经典著作，举一反三，学以致用。我们也希望通过学习设计模式能让更多的同学在系统设计能力上得到提升。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;作者简介&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;嘉凯、杨柳，来自美团金融服务平台/联名卡研发团队。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;----------  END  ----------&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;招聘信息&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section data-source=&quot;bj.96weixin.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;联名卡技术团队隶属美团金服平台的联名卡事业部，我们的使命是联合银行为用户提供申卡、激活、用卡等服务。我们的目标是在线上及线下场景，为美团用户和商家提供高效、稳定的信用卡产品。欢迎加入我们，一起打造领先的消费金融科技平台。联名卡技术团队长期招聘架构师/技术专家/高级Java工程师，感兴趣的同学可以将简历发送至：&lt;/span&gt;&lt;span&gt;yangliu26@meituan.com&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;邮件主题：联名卡技术团队&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;也许你还想看&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  | &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651751455&amp;amp;idx=1&amp;amp;sn=b67a0fe617f1f1d3a6ee2217f7b4e853&amp;amp;chksm=bd125d528a65d44424b60a3c9890fe36773da7b2b4c1df9cea33c61936133718571d78e44207&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;设计模式在外卖营销业务中的实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651751455&amp;amp;idx=1&amp;amp;sn=b67a0fe617f1f1d3a6ee2217f7b4e853&amp;amp;chksm=bd125d528a65d44424b60a3c9890fe36773da7b2b4c1df9cea33c61936133718571d78e44207&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;设计模式在外卖营销业务中的实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;设计模式在外卖营销业务中的实践&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt;&lt;/span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651749520&amp;amp;idx=4&amp;amp;sn=8012a788e32ff820278a4df8a2e66a7c&amp;amp;chksm=bd12a5dd8a652ccb05a296860c943c23527988b59111e6fe29eed2e0516706df3622dcd7935c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;美团即时物流的分布式系统架构设计&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;美团即时物流的分布式系统架构设计&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651748475&amp;amp;idx=2&amp;amp;sn=ae2a8a8a48460a262fd83b873aea9117&amp;amp;chksm=bd12a1368a6528202fd6540cfb6209d9afa3bd4eb3e51522c978536d708b6543ccc1f67af98a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;美团配送系统架构演进实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;美团配送系统架构演进实践&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;阅读更多&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;---&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765958&amp;amp;idx=1&amp;amp;sn=8201546812e5a95a2bee9dffc6d12f00&amp;amp;chksm=bd12658b8a65ec9de2f5be1e96796dfb3c8f1a374d4b7bd91266072f557caf8118d4ddb72b07&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;前‍端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;前端&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7v&quot; textvalue=&quot; 安全&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt; &lt;/strong&gt; &lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765981&amp;amp;idx=1&amp;amp;sn=c2dd86f15dee2cbbc89e27677d985060&amp;amp;chksm=bd1265908a65ec86d4d08f7600d1518b61c90f6453074f9b308c96861c045712280a73751c73&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;算‍法&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;算法&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765982&amp;amp;idx=1&amp;amp;sn=231b41f653ac7959f3e3b8213dcec2b0&amp;amp;chksm=bd1265938a65ec85630c546169444d56377bc2f11401d251da7ca50e5d07e353aa01580c7216&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;后‍端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;后端&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765964&amp;amp;idx=1&amp;amp;sn=ab6d8db147234fe57f27dd46eec40fef&amp;amp;chksm=bd1265818a65ec9749246dd1a2eb3bf7798772cc4d5b4283b15eae2f80bc6db63a1471a9e61e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;数‍据&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;数据&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765965&amp;amp;idx=1&amp;amp;sn=37e0c56c8b080146ce5249243bfd84d8&amp;amp;chksm=bd1265808a65ec96d3a2b2c87c6e27c910d49cb6b149970fb2db8bf88045a0a85fed2e6a0b84&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;安‍全&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;安全&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765972&amp;amp;idx=1&amp;amp;sn=afe02ec92762c1ce18740d03324c4ac3&amp;amp;chksm=bd1265998a65ec8f10d5f58d0f3681ddfc5325137218e568e1cda3a50e427749edb5c6a7dcf5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;And‍roid&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;Android&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765973&amp;amp;idx=1&amp;amp;sn=32a23bf1d278dda0398f993ab60a697e&amp;amp;chksm=bd1265988a65ec8e630ef4d24b4946ab6bd7e66702c1d712481cf3c471468a059c470a14c30d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;iO‍S&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;iOS&lt;/a&gt;&lt;span&gt; &lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765963&amp;amp;idx=1&amp;amp;sn=a3de9ef267d07d94118c1611776a4b28&amp;amp;chksm=bd1265868a65ec906592d25ad65f2a8516338d07ec3217059e6975fc131fc0107d66a8cd2612&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;运‍维&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;运维&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765974&amp;amp;idx=1&amp;amp;sn=763c1e37d04acffd0142a2852ecfb000&amp;amp;chksm=bd12659b8a65ec8dfcfeb2028ef287fae7c38f134a665375ba420556ce5d2e4cf398147bd12e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;测‍试&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;测试&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>