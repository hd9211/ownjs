<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>a653996147d109e2bf83be1b5d991785</guid>
<title>网络编程怎么做才算是优雅？</title>
<link>https://toutiao.io/k/zylzzpi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;174&quot; data-backw=&quot;365&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4767123287671233&quot; data-type=&quot;gif&quot; data-w=&quot;365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cvQbJDZsKLp6wejHtKTRbqqQyt0wMk9K1wNtuwRqQTJAPOJ1KiaqSeSRbIJRTicVicKpDKRndBodY2DBNN20tvWwA/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原创：小姐姐味道（微信公众号ID：xjjdog），欢迎分享，转载请保留出处。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;据说，web2.0的魅力在于由静态资源变成交互性资源，web3.0的魅力在于其去中心化的资源，大家都可以参与其中得享时代的福利。但是，无论上层概念玩的再花哨，最下层的通信还是基于web1.0所形成的技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的终极目标，其实就是打着去中心化的名义，做实际上的中心化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当流量增加到一定程度，网络编程会发生各种怪异的场景。下面将以十几个实际的案例，来说明xjjdog平常在工作中遇到的与网络相关的高频问题，希望能够助你一臂之力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 大量客户端上线注意躲避&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论你的服务器能力多强，在大批量连接到来，进行业务服务的时候，都会产生瞬时的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，如果你的MQTT服务器连接了几十万台设备。当你的MQTT服务器宕机重启的时候，就要接受几十万的并发，这几乎没有任何服务能够受得了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在xjjdog以往的经验中，因为服务端重启问题而造成的阻塞事故，数不胜数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个场景，其实和缓存的击穿概念非常的相似。当缓存中的热点数据集中失效的时候，请求就会全部击穿到数据库层面，造成问题。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4798807749627422&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1342&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLr2VuKPZxnONlCFrhAIg0Agc6t3LlnbibUrKk6UCDUnCzAfqntNh0mz60QcMVpNHaDPMFfyDp0aj5A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图，解决缓存击穿问题就是给每个key加个失效时间的随机值，让它们不要在同一时间失效。类似的，我们可以在客户端重连服务端的时候，加上一个随机的时间。随机数是个好东西，它能让我们的海量连接在随机时间窗口内保持类线性的增长。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 多网卡队列&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在类似openstack等虚拟平台上假设的虚拟机，往往因为网卡能力不强而造成流量在达到一定程度之后，服务发生卡顿。这是因为单个cpu在处理中断时，产生了瓶颈。通过dstat或者iftop命令，可以看到当前的网络流量。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4381551362683438&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;954&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLraeg3qV1NqYqicNYpXMukH2HSibZc6bRbZyvIKzHKsczuuwpRuviamELTCT78oUQaUkmZzLnvPXricYQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，Kafka新机器上线之后，会进行大规模的数据拷贝，这个时候如果你去ping相关的机器，会发现ping值变的非常大。同时，&lt;code&gt;Recv-Q&lt;/code&gt;和&lt;code&gt;Send-Q&lt;/code&gt;的值也会增大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候，就需要开启网卡多队列模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;ethtool&lt;/code&gt;可以看到网卡的队列信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ethtool -l eth0 | grep &lt;span&gt;&#x27;Combined&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;Combined: 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，通过下面的命令，可以增加网卡的队列。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ethtool -L eth0 combined 2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议同时开启中断平衡服务。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;systemctl start irqbalance&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 不定时的切断一下长连接&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果客户端和服务端连接上了，并一直保持连接不关闭对方，那么它就是一条长连接。长连接可以避免频繁的连接创建所产生的开销。从HTTP1到HTTP2再到HTTP3，一直在向减少连接，复用连接方面去努力。通常情况下，长连接是第一选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有一些特殊情况，我们希望长连接并不要一直在那里保持着，需要给它增加TTL。这种情况通常发生在负载均衡场景里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如LVS、HAProxy等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果后端有A、B、C三台机器，经过LVS负载之后，90条连接被分散到三台机器。但某个时刻，A宕机了，它所持有的30个连接就会被重新负载到B、C上，这时候它们都持有45条连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当A重启之后，它却再也拿不到新的连接。如果LVS运算一次再平衡的话，产生的影响也比较大。所以我们希望创建的长连接能够有一个生存时长的属性，在某个时间间隔内达到渐进式的再平衡。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. k8s端口范围&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了k8s和别的程序不起冲突，默认端口的范围是 30000-32767。如果你在使用k8s平台，配置了nodeport但是无法访问到，要注意是不是设置的端口号太小了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. TIME_WAIT&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TIME_WAIT是主动关闭连接的一方保持的状态，像nginx、爬虫服务器，经常发生大量处于time_wait状态的连接。TCP一般在主动关闭连接后，会等待2MS，然后彻底关闭连接。由于HTTP使用了TCP协议，所以在这些频繁开关连接的服务器上，就积压了非常多的TIME_WAIT状态连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某些系统通过dmesg可以看到以下信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;__ratelimit: 2170 callbacks suppressed&lt;br/&gt;TCP: time &lt;span&gt;wait&lt;/span&gt; bucket table overflow&lt;br/&gt;TCP: time &lt;span&gt;wait&lt;/span&gt; bucket table overflow&lt;br/&gt;TCP: time &lt;span&gt;wait&lt;/span&gt; bucket table overflow&lt;br/&gt;TCP: time &lt;span&gt;wait&lt;/span&gt; bucket table overflow&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sysctl命令可以设置这些参数，如果想要重启生效的话，加入/etc/sysctl.conf文件中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# 修改阈值&lt;/span&gt;&lt;br/&gt;net.ipv4.tcp_max_tw_buckets = 50000 &lt;br/&gt;&lt;span&gt;# 表示开启TCP连接中TIME-WAIT sockets的快速回收&lt;/span&gt;&lt;br/&gt;net.ipv4.tcp_tw_reuse = 1&lt;br/&gt;&lt;span&gt;#启用timewait 快速回收。这个一定要开启，默认是关闭的。&lt;/span&gt;&lt;br/&gt;net.ipv4.tcp_tw_recycle= 1   &lt;br/&gt;&lt;span&gt;# 修改系統默认的TIMEOUT时间,默认是60s&lt;/span&gt;&lt;br/&gt;net.ipv4.tcp_fin_timeout = 10&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试参数的话，可以使用 sysctl -w net.ipv4.tcp_tw_reuse = 1 这样的命令。如果是写入进文件的，则使用sysctl -p生效。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. CLOSE_WAIT&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CLOSE_WAIT一般是由于对端主动关闭，而我方没有正确处理的原因引起的。说白了，就是程序写的有问题，属于危害比较大的一种。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家都知道TCP的连接是三次握手四次挥手，这是由于TCP连接允许单向关闭。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0374707259953162&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;427&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLraeg3qV1NqYqicNYpXMukH2Hic8Rj6p5VFicDO6n01u1CNMWO3db3SdCibKMqOz8u3yv9wOicoWyS5sPQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图，当一个连接发起主动关闭之后，它将进入fin_wait_1状态。同时，收到fin报文的被动关闭方，进入close_wait状态，然后回复ack后，主动关闭方进入fin_wait_2状态。这就是单向的关闭。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，如果被动关闭方因为某些原因，没有发送fin报文给主动关闭方，那么它就会一直处于close_wait状态。比如，收到了EOF但没有发起close操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，这多数是一种编程bug，只能通过代码review来解决。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7. 一个进程能够打开的网络连接&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4233576642335766&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;685&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLraeg3qV1NqYqicNYpXMukH2hIibPMZfiaXutYUhHiaqpYdg2bKY24g6Nj96l0KpdV7JUC1041pEO0Aiag/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux即使放开一个端口，能够接受的连接也是海量的。这些连接的上限，受到单进程文件句柄数量和操作系统文件句柄数量的限制，也就是ulimit和file-max。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了能够将参数修改持久化，我们倾向于将改动写入到文件里。进程的文件句柄限制，可以放在&lt;code&gt;/etc/security/limits.conf&lt;/code&gt;中，它的上限受到&lt;code&gt;fs.nr_open&lt;/code&gt;的制约；操作系统的文件句柄限制，可以放到&lt;code&gt;/etc/sysctl.conf&lt;/code&gt;文件中。最后，别忘了在&lt;code&gt;/proc/$id/limits&lt;/code&gt;文件中，确认修改是否对进程生效了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;/etc/security/limits.conf配置案例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;root soft nofile 1000000&lt;br/&gt;root hard nofile 1000000&lt;br/&gt;* soft nofile 1000000&lt;br/&gt;* hard nofile 1000000&lt;br/&gt;es  -  nofile  65535&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8. SO_KEEPALIVE&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果将这个Socket选项打开，客户端Socket每隔段的时间（大约两个小时）就会利用空闲的连接向服务器发送一个数据包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个数据包并没有其它的作用，只是为了检测一下服务器是否仍处于活动状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果服务器未响应这个数据包，在大约11分钟后，客户端Socket再发送一个数据包，如果在12分钟内，服务器还没响应，那么客户端Socket将关闭。如果将Socket选项关闭，客户端Socket在服务器无效的情况下可能会长时间不会关闭。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9. SO_REUSEADDR是为了解决什么问题&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们在网络开发时，时常会碰到&lt;code&gt;address already in use&lt;/code&gt;的异常，这是由于关闭应用程序时，还有对应端口的网络连接处于&lt;code&gt;TIME_WAIT&lt;/code&gt;状态而造成的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TIME_WAIT状态通常会持续一段时间（2ML），设置SO_REUSEADDR可以支持快速端口复用，支持应用的快速重启。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10. 健康检查采用应用心跳&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tcp自身的keepalived机制非常的鸡肋，它静悄悄的在底层运行，无法产生应用层的语义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们的想象里，连接就应该是一条线。但其实，它只是2个点，而且每次走的路径都可能不一样。一个点，需要在发出心跳包然后收到回复之后，才能知道对方是否存活。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tcp自带的心跳机制，仅仅能知道对方是否存活，对于服务是否可用，健康状况这些东西一概不知，而且超时配置常常与超时重传机制相冲突。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，有确切含义的应用层心跳是必要的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;11. SO_LINGER&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个Socket选项可以影响close方法的行为。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在默认情况下，当调用close方法后，将立即返回；如果这时仍然有未被送出的数据包，那么这些数据包将被丢弃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果将linger参数设为一个正整数n时（n的值最大是65，535），在调用close方法后，将最多被阻塞n秒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这n秒内，系统将尽量将未送出的数据包发送出去；如果超过了n秒，如果还有未发送的数据包，这些数据包将全部被丢弃；而close方法会立即返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果将linger设为0，和关闭SO_LINGER选项的作用是一样的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;12. SO_TIMEOUT&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过这个选项来设置读取数据超时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当输入流的read方法被阻塞时，如果设置timeout（timeout的单位是毫秒），那么系统在等待了timeout毫秒后会抛出一个InterruptedIOException例外。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在抛出例外后，输入流并未关闭，你可以继续通过read方法读取数据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;13. SO_SNDBUF，SO_RCVBUF&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在默认情况下，输出流的发送缓冲区是8096个字节（8K）。这个值是Java所建议的输出缓冲区的大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这个默认值不能满足要求，可以用setSendBufferSize方法来重新设置缓冲区的大小。但最好不要将输出缓冲区设得太小，否则会导致传输数据过于频繁，从而降低网络传输的效率。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;14. SO_OOBINLINE&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这个Socket选项打开，可以通过Socket类的sendUrgentData方法向服务器发送一个单字节的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个单字节数据并不经过输出缓冲区，而是立即发出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然在客户端并不是使用OutputStream向服务器发送数据，但在服务端程序中这个单字节的数据是和其它的普通数据混在一起的。因此，在服务端程序中并不知道由客户端发过来的数据是由OutputStream还是由sendUrgentData发过来的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;End&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我非常惊讶的发现，现在有些网络环境，依然还是千兆网卡，包括一些比较专业的测试环境。当在这些环境上进行实际的压测时，当流量突破了网卡的限制，应用响应将会变的异常缓慢。计算机系统是一个整体，CPU、内存、网络、IO，任何一环出现瓶颈，都会造成问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式系统中，网络是一个非常重要的因素。但由于它相对来说比较底层，所以大多数开发对其了解较少。加上现在各种云原生组件的流行，接触这些底层设施的机会就越来越少。但如果系统真的发生了问题，在排除掉其他最可能出问题的组件后，千万别忘了--&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有网络这一摊子等着你。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者简介：&lt;strong&gt;小姐姐味道&lt;/strong&gt;  (xjjdog)，一个不允许程序员走弯路的公众号。聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。我的个人微信xjjdog0，欢迎添加好友，进一步交流。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>03fb19fb375df98ccc4c58eb045db125</guid>
<title>卷王之王。</title>
<link>https://toutiao.io/k/hj0898g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fa300ff38391a94dd17be3bc3be89ab1</guid>
<title>SpringBoot 热部署神器快速重启的秘密！</title>
<link>https://toutiao.io/k/8b5fv5e</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天咱们来聊聊这个热部署神器 &lt;strong&gt;spring-boot-devtools&lt;/strong&gt; 的运行原理，看看它是怎么用这个 &lt;strong&gt;ClassLoader&lt;/strong&gt;  来实现快速重启，帮我们节省时间的！😝&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;文章概要&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章的主旋律如下👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3611111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOIBho3dOxx0npRP8uWLm534FvCqjMTJHfLAQRcraEfmFThWgicicq27Cg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;576&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;spring.factories&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们直接打开 &lt;strong&gt;spring-boot-devtools&lt;/strong&gt; 源码 ，找到 &lt;strong&gt;spring.factories&lt;/strong&gt; 文件：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42812006319115326&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOSMo7WFNVggRgnvEqY9L6EOXPW0cughQRQqwW7hJAnmn9t6mcjMAeCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1266&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一般都本地开发调试的，所以就直接看这个 &lt;strong&gt;LocalDevToolsAutoConfiguration&lt;/strong&gt; 类啦😋&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;LocalDevToolsAutoConfiguration&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到核心点在 &lt;strong&gt;重启和重载&lt;/strong&gt; 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5916824196597353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOMVkHCHRjPcOmjWMJygpJaTtOa6LmicReLcr3m9KOaSjrryAyWnEz19g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1058&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;主角👇&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5021037868162693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOv9tLibOljS5CuRbXDEKGickNbPOZAz1tGibCuVs3980wib60Hzj3qibvCXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;713&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看看这个 &lt;strong&gt;重启&lt;/strong&gt; 中有什么叭😄&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重启原理介绍&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大概这么一个思路👇 下面就跟着源码分析啦😄（&lt;strong&gt;文末有源码重启要点流程图&lt;/strong&gt;）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6090686274509803&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOj0m7l3tJKV9Sdl9xan0H30VhicZJkuN8jy0ibaticIQtetYUemgMKTM4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;816&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RestartConfiguration&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有这么些方法👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6709183673469388&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgODw7zwpMMgezyXDYMlLuVxNp86dMpGAv1sox3hJVmMpYIkRL5qK9pSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;784&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从名字上分析，这两个方法应该是重点，逻辑上应该是 有一个 &lt;strong&gt;watcher&lt;/strong&gt; 在盯着 &lt;strong&gt;classpath&lt;/strong&gt; ，如果有变动的话，就触发这个 &lt;strong&gt;ClassPathChangedEvent&lt;/strong&gt; 事件 😝&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么看看这个 &lt;strong&gt;watcher&lt;/strong&gt; 叭 😄&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ClassPathFileSystemWatcher&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2476290832455216&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOHdfob8717g30kS4EeOlaZwPNMRPfqLB7dsIJdM2k5o9ZZj7T3YJhvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;949&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到这里就创建了这个 &lt;strong&gt;ClassPathFileSystemWatcher&lt;/strong&gt; 类 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3411016949152542&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOwwGN4mvDTliazWY4UpTM7LJBZARqsPiauibJZcZZXKmmVNcOVxenjzMzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;944&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们注意到它实现了三个接口，经过前面 &lt;strong&gt;Spring&lt;/strong&gt; 文章的学习，咱们知道第一步就该看啥了😄&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据类的初始化，先看看有 &lt;strong&gt;static&lt;/strong&gt; 相关的代码没，接着看 &lt;strong&gt;构造器&lt;/strong&gt; ，最后就来到这个初始化方法 &lt;strong&gt;afterPropertiesSet&lt;/strong&gt; 啦😄&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里没有 &lt;strong&gt;static&lt;/strong&gt; 方法，构造器也很简单，就是获取 &lt;strong&gt;FileSystemWatcherFactory&lt;/strong&gt;  ，&lt;strong&gt;ClassPathRestartStrategy&lt;/strong&gt; 和 监视的文件路径，那么就看看 &lt;strong&gt;afterPropertiesSet&lt;/strong&gt; 写了什么叭 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2799208704253215&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgO5xurUpTOBGmqncpYEK3QsN1MsPcjGicNN82sh1PFOL9ND23X46gM3lw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1011&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ClassPathFileChangeListener&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个也不复杂，就监听到文件改变后，发布事件 &lt;strong&gt;ClassPathChangedEvent&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6427860696517413&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOHopJRkxUEfKVxkfJiblibzyH6dAHjncZbkaiaA7pFibtx0xianY8GMZPsuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1005&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;FileSystemWatcher&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着就是这个 &lt;strong&gt;start&lt;/strong&gt; 方法啦👇&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显就是开启一个线程，那么咱们来看看线程中到底在 &lt;strong&gt;run&lt;/strong&gt; 什么🐷&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5205078125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOJYx3pKLVDzG9Vp6DBVkOpVsibRejza5adLvb3UygYaD4fYxp7DXQ7tw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;找到这个任务类 &lt;strong&gt;Watcher&lt;/strong&gt; 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7388888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOcEOa4icGhMnFXxloaPTvvrnIDV7Yn31sBlPibyUdg8TlhlGbZiaBjzb3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以发现它的任务就是一直 &lt;strong&gt;scan&lt;/strong&gt; ，&lt;strong&gt;pollInterval&lt;/strong&gt; 默认是 &lt;strong&gt;1s&lt;/strong&gt; ，&lt;strong&gt;quietPeriod&lt;/strong&gt; 默认是 &lt;strong&gt;0.4s&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;意思是每次轮询的时间是 &lt;strong&gt;1s&lt;/strong&gt; ，包含中间休息的 &lt;strong&gt;0.4s&lt;/strong&gt; ，休息事件是来确认文件在这个期间没有再次被改动。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改动了的话会回调 &lt;strong&gt;FileChangeListener&lt;/strong&gt; 的 &lt;strong&gt;onChange&lt;/strong&gt; ，对应我们上面的这个 &lt;strong&gt;ClassPathFileChangeListener&lt;/strong&gt; ，会去发布事件 &lt;strong&gt;ClassPathChangedEvent&lt;/strong&gt; 😋&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ApplicationListener&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;绕了一大圈，终于描述完了这个监视器 &lt;strong&gt;ClassPathFileSystemWatcher&lt;/strong&gt; ，同时，我们也得把目光移到这个&lt;strong&gt;RestartConfiguration&lt;/strong&gt; 的第二个核心 &lt;strong&gt;监听器&lt;/strong&gt; 👇&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图所示，这个方法的作用就是&lt;strong&gt;重启应用 restart&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20310880829015543&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOW4vzVibdcLW5Slvs0poxcPJojUGQYkjnGpo0oFulK4Lk4I1wJTibSiaGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;965&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重启应用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重启的过程中呢，包括两个步骤，第一步 &lt;strong&gt;stop&lt;/strong&gt; ，第二步 &lt;strong&gt;start&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;stop&lt;/strong&gt; 部分就是毁灭这些东西了，这里也藏了很多细节，有很多并发相关的知识点 😋&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一. &lt;strong&gt;ReentrantLock&lt;/strong&gt;  是写在 &lt;strong&gt;try catch&lt;/strong&gt; 的里面还是外面？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二. 循环里的 &lt;strong&gt;rootContexts&lt;/strong&gt; 其实是 &lt;strong&gt;CopyOnWriteArrayList&lt;/strong&gt; 类型的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三. 通过强制的 &lt;strong&gt;OOM&lt;/strong&gt; 来清除所有的 &lt;strong&gt;软/弱引用&lt;/strong&gt; (😱 还有这种操作的！)&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.638676844783715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOWgfLvzCOtXdjjoMCNN8a2SxHkBmRGTED10pFOvWe58w9VnODb9crNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;strong&gt;start&lt;/strong&gt; 的过程中，是通过创建这个&lt;strong&gt;重启线程&lt;/strong&gt; &lt;strong&gt;RestartLauncher&lt;/strong&gt; 来实现的，可以发现该类的任务就是找到 &lt;strong&gt;mainclass&lt;/strong&gt; 并调用 &lt;strong&gt;main&lt;/strong&gt; 方法，完成重启。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28982300884955753&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOs7XvSUnMUqNQwbIeSGoTmJkWgcG1dzoQjPtxp7nONF1D76qI6iceiccQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;904&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在这个过程中，就涉及到这个 &lt;strong&gt;classloader&lt;/strong&gt; 啦。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ClassLoader&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;细心的小伙伴可以发现上面这行代码中，调用到了这个 &lt;strong&gt;ClassLoader&lt;/strong&gt; ，这个 &lt;strong&gt;getContextClassLoader()&lt;/strong&gt; 是属于 &lt;strong&gt;Thread&lt;/strong&gt; 类的，通过它可以获取到当前线程上下文的 &lt;strong&gt;ClassLoader&lt;/strong&gt; 。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Class.forName(this.mainClassName, &lt;span&gt;false&lt;/span&gt;, getContextClassLoader());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在创建这个 &lt;strong&gt;RestartLauncher&lt;/strong&gt; 线程时，就已经将咱们这个 &lt;strong&gt;RestartClassLoader&lt;/strong&gt;  给传进来了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2573454913880446&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOHSiaB6vyv9xKEH34MSiccUwPJr35odlEWA3At2IkTaXyXvjmbqviajLPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;987&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29514824797843664&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOHX9X6YPBKWIGOaWTqn65BrH2F2t6LqUTJ2hEgXa9WyR2Dffa0gQslw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;742&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重启时，就直接通过 &lt;strong&gt;RestartClassLoader&lt;/strong&gt;  去找到 &lt;strong&gt;main&lt;/strong&gt; 方法，完成重启。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5336225596529284&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgO35OAYbCnI57V4Xeial8MsGMhlCnslEgV5bFCEZPSLHxuSn5lUhic1w6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;922&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;很明显这里 &lt;strong&gt;破坏了双亲委派机制，先从自身查找，没有的话再去父类查找&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里 &lt;strong&gt;业务代码&lt;/strong&gt; 都被 &lt;strong&gt;RestartClassLoader&lt;/strong&gt; 加载了，而每次重启都会重新创建这个 &lt;strong&gt;RestartClassLoader&lt;/strong&gt;  ，然后去加载业务代码 🐖 （通过传进来的 &lt;strong&gt;URL&lt;/strong&gt;  可以发现）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么到此，这个 &lt;strong&gt;重启&lt;/strong&gt; 的过程就完成了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;差点忘了，这里还有个默认的监视范围🐷&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;监视策略&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图👇 默认策略中，这些路径下的文件变化&lt;strong&gt;不被检测&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3897216274089936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOdShgfL1Lia3fHmpPTclgcYpTibnbCeQf77P1He9MJAwUlqoIsiau3ePJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;934&quot;/&gt;&lt;figcaption&gt;image-20210920230435492&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可通过配置修改&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; spring.devtools.restart.exclude=static/**,public/**&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过阅读源码，我们知道了 &lt;strong&gt;spring-boot-devtools&lt;/strong&gt; 是通过自定义 &lt;strong&gt;RestartClassLoader&lt;/strong&gt;  来加载业务代码，并在重启时销毁它，再重新创建，进而重新获取代码，实现这个快速重启的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而其他 &lt;strong&gt;jar&lt;/strong&gt; 包等由另外的 &lt;strong&gt;ClassLoader&lt;/strong&gt;  加载，不受影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，也可以看到 Spring 事件机制 无处不在的身影，还有各种初始化的操作，以及&lt;strong&gt;线程，并发，锁&lt;/strong&gt;在重启过程中的使用，这些就需要小伙伴们打开源码自身感受了，如 &lt;strong&gt;守护线程&lt;/strong&gt;，&lt;strong&gt;ReentrantLock&lt;/strong&gt; ，&lt;strong&gt;CopyOnWriteArrayList&lt;/strong&gt; ，&lt;strong&gt;CountDownLatch&lt;/strong&gt; ，甚至 &lt;strong&gt;OOM&lt;/strong&gt; 都能这么用！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有 &lt;strong&gt;重启&lt;/strong&gt; 原来就是 &lt;strong&gt;反射调用 main 方法&lt;/strong&gt; 呀🐷&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重启过程源码要点&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6621923937360179&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOSprdN2BC7DwThL09t34S5g1qPqDCh42qzMibGlPaKETH5JpjyxGicIOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;894&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6382289416846653&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgORuc9Tt8ibWiaF5mragdDzwib6wicbpuiaznzGvZW0rfmHBN3x9BoBRbHB2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;926&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e8970c5f3344cca54af5485ce79b403b</guid>
<title>深入浅出Spark：存储系统</title>
<link>https://toutiao.io/k/s1aizd7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;作者 | 吴磊&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;策划 | 陈思&lt;/span&gt;&lt;/section&gt;&lt;section&gt;
&lt;strong&gt;专题介绍&lt;/strong&gt;:2009 年，Spark 诞生于加州大学伯克利分校的 AMP 实验室（the Algorithms, Machines and People lab），并于 2010 年开源。2013 年，Spark 捐献给阿帕奇软件基金会（Apache Software Foundation），并于 2014 年成为 Apache 顶级项目。如今，十年光景已过，Spark 成为了大大小小企业与研究机构的常用工具之一，依旧深受不少开发人员的喜爱。如果你是初入江湖且希望了解、学习 Spark 的“小虾米”，那么 InfoQ 与 FreeWheel 技术专家吴磊合作的专题系列文章——《深入浅出 Spark：原理详解与开发实践》一定适合你！本文系专题系列第四篇。&lt;/section&gt;&lt;p&gt;首先感谢各位看官在百忙之中来听我说书，真是太给面子啦！在前文书《Spark 调度系统之权力的游戏》中咱们提到 SparkContext 的初始化就像是打开了潘多拉的盒子，宛如三十六天罡临凡、七十二地煞降世，稳坐聚义厅头三把交椅的是 Spark 调度系统的三位大佬。三位大佬通力配合最终将任务（代码）分发到 Executor，Executor 则将分布式任务封装为 TaskRunner 并交由线程池执行。&lt;/p&gt;&lt;p&gt;笼统地说，任务执行的过程通常是将数据从一种形态转换为另一种形态，对于计算成本较高的数据形态，Spark 通过缓存机制来保证作业的顺利完成，今天咱们就来说说 Spark 的存储系统，看看 Spark 存储系统如何为任务的执行提供基础保障。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.472397476340694&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNiampMtJ87THWdBdAU1ciczMRqxr7R3V2mwgMCGM3d4zDibUF4PHDNK8kc1H21G7vBBuUfSV8lAzH3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2536&quot;/&gt;&lt;span&gt;SparkContext 初始化&lt;/span&gt;&lt;/p&gt;&lt;p&gt;任何一个存储系统要解决的关键问题无非是数据的存与取、收与发，不过，在去探讨 Spark 存储系统如何工作之前，咱们先来搞清楚 Spark 存储系统中“存”的主要是什么内容？总的来说，Spark 存储系统用于存储 3 个方面的数据：&lt;/p&gt;&lt;p&gt;在咱们这套书《深入浅出 Spark：原理详解与开发实践》中，这 3 个概念还是头一次出现。RDD 缓存指的是将 DAG 中某些计算成本较高且访问频率较高的数据形态以缓存的形式物化到内存或磁盘的过程。对于血统较长的 DAG 来说，RDD 缓存一来可以通过截断 DAG 从而降低失败重试的开销，二来通过缓存在内存或磁盘中的数据来从整体上提升作业的端到端执行性能。&lt;/p&gt;&lt;p&gt;Shuffle 的概念咱们在第二篇《深入浅出 Spark（二）：DAG》有简单的提及，不得不说，Shuffle 是个超级大的话题，作为绝大多数 Spark 应用的性能瓶颈担当，咱们在后文书还会细说 Spark 如何搞定 Shuffle。如果非要用一两句话来提炼，那么 Shuffle 的过程应该是：&lt;/p&gt;&lt;p&gt;Map 阶段产生的数据分片，还有另外一个名字，聪明的您一定猜到了 —— 没错！就是“Shuffle 中间结果”。通常来说，这些中间结果默认都是存储在磁盘上的，不过要是您不差钱、内存随便用，想把这些中间结果怼到内存里去从而提升 I/O 效率，也是有办法的，这是后话，咱们回头再说。&lt;/p&gt;&lt;p&gt;最后说说广播变量，广播变量的设计初衷是为了解决 Spark 调度系统中任务调度的开销问题。在前文书咱们提到，Task 分发到 Executor 后，Executor 中的线程池会并发地执行多个 Task。对于如下这段代码：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;val dict = List(“spark”, “scala”)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;val words = sparkContext.textFile(“~/words.csv”)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;val keywords = words.filter(word =&amp;gt; dict.contains(word))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;keywords.map((_, 1)).reduceByKey(_ + _).collect&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;只有第一行定义 dict 列表的代码是在 Driver 端执行，其余 3 行代码都在 Executor 端运行。需要特别注意的是，在第三行代码中，每个分发到 Executor 的 Task 都会消费第一行定义的 dict 列表，在没有广播变量机制的情况下，每个分发的 Task 都会携带一份这个列表的拷贝，对于一个线程池大小为 20 的 Executor 来说，这意味着在任意时刻该 Executor 中都有 20 份同样的数据拷贝，毫无疑问，这种分发方式引入大量不必要的网络和存储开销。&lt;/p&gt;&lt;p&gt;明智的做法自然是把需要共同访问的数据与 Tasks 剥离开来，让所有 Tasks 以共享的方式访问同一份数据。广播变量就是在这样的背景下诞生的，我们来看看使用广播变量的前后对比，即可一目了然地理解广播变量机制如何帮助任务分发降低网络与存储开销。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3723958333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNiampMtJ87THWdBdAU1ciczMZfweYA35qocDLbZYM99htMQyTrKoaTyqDe3Jibicp064KLdnm97EibJlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;span&gt;广播变量机制生效前后的任务分发对比&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在广播变量机制下，Driver 中的 dict 列表在每个 Executor 中仅分发、存储一次。具体来说，dict 列表以广播变量的形式分发并存储到 Executor 的 BlockManager 中，Executor 中的多个 Tasks 不再持有 dict 列表拷贝，在需要读取 dict 数据时，通过 BlockManager 中存储的广播变量进行访问。广播变量的收益显而易见，一则提升存储效率，二则大幅降低网络开销，那么，如果我们将思维发散出去，广播变量是不是也适合其他需要考虑存储效率和网络开销的场景呢？&lt;/p&gt;&lt;p&gt;介绍完 3 种存储对象，咱们再收回来说说 Spark 存储系统的基本构成。还记得斯巴克国际建筑集团公司的权力派系吗？驻扎在总公司的 BlockManagerMaster 作为空降派主要成员，随时向老大戴格汇报建筑材料明细，当然这里的建材指的不仅仅是原始建筑材料如钢筋、水泥、砂石料，还可以是任意加工过的半成品如楼板、承重墙面等等。BlockManagerMaster 所掌握的一手信息均来自分公司的下属 —— BlockManager。本篇要讲述的，就是布劳克（BlockManager）和他的小弟们之间的故事。&lt;/p&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3453125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNiampMtJ87THWdBdAU1ciczMbycXDkzp6cRJyM3bmbVDvHhPT8GoBJQYMgEpEJfCaePKqD9ZyRTuvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;span&gt;Spark 分布式系统新老派系构成 —— 新老派系的故事请参考《Spark 调度系统之权力的游戏》&lt;/span&gt;&lt;/section&gt;&lt;section&gt;
&lt;span&gt;存储建材的仓库&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;无论是原材料还是中间加工的半成品，这些形形色色的数据形态都需要有个地方“存”才行，Spark 存储系统提供了两种存储实现，分别是内存存储 MemoryStore 和磁盘存储 DiskStore。从名字我们就能看出来，MemoryStore 用于存储内存中的数据块，而 DiskStore 则用来存储磁盘中的数据块。&lt;/p&gt;&lt;p&gt;更形象地，在斯巴克建筑集团的分公司，MemoryStore 相当于是建筑工地上的临时储物仓库，无论是往里存物料还是往外取建材都很方便，不过缺点是临时仓库空间有限，能装的东西少；DiskStore 则不同，DiskStore 是能够容纳所有建材的专用仓储基地，这里地大物博，空间大、各种建材应有尽有，不过缺点是距离工地太远，来回往返运输建材比较麻烦，得需要多辆专用的大型货车才能及时地供应建筑工地的作业需要。&lt;/p&gt;&lt;p&gt;说完“在哪儿”（Where）存，咱们再来说说不同的数据形态以怎样的形式存储于 MemoryStore 和 DiskStore。&lt;/p&gt;&lt;p&gt;Spark 支持两种数据存储形式，即对象值和字节数组，且两者之间可以相互转化。将对象值压缩为字节数组的过程，称为序列化；相反，将字节数组还原为对象值，称之为反序列化。序列化的字节数组就像是从宜家家具超市购买的待组装板材（外加组装说明书），而对象值则是将板材拆包、并根据说明书组装而成的各种桌椅板凳。对象值的优点是“拿来即用”、所见即所得，缺点是所需的存储空间大、占地儿。相比之下，序列化的字节数组的空间利用率要高得多，不过要是急用桌椅板凳的话，还得根据说明书现装，略麻烦。&lt;/p&gt;&lt;p&gt;由此可见，二者的关系是一种博弈，所谓的“以空间换时间”和“以时间换空间”，具体的取舍还要看使用场景，想省地儿，您就用字节数组，想以最快的速度访问对象，对象值的存储方式还是来的更直接一些。不过像这种选择的烦恼只存在于 MemoryStore 之中，DiskStore 只能存序列化后的字节数组 —— 这里咱们多说两嘴，凡是需要走网络或落盘的数据，都是需要序列化的。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.571875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNiampMtJ87THWdBdAU1ciczMTfv58ZXrCjRciarSrpic9aeI7nkOAHFlNNUFibf4KsH1os1bZYicxSrnWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;span&gt;仓库类比之 MemoryStore 与 DiskStore&lt;/span&gt;&lt;/p&gt;&lt;p&gt;得益于临时储物仓库（MemoryStore）和专用仓储基地（DiskStore），斯巴克的各个分公司暂时解决了东西存在哪儿的问题，不过，光有仓库也不行啊，总得要有人打理、管理这些仓库，不然来拉取建材的人连想要的东西具体放在哪个货架都不清楚，总不能每次来都从头到尾把仓库逛个遍吧。&lt;/p&gt;&lt;p&gt;说到分公司的组织架构，建材部的部门经理布劳克（BlockManager）对与建材和库管有关的所有事项负责，比如建材编号、建材存储、建材拉取、建材运输、建材状态维护、仓库管理、仓库维护等等。&lt;/p&gt;&lt;p&gt;不过，作为部门经理，受限于时间和精力有限，布劳克自然不能事必躬亲，更何况他还要对自己的老板（总公司的 BlockManagerMaster）负责 —— 随时汇报分公司建材与仓储的信息与状态。好在布劳克还有一众小弟们来帮他打理各种具体事务，仅库存管理就有两个小弟来分别负责工地的临时储物仓库和专用仓储基地，他们分别是：BlockInfoManager 和 DiskBlockManager。&lt;/p&gt;&lt;p&gt;先说 DiskBlockManager，DiskBlockManager 的主要职责是记录逻辑数据块 Block 与磁盘文件系统中物理文件的对应关系。每个 Block 都对应一个磁盘文件，同理，每个磁盘文件都有一个与之对应的 Block ID，这就好比仓库中的每一件货物都有唯一的 ID 标识，显而易见，DiskBlockManager 就是专用仓储基地 DiskStore 的“库管”。&lt;/p&gt;&lt;p&gt;对于仓库的管理，DiskBlockManager 首先根据用户配置如 spark.local.dir 创建出用于存储文件的根目录，这一步相当于是在仓库中把所需的货架都提前准备好；然后，根据存储内容（如 RDD 缓存或 Shuffle 中间结果）的不同，创建不同前缀的文件：RDD 缓存为‘rdd_’，Shuffle 中间结果为‘shuffle_’，广播变量是‘broadcast_’，在创建文件的过程中，DiskBlockManager 同时维护 Block 与文件之间的对应关系；最后，当不同类型的任务根据 Block ID 尝试获取、访问这些数据块时，DiskBlockManager 根据对应关系查找与该 Block ID 对应的物理文件地址。&lt;/p&gt;&lt;p&gt;相较于 DiskBlockManager，MemoryStore“库管”BlockInfoManager 就显得没那么“称职”，对于 MemoryStore 中存储的数据，BlockInfoManager 的职责仅包含如下各项：记录数据块大小、维护加持在 Block 上的读锁与写锁、维护任务的读写权限状态。简言之，BlockInfoManager 主要用于保持 MemoryStore 中数据状态的一致性，而不是用于维护逻辑块与物理存储的对应关系。那么问题来了，想要拉取 MemoryStore 中“货物”的卡车司机怎么知道货物存储在哪个货架呢？&lt;/p&gt;&lt;section&gt;
&lt;span&gt;建材的存与取&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;要回答这个问题，咱们还要说回 MemoryStore，前文书咱们说到 MemoryStore 可以存储两种形式的数据，即对象值和字节数组，对于这两种数据形式，MemoryStore 统一采用 MemoryEntry 抽象来进行封装。&lt;/p&gt;&lt;p&gt;MemoryEntry 实现为 Scala Trait，主要成员为数据块大小和数据类型，它的两个实现类 DeserializedMemoryEntry 和 SerializedMemoryEntry 分别用于封装对象值和字节数组，其中 DeserializedMemoryEntry 利用 Array[T] 来存储对象值序列，而 SerializedMemoryEntry 利用 ByteBuffer 来存储序列化后的字节序列。&lt;/p&gt;&lt;p&gt;MemoryStore 通过一种高效的数据结构来统一数据块的存储与访问：LinkedHashMap[BlockId, MemoryEntry]，即 Key 为 BlockId、Value 是 MemoryEntry 的映射。显然，一个 Block 对应一个 MemoryEntry，MemoryEntry 既可以是 DeserializedMemoryEntry、也可以是 SerializedMemoryEntry。有了这个 LinkedHashMap，通过 BlockId 即可方便地定位 MemoryEntry，从而实现数据块的快速存取。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3411458333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNiampMtJ87THWdBdAU1ciczMpibs5cEUs9K7KEobecV48ib1sXchWD5EyUCer1r1RcBUqsqCtict7uE1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;span&gt;MemoryStore 中的数据存储流程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;先来看数据存储的流程，也即将 RDD 中数据分片（Partitions/Blocks）的 Iterator 物化为数据存储的过程。&lt;/p&gt;&lt;p&gt;逻辑上，RDD 数据分片（也即 Partition）与 Block 是一一对应的，不过需要指出的是，Partition 的编号规则与 Block 的编号规则不见得保持一致。MemoryStore 提供了 putIteratorAsValues 和 putIteratorAsBytes 来将 RDD 数据分片对应的迭代器分别物化为对象值序列和字节序列，具体流程如上图所示。&lt;/p&gt;&lt;p&gt;值得注意的是，在将数据封装为 MemoryEntry 之前，MemoryStore 先利用 ValuesHolder 对 Iterator 进行展开（Unroll），展开的过程实际上就是物化的过程，数据实实在在地存储到 ValuesHolder 封装的数据结构（Vector 或 OutputStream）中，这些物化的数据在之后封装为 MemoryEntry 的过程中，仅仅（通过 toArray、toByteBuffer 等操作）在数据类型上做了转换，并没有带来额外的内存消耗，Spark 源码中将这个过程称之为：从 Unroll memory 到 Storage memory 的“Transfer（转移）”。&lt;/p&gt;&lt;p&gt;理顺了数据存储的流程，数据的读取和访问则一目了然。MemoryStore 提供 getValues 和 getBytes 方法，根据 BlockId 分别访问对象值与字节序列，如下图所示。两种方法首先通过 BlockId 获取到对应的 DeserializedMemoryEntry 或 SerializedMemoryEntry，然后在通过访问各自封装的 Array[T] 和 ByteBuffer 来读取数据内容。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5317708333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNiampMtJ87THWdBdAU1ciczMRTVygtJWqPt9OqwJibXukqSthBt1pRQjnqGwVaBic81291arvKH9wXxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;span&gt;MemoryStore 中的数据访问&lt;/span&gt;&lt;/p&gt;&lt;p&gt;说到 MemoryStore 中数据的存与取，有几个重要的角色不得不提，他们分别是：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;BlockInfoManager：前文书已有交代，其主要职责是通过锁机制来保证多任务并发情况下数据访问的一致性。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;SerializerMananger：顾名思义，自然是负责 MemoryStore 中数据的序列化与反序列化。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;MemoryManager：Spark 内存管理器，这可是斯巴克国际建筑集团分公司举足轻重的一位大佬，我们在下一篇《Spark 内存管理》中会有更详细的交代。&lt;/p&gt;&lt;p&gt;如果非要用一句话概括，MemoryManager 的主要职能是维持不同内存区域（Storage memory, Shuffle memory, Runtime memory 等）之间的平衡、以及维持多任务并发下不同线程之间内存消耗的平衡。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;BlockEvictionHandler：这个角色比较有意思，他负责把 MemoryStore 中的数据块“驱逐”出内存 —— 通常情况下都会把这些被驱逐的 Block“撵”到 DiskStore 中去，也即把内存中物化的数据转移到磁盘存储中。一个典型的场景是当 RDD 缓存采用 MEMORY_AND_DISK 模式且内存不足以容纳整个 RDD 数据集时，根据 LRU 原则，访问频次较低且访问时间较为久远的 Block 就会被 BlockEvictionHandler“下放”到 DiskStore 中去。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6401041666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNiampMtJ87THWdBdAU1ciczM3B9XibXI7fk7J0eHXDjPm7ECiawtKyibibrIbSBoYyuhiajbWp561KxVy8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;span&gt;DiskStore 中数据的存与取&lt;/span&gt;&lt;/p&gt;&lt;p&gt;说来说去又说回了 DiskStore，DiskStore 中的数据存取相对直截了当一些，有 DiskBlockManager 这个“管家”协助维护 Block 与磁盘文件的对应关系，DiskStore 并不需要过多的抽象来封装读写逻辑。实际上，在数据存取的闭环中，DiskStore 仅在数据访问的过程中利用 BlockData 抽象来封装将磁盘文件内容转换为字节数组的操作。&lt;/p&gt;&lt;p&gt;BlockData 的两个实现类 DiskBlockData 和 EncryptedBlockData 都是通过 open 函数获取 Java NIO 的 FileChannel，然后再通过 toByteBuffer 函数利用 FileChannel 将文件内容转换为字节数组。如上图所示，在数据访问过程（步骤 4 至 7）中，getBytes 首先根据 BlockId 从 DiskBlockManager 获取对应磁盘文件，然后将 FileChannel 封装为 BlockData，最后通过 BlockData 的 toByteBuffer 方法得到所需的字节数组。数据写入的过程（步骤 1 至 3）则更简单，首先根据 BlockId 从 DiskBlockManager 获取文件地址，然后再通过 FileChannel 将 ByteBuffer 内容落地到磁盘文件。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;建材的运输与物流&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;到目前为止，数据的存与取都是发生在本地的，也即数据存储与拉取的请求和处理都是发生在同一个计算节点。前文书咱们说到，Spark 存储系统主要服务于三类任务：&lt;/p&gt;&lt;p&gt;要完成这些任务，仅有本地化的数据存取是不够的，Spark 存储系统还需要提供跨节点存取数据的能力。具体来说，为了提高可用性和稳定性，RDD Caching 往往会在 MemoryStore 和 DiskStore 中缓存多份 RDD 副本，节点间的副本拷贝与上传需要跨节点传输的能力。Shuffle 任务在 Shuffle write 阶段会将对应于多个 Reducer 的数据分片写入到本地磁盘，这些数据分片称为 Shuffle 中间文件，Shuffle read 阶段 Reducer 通过网络访问所有节点从而读取所有属于自己的数据分片，这个过程自然需要网络 I/O 的支持。那么问题来了，如何提供这些能力从而支持跨节点数据存取的功能呢？&lt;/p&gt;&lt;p&gt;在本篇的开始，咱们说到 SparkContext 在初始化的过程中会创建一系列的对象来分别服务于众多的 Spark 子系统 —— 如调度系统、存储系统、内存管理、Shuffle 管理、RPC 系统等，我们暂且把这些对象称之为“上下文对象”。BlockManager 作为 Spark 存储系统的入口，以组合的设计模式持有多个“上下文对象”的引用，封装了与数据存取有关的所有抽象。BlockManager 的组合对象星罗云布，到目前为止我们接触过的有：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;MemoryStore、DiskStore、BlockInfoManager、DiskBlockManager —— 本地数据存取&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;MemoryManager —— 维护不同内存区域之间的平衡&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;SerializerManager —— 序列化管理器&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;除此之外，还有 MapOutputTracker、ShuffleManager、BlockTransferService 等等。MapOutputTracker 咱们在上一篇《Spark 调度系统之权力的游戏》略有提及；Shuffle 是个大话题，ShuffleManager 我们留到之后《Spark Shuffle 管理》再讲；本章节的主角是 BlockTransferService —— 回答刚刚的问题，Spark 存储系统正是仰仗 BlockTransferService 来提供跨节点的数据存取。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.34375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNiampMtJ87THWdBdAU1ciczMledrUJUBUnDTvX4V5M1vAbByJaxze8zI77kRTZymMtAte29TwldRQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;span&gt;Spark 存储系统对于不同类型任务的支持&lt;/span&gt;&lt;/p&gt;&lt;p&gt;BlockTransferService 抽象主要提供两种方法来支持不同类型的计算任务，即如上图所示的 fetchBlockSync 方法和 uploadBlockSync 方法。&lt;/p&gt;&lt;p&gt;BlockTransferService，顾名思义，既然是 Service，自然就绕不开 Server/Client 的概念。fetchBlockSync 方法和 uploadBlockSync 方法都属于客户端方法，用于向服务端提交“下载数据块”和“上传数据块”的请求。&lt;/p&gt;&lt;p&gt;说到这里，各位看官不禁要问：BlockTransferService 就是个抽象而已，而且仅仅提供了两个数据收发的接口，它依托什么来构建服务端和客户端呢？&lt;/p&gt;&lt;p&gt;要说清楚客户端与服务端，咱们就需要深入到 BlockTransferService 接口的唯一实现类 NettyBlockTransferService 中去一探究竟。Netty 是基于 NIO（Nonblocking I/O，非阻塞 I/O）的网络通信框架，非阻塞 I/O 赋予 Netty 天然的高并发特性，Netty 提供 Channel 抽象对 JDK 原生的 SocketChannel 进行了封装和增强从而使得开发者可以更加高效地进行网络开发。NettyBlockTransferService 正是站在 Netty 的“肩膀”上在初始化阶段同时创建客户端工厂和服务端。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.49375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNiampMtJ87THWdBdAU1ciczMU76tkExIvDOFqcrVgo29J0ker5T0Nwn5y4Rw2LIvjOOTvKOUbfRpjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;span&gt;NettyBlockTransferService 创建建客户端与服务端&lt;/span&gt;&lt;/p&gt;&lt;p&gt;如上图所示，NettyBlockTransferService 在初始化过程中分别通过 createServer 和 createClientFactory 来创建服务端和客户端，二者的创建过程极其类似 —— 先实例化 Netty Bootstrap、然后绑定 Channel 和异步处理线程 NioEventLoop、最后绑定地址与端口 / 连接服务器来启动服务 / 发起请求。&lt;/p&gt;&lt;p&gt;通过客户端，BlockManager 即可通过 fetchBlockSync 方法和 uploadBlockSync 方法向其他计算节点发起数据块下载 / 上传请求；相应地，每个 BlockManager 通过服务端来响应其他节点发来的数据传输请求。这么看来，对于斯巴克国际建筑集团公司来说，BlockTransferService 相当于是集团为分公司（Executor）配备的物流服务，专门负责不同分公司之间建材的物流与分发。&lt;/p&gt;&lt;p&gt;到此为止，Spark 存储系统的全貌已初露端倪，尽管相关环节细节还有待深入，不过从功能和功用的角度来说，Spark 存储系统作为底层基础设施，我们基本上弄清了它如何为其他数据服务（如 RDD 缓存、Shuffle）提供基础保障。这些数据服务在 Spark 分布式计算中扮演着至关重要的角色，运用得当，他们可以帮助应用程序大幅提升执行性能，不过，反之亦然。在接下来的篇章里，我们将一一对其展开、渐进式地解锁性能调优的技能，敬请期待。&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Postscript&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本篇是《Spark 分布式计算科普专栏》的第四篇，笔者学浅才疏、疏漏难免。如果您有任何疑问，或是觉得文章中的描述有所遗漏或不妥，欢迎在评论区留言、讨论。掌握一门技术，书本中的知识往往只占两成，三成靠讨论，五成靠实践。更多的讨论能激发更多的观点、视角与洞察，也只有这样，对于一门技术的认知与理解才能更深入、牢固。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在本篇博文中，先从功用的角度介绍了 Spark 存储系统服务的主要对象（RDD 缓存、Shuffle、广播）；紧接着从“建材仓储”MemoryStore 和 DiskStore 入手，说明了数据在 BlockManager 中的存储形式和存储方式；然后通过 MemoryEntry 和 DiskBlockManager 来讲述数据在内存和磁盘中的存取过程；最后以 BlockTransferService 收尾，NettyBlockTransferService 以服务端与客户端的形式为跨节点数据传输提供基础服务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;出于科普的初衷，本篇隐去了 Spark 存储系统中的一些分支和细节，如与 ExternalShuffleService（提供高可用的 Shuffle 服务）有关的存储功能、为支持异步数据拷贝与上传而提供的 newCachedThreadPool 线程池，等等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从下一篇开始，咱们将以性能调优为导向分析、探讨 Spark 分布式系统的关键环节，而不只是单纯地进行原理的讲解。作为一款内存计算引擎，内存的探索与利用自然尤为重要，毕竟不知 MemoryManager 如何以统一的方式打理内存，且听下回分解。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>131ae5b965b85e7bff95801197b068d3</guid>
<title>service worker轻度探索 - 解决运营活动需求中的图片加载问题?</title>
<link>https://toutiao.io/k/v1u5lan</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxNzk1MjQ0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/YBFV3Da0Nwvv72YkFO0qPibDKicOCsfltiaE9070DOu4iahXnicYwRIHcxe9VBicAy45MkPqy8nZzLTVibugOtV0ORFcg/0?wx_fmt=png&quot; data-nickname=&quot;程序员成长指北&quot; data-alias=&quot;coder_growth&quot; data-signature=&quot;专注 Node.js 技术栈分享，从 前端 到 Node.js 再到 后端数据库，祝您成为优秀的高级 Node.js 全栈工程师。一个有趣的且乐于分享的人。座右铭：今天未完成的，明天更不会完成。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大厂技术&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;高级前端&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;Node进阶&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;点击上方 &lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(0, 128, 255)&quot;&gt;程序员成长指北&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;，关注公众号&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回复&lt;/span&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，加入高级Node交流群&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;做过运营活动需求的同学都知道，一般一个运营活动中会用到很多的图片资源。用户访问首页时，都会看到一个loading态，表示页面正在加载所需的所有图片资源。像下面这样：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.3380281690140845&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/R7oib8BJQz2hm4F7zsECx0tyjxibbo6XVOKjFcyLYnTfp35BIBqhljfzqqVq4X0Z2zJib7SiaLR93QibnHibLx0JlXkw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;142&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;手动加载一个图片的代码也很简单：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; img = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Image();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;img.onload = &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt;{ ... }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;img.src = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;图片地址&#x27;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span md-inline=&quot;plain&quot;&gt;之所以要提前加载所有的图片，是为了在后续的页面中使用图片时，不会因为需要加载图片而产生耗时，导致体验问题。本文所要讨论的场景就是：&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;怎么样做到在首页加载图片后，直接在后面的业务逻辑中直接使用提前加载好的图片呢&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;？答案就是：把图片存下来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;缓存首页加载的图片&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;我能想到的这种场景下的缓存图片方法有两种：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n9&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n11&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;使用浏览器的缓存&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;。图片在第一次请求成功后，一般都会设置缓存。在页面后续的业务逻辑中，如果说想使用某图片，直接正常发起图片请求即可，浏览器会走缓存，甚至是从内存中直接返回这个图片。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n13&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;将加载好的Image对象直接保存在内存中&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;。这种方法很适用canvas中画图的场景，直接把保存下来的Image对象扔到canvas的drawImage中即可。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n13&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n13&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n13&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n13&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;做业务需要不断的总结，思考。还能用什么方法来实现图片的缓存呢 ?  我尝试了一下Service Worker，本文将介绍一下Service Worker在这种业务场景下的应用。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p cid=&quot;n13&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span&gt;本文只是轻度尝试了一下Service Worker，并未在线上应用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;service worker&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p cid=&quot;n18&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Service Worker是PWA的重要组成部分，其包含安装、激活、等待、销毁等四个生命周期。主要有以下的特性：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n19&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n21&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n23&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;一旦被 install，就永远存在，除非被手动 unregister&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n25&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;用到的时候可以直接唤醒，不用的时候自动睡眠&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n27&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n29&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;离线内容开发者可控&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n31&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;能向客户端推送消息&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n33&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;不能直接操作 DOM&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n35&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;必须在 HTTPS 环境下才能工作( 或 &lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;http://localhost&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; )&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n37&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;异步实现，内部大都是通过 Promise 实现&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n38&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在本文所描述的业务场景中，主要是应用service worker的拦截代理请求和返回的功能。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n39&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;关于service worker的基础，谷歌开发者网站上有详细的介绍，这里就不赘述了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n40&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址在这里：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://developers.google.com/web/fundamentals/primers/service-workers/?hl=zh-cn&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n41&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;需要注意的是，service worker一定要谨慎使用，因为它太重要了，一旦注册，站点的所有请求都会被控制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;service worker的示例&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;结合文章开头所描述的场景，我们先来写一些必要的业务函数。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;loadImage&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;imgUrl&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;code-snippet__function&quot;&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;resolve, reject&lt;/span&gt;)=&amp;gt;&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; img = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Image();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        img.onload = &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            resolve();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        img.src = imgUrl;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;loadImageList&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;imgList&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Promise&lt;/span&gt;.all(imgList.map(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;code-snippet__params&quot;&gt;imgUrl&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; loadImage(imgUrl);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;下面是service worker的代码：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;self&lt;/span&gt;.addEventListener(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;install&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(event)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    console.log(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;install&#x27;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;self&lt;/span&gt;.addEventListener(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;fetch&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(evt)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    evt.respondWith(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        caches.match(evt.request).then(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(response)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (response) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; response;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; request = evt.request.&lt;span class=&quot;code-snippet__keyword&quot;&gt;clone&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; fetch(request).then(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(response)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!response || response.status !== &lt;span class=&quot;code-snippet__number&quot;&gt;200&lt;/span&gt; || !response.headers.get(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;Content-type&#x27;&lt;/span&gt;).match(/image/)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; response;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; responseClone = response.&lt;span class=&quot;code-snippet__keyword&quot;&gt;clone&lt;/span&gt;(); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                caches.open(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;test-cache&#x27;&lt;/span&gt;).then(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(cache)&lt;/span&gt; &lt;/span&gt;{ &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    cache.put(evt.request, responseClone);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; response;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        })&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;self&lt;/span&gt;.addEventListener(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;activate&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    console.log(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;activate&#x27;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    clients.claim(); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p cid=&quot;n47&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;注册完service worker后，我们就劫持了页面的所有请求。每一次请求经过service worker时，都会判断刚请求是否已有缓存，如果有缓存，就直接返回结果。没有缓存时，才会向服务器发起请求，并且将图片请求的结果缓存起来。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n48&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在业务代码中，我们注册并使用这个service worker的代码如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; imgArr = [&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;http://xxx.png&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;...&#x27;&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;registerServiceWorker&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;serviceWorker&#x27;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; navigator) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; navigator.serviceWorker.register(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;http://localhost:8080/service.js&#x27;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;registerServiceWorker().then(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;registration&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; serviceWorker;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (registration.installing) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;registration.installing&#x27;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        serviceWorker = registration.installing;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (registration.waiting) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;registration.waiting&#x27;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        serviceWorker = registration.waiting;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (registration.active) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;registration.active&#x27;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        serviceWorker = registration.active;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        loadImageList(imgArr);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (serviceWorker) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        serviceWorker.addEventListener(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;statechange&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;code-snippet__params&quot;&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(e.target.state === &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;activated&#x27;&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;首次注册sw时，sw激活&#x27;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                loadImageList(imgArr);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}).catch(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;e&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n50&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;注意事项：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n51&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n53&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;正常情况下，service worker刚注册时，是不会控制页面的，即无法拦截到页面的请求。需要用户刷新页面，再次访问时，service worker才会拦截页面请求。这与我们的需求场景不符合。我们的需求是：用户首次访问请求图片资源时，就需要对返回的图片进行缓存。所以，需要在service worker进入activate状态后，通过clients.claim()来获得页面的控制权。&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;不过，这种方式并不被提倡&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n55&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;service worker拦截到请求后，我们需要拷贝返回的数据流，才能存入缓存。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n57&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在业务代码中，我们每次都需要调用navigator.serviceWorker.register来拿到一个service worker。浏览器会判断当前service worker的状态，返回对应的对象。我们需要保证在service worker准备无误后，再发起图片的请求。由于server worker的自身逻辑需要一定的时间，所以我们发起图片请求的时间会被延后。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;使用service worker后的效果&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;以我做的运营活动项目为例，使用service worker之前，网络请求是这样的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n61&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n63&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;活动页首页，首次集中请求图片：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n63&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.54140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/R7oib8BJQz2hm4F7zsECx0tyjxibbo6XVOaWF2r2Eiclg9FANadrMAISX6h2nWkQeic3RUEN7o4pw4f9yYS6xRjJNw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n41&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&lt;span&gt;活动页后续页面中，使用加载好的图片：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4151898734177215&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/R7oib8BJQz2hm4F7zsECx0tyjxibbo6XVOVZrc22iaL2ibzHIibrpdmw03QxBHxyIInUPXsTIgKRThico8ibNNPyWwn4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1580&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n41&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&lt;span&gt;使用service-worker之后，网络请求是这样的：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n41&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&lt;span&gt;&lt;span&gt;活动页首页，首次集中请求图片：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45663265306122447&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/R7oib8BJQz2hm4F7zsECx0tyjxibbo6XVO1D5jybEBjeFsiaibsRsviaYNrmCZmwg5nepd7c50gr1MyqI42D35tT2ibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1568&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4740834386852086&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/R7oib8BJQz2hm4F7zsECx0tyjxibbo6XVOJl78vFEmX7BYAhLmTJ1rD8KZ9VAl9fDtSdPaBfyic6DMLK1ECXlVtcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1582&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到，我们成功使用service worker劫持了页面的请求，并且将图片缓存到了浏览器的cache storage中。我们来看一下浏览器的缓存。这里的缓存都是http response：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4848851269649335&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/R7oib8BJQz2hm4F7zsECx0tyjxibbo6XVOZBpQXwRicVmQEqkrnNf4un6TFDzV2tSicib6OAq7LCHvRxpIGhp5UE9fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1654&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 另外这里多说一句，可以使用下面的代码，来查看当前网站可以使用的浏览器本地存储空间&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;storage&#x27;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; navigator &amp;amp;&amp;amp; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;estimate&#x27;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; navigator.storage) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  navigator.storage.estimate().then(&lt;span class=&quot;code-snippet__function&quot;&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;{usage, quota}&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;code-snippet__string&quot;&gt;`Using &lt;span class=&quot;code-snippet__subst&quot;&gt;${usage}&lt;/span&gt; out of &lt;span class=&quot;code-snippet__subst&quot;&gt;${quota}&lt;/span&gt; bytes.`&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;一些思考&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p cid=&quot;n82&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在本文提到的场景中，我们在用户首次访问页面时，先注册了service worker，并且使service worker立即控制页面，然后再开始请求图片。这种做法延后了图片请求的发起时间，并且从上面的图中可以看到，通过service worker加载图片的耗时比正常直接请求图片耗时略长。这些因素导致首屏时间被延后了。另外，作为运营活动页，同一个用户也不会在几天内多次访问，因此service worker的【绕过网络，立即响应请求】的特性并不能很好地发挥出来。综上所述，在本文的场景中，使用service worker来做缓存并不是最佳实践。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n84&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;关于service worker做缓存的最佳实践以及使用场景，可以查看这篇文章：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n85&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading?hl=zh-cn&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;service worker最适合的场景还是资源离线化，用户二次进入页面时可以达到资源秒加载，不会受网络状况的影响。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;写在后面&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;本文从业务的角度出发，轻度探索了service worker在文章开头给出的业务场景中的应用，了解了service worker的使用方法。后续会考虑在合适的业务场景中进行应用。符合预期。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16071428571428573&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ljib4So7yuWjicACzgyxJniasy6ibkpInm3TcGNLCiaeicY5I6o9PKBOTiaibVUDnic11QLEp9CKmBpQggtMDhKaXEPbE4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxNzk1MjQ0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/YBFV3Da0Nwvv72YkFO0qPibDKicOCsfltiaE9070DOu4iahXnicYwRIHcxe9VBicAy45MkPqy8nZzLTVibugOtV0ORFcg/0?wx_fmt=png&quot; data-nickname=&quot;程序员成长指北&quot; data-alias=&quot;coder_growth&quot; data-signature=&quot;专注 Node.js 技术栈分享，从 前端 到 Node.js 再到 后端数据库，祝您成为优秀的高级 Node.js 全栈工程师。一个有趣的且乐于分享的人。座右铭：今天未完成的，明天更不会完成。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section label=&quot;Copyright © 2016 playhudong All Rights Reserved.&quot; donone=&quot;shifuMouseDownPayStyle(&#x27;shifu_t_042&#x27;)&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;Node 社群&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;89226&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;我组建了一个氛围特别好的 Node.js 社群，里面有很多 Node.js小伙伴，如果你对Node.js学习感兴趣的话（后续有计划也可以），我们可以一起进行Node.js相关的交流、学习、共建。下方加 考拉 好友回复「Node」即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YBFV3Da0NwsF7OKB4iaaXAzQPbNstk2LybA0Zz5I1hiaiazE9W7WH2Ojt2dibDODWMVUmHqgfXCefVwt7z5ibNMWLvg/0?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;578.2649006622516&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;700.2119205298013&quot; data-fileid=&quot;100016913&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2093425605536332&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YBFV3Da0NwvFQgO67XibvUG5S2UMXwCghOuJvE8BFRzUXnCAfWXkU1qHld6Ly9xiarib3siaWicJWJ0U3lI8kSgD38w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;strong&gt;&lt;span&gt; “分享、点赞&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;在看” 支持一波👍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>