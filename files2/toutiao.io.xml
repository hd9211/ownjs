<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e8311f3f2ed9157b03eb2977465510bc</guid>
<title>MyBatis 的本质和原理</title>
<link>https://toutiao.io/k/613ifih</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    项目需要，我们需要自己做一套mybatis，或者使用大部分mybatis的原始内容。对其改造，以适应需要。这就要求我再次学习一下mybatis，对它有更深入的了解。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;是什么&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;    MyBatis是一个持久层框架，用来处理对象关系映射。说白了就是以相对面向对象的方式来提交sql语句给jdbc。如果想找个简单、快速上手的例子，最好是和spring想结合的。直接用官网的吧，简单清晰也没谁了：http://mybatis.org/spring/getting-started.html&lt;/p&gt;&lt;p&gt;https://mybatis.org/mybatis-3/getting-started.html&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;为什么&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    Java开发都是面向对象的思维，如果用传统下面自己去调用连接拼装sql的方式，维护成本高，代码可读性差。&lt;/p&gt;&lt;pre&gt;&lt;span&gt;public static void &lt;/span&gt;&lt;span&gt;main&lt;/span&gt;(String[] args) {&lt;br/&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据&lt;/span&gt;&lt;span&gt;库连&lt;/span&gt;&lt;span&gt;接&lt;/span&gt;&lt;span&gt;对&lt;/span&gt;&lt;span&gt;象&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;Connection conn = &lt;span&gt;null;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据&lt;/span&gt;&lt;span&gt;库&lt;/span&gt;&lt;span&gt;操作&lt;/span&gt;&lt;span&gt;对&lt;/span&gt;&lt;span&gt;象&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;PreparedStatement stmt = &lt;span&gt;null;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;//1&lt;/span&gt;&lt;span&gt;、加&lt;/span&gt;&lt;span&gt;载驱动&lt;/span&gt;&lt;span&gt;程序&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;try &lt;/span&gt;{&lt;br/&gt;        Class.&lt;span&gt;forName&lt;/span&gt;(&lt;span&gt;DBDRIVER&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;} &lt;span&gt;catch &lt;/span&gt;(ClassNotFoundException e) {&lt;br/&gt;        e.printStackTrace()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;    &lt;span&gt;//2&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;连&lt;/span&gt;&lt;span&gt;接数据&lt;/span&gt;&lt;span&gt;库&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通&lt;/span&gt;&lt;span&gt;过连&lt;/span&gt;&lt;span&gt;接管理器&lt;/span&gt;&lt;span&gt;连&lt;/span&gt;&lt;span&gt;接数据&lt;/span&gt;&lt;span&gt;库&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;try &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;连&lt;/span&gt;&lt;span&gt;接的&lt;/span&gt;&lt;span&gt;时&lt;/span&gt;&lt;span&gt;候直接&lt;/span&gt;&lt;span&gt;输&lt;/span&gt;&lt;span&gt;入用&lt;/span&gt;&lt;span&gt;户&lt;/span&gt;&lt;span&gt;名和密&lt;/span&gt;&lt;span&gt;码&lt;/span&gt;&lt;span&gt;才可以&lt;/span&gt;&lt;span&gt;连&lt;/span&gt;&lt;span&gt;接&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;conn = DriverManager.&lt;span&gt;getConnection&lt;/span&gt;(&lt;span&gt;DBURL&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;USERNAME&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;PASSWORD&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;} &lt;span&gt;catch &lt;/span&gt;(SQLException e) {&lt;br/&gt;        e.printStackTrace()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;    &lt;span&gt;//3&lt;/span&gt;&lt;span&gt;、向数据&lt;/span&gt;&lt;span&gt;库&lt;/span&gt;&lt;span&gt;中插入一条数据&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;String sql = &lt;span&gt;&quot;INSERT INTO person(name,age) VALUES (?,?)&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    try &lt;/span&gt;{&lt;br/&gt;        stmt = conn.prepareStatement(sql)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;stmt.setString(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;陈&lt;/span&gt;&lt;span&gt;昆&lt;/span&gt;&lt;span&gt;仑&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;stmt.setInt(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;stmt.executeQuery()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;} &lt;span&gt;catch &lt;/span&gt;(SQLException e) {&lt;br/&gt;        e.printStackTrace()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;    &lt;span&gt;//4&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;执&lt;/span&gt;&lt;span&gt;行&lt;/span&gt;&lt;span&gt;语&lt;/span&gt;&lt;span&gt;句&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;try &lt;/span&gt;{&lt;br/&gt;        ResultSet resultSet = stmt.executeQuery()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;} &lt;span&gt;catch &lt;/span&gt;(SQLException e) {&lt;br/&gt;        e.printStackTrace()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;    &lt;span&gt;//5&lt;/span&gt;&lt;span&gt;、关&lt;/span&gt;&lt;span&gt;闭&lt;/span&gt;&lt;span&gt;操作，步&lt;/span&gt;&lt;span&gt;骤&lt;/span&gt;&lt;span&gt;相反哈&lt;/span&gt;&lt;span&gt;~&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;try &lt;/span&gt;{&lt;br/&gt;        stmt.close()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;conn.close()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;} &lt;span&gt;catch &lt;/span&gt;(SQLException e) {&lt;br/&gt;        e.printStackTrace()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;怎么做&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    我们来看一下底层是怎么处理和交互的。基本流程如下：&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8kINd9hW6JctZMvRNg5GibNvYQySUAKMgmDiaib46wVLhFZuYU1ZA4cGxIRvD4KIIyiaIVNJoCAdUNFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.1336971350613916&quot; data-w=&quot;733&quot;/&gt;&lt;/p&gt;&lt;p&gt;    看着头大？没事，我们先从最简化的版本开始添枝加叶。MyBatis可以用配置文件或者注解形式注入sql。因为配置文件方式可以方便的处理动态SQL(动态SQL就是sql语句里有if else for这些的，可以根据参数的变化最终sql也跟着变化)等优点，用的更为普遍。&lt;/p&gt;&lt;p&gt;    假设现在是2000年，Clinton Begin还没有发起ibatis(mybatis的前身)项目。而apache基金会内部发起了讨论要设计这样一个产品，指派你作为项目负责人。现在思考，你的思路是什么？&lt;/p&gt;&lt;p&gt;    一般思路是先把架构搭建起来，做成一个MVP最小可行性版本，然后再做功能增强。&lt;/p&gt;&lt;p&gt;    从功能最简化方面来看，需要两步：第一步要将sql及所需要的元素以对象的形式输入，第二步是获取到这些信息转换成jdbc信息处理。&lt;/p&gt;&lt;p&gt;    这样拆解后的思路是将sql及所需要的元素拆解成类方法的参数形式，方法本身要做的事情就是将这些参数以jdbc编程需要的形式传给jdbc执行。这里方法内部做的事情是一样的，那就自然而然的想到不用每个类都有一个实现。只要定义好接口，把实现用代理或者上层切面的方式统一处理就可以了。&lt;/p&gt;&lt;p&gt;    根据这个思路，首先要用代理来获取参数。我设计使用方式是Insert、Select等注解里写sql元语句。通过方法参数注入参数。最终返回结果。如下&lt;/p&gt;&lt;pre&gt;&lt;span&gt;public interface &lt;/span&gt;UserMapper {&lt;br/&gt;&lt;/pre&gt;&lt;pre&gt;    &lt;span&gt;@Insert&lt;/span&gt;(&lt;span&gt;&quot;INSERT INTO person(name,age) VALUES (#{name},#{age})&quot;&lt;/span&gt;)&lt;br/&gt;    Integer &lt;span&gt;insertUser&lt;/span&gt;(User user)&lt;span&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;    要实现接口的解析。先建立一个类，里面构造一个代理类，实现类似于SqlSession，所以起名叫YunaSession（yuna是我给经典java学习场景工程https://github.com/xiexiaojing/yuna 起的名字）&lt;/p&gt;&lt;pre&gt;&lt;span&gt;public class &lt;/span&gt;YunaSession {&lt;br/&gt;   &lt;span&gt;public static &lt;/span&gt;Object &lt;span&gt;dealSql&lt;/span&gt;(Class clazz) {&lt;br/&gt;       Class c[] = &lt;span&gt;new &lt;/span&gt;Class[]{clazz}&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;p&gt;&lt;span&gt;       return &lt;/span&gt;Proxy.&lt;span&gt;newProxyInstance&lt;/span&gt;(YunaSession.&lt;span&gt;class&lt;/span&gt;.getClassLoader()&lt;span&gt;, &lt;/span&gt;c&lt;span&gt;,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;new &lt;/span&gt;YunaInvocationHandler())&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;span&gt;   &lt;/span&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;    下面要实现的是代理中YunaInvocationHandler真正要实现的逻辑：将这些参数以jdbc编程需要的形式传给jdbc执行。也就是说把上面【为什么】部分一开始的那段执行jdbc的代码贴进去，将sql和参数的部分做替换。&lt;/p&gt;&lt;p&gt;     我们把关键再贴一遍便于说明问题&lt;/p&gt;&lt;pre&gt;&lt;span&gt;//3&lt;/span&gt;&lt;span&gt;、向数据&lt;/span&gt;&lt;span&gt;库&lt;/span&gt;&lt;span&gt;中插入一条数据&lt;br/&gt;&lt;/span&gt;String sql = &lt;span&gt;&quot;INSERT INTO person(name,age) VALUES (?,?)&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;try &lt;/span&gt;{&lt;br/&gt;    stmt = conn.prepareStatement(sql)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;stmt.setString(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;陈&lt;/span&gt;&lt;span&gt;昆&lt;/span&gt;&lt;span&gt;仑&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;stmt.setInt(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;stmt.executeQuery()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;} &lt;span&gt;catch &lt;/span&gt;(SQLException e) {&lt;br/&gt;    e.printStackTrace()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;/pre&gt;&lt;p&gt;    这里有两个?，而jdbc的预处理语句传入参数的时候要明确的知道第一个参数的类型是什么，如果传过来是对象的话，要知道对应对象的哪个值。这就是为什么接口里的预处理语句传入是&lt;/p&gt;&lt;pre&gt;&lt;span&gt;INSERT INTO person(name,age) VALUES (#{name},#{age})&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;    因为可以通过匹配#{XX}这样的确定都是哪些参数，因为User对象里有定义参数的类型。所以类型和值都确定了。这个就是MappedStatement对象做的事情。以下是用正则表达式匹配+反射来达到解析sql并和对象值做匹配的实现：&lt;/p&gt;&lt;pre&gt;&lt;span&gt;public static void &lt;/span&gt;&lt;span&gt;main&lt;/span&gt;(String[] args) &lt;span&gt;throws &lt;/span&gt;Exception{&lt;br/&gt;    Matcher m= &lt;span&gt;pattern&lt;/span&gt;.matcher(&lt;span&gt;&quot;INSERT INTO person(name,age) VALUES (#{name},#{age})&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;User user1 = &lt;span&gt;new &lt;/span&gt;User()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;user1.setId(&lt;span&gt;1&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;user1.setName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;贾&lt;/span&gt;&lt;span&gt;元春&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;user1.setAge(&lt;span&gt;27&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    int &lt;/span&gt;i=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    while&lt;/span&gt;(m.find()) {&lt;br/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(m.group())&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;String group = m.group()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;String fieldName = group.replace(&lt;span&gt;&quot;#{&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;).replace(&lt;span&gt;&quot;}&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;Field field = User.&lt;span&gt;class&lt;/span&gt;.getDeclaredField(fieldName)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;field.setAccessible(&lt;span&gt;true&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        if&lt;/span&gt;(&lt;span&gt;&quot;java.lang.Integer&quot;&lt;/span&gt;.equals(field.getType().getName())) {&lt;br/&gt;            System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;stmt.setInt(&quot;&lt;/span&gt;+i+&lt;span&gt;&quot;,&quot;&lt;/span&gt;+field.get(user1)+&lt;span&gt;&quot;)&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;} &lt;span&gt;else if&lt;/span&gt;(&lt;span&gt;&quot;java.lang.String&quot;&lt;/span&gt;.equals(field.getType().getName())) {&lt;br/&gt;            System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot; stmt.setString(&quot;&lt;/span&gt;+i+&lt;span&gt;&quot;,&quot;&lt;/span&gt;+field.get(user1)+&lt;span&gt;&quot;)&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;}&lt;br/&gt;        i++&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;运行结果是&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7423469387755102&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicPPxcYCb63l1j0KiaRkeQmuXvCSdnab1V0YLVt2ibCDGIrW6Up2b6QAKJMR0jApnicUVYaOb8l4o6xA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;392&quot;/&gt;&lt;/p&gt;&lt;p&gt;可以看到实现了效果。下面就是和jdbc连接结合起来。&lt;/p&gt;&lt;pre&gt;&lt;span&gt;public class &lt;/span&gt;YunaInvocationHandler &lt;span&gt;implements &lt;/span&gt;InvocationHandler {&lt;br/&gt;    &lt;span&gt;public static final &lt;/span&gt;String &lt;span&gt;DBDRIVER &lt;/span&gt;= &lt;span&gt;&quot;org.xx.mm.mysql.Driver&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    public static final &lt;/span&gt;String &lt;span&gt;DBURL &lt;/span&gt;= &lt;span&gt;&quot;jdbc:mysql://localhost:3306/mydb&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;现&lt;/span&gt;&lt;span&gt;在使用的是&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;数据&lt;/span&gt;&lt;span&gt;库&lt;/span&gt;&lt;span&gt;，是直接&lt;/span&gt;&lt;span&gt;连&lt;/span&gt;&lt;span&gt;接的，所以此&lt;/span&gt;&lt;span&gt;处&lt;/span&gt;&lt;span&gt;必&lt;/span&gt;&lt;span&gt;须&lt;/span&gt;&lt;span&gt;有用&lt;/span&gt;&lt;span&gt;户&lt;/span&gt;&lt;span&gt;名和密&lt;/span&gt;&lt;span&gt;码&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public static final &lt;/span&gt;String &lt;span&gt;USERNAME &lt;/span&gt;= &lt;span&gt;&quot;root&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    public static final &lt;/span&gt;String &lt;span&gt;PASSWORD &lt;/span&gt;= &lt;span&gt;&quot;mysqladmin&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;@Override&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public &lt;/span&gt;Object &lt;span&gt;invoke&lt;/span&gt;(Object proxy&lt;span&gt;, &lt;/span&gt;Method method&lt;span&gt;, &lt;/span&gt;Object[] args) &lt;span&gt;throws &lt;/span&gt;Exception{&lt;br/&gt;        Object result = &lt;span&gt;null;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;Insert &lt;/span&gt;insert = method.getAnnotation(&lt;span&gt;Insert&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        if &lt;/span&gt;(insert != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            String sql = insert.value()[&lt;span&gt;0&lt;/span&gt;]&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;插入&lt;/span&gt;&lt;span&gt;语&lt;/span&gt;&lt;span&gt;句&lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+s)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;YunaSqlDeal yunaSqlDeal = &lt;span&gt;new &lt;/span&gt;YunaSqlDeal()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;yunaSqlDeal.&lt;span&gt;insert&lt;/span&gt;(s&lt;span&gt;, &lt;/span&gt;Arrays.&lt;span&gt;toString&lt;/span&gt;(args))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;//1&lt;/span&gt;&lt;span&gt;、加&lt;/span&gt;&lt;span&gt;载驱动&lt;/span&gt;&lt;span&gt;程序&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;try &lt;/span&gt;{&lt;br/&gt;                Class.&lt;span&gt;forName&lt;/span&gt;(&lt;span&gt;DBDRIVER&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;} &lt;span&gt;catch &lt;/span&gt;(ClassNotFoundException e) {&lt;br/&gt;                e.printStackTrace()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;}&lt;br/&gt;            &lt;span&gt;//2&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;连&lt;/span&gt;&lt;span&gt;接数据&lt;/span&gt;&lt;span&gt;库&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通&lt;/span&gt;&lt;span&gt;过连&lt;/span&gt;&lt;span&gt;接管理器&lt;/span&gt;&lt;span&gt;连&lt;/span&gt;&lt;span&gt;接数据&lt;/span&gt;&lt;span&gt;库&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据&lt;/span&gt;&lt;span&gt;库连&lt;/span&gt;&lt;span&gt;接&lt;/span&gt;&lt;span&gt;对&lt;/span&gt;&lt;span&gt;象&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;Connection conn = &lt;span&gt;null;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            try &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;连&lt;/span&gt;&lt;span&gt;接的&lt;/span&gt;&lt;span&gt;时&lt;/span&gt;&lt;span&gt;候直接&lt;/span&gt;&lt;span&gt;输&lt;/span&gt;&lt;span&gt;入用&lt;/span&gt;&lt;span&gt;户&lt;/span&gt;&lt;span&gt;名和密&lt;/span&gt;&lt;span&gt;码&lt;/span&gt;&lt;span&gt;才可以&lt;/span&gt;&lt;span&gt;连&lt;/span&gt;&lt;span&gt;接&lt;br/&gt;&lt;/span&gt;&lt;span&gt;                &lt;/span&gt;conn = DriverManager.&lt;span&gt;getConnection&lt;/span&gt;(&lt;span&gt;DBURL&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;USERNAME&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;PASSWORD&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;} &lt;span&gt;catch &lt;/span&gt;(SQLException e) {&lt;br/&gt;                e.printStackTrace()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;}&lt;br/&gt;            &lt;span&gt;composeStatement&lt;/span&gt;(sql&lt;span&gt;, &lt;/span&gt;args[&lt;span&gt;0&lt;/span&gt;]&lt;span&gt;, &lt;/span&gt;conn)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;}&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;    &lt;span&gt;private static final &lt;/span&gt;String &lt;span&gt;PATTERN &lt;/span&gt;= &lt;span&gt;&quot;#&lt;/span&gt;&lt;span&gt;\\&lt;/span&gt;&lt;span&gt;{[A-Za-z0-9]+&lt;/span&gt;&lt;span&gt;\\&lt;/span&gt;&lt;span&gt;}&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    private static &lt;/span&gt;Pattern &lt;span&gt;pattern &lt;/span&gt;= Pattern.&lt;span&gt;compile&lt;/span&gt;(&lt;span&gt;&quot;(&quot;&lt;/span&gt;+&lt;span&gt;PATTERN&lt;/span&gt;+&lt;span&gt;&quot;)&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    public static void &lt;/span&gt;&lt;span&gt;composeStatement&lt;/span&gt;(String sql&lt;span&gt;, &lt;/span&gt;Object obj&lt;span&gt;, &lt;/span&gt;Connection conn) &lt;span&gt;throws &lt;/span&gt;Exception{&lt;br/&gt;        PreparedStatement stmt = conn.prepareStatement(sql.replaceAll(&lt;span&gt;PATTERN&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;Matcher m= &lt;span&gt;pattern&lt;/span&gt;.matcher(sql)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        int &lt;/span&gt;i=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        while&lt;/span&gt;(m.find()) {&lt;br/&gt;            System.&lt;span&gt;out&lt;/span&gt;.println(m.group())&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;String group = m.group()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;String fieldName = group.replace(&lt;span&gt;&quot;#{&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;).replace(&lt;span&gt;&quot;}&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;Field field = User.&lt;span&gt;class&lt;/span&gt;.getDeclaredField(fieldName)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;field.setAccessible(&lt;span&gt;true&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            if&lt;/span&gt;(&lt;span&gt;&quot;java.lang.Integer&quot;&lt;/span&gt;.equals(field.getType().getName())) {&lt;br/&gt;                System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;stmt.setInt(&quot;&lt;/span&gt;+i+&lt;span&gt;&quot;,&quot;&lt;/span&gt;+field.get(obj)+&lt;span&gt;&quot;)&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;                &lt;/span&gt;stmt.setInt(i&lt;span&gt;, &lt;/span&gt;Integer.&lt;span&gt;parseInt&lt;/span&gt;(field.get(obj).toString()))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;} &lt;span&gt;else if&lt;/span&gt;(&lt;span&gt;&quot;java.lang.String&quot;&lt;/span&gt;.equals(field.getType().getName())) {&lt;br/&gt;                stmt.setString(i&lt;span&gt;, &lt;/span&gt;field.get(obj).toString())&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;}&lt;br/&gt;            i++&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;}&lt;br/&gt;        stmt.execute()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;stmt.close()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;conn.close()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;    这个实现的是insert的，返回值类型固定，如果是select查询语句，涉及到返回的结果封装成对象。思路也是通过反射，和参数转换步骤差不多，就不贴代码了。&lt;/p&gt;&lt;p&gt;    到此，我们实现了一个简化版的mybatis框架。比贴的架构图简化在少用了很多设计模式的东西，和出于性能考虑重用的东西。mybatis的核心就实现完了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;总结&lt;/p&gt;&lt;p&gt;    本文从mybatis的设计者角度出发，构造了一个简化的mybatis框架。具体可运行的完整代码放到了我的github上，地址：&lt;/p&gt;&lt;p&gt;https://github.com/xiexiaojing/yuna。&lt;/p&gt;&lt;p&gt;    很多原理性的东西看过之后会忘，但是如果真正站在设计者角度实现过一个简化的版本，相信会增强记忆。同时也能和真正的实现做对比，更深层学习技术大牛们的设计精华。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>82857b8beacde9c1566c4da9f55eb124</guid>
<title>高并发高性能服务器是如何实现的</title>
<link>https://toutiao.io/k/e3xq8ad</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;Ctrump才是世界上最好的语言&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3d118c2e31438a47014e34138dfd3c44</guid>
<title>精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期</title>
<link>https://toutiao.io/k/3ininot</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第324期（2020-11-11）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;双十一，买它买它买它！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_324.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;基于 Kubernetes 的云原生批量计算平台&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;对以 Transformer 为基础的序列特征提取器 (Encoder) 和自回归的序列解码器 (Decoder) 做了深度优化&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;技术雷达是 ThoughtWorks 每半年发布一次的技术趋势报告&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;这是德勤第 11 年发布技术趋势年度报告&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;个人经历&lt;/p&gt;
        
        &lt;p&gt;你知道吗？&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验总结&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;适合入门&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;深入探讨&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;基于 Swift 推出的函数响应框架&lt;/p&gt;
        
        &lt;p&gt;使用 JavaScript 来自动化 iOS&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;实践总结&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;细致讲解&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;7年工作经验，技术总监&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 451915 即可&lt;/p&gt;
        
        &lt;p&gt;坚持原创，持续分享技术，包括但不限于：分布式、微服务架构，spring cloud、Dubbo微服务框架，Java核心技术，Redis缓存、Kafka消息队列中间件等。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 450130 即可&lt;/p&gt;
        
        &lt;p&gt;一个工作10年的程序猿，分享技术干货及内心的声音。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 413084 即可&lt;/p&gt;
        
        &lt;p&gt;详解数据结构与算法&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 142771 即可&lt;/p&gt;
        
        &lt;p&gt;Web前端、服务端、小程序、App、学习资料、工具、资讯&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 125297 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=20115&amp;amp;url=http%3A%2F%2Fproduct.dangdang.com%2F29132383.html&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/book_324.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;一个技术总监的忠告&lt;/p&gt;
        
        &lt;p&gt;写作不易&lt;/p&gt;
        
        &lt;p&gt;同理心&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>17094f3fb7e8f7bdf25bccf351722970</guid>
<title>谈一谈 TCP 连接</title>
<link>https://toutiao.io/k/ncz653e</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content&quot;&gt;
      &lt;h1 id=&quot;套接字编程&quot;&gt;套接字编程&lt;/h1&gt;
&lt;h1 id=&quot;什么是套接字&quot;&gt;什么是套接字&lt;/h1&gt;
&lt;p&gt;在因特网中，我们用&lt;code&gt;IP地址&lt;/code&gt;区分不同的主机。而一个主机上往往运行着多个进程，比如qq和微信。我们使用qq发出去的消息，必然是希望对方用qq接收到。那么如何区分一个主机上的不同进程呢？答案是&lt;code&gt;端口号(Port)&lt;/code&gt;。&lt;code&gt;端口号&lt;/code&gt;是一个16比特的数，其大小在&lt;code&gt;0~65535&lt;/code&gt;之间。其中&lt;code&gt;0~1023&lt;/code&gt;范围的端口号是受限制的，被特定的应用层协议使用，比如&lt;code&gt;http&lt;/code&gt;和&lt;code&gt;ftp&lt;/code&gt;。客户端可以选择剩余的端口号来使用。&lt;/p&gt;
&lt;p&gt;当一个新的应用程序（有网络通信的）开发完之后，必须为其分配一个端口号。这样，&lt;code&gt;IP:Port&lt;/code&gt;就可以唯一标识一个主机上的应用程序，并用这个标识进行通信。&lt;u&gt;我们称&lt;code&gt;IP:Port&lt;/code&gt;为套接字。&lt;/u&gt;&lt;/p&gt;
&lt;h2 id=&quot;python实例&quot;&gt;python实例&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkk6tns1y8j30da0dnwex.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;客户端-服务端请求应答模型如上图所示。&lt;/p&gt;
&lt;h3 id=&quot;服务端&quot;&gt;服务端&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;
&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot;&gt; 1
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 2
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 3
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 4
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 5
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 6
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 7
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 8
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 9
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;10
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;11
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;12
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;13
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;14
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;15
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;16
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;socket&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;serverPort&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8090&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;serverSocket&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AF_INET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SOCK_STREAM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;serverSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serverPort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;serverSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;listen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;The server is ready to recieve!&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;connectionSocket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serverSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;accept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connectionSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Get your: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;upper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 将客户端消息转为大写&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;connectionSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;connectionSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;ne&quot;&gt;KeyboardInterrupt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
    
&lt;span class=&quot;n&quot;&gt;serverSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;首先使用&lt;code&gt;socket&lt;/code&gt;创建一个TCP嵌套字，其中&lt;code&gt;SOCK_STREAM&lt;/code&gt;用于指示这是一个TCP连接而非UDP连接；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bind&lt;/code&gt;绑定主机名和端口号；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listen&lt;/code&gt;令服务器监听&lt;code&gt;8090&lt;/code&gt;端口来自客户端的TCP连接请求。其中的参数&lt;code&gt;1&lt;/code&gt;表示请求的最大连接数为1；&lt;/li&gt;
&lt;li&gt;最后在&lt;code&gt;while&lt;/code&gt;循环中，使用&lt;code&gt;accept()&lt;/code&gt;方法。接收到来自客户端的请求之后会重新分配一个名为&lt;code&gt;connectionSocket&lt;/code&gt;的新的套接字，给这个特定的用户使用。这样可以让一个套接字专门用来接收请求，生成的连接套接字用于不同客户端的通信，防止欢迎套接字被一个请求占用之后，其他请求无法再响应了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkk6uepevyj30ki0ke1hc.jpg&quot; alt=&quot;image-20201109160840609&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其中的&lt;code&gt;try&lt;/code&gt;和&lt;code&gt;except&lt;/code&gt;可以先不用管，这个是为了中断程序时可以自动释放端口号。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;客户端&quot;&gt;客户端&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;
&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot;&gt; 1
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 2
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 3
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 4
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 5
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 6
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 7
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 8
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 9
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;10
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;socket&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;serverName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;127.0.0.1&#x27;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;serverPort&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8090&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;clientSocket&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AF_INET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SOCK_STREAM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;clientSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serverName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serverPort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;hello world!&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;clientSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 发送&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clientSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 接受响应&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;Data from server ==&amp;gt;&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;clientSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;首先使用&lt;code&gt;socket&lt;/code&gt;创建一个TCP嵌套字，与服务端一样；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;connect&lt;/code&gt;与服务端建立连接，发生了三次握手的过程；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;运行程序&quot;&gt;运行程序&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;
&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot;&gt;1
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c1&quot;&gt;# server&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;The&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ready&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recieve&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;
&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot;&gt;1
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c1&quot;&gt;# client&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Get&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;your&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HELLO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WORLD&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&quot;wireshark抓包&quot;&gt;wireshark抓包&lt;/h2&gt;
&lt;p&gt;尝试用&lt;code&gt;wireshark&lt;/code&gt;抓包看一下我们程序运行的过程。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkk6zoh8wdj32800la10t.jpg&quot; alt=&quot;截屏2020-11-09 下午4.23.42&quot;/&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;客户端默认工作在&lt;code&gt;51171&lt;/code&gt;端口，服务端监听&lt;code&gt;8090&lt;/code&gt;端口。&lt;code&gt;1～3&lt;/code&gt;是三次握手的过程，&lt;code&gt;8/10/11/12&lt;/code&gt;是四次挥手的过程。中间是数据传输与应答过程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第5个包中，客户端发送了&lt;code&gt;hello world!&lt;/code&gt;；第6个包是服务端发送&lt;code&gt;ACK&lt;/code&gt;；第7个包是服务端发送&lt;code&gt;Data from server ==&amp;gt; Get your: HELLO WORLD!&lt;/code&gt;；第9个包是客户端发送的&lt;code&gt;ACK&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从抓包过程中我们可以看出，仅仅是简单地传输两个字符串，就需要这个多次&lt;code&gt;TCP&lt;/code&gt;包的传输。这些传输到底是什么含义呢？&lt;/p&gt;
&lt;h1 id=&quot;连接与可靠&quot;&gt;连接与可靠&lt;/h1&gt;
&lt;p&gt;众所周知，&lt;code&gt;TCP&lt;/code&gt;是面向连接的可靠的传输协议。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向连接指的是在传输实体数据之前必须建立连接：上面的&lt;code&gt;connect&lt;/code&gt;就是建立连接的过程；&lt;/li&gt;
&lt;li&gt;可靠即能保证接收到的数据是发送方想发送的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么会发生不可靠的传输呢？主要有两种情况，一种是比特差错；另一种是丢包。&lt;/p&gt;
&lt;h2 id=&quot;比特差错&quot;&gt;比特差错&lt;/h2&gt;
&lt;p&gt;根据香农理论，当通过信道的信号速率超过某个值时，信号的误码率会显著提高，也就是比特差错数会显著提高。同时由于噪声的影响也会使得接收到判断发送端发送的是1还是0的时候发生错误。&lt;/p&gt;
&lt;h2 id=&quot;丢包&quot;&gt;丢包&lt;/h2&gt;
&lt;p&gt;从北京往上海发一个包，中间会经过路由器和交换机中转。大多数分组交换剂在输入端使用&lt;strong&gt;存储转发传输&lt;/strong&gt;：&lt;u&gt;也就是将整个包都接受完了之后，才会向输出链路传输该分组。&lt;/u&gt;分组交换机的每条链路具有一个输出缓存，用于存储准备发往该链路的分组。由于发送速率是有限的，所以如果包到达的速率要大于发送的速率的话，就必须在这个缓存区等待。而缓存区大小往往是有限的，所以超过的部分可能会被丢弃，从而发送&lt;strong&gt;丢包&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;还有一种是当发包的速度过快了，服务器应用程序没来得及消费这些东西，而缓存区也满了，那么就会丢弃这些包。&lt;/p&gt;
&lt;h1 id=&quot;如何保证可靠&quot;&gt;如何保证可靠&lt;/h1&gt;
&lt;h2 id=&quot;比特差错-1&quot;&gt;比特差错&lt;/h2&gt;
&lt;p&gt;首先看一下TCP报文格式：&lt;br/&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkk70q2r44j30on0ew74h.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的&lt;code&gt;检验和&lt;/code&gt;用于检验比特差错。目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到校验和有差错，则TCP段会被直接丢弃。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发送方&lt;/strong&gt;计算TCP的检验和的计算方法如下：&lt;/p&gt;
&lt;ol start=&quot;0&quot;&gt;
&lt;li&gt;
&lt;p&gt;将检验和字段设为0；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加12字节的伪头部，包括：源IP地址、目的IP地址、协议版本号（一般为6）和16位的TCP总长度（这个长度是计算获得的，不是直接有的字段）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对所有16比特字求和，求和时遇到的任何溢出都将被&lt;u&gt;回卷&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对和进行反码运算。计算的结果填到检验和字段中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;回卷就是超过16bit的部分重新加到后16bit上。比如0x36666，回卷之后就是0x3 + 0x6666 = 0x6669。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;接收方&lt;/strong&gt;检验&lt;code&gt;checksum&lt;/code&gt;的方式如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;添加12字节的伪头部，包括：源IP地址、目的IP地址、协议版本号和16位的TCP总长度。&lt;/li&gt;
&lt;li&gt;对所有16比特字求和，求和时遇到的任何溢出都将被&lt;u&gt;回卷&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;判断结果是否为&lt;code&gt;0xFFFF&lt;/code&gt;，如果不是则出错。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用&lt;code&gt;wireshark&lt;/code&gt;抓包时可以发现，抓包之后的&lt;code&gt;checksum&lt;/code&gt;都是错误的：&lt;code&gt;[Header checksum status: Unverified]&lt;/code&gt;。手动进行求和验证发现也是无法通过的。这是为什么呢？&lt;/p&gt;
&lt;p&gt;原来是因为为了减少CPU的开销，检验和的计算会交给硬件（网卡）而不是&lt;code&gt;TCP&lt;/code&gt;来计算。而抓包时还没有到网卡这一层，所以系统会在&lt;code&gt;checksum&lt;/code&gt;这里随机填一些数字，而不是真正的检验和。在windows电脑中可以关闭网卡检验和再尝试。（mac中我还没有找到设置的方法，求指导！）&lt;/p&gt;
&lt;p&gt;&lt;u&gt;但是需要注意的是！检验和并不是只有TCP才有的，UDP和IP计算都会有这个步骤。&lt;/u&gt;&lt;/p&gt;
&lt;h2 id=&quot;丢包-1&quot;&gt;丢包&lt;/h2&gt;
&lt;p&gt;客户端发了几个包过去，客户端和服务端如何能保证是不丢失的？保证不丢包的前提是，&lt;u&gt;如果发生了丢包，他们必须是能够知道的&lt;/u&gt;，否则就没法进行重传。&lt;/p&gt;
&lt;p&gt;很容易想到的一种方法是&lt;strong&gt;应答&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Client&lt;/code&gt;发送一个包之后，等待&lt;code&gt;Server&lt;/code&gt;响应。例如&lt;code&gt;ACK=1&lt;/code&gt;表示我收到了完整的包；&lt;code&gt;ACK=0&lt;/code&gt;表示我收到了受损的包，请重发一次。如果&lt;code&gt;Client&lt;/code&gt;在等待一定时常之后没有收到&lt;code&gt;Server&lt;/code&gt;响应，就认为包是丢失的，开始重传。&lt;/p&gt;
&lt;p&gt;这种方式有一些弊端：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何保证收到的&lt;code&gt;ACK&lt;/code&gt;在途中不会因为噪声干扰发生变化；&lt;/li&gt;
&lt;li&gt;因为客户端都等待服务端的响应，所以在这个过程中无法发送其他包，效率是低下的。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;Server&lt;/code&gt;接收到的是完整的包，但是&lt;code&gt;ACK&lt;/code&gt;在响应过程中丢失了，客户端会在一定时间之后重新发送一个包。服务端无法区别这个是重传的包还是新的包。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;既然无法区分包，那不如就给所有包标上序号吧！这个就是TCP报文头中的&lt;code&gt;序号&lt;/code&gt;和&lt;code&gt;确认号&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;由于TCP是一个全双工的协议，所以客户端和服务端都是可以相互发送报文的。序号用于表示自己这个报文的标号，而确认号表示我希望你能给我发哪个报文（间接表明了你发过来的报文有哪些是安全到达的）。&lt;/p&gt;
&lt;p&gt;这是TCP报文首部中最重要的两个字段，需要好好理解一下！&lt;/p&gt;
&lt;h3 id=&quot;序号与确认号&quot;&gt;序号与确认号&lt;/h3&gt;
&lt;p&gt;TCP把数据看成是一个无结构的、有序的字节流。序号并不是对报文进行编号，而是对字节流进行编号。&lt;/p&gt;
&lt;p&gt;例如主机A的一个进程想通过TCP连接向主机B的一个进程发送一个数据流。这个数据流的大小是500 000字节，一个TCP报文能放的数据大小是1000个字节。那么这个数据流将被拆分成$500000/1000 = 500$个包，第一个报文分配序号&lt;code&gt;0&lt;/code&gt;，第二个报文分配序号&lt;code&gt;1000&lt;/code&gt;，以此类推。&lt;/p&gt;
&lt;p&gt;主机A填充进报文的确认号是主机A希望从主机B收到的下一个字节的序号。例如主机A已经收到了&lt;code&gt;0~999&lt;/code&gt;的所有字节，那么它下一个希望收到的序号是&lt;code&gt;1000&lt;/code&gt;，则A发送的TCP包的确认号是&lt;code&gt;1000&lt;/code&gt;。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkk71mhau1j30ms0p67wh.jpg&quot; alt=&quot;截屏2020-11-10 下午1.52.18&quot;/&gt;  
&lt;p&gt;这样发送方可以直接通过应答方发送的确认号就可以知道自己之前发送报文的确认情况。如果经过一定时间没有收到应答方的回答的话，就进行重传。由于重传时&lt;code&gt;Seq&lt;/code&gt;是不变的，所以应答方可以通过它来判断是否是重复收到同一个报文了。&lt;/p&gt;
&lt;p&gt;但一次只发一个报文终究是很费时的，所以会一次性传多个报文。虽然发送报文是按序的，但是由于网络链路的影响，接受报文可能不是有序的，甚至可能发生中间的丢包。那么怎么办呢？&lt;/p&gt;

&lt;h3 id=&quot;1-退回n步-go-back-n&quot;&gt;(1) 退回N步 Go-Back-N&lt;/h3&gt;
&lt;p&gt;可以直接在《计算机网络：自顶向下方法》的配套实验网站中看演示动画：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/go-back-n-protocol/index.html&quot;&gt;https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/go-back-n-protocol/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在GBN算法中，所有分组必须有序到达，否则会被丢弃。也就是接收方丢弃所有失序分组。而当发送方没有收到分组&lt;code&gt;n&lt;/code&gt;的应答，但是却收到了&lt;code&gt;n+1, n+2&lt;/code&gt;的应答时，在等一定时间之后，&lt;code&gt;n, n+1, n+2&lt;/code&gt;都会被重发。&lt;/p&gt;
&lt;p&gt;这种方法的优点是，在接受侧不需要缓存任何失序分组；发送侧需要维护一个发送窗口。&lt;/p&gt;
&lt;p&gt;但是由于一些明明完整到达的报文，由于顺序不对会被丢弃，需要重发，这个会影响性能。尤其是当窗口长度和带宽时延都很大时，可能会需要大量重传分组。而很多分组其实没必要重传。&lt;/p&gt;
&lt;h3 id=&quot;2-选择重传&quot;&gt;(2) 选择重传&lt;/h3&gt;
&lt;p&gt;演示地址：
&lt;a href=&quot;https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html&quot;&gt;https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里需要发送方和接收方都维护一个窗口。对于发送方来说，只有当窗口内连续的前&lt;code&gt;x&lt;/code&gt;个包都收到了回应，才会把窗口推进&lt;code&gt;x&lt;/code&gt;。一定时间之后如果还没收到，则重发。&lt;/p&gt;
&lt;h3 id=&quot;tcp的重传&quot;&gt;TCP的重传&lt;/h3&gt;
&lt;p&gt;TCP报文的重传结合了这两种方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先TCP确认是&lt;u&gt;累计式的，并不会对正确接受但是失序的报文逐个确认&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;比如说发送了&lt;code&gt;1, 2, ... n, n+1,n+2&lt;/code&gt;几个包，但是接收方只收到了&lt;code&gt;1, 2, ..., n+1,n+2&lt;/code&gt;，接收方会反复回应&lt;code&gt;ACK=n&lt;/code&gt;，而不会对之后接受的包进行回应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但是TCP提供了缓存机制。发送方接收到回应&lt;code&gt;ACK=n&lt;/code&gt;之后只会重传&lt;code&gt;n&lt;/code&gt;包，而不会重传之后的包。不过发送方不是收到一个&lt;code&gt;ACK=n&lt;/code&gt;就会重发的，它会在收到3个冗余&lt;code&gt;ACK&lt;/code&gt;之后才会执行快速重传。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkk73kz657j30jw0se4qp.jpg&quot; alt=&quot;image-20201110150742521&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于（1）的特性，所以TCP确认并不需要对&lt;code&gt;1, 2, ..., n-1&lt;/code&gt;都进行，只要收到了&lt;code&gt;n&lt;/code&gt;的确认，就可以认为之前的包都有序送达了！这样即便&lt;code&gt;ACK=100&lt;/code&gt;丢失了，也不会有影响。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkk7489ai8j30iu0oq1kx.jpg&quot; alt=&quot;image-20201110144849613&quot;/&gt;&lt;/p&gt;
&lt;center&gt;RFC 5681 产生ACK的建议&lt;/center&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事件&lt;/th&gt;
&lt;th&gt;TCP接收方动作&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1~n都到达并ACK了; 现在到了n+1&lt;/td&gt;
&lt;td&gt;延迟ACK。对n+2最多等待500ms，如果没到达则发送一个ACK确认n+1。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1~n-1都到达并确认了，n到达还没确认；现在到了n+1&lt;/td&gt;
&lt;td&gt;立即发送单个累计ACK=n+2，同时确认n和n+1。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1~n-1都到达并确认了，n没到达；现在到了n+1&lt;/td&gt;
&lt;td&gt;立即发送冗余ACK=n&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;能部分或完全填充接受数据间隔的报文段到达&lt;/td&gt;
&lt;td&gt;如果该报文段填的是对早的空的段，立即发送ACK&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;连接与断开的过程&quot;&gt;连接与断开的过程&lt;/h2&gt;
&lt;p&gt;上述是建立完TCP连接之后报文的传输过程。TCP中另一个很重要的是&lt;u&gt;建立连接与断开连接&lt;/u&gt;的过程。其实这个本质和普通的报文传输是一样的，只不过会用一些特殊的位来表示我们正在建立/断开连接。&lt;/p&gt;
&lt;h3 id=&quot;三次握手建立连接&quot;&gt;三次握手🤝建立连接&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;客户端的TCP先向服务器端的TCP发送一个特殊的TCP报文段，该报文段不包含应用层数据，但是将报文段的首部&lt;code&gt;SYN&lt;/code&gt;位设置为&lt;code&gt;1&lt;/code&gt;。另外客户端会随机选择生成一个&lt;code&gt;client_isn&lt;/code&gt;放入起始的TCP序号中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器主机收到包含&lt;code&gt;SYN=1&lt;/code&gt;的报文段之后，就知道有客户端想要建立连接了。所以服务器会为该TCP连接分配TCP缓存和变量。然后返回一个响应，表示允许建立连接。这个允许连接的报文也不包含应用层数据，但是有&lt;code&gt;SYN=1&lt;/code&gt;，&lt;code&gt;序号=server_isn&lt;/code&gt;，&lt;code&gt;确认号=client_isn+1&lt;/code&gt;，&lt;code&gt;ACK=1&lt;/code&gt;。（这里虽然没有应用层的数据，但由于它是建立连接的报文，所以确认号是在接收的序号上+1的，这点和单纯的数据传输不太一样）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端接收到服务器的响应之后，客户端也为该连接分配缓存和变量。然后客户端向服务端发送另一个报文：&lt;code&gt;SYN=0&lt;/code&gt;，&lt;code&gt;序号=client_isn+1&lt;/code&gt;，&lt;code&gt;确认号=server_isn+1&lt;/code&gt;。&lt;u&gt;在这个阶段，可以在报文段负载中携带客户端到服务器的数据了！&lt;/u&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;之后通信的所有报文段&lt;code&gt;SYN=0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkk74tbkvwj30o20nk4qp.jpg&quot; alt=&quot;image-20201110161231022&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;实际上在第二步中，服务器并不会直接为这个TCP连接分配缓存，因为有可能会有黑客不断发送第一步的连接请求，但是不发送第三步的报文，这样会导致服务器建立了大量TCP缓存，但是却都没有用！这个被称为&lt;strong&gt;SYN攻击&lt;/strong&gt;！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;确认客户端和服务端都有接收和发送的能力。&lt;/li&gt;
&lt;li&gt;如果只有2次握手：万一服务端的应答在过程中丢失了，客户端不会和服务端进行连接，但是服务端会建立连接，这样会白白消耗资源。之后如果客户端再次重发请求，服务器就会认为这是两个TCP连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;四次挥手断开连接&quot;&gt;四次挥手🙋断开连接&lt;/h3&gt;
&lt;p&gt;假设是客户端主动要求关闭连接的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端进程发出一个报文，其中&lt;code&gt;FIN=1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;服务器接收到报文之后，发送一个确认报文。&lt;/li&gt;
&lt;li&gt;服务器发送未传输完的数据。&lt;/li&gt;
&lt;li&gt;服务器发送自己的终止报文，有&lt;code&gt;FIN=1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;服务器接收到之后对其进行确认，并定时等待一段时间之后关闭连接。
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkk753ihbkj30sm0y8x6p.jpg&quot; alt=&quot;image-20201110161653631&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ol&gt;
&lt;li&gt;客户端发起关闭请求时，它的数据必然是已经发送完毕的。但是服务器的数据可能被发送完毕，所以需要等服务器发送完了之后才会再给一个&lt;code&gt;FIN=1&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;ol&gt;
&lt;li&gt;避免客户端发送的ACK没有到达服务端，这样服务端没有接收到ACK会重发FIN且不会释放资源。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;总结一下&quot;&gt;总结一下&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkk75g9ni8j30uo0rsqv5.jpg&quot; alt=&quot;image-20201110161905182&quot;/&gt;&lt;/p&gt;
&lt;h1 id=&quot;回到wireshark抓包&quot;&gt;回到wireshark抓包&lt;/h1&gt;
&lt;p&gt;最后会到之前抓包的结果看一看。中括号内的是首部中的位。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;包序号&lt;/th&gt;
&lt;th&gt;方向&lt;/th&gt;
&lt;th&gt;包内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;51171 ➡️  8090&lt;/td&gt;
&lt;td&gt;[SYN], Seq=0, Len=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;8090 ➡️  51171&lt;/td&gt;
&lt;td&gt;[SYN, ACK], Seq=0, Ack=1, Len=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;51171 ➡️  8090&lt;/td&gt;
&lt;td&gt;[ACK], Seq=1, Ack=1, Len=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;51171 ➡️  8090&lt;/td&gt;
&lt;td&gt;[PSH, ACK], Seq=1, Ack=1, Len=12（Data = hello world!）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;8090 ➡️  51171&lt;/td&gt;
&lt;td&gt;[ACK], Seq=1, Ack=13, Len=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8090 ➡️  51171&lt;/td&gt;
&lt;td&gt;[PSH, ACK], Seq=1, Ack=13, Len=22（Data = Get your: HELLO WORLD!）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;8090 ➡️  51171&lt;/td&gt;
&lt;td&gt;[FIN, ACK], Seq=23, Ack=13, Len=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;51171 ➡️  8090&lt;/td&gt;
&lt;td&gt;[ACK], Seq=13, Ack=23, Len=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;51171 ➡️  8090&lt;/td&gt;
&lt;td&gt;[ACK], Seq=13, Ack=24, Len=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;51171 ➡️  8090&lt;/td&gt;
&lt;td&gt;[Fin, ACK], Seq=13, Ack=24, Len=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;8090 ➡️  51171&lt;/td&gt;
&lt;td&gt;[Ack], Seq=24, Ack=14, Len=0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;包1中的&lt;code&gt;Seq&lt;/code&gt;实际上是随机生成的数字&lt;code&gt;368303858&lt;/code&gt;，但后面都用相对表示，所以直接认为=0；&lt;/p&gt;
&lt;p&gt;包2中的&lt;code&gt;Ack&lt;/code&gt;也是同理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;挥手流程梳理如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkk76fn6b1j30o40e2gnu.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h1 id=&quot;预告&quot;&gt;预告&lt;/h1&gt;
&lt;p&gt;篇幅比较长了，就先写到这里。我是一名正在自学计算机的大四学生，会在我的博客中记录我的学习之路，欢迎在《开发者头条》中订阅我的独家号「彬Goh的Coding之路」。一起进步吧！&lt;/p&gt;
    &lt;/div&gt;

    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2e78fd9e8b58d1e1d0b059961635c012</guid>
<title>漫画面试回答 kafka 为何如此之快</title>
<link>https://toutiao.io/k/jeuqdr2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>