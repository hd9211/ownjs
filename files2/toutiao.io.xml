<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2803f093afb1d608205eafe2f5d8a363</guid>
<title>如何通过项目复盘来加速个人成长</title>
<link>https://toutiao.io/k/ys08f63</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样工作年限的人，能力可能差别很大。工作 5 年的前端，有的只会做简单的任务，有的已经可以独当一面了。导致这种情况的原因有很多，本质是成长的速度不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复盘可以加速个人成长。本文主要介绍，个人通过项目复盘来加速成长的方法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是复盘&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;复盘本是围棋术语，意指对弈者在下完一盘棋后，把对弈过程重新摆一遍，寻找改进点。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复盘就是从经验中学习。做得不好的地方，避免下次再犯。做得好的地方，争取下次能做得更好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议在做完项目的一周内做复盘。这时，对项目的感触是最新鲜的~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;复盘的步骤&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做好复盘，主要分为 5 步：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;定主题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;做回顾&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;找根因&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;定策略&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;跟踪落地&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第 1 步: 定主题&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定主题就是确定复盘的主题。复盘前，如果没确定主题，想法有很多，会有无从下手的感觉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复盘的主题可以从项目特点来考虑。项目的功能比较复杂，主题可以是: 复杂业务的代码组织。项目大量用了某新技术，主题可以是: xx技术分析。项目有很多跨部门沟通的内容，主题可以是：如何做好跨部门沟通。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复盘的主题可以从项目的结果来考虑。主题可以是：成功原因分析，失败原因分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复盘的主题可以从个人的职位和发展方向来考虑。专注代码质量的同学，主题可以是：降低代码的复杂度。专注性能的同学，主题可以是：渲染性能优化分析。项目 Leader 主题可以是：提升开发体验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要注意的是，主题不要太大。主题越大，考虑的内容就越多，容易没有重点，也越难写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果觉得没法用一个主题描述一次复盘。可以有多个主题。当然，如果实在不知道起什么主题，那就随缘吧XD&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第 2 步: 做回顾&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做回顾就是仔细回顾做项目的整个过程。在回顾的过程中，结合主题，列出做的好的和不好的内容。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;举个例子&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6244784422809457&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mEakJnD74m9OaaDmwM9jKHcTw4vwZKtb8mXfoJgyaGicwCZZRiaRDLlibDeRt9jgYjo2hkQuojTnD66VeuX9Czf3Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1438&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图是我最近做了一个多月的任务：项目集的计划页。页面显示了任务和里程碑的甘特图。用户在这个页面上，可以对任务和里程碑进行新建，编辑，排序，删除等操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技术栈是 React。组件基本都是函数组件。管理多组件间共享的数据用的是 React 自带的 &lt;span&gt;Context API&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复盘的主题是：&lt;strong&gt;渲染性能优化分析&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做的好的部分：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对大部分组件都用了 &lt;code&gt;React.memo&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;函数属性基本都用了 &lt;code&gt;useCallback&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在必要的地方用了 &lt;code&gt;useMemo&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做的不好的地方：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;有 2 个比较大的 Context。导致用到这两个 Context 的组件有时会产生不必要的渲染。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;甘特图性能不好。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第 3 步: 找根因&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;找根因就是产生结果的的根本原因。找根因可以用&lt;span&gt;5why分析法&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;5why分析法，又称“5问法”，也就是对一个问题点连续以5个“为什么”来自问，以追究其根本原因。虽为5个为什么，但使用时不限定只做“5次为什么的探讨”，主要是必须找到根本原因为止，有时可能只要几次，有时也许要十几次，如古话所言：打破砂锅问到底。5why法的关键所在：鼓励解决问题的人要努力避开主观或自负的假设和逻辑陷阱，从结果着手，沿着因果关系链条，顺藤摸瓜，直至找出原有问题的根本原因。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们用 5why分析法 来分析：甘特图性能不好。&lt;br/&gt;&lt;img data-ratio=&quot;3.8434343434343434&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mEakJnD74m9OaaDmwM9jKHcTw4vwZKtbDUdLSiakwTZ9EERJ18RjibghlsHwt4CImCtOHhguKUxUQDPeoJqWZ1xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;198&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果根因有很多个，可以用&lt;span&gt;鱼骨图&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;来分析。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;鱼骨图是一种发现问题“根本原因”的方法，它也可以称之为“Ishikawa”或者“因果图”。其特点是简洁实用，深入直观。它看上去有些像鱼骨，问题或缺陷（即后果）标在“鱼头”处。在鱼骨上长出鱼刺，上面按出现机会多寡列出产生问题的可能原因，有助于说明各个原因是如何影响后果的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如:&lt;img data-ratio=&quot;0.4536082474226804&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mEakJnD74m9OaaDmwM9jKHcTw4vwZKtbz4biblrlN234nrK9WeThNjxM9znyzvKB5dVhyxjnp6j95vnxWHKkAfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;970&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第 4 步: 定策略&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定策略就是定改进的策略。可以用海星复盘图来定策略。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9660326086956522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mEakJnD74m9OaaDmwM9jKHcTw4vwZKtbzhhQhDzL0mcIeeoAczXdsodLO0YtywReevUwSRNYDL80fUSdQmqicAA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1472&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;海星复盘图将策略分为5类：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Stop — 指那些非但没有给团队或客户带来价值，反而带来浪费的活动。&lt;br/&gt;Less — 指团队过去做的一些活动，但并没带来更多收益，团队以后需要花费更少的精力做这些事情。&lt;br/&gt;Keep — 指团队想要继续保留的良好实践或活动。&lt;br/&gt;More — 指那些团队应该更聚焦或更经常进行的活动。&lt;br/&gt;Start — 指想引入到团队中的活动或想法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细介绍见: &lt;span&gt;如何做好项目复盘 - 海星复盘图&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第 5 步: 跟踪落地&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跟踪落地就是具体实施改进的策略，并评估结果。制定实施计划和评估结果可以使用 &lt;span&gt;SMART 原则&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后推荐一本关于复盘的书：&lt;span&gt;《复盘+：把经验转化为能力（第2版）》&lt;/span&gt;&lt;sup&gt;[6]：&lt;/sup&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;随着环境日趋多变、不确定、复杂、模糊，无论是个人还是组织，都需要更快更有效地进行创新应变、提升能力。复盘作为一种从经验中学习的结构化方法，满足了快速学习的需求，也是有效进行知识萃取与共享的机制。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一起来做项目复盘吧~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Context API: &lt;em&gt;https://reactjs.org/docs/context.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;5why分析法: &lt;em&gt;https://baike.baidu.com/item/5why%E5%88%86%E6%9E%90%E6%B3%95&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;鱼骨图: &lt;em&gt;https://baike.baidu.com/item/%E9%B1%BC%E9%AA%A8%E5%9B%BE/6514245&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;如何做好项目复盘 - 海星复盘图: &lt;em&gt;https://juejin.cn/post/6844903817260040199&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;SMART 原则: &lt;em&gt;https://baike.baidu.com/item/SMART%E5%8E%9F%E5%88%99/8575850&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;《复盘+：把经验转化为能力（第2版）》: &lt;em&gt;https://book.douban.com/subject/26838511/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7b19ccbb6acdb62c991d7ab1ce59d8f6</guid>
<title>技术人才的纵横发展</title>
<link>https://toutiao.io/k/o31tkm7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;近期碰到一些工程师对职业发展产生很多困惑，诸如:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;我现在做的工作好像离技术越来越远了。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每天都在垒业务逻辑，技术上没有任何成长，以后是不是会被淘汰掉？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每天都在撸代码造轮子，老板总觉得我们不关心业务，也不知道我们在做什么。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写那么多年代码，是不是现在要转管理才不会被市场淘汰？&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;首先，工程师可以粗线条的分为工程和产品两个方向，横向发展较多的工程师可以培养为研发leader，纵向发展较多的可以成为技术专家。没有孰优孰劣，个人定位而已，就跟你想做一个销售还是技术一样的问题。 &lt;/p&gt;&lt;h2&gt;工程方向工程师&lt;/h2&gt;&lt;p&gt;一般都属于“基础架构”和“服务平台”这种团队，下面这三项覆盖了这个团队leader或者高工主要承担的工作范围，只是各项权重有些细小差异，现阶段哪项比较薄弱自然权重就高一些。 &lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;保障业务稳定运行，无线上故障，无重大安全问题。一些量化指标比如核心服务99.99%，非核心服务99.9%，服务接口延时不超过300ms，线上故障回滚不超过120秒，服务报警延时不超过5秒等等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;分阶段持续量化和优化整体业务的运维成本，主要包括服务器、带宽、第三方付费服务等。持续提升研发效率，降低研发人力成本。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;开发和维护所有业务通用支持的核心系统、中间件以及核心服务，核心系统、中间件有MQ、Cache、RPC框架、持久化存储DB和NoSQL以及分布式存储、报警监控系统等等，核心服务比如发号器、各种简化业务开发复杂度的proxy、passport系统、反作弊系统等从业务开发下沉到基础架构的服务。至于开源还是自研可根据业务需求和公司技术发展阶段来调整。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这类工程师核心能力是技术挑战、技术深度以及系统设计能力。&lt;/p&gt;&lt;h2&gt;产品方向工程师&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;明显提升产品DAU、用户留存、用户使用时长等功能需求开发，持续优化用户体验&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;广告变现、会员业务、支付充值业务等提升公司收入的功能需求开发&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;提升运营效率的运营后台系统、时效性商业运营活动等功能需求开发&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这类工程师核心能力是产品和数据敏感、熟悉业务、善于协调和使用内部资源。&lt;/p&gt;&lt;p&gt;背景讲完了，可以看到，工程和产品两个方向的工作目标以及具体产出差别较大。给自己明确定位清楚后，就要持续培养和发展该方向的核心能力。 &lt;/p&gt;&lt;h2&gt;纠正几个误区，让工程师更加“健康自信”的发展。&lt;/h2&gt;&lt;h3&gt;单方面追求自己的技术深度，公司的业务发展跟我关系不大&lt;/h3&gt;&lt;p&gt;某个领域的技术深度基本上是和公司业务发展成正比的，该领域的专精人才一般都在业务排名top3的公司里面。反过来说，公司在自己核心技术上的投入肯定是最大的，也容易吸引和培养该领域的专精人才。高速发展的业务会给技术带来巨大的挑战，这些挑战也会催生出一批高端的技术人才，一般来讲，业务很一般的公司，工程师的技术能力也会大打折扣。所以我们的技术规划要跟着业务走，去解决业务的痛点，技术能适应甚至推动业务发展，受益的是我们工程师自己。 &lt;/p&gt;&lt;h3&gt;技术选型跟公司业务关系不大，哪个技术现在流行选哪个&lt;/h3&gt;&lt;p&gt;好的架构师都是可以做出复杂场景下最优解的决策人才，就跟分布式领域中的CAP理论一样，无非是看你选择什么放弃什么。现实中往往选择了性能就放弃了部分安全，拿空间复杂度换时间复杂度等等，技术选型也是如此，要根据目前业务的规模和阶段来看，适合自己业务的才是最好的。有一个公认的原则：如果不是一些特殊的场景，尽量选择自身研发团队熟悉的，有该领域专精的人才更好。技术挑战很大的团队都知道，开源社区一般碰不到的问题自己都会碰到，很大程度上都需要自己投入人力解决。所以，团队已有这方面专家或者早期就开始培养这方面技术专家，是团队leader很重要的一个工作。 &lt;/p&gt;&lt;h3&gt;基础架构服务于业务，业务发展好，非技术背景的老板看不到基础架构的价值&lt;/h3&gt;&lt;p&gt;基础架构的高工或者leader有责任和义务做好研发工作的规划和成果阶段性汇报，对齐整体业务的产品运营节奏，提前规划和解决业务的技术痛点，加上上述的三方面工程方向KPI整体产出，让老板们和产品、运营、商业化、人力资源负责人感受到这部分工作的影响力，互通有无。非技术背景的老板不代表不认可技术价值，研发负责人要做好充分的向上沟通。 &lt;/p&gt;&lt;h3&gt;工程师岁数到了30多岁以后要转管理&lt;/h3&gt;&lt;p&gt;阿里巴巴的一位HR高管说过：把研发人力分为P和M两个晋升序列并且设定两者的职级对应关系，是为了分别满足专家人才和技术管理人才的个人发展预期，现在基本所有大型互联网公司的职级体系都是这么设定的。资深的研发工程师虽然不是综合性的管理人才，但不影响自己对公司对业务的贡献，只要做到那20%的绩优人才就可以。有些公司将工程师细分为工程方向和产品方向，更加细化了工程师的预期管理和晋升方向，所以技术深度和技术管理无优劣，关键是不管横向还是纵向发展，都要力求进入那群人中最优秀的TOP10%。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7e9cf0027e543d686869492f128bbb5a</guid>
<title>无需刷新即可检测 JavaScript 中的 URL 更改</title>
<link>https://toutiao.io/k/nigs494</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;Post-body&quot;&gt;
                    &lt;p&gt;如何为 &lt;a href=&quot;https://nicelinks.site/post/604795465f9af714fe21dcbc&quot; rel=&quot; nofollow ugc&quot;&gt;Flarum&lt;/a&gt; 论坛添加 &lt;a href=&quot;https://github.com/francoischalifour/medium-zoom&quot; rel=&quot; nofollow ugc&quot;&gt;medium-zoom&lt;/a&gt;（用于缩放图像的 JavaScript 库，如 Medium）呢？本篇文章，在于分析借助 &lt;strong&gt;&lt;code&gt;MutationObserver&lt;/code&gt;&lt;/strong&gt; 函数，从而为 SPA 应用，添加些特殊处理，如添加 &lt;code&gt;medium-zoom&lt;/code&gt; 动画。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lovejade.oss-cn-shenzhen.aliyuncs.com/LakeSchreckseeBY.jpg&quot; title=&quot;&quot; alt=&quot;无需刷新即可检测 JavaScript 中的 URL 更改&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;故事背景&lt;/h2&gt;

&lt;p&gt;在今年年初，有基于 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://flarum.org/&quot; rel=&quot; nofollow ugc&quot;&gt;Flarum&lt;/a&gt; 搭建了&lt;a href=&quot;https://forum.lovejade.cn/&quot; rel=&quot; nofollow ugc&quot;&gt;悠然宜想亭&lt;/a&gt;这个站（具体由来，在&lt;a href=&quot;https://forum.lovejade.cn/d/1&quot; rel=&quot; nofollow ugc&quot;&gt;关于“悠然宜想亭”的由来，以及未来&lt;/a&gt;一文中，有做阐述）。&lt;a href=&quot;https://nicelinks.site/redirect?url=https://flarum.org/&quot; rel=&quot; nofollow ugc&quot;&gt;Flarum&lt;/a&gt; 是一款优雅简洁论坛软件，让在线交流变得更加轻松愉快。它那极简的部署方式，强大的后台管理，都令人欢喜不已；当然，前端页面也有些美中不足，如帖子的图片，不能放大化，像 &lt;a href=&quot;https://nicelinks.site/post/5c3f3151a5957e07a40b30ff&quot; rel=&quot; nofollow ugc&quot;&gt;Ghost&lt;/a&gt; 或 medium 那样。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/francoischalifour/medium-zoom&quot; rel=&quot; nofollow ugc&quot;&gt;medium-zoom&lt;/a&gt;：用于缩放图像的 JavaScript 库，如 Medium（A JavaScript library for zooming images like Medium）；它具有：📱 响应式、🚀 高性能和轻量级、⚡️ 高清支持、🔎 灵活性、📦 自定义、🔧 可插拔、🖱 鼠标、键盘和手势友好等优点；此外，&lt;code&gt;medium-zoom&lt;/code&gt; 的安装和使用，也都极其简单，如下示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// CSS selector
mediumZoom(&quot;[data-zoomable]&quot;);

// HTMLElement
mediumZoom(document.querySelector(&quot;#cover&quot;));

// NodeList
mediumZoom(document.querySelectorAll(&quot;[data-zoomable]&quot;));

// Array
const images = [
  document.querySelector(&quot;#cover&quot;),
  ...document.querySelectorAll(&quot;[data-zoomable]&quot;),
];

mediumZoom(images);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但，在 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://flarum.org/&quot; rel=&quot; nofollow ugc&quot;&gt;Flarum&lt;/a&gt; 项目中，直接使用 &lt;a href=&quot;https://github.com/francoischalifour/medium-zoom&quot; rel=&quot; nofollow ugc&quot;&gt;medium-zoom&lt;/a&gt; 会存在点小问题；&lt;code&gt;Flarum&lt;/code&gt; 是单页（SPA）应用，即更改 URL，整个页面内容不会全部刷新（仅限于主题内容部分）。这也就使得在后台 &lt;code&gt;Custom Header&lt;/code&gt; 插入的代码，无法在切换页面时也重新运行；按找正常逻辑，要处理这个问题，就须对 URL 做下监听，当检测到变化，则重新运行 mediumZoom 相关代码，使得「图像缩放」功能，可以在页面切换后，依然可以正常工作。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;&lt;code&gt;MutationObserver&lt;/code&gt;&lt;/strong&gt; 函数&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;MutationObserver()&lt;/code&gt;&lt;/strong&gt; 函数用于检测或观察对 DOM 树所做的更改。它只是检测 DOM 元素更改以及单页网站（如 React JS 和 Angular JS）上的 URL 更改。欲了解更详细内容，可参见 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver&quot; rel=&quot; nofollow ugc&quot;&gt;MutationObserver | MDN Web Docs&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;无需页面刷新即可检测 JavaScript 中 URL 更改的源代码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;let lastUrl = location.href;
new MutationObserver(() =&amp;gt; {
  const url = location.href;
  if (url !== lastUrl) {
    lastUrl = url;
    onUrlChange();
  }
}).observe(document, { subtree: true, childList: true });

function onUrlChange() {
  alert(&quot;URL changed!&quot;, location.href);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;代码说明：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;首先在上面的源代码中，我们使用页面的当前 URL &lt;strong&gt;&lt;code&gt;location.href;&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;之后，我们使用 &lt;strong&gt;MutationObserver 方法&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;observe()&lt;/code&gt;&lt;/strong&gt;配置 &lt;strong&gt;MutationObserver 回调以开始接收&lt;/strong&gt;与给定选项匹配的&lt;strong&gt;DOM 更改通知&lt;/strong&gt;。
  &lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;observe(document, {subtree: true, childList: true});&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;最后，我们比较 URL，然后调用提示新位置 URL 的函数。&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;您可以复制完整的代码，以便在现有程序上检查或使用。&lt;/p&gt;

&lt;h2&gt;为 Flarum 论坛添加 medium-zoom 库&lt;/h2&gt;

&lt;p&gt;只需，在 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://flarum.org/&quot; rel=&quot; nofollow ugc&quot;&gt;Flarum&lt;/a&gt; 后台 &lt;code&gt;Appearance&lt;/code&gt; =&amp;gt; &lt;code&gt;Custom Header&lt;/code&gt;，添加如下代码，即可使得 Flarum 帖子中的图片，在点击后可「放大」以方便查看。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&amp;lt;script&amp;gt;
  let lastUrl = location.href;
  new MutationObserver(() =&amp;gt; {
    const url = location.href;
    if (url !== lastUrl) {
      lastUrl = url;
      onUrlChange();
    }
  }).observe(document, {subtree: true, childList: true});

  function onUrlChange() {
    setTimeout(function () {
       mediumZoom(document.querySelectorAll(&#x27;.Post-body img&#x27;));
    }, 500)
  }
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;猜您可能感兴趣的文章&lt;/h2&gt;



                &lt;/div&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>17d5ee32adf30877a64bb2b4b9d325f3</guid>
<title>案例分享：Dubbo 2.7.12 bug 导致线上故障</title>
<link>https://toutiao.io/k/zusnv14</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;背景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近某天的深夜，刚洗完澡就接到业务方打来电话，说他们的 dubbo 服务出故障了，要我协助排查一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;电话里，询问了他们几点&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;是线上有损故障吗？——是&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;止损了吗？——止损了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有保留现场吗？——没有&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是我打开电脑，连上 VPN 看问题。为了便于理解，架构简化如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2844141069397042&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0RsPot9ibD6IGMYFkhYP61mCmJ9fJr7VVWnoVLHl58eKQPl7TRsu049XhNWA7fenY2JjPYNNjAZVDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1758&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需要关注 A、B、C 三个服务，他们之间调用都是 dubbo 调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发生故障时 B 服务有几台机器完全夯死，处理不了请求，剩余正常机器请求量激增，耗时增加，如下图（图一请求量、图二耗时）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6130952380952381&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0RsPot9ibD6IGMYFkhYP61mCOyQsiaxWwj0yxRYQbHY9CDZOqLicib6yd8Vlb0B2xK12A4PMNic5TqFWOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1680&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4183927091963546&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0RsPot9ibD6IGMYFkhYP61mCkXKWDosXs7ErATg5RF6mIV3Dd6VyukxXD7y61F70NFLHS5TiaaHlC3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2414&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;问题排查&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于现场已被破坏，只能先看监控和日志&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上述监控外，翻看了 B 服务 CPU 和内存等基础监控，发现故障的几台机器内存上涨比较多，都达到了 80% 的水平线，且 CPU 消耗也变多&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.39628482972136225&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0RsPot9ibD6IGMYFkhYP61mCxACts1SRK1r3W0T6w9rNxXSc0rxPYxrNmKEq2qpBOaGia5SrXHAkl4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1938&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时比较怀疑内存问题，于是看了下 JVM 的 fullGC 监控&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4058536585365854&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0RsPot9ibD6IGMYFkhYP61mCEOayEDTU9M4UgCzOTuU5GjQjLaFh1BONYYYIfutSxenTKhEud6awdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2050&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;果然 fullGC 时间上涨很多，基本可以断定是内存泄漏导致服务不可用了。但为什么会内存泄漏，还无法看出端倪。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;申请机器权限，查看日志，发现了一条很奇怪的 WARN 日志&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;[dubbo-future-timeout-thread-1] WARN org.apache.dubbo.common.timer.HashedWheelTimer&lt;span&gt;$HashedWheelTimeout&lt;/span&gt;&lt;br/&gt;(HashedWheelTimer.java:651) &lt;br/&gt;-  [DUBBO] An exception was thrown by TimerTask., dubbo version: 2.7.12, current host: xxx.xxx.xxx.xxx&lt;br/&gt;java.util.concurrent.RejectedExecutionException: &lt;br/&gt;Task org.apache.dubbo.remoting.exchange.support.DefaultFuture&lt;span&gt;$TimeoutCheckTask&lt;/span&gt;$&lt;span&gt;$Lambda&lt;/span&gt;&lt;span&gt;$674&lt;/span&gt;/1067077932@13762d5a &lt;br/&gt;rejected from java.util.concurrent.ThreadPoolExecutor@7a9f0e84[Terminated, pool size = 0, &lt;br/&gt;active threads = 0, queued tasks = 0, completed tasks = 21]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出业务方使用的是&lt;strong&gt;2.7.12&lt;/strong&gt;版本的 dubbo&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拿这个日志去 dubbo 的 github 仓库搜了一下，找到了如下这个 issue：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://github.com/apache/dubbo/issues/6820&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4563335955940205&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0RsPot9ibD6IGMYFkhYP61mCn7YCoLFgSkCxvIQdxUVBEfgNcznRFRtic82f6g6J1ib4btDWXM3BAzmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2542&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但很快排除了该问题，因为在 2.7.12 版本中已经是修复过的代码了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续又找到了这两个 issue：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://github.com/apache/dubbo/issues/8172&lt;/p&gt;&lt;p&gt;https://github.com/apache/dubbo/pull/8188&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从报错和版本上来看，完全符合，但没有提及内存问题，先不管内存问题，看看是否可以按照 &lt;strong&gt;#8188&lt;/strong&gt; 这个 issue 复现&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.411635565312843&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0RsPot9ibD6IGMYFkhYP61mCB6zfHibqGkAOw0Yibl2Ap7SrK80X5ibaJzgIkRww5NCQLSYUknk4FibHpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1822&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;issue 中也说的比较清楚如何复现，于是我搭了这样三个服务来复现，刚开始还没有复现。通过修复代码来反推&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2820299500831947&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0RsPot9ibD6IGMYFkhYP61mCvUnS48ZA5wrq7pJg6JB8c9rJicmMhXXVKnOlk9rsJiaQQklU5W0mcZ2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2404&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;删除代码部分是有问题，但我们复现却难以进入这块，怎么才能进入呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里一个 feature 代表一个请求，只有当请求没有完成时才会进入，这就好办了，让 provider 一直不返回，肯定可以实现，于是在 provider 端测试代码加入&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Thread.sleep(Integer.MAX_VALUE);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过测试果然复现了，如 issue 所说，当 kill -9 掉第一个 provider 时，消费者全局 ExecutorService 被关闭，当 kill -9 第二个 provider 时，SHARED_EXECUTOR 也被关闭。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这个线程池是用来干什么的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它在 &lt;strong&gt;HashedWheelTimer&lt;/strong&gt; 中被用来检测 consumer 发出的请求是否超时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HashedWheelTimer 是 dubbo 实现的一种时间轮检测请求是否超时的算法，具体这里不再展开，改天可以详细写一篇 dubbo 中时间轮算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当请求发出后，如果可以正常返回还好，但如果超过设定的超时时间还未返回，则需要这个线程池的任务来检测，对已经超时的任务进行打断。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下代码为提交任务，当这个线程池被关闭后，提交任务就会抛出异常，超时也就无法检测。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;expire&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!compareAndSetState(ST_INIT, ST_EXPIRED)) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        task.run(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (logger.isWarnEnabled()) {&lt;br/&gt;            logger.warn(&lt;span&gt;&quot;An exception was thrown by &quot;&lt;/span&gt; + TimerTask&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getSimpleName&lt;/span&gt;() + &#x27;.&#x27;, &lt;span&gt;t&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里恍然大悟：如果请求一直发送，不超时，那是不是有可能撑爆内存？于是我又模拟了一下，并且开了 3 个线程一直请求  provider，果然复现出内存被撑爆的场景，而当不触发这个问题时，内存是一直稳定在一个低水平上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6542857142857142&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0RsPot9ibD6IGMYFkhYP61mCsibib2FQ6xoyes5cj76FMxCsJmrFmW1hpML80fZbfHiaJNQDLKhE35STA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2100&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里我用的 arthas 来看的内存变化，非常方便&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;得出结论&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本地复现后，于是跟业务方求证一下，这个问题复现还是比较苛刻的，首先得是&lt;strong&gt;异步调用&lt;/strong&gt;，其次 &lt;strong&gt;provider 需要非正常下线&lt;/strong&gt;，最后 &lt;strong&gt;provider 需要有阻塞&lt;/strong&gt;，即请求一直不返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步调用得到业务方的确认，provider 非正常下线，这个比较常见，物理机的故障导致的容器漂移就会出现这个情况，最后 provider 有阻塞这点也得到业务方的确认，确实 C 服务有一台机器在那个时间点附近僵死，无法处理请求，但进程又是存活的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这个问题是 dubbo 2.7.12 的 bug 导致。翻看了下这个 bug 是 2.7.10 引入， 2.7.13 修复。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;复盘&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;差不多花了1天的时间来定位和复现，还算顺利，运气也比较好，没怎么走弯路，但这中间也需要有些地方需要引起重视。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;止损的同时最好能保留现场，如本次如果在重启前 dump 下内存或摘除流量保留机器现场，可能会帮助加速定位问题。如配置 OOM 时自动 dump 内存等其他手段。这也是本起事故中不足的点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务的可观测性非常重要，不管是日志、监控或其他，都要齐全。基本的如日志、出口、进口请求监控、机器指标（内存、CPU、网络等）、JVM 监控（线程池、GC 等）。这点做的还可以，基本该有的都有&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开源产品，可从关键日志去网络查找，极大概率你遇到的问题大家也遇到过。这也是这次幸运的点，少走了很多弯路&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;搜索关注微信公众号&quot;捉虫大师&quot;，后端技术分享，架构设计、性能优化、源码阅读、问题排查、踩坑实践。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/xacdaKuBM0RsPot9ibD6IGMYFkhYP61mCiaEnjMV0AdaTia5o0xpU4ric0WOM9nzIG3QULiaRnDwZ7rRgG0urvE5BlA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/figure&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>273ed205355050d46bc7e6ea7be52e07</guid>
<title>Redis 核心原理与实践：散列类型与字典结构实现原理</title>
<link>https://toutiao.io/k/gomuz3y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;Redis散列类型可以存储一组无序的键值对，它特别适用于存储一个对象数据。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt; &lt;span&gt;HSET&lt;/span&gt; &lt;span&gt;fruit&lt;/span&gt; &lt;span&gt;name&lt;/span&gt; &lt;span&gt;apple&lt;/span&gt; &lt;span&gt;price&lt;/span&gt; 7&lt;span&gt;.6&lt;/span&gt; &lt;span&gt;origin&lt;/span&gt; &lt;span&gt;china&lt;/span&gt;&lt;br/&gt;3&lt;br/&gt;&amp;gt; &lt;span&gt;HGET&lt;/span&gt; &lt;span&gt;fruit&lt;/span&gt; &lt;span&gt;price&lt;/span&gt;&lt;br/&gt;&quot;7&lt;span&gt;.6&lt;/span&gt;&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;本文分析Redis中散列类型以及其底层数据结构--字典的实现原理。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;字典&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Redis通常使用字典结构存储用户散列数据。 &lt;br/&gt;字典是Redis的重要数据结构。除了散列类型，Redis数据库也使用了字典结构。 &lt;br/&gt;Redis使用Hash表实现字典结构。分析Hash表，我们通常关注以下几个问题： &lt;br/&gt;（1）使用什么Hash算法？ &lt;br/&gt;（2）Hash冲突如何解决？ &lt;br/&gt;（3）Hash表如何扩容？&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;提示：本章代码如无特别说明，均在dict.h、dict.c中。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;&lt;span&gt;定义&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;字典中键值对的定义如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;dictEntry&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;void&lt;/span&gt; *key;&lt;br/&gt;    &lt;span&gt;union&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;void&lt;/span&gt; *val;&lt;br/&gt;        &lt;span&gt;uint64_t&lt;/span&gt; u64;&lt;br/&gt;        &lt;span&gt;int64_t&lt;/span&gt; s64;&lt;br/&gt;        &lt;span&gt;double&lt;/span&gt; d;&lt;br/&gt;    } v;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;dictEntry&lt;/span&gt; *&lt;span&gt;next&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;} dictEntry;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;提示：C语言union关键字用于声明共用体，共用体的所有属性共用同一空间，同一时间只能储存其中一个属性值。也就是说，dictEntry.v可以存放val、u64、s64、d中的一个属性值。使用sizeof函数计算共用体大小，结果不会小于共用体中最大的成员属性大小。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;字典中Hash表的定义如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;dictht&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    dictEntry **table;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; size;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; sizemask;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; used;&lt;br/&gt;} dictht;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;table：Hash表数组，负责存储数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;used：记录存储键值对的数量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;size：Hash表数组长度。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;dictht的结构如图3-1所示。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8448753462603878&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Of81vjDNtAyumicu56oibsfCjKpz4aue6ib88QUTibkibXSsrGDVUfCoqhom6dPN2mWtJG9xfaprsX4a6EsUOE6ibE4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;361&quot; title=&quot;图3-1&quot;/&gt;&lt;figcaption&gt;图3-1&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;字典的定义如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;dict&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    dictType *type;&lt;br/&gt;    &lt;span&gt;void&lt;/span&gt; *privdata;&lt;br/&gt;    dictht ht[&lt;span&gt;2&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; rehashidx; &lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; iterators;&lt;br/&gt;} dict;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;type：指定操作数据的函数指针。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ht[2]：定义两个Hash表用于实现字典扩容机制。通常场景下只使用ht[0]，而在扩容时，会创建ht[1]，并在操作数据时中逐步将ht[0]的数据移到ht[1]中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;rehashidx：下一次执行扩容单步操作要迁移的ht[0]Hash表数组索引，-1代表当前没有进行扩容操作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;iterators：当前运行的迭代器数量，迭代器用于遍历字典键值对。 &lt;br/&gt;dictType定义了字典中用于操作数据的函数指针，这些函数负责实现数据复制、比较等操作。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;dictType&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;uint64_t&lt;/span&gt; (*hashFunction)(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; *key);&lt;br/&gt;    &lt;span&gt;void&lt;/span&gt; *(*keyDup)(&lt;span&gt;void&lt;/span&gt; *privdata, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; *key);&lt;br/&gt;    &lt;span&gt;void&lt;/span&gt; *(*valDup)(&lt;span&gt;void&lt;/span&gt; *privdata, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; *obj);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; (*keyCompare)(&lt;span&gt;void&lt;/span&gt; *privdata, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; *key1, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; *key2);&lt;br/&gt;    &lt;span&gt;void&lt;/span&gt; (*keyDestructor)(&lt;span&gt;void&lt;/span&gt; *privdata, &lt;span&gt;void&lt;/span&gt; *key);&lt;br/&gt;    &lt;span&gt;void&lt;/span&gt; (*valDestructor)(&lt;span&gt;void&lt;/span&gt; *privdata, &lt;span&gt;void&lt;/span&gt; *obj);&lt;br/&gt;} dictType;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过dictType指定操作数据的函数指针，字典就可以存放不同类型的数据了。但在一个字典中，键、值可以是不同的类型，但键必须类型相同，值也必须类型相同。 &lt;br/&gt;Redis为不同的字典定义了不同的dictType，如数据库使用的server.c/dbDictType，散列类型使用的server.c/setDictType等。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;操作分析&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;dictAddRaw函数可以在字典中插入或查找键：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)&lt;br/&gt;{&lt;br/&gt;    long index;&lt;br/&gt;    dictEntry *entry;&lt;br/&gt;    dictht *ht;&lt;br/&gt;    &lt;span&gt;// [1]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (dictIsRehashing(d)) _dictRehashStep(d);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [2]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == &lt;span&gt;-1&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// [3]&lt;/span&gt;&lt;br/&gt;    ht = dictIsRehashing(d) ? &amp;amp;d-&amp;gt;ht[&lt;span&gt;1&lt;/span&gt;] : &amp;amp;d-&amp;gt;ht[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;// [4]&lt;/span&gt;&lt;br/&gt;    entry = zmalloc(sizeof(*entry));&lt;br/&gt;    entry-&amp;gt;next = ht-&amp;gt;table[index];&lt;br/&gt;    ht-&amp;gt;table[index] = entry;&lt;br/&gt;    ht-&amp;gt;used++;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [5]&lt;/span&gt;&lt;br/&gt;    dictSetKey(d, entry, key);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; entry;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参数说明：&lt;/p&gt;&lt;p&gt;【1】如果该字典正在扩容，则执行一次扩容单步操作。 &lt;br/&gt;【2】计算参数key的Hash表数组索引，返回-1，代表键已存在，这时dictAddRaw函数返回NULL，代表该键已存在。 &lt;br/&gt;【3】如果该字典正在扩容，则将新的dictEntry添加到ht[1]中，否则添加到ht[0]中。 &lt;br/&gt;【4】创建dictEntry，头插到Hash表数组对应位置的链表中。Redis字典使用链表法解决Hash冲突，Hash表数组的元素都是链表。 &lt;br/&gt;【5】将键设置到dictEntry中。&lt;/p&gt;&lt;p&gt;dictAddRaw函数只会插入键，并不插入对应的值。可以使用返回的dictEntry插入值：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    entry = dictAddRaw(dict,mykey,&lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (entry != &lt;span&gt;NULL&lt;/span&gt;) dictSetSignedIntegerVal(entry,&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Hash算法&lt;/strong&gt;  &lt;br/&gt;dictHashKey宏调用dictType.hashFunction函数计算键的Hash值：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; dictHashKey(d, key) (d)-&amp;gt;type-&amp;gt;hashFunction(key)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Redis中字典基本都使用SipHash算法（server.c/dbDictType、server.c/setDictType等dictType的hashFunction属性指向的函数都使用了SipHash算法）。该算法能有效地防止Hash表碰撞攻击，并提供不错的性能。 &lt;br/&gt;Hash算法涉及较多的数学知识，本书并不讨论Hash算法的原理及实现，读者可以自行阅读相关代码。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;提示：Redis 4.0之前使用的Hash算法是MurmurHash。即使输入的键是有规律的，该算法计算的结果依然有很好的离散性，并且计算速度非常快。Redis 4.0开始更换为SipHash算法，应该是出于安全的考虑。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;计算键的Hash值后，还需要计算键的Hash表数组索引：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; _dictKeyIndex(dict *d, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; *key, &lt;span&gt;uint64_t&lt;/span&gt; hash, dictEntry **existing)&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; idx, table;&lt;br/&gt;    dictEntry *he;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (existing) *existing = &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [1]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (_dictExpandIfNeeded(d) == DICT_ERR)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// [2]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (table = &lt;span&gt;0&lt;/span&gt;; table &amp;lt;= &lt;span&gt;1&lt;/span&gt;; table++) {&lt;br/&gt;        idx = hash &amp;amp; d-&amp;gt;ht[table].sizemask;&lt;br/&gt;        he = d-&amp;gt;ht[table].table[idx];&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;(he) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (key==he-&amp;gt;key || dictCompareKeys(d, key, he-&amp;gt;key)) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (existing) *existing = he;&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            he = he-&amp;gt;next;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// [3]&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!dictIsRehashing(d)) &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; idx;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【1】根据需要进行扩容或初始化Hash表操作。 &lt;br/&gt;【2】遍历ht[0]、ht[1]，计算Hash表数组索引，并判断Hash表中是否已存在参数key。若已存在，则将对应的dictEntry赋值给*existing。 &lt;br/&gt;【3】如果当前没有进行扩容操作，则计算ht[0]索引后便退出，不需要计算ht[1]。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;扩容&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;Redis使用了一种渐进式扩容方式，这样设计，是因为Redis是单线程的。如果在一个操作内将ht[0]所有数据都迁移到ht[1]，那么可能会引起线程长期阻塞。所以，Redis字典扩容是在每次操作数据时都执行一次扩容单步操作，扩容单步操作即将ht[0].table[rehashidx]的数据迁移到ht[1]。等到ht[0]的所有数据都迁移到ht[1]，便将ht[0]指向ht[1]，完成扩容。 &lt;br/&gt;_dictExpandIfNeeded函数用于判断Hash表是否需要扩容：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; int _dictExpandIfNeeded(dict *d)&lt;br/&gt;{&lt;br/&gt;    ...&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (d-&amp;gt;ht[&lt;span&gt;0&lt;/span&gt;].used &amp;gt;= d-&amp;gt;ht[&lt;span&gt;0&lt;/span&gt;].size &amp;amp;&amp;amp;&lt;br/&gt;        (dict_can_resize ||&lt;br/&gt;         d-&amp;gt;ht[&lt;span&gt;0&lt;/span&gt;].used/d-&amp;gt;ht[&lt;span&gt;0&lt;/span&gt;].size &amp;gt; dict_force_resize_ratio))&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; dictExpand(d, d-&amp;gt;ht[&lt;span&gt;0&lt;/span&gt;].used*&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; DICT_OK;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;扩容需要满足两个条件： &lt;br/&gt;（1）d-&amp;gt;ht[0].used≥d-&amp;gt;ht[0].size：Hash表存储的键值对数量大于或等于Hash表数组的长度。 &lt;br/&gt;（2）开启了dict_can_resize或者负载因子大于dict_force_resize_ratio。  &lt;br/&gt;d-&amp;gt;ht[0].used/d-&amp;gt;ht[0].size，即Hash表存储的键值对数量/Hash表数组的长度，称之为负载因子。dict_can_resize默认开启，即负载因子等于1就扩容。负载因子等于1可能出现比较高的Hash冲突率，但这样可以提高Hash表的内存使用率。dict_force_resize_ratio关闭时，必须等到负载因子等于5时才强制扩容。用户不能通过配置关闭dict_force_resize_ratio，该值的开关与Redis持久化有关，等我们分析Redis持久化时再讨论该值。&lt;/p&gt;&lt;p&gt;dictExpand函数开始扩容操作：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;dictExpand&lt;/span&gt;&lt;span&gt;(dict *d, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; size)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;// [1]&lt;/span&gt;&lt;br/&gt;    dictht n; &lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; realsize = _dictNextPower(size);&lt;br/&gt;    ...&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [2]&lt;/span&gt;&lt;br/&gt;    n.size = realsize;&lt;br/&gt;    n.sizemask = realsize&lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;    n.table = zcalloc(realsize*&lt;span&gt;sizeof&lt;/span&gt;(dictEntry*));&lt;br/&gt;    n.used = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [3]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (d-&amp;gt;ht[&lt;span&gt;0&lt;/span&gt;].table == &lt;span&gt;NULL&lt;/span&gt;) {&lt;br/&gt;        d-&amp;gt;ht[&lt;span&gt;0&lt;/span&gt;] = n;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; DICT_OK;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [4]&lt;/span&gt;&lt;br/&gt;    d-&amp;gt;ht[&lt;span&gt;1&lt;/span&gt;] = n;&lt;br/&gt;    d-&amp;gt;rehashidx = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; DICT_OK;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参数说明：&lt;/p&gt;&lt;p&gt;【1】_dictNextPower函数会将size调整为2的n次幂。 &lt;br/&gt;【2】构建一个新的Hash表dictht。 &lt;br/&gt;【3】ht[0].table==NULL，代表字典的Hash表数组还没有初始化，将新dictht赋值给ht[0]，现在它就可以存储数据了。这里并不是扩容操作，而是字典第一次使用前的初始化操作。 &lt;br/&gt;【4】否则，将新dictht赋值给ht[1]，并将rehashidx赋值为0。rehashidx代表下一次扩容单步操作要迁移的ht[0] Hash表数组索引。&lt;/p&gt;&lt;p&gt;为什么要将size调整为2的n次幂呢？这样是为了ht[1] Hash表数组长度是ht[0] Hash表数组长度的倍数，有利于ht[0]的数据均匀地迁移到ht[1]。 &lt;br/&gt;我们看一下键的Hash表数组索引计算方法：&lt;code&gt;idx=hash&amp;amp;ht.sizemask&lt;/code&gt;，由于&lt;code&gt;sizemask= size-1&lt;/code&gt;，计算方法等价于：&lt;code&gt;idx=hash%(ht.size)&lt;/code&gt;。 &lt;br/&gt;因此，假如ht[0].size为n，ht[1].size为2×n，对于ht[0]上的元素，ht[0].table[k]的数据，要不迁移到ht[1].table[k]，要不迁移到ht[1].table[k+n]。这样可以将ht[0].table中一个索引位的数据拆分到ht[1]的两个索引位上。 &lt;br/&gt;图3-2展示了一个简单示例。 &lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5094339622641509&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Of81vjDNtAyumicu56oibsfCjKpz4aue6ibwmowzvXVWTJrPMviaIG64ZYgd0Gx05OSbBnk4qbleLelTrzDf1nXnjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;371&quot; title=&quot;图3-2&quot;/&gt;&lt;figcaption&gt;图3-2&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;_dictRehashStep函数负责执行扩容单步操作，将ht[0]中一个索引位的数据迁移到ht[1]中。dictAddRaw、dictGenericDelete、dictFind、dictGetRandomKey、dictGetSomeKeys等函数都会调用该函数，从而逐步将数据迁移到新的Hash表中。&lt;br/&gt;_dictRehashStep调用dictRehash函数完成扩容单步操作：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;int dictRehash(dict *d, int n) {&lt;br/&gt;    int empty_visits = n*&lt;span&gt;10&lt;/span&gt;; &lt;br/&gt;    &lt;span&gt;// [1]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!dictIsRehashing(d)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(n-- &amp;amp;&amp;amp; d-&amp;gt;ht[&lt;span&gt;0&lt;/span&gt;].used != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        dictEntry *de, *nextde;&lt;br/&gt;&lt;br/&gt;        assert(d-&amp;gt;ht[&lt;span&gt;0&lt;/span&gt;].size &amp;gt; (unsigned long)d-&amp;gt;rehashidx);&lt;br/&gt;        &lt;span&gt;// [2]&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;(d-&amp;gt;ht[&lt;span&gt;0&lt;/span&gt;].table[d-&amp;gt;rehashidx] == &lt;span&gt;NULL&lt;/span&gt;) {&lt;br/&gt;            d-&amp;gt;rehashidx++;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (--empty_visits == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// [3]&lt;/span&gt;&lt;br/&gt;        de = d-&amp;gt;ht[&lt;span&gt;0&lt;/span&gt;].table[d-&amp;gt;rehashidx];&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;(de) {&lt;br/&gt;            uint64_t h;&lt;br/&gt;&lt;br/&gt;            nextde = de-&amp;gt;next;&lt;br/&gt;            h = dictHashKey(d, de-&amp;gt;key) &amp;amp; d-&amp;gt;ht[&lt;span&gt;1&lt;/span&gt;].sizemask;&lt;br/&gt;            de-&amp;gt;next = d-&amp;gt;ht[&lt;span&gt;1&lt;/span&gt;].table[h];&lt;br/&gt;            d-&amp;gt;ht[&lt;span&gt;1&lt;/span&gt;].table[h] = de;&lt;br/&gt;            d-&amp;gt;ht[&lt;span&gt;0&lt;/span&gt;].used--;&lt;br/&gt;            d-&amp;gt;ht[&lt;span&gt;1&lt;/span&gt;].used++;&lt;br/&gt;            de = nextde;&lt;br/&gt;        }&lt;br/&gt;        d-&amp;gt;ht[&lt;span&gt;0&lt;/span&gt;].table[d-&amp;gt;rehashidx] = &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;        d-&amp;gt;rehashidx++;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [4]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (d-&amp;gt;ht[&lt;span&gt;0&lt;/span&gt;].used == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        zfree(d-&amp;gt;ht[&lt;span&gt;0&lt;/span&gt;].table);&lt;br/&gt;        d-&amp;gt;ht[&lt;span&gt;0&lt;/span&gt;] = d-&amp;gt;ht[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;        _dictReset(&amp;amp;d-&amp;gt;ht[&lt;span&gt;1&lt;/span&gt;]);&lt;br/&gt;        d-&amp;gt;rehashidx = &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参数说明：&lt;/p&gt;&lt;p&gt;【1】如果字典当前并没有进行扩容，则直接退出函数。 &lt;br/&gt;【2】从rehashidx开始，找到第一个非空索引位。 &lt;br/&gt;如果这里查找的的空索引位的数量大于n×10，则直接返回。 &lt;br/&gt;【3】遍历该索引位链表上所有的元素。 &lt;br/&gt;计算每个元素在ht[1]的Hash表数组中的索引，将元素移动到ht[1]中。 &lt;br/&gt;【4】ht[0].used==0，代表ht[0]的数据已经全部移到ht[1]中。  &lt;br/&gt;释放ht[0].table，将ht[0]指针指向ht[1]，并重置rehashidx、d-&amp;gt;ht[1]，扩容完成。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;缩容&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;执行删除操作后，Redis会检查字典是否需要缩容，当Hash表长度大于4且负载因子小于0.1时，会执行缩容操作，以节省内存。缩容实际上也是通过dictExpand函数完成的，只是函数的第二个参数size是缩容后的大小。&lt;/p&gt;&lt;p&gt;dict常用的函数如表3-1所示。&lt;/p&gt;&lt;table data-sort=&quot;sortDisabled&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;&lt;th&gt;作用&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;dictAdd&lt;/td&gt;&lt;td&gt;插入键值对&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;dictReplace&lt;/td&gt;&lt;td&gt;替换或插入键值对&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;dictDelete&lt;/td&gt;&lt;td&gt;删除键值对&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;dictFind&lt;/td&gt;&lt;td&gt;查找键值对&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;dictGetIterator&lt;/td&gt;&lt;td&gt;生成不安全迭代器，可以对字典进行修改&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;dictGetSafeIterator&lt;/td&gt;&lt;td&gt;生成安全迭代器，不可对字典进行修改&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;dictResize&lt;/td&gt;&lt;td&gt;字典缩容&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;dictExpand&lt;/td&gt;&lt;td&gt;字典扩容&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;&lt;span&gt;编码&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;散列类型有OBJ_ENCODING_HT和OBJ_ENCODING_ZIPLIST两种编码，分别使用dict、ziplist结构存储数据（redisObject.ptr指向dict、ziplist结构）。Redis会优先使用ziplist存储散列元素，使用一个ziplist节点存储键，后驱节点存放值，查找时需要遍历ziplist。使用dict存储散列元素，字典的键和值都是sds类型。散列类型使用OBJ_ENCODING_ZIPLIST编码，需满足以下条件： &lt;br/&gt;（1）散列中所有键或值的长度小于或等于server.hash_max_ziplist_value，该值可通过hash-max-ziplist-value配置项调整。 &lt;br/&gt;（2）散列中键值对的数量小于server.hash_max_ziplist_entries，该值可通过hash-max- ziplist-entries配置项调整。 &lt;br/&gt;散列类型的实现代码在t_hash.c中，读者可以查看源码了解更多实现细节。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;数据库&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Redis是内存数据库，内部定义了数据库对象server.h/redisDb负责存储数据，redisDb也使用了字典结构管理数据。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;redisDb&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    dict *dict;                 &lt;br/&gt;    dict *expires;              &lt;br/&gt;    dict *blocking_keys;        &lt;br/&gt;    dict *ready_keys;           &lt;br/&gt;    dict *watched_keys;         &lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; id;                     &lt;br/&gt;    ...&lt;br/&gt;} redisDb;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;dict：数据库字典，该redisDb所有的数据都存储在这里。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;expires：过期字典，存储了Redis中所有设置了过期时间的键及其对应的过期时间，过期时间是long long类型的UNIX时间戳。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;blocking_keys：处于阻塞状态的键和相应的客户端。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ready_keys：准备好数据后可以解除阻塞状态的键和相应的客户端。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;watched_keys：被watch命令监控的键和相应客户端。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;id：数据库ID标识。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Redis是一个键值对数据库，全称为Remote Dictionary Server（远程字典服务），它本身就是一个字典服务。redisDb.dict字典中的键都是sds，值都是redisObject。这也是redisObject作用之一，它将所有的数据结构都封装为redisObject结构，作为redisDb字典的值。 &lt;br/&gt;一个简单的redisDb结构如图3-3所示。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.26785714285714285&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Of81vjDNtAyumicu56oibsfCjKpz4aue6ibjOrhhrdF5BBibqRJ05k6LnqKGGqo0QYicTKADVJ8ZwaUNzqwLKC1pXdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;560&quot; title=&quot;图3-3&quot;/&gt;&lt;figcaption&gt;图3-3&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;当我们需要操作Redis数据时，都需要从redisDb中找到该数据。 &lt;br/&gt;db.c中定义了hashTypeLookupWriteOrCreate、lookupKeyReadOrReply等函数，可以通过键找到redisDb.dict中对应的redisObject，这些函数都是通过调用dict API实现的，这里不一一展示，感兴趣的读者可以自行阅读代码。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Redis字典使用SipHash算法计算Hash值，并使用链表法处理Hash冲突。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Redis字典使用渐进式扩容方式，在每次数据操作中都执行一次扩容单步操作，直到扩容完成。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;散列类型的编码格式可以为OBJ_ENCODING_HT、OBJ_ENCODING_ZIPLIST。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;本文内容摘自作者新书&lt;strong&gt;《Redis核心原理与实践》&lt;/strong&gt;，这本书深入地分析了Redis常用特性的内部机制与实现方式，大部分内容源自对Redis 6.0源码的分析，并从中总结出设计思路、实现原理。通过阅读本书，读者可以快速、轻松地了解Redis的内部运行机制。 &lt;br/&gt;经过该书编辑同意，我会继续在个人技术公众号（binecy）发布书中部分章节内容，作为书的预览内容，欢迎大家查阅，谢谢。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>