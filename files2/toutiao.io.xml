<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ef43c3b03535f3c8ac206836cb412daf</guid>
<title>字节跳动是如何落地微前端的</title>
<link>https://toutiao.io/k/ou37ua8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文内提及的 Garfish 微前端解决方案已开源：https://github.com/modern-js-dev/garfish（目前的 Garfish 作为字节跳动各部门应用最广泛的微前端解决方案已经服务超过 100+ 前端团队，400+ 项目），另外字节跳动的现代 Web 工程体系即将开源（&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzkxNDIzNTg4MA==&amp;amp;mid=2247484407&amp;amp;idx=1&amp;amp;sn=c3706cdacefe4fd0ee372804ce53b4ce&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Modern.js&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Modern.js&lt;/a&gt;），深度集成 Garfish 提供了对微前端的原生支持，提供更开箱即用的能力，敬请期待！&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;微前端的出现的背景和意义&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微前端是什么：微前端是一种类似于微服务的架构，是一种由独立交付的多个前端应用组成整体的架构风格，将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的应用，而在用户看来仍然是内聚的单个产品。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微前端诞生在两个大的背景下，在提倡拥抱变化的前端社区可以看到新的框架、技术、概念层出不穷，并且随着 Web 标准的演进，前端应用已经具备更好的性能、更快的开发效率。但随着而来的是应用的复杂程度更高、涉及的团队规模更广、更高的性能要求，应用复杂度已经成为阻塞业务发展的重要瓶颈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微前端就是诞生于 Web 应用日益复杂化的场景中，因为随着网络速度、计算机硬件水平的提升和 Web 标准的演进，过去 Web 应用用户体验远不如传统的应用软件时代已逐渐远去，两者之间在用户体验上的差距不断缩减，并且由于 Web 应用开发速度快、用完即走等特性，导致的一个最终结果就是「能用 Web 技术实现的应用，最终都会通过 Web 来实现」。在近几年涌现了一大批之前只能在传统 PC 软件中才能看到的优秀产品，例如：Photoshop、Web Office、Web IDE。尽管随着 Web 标准的演进，前端工程化也在不断演变，从模块化到组件化在到现在的工程化，但在面对跨团队大规模开发、跨团队企业级应用协作，现有的分治设计模式仍然显得有心无力。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1828125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyTyU8s8ytuFos30JdhRhJAeoptxAtvFtiaT7zZBdicCpOaZJE3VsuuiajAam4WDQbbzibnbDVjEa2shw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大规模 Web 应用的困局&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管 Web 应用的复杂度和参与人数以爆炸式的增长速度，但却没有一种新的架构模式来解决现有的困境，并同时兼顾 DX（developer experience）和 UX（user experience）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以字节跳动内「研发中台」举例，在研发日常工作中需要使用非常多的研发系统，例如：代码管理、代码构建、域名管理、应用发布、CDN 资源管理、对象存储等。站在整个公司研发的角度考虑，最好的产品形态就是将所有的研发系统都放置同一个产品内，用户是无法感知他在使用不同的产品，对于用户而言就是单个产品不存割裂感，也不需要去学习多个平台，仅仅需要学习和了解字节跳动内的「研发中台」即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在字节跳动内这一类应用随处可见，由于字节跳动内存在大量业务线，每一条业务线都会诞生大量的中台系统，并且还在指数增长，以字节跳动内电商业务举例，对于电商运营的日常工作来说，其实与研发日常工作一样，围绕在：商品、商家、品牌、风控、营销等工作上，那么对于电商运营来说怎么样才最高效的电商运营系统呢，由于整个系统涉及范围较广，在实际的研发过程中必然会以功能或业务需求垂直的切分成更小的子系统，切分成各种小系统后尽管由于分治的设计理念提升了开发者体验，但是一定程度上降低了用户体验。那能否以一种新的架构模式，既保开发者体验，又能提升用户体验呢。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;传统 Web 应用的利与弊&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里简单分析一下传统 Web 应用在开发大规模应用和涉及多研发团队协作时遇到的一些困境，以上面案例中的「电商运营平台」举例，对于电商运营而言商品、商家、品牌等都是电商运营平台能力的一部分，而不是独立之间的孤岛。若以传统的前端研发模式进行开发，那么此时有两种项目设计策略：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将平台内多个系统放置同一个代码仓库维护 ，采用 SPA（Single-page Application） 单页应用模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将系统分为多个仓库维护，在首页聚合所有平台的入口，采用 MPA（Multi-page Application）多页应用模式&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;若采用多个系统放置同一个项目内维护：&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;优势：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;更好的性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;具备局部更新，无缝的用户体验&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提前预加载用户下一页的内容&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;统一的权限管控、统一的 Open API 开发能力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更好的代码复用，基础库复用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;统一的运营管理能力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不同系统可以很好的通信&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SPA 应用特有优势：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;劣势：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;代码权限管控问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;项目构建时间长&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需求发布相互阻塞&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码 commit 混乱、分支混乱&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;技术体系要求统一&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无法同时灰度多条产品功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码回滚相互影响&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;错误监控无法细粒度拆分&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用方案一的劣势非常明显，在日常开发中研发：代码构建半小时以上、发布需求时被需求阻塞、无法局部灰度局部升级、项目遇到问题时回滚影响其他业务、无法快速引进新的技术体系提高生产力，项目的迭代和维护对于研发同学而言无疑是噩梦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管降低了开发体验，如果对项目整体的代码拆分，懒加载控制得当，其实对于使用平台的用户而言体验却是提升的，这一切都归咎于 SPA 应用带来的优势，SPA 应用跳转页面时无需刷新整个页面，路由变化时仅更新局部，不用让用户产生在 MPA 应用切换时整个页面刷新带来的抖动感而降低体验，并且由于页面不刷新的特性可以极大程度的复用页面间的资源，降低切换页面时带来的性能损耗，用户也不会感知他在使用不同平台。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;若采用拆分成多个仓库维护&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;优势&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可以以项目维度拆分代码，解决权限管控问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;仅构建本项目代码，构建速度快&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以使用不同的技术体系&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不存在同一个仓库维护时的 commit 混乱和分支混乱等问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;功能灰度互不影响&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;劣势&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户在使用时体验割裂，会在不同平台间跳转，无法达到 SPA 应用带来的用户体验&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只能以页面维度拆分，无法拆分至区块部分，只能以业务为维度划分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多系统同灰度策略困难&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;公共包基础库重复加载&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不同系统间不可以直接通信&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;公共部分只能每个系统独立实现，同一运维通知困难&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;产品权限无法进行统一收敛&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用方案二在一定程度上提升了开发体验，但却降低了用户体验，研发在日常开发工作中需要使用大量的平台，但是却需要跳转到不同的平台上进行日常的研发工作，整体使用体验较差。体验较差的原因在于将由于通过项目维度拆分了整体「研发中台」这样的一个产品，使各个产品之间是独立的孤岛，系统间相互跳转都是传统意义上的 MPA，跳转需要重新加载整个页面的资源，除了性能是远不如 SPA 应用的并且应用间是没法直接通信，这就进一步增强了用户在使用产品时的割裂感。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;背景和意义总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上两个场景案例，其实可以发现由于 Web 应用在逐步取代传统的 PC 软件时，大规模 Web 应用在面对高复杂度和涉及团队成员广下无法同时保证 DX 和 UX 的困境。传统的分而治之的策略已经无法应对现代 Web 应用的复杂性，因此衍生出了微前端这样一种新的架构模式，与后端微服务相同，它同样是延续了分而治之的设计模式，不过却以全新的方法来实现。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;微前端解决方案&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上一节总结了微前端出现的背景和意义，并且了解了两种传统 Web 应用的研发模式：SPA（Single-page Application）、MPA（Multi-page Application）在涉及人员广和项目复杂度高的场景下带来的劣势，那么期望能有一种新的架构能同时具备 SPA 和 MPA 两种架构优势，并同时提升  DX（developer experience）和 UX（user experience）呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那在理想的情况下，期望能达到，将一个复杂的单体应用以功能或业务需求垂直的切分成更小的子系统，并且能够达到以下能力：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;子系统间的开发、发布从空间上完成隔离&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子系统可以使用不同的技术体系&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子系统间可以完成基础库的代码复用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子系统间可以快速完成通信&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子系统间需求迭代互不阻塞&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子应用可以增量升级&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子系统可以走向同一个灰度版本控制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供集中子系统权限管控&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户使用体验整个系统是一个单一的产品，而不是彼此的孤岛&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;项目的监控可以细化到到子系统&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么基于上面理想情况，如何从零设计一套全新的架构用于解决现代 Web 应用在面对企业级系统遇到的困境呢。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;微前端的整体架构&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如何提供一套既具备 SPA 的用户体验，又具备 MPA 应用带来的灵活性，并且可以实现应用间同灰度，监控也可以细化到子系统的解决方案呢？目前在字节跳动内应用的微前端解决方案「Garfish」就是这样的一套方案 ，该解决方案主要分为三层：部署侧、框架运行时、调试工具，采用的是 SPA 的架构。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;解决方案整体架构&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6779935275080906&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyTyU8s8ytuFos30JdhRhJAicWgtI6vSRSMLPictLvENAHrnOw4Df6pmKSQA1t7iauYjialqlMBhq4lYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1236&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0712328767123287&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyTyU8s8ytuFos30JdhRhJA17qlsRxq84qE71wzBzLbtNsjEg3LYcamvPzicF9VeqbNGYq8rGtfib3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1460&quot;/&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;微前端部署平台&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;部署平台作为微前端研发流程中重要的一环，主要提供了：微前端的服务发现、服务注册、子应用版本控制、多个子应用间同灰度、增量升级子应用、下发子应用信息列表，分析子应用依赖信息提取公共基础库降低不同应用的依赖重复加载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于解决微前端中子应用的独立部署、版本控制和子应用信息管理，通过 Serverless 平台提供的接口或在渲染服务中下发主应用的 HTML 内容中包含子应用列表信息，列表中包括了子应用的详细信息例如：应用 id、激活路径、依赖信息、入口资源等信息，并通过对于子应用的公共依赖进行分析，下发子应用的公共依赖，在运行时获取到子应用的信息后注册给框架，然后在主应用上控制子应用进行渲染和销毁。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyTyU8s8ytuFos30JdhRhJAwsZpI7IKn1K6YerFkeO0hcGsM4Xc9ib0ynlOzcYhAlJmTiahHXBjbY4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;微前端运行时&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Why not iframe&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;谈到微前端绕不开的话题就是为什么不适用 iframe 作为承载微前端子应用的容器，其实从浏览器原生的方案来说，iframe 不从体验角度上来看几乎是最可靠的微前端方案了，主应用通过iframe 来加载子应用，iframe 自带的样式、环境隔离机制使得它具备天然的沙盒机制，但也是由于它的隔离性导致其并不适合作为加载子应用的加载器，iframe 的特性不仅会导致用户体验的下降，也会在研发在日常工作中造成较多困扰，以下总结了 iframe 作为子应用的一些劣势：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用iframe 会大幅增加内存和计算资源，因为 iframe 内所承载的页面需要一个全新并且完整的文档环境&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;iframe 与上层应用并非同一个文档上下文导致&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;主应用劫持快捷键操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事件无法冒泡顶层，针对整个应用统一处理时效&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;事件冒泡不穿透到主文档树上，焦点在子应用时，事件无法传递上一个文档流&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;跳转路径无法与上层文档同步，刷新丢失路由状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;iframe 内元素会被限制在文档树中，视窗宽高限制问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;iframe 登录态无法共享，子应用需要重新登录&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;iframe 在禁用三方 cookie 时，iframe 平台服务不可用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;iframe 应用加载失败，内容发生错误主应用无法感知&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;难以计算出 iframe 作为页面一部分时的性能情况&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;无法预加载缓存 iframe 内容&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无法共享基础库进一步减少包体积&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事件通信繁琐且限制多&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;基于 SPA 的微前端架构&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管难以将 iframe 作为微前端应用的加载器，但是却可以参考其设计思想，一个传统的 iframe 加载文档的能力可以分为四层：文档的加载能力、HTML 的渲染、执行 JavaScript、隔离样式和 JavaScript 运行环境。那么微前端库的基础能力也可以参考其设计思想。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从设计层面采取的是基座+子应用分治的概念，部署平台负责进行服务发现和服务注册，将注册的应用列表信息下发至基座，通过基座来动态控制子系统的渲染和销毁，并提供集中式的模式来完成应用间的通信和应用的公共依赖管理，因此 Garfish 在 Runtime 层面主要提供了以下四个核心能力：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;加载器（Loader）&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;HTML 入口类型，拆解 HTML Dom、Script、Style&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JS 入口类型，提供基础 Dom 容器&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;负责注册平台侧提供的应用列表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;负责加载和解析子应用入口资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;预加载能力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解析子应用导出内容&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;沙箱隔离（Sandbox）&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;提供代码执行能力，收集执行代码时存在的副作用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供销毁收集副作用的能力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持沙箱多实例，收集不同实例的副作用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;路由托管（Router）&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;解决不同应用间的路由不同步问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供路由劫持能力，在主应用上管控子应用路由&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供路由驱动能力来拼装完整的平台的能力&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;子应用通信（Store）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4421875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyTyU8s8ytuFos30JdhRhJAtibSAtvI0nLicTIF3hvbBbZa708OUhXib2icbEob79YOrwnea15ne0FOJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;应用生命周期&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个微前端子应用的生命周期基本可以总结为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;渲染阶段&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;若入口类型为 HTML 类型，将开始解析和拆解子应用资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若入口类型为 JS，创建子应用的挂点 DOM&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;主应用通过路由驱动或手动挂载的方式触发子应用渲染&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开始加载应用的资源内容，并初始化子应用的沙箱运行时环境&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断入口类型&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将子应用存在”副作用“（对当前页面可能产生影响的内容）交由沙箱处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开始渲染子应用的 DOM 树&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;触发子应用的渲染 Hook&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;销毁阶段&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;若路由变化离开子应用的激活范围或主动触发销毁函数，触发应用的销毁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;清除应用在渲染时和运行时产生的副作用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;移除子应用的 DOM 元素&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.9572301425661915&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyTyU8s8ytuFos30JdhRhJA614VicDRaPsoQNNjrdQ2WEgC4UG8Dw3vXrICZXASmNyicrrnV2kuJUyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;982&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;加载器的设计&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加载器的整体设计理念其实与 React-loadable 非常类似，具备以下能力：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;异步加载组件资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以预加载资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以缓存组件资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缓存组件实例&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与组件不同的是微前端作为一种能够将单体应用拆解成多个子应用的架构模式，不同于组件，这些被拆分出去的子应用最好的研发模式是在开发、测试、部署都与宿主环境分离，子应用本身应具备自治能力，那么此时就与 iframe 提供的能力非常类似，iframe 通过加载 HTML 文档的形式加载整个子应用的资源，那么子应用本身就可作为一个独立站点，天然具备独立开发、测试的能力。因此 Garfish 的加载器提供了两种应用入口类型：HTML 类型和 JS 入口类型，但需要注意的是 Garfish 并非像 iframe 一样将其分为了另一个文档流，而是将其与主应用作为同一个文档流处理，用以规避其不再同一个文档流带来的体验感割裂问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 HTML 入口类型天然具备独立、开发、测试的特性，在微前端整体架构设计中，对于跨团队协作而言，最好的研发模式是能降低其沟通成本，而降低沟通成本的最好方式是不沟通，所以一般项目类型都尽可能的推荐用户使用 HTML 的入口类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么针对 HTML 入口类型的加载器需要做一些什么呢，下面是一张浏览器的渲染过程图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.11&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyTyU8s8ytuFos30JdhRhJAHuialvIfuC3x4fPDAUU4SaxSl7VVE1ibzficMjP3johFicC1lByk38OONg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对浏览器的渲染过程也可将其分为：HTML 文本下载、 HTML 拆解为语法树、拆解语法树中具备”副作用的内容“（对当前页面可能产生影响的内容）如 Script、Style、Link 并交由沙箱处理进行后渲染，与一般的子应用不同的是需要子应用提供 provider，provider 中包含了子应用渲染和销毁的生命周期，这两个 Hook 可以应用缓存模式中进一步增强应用的渲染速度和性能。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.81125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyTyU8s8ytuFos30JdhRhJAuu8v9hkSWBAFyz9QtMDFrV3U5kk047ZI6D7oHhjwq4A9GWBIEdS8dQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;沙箱的设计&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;为什么需要沙箱&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实在过去的 Web 应用中是很少提及到沙箱这一概念的，因为组件的开发一般都会由研发通过研发规范来尽可能的去避免组件对当前应用环境造成副作用，诸如：组件渲染后添加了定时器、全局变量、滚动事件、全局样式并且在组件销毁后会及时的清除子应用对当前环境产生的副作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与组件完全不同的是微前端是由多个独立运行的应用组成的架构风格，这些系统可能分别来自不同的技术体系。项目的开发、测试从空间和时间上都是分离的，由于没有 iframe 一样原生能力的隔离很难应用间不发生冲突，这些冲突可能会导致应用发生异常、报错、甚至不可用等状态。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;以 Webpack4 JsonpFunction 为例&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Webpack5 中提供了一个重要的功能就是 Module Federation，随着 Webpack 5 推出 Module Federation ，与 Webpack 4 发生变化的一个重要配置就是 &lt;code&gt;JsonpFunction&lt;/code&gt; 属性变为了 &lt;code&gt;chunkLoadingGlobal&lt;/code&gt;，并且由原来的默认值 &lt;code&gt;webpackJsonp&lt;/code&gt; 变成了默认使用 &lt;code&gt;output.library&lt;/code&gt; 名称或者上下文中的 &lt;code&gt;package.json&lt;/code&gt; 的 包名称(package name)作为唯一值（webpack.js.org/issues/3940）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么会发生这个转变呢，如果了解过 Webpack 构建产物的一定会知道 Webpack 通过全局变量存储了分 chunk 后的产物，用于解决分包 chunk 的加载问题。由于 Webpack 5 引入 Module Federation 页面中可能会同时存在两个以上的 Webpack 构建产物，如果还是通过是通过同一个变量存储要加载的 chunk ，必然会造成产物之间的互相影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 Webpack 4 到 Webpack 5 支持 Module Federation 之后可以发现，在一个基础库尚未考虑默认兼容多实例的场景下，贸然将其作为多实例使用很可能会造成应用无法按照预期运行，更为严重的是你以为其正常运行了其实应用已经发生了严重的内存泄漏或不可预知的情况，倘若将 Webpack 构建产物的应用多次动态的在页面中运行，将会发现已经造成严重的内存泄漏，因为 Webpack 会增量的向全局存储 chunk 的变量上挂载模块以及依赖信息，简单来说就是每次执行 Webpack 构建的子应用代码都会向 webpackJsonp 数组 push 大量的数据，最终造成内存泄漏，直至页面崩溃。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;沙箱的核心能力&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了保证应用能够稳定的运行且互不影响，需要提供安全的运行环境，能够有效地隔离、收集、清除应用在运行期间所产生的副作用，那应用运行期间主要会产生哪些副作用呢，可以将其分为以下几类：全局变量、全局事件、定时器、网络请求、localStorage、Style 样式、DOM 元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Garfish Runtime 中的沙箱主要能力也是围绕在这一块的能力建设上，针对子应用可能产生的副作用类型主要分为两类，一类是：静态副作用、另一类则是：动态副作用。这里静态副作用和动态副作用分别指的是什么呢，静态副作用指的是 HTML 中静态标签内容例如：Script 标签、Style 标签、Link 标签，这些内容属于在 HTML 文档流中就包含的，另外一部分副作用属于动态副作用，动态副作用指的是由 JavaScript 动态创建出来的，例如 JavaScript 可以动态创建 Style、动态创建 Script、动态创建 Link、动态执行代码、动态添加 DOM 元素、添加全局变量、添加定时器、网络请求、localStorage 等对当前页面产生副作用的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对子应用的静态副作用的收集比较简单，Loader 核心模块上已经提供了子应用入口资源类型的分析和拆解，可以从子应用 DOM 树中轻松拆解获取副作用内容，那么对于静态副作用已经可以完成有效的收集、清除，但是尚未具备隔离的能力。动态创建的副作用都是通过 JavaScript 来动态创建的，需要收集到 JavaScript 运行时产生的副作用，并提供副作用的隔离和销毁能力。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;沙箱设计的两种思路&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Garfish 微前端中，如何有效收集、隔离、清除应用的副作用是保障应用能够平稳运行的核心能力之一。沙箱的主要能力也在于能够捕获动态创建的副作用，对应用的副作用进行隔离和清除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如何能够有效的捕获到动态创建的副作用、收集、并隔离呢？目前 Garfish 提供了两种设计思路，一种是快照模式，另外一种是 VM 模式。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;快照沙箱&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顾名思义，在应用运行前通过快照的模式来保存当前执行环境，在应用销毁后恢复回应用之前的执行环境，用于实现应用间副作用的隔离和清除。类似于 “SL 大法”，通过 save 存储环境，通过 load 加载环境的模式。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;代码实现思路&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1922246220302375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyTyU8s8ytuFos30JdhRhJAylw2z6P98z1067Hjq0QYwnC3Y3HU2qgzBsicsfIictO0rdwe76ichdxOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1852&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心设计思想简述：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;针对每一种副作用提供一个 Patch 类，这个类需要提供 save 和 load 两个方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Save 对应着该副作用的环境快照存储，Load 对应着销毁该副作用的销毁恢复环境&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并且针对每一种 Patch 还可以存储其在运行期间发生的变化，在优化场景时并不用所有代码，仅恢复执行环境即可&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;VM 沙箱&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过快照沙箱的最简化的核心实现后可以发现，它的设计理念依赖于整个代码的执行属于线性的过程，即：存储执行环境=&amp;gt;执行具备副作用的代码=&amp;gt;恢复执行环境，但在实际的场景中对于应用的划分并以页面为维度划分，同一个页面可能存在多个应用，所以它的执行顺序并非线性，可能同时存在多个快照沙箱的实例环境，也就是快照沙箱多实例，以下面代码举例：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9295774647887324&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyTyU8s8ytuFos30JdhRhJAMJ2qpSTWVfwQn7y5SqhEmyIFZawCTLDfANtFDlX35iaayERQwJ0moMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1136&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的代码可以发现，在同时运行多个快照沙箱实例时，在代码执行顺序非线性的场景下，并不能有效的收集和处理应用的副作用，也基于此快照沙箱无法使用在非线性呢多实例的场景中，因此也进一步推出了 VM（virtual machine） 沙箱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维基百科关于 VM  的解释：在计算机科学中的体系结构里，是指一种特殊的软件，可以在计算机平台和终端用户之间创建一种环境，而终端用户则是基于虚拟机这个软件所创建的环境来操作其它软件。虚拟机（VM）是计算机系统的仿真器，通过软件模拟具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统，能提供物理计算机的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Node 中也提供了 VM 模块，不过不过不同于传统的 VM，它并不具备虚拟机那么强的隔离性，并没有从模拟完整的硬件系统，仅仅将指定代码放置了特定的上下文中编译并执行代码，所以它无法用于不可信来源的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考 Node 中 VM 模块的设计，以及 JavaScript 词法作用域 的特性，可以设计出 VM 沙箱，不过与传统的 VM 差异也同样存在，它并能执行不可信的代码，因为它的隔离能力仅限于将其运行在一个指定的上下文环境中。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从而得出以下设计&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8141414141414142&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyTyU8s8ytuFos30JdhRhJANOXUXs73h17FZBicQQvzkzdn9VBpfBPyVDXWiaIic0A3XnIYc7EdicR2hA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;990&quot;/&gt;&lt;img data-ratio=&quot;0.6959459459459459&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyTyU8s8ytuFos30JdhRhJA0KyJdy3vL6QEE2oKfT4gNNWzEksRITEtyA0MuMFsIia0WfIkCopRbCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1184&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;隔离环境需要哪些上下文&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对副作用的类型：全局变量、全局事件、定时器、网络请求、localStorage、Style 样式、DOM 元素，分别提供了全新的执行上下文：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Window&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;document&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;收集 DOM 副作用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;收集 Style 副作用，进行处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;收集 Script，继续放置沙箱处理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用于捕获动态创建的 DOM 节点、Style、Script&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;timeout、interval&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;localstorage&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;listener&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;新的执行上下文哪里来&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新的执行上下文有两个来源，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 iframe 创建后需要需要较多的内存资源和计算资源，而微前端中的 VM 沙箱并不需要一个完全的执行上下文，所以可以基于当前环境。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9919354838709677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyTyU8s8ytuFos30JdhRhJAicKyEUZ6A9zdW7hUEQM4ORNhU7Lu1dIiaMGqIg19M9FhWDgAXVTxzTaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;992&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;快照沙箱和 VM 沙箱能力对比&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46924428822495606&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyTyU8s8ytuFos30JdhRhJAsYxxTS7W96aAKShE3llQ8KoMRq4emnPGGUwUuMsZpk15aPCHptr19w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1138&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;路由系统的设计&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在于现代 MVC 的设计思想，前端框架的设计思想也一直在发生变更，现代 Web 前端框架提供的最经典的能力莫过于将 MVC 中的 Constroller 变为了 Router，目前几乎主流的前端框架都支持路由驱动视图，仅提供一个 Router Map 路由表，无需关注控制任何路由状态即可完成跳转后的路由更新。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过微前端出现的背景和意义，可以了解到微前端主要是用于解决：应用增量升级、多技术体系并存、构建大规模企业级 Web 应用而诞生的。那么在基于 SPA 的微前端架构中也可以了解到，目前微前端主要是采用应用分而治之 + 动态加载 + SPA 应用的模式来解决大规模应用带来的一系列问题。在以组件为颗粒度的 SPA 应用中组件内部是不需要关心路由的，但是在微前端中主要通过应用维度来拆分，那么拆分的应用也可能是一个独立的 SPA 应用，那么此时主应用与子应用的关系如何编排呢？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;微前端应用中理想的路由调度&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设存在一个 Garfish 站点，这个站点它是由主应用+三个子应用构成，主应用的 basename 为 &lt;code&gt;/demo&lt;/code&gt;，并存在三个 Tab 分别指向跳转至不同的应用，理想的路由效果：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在点击 vue-app Tab，跳转至 &lt;code&gt;/demo/vue-app&lt;/code&gt; 路由后，分别激活 &lt;code&gt;vue-app&lt;/code&gt; 下，为 Vue 类型的 A 应用和 B 应用，并激活 A 应用和 B 应用中的 Home 组件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;点击 React-app Tab 进入到 &lt;code&gt;/demo/react-app&lt;/code&gt; 路由后，分别激活 &lt;code&gt;react-app&lt;/code&gt; 下，为 React 类型的 C 应用，并激活 C 应用的 Home 组件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在激活 C 应用的基础上，点击 Detail 按钮，跳转至 &lt;code&gt;/demo/react-app/detail&lt;/code&gt;，并激活 C 应用的 detail 组件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;点击浏览器返回按钮展示，跳转 &lt;code&gt;/demo/react-app/detail&lt;/code&gt;，并激活 C 应用的 Home 组件，至此完成浏览器的基本路由跳转能力。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/FuxFc4JogFyTyU8s8ytuFos30JdhRhJAdpJVyKVciciaTic1Nd3tgWA9uGM0FoPvNTBG53kK8A4JuE5jg34OK2Keg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;不考虑任何路由处理的场景&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设存在一个 Garfish 站点，这个站点它是由主应用+一个子应用构成。由于 Garfish 采用的是  SPA 架构，子应用与主应用所处于同一个执行上下文，子应用的路由原样反应在主应用上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4714285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyTyU8s8ytuFos30JdhRhJAXdhPAeAwGDicWnjibx4IgVPDhxUW0QCic2H8yzibqE6aYNezLWStd7HMrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么此时分别跳转到：&lt;code&gt;/home&lt;/code&gt;、&lt;code&gt;/detail&lt;/code&gt;路由会发现哪些问题呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;假定跳转的方法可以同时触发主子应用路由更新，主应用路由和子应用路由会同时发生抢占情况，后渲染的组件会覆盖先渲染的路由组件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在触发路由跳转方后，只有主应用视图触发刷新、只有子应用视图刷新、或都不刷新&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;「视图的路由状态维护在框架内部」，通过原生跳转无法触发视图更新&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时当分别跳转到：&lt;code&gt;/home&lt;/code&gt;、&lt;code&gt;/detail&lt;/code&gt;、&lt;code&gt;/test&lt;/code&gt; 路由时分别触发对应的组件视图，但是倘若子应用路由中也存在 &lt;code&gt;/detail&lt;/code&gt;视图呢，由于应用的开发采用分治的模式，应用的开发从空间和时间上都是分离的，无法保证应用间的路由不发生路由抢占的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;「通过 history 路由跳转无法保证应用能够触发视图更新」，在通过 history api 进行路由跳转时，是无法触发应用视图更新，假设存在一个 React 应用 A，存在一个组件视图 Test，分别通过 React 提供的路由方法跳转和原生的路由跳转进行观察：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6713286713286714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyTyU8s8ytuFos30JdhRhJAeicDFveWu8zORp2pgzicz723CzDtbzbiczQhCqk50Eic0lpd6qnYicuic2DQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1144&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;Hash 和 History 路由模式&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前主流的 SPA 前端应用基本上都支持两种路由模式，一种是：hash 模式、另一种则是 History 路由模式，两者的优劣和使用并不在本文的讨论范围之内，这里仅做在微前端这种分离式开发模式下的介绍，在微前端这种分离式 SPA 应用开发的模式下该选择哪种路由模式，以及多 SPA 应用下他们的路由应该如何编排：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设站点地址为：&lt;/span&gt;&lt;code&gt;http://garfish.bytedance.net&lt;/code&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;正常路由情况&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主应用 history 模式、子应用 history 模式&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;主应用（&lt;/span&gt;&lt;code&gt;basename: /example&lt;/code&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;主应用所有路由基于：&lt;/span&gt;&lt;code&gt;http://garfish.bytedance.net/example&lt;/code&gt;&lt;span&gt;例&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;例如跳转到：/appA，&lt;/span&gt;&lt;code&gt;http://garfish.bytedance.net/example/appA/&lt;/code&gt;&lt;span&gt;子&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;子应用（&lt;/span&gt;&lt;code&gt;basename: /example/appA&lt;/code&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;子应用所有路由基于：&lt;/span&gt;&lt;code&gt;http://garfish.bytedance.net/example/appA&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;跳转到子应用的 /detail 页，&lt;/span&gt;&lt;code&gt;http://garfish.bytedance.net/example/appA/detail&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;特点：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;当主子应用分别为 history 模式时，子应用的路由基于主应用基础路由并带上自己的业务路由&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;路由同步到主应用路由上，通过 子应用 scope 命名空间隔离（子应用 A，提供 appA 的 scope）主应用和其他应用的路由冲突，并将子应用&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;路径符合用户和开发者认知和理解&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;支持嵌套层级使用，并继续通过 scope 的命名空间保证路由可读&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主应用 history 模式、子应用 hash 模式&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;主应用（&lt;/span&gt;&lt;code&gt;basename: /example&lt;/code&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;主应用所有路由基于：&lt;/span&gt;&lt;code&gt;http://garfish.bytedance.net/example&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;例如跳转到：/appA，&lt;/span&gt;&lt;code&gt;http://garfish.bytedance.net/example/appA/&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;子应用（&lt;/span&gt;&lt;code&gt;basename: /example/appA&lt;/code&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;子应用所有路由基于：&lt;/span&gt;&lt;code&gt;http://garfish.bytedance.net/example/appA&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;从主应用：&lt;/span&gt;&lt;code&gt;http://garfish.bytedance.net/example/appA&lt;/code&gt;&lt;span&gt;，跳转到子应用的 &lt;span&gt;/detail&lt;/span&gt; 页，&lt;/span&gt;&lt;code&gt;http://garfish.bytedance.net/example/appA#/detail&lt;/code&gt;&lt;span&gt;特&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;特点：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;在一定程度上具备主子应用都为 history 模式的优势，不支持嵌套层级使用&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;目前多数框架都不支持以 hash 值作为 basename&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;可读性尚可&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;异常路由情况&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主应用 hash 模式、子应用 history 模式&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;主应用（&lt;/span&gt;&lt;code&gt;basename: /example&lt;/code&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;主应用所有路由基于：&lt;/span&gt;&lt;code&gt;http://garfish.bytedance.net/example&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;例如跳转到：/detail，&lt;/span&gt;&lt;code&gt;http://garfish.bytedance.net/example#/appA&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;子应用（&lt;/span&gt;&lt;code&gt;basename: /example#/appA&lt;/code&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;子应&lt;/span&gt;&lt;span&gt;用所有路由基于：&lt;/span&gt;&lt;code&gt;http://garfish.bytedance.net/example#/appA&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;跳转到子应用的 /detail 页，&lt;/span&gt;&lt;code&gt;http://garfish.bytedance.net/example/detail#/appA&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;特点：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;「路由混乱」，不符合用户和开发者直觉&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;目前多数框架都不支持以 hash 值作为 basename&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主应用 hash 模式、子应用 hash 模式&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;主应用（&lt;/span&gt;&lt;code&gt;basename: /example&lt;/code&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;主应用所有路由基于：&lt;/span&gt;&lt;code&gt;http://garfish.bytedance.net/example&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;例如跳转到：/detail，&lt;/span&gt;&lt;code&gt;http://garfish.bytedance.net/example#/appA&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;子应用（&lt;/span&gt;&lt;code&gt;basename: /example#/appA&lt;/code&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;子应用所有路由基于：&lt;/span&gt;&lt;code&gt;http://garfish.bytedance.net/example#/appA&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;跳转到子应用的 /detail 页，&lt;/span&gt;&lt;code&gt;http://garfish.bytedance.net/example#/detail&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;特点：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;「路由混乱」，不符合用户和开发者直觉&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;目前多数框架都不支持以 hash 值作为 basename&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;可能与主应用或其他子应用发生路由冲突&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;Garfish  Router 如何处理路由&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面理想的路由模式案例发现，微前端应用拆分成子应用后，子应用路由应具备自治能力，可以充分的利用应用解耦后的开发优势，但与之对应的是应用间的路由可能会发生冲突、两种路由模式下可能产生用户难以理解的路由状态、无法激活不同前端框架的下带来的视图无法更新等问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;目前 Garfish 主要提供了以下四条策略&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;提供 Router Map，减少典型中台应用下的开发者理解成本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为不同子应用提供不同的 basename 用于隔离应用间的路由抢占问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;路由发生变化时能准确激活并触发应用视图更新&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;Router Map 降低开发者理解成本&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在典型的中台应用中，通常可以将应用的结构分为两块，一块是菜单另一块则是内容区域，依托于现代前端 Web 应用的设计理念的启发，通过提供路由表来自动化完成子应用的调度，将公共部分作为拆离后的子应用渲染区域。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41284403669724773&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyTyU8s8ytuFos30JdhRhJAlXDiaDgqYwUQ7QGoGwnHpyJSCTI2aEEMFH1L9g1PJciaynvmE1wrxPBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1090&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0440528634361232&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyTyU8s8ytuFos30JdhRhJAvOMbiaH3ukfq6TgUvFmG87R2OjDaBN1DNVgLjMMAAjicLcaY59ctR4uA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;908&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;自动计算出子应用所需的 basename&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当应用处于激活状态时，根据应用的激活条件自动计算出应用所需的基础路径，并在渲染时告诉框架，以便于应用间路由不发生冲突。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.452970297029703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FuxFc4JogFyTyU8s8ytuFos30JdhRhJAywABjAXsqLJm80Z09zqeKsjm42fp5ugk2d5qIbQHvTLsNceVqWf4cQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1616&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;如何有效的触发不同应用间的视图更新&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前主流框架实现路由的方式并不是监听路由变化触发组件更新，让开发者通过框架包装后的 API 进行跳转，并内部维护路由状态，在使用框架提供 API 方法发生路由更新时，内部状态发生变更触发组件更新。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于框架的路由状态分别维护在各自的内部，那么如何保证在路由发生变化时能及时有效的触发应用的视图更新呢，答案是可以的，目前主要有两种实现策略：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;收集框架监听的 popstate 事件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主动触发 popstate 事件&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为目前支持 SPA 应用的前端框架都会监听浏览器后退事件，在浏览器后退时根据路由状态触发应用视图的更新，那么其实也可以利用这种能力主动触发应用视图的更新，可以通过收集框架的监听事件，也可以触发 popstate 来响应应用的 popstate 事件&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;基于「现代 Web 框架」的微前端最佳实践&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微前端作为一种全新的 Web 应用类型，不同于以往传统的 Web 应用开发，微前端需要采用主子应用分治的开发模式后带来了一系列新的挑战，这些挑战包括但不限于：主子应用开发调试、普通 Web 应用如何快速变为微前端应用、如何支持微前端应用 SSR、主子应用数据通信触发视图更新。&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzkxNDIzNTg4MA==&amp;amp;mid=2247484407&amp;amp;idx=1&amp;amp;sn=c3706cdacefe4fd0ee372804ce53b4ce&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Modern.js&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Modern.js&lt;/a&gt; 作为 Garfish 上层的现代 Web 框架，能够很好的解决这些问题，并提供开箱即用的开发体验。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;微前端应用的调试开发&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于微前端应用采用分治的开发策略，应用间的维护和开发可能在时间和空间上都是分离的，那么在开发环境时启动整个微前端项目的所有主子应用，是一个并不明智的策略，不仅需要 clone 其他仓库并完成应用的运行，还要保证其代码的时效性。Modern.js 提供了更优的的策略：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;某些子应用需要更新时&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;主应用线上环境&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要开发的子应用线下环境&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不需要开发的子应用上线&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;主应用需要更新时&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上更优的调试策略，可以保证开发者仅运行自己的关注的应用即可。那么如何达到这种更优的，可以采用应用列表的下发模式，框架运行时加载下发的应用列表，在开发主应用时拉取线上的应用列表，在开发某个子应用时代理代理列表中的资源为子应用的列表。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;传统 Web 应用支持微前端模式&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过微前端运行时章节可以发现传统 Web 应用与微前端应用间进行切换成本并不高，但需要研发关注应用的路由的调度、应用的生命周期导出、额外的构建配置、应用通信数据触发视图更新，微前端模式应用和传统 Web 应用间如何进行切换都存在一定的学习和理解成本。&lt;/p&gt;&lt;p&gt;在 Modern.js 中作为上层框架集成了 Garfish，原生支持微前端应用，可以通过简单配置即可完成微前端应用类型的转换，帮助用户快速搭建应用基础结构，以降低其学习成本，快速生成微前端应用。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;微前端应用如何支持 SSR&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微前端作为一种全新的架构模式，其分治设计模式除了带来的诸多优点外，但与之对应的是引入了新的问题，如何支持传统 Web 应用提供的 SSR 能力，由于微前端采用了分治的开发模式，应用拆分成了多个子应用，那么需要实现整体应用的 SSR 能力，则需要与具体的 Web 框架相结合，通过制定微前端应用的加载规则，达到微前端应用也能有效的实现 SSR 能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Modern.js 作为 Garfish 的上层框架，提供更开箱即用的上层能力 ，并解决了以上微前端不同于传统 Web 应用开发后带来的弊端，文末有关于 &lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzkxNDIzNTg4MA==&amp;amp;mid=2247484407&amp;amp;idx=1&amp;amp;sn=c3706cdacefe4fd0ee372804ce53b4ce&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Modern.js&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Modern.js&lt;/a&gt; 的发布预告，可以了解并关注。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;微前端的优点&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;适用于大规模 Web 应用的开发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更快的开发速度&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持迭代可开发和增强升级&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拆解后的部分降低了开发者的理解成本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同时具备 UX 和 DX 的开发模式&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;微前端的缺点&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;复杂度从代码转向基础设施&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;整个应用的稳定性和安全性变得更加不可控&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;具备一定的学习和了解成本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要建立全面的微前端周边设施，才能充分发挥其架构的优势&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;何时使用微前端&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;大规模企业级 Web 应用开发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;跨团队及企业级应用协作开发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;长期收益高于短期收益&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不同技术选型的项目&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内聚的单个产品中部分需要独立发布、灰度等能力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;微前端的目标并非用于取代 iframe&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;总结&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微前端概念的出现是前端发展的必然阶段，PC 互联网转向移动互联网时代时，PC 的场景并未完全被消灭，反而转向了衍生出了更多沉浸感更高、体验感更强的应用，与之对应的应该是出现新的架构模式来应对这些应用规模的增长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微前端也并非银弹，采用微前端后复杂度并未凭空消失，而是由代码转向了基础设施，对架构设计带来了更大的挑战，并且在新的架构下需要设计并提供更多的周边工具和生态来助力这一新的研发模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文更多的是从背景和设计层面讲清楚微前端解决方案应具备哪些能力，以及核心模块的设计。每一部分并未包含过于详细的细节，如果想要了解「微前端运行时」详细设计，可以通过 https://github.com/modern-js-dev/garfish 仓库了解细节。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;参考&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如何设计微前端中的主子路由调度：https://mp.weixin.qq.com/s/TAXP7ipDdtb2Jb-L3QHszA&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何取巧实现一个沙箱：https://mp.weixin.qq.com/s/Mg3fU0WvZUQnlWHdxc-b5A&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;微服务架构及其最重要的 10 个设计模式：https://www.infoq.cn/article/kdw69bdimlx6fsgz1bg3&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;single-spa：https://github.com/single-spa/single-spa&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Modern.js 开源预告&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Modern.js 和 Garfish 都是字节跳动 Web Infra 发起的「现代 Web 工程体系」开源项目，Modern.js 原生支持微前端，在 Garfish 基础上提供了完整的微前端最佳实践。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzkxNDIzNTg4MA==&amp;amp;mid=2247484407&amp;amp;idx=1&amp;amp;sn=c3706cdacefe4fd0ee372804ce53b4ce&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Modern.js &quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Modern.js &lt;/a&gt;计划在 10 月 14 号发布 1.0.0 版和上线文档站，欢迎关注和参与。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;👇 点击 「阅读原文」，查看 Garfish 仓库&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b7819307fdc2a5679a276940ae18c063</guid>
<title>[推荐] 彻底弄懂 base64 的编码与解码原理</title>
<link>https://toutiao.io/k/21wnwdq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;p/&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0e20bc6a360cb9b403f1efa04a99af31_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;319&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-0e20bc6a360cb9b403f1efa04a99af31_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;319&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-0e20bc6a360cb9b403f1efa04a99af31_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-0e20bc6a360cb9b403f1efa04a99af31_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;背景&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;base64的编码原理网上讲解较多，但解码原理讲解较少，并且没有对其中的内部实现原理进行剖析。想要彻底了解base64的编码与解码原理，请耐心看完此文，你一定会有所收获。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;涉及算法与逻辑运算概念&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在探究base64编码原理和解码原理的过程中，我们首先需要了解下面会用到的算法和逻辑运算的概念，这样才能真正的吃透base64的编码原理和解码原理，体会到其中算法的精妙，甚至是在思考的过程中得到意想不到的收获。不清楚base64编码表和ascII编码表的同学可直接前往文末查看。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;短除法&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;短除法运算方法是先用一个除数除以能被它除尽的一个质数，以此类推，除到商是质数为止。&lt;br/&gt;通过短除法，十进制数可以不断除以2得到多个余数。最后，将余数从下到上进行排列组合，得到二进制数，我们以字符n对应的ascII编码110为例。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;    110 / 2  = 55...0
    55  / 2  = 27...1
    27  / 2  = 13...1
    13  / 2  = 6...1
    6   / 2  = 3...0
    3   / 2  = 1...1
    1   / 2  = 0...1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将余数从下到上进行排列组合，得到字符n对应的ascII编码110转二进制为1101110，因为一字节对应8位(bit), 所以需要向前补0补足8位，得到01101110。其余字符同理可得。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;按权展开求和&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;按权展开求和, 8位二进制数从右到左，次数是0到7依次递增, 基数*底数次数，从左到右依次累加，相加结果为对应十进制数。我们以二进制数01101110转10进制为例：&lt;/p&gt;&lt;blockquote&gt;(01101110)2 = 0 * 20 + 1 * 21 + 1 * 22 + 1 * 23 + 0 * 24 + 1 * 25 + 1 * 26 + 0 * 27&lt;/blockquote&gt;&lt;h3&gt;&lt;b&gt;位概念&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;二进制数系统中，每个0或1就是一个位(bit，比特)，也叫存储单元，位是数据存储的最小单位。其中8bit就称为一个字节（Byte）。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;移位运算符&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;移位运算符在程序设计中，是位操作运算符的一种。移位运算符可以在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种：&amp;lt;&amp;lt;(左移)、&amp;gt;&amp;gt;(带符号右移)和&amp;gt;&amp;gt;&amp;gt;(无符号右移)。我们在base64的编码和解码过程中操作的又是正数，所以仅使用&amp;lt;&amp;lt;(左移)、&amp;gt;&amp;gt;(带符号右移)两种运算符。&lt;/p&gt;&lt;blockquote&gt;1.左移运算：是将一个二进制位的操作数按指定移动的位数向左移动，移出位被丢弃，右边移出的空位一律补0。&lt;br/&gt;2.右移运算：是将一个二进制位的操作数按指定移动的位数向右移动，移出位被丢弃，左边移出的空位一律补0，或者补符号位，这由不同的机器而定。在使用补码作为机器数的机器中，正数的符号位为0，负数的符号位为1。&lt;/blockquote&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;我们用大白话来描述左移位，一共有8个座位，坐了8个人，在8个座位不动的情况下，现在我让这8个人往左挪2个座位，于是最左边的两个人站了起来，没有座位坐，而最右边空出来了两个座位。移位操作就相当于站起来的人出局，留出来的空位补0.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 左移
    01101000 &amp;lt;&amp;lt; 2 -&amp;gt; 101000(左侧移出位被丢弃) -&amp;gt; 10100000(右侧空位一律补0)
    // 右移
    01101000 &amp;gt;&amp;gt; 2 -&amp;gt; 011010(右侧移出位被丢弃) -&amp;gt; 00011010(左侧空位一律补0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;与运算、或运算&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;与运算、或运算都是计算机中一种基本的逻辑运算方式。&lt;/p&gt;&lt;blockquote&gt;1.与运算：符号表示为&amp;amp;。运算规则：两位同时为“1”，结果才为“1”，否则为0&lt;br/&gt;2.或运算：符号表示为｜。运算规则：两位只要有一位为“1”，结果就为“1”，否则为0&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;什么是base64编码&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Base64编码是将字符串以每3个8比特(bit)的字节子序列拆分成4个6比特(bit)的字节(6比特有效字节，最左边两个永远为0，其实也是8比特的字节)子序列，再将得到的子序列查找Base64的编码索引表，得到对应的字符拼接成新的字符串的一种编码方式。&lt;/p&gt;&lt;p&gt;每3个8比特(bit)的字节子序列拆分成4个6比特(bit)的字节的拆分过程如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-eb270dec0d0e62bd02176a571f3f4ae7_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;938&quot; data-rawheight=&quot;72&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-eb270dec0d0e62bd02176a571f3f4ae7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;938&quot; data-rawheight=&quot;72&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-eb270dec0d0e62bd02176a571f3f4ae7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-eb270dec0d0e62bd02176a571f3f4ae7_b.png&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;b&gt;为什么base64编码后的大小是原来的4/3倍&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;因为6和8的最大公倍数是24，所以3个8比特的字节刚好可以拆分成4个6比特的字节，3&lt;i&gt;8 = 6&lt;/i&gt;4。计算机中，因为一个字节需要8个存储单元存储，所以我们要把6个比特往前面补两位0，补足8个比特。如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-32b25ec16c8a06bb3659cbf4a3216624_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;73&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-32b25ec16c8a06bb3659cbf4a3216624_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;73&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-32b25ec16c8a06bb3659cbf4a3216624_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-32b25ec16c8a06bb3659cbf4a3216624_b.png&quot;/&gt;&lt;/figure&gt;&lt;p&gt;很明显，补足后所需的存储单元为32个，是原来所需的24个的4/3倍。现在大家明白为什么base64编码后的大小是原来的4/3倍了吧。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;为什么命名为base64呢？&lt;/b&gt;&lt;/h3&gt;&lt;blockquote&gt;因为6位(bit)的二进制数有2的6次方个,也就是二进制数(00000000-00111111)之间的代表0-63的64个二进制数。&lt;/blockquote&gt;&lt;h3&gt;&lt;b&gt;不是说一个字节是用8位二进制表示的吗，为什么不是2的8次方？&lt;/b&gt;&lt;/h3&gt;&lt;blockquote&gt;因为我们得到的8位二进制数的前两位永远是0，真正的有效位只有6位，所以我们所能够得到的二进制数只有2的6次方个。&lt;/blockquote&gt;&lt;h3&gt;&lt;b&gt;Base64字符是哪64个？&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;Base64的编码索引表，字符选用了&quot;A-Z、a-z、0-9、+、/&quot; 64个可打印字符来代表(00000000-00111111)这64个二进制数。即&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;    let base64EncodeChars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;编码原理&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们不妨自己先思考一下，要把3个字节拆分成4个字节可以怎么做？你的实现思路和我的实现思路有哪个不同，我们之间又会碰出怎样的火花？&lt;/p&gt;&lt;h3&gt;&lt;b&gt;流程图&lt;/b&gt;&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ff904d3eefb58c00ea4c5c440d07ae37_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;430&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-ff904d3eefb58c00ea4c5c440d07ae37_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;430&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-ff904d3eefb58c00ea4c5c440d07ae37_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-ff904d3eefb58c00ea4c5c440d07ae37_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;b&gt;思路&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;分析映射关系：abc -&amp;gt; xyzi。我们从高位到低位添加索引来分析这个过程&lt;/p&gt;&lt;ul&gt;&lt;li&gt;x: (前面补两个0)a的前六位 =&amp;gt; 00a7a6a5a4a3a2&lt;/li&gt;&lt;li&gt;y: (前面补两个0)a的后两位 + b的前四位 =&amp;gt; 00a1a0b7b6b5b4&lt;/li&gt;&lt;li&gt;z: (前面补两个0)b的后四位 + c的前两位 =&amp;gt; 00b3b2b1b0c7c6&lt;/li&gt;&lt;li&gt;i: (前面补两个0)c的后六位 =&amp;gt; 00c5c4c3c2c1c0通过上述的映射关系，我们很容易得到下面的实现思路：&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;将字符对应的ascII编码转为8位二进制数&lt;/li&gt;&lt;li&gt;将每三个8位二进制数进行以下操作&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;将第一个数右移位2位，得到第一个6位有效位二进制数&lt;/li&gt;&lt;li&gt;将第一个数 &amp;amp; 0x3之后左移位4位，得到第二个6位有效位二进制数的第一个和第二个有效位，将第二个数 &amp;amp; 0xf0之后右移位4位，得到第二个6位有效位二进制数的后四位有效位，两者取且得到第二个6位有效位二进制&lt;/li&gt;&lt;li&gt;将第二个数 &amp;amp; 0xf之后左移位2位，得到第三个6位有效位二进制数的前四位有效位，将第三个数 &amp;amp; 0xC0之后右移位6位，得到第三个6位有效位二进制数的后两位有效位，两者取且得到第三个6位有效位二进制&lt;/li&gt;&lt;li&gt;将第三个数 &amp;amp; 0x3f，得到第四个6位有效位二进制数&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;将获得的6位有效位二进制数转十进制，查找对应base64字符&lt;/li&gt;&lt;p&gt;我们以hao字符串为例，观察base64编码的过程，我们将上面转换通过代码逻辑分析实现吧。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;代码实现&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 输入字符串
let str = &#x27;hao&#x27;
// base64字符串
let base64EncodeChars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;
// 定义输入、输出字节的二进制数
let char1, char2, char3, out1, out2, out3, out4, out
// 将字符对应的ascII编码转为8位二进制数
char1 = str.charCodeAt(0) &amp;amp; 0xff // 104  01101000
char2 = str.charCodeAt(1) &amp;amp; 0xff // 97  01100001
char3 = str.charCodeAt(2) &amp;amp; 0xff // 111  01101111
// 输出6位有效字节二进制数
6out1 = char1 &amp;gt;&amp;gt; 2 // 26  011010
out2 = (char1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4 | (char2 &amp;amp; 0xf0) &amp;gt;&amp;gt; 4 // 6  000110
out3 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 2 | (char3 &amp;amp; 0xc0) &amp;gt;&amp;gt; 6 // 5  000101
out4 = char3 &amp;amp; 0x3f // 47 101111

out = base64EncodeChars[out1] + base64EncodeChars[out2] + base64EncodeChars[out3] + base64EncodeChars[out4] // aGFv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;算法剖析&lt;/p&gt;&lt;ol&gt;&lt;li&gt;out1: char1 &amp;gt;&amp;gt; 201101000 -&amp;gt; 00011010&lt;br/&gt;&lt;/li&gt;&lt;li&gt;out2 = (char1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4 | (char2 &amp;amp; 0xf0) &amp;gt;&amp;gt; 4// 且运算&lt;br/&gt;01101000        01100001&lt;br/&gt;00000011        11110000&lt;br/&gt;--------        --------&lt;br/&gt;00000000        01100000&lt;br/&gt;&lt;br/&gt;// 移位运算后得&lt;br/&gt;00000000        00000110&lt;br/&gt;&lt;br/&gt;// 或运算&lt;br/&gt;00000000&lt;br/&gt;00000110&lt;br/&gt;--------&lt;br/&gt;00000110&lt;br/&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;第三个字符第四个字符同理&lt;/p&gt;&lt;p&gt;整理上述代码，扩展至多字符字符串&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 输入字符串
let str = &#x27;haohaohao&#x27;
// base64字符串
let base64EncodeChars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;

// 获取字符串长度
let len = str.length
// 当前字符索引
let index = 0
// 输出字符串
let out = &#x27;&#x27;
while(index &amp;lt; len) {
    // 定义输入、输出字节的二进制数
    let char1, char2, char3, out1, out2, out3, out4
    // 将字符对应的ascII编码转为8位二进制数
    char1 = str.charCodeAt(index++) &amp;amp; 0xff // 104  01101000
    char2 = str.charCodeAt(index++) &amp;amp; 0xff // 97  01100001
    char3 = str.charCodeAt(index++) &amp;amp; 0xff // 111  01101111
    // 输出6位有效字节二进制数
    out1 = char1 &amp;gt;&amp;gt; 2 // 26  011010
    out2 = (char1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4 | (char2 &amp;amp; 0xf0) &amp;gt;&amp;gt; 4 // 6  000110
    out3 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 2 | (char3 &amp;amp; 0xc0) &amp;gt;&amp;gt; 6 // 5  000101
    out4 = char3 &amp;amp; 0x3f // 47 101111

    out = out + base64EncodeChars[out1] + base64EncodeChars[out2] + base64EncodeChars[out3] + base64EncodeChars[out4] // aGFv
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;原字符串长度不是3的整倍数的情况，需要特殊处理&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;    ...
    char1 = str.charCodeAt(index++) &amp;amp; 0xff // 104  01101000
    if (index == len) {
        out2 = (char1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4
        out = out + base64EncodeChars[out1] + base64EncodeChars[out2] + &#x27;==&#x27;
        return out
    }
    char2 = str.charCodeAt(index++) &amp;amp; 0xff // 97  01100001
    if (index == len) {
        out1 = char1 &amp;gt;&amp;gt; 2 // 26  011010
        out2 = (char1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4 | (char2 &amp;amp; 0xf0) &amp;gt;&amp;gt; 4 // 6  000110
        out3 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 2
        out = out + base64EncodeChars[out1] + base64EncodeChars[out2] + base64EncodeChars[out3] + &#x27;=&#x27;
        return out
    }
    ...

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;全部代码&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;function base64Encode(str) {
    // base64字符串
    let base64EncodeChars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;

    // 获取字符串长度
    let len = str.length
    // 当前字符索引
    let index = 0
    // 输出字符串
    let out = &#x27;&#x27;
    while(index &amp;lt; len) {
        // 定义输入、输出字节的二进制数
        let char1, char2, char3, out1, out2, out3, out4
        // 将字符对应的ascII编码转为8位二进制数
        char1 = str.charCodeAt(index++) &amp;amp; 0xff
        out1 = char1 &amp;gt;&amp;gt; 2
        if (index == len) {
            out2 = (char1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4
            out = out + base64EncodeChars[out1] + base64EncodeChars[out2] + &#x27;==&#x27;
            return out
        }
        char2 = str.charCodeAt(index++) &amp;amp; 0xff
        out2 = (char1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4 | (char2 &amp;amp; 0xf0) &amp;gt;&amp;gt; 4 
        if (index == len) {
            out3 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 2
            out = out + base64EncodeChars[out1] + base64EncodeChars[out2] + base64EncodeChars[out3] + &#x27;=&#x27;
            return out
        }
        char3 = str.charCodeAt(index++) &amp;amp; 0xff
        // 输出6位有效字节二进制数
        out3 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 2 | (char3 &amp;amp; 0xc0) &amp;gt;&amp;gt; 6
        out4 = char3 &amp;amp; 0x3f

        out = out + base64EncodeChars[out1] + base64EncodeChars[out2] + base64EncodeChars[out3] + base64EncodeChars[out4]
    }
    return out
}
base64Encode(&#x27;haohao&#x27;) // aGFvaGFv
base64Encode(&#x27;haoha&#x27;) // aGFvaGE=
base64Encode(&#x27;haoh&#x27;) // aGFvaA==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;解码原理&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;逆向推导，由每4个6位有效位的二进制数合并成3个8位二进制数，根据ascII编码映射到对应字符后拼接字符串&lt;/p&gt;&lt;h3&gt;&lt;b&gt;思路&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;分析映射关系 xyzi -&amp;gt; abc&lt;/p&gt;&lt;ul&gt;&lt;li&gt;a: x后六位 + y第三、四位 =&amp;gt; x5x4x3x2x1x0y5y4&lt;/li&gt;&lt;li&gt;b: y后四位 + z第三、四、五、六位 =&amp;gt; y3y2y1y0z5z4z3z2&lt;/li&gt;&lt;li&gt;c: z后两位 + i后六位 =&amp;gt; z1z0i5i4i3i2i1i0&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;将字符对应的base64字符集的索引转为6位有效位二进制数&lt;/li&gt;&lt;li&gt;将每四个6位有效位二进制数进行以下操作&lt;/li&gt;&lt;ol&gt;&lt;li&gt;第一个二进制数左移位2位，得到新二进制数的前6位，第二个二进制数 &amp;amp; 0x30之后右移位4位，或运算后得到第一个新二进制数&lt;/li&gt;&lt;li&gt;第二个二进制数 &amp;amp; 0xf之后左移位4位，第三个二进制数 &amp;amp; 0x3c之后右移位2位，或运算后得到第二个新二进制数&lt;/li&gt;&lt;li&gt;第二个二进制数 &amp;amp; 0x3之后左移位6位，与第四个二进制数或运算后得到第二个新二进制数&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;根据ascII编码映射到对应字符后拼接字符串&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;b&gt;代码实现&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// base64字符串
let str = &#x27;aGFv&#x27;
// base64字符集
let base64CharsArr = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;.split(&#x27;&#x27;)
// 获取索引值
let char1 = base64CharsArr.findIndex(char =&amp;gt; char==str[0]) &amp;amp; 0xff // 26  011010
let char2 = base64CharsArr.findIndex(char =&amp;gt; char==str[1]) &amp;amp; 0xff // 6  000110
let char3 = base64CharsArr.findIndex(char =&amp;gt; char==str[2]) &amp;amp; 0xff // 5  000101
let char4 = base64CharsArr.findIndex(char =&amp;gt; char==str[3]) &amp;amp; 0xff // 47  101111
let out1, out2, out3, out
// 位运算
out1 = char1 &amp;lt;&amp;lt; 2 | (char2 &amp;amp; 0x30) &amp;gt;&amp;gt; 4
out2 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 4 | (char3 &amp;amp; 0x3c) &amp;gt;&amp;gt; 2
out3 = (char3 &amp;amp; 0x3) &amp;lt;&amp;lt; 6 | char4
console.log(out1, out2, out3)
out = String.fromCharCode(out1) + String.fromCharCode(out2) + String.fromCharCode(out3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;遇到有用&#x27;=&#x27;补过位的情况时&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;function base64decode(str) {
    // base64字符集
    let base64CharsArr = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;.split(&#x27;&#x27;)
    let char1 = base64CharsArr.findIndex(char =&amp;gt; char==str[0])
    let char2 = base64CharsArr.findIndex(char =&amp;gt; char==str[1])
    let out1, out2, out3, out
    if (char1 == -1 || char2 == -1) return out
    char1 = char1 &amp;amp; 0xff
    char2 = char2 &amp;amp; 0xff
    let char3 = base64CharsArr.findIndex(char =&amp;gt; char==str[2])
    // 第三位不在base64对照表中时，只拼接第一个字符串
    if (char3 == -1) {
        out1 = char1 &amp;lt;&amp;lt; 2 | (char2 &amp;amp; 0x30) &amp;gt;&amp;gt; 4
        out = String.fromCharCode(out1)
        return out
    }
    let char4 = base64CharsArr.findIndex(char =&amp;gt; char==str[3])
    // 第三位不在base64对照表中时，只拼接第一个和第二个字符串
    if (char4 == -1) {
        out1 = char1 &amp;lt;&amp;lt; 2 | (char2 &amp;amp; 0x30) &amp;gt;&amp;gt; 4
        out2 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 4 | (char3 &amp;amp; 0x3c) &amp;gt;&amp;gt; 2
        out = String.fromCharCode(out1) + String.fromCharCode(out2)
        return out
    }
    // 位运算
    out1 = char1 &amp;lt;&amp;lt; 2 | (char2 &amp;amp; 0x30) &amp;gt;&amp;gt; 4
    out2 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 4 | (char3 &amp;amp; 0x3c) &amp;gt;&amp;gt; 2
    out3 = (char3 &amp;amp; 0x3) &amp;lt;&amp;lt; 6 | char4
    console.log(out1, out2, out3)
    out = String.fromCharCode(out1) + String.fromCharCode(out2) + String.fromCharCode(out3)
    return out
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;解码整个字符串，整理代码后&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;function base64decode(str) {
    // base64字符集
    let base64CharsArr = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;.split(&#x27;&#x27;)
    let i = 0
    let len = str.length
    let out = &#x27;&#x27;
    while(i &amp;lt; len) {
        let char1 = base64CharsArr.findIndex(char =&amp;gt; char==str[i])
        i++
        let char2 = base64CharsArr.findIndex(char =&amp;gt; char==str[i])
        i++
        let out1, out2, out3
        if (char1 == -1 || char2 == -1) return out
        char1 = char1 &amp;amp; 0xff
        char2 = char2 &amp;amp; 0xff
        let char3 = base64CharsArr.findIndex(char =&amp;gt; char==str[i])
        i++
        // 第三位不在base64对照表中时，只拼接第一个字符串
        out1 = char1 &amp;lt;&amp;lt; 2 | (char2 &amp;amp; 0x30) &amp;gt;&amp;gt; 4
        if (char3 == -1) {
            out = out + String.fromCharCode(out1)
            return out
        }
        let char4 = base64CharsArr.findIndex(char =&amp;gt; char==str[i])
        i++
        // 第三位不在base64对照表中时，只拼接第一个和第二个字符串
        out2 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 4 | (char3 &amp;amp; 0x3c) &amp;gt;&amp;gt; 2
        if (char4 == -1) {
            out = out + String.fromCharCode(out1) + String.fromCharCode(out2)
            return out
        }
        // 位运算
        out3 = (char3 &amp;amp; 0x3) &amp;lt;&amp;lt; 6 | char4
        console.log(out1, out2, out3)
        out = out + String.fromCharCode(out1) + String.fromCharCode(out2) + String.fromCharCode(out3)
    }
    return out
}
base64decode(&#x27;aGFvaGFv&#x27;) // haohao
base64decode(&#x27;aGFvaGE=&#x27;) // haoha
base64decode(&#x27;aGFvaA==&#x27;) // haoh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述解码核心是字符与base64字符集索引的映射，网上看到过使用AccII编码索引映射base64字符索引的方法&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;let base64DecodeChars = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1]
// 
let char1 = &#x27;hao&#x27;.charCodeAt(0) // h -&amp;gt; 104
base64DecodeChars[char1] // 33 -&amp;gt; base64编码表中的h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由此可见，base64DecodeChars对照accII编码表的索引存放的是base64编码表的对应字符的索引。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;说起Base64编码可能有些奇怪，因为大多数的编码都是由字符转化成二进制的过程，而从二进制转成字符的过程称为解码。而Base64的概念就恰好反了，由二进制转到字符称为编码，由字符到二进制称为解码。Base64 是一种数据编码方式，可做简单加密使用，我们可以改变base64编码映射顺序来形成自己独特的加密算法进行加密解密。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;编码表&lt;/b&gt;&lt;/h2&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-389e3895fda68d47c1edbc0cb71cfff6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;972&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-389e3895fda68d47c1edbc0cb71cfff6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;972&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-389e3895fda68d47c1edbc0cb71cfff6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-389e3895fda68d47c1edbc0cb71cfff6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b15e05ad7509dfc390e445560196c71e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1227&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-b15e05ad7509dfc390e445560196c71e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1227&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-b15e05ad7509dfc390e445560196c71e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b15e05ad7509dfc390e445560196c71e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8dc19906c7caff557d3718840188f9fc</guid>
<title>[推荐] 发票总库 DDD 实践</title>
<link>https://toutiao.io/k/0d4bxmx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-backh=&quot;57&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.0984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/UPBmkBoiaVwuh8DEJlYXXvEjNrISejeXSt7knYYiaGantXAsgOvXvxAOog7a4L9yEicM1biao6MGia2Ob4I3B77Z6Vg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总篇117篇 2021年第8篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DDD&lt;/span&gt;&lt;span&gt;是一套完善的系统设计方法，可以帮助我们在系统设计的过程中缕清思路，规范流程，降低系统建设的复杂度，同时DDD的领域建模过程也是团队成员之间形成系统通用语言、建立良好沟通机制的过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在电商中台研发团队内部，很早之前就对DDD有过分享和讨论，近期我们在做购车发票总库的迁移工作，经过分析，借此项目做一次DDD的落地实践，在时间和人员投入上都比较适宜。本篇文章就对我们的整个实践过程做一个总结，与大家一起学习和提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们先来看一张DDD的经典知识体系结构图：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;442&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7651452282157676&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UPBmkBoiaVwvXPMZLLx7toI4AvneeOn5pMQMDEwxCqPbVnMRrAiaq4zGgqZHia6o3micO8XZgqmgicKAR0NRDCiaZvZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1205&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DDD的核心就是将问题范围限定在特定的边界内，在这个特定的边界内建立领域模型，进而解决相应的业务问题。领域是用来限定业务边界和范围，自然它的边界就或大或小，当一个领域过大的时候可以将其进一步拆分为子领域。而子领域按照重要性以及关注度，可以分类为：核心子域、支撑子域、通用子域，这三类子域随着时间的推移或者业务的变化，其角色也可能发生转换，我们的重点应该放在核心子域建设上。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;明确了领域（子域）其实也就定义好了边界，即：限界上下文，为了确保在限界上下文内，所有人对概念的理解一致，不产生歧义，就需要对限界上下文中的每一个事件、动作、实体等对象都要形成通用语言，统一命名。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;实体和值对象是领域模型中非常重要的两个基本概念，一起构成了领域模型中最核心的领域逻辑。实体具有唯一标识以及本身的生命周期，当实体的属性（值）发生变化时，实体还是原来的那个实体，而值对象更多的是属性（值）的描述，当属性（值）发生变化时，值对象就不在是原来的值对象了。实体在代码形态上，通常采用充血模型实现，与实体相关的所有业务逻辑都在该实体类中实现，实体自身保障事务的原子性，当需要多个实体共同实现某个逻辑时，则会在领域服务层实现跨多个实体的组合封装。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;聚合根也是实体，它用来管理聚合内所有的实体以及值对象，一个聚合内包含了聚合根、实体、值对象、领域服务等，它们按照聚合的业务规则完成聚合内的领域逻辑，一个聚合只有一个聚合根，聚合和聚合之间只能通过聚合根的唯一ID标识进行引用，对于跨聚合的服务调用，往往是在应用服务层组合编排他们之间的调用关系，实现相互之间的协同。在DDD中强调一次事务最多只修改一个聚合的数据，因此在聚合内部会采用数据强一致性，而聚合之间则采用数据最终一致性的方式实现数据一致性。&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常在大部分领域模型中，有70%的聚合通常只有一个实体，即聚合根，该实体内部没有包含其他实体，只包含一些值对象；&lt;/span&gt;&lt;span&gt;另外30%的聚合中，基本上也只包含两到三个实体。&lt;/span&gt;&lt;span&gt;这意味着大部分的聚合都只是一个实体，该实体同时也是聚合根。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;领域事件是领域模型中非常重要的一环，一个个领域事件可以串联起完整的业务逻辑闭环，领域事件采用事件驱动的方式用来解耦服务与服务之间的依赖关系，在服务内部可以采用事件总线的方式实现逻辑的串联，服务与服务之间可以采用消息队列的方式实现服务间的解耦和数据最终一致性。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;工厂和仓储&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此工厂非彼设计模式的工厂，领域驱动的工厂强调封装了所有创建对象的复杂操作过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;仓储就是持久化机制，比如：Dao层、Cache层等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在整个发票总库DDD的实践过程中，我们也是按照战略设计和战术设计两个阶段进行：业务抽象的过程就是业务领域建模的过程，对应DDD的战略设计，而系统架构设计并落地的过程则对应DDD的战术设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;244&quot; data-backw=&quot;448&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/UPBmkBoiaVwvXPMZLLx7toI4AvneeOn5pLJvVZxaulib9Y96zoWYRia2RQR0kToPZm8a1Bjed9mFJUKB2PR6NQnUQ/0?wx_fmt=png&quot; data-cropx1=&quot;119.5847750865052&quot; data-cropx2=&quot;1113.9100346020762&quot; data-cropy1=&quot;121.79930795847751&quot; data-cropy2=&quot;662.1453287197232&quot; data-ratio=&quot;0.5442655935613682&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UPBmkBoiaVwvXPMZLLx7toI4AvneeOn5pECsrgiaK86HIUmibaqdtEEqV5zPtVyicODzKCxe5QYCN3uRrKNC76DN7Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;994&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;在战略设计阶段&lt;/strong&gt;&lt;span&gt;，因为发票总库的业务逻辑相对比较清晰，也有助于我们采用事件风暴的方式，快速的找出了聚合、领域对象、领域类型，为构建领域模型奠定了基础，以下是我们梳理完成的发票域的对象清单：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;325&quot; data-backw=&quot;413&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/UPBmkBoiaVwvXPMZLLx7toI4AvneeOn5puUAQRgw9EZ2zRJoBs8K4aLqxHgXOyaM293GDaybZtJuPQw0cYM0rmQ/0?wx_fmt=png&quot; data-cropx1=&quot;179.3771626297578&quot; data-cropx2=&quot;1093.9792387543253&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.787746170678337&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UPBmkBoiaVwvXPMZLLx7toI4AvneeOn5pxicLKpxia1BLUVLXJjBEr1HxMth0iaicbjvm2G96eYulxggLPsg2xpNvzg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;914&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上图中可以看到，整个发票域我们只定义了发票这个聚合，同时它也是聚合根，在发票领域服务内部，还包含了排重规则&lt;/span&gt;&lt;span&gt;、发票日志两个实体以及发票审核状态、业务类型、入库类型、应用唯一标识四个值对象，结合发票入库这个领域事件以及发票总库的业务逻辑&lt;/span&gt;&lt;span&gt;，在发票领域服务内对外提供了发票入库、发票排重等方法，对于数据存储，则需要统一抽象了仓储接口（不受限于具体的数据存储介质）。&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;在战术设计阶段&lt;/strong&gt;，我们完成了分层设计、规范设计等事项，在分层设计中我们遵循了DDD的四层分层模型，如下所示：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;354&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6123188405797102&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UPBmkBoiaVwvXPMZLLx7toI4AvneeOn5pZySrK0GW3XvhiasaWTZEibT8v9iaAyt5fGCibnaJVeuRQDDkq7WRA6jOUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;552&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户接口层主要实现后端服务与前端调用入口的接口数据适配和转换；&lt;/span&gt;&lt;span&gt;应用层主要用来协调领域层多个聚合之间的服务组合和编排，以及负责领域事件的订阅和发布等职责；&lt;/span&gt;&lt;span&gt;领域层是领域模型的核心，实现领域模型的核心业务逻辑，其内部逻辑相对稳定，不会受外界变化（如：&lt;/span&gt;&lt;span&gt;底层数据存储介质的变换、通讯方式的变化等）的影响，基础层主要用来提供通用的基础工具类或基础服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;结合上述四层模型，在实际代码工程的构建过程中，我们也是参考了COLA架构进行构建，具体如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;466&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.8051063829787234&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UPBmkBoiaVwvXPMZLLx7toI4AvneeOn5pH1afb38dibTC6yR7oLdydkNzDvVMC1n85Iya0KujHlGP62debLx7TFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1175&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作为服务的启动模块（SpringBootApplication）以及用户接口层（Controller），定义了所有对外发布的接口以及DTO到领域层实体类的转换。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;应用层模块，提供了发票领域服务的方法定义及实现，同时作为事件总线（EventBus）的接收层，提供了多个发票领域事件的Handler处理器，对领域事件做下一步处理，比如：发送MQ消息等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;领域层模块，定义了发票领域的实体、值对象、发票事件、发票领域服务以及仓储层接口，同时包含了创建领域实体的工厂类。在发票领域服务类中，通过发票实体以及发票规则实体的协作，完成发票入库逻辑，当发票入库事件发生后，会通过事件总线（EventBus）将该领域事件发布出去。而在发票的聚合根实体内，则通过事务控制了发票实体以及发票日志实体的数据存储。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基础设施层模块，提供了发票仓储接口、发票日志仓储接口的实现类以及从领域实体类到仓储层PO对象类的转换，同时提供了事件总线（EventBus）以及加解密等通用工具类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;客户端模块，提供了API定义以及DTO、VO等对象的定义。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;为了防止开发过程中的随心所欲，开发规范的制定就显得特别重要，但也是最容易被无视的点，其结果就是架构的一致性被严重破坏，代码的可维护性将急剧下降，架构将形同虚设。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先是分包设计，在领域驱动设计里，推荐使用了基于业务的分包，即通过软件所实现的业务功能进行模块化划分，而不是从技术的角度划分(比如首先划分出service和infrastruture等包)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;123&quot; data-backw=&quot;523&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/UPBmkBoiaVwvXPMZLLx7toI4AvneeOn5po9gGicZtbte4H30ic1ciaSIUUEicQev6xs2ox36Hw1qLUbnkdO4icoGy2zw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1158.2006920415226&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;272.38754325259515&quot; data-ratio=&quot;0.23575129533678757&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UPBmkBoiaVwvXPMZLLx7toI4AvneeOn5pGozicLmKWfFUStYL7nSfeUJOFA9g7nYEuqKZdnbtGk8FnvnCtOYPGmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1158&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;类名应该是自明的，也就是看到类名就知道里面是干了什么事，这也就反向要求我们的类也必须是单一职责的。为了避免团队人员对dto、bo、vo、po等这些pojo对象的二义性理解，我们制定了类名规范。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;666&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.1518858307849134&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UPBmkBoiaVwvXPMZLLx7toI4AvneeOn5peF5JqQsD6wUhCJUvzLYlO6mj8dpc3KCAPAKZkVibZLW8YVDgypgehfw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;981&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;方法名约定&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;308&quot; data-backw=&quot;450&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/UPBmkBoiaVwvXPMZLLx7toI4AvneeOn5pptOFrR7JHOjF2vs19WvxVZ8beKsmkFd8upVYCsoNbKWqNBR73WnpDQ/0?wx_fmt=png&quot; data-cropx1=&quot;98.08650519031141&quot; data-cropx2=&quot;766.8581314878893&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;457.7370242214533&quot; data-ratio=&quot;0.6856287425149701&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UPBmkBoiaVwvXPMZLLx7toI4AvneeOn5pKtEh82rzwcKwHkp8mYTl2ZAmP1FL4zkBYDMzWhiaelq8VvxbutCduBA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;668&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;经过上述过程，我们按照DDD的方式完成了购车发票总库的迁移工作，目前系统已经顺利上线，因为大家都是第一次做DDD的落地实践，在整个过程中会发现从理论到实践难免会出现一些理解的偏差和分歧，比如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;解：创建聚合根通过Factory完成；业务逻辑优先在聚合根边界内完成；聚合根中不合适放置的业务逻辑才考虑放到DomainService中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;解：DDD的概念提出之初，事务的层次体现在跨领域交付的应用服务层。在微服务的流行的现阶段，各领域之间通过接口交互，在实施过程中，我们要灵活根据业务逻辑和当前的架构来把事务粒度做到最小。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;解：读操作便可以根据自身所需独立设计数据结构，而不用受写模型数据结构的牵制。因此，领域驱动设计通常适用于增删改的业务操作，但不适用于分析统计。在一个系统中，增删改的业务可以采用领域驱动的设计，但在非增删改的分析汇总场景中，则不必采用领域驱动的设计，直接 SQL 查询就好了，也就不必再遵循聚合的约束了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;解：领域实体里的方法映射的是现实世界的动作行为，改变的是状态、时间，而领域服务是实体的能力，领域服务在设计上应该是无状态的，它存在的意义就是协调领域对象共完成某个操作。业务逻辑应该放在领域实体里还是领域服务里应该根据这个原则来评估。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在实践过程中出现这些问题其实都很正常，每一个问题都不一定会有标准答案，比如上述没有提到的问题：一个领域对象究竟是定义为实体还是值对象等，即便是上述我们有答案的问题也仅仅是我们的一些见解，仁者见仁，智者见智，面对这些问题，我们一方面需要摆脱掉之前的思维定式，再次深入的理解理论定义，一方面也需要借鉴参考一些成熟代码案例，找到适合我们自身项目的结论。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;按照DDD的模式进行项目的落地实施，相比与传统开发模式也会有一些质的提升，主要表现在以下几方面：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DDD首先强调的是确定领域边界，领域边界确定后所有设计均会在同一个领域范围内进行开展，清晰的领域边界对应了实际系统落地过程中合理的系统边界，这对于后续系统内高内聚功能的延展起到了积极的帮助作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在传统的开发模式中，不同环节的人员经常会出现对于同一对象的叫法不一致、定义不一致的现象，这在一定程度上也造成了大家对于系统理解的偏差，而在DDD模式中，提出了通用语言的概念，参与其中的所有成员在系统生命周期内均采用简单清晰明了的通用语言进行交流，通用语言成为团队内外部系统交流的统一语言，既减少了信息的失真, 又确保了大家在同一领域知识体系内交流的便利性、理解的一致性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;传统开发模式采用贫血模型，将属性与业务逻辑彻底分离，通过get / set方法改变对象属性，对象属性可以被随意的修改，在面对简单的业务场景，贫血模型还可以应对，但是在面对复杂的业务场景时，传统开发模式的贫血模型维护成本高的弊端就会被暴露。与贫血模型相对应的，DDD的开发模式强调采用充血模型，将属性和行为聚合到一个实体内，业务逻辑更加便于维护和管理，也更加符合面向对象的编程逻辑，这也是基于充血模型的 DDD 开发模式越来越被人提倡的原因。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DDD所涵盖的范围其实是比较广泛的，在具体的实践过程中是需要结合实际的项目场景和团队成员的实际情况等多方面因素，不断的摸索，经过长时间的学习和积累，逐步的在团队内部建立DDD的方法论以及对应的开发模式、技术架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上就是我们的DDD实践总结，欢迎对此感兴趣的同学与我们交流，共同进步。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;434&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UPBmkBoiaVwvXPMZLLx7toI4AvneeOn5p79Z4yMmTV5IAIZXtCXgYGTPpkezuAXrsV1sewb8MT7KicSrYUMK47MQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;王松，2015年加入汽车之家，现担任商业平台中心电商中台技术负责人；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;方利，2016年加入汽车之家，现担任商业平台中心电商中台系统架构师，负责订单交易相关系统的架构及研发工作；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;发票总库DDD实践小组其他成员：张凡、张林林，均担任商业平台中心电商中台软件开发工程师，拥有多年的电商交易系统研发经验。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2eb404e9476e352607a9a2df77151e12</guid>
<title>[推荐] 十个现象，识别程序员的 “水份”</title>
<link>https://toutiao.io/k/l2sw9ji</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2NzEwMDc4OQ==&amp;amp;action=getalbum&amp;amp;album_id=1665534267625439237#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1665534267625439237&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#程序员&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;33个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;strong&gt;&lt;span&gt;这里是Z哥的个人公众号&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;每周五11：45 按时送达&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;当然了，也会时不时加个餐～&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;我的第「210」篇原创敬上&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大家好，我是Z哥。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下周五正好是国庆，我也给自己放个假，就不发文了。所以今天是节前最后一篇文章，先提前祝大家国庆快乐，可以好好放松一下。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;今天我们不聊干货了，聊点轻松的，来吐槽一下程序员的那些事儿。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在软件开发领域一直流传着一句话，它说明了程序员的水平和资历之间并不存在着相关性，并且可能相差特别大。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;26&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;到底是货真价实的十年经验？还是一年经验重复用了十年？&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;随着我在工作中遇到过的人越来越多、面试过的人越来越多，发现这句看似夸张的话讲述的的确是事实。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有些人工作了 7、8 年，所表现出来的专业性就像刚入行 1、2 年的新人。并且,比新人还不如的是，他们身上往往也没有了新人的那种学习欲望。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;与之相对的，我也与刚毕业就加入公司的应届生共事过，他们身上所表现出的惊人成长能力，让他们在不到一年的时间内就挑起了项目组的大梁。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;经过我对所接触过的程序员们的观察，我总结出了一些“信号”，他们可以帮助你识别出与你一起工作的同事到底是不是“货真价值”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然后，你就可以与那些“货真价实”的资深程序员们多打交道、多交流，与厉害的人多在一起，自己也更容易变得厉害。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;好了，下面开始。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你发现某位工作多年的程序员身上有这些现象出来，那么他大概率就是一位“有水份的高级程序员”。符合的现象越多，水份越大……&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;/01  总是喜欢“攒”一些代码后再提交代码/&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不知道你有没有留意过，一个团队里只要有一个人喜欢“攒”代码，那么这个项目的代码合并将会长期面临代码冲突的痛苦。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;道理很好理解，两个胖子之间的碰撞面积，总比两个瘦子大吧。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而且喜欢这么干的人往往也不太认可 CodeReview 这事，为啥？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因为他大概率没有想过，做 CodeReview 的人，一次性看到几十上百个变更文件时的感受。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们可以建议他们，实现或者修复一个完整的小问题和小任务，就提交一次代码。最差也得每天提交一次，当然，需要将未实现的部分做好处理，避免编译报错。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/02  总是很早就开始 coding，但是很晚才通过验收/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;用马保国老师的话来说，“有些程序员写代码很快啊，pia 一下，我都来不及闪，他就写了好几行代码了。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;他们实现功能很快，不熟悉的人还以为是高手。但是实际上，他们修 bug 的时间往往会明显多于其他人，最终可能反而导致拖整个项目进度的后腿。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;虽说不一定非得每次花时间正儿八经的画图，做设计。但是真正有经验的程序员，他们写代码之前脑子里是会先梳理好思路的，有一个清晰的达到终点的“路线”。这样他在写下每一行代码的时候，都知道他在做什么，而且下一步是什么。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，我们可以建议他们写代码之前，稍微多花点时间去搞清楚一些业务问题，梳理清楚需求。并且在写代码之前做一下规划，避免后来你的代码只有你自己看得懂，甚至是自己都看不懂。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;/03  看上去很忙，在多件事之间来回奔波/&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在团队里越是核心的人员总是越忙的，但并不是所有忙的人都是核心人员。因为有些忙是自己导致的。比如，当我们面前有多个问题需要处理的时候，不是谁来催得紧，你就先处理哪个。还得自己心里有一杆秤，根据优先级来处理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;否则，花费了大量时间在多个事情之间切换，实际真正的有效工作时间可能连一半都不到。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们可以建议他们不管是做任何还是修 bug，搞定一个之后再进行下一个，除非每次新来的问题都比之前的优先级高。但是，应该没那么巧吧？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外，将任务分解成小任务，也更有利于自己掌控时间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/04  固执己见/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果一位缺乏经验的程序员恰好又是团队里资历比较老的，那就很容易出现固执己见的情况。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这会使得他进入一个不太好的循环里去。自我感觉良好 -&amp;gt; 无法改掉身上的坏毛病 -&amp;gt; 资历老，听不进别人的 -&amp;gt; 自我感觉良好。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是往往获取经验最快的方式是以开放的心态与别人交流，学习别人的长处，补足自己的短处。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，我们可以建议他们多考虑一下事物好坏的另一面，毕竟任何事物都有两面性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/05  不断地重复掉进同一个坑/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;毕竟有了不少工作年限，所以当遇到生产环境的 bug 时，不会出现真正的新手那样不知从何下手的情况。他们会祭出打 log 大法，或者是调试大法，用最快的速度解决问题。然后，就没有然后了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从别人眼中看来，他们这是头痛医头，脚疼医脚。但是在他们眼里，没有任何两个“坑”是一样的，每个都不同，所以，下次相同的问题再次出现也是正常的。这种做法真的难以给人靠谱、放心的感觉。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，我们可以建议他们。在出问题后，先通过逻辑分析思考一下问题可能出在哪里，梳理相关的信息和思路。然后，即使解开了 Bug ，也应该多思考一下是否其它部分也有类似的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/06  盲目追逐技术潮流/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;你说他们完全不学习吧，也不是。当从身边很多人的嘴里听到同一个技术名词的时候，他会视该技术为传说中的“ SliverBullet ”，赶紧去学习官方教程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是，往往跟着入门教程走完一遍之后，就觉得这也没什么难的，自己已经掌握了。实际上，没有经过实战的使用就觉得掌握，仅仅是一种幻觉而已。因为一旦实际进行落地，往往会出现各种意料之外的问题等待着你去解决，甚至有些是连官网都未发现的bug。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;他们对新技术的崇拜，其实是他们觉得，如果自己不了解这个新技术，会觉得错过些什么。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，我们建议他们抱着学以致用的心态去学新技术，或者至少不要只停留在官方教程上，找一个自己工作或者生活中的场景，用新技术来实现一个功能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;/07  代码写得很随意/&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;写代码随意的场景有很多，小到变量、方法的命名规范与否，大到整体的架构设计上是否有考虑到一些非显性的问题，如性能、扩展性等等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;缺乏经验的程序员，不但全部命中上面这些点，而且写出来的代码，其它人很难看懂，特别在一些业务本身就有一定复杂度的场景中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;相反，优秀的程序员们在编写自认为复杂的代码段的时候，会写下清晰的注释来帮助后来人理解。因为他们知道代码不仅是让计算机执行，更是需要让别人也理解的，因为项目开发大多是团队协作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，我们可以建议他们在写代码的时候考虑一下，如果两年后回头来看今天写下的代码，还看得懂吗？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;/08  总喜欢直接调试生产环境/&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“线上有问题？来说下你怎么操作的，我调试一下。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“接口报错？参数发我，我调试一下。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这些是他们的口头禅。不可否认，从理论上来说，直接调试线上必然是解决问题最快的方式，毕竟直接面对案发现场。但也正是因为解决地过于容易，导致自己不容易“长记性”，下次大概率还会犯一样的错误。所谓，“捷径走多了，人就废了。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外，一旦对项目不是100%的熟悉，那么搞不好在调试的过程中，不知不觉给生产环境产生了垃圾数据，可能进一步导致埋下了新的隐患。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，我们可以建议他们，遇到问题先思考，用你的专业知识和业务经验进行逻辑分析，如此，也能提炼出一些普适性的规律避免自己后续再犯相同的错误。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/09  不做自测/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;前面提到过有些伙计写代码很快，其实他们之中的大部分也不会做自测，毕竟这会降低他们的开发速度。而且，在他们心里可能觉得测试嘛，不是应该测试工程师干的么，我都自测过一遍的话，不是抢他们饭碗么。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当然，如果有些公司有明确的工作要求需要自测，他们也会做，但不是去尽量模仿真实的数据，而是用很随意的数据来测试，效果其实是很差的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;自测的好处有很多，最直接的就是可以降低修复bug总时间，毕竟，开发和测试之间沟通bug的时间肯定就节省掉了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，我们可以建议他们做自测，因为这不但可以让整个项目的工期得以更快完成，也能让自己和其他人摆脱加班、摆脱996，不香么。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/10  不主动推进项目进度/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;资深的程序员身上会有那种领袖气质，这种领袖气质并不是凭空出现的，而是需要有主动推进一件事往前发展的意愿。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而那些有资历却缺乏经验的程序员们则完全相反，只着眼于自己的一亩三分地，其它的都与我无关。如此一来他们也错失了快速扩大自己能力圈的机会。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从资历的这个角度上来说，作为团队里懂得最多的人，是推动项目往前的最佳人选。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，我们可以建议他们多给出自己积累多年的经验，因为“你是专家”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;怎么样？是不是很多现象都很熟悉？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其实还有很多其它的现象，只是上面这些是比较常见的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其实我们不是在吐槽他们，而是希望他们能够发挥自己真正的价值，这不仅仅是为了整个团队创造更好的工作环境，也是为了避免他们迷失在走向中年危机的道路上。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;希望大家能够多多转发，能叫醒一个算一个，帮助他人，也是帮助自己，不香么。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原创不易，如果你觉得这篇文章还不错，就「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;点赞&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」或者「&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;」一下吧，鼓励我的创作 ：）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也可以分享我的公众号名片给有需要的朋友们。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU2NzEwMDc4OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/oB5bd6W6hI1ENbrFbGjEucl1Az92hEuwmUSdaNXxibiaWuO9sLTPHokw00p8ZxAYdIJJJ7FXj77Ts0YoV5KwEKCA/0?wx_fmt=png&quot; data-nickname=&quot;跨界架构师&quot; data-alias=&quot;Zachary_ZF&quot; data-signature=&quot;坚持原创。专注大型互联网技术，涉猎产品、运营。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果你有关于软件架构、分布式系统、产品、运营的困惑&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以试试点击「&lt;strong&gt;阅读原文&lt;/strong&gt;」&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>081ef7fe76c2672b5abe518e73cbc65e</guid>
<title>[推荐] 《架构之道》读书笔记：架构设计的新思路</title>
<link>https://toutiao.io/k/z6w8vl5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;/p&gt;&lt;p&gt;《righting software》是 Pearson 出版社 2020 年出版的一本书，作者是 Juval Löwy，今年国内也引进了这本书，中文名是《架构之道》。&lt;/p&gt;&lt;p&gt;中秋期间读完了这本书里我比较关心的部分，本文将其中的一些核心观点进行摘录。&lt;/p&gt;&lt;p&gt;作者首先总结自己几十年的经验(先表达一下羡慕)，提出了靠谱软件的设计方法，称为 The Method(中文译成了元方法)：&lt;/p&gt;&lt;p&gt;The Method = System Design + Project Design&lt;/p&gt;&lt;p&gt;这本书也就被分成了这两部分，System Design 和 Project Design。&lt;/p&gt;&lt;p&gt;先说说 Project Design，这个其实就是项目规划，这部分大多数公司的项目管理培训中都有科普，就是通过对项目的工作任务进行拆分，绘制出网络图，找到迭代的关键路径，并为不同阶段分配不同的开发资源。看一下这张图你基本就懂了：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.33515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbe6dpTCiaTUxPicvSDYzibArxPBwicELeBIy6g8KmAKckkicYARc8duGDdG59H45oYHgAZeXx3v49WcOcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;尽管作者把项目管理也放在了架构师的职责内，不过&lt;strong&gt;这些事情一般都是项目经理来干的(很多项目进了中后期，日常迭代其实都不需要做什么分析了，都是堆嘛)&lt;/strong&gt;，作者也没有提出让人眼前一亮的观点，本文会先忽略应该没什么人感兴趣的这个部分，大多公司的项目管理方式也比较粗放，循规蹈矩的做基于网络排期的公司很少很少。&lt;/p&gt;&lt;p&gt;System Design 对我们来说比较重要，一线软件开发和架构师每天的日常工作都会或多或少涉及一点设计。关于 System Design 的部分是这本书的上半部分，中文版总共 102 页，所以读起来也是比较快的。&lt;/p&gt;&lt;p&gt;微服务模式已经是后端架构模式的大前提，我们最耳熟能详的对微服务建模的观点一般是“基于功能”或“基于领域”拆分出来的微服务。实际的情况是，大多数一线工程师还在吵吵用不用 DDD，因为那几本 DDD 的书实在是写的太难读了。之后有机会我也写写 DDD 的科普文，应该没那么难的。&lt;/p&gt;&lt;p&gt;这本书就很神奇了，作者既&lt;strong&gt;不赞同基于功能进行拆分，也不赞同基于领域拆分&lt;/strong&gt;。&lt;/p&gt;&lt;h2&gt;为什么不赞同基于功能拆分？&lt;/h2&gt;&lt;p&gt;这里给出了五个理由：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;服务很难重用&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;比如拆分了三个服务 A、B、C，看起来是三个独立的服务，但在&lt;strong&gt;执行 B 的时候，其实需要 client 先去访问 A 拿到 B 所需要的参数。访问 C 需要先从 B 中拿一些参数&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;这样 A、B、C 都不是独立的服务，他们是一组服务，你没法单独复用任何一个。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;数量过度或规模过度&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这个我们在大公司内见的比较多了，比如国内的几家规模比较大的公司，服务数量都超过 10 w 了，&lt;strong&gt;喜欢规模的人看到这些数字反而还会比较高兴&lt;/strong&gt;。有些服务总共也就几千行代码，实现功能单一的简单逻辑。&lt;/p&gt;&lt;p&gt;还有那些没拆好的，单服务几十万行~100w 行代码的服务，本人也是实际见过的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;客户端臃肿耦合&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;服务数量爆炸会导致集成的难度变高，客户端的会随着服务数量的膨胀同步变复杂。作者这里没提到 BFF，不过 &lt;strong&gt;BFF 其实也没有降低集成复杂度，只是把这部分从 client 移到了 BFF 里&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.409375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbe6dpTCiaTUxPicvSDYzibArxPmOwgTTouKib1zo5xFV70vJqQ4luuPSr63O1wJTcsoWmGhaFpr0epibSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;下面这张图是一个基于功能拆分的系统，在迭代一段时间后，客户端侧的圈复杂度的综合统计：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbe6dpTCiaTUxPicvSDYzibArxPXC5JkRFUzvYkS9ou5FfbEErTibxAPoefF7cpuUjre54bt7atsqPe8GA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;模块的复杂度分布极不均衡，组件极多，&lt;strong&gt;这里的 Resources 模块变得很大，就是因为后端服务数量太多造成的&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;服务数量多导致的逻辑冗余&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;上面把很多服务都直接暴露给了客户端，导致每个服务都需要集成身份验证、授权、可伸缩、事务传播、等等等等。&lt;/p&gt;&lt;p&gt;这条其实有个 BFF 就还好了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;服务臃肿耦合&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如果不想让 client 访问每个服务来实现业务，那可以让 client 只调用 A，但 A、B、C 自己要进行集成，比如这种链式的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbe6dpTCiaTUxPicvSDYzibArxPjRDicIzAFGSfk3tm8QTo3mV0sHqiabz8XtpSwoDlUWCrM8VODEYDaxOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;这样其实是让 A 完成了集成的角色，它需要准备后续服务需要的所有参数，集成的复杂度落在 A 上：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbe6dpTCiaTUxPicvSDYzibArxP4PWzyUADXSR8ib6bREv4mNF1vjjY2xWfGKnlmytJCkHribxq0TfZ2zZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果涉及到工作流、事务性质的业务，那可能 C 里还要关心 A、B 中的流程执行失败的时候，是不是要回调来进行逻辑补偿：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.45546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbe6dpTCiaTUxPicvSDYzibArxPibvqGicLIJ5BVibKxz5X0tyTdA7TpMALs5OdN6OrzhibOkVtwSuGwL6sUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;作者又举了一个真实生活的例子，如果我们要建造房子，是从房子的功能来考虑，那可能最后房子就变成这样了：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.44296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbe6dpTCiaTUxPicvSDYzibArxP1HCyerfdxN1vZx3YbLjrXtUr1PicWDRqUibibVKgQUpOHjAA69oBybtbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;为每个功能需求建立一个模块，只要拿真实世界的房子设计和这里的图进行对比就知道这种设计是多荒谬了。&lt;/p&gt;&lt;h2&gt;为什么不赞同用领域拆分?&lt;/h2&gt;&lt;p&gt;还是那个房屋的例子，如果按照领域拆分，那么大概率会划分成下面这样的架构：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.475&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbe6dpTCiaTUxPicvSDYzibArxPFKicE5ObNmKZ0e8mXDNBLDULN8JEOYVbPcRsUzQztyZZYTvVUxsLD2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;作者认为&lt;strong&gt;如果我们要在这样的建模下实现睡觉这个功能，那么就需要在每个领域里都实现一遍&lt;/strong&gt;。(这里我其实觉得和软件领域类比稍微有点牵强)&lt;/p&gt;&lt;p&gt;领域本身无法独立运行，要交付必须完整交付，所以&lt;strong&gt;如果一开始就用领域建模，会导致一部分领域反复地被重建&lt;/strong&gt;。比如你先把厨房做好了，在后面做其它模块的时候，发现排水管有问题，那厨房需要拆了重建。再后面又发现电器线路有问题，又需要拆了重建。这会产生很多资源浪费，且这种浪费是隐性的(这个倒是有道理，如果是比较大的项目，开发阶段某几个模块因为集成问题，反复地返工确实很常见)。&lt;/p&gt;&lt;p&gt;另外&lt;strong&gt;单元测试在领域中基本没什么用处，业务需求是不同领域共同作用的结果，即使某个领域的单元测试 100% pass&lt;/strong&gt;，&lt;strong&gt;也不能保证业务逻辑能正常运行&lt;/strong&gt;。(又一个和常规理念不太一样的观点)&lt;/p&gt;&lt;h2&gt;基于易变性(volatility)的分解&lt;/h2&gt;&lt;p&gt;1972 年 David Parnas 发表的 6 页论文 criteria for modularization 已经包含了现代软件工程的大部分元素，包括封装、信息隐藏、内聚、模块和松耦合。这篇文章指出，寻找变化点是分解的关键标准，功能本身不是分解的关键标准。&lt;/p&gt;&lt;p&gt;这也是《righting software》这本书的核心观点，基于易变性(volatility)的分解。这里也有一个反直觉的观点：我们的架构不应该按照需求来设计，&lt;strong&gt;因为需求一般都是对功能的需求，按部就班只能产生“根据功能分解”的系统&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;考虑易变性，主要是从两方面考虑：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;同一个客户的需求，随着时间迁移的不断变化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不同客户的需求，在同一时刻中的不同之处&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;书里管这两方面叫两个独立的轴，不过我个人觉得说成是时间、空间的影响可能更为恰当一些~&lt;/p&gt;&lt;p&gt;比如下面这个是同一房屋随着时间变化，可能会产生变化的一些要素，&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.16640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbe6dpTCiaTUxPicvSDYzibArxPq8b5KDmmNNic0cOqpDTjYgQ2I7lX4fW2yK4JohdtG4eYyFsOtBboicKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;家具变旧了要换掉，电器老了要换，后续卖给别人的话业主要换，哪天业主不开心了可能想刷个墙外观会变，以此类推。&lt;/p&gt;&lt;p&gt;下面是同一时刻不同的房屋之间可能存在的差别：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.1578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbe6dpTCiaTUxPicvSDYzibArxP1fVfxgBscQqGSibEAkopznAO7AeftoQgsL3Ikm3WQeeqRIR48Q1icyTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;如房屋结构的易变性，不同房屋的邻居肯定也是不同的，不同的房屋也可能会处在不同的城市。&lt;/p&gt;&lt;p&gt;任何一种易变性都是可以被分类到第一方面(时间)或者第二方面(空间)的，我们根据这两个方面(或者叫轴)来对项目进行分析，一开始项目是单一的一块结构，我们沿着第一条轴询问自己，&lt;strong&gt;随着时间推移的某种易变性是否被封装好了&lt;/strong&gt;？如果没有，那么就将该易变性封装进模块 B；然后可能接着问自己，同一时刻，&lt;strong&gt;是否所有用户都能使用相同的 B&lt;/strong&gt;？如果不能，那么就需要继续封装这种差异性，形成 A、B、C：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.35078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbe6dpTCiaTUxPicvSDYzibArxPQuGE77j0d9WuZKH5P45fz1CG3ErzeeWENde5kLjOiacUJKLD0xO7kRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;在接到需求列表的时候，还应该注意有些需求描述的不是需求，而是解决方案，比如&lt;strong&gt;烹饪不是需求，吃饭才是需求，烹饪只是个解决方案，在做易变性分析的时候要把这些解决方案进行转换，要找到根源的需求，才能分析出可变性来&lt;/strong&gt;，比如烹饪会被封装进进食的组件中，该组件负责处理进食的各种可变性(你也可以不自己做饭，点外卖嘛)。&lt;/p&gt;&lt;p&gt;项目设计阶段，应该把所有项目未来的易变性都列出来，比如一套交易系统，它的易变性包括：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户易变性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端程序易变性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安全易变性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通知易变性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存储易变性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;连接和同步易变性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;持续时间和设备易变性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;交易项易变性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;工作流程易变性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;地区和法规易变性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;市场信息源易变性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;关于每种易变性的说明大家去读原书就可以了，有了易变性之后，再根据这些易变性来设计系统，要保证每种易变性都尽量被封装到某一个模块里，比如书里给出的结构：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.60703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbe6dpTCiaTUxPicvSDYzibArxP6Tse1p87Wlf6icMp5s8OQjbzjw17ibMYRiaENPfxBZgpVUoV47OVraiceA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;在设计架构的时候，要注意&lt;strong&gt;业务本身的性质是不应该被封装的&lt;/strong&gt;，比如你们搞的是打车的业务，你还想在相同的架构下去做一套微博，这种不太可能，在老架构上迭代成本可能比新做一套都高。书里也给了两个判断标准：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果某种变化是极其罕见，发生概率很低，那么不一定非得封装它&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果封装变更的尝试需要巨大的经济成本(就是说你设计个系统要花公司极多的钱)，那么也不应该封装它&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;稍微具体一些&lt;/h2&gt;&lt;p&gt;前面给的那个示例结构就是这本书里给出来的很典型的分层了：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.575&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbe6dpTCiaTUxPicvSDYzibArxP5jkN028kRrc6nJCB41lHXgsf6ibWlwF3bdfRun5icEkFRAib2r7icnFq6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;client 就不用说了，业务逻辑这层分成 Manager 和 Engine 层，Manager 负责管理流程类的易变性，Engine 负责某个活动节点本身的易变性。&lt;/p&gt;&lt;p&gt;流程易变性好理解，就是工作流嘛(这本书的作者应该和早期的 WCF 有渊源)：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.59609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbe6dpTCiaTUxPicvSDYzibArxPAjwiaVbLrbI0B8y0FrnF3eu6CSVkLIBs8AHZkVrFqvnlQTG5wYiagrWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;下面的两个流程是完全相同的，只是在第二步使用的活动不一样，如果 B 和 D 干的是同一件事情，那么 B 和 D 应该被封装进同一个 Engine 中。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbe6dpTCiaTUxPicvSDYzibArxPlpnQtolpjnZ85yjibmRzDETNxrLXOukYibRyyQBtCaAANedIxUWTjvfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;当然，如果 B 和 D 功能不一样，那这两个流程就不一样了，另论。&lt;/p&gt;&lt;p&gt;Resource Access 这一层是资源访问层，负责一些存储资源的封装，也就是说公司内的基础设施要变化的时候，不应该影响到上层的业务，这种在 DDD 社区也有 Repo Pattern 之类的，比较好理解。&lt;/p&gt;&lt;p&gt;Utilities 那些紫色的组件，一般是一些大家公用的非功能性 SDK，也比较好理解。&lt;/p&gt;&lt;p&gt;架构图里的模块大多是服务：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.67421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbe6dpTCiaTUxPicvSDYzibArxPiagK8xz543lxdJuyQs2KTw5xpBtZPd9Ns5CqR2ehrCzFSZf6yYiafoIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;这样的分层每一次都是在解决 Who、What、How、Where 这四个问题：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbe6dpTCiaTUxPicvSDYzibArxPeqUNlgeWV3A8aYv0fcNml0joiaibgOG2L6xEs5OOmQ9LVTSHenQLWd5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;从上往下，易变性是逐渐降低的&lt;/strong&gt;，我们可以想想，公司里最常修改的都是上面的一些业务逻辑，底层的基础设施几年变一次就不错了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;自上而下的重用性是逐渐增加的，Manager 经常做变更、重构、完全重写，都是挺正常的。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;作者在这里又狠狠批判了一把按功能分解微服务，导致没有获得模块化任何好处的前提下，却要解决功能分解和面向服务的复杂性问题。这种双重打击超出了很多企业能承受的范畴。作者表示担心微服务将是软件史上最大的失败(嘿嘿)。&lt;/p&gt;&lt;h2&gt;开放架构与封闭架构&lt;/h2&gt;&lt;h3&gt;开放架构&lt;/h3&gt;&lt;p&gt;任何组件都可以调用任何其它组件，而不必考虑组件所在的层。可以向上向下调用。&lt;/p&gt;&lt;p&gt;开发架构有很大的灵活性，不过显然会导致层与层之间互相耦合，层内的横向调用也会导致层内的相互耦合，这样的项目是没法维护的。&lt;/p&gt;&lt;p&gt;作者认为产生横向调用是因为架构按照功能分解的恶果之一。&lt;/p&gt;&lt;h3&gt;封闭架构&lt;/h3&gt;&lt;p&gt;封闭架构禁止层内的横向调用，并且禁止下层调用上层系统。这样才能发挥分层的优势，将层与层之间解耦。封闭架构只允许一层的组件调用相邻较低层中的组件。下层的组件封装更下层的逻辑。&lt;/p&gt;&lt;h3&gt;半封闭半开放架构&lt;/h3&gt;&lt;p&gt;基础设施的关键部分，有时互相调用是难以避免的。因为基础设施要考虑性能问题，必须要进行最大优化，而有时向下转换会导致性能问题。&lt;/p&gt;&lt;p&gt;还有基本不怎么变的系统，耦合就耦合了，你管它呢。作者这里举了一个例子，网络栈就是基本不怎么变化的代码。&lt;/p&gt;&lt;p&gt;但大多系统不需要半开半闭，只要封闭就可以了。&lt;/p&gt;&lt;h3&gt;放宽一点封闭架构的规则&lt;/h3&gt;&lt;p&gt;因为封闭架构的要求太苛刻，实际开发中确实会遇到问题，在下面这些情况下也可以酌情放宽：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用 utilities&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;按业务逻辑访问资源访问，即 manager 层直接调用 resource access 层&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;manager 组件调用不太相邻的引擎&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;manager 组件到其它 manager 组件通过 MQ 来通信，这种情况 manager 组件不需要知道其它组件，只要发 message 就可以了&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;设计禁忌&lt;/h2&gt;&lt;p&gt;下面这些行为都是不能允许的：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;client 不应该在一个用例中调用多个 manager&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;client 不应该直接调用 engine&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同一个用例中，manager 不应该将等待多个 manager 的返回结果，这种情况下应该用 pub/sub 模型&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引擎不应该订阅消息队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;resource access 层不应该订阅消息队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;client 不应该向消息队列发布消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引擎不应该发布消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;resource access 不应该发布消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;resource 也不应该发布消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;engine 不应该相互调用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;manager 之间不应该相互调用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;可组合架构与架构验证&lt;/h2&gt;&lt;p&gt;这里又提出了反直觉的观点，&lt;strong&gt;一定不要根据需求设计，而是要根据易变性来设计&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;设计系统时，要从需求列表中找到核心需求，在设计完成之后，先用核心用例进行架构验证。举个例子，书里说的 Trade 系统，核心用例就是交易撮合。&lt;/p&gt;&lt;p&gt;增加新的需求时，应该不太需要变更架构，这才说明这套架构设计对了。&lt;/p&gt;&lt;p&gt;系统中的功能是集成的结果，而不是实现的结果。(有点抽象，想看明白的这里还是读读书好了)。&lt;/p&gt;&lt;h2&gt;案例&lt;/h2&gt;&lt;p&gt;系统设计的最后一部分，给出了前面说的 Trade 系统的相对完整的几个核心用例在按照易变性设计上的验证过程。&lt;/p&gt;&lt;p&gt;先是按照前面的四个问题的分析框架，把相关的概念进行罗列：&lt;/p&gt;&lt;p&gt;• Who&lt;br/&gt;- 技工&lt;br/&gt;- 承包商&lt;br/&gt;- TradeMe 客户代表&lt;br/&gt;- 教育中心&lt;br/&gt;- 后台程序 (i.e., scheduler for payment)&lt;/p&gt;&lt;p&gt;• What&lt;br/&gt;- 技工和承包商会员资质&lt;br/&gt;- 建筑项目 marketplace&lt;br/&gt;- 教育证书和培训&lt;/p&gt;&lt;p&gt;• How&lt;br/&gt;- 搜索&lt;br/&gt;- 合规&lt;br/&gt;- 访问资源&lt;/p&gt;&lt;p&gt;• Where&lt;br/&gt;- 本地数据库&lt;br/&gt;- 云端&lt;br/&gt;- 其它系统&lt;/p&gt;&lt;p&gt;然后对易变性进行分析，并列出易变性列表：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;客户端应用程序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;管理会员&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;费用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;项目&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;争议处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;匹配和批准&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;教育&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;法规&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;报告&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本地化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;资源访问&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部署模型&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;认证和授权&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;此外还有两个比较弱的易变性：&lt;/p&gt;&lt;p&gt;将易变性进行合理映射后，设计出的静态架构如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.59921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbe6dpTCiaTUxPicvSDYzibArxPXVciaHP8Aib47keMicv4vD2w5IhXcEYRgQeW9QL3cCRBKh9aWhAMCjPmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;然后从需求中找出核心用例，分别是：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;添加技工/承包商用例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请求技工用例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;匹配技工用例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分配技工用例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;终止技工用例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支付技工用例&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;通过泳道图，能够将核心用例一一进行验证即可。类似这样：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6454767726161369&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbe6dpTCiaTUxPicvSDYzibArxPgJnp6CaRPib5iaBOVibiaN5BGVeibicgSwlnW6PUmavRANc4vyDpNY5OK6Mg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1636&quot;/&gt;&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;《righting software》这本书给了我们一种全新的设计系统架构的思路，只看作者的描述的话，确实是比之前的功能分解和 DDD 分解要靠谱一些，但&lt;strong&gt;考虑到现在国内的互联网公司连用不要用 DDD 都要吵吵半天的实际情况，基于可变性的设计方法被普遍接受可能比较难&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;作者没有像 DDD 社区那样拉一堆大佬上站台，尽管他也有多年的从业经验，且被人誉为微服务的先驱，但相比 DDD 社区那些更能嚷嚷的大佬，这套方法论缺少更多的外部实践。&lt;/p&gt;&lt;p&gt;这本书里只给出了一个案例，后半部分都在讲项目管理了，稍微有点遗憾。&lt;/p&gt;&lt;p&gt;在阅读过程中，我也结合了之前公司内的开发经历不断地思考，能看出作者的理论在没有政治影响的情况下，应该是能自洽的。&lt;/p&gt;&lt;p&gt;不过这套理论有一个比较关键的问题，&lt;strong&gt;架构师在易变性分析的过程中，存在遗漏可变性的可能性&lt;/strong&gt;。这在我之前见过的无数项目中都发生过，架构师前脚走，后面一线的工程师就在吐槽架构师能力不行，设计出来的东西满足不了新需求。&lt;/p&gt;&lt;p&gt;如果是做&lt;strong&gt;创新业务，可能无时无刻不在做一些颠覆性的东西&lt;/strong&gt;，易变性分析一旦有所遗漏，做出稳定的架构还是挺难的。&lt;/p&gt;&lt;p&gt;先不提这些，这本书的新观点还是值得学习的。&lt;/p&gt;&lt;p&gt;如果你对这本感兴趣，也可以购买中文翻译版：&lt;/p&gt;&lt;section&gt;&lt;mpcps frameborder=&quot;0&quot; class=&quot;js_editor_cps&quot; data-datakey=&quot;1632329754241_0.9529256845661089&quot; data-uid=&quot;1632329754239&quot; data-type=&quot;1&quot; data-product=&quot;&quot; data-templateid=&quot;list&quot; data-pid=&quot;13382576&quot; data-categoryid=&quot;3&quot; data-appuin=&quot;3208869061&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;本书介绍详见：&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg5MDU5NTM1NQ==&amp;amp;mid=2247523085&amp;amp;idx=2&amp;amp;sn=1a4d9bb0de5b1693bb5b19e498866db6&amp;amp;scene=21#wechat_redirect&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;架构之道&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看到这里的朋友，这次依然有送书活动，截止 9.23 号晚上 23:59:59，如果你满足下面的条件：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第一、第二个评论&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;除第一、第二个回复之外，点赞前三的评论&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么你就可以获得一本《架构之道》的中文版。&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>