<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>57f56a1e4e38799eb7ab696d3c5f59d1</guid>
<title>我不能没有的 5 个 Vue.js 库</title>
<link>https://toutiao.io/k/l04ibvu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;1.Click Off to Close&lt;/h2&gt;&lt;section&gt;&lt;span&gt;有的时候，我们需要在用户点击元素之外的时候触发一个事件。最常见的用例是当你想通过点击关闭一个下拉框或对话框时。这是一个必不可少的包，几乎在我构建的每个应用中都会用到。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首选：&lt;strong&gt;vue-clickaway&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.343&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/WYoaOn5t0AOUCI5wdH14guJwREX4cO5L1aIfJpkoe1cGNfW94R5KFticPvwr2lVHuLKChzxpbGU7HMNbiaiaZpt1w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1000&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;https://github.com/simplesmiler/vue-clickaway&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;我通常会将它安装在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;main.js&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中，以便在我的应用程序中使用。如果你只在一个或两个页面上使用它，你可能会想单独导入它。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你真的单独导入，请记住，指令需要在指令下暴露。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;✅ &lt;code&gt;&lt;span&gt;directives: { onClickaway }&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;而不是组件：&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❌ &lt;code&gt;&lt;span&gt;components: { onClickaway }&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;使其全局可用（在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;main.js&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中）：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { directive &lt;span&gt;as&lt;/span&gt; onClickaway } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;vue-clickaway&#x27;&lt;/span&gt;&lt;br/&gt;Vue.directive(&lt;span&gt;&#x27;on-clickaway&#x27;&lt;/span&gt;, onClickaway)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在模板中：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4517937219730942&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOUCI5wdH14guJwREX4cO5LcD1ejkKgUBFYPyn8gmUb2dKB26G9zk4c2UCHl8xrn7ib5kIGKHcfM6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;想象一下，我有一个完整的选择框，其中包含 &lt;/span&gt;&lt;code&gt;&lt;span&gt;li&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 元素列表（此处未显示）。上面的按钮用于触发我的自定义选择框项目列表，当我在该元素外点击时，会触发一个关闭选项列表的方法。这比强迫用户始终单击元素右上角处的“X”按钮要好得多。我们只需将以下内容添加到按钮即可获得此功能：&lt;/span&gt;&lt;code&gt;&lt;span&gt;v-on-clickaway = &quot;closeMethodName&quot;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;你应该总是在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;close&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法中使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;vue-clickaway&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ，而不是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;toggle&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法。我的意思是这个方法连接到&lt;/span&gt;&lt;code&gt;&lt;span&gt;v-on-clickaway&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 应该是这样的:&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;closeMethod() {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.showSomething = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而不是这样：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;toggleMethod() {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.showSomething = !&lt;span&gt;this&lt;/span&gt;.showSomething&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;如果你使用了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;toggle&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法，那么每当你在该元素外点击时，无论你点击什么，它都会打开，然后一遍遍地关闭该元素。这很可能不是你想要的结果，所以请记住使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;close&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法来防止这种情况发生。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;2.Toasts (Notification Bar)&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首选：&lt;strong&gt;vue-toastification&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.495&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/WYoaOn5t0AOUCI5wdH14guJwREX4cO5LiaZLPibbq2z5WWickAMysdSiafVfDl8XG6u6OxIYCb1Wvk7ZTCWG9NyKicQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1000&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;https://maronato.github.io/vue-toastification/&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;你有很多toast和类似通知的选择，但我是Maronato的vue-toastification的忠实粉丝。它提供了大量的选项来覆盖你的大部分边界情况，而且样式和动画导致了出色的用户体验，远远超过其他软件包。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Vue-toastification提供了几种在其文档中使用它的方法。你可以在组件级别，全局级别甚至在Vuex内执行此操作，如果你希望根据状态或与服务器相关的操作显示toasts。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;全局使用（在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;main.js&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中）：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; Toast &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;vue-toastification&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Toast styles&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&#x27;vue-toastification/dist/index.css&#x27;&lt;/span&gt;&lt;br/&gt;Vue.use(Toast, {&lt;br/&gt;  &lt;span&gt;transition&lt;/span&gt;: &lt;span&gt;&#x27;Vue-Toastification__bounce&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;maxToasts&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;newestOnTop&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;position&lt;/span&gt;: &lt;span&gt;&#x27;top-right&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;timeout&lt;/span&gt;: &lt;span&gt;2000&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;closeOnClick&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;pauseOnFocusLoss&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;pauseOnHover&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;draggable&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;draggablePercent&lt;/span&gt;: &lt;span&gt;0.7&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;showCloseButtonOnHover&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;hideProgressBar&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;closeButton&lt;/span&gt;: &lt;span&gt;&#x27;button&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;icon&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;rtl&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;你可以在每个组件中单独控制样式，但在上面的案例中，我通过将它导入 &lt;/span&gt;&lt;code&gt;&lt;span&gt;main.js&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，然后在那里设置我想使用的选项，使它在我的应用程序中到处可用，这使我不必每次都编写相同的选项属性。Vue-toastification有一个很好的在线演示，在这里你可以看到每个选项属性的结果，只需要复制粘贴你想要的选项，就像我上面做的那样。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;选项1：在组件（模板）中使用Toast&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&quot;showToast&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;Show toast&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2710997442455243&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOUCI5wdH14guJwREX4cO5LEmRKwLvrtluCHtfmE9F1IQ5SWMlyMS9Cz6MuAJp1GQpkgPKDfqD7XQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1173&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;选项2：在Vuex action中发现错误（或成功）时调用Toast&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4110738255033557&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOUCI5wdH14guJwREX4cO5Lb26KUYk2p31UlC5cjOHiaqOzOSEGOyU3Rr2micziaia2FKq69Oft6x8ibtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1192&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;你只需将 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.error&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 改为 .success&lt;/span&gt;&lt;code&gt;&lt;span&gt;，&lt;/span&gt;&lt;/code&gt;&lt;span&gt;.info&lt;/span&gt;&lt;code&gt;&lt;span&gt;，&lt;/span&gt;&lt;/code&gt;&lt;span&gt;.warning 即可更改所需的Toast类型，也可以将其完全删除以作为默认的Toast通知。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Toasts可以让你根据实时状态的变化或者发生了不可预见的错误来显示消息，这大大改善了用户的体验。Toasts提供了比模态或丑陋的提示框更好的视觉指示，例如，用户必须提供一个额外的点击来关闭。用户会很感激你给他们一个视觉上的提示，让他们知道出了什么问题，防止他们盯着屏幕茫然地等待一些永远不会发生的事情。确认他们执行的操作是否成功完成也很有用。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1603699772392&quot; data-category_id_list=&quot;48|26|49|1|55|8|47|35|5|6|7|24|37|11|50|54|53|52|42|29|43|16|17|51|36&quot; data-id=&quot;1603699772392&quot;/&gt;&lt;span&gt;3.Tables&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首选：&lt;strong&gt;vue-good-table&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.43&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOUCI5wdH14guJwREX4cO5Lial31Wn8ggKf3l3spzxP2Cd34YIKYpforxficM4te6bAM80diayIEw5dQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;https://xaksis.github.io/vue-good-table&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;表格是许多Web应用程序的重要组成部分，选择错误的表格会让你陷入无尽的痛苦之中。尝试了很长的包选项列表后，我相信vue-good-table将解决你大部分的表需求。它不仅仅是为了好玩才叫“good-table”。它真的很好，提供了更多的选择和功能，超出了你的能力范围。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在以下情况下，我将 &lt;/span&gt;&lt;code&gt;&lt;span&gt;:rows&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 数据绑定到名为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;getOrderHistory&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的Vuex getter。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7504159733777038&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOUCI5wdH14guJwREX4cO5L6AjNcRAO3ibDHlA0xcx3teWr1tPQpQUc4HMhQSoATTy5818burKRcZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在本地 &lt;/span&gt;&lt;code&gt;&lt;span&gt;data()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中定义我的列：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1537822111388196&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOUCI5wdH14guJwREX4cO5L53rJJoEtdhTLX2jRicJFxqmhmy3AdCFUcY5NfeYKAgohEOcPyUGb0Lw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1203&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;label&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是显示的列标题，而 &lt;/span&gt;&lt;code&gt;&lt;span&gt;field&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是我在Vuex getter中绑定的数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在上图中，我还使用了vue-good-table的一些自定义选项，比如设置我的日期的输入和输出格式(这让我可以把服务器提供的一个很长的时间戳改成对我的用户来说更易读的东西)。我还使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;formatFn&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来格式化我的价格，调用了一个我命名为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;toLocale&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的单独方法，然后我通过绑定 &lt;/span&gt;&lt;code&gt;&lt;span&gt;tdClass&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 到我在 local &lt;/span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;style&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中设置的类来定制每个单元格的外观。Vue-good-table确实内置了无穷的可定制性，他们已经覆盖了非常广泛的边缘案例。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Vue-good-table还可以与自定义模板配合使用，因此你可以轻松地将按钮，选择框或您喜欢的其他任何东西注入到表格的单元格中。为此，你只需使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;v-if&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 定义应将其注入的位置。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;要添加另一个自定义列，只需在你的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;v-if&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 标签后面添加一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;v-else-if&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（在上面的例子中是一个跨度），然后在那里添加第二个自定义模板的逻辑。无论你需要什么，vue-good-table都能满足你的需求。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;4.Date Picker&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首选：&lt;strong&gt;vue2-datepicker&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.421&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/WYoaOn5t0AOUCI5wdH14guJwREX4cO5LKxHzrMFTuW7ZKibHYA9BE47iabFiaXmD8aUQYdA1kH137ibU6EhsBqlKgA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1000&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;https://mengxiong10.github.io/vue2-datepicker/index.html#Basic&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;啊，日期选择器，这是许多应用程序的重要组成部分。在这个列表中，日期选择器的选择比其他任何东西都多，但Mengxiong打造的vue2-datepicker是我不断回归的一个选择。它的风格简单，提供了广泛的选择日期和日期范围的选项，并被包装在一个光滑和用户友好的UI中。它甚至支持i18n语言和日期格式的本地化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;尽管包名为vue2-datepicker，但将这个包(或这里列出的其他包)添加到Vue 3.0应用程序中应该没有问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在组件或视图中导入，使其可以使用。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; DatePicker &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;vue2-datepicker&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;// styles&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&#x27;vue2-datepicker/index.css&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在模板中：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42907385697538103&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOUCI5wdH14guJwREX4cO5Ljel0nBuHBhxUycYJtCQoh2MoaWN8gLYdvtSk5Dse68orTpbmsRPRBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;853&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;在这里，我使用的是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;range&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 选项，允许用户选择日期范围，并将用户输入的日期 &lt;/span&gt;&lt;code&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 以一个名为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;dateRange&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的数据值绑定。然后，vue-good-table（如下）使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;dateRange&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对我的表的结果进行排序。我还使用事件选项 &lt;/span&gt;&lt;code&gt;&lt;span&gt;@clear&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;@input&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来触发重置表（resetList）或发送服务器请求表数据（searchDate）的方法。Vue2-datepicker提供了更多的选项和事件，以方便你的使用，但这些是我发现自己最经常使用的。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;5.User Ratings&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首选：&lt;strong&gt;vue-star-rating&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.041&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/WYoaOn5t0AOUCI5wdH14guJwREX4cO5LKiakCO1BTJZzbOIg3Hlias1XwvjXord6CVlN3TqcO8I3ibqwoowKIrFvA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1000&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;https://github.com/craigh411/vue-star-rating&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;虽然你可能不会在每个项目中都使用这个功能，但对于任何需要用户评级元素的网站（比如Amazon或Rotten Tomatoes），vue-star-rating是我的首选。自己创建看似是一件微不足道的事情，但当你进入细节后，星级评定很快就会变得比你预期的要复杂。如果需要特殊功能，它可以让你使用自定义SVG形状，并且可以轻松自定义大小，间距和颜色。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过这些选项，可以很容易地将用户选择的评级 &lt;/span&gt;&lt;code&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 绑定到任何你想使用的地方，你可以通过一个prop将评级设置为可更改或只读。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你发现需要更多选择，请查看创建者的扩展软件包vue-rate-it。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在模板中（带有选项）：&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.39558417663293466&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOUCI5wdH14guJwREX4cO5LiaLSVgFBdFosIKuKBgjMOfKK2CFf9xDiaIOMG1YfkprLicjgA1VmgI2lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1087&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;将其导入到组件或视图中：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3274745605920444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOUCI5wdH14guJwREX4cO5LzDdjibic2Sd4GjxjS7ia6Z99lsQy6Po1FBEOSe4hh5PGemCLltkg8mxow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1081&quot;/&gt;&lt;/figure&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;900&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOPiaqWez1sKrh7Hffjoia7y8zkhic56DPic8FsoheTZljsrr5rpFMFcp7OgSZoOuuLKdXkWmhKibHia0fQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f14dd5732e3fa1153f523f6b9ac19cbf</guid>
<title>阿里终面：分布式事务原理</title>
<link>https://toutiao.io/k/vunm1k6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文提纲如下&lt;/p&gt;&lt;ol start=&quot;0&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;前言&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单数据源事务 &amp;amp; 多数据源事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;常见分布式事务解决方案&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;2.1. 分布式事务模型&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.2. 二将军问题和幂等性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.3. 两阶段提交（2PC） &amp;amp; 三阶段提交（3PC）方案&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.4. TCC 方案&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.5. 事务状态表方案&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.6. 基于消息中间件的最终一致性事务方案&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;Seata in AT mode 的实现&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;3.1. Seata in AT mode 工作流程概述&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3.2. Seata in AT mode 工作流程详述&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;结束语&lt;/section&gt;&lt;/li&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5766793409378961&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OqmCT8JwGrJu90FJetDcJDBrHYylXMP3X9Lsru4V0SbK3NzuqmqJbCA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;789&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;0. 前言&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 CPU 到内存、到磁盘、到操作系统、到网络，计算机系统处处存在不可靠因素。工程师和科学家努力使用各种软硬件方法对抗这种不可靠因素，保证数据和指令被正确地处理。在网络领域有 &lt;strong&gt;TCP 可靠传输协议&lt;/strong&gt;、在存储领域有 &lt;strong&gt;Raid5&lt;/strong&gt; 和 &lt;strong&gt;Raid6&lt;/strong&gt; 算法、在数据库领域有 &lt;strong&gt;基于 ARIES 算法理论实现的事务机制&lt;/strong&gt;……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章先介绍&lt;strong&gt;单机数据库事务的 ACID 特性&lt;/strong&gt;，然后指出&lt;strong&gt;分布式场景下操作多数据源面临的困境&lt;/strong&gt;，引出&lt;strong&gt;分布式系统中常用的分布式事务解决方案&lt;/strong&gt;，这些解决方案可以保证业务代码在操作多个数据源的时候，能够像操作单个数据源一样，具备 ACID 特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章在最后给出业界较为成熟的分布式事务框架——&lt;strong&gt;Seata 的 AT 模式全局事务的实现&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;1. 单数据源事务 &amp;amp; 多数据源事务&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个应用程序在一次业务流中通过连接驱动和数据源接口只连接并查询（这里的查询是广义的，包括增删查改等）一个特定的数据库，该应用程序就可以利用数据库提供的事务机制（如果数据库支持事务的话）保证对库中记录所进行的操作的可靠性，这里的可靠性有四种语义：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;笔者在这里不再对这四种语义进行解释，了解单数据源事务及其 ACID 特性是读者阅读这篇文章的前提。单个数据库实现自身的事务特性是一个复杂又微妙的过程，例如 &lt;strong&gt;MySQL 的 InnoDB 引擎通过 Undo Log + Redo Log + ARIES 算法来实现&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个很宏大的话题，不在本文的描述范围，读者有兴趣的话可自行研究。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;单数据源事务也可以叫做单机事务，或者本地事务。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式场景下，一个系统由多个子系统构成，每个子系统有独立的数据源。多个子系统之间通过互相调用来组合出更复杂的业务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在时下流行的微服务系统架构中，每一个子系统被称作一个微服务，同样每个微服务都维护自己的数据库，以保持独立性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，一个电商系统可能由购物微服务、库存微服务、订单微服务等组成。购物微服务通过调用库存微服务和订单微服务来整合出购物业务。用户请求购物微服务商完成下单时，购物微服务一方面调用库存微服务扣减相应商品的库存数量，另一方面调用订单微服务插入订单记录（为了后文描述分布式事务解决方案的方便，这里给出的是一个最简单的电商系统微服务划分和最简单的购物业务流程，后续的支付、物流等业务不在考虑范围内）。电商系统模型如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2506596306068603&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5O1Z1djEJzPNiaVyvIGQPgtQZm8gG81ibunnYh7yMjH62MDpNqDvToXrlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;379&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在用户购物的业务场景中，&lt;strong&gt;shopping-service&lt;/strong&gt; 的业务涉及两个数据库：&lt;strong&gt;库存库（repo_db）&lt;strong&gt;和&lt;/strong&gt;订单库（repo_db）&lt;/strong&gt;，也就是 g 购物业务是调用多数据源来组合而成的。作为一个面向消费者的系统，电商系统要保证购物业务的高度可靠性，这里的可靠性同样有 ACID 四种语义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是一个数据库的本地事务机制仅仅对落到自己身上的查询操作（这里的查询是广义的，包括增删改查等）起作用，无法干涉对其他数据库的查询操作。所以，&lt;strong&gt;数据库自身提供的本地事务机制无法确保业务对多数据源全局操作的可靠性。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于此，针对多数据源操作提出的分布式事务机制就出现了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分布式事务也可以叫做全局事务。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;2. 常见分布式事务解决方案&lt;/strong&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1. 分布式事务模型&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5Og9TkSZzCB0expnKC5ceF7Tk0YXTRic9v38yKfKYXnic2CEbFbM1JEGPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;描述分布式事务，常常会使用以下几个名词：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;事务参与者&lt;/strong&gt;：例如每个数据库就是一个事务参与者&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;事务协调&lt;/strong&gt;者：访问多个数据源的服务程序，例如 shopping-service 就是事务协调者&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;资源管理器（Resource Manager, RM）&lt;/strong&gt;：通常与事务参与者同义&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;事务管理器（Transaction Manager, TM）&lt;/strong&gt;：通常与事务协调者同义&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式事务模型中，一个 TM 管理多个 RM，即一个服务程序访问多个数据源；TM 是一个全局事务管理器，协调多方本地事务的进度，使其共同提交或回滚，最终达成一种全局的 ACID 特性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2. 二将军问题和幂等性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二将军问题是网络领域的一个经典问题，用于表达计算机网络中互联协议设计的微妙性和复杂性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里给出一个二将军问题的简化版本：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;一支白军被围困在一个山谷中，山谷的左右两侧是蓝军。困在山谷中的白军人数多于山谷两侧的任意一支蓝军，而少于两支蓝军的之和。若一支蓝军对白军单独发起进攻，则必败无疑；但若两支蓝军同时发起进攻，则可取胜。两只蓝军的总指挥位于山谷左侧，他希望两支蓝军同时发起进攻，这样就要把命令传到山谷右侧的蓝军，以告知发起进攻的具体时间。假设他们只能派遣士兵穿越白军所在的山谷（唯一的通信信道）来传递消息，那么在穿越山谷时，士兵有可能被俘虏。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.8775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5O4MyMt1lE2m7kwf2SLLeXXfqlAQqReD1hhndqm28XPibMl2F1J1iazyKw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有当送信士兵成功往返后，总指挥才能确认这场战争的胜利（上方图）。现在问题来了，派遣出去送信的士兵没有回来，则左侧蓝军中的总指挥能不能决定按命令中约定的时间发起进攻？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是不确定，派遣出去送信的士兵没有回来，他可能遇到两种状况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;命令还没送达就被俘虏了（中间图），这时候右侧蓝军根本不知道要何时进攻；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;命令送达，但返回途中被俘虏了（下方图），这时候右侧蓝军知道要何时进攻，但左侧蓝军不知道右侧蓝军是否知晓进攻时间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似的问题在计算机网络中普遍存在，例如发送者给接受者发送一个 HTTP 请求，或者 MySQL 客户端向 MySQL 服务器发送一条插入语句，然后超时了没有得到响应。请问服务器是写入成功了还是失败了？答案是不确定，有以下几种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可能请求由于网络故障根本没有送到服务器，因此写入失败；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可能服务器收到了，也写入成功了，但是向客户端发送响应前服务器宕机了；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可能服务器收到了，也写入成功了，也向客户端发送了响应，但是由于网络故障未送到客户端。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论哪种场景，在客户端看来都是一样的结果：它发出的请求没有得到响应。为了确保服务端成功写入数据，客户端只能重发请求，直至接收到服务端的响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似的问题问题被称为&lt;strong&gt;网络二将军问题&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;网络二将军问题的存在使得消息的发送者往往要重复发送消息，直到收到接收者的确认才认为发送成功，但这往往又会导致消息的重复发送。&lt;/strong&gt; 例如电商系统中订单模块调用支付模块扣款的时候，如果网络故障导致二将军问题出现，扣款请求重复发送，产生的重复扣款结果显然是不能被接受的。因此要保证一次事务中的扣款请求无论被发送多少次，接收方有且只执行一次扣款动作，这种保证机制叫做接收方的幂等性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OCkOSATodib1kENFfXyARy7uI3wEzS2QyG1K5y8tyqepjg7d4O17faicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3. 两阶段提交（2PC） &amp;amp; 三阶段提交（3PC）方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2PC 是一种实现分布式事务的简单模型&lt;/strong&gt;，这两个阶段是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;准备阶段&lt;/strong&gt;：事务协调者向各个事务参与者发起询问请求：“我要执行全局事务了，这个事务涉及到的资源分布在你们这些数据源中，分别是……，你们准备好各自的资源（即各自执行本地事务到待提交阶段）”。各个参与者协调者回复 yes（表示已准备好，允许提交全局事务）或 no（表示本参与者无法拿到全局事务所需的本地资源，因为它被其他本地事务锁住了）或超时。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提交阶段：如果各个参与者回复的都是 yes，则协调者向所有参与者发起事务提交操作，然后所有参与者收到后各自执行本地事务提交操作并向协调者发送 ACK；如果任何一个参与者回复 no 或者超时，则协调者向所有参与者发起事务回滚操作，然后所有参与者收到后各自执行本地事务回滚操作并向协调者发送 ACK。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2PC 的流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8847184986595175&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5Oqr1VBDytKVqEicFfa8Wg3HOXmF3GyUkIILDj7VUHOWvAoe7LQ4bKvCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;746&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图可以看出，要实现 2PC，所有的参与者都要实现三个接口：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Prepare()&lt;/strong&gt;：TM 调用该接口询问各个本地事务是否就绪&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Commit()&lt;/strong&gt;：TM 调用该接口要求各个本地事务提交&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Rollback()&lt;/strong&gt;：TM 调用该接口要求各个本地事务回滚&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以将这三个接口简单地（但不严谨地）理解成 &lt;strong&gt;XA 协议&lt;/strong&gt;。XA 协议是 X/Open 提出的分布式事务处理标准。MySQL、Oracle、DB2 这些主流数据库都实现了 XA 协议，因此都能被用于实现 2PC 事务模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2PC 简明易懂，但存在如下的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;性能差。在准备阶段，要等待所有的参与者返回，才能进入阶段二，在这期间，各个参与者上面的相关资源被排他地锁住，参与者上面意图使用这些资源的本地事务只能等待。因为存在这种同步阻塞问题，所以影响了各个参与者的本地事务并发度；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;准备阶段完成后，如果协调者宕机，所有的参与者都收不到提交或回滚指令，导致所有参与者“不知所措”；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在提交阶段，协调者向所有的参与者发送了提交指令，如果一个参与者未返回 ACK，那么协调者不知道这个参与者内部发生了什么（由于网络二将军问题的存在，这个参与者可能根本没收到提交指令，一直处于等待接收提交指令的状态；也可能收到了，并成功执行了本地提交，但返回的 ACK 由于网络故障未送到协调者上），也就无法决定下一步是否进行全体参与者的回滚。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2PC 之后又出现了 3PC，把两阶段过程变成了三阶段过程，分别是：&lt;strong&gt;1.询问阶段&lt;/strong&gt;、&lt;strong&gt;2.准备阶段&lt;/strong&gt;、&lt;strong&gt;3.提交或回滚阶段&lt;/strong&gt;，这里不再详述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3PC 利用超时机制解决了 2PC 的同步阻塞问题，避免资源被永久锁定，进一步加强了整个事务过程的可靠性。但是 3PC 同样无法应对类似的宕机问题，只不过出现多数据源中数据不一致问题的概率更小。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2PC 除了性能和可靠性上存在问题，它的适用场景也很局限，它要求参与者实现了 XA 协议，例如使用实现了 XA 协议的数据库作为参与者可以完成 2PC 过程。但是在多个系统服务利用 api 接口相互调用的时候，就不遵守 XA 协议了，这时候 2PC 就不适用了。所以 2PC 在分布式应用场景中很少使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以前文提到的电商场景无法使用 2PC，因为 shopping-service 通过 RPC 接口或者 Rest 接口调用 repo-service 和 order-service 间接访问 repo_db 和 order_db。除非 shopping-service 直接配置 repo_db 和 order_db 作为自己的数据库。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4. TCC 方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;描述 TCC 方案使用的电商微服务模型如下图所示，在这个模型中，shopping-service 是事务协调者，repo-service 和 order-service 是事务参与者。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2440944881889764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5ORRW2eiaJESv0YyxfNQAuR78nibPibYPCQFiabSjhD6LORxttFiaKYLHsNBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;381&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文提到，2PC 要求参与者实现了 XA 协议，通常用来解决多个数据库之间的事务问题，比较局限。在多个系统服务利用 api 接口相互调用的时候，就不遵守 XA 协议了，这时候 2PC 就不适用了。现代企业多采用分布式的微服务，因此更多的是要解决多个微服务之间的分布式事务问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCC 就是一种解决多个微服务之间的分布式事务问题的方案。TCC 是 Try、Confirm、Cancel 三个词的缩写，其本质是一个应用层面上的 2PC，同样分为两个阶段：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;准备阶段&lt;/strong&gt; ：协调者调用所有的每个微服务提供的 try 接口，将整个全局事务涉及到的资源锁定住，若锁定成功 try 接口向协调者返回 yes。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;提交阶段&lt;/strong&gt; ：若所有的服务的 try 接口在阶段一都返回 yes，则进入提交阶段，协调者调用所有服务的 confirm 接口，各个服务进行事务提交。如果有任何一个服务的 try 接口在阶段一返回 no 或者超时，则协调者调用所有服务的 cancel 接口。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCC 的流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.871222076215506&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5ObtPwqrF3V59taSch79uRGELZNib6CwWcE6nvlbicFUaP2xCiaeiaZXmz3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;761&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有个关键问题，既然 TCC 是一种服务层面上的 2PC。&lt;strong&gt;它是如何解决 2PC 无法应对宕机问题的缺陷的呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是不断重试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 try 操作锁住了全局事务涉及的所有资源，保证了业务操作的所有前置条件得到满足，因此无论是 confirm 阶段失败还是 cancel 阶段失败都能通过不断重试直至 confirm 或 cancel 成功（所谓成功就是所有的服务都对 confirm 或者 cancel 返回了 ACK）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5Ob3qPfib0qAIB6F5nIrO0R9HKS3O8bIxv2m6FMciaF3DOQgHdYJAV10Gg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里还有个关键问题，在不断重试 confirm 和 cancel 的过程中（考虑到网络二将军问题的存在）有可能重复进行了 confirm 或 cancel，因此还要再保证 confirm 和 cancel 操作具有幂等性，也就是整个全局事务中，每个参与者只进行一次 confirm 或者 cancel。实现 confirm 和 cancel 操作的幂等性，有很多解决方案，例如每个参与者可以维护一个去重表（可以利用数据库表实现也可以使用内存型 KV 组件实现），记录每个全局事务（以全局事务标记 XID 区分）是否进行过 confirm 或 cancel 操作，若已经进行过，则不再重复执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCC 由支付宝团队提出，被广泛应用于金融系统中。我们用银行账户余额购买基金时，会注意到银行账户中用于购买基金的那部分余额首先会被冻结，由此我们可以猜想，这个过程大概就是 TCC 的第一阶段。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5. 事务状态表方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外有一种类似 TCC 的事务解决方案，借助事务状态表来实现。假设要在一个分布式事务中实现调用 repo-service 扣减库存、调用 order-service 生成订单两个过程。在这种方案中，协调者 shopping-service 维护一张如下的事务状态表：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;分布式事务 ID&lt;/th&gt;&lt;th&gt;事务内容&lt;/th&gt;&lt;th&gt;事务状态&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;global_trx_id_1&lt;/td&gt;&lt;td&gt;操作 1：调用 repo-service 扣减库存 操作 2：调用 order-service 生成订单&lt;/td&gt;&lt;td&gt;状态 1：初始 状态 2：操作 1 成功 状态 3：操作 1、2 成功&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始状态为 1，每成功调用一个服务则更新一次状态，最后所有的服务调用成功，状态更新到 3。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这张表，就可以启动一个后台任务，扫描这张表中事务的状态，如果一个分布式事务一直（设置一个事务周期阈值）未到状态 3，说明这条事务没有成功执行，于是可以重新调用 repo-service 扣减库存、调用 order-service 生成订单。直至所有的调用成功，事务状态到 3。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果多次重试仍未使得状态到 3，可以将事务状态置为 error，通过人工介入进行干预。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于存在服务的调用重试，因此每个服务的接口要根据全局的分布式事务 ID 做幂等，原理同 2.4 节的幂等性实现。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.6. 基于消息中间件的最终一致性事务方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;无论是 2PC &amp;amp; 3PC 还是 TCC、事务状态表，基本都遵守 XA 协议的思想&lt;/strong&gt;。即这些方案本质上都是事务协调者协调各个事务参与者的本地事务的进度，使所有本地事务共同提交或回滚，最终达成一种全局的 ACID 特性。在协调的过程中，协调者需要收集各个本地事务的当前状态，并根据这些状态发出下一阶段的操作指令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这些全局事务方案由于操作繁琐、时间跨度大，或者在全局事务期间会排他地锁住相关资源，使得整个分布式系统的全局事务的并发度不会太高。这很难满足电商等高并发场景对事务吞吐量的要求，因此互联网服务提供商探索出了很多与 XA 协议背道而驰的分布式事务解决方案。其中利用消息中间件实现的最终一致性全局事务就是一个经典方案。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5O5yszDOGWs9CVicia8qFwcH3GnYiah4b1Zkqibbk7eLib20LfJwaaRIZicHxg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了表现出这种方案的精髓，我将使用如下的电商系统微服务结构来进行描述：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.828752642706131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5O8H5s6iccLprEicEBucv7WjVyZXic6bmf3BWqRreuy8W5kr5K30icWkDRog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;473&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个模型中，用户不再是请求整合后的 shopping-service 进行下单，而是直接请求 order-service 下单，order-service 一方面添加订单记录，另一方面会调用 repo-service 扣减库存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种基于消息中间件的最终一致性事务方案常常被误解成如下的实现方式：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4182939362795478&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OT1CRZAQpT4dxQ6xzmjoHCHmrt3ue8pldzqI2LicXibOmDqicttDEGicK4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;973&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种实现方式的流程是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;order-service 负责向 MQ server 发送扣减库存消息（repo_deduction_msg）；repo-service 订阅 MQ server 中的扣减库存消息，负责消费消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户下单后，order-service 先执行插入订单记录的查询语句，后将 repo_deduction_msg 发到消息中间件中，这两个过程放在一个本地事务中进行，一旦“执行插入订单记录的查询语句”失败，导致事务回滚，“将 repo_deduction_msg 发到消息中间件中”就不会发生；同样，一旦“将 repo_deduction_msg 发到消息中间件中”失败，抛出异常，也会导致“执行插入订单记录的查询语句”操作回滚，最终什么也没有发生。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9090909090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5ODyrv0PYJv9icmhjQaMIQdTAAYTM3qk02BNWdLW5TNwGYQ7KUic8ISTGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;198&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;repo-service 接收到 repo_deduction_msg 之后，先执行库存扣减查询语句，后向 MQ sever 反馈消息消费完成 ACK，这两个过程放在一个本地事务中进行，一旦“执行库存扣减查询语句”失败，导致事务回滚，“向 MQ sever 反馈消息消费完成 ACK”就不会发生，MQ server 在 Confirm 机制的驱动下会继续向 repo-service 推送该消息，直到整个事务成功提交；同样，一旦“向 MQ sever 反馈消息消费完成 ACK”失败，抛出异常，也对导致“执行库存扣减查询语句”操作回滚，MQ server 在 Confirm 机制的驱动下会继续向 repo-service 推送该消息，直到整个事务成功提交。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.025974025974026&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OVWRCuEW5KCPYlqibgVGQsicA9gejI9v31kgRaIl7B4CeHEVOEpnOic7fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;154&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种做法看似很可靠。但没有考虑到网络二将军问题的存在，有如下的缺陷：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;网络的 2 将军问题&lt;/strong&gt; ：上面第 2 步中 order-service 发送 repo_deduction_msg 消息失败，对于发送方 order-service 来说，可能是消息中间件没有收到消息；也可能是中间件收到了消息，但向发送方 order-service 响应的 ACK 由于网络故障没有被 order-service 收到。因此 order-service 贸然进行事务回滚，撤销“执行插入订单记录的查询语句”，是不对的，因为 repo-service 那边可能已经接收到 repo_deduction_msg 并成功进行了库存扣减，这样 order-service 和 repo-service 两方就产生了数据不一致问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;数据库长事务问题&lt;/strong&gt; ：repo-service 和 order-service 把网络调用（与 MQ server 通信）放在本地数据库事务里，可能会因为网络延迟产生数据库长事务，影响数据库本地事务的并发度。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OSm6gAKgOZZIjZ4Bv73QOqkN493ibeKdichC6M9iaeiac5mCbiauWxJ1yJSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上是被误解的实现方式，下面给出正确的实现方式，如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.36018518518518516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OSWufbwc1iahgpyuxuk4HBjNbqk4BhZwMalMMnFiaN7U8a8iaPjs77RJHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图所示的方案，利用消息中间件如 rabbitMQ 来实现分布式下单及库存扣减过程的最终一致性。对这幅图做以下说明：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）order-service 中，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;在 t_order 表添加订单记录 &amp;amp;&amp;amp;&lt;br/&gt;&lt;br/&gt;在 t_local_msg 添加对应的扣减库存消息&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个过程要在一个事务中完成，保证过程的原子性。同样，repo-service 中，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;检查本次扣库存操作是否已经执行过 &amp;amp;&amp;amp;&lt;br/&gt;&lt;br/&gt;执行扣减库存如果本次扣减操作没有执行过 &amp;amp;&amp;amp;&lt;br/&gt;&lt;br/&gt;写判重表 &amp;amp;&amp;amp;&lt;br/&gt;&lt;br/&gt;向 MQ sever 反馈消息消费完成 ACK&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这四个过程也要在一个事务中完成，保证过程的原子性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）order-service 中有一个后台程序，源源不断地把消息表中的消息传送给消息中间件，成功后则删除消息表中对应的消息。如果失败了，也会不断尝试重传。由于存在网络 2 将军问题，即当 order-service 发送给消息中间件的消息网络超时时，这时候消息中间件可能收到了消息但响应 ACK 失败，也可能没收到，order-service 会再次发送该消息，直至消息中间件响应 ACK 成功，这样可能发生消息的重复发送，不过没关系，只要保证消息不丢失，不乱序就行，后面 repo-service 会做去重处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）消息中间件向 repo-service 推送 repo_deduction_msg，repo-service 成功处理完成后会向中间件响应 ACK，消息中间件收到这个 ACK 才认为 repo-service 成功处理了这条消息，否则会重复推送该消息。但是有这样的情形：repo-service 成功处理了消息，向中间件发送的 ACK 在网络传输中由于网络故障丢失了，导致中间件没有收到 ACK 重新推送了该消息。这也要靠 repo-service 的消息去重特性来避免消息重复消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4）在 2）和 3）中提到了两种导致 repo-service 重复收到消息的原因，一是生产者重复生产，二是中间件重传。为了实现业务的幂等性，repo-service 中维护了一张判重表，这张表中记录了被成功处理的消息的 id。repo-service 每次接收到新的消息都先判断消息是否被成功处理过，若是的话不再重复处理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9345794392523364&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OHdf2TqjpXFrdlicGyn9tsqebB0wTFauZzC41lpRvXYE6ddfzBGibGOdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;214&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这种设计，实现了消息在发送方不丢失，消息在接收方不被重复消费，联合起来就是消息不漏不重，严格实现了 order-service 和 repo-service 的两个数据库中数据的最终一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于消息中间件的最终一致性全局事务方案是互联网公司在高并发场景中探索出的一种创新型应用模式，利用 MQ 实现微服务之间的异步调用、解耦合和流量削峰，支持全局事务的高并发，并保证分布式数据记录的最终一致性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5ODAtXVRcibzJbWT3AVC0wSuOjJYeOmeI1cGmTFCc8hNrrPtxR7AMLWJg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;3. Seata in AT mode 的实现&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第 2 章给出了实现实现分布式事务的集中常见的理论模型。本章给出业界开源分布式事务框架 Seata 的实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Seata 为用户提供了 AT、TCC、SAGA 和 XA 事务模式&lt;/strong&gt;。其中 &lt;strong&gt;AT 模式是 Seata 主推的事务模式&lt;/strong&gt;，因此本章分析 Seata in AT mode 的实现。&lt;strong&gt;使用 AT 有一个前提，那就是微服务使用的数据库必须是支持事务的关系型数据库。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1. Seata in AT mode 工作流程概述&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Seata 的 AT 模式建立在关系型数据库的本地事务特性的基础之上，通过数据源代理类拦截并解析数据库执行的 SQL，记录自定义的回滚日志，如需回滚，则重放这些自定义的回滚日志即可。AT 模式虽然是根据 XA 事务模型（2PC）演进而来的，但是 AT 打破了 XA 协议的阻塞性制约，在一致性和性能上取得了平衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AT 模式是基于 XA 事务模型演进而来的，它的整体机制也是一个改进版本的两阶段提交协议。AT 模式的两个基本阶段是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先获取本地锁，执行本地事务，业务数据操作和记录回滚日志在同一个本地事务中提交，最后释放本地锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如需全局提交，异步删除回滚日志即可，这个过程很快就能完成。如需要回滚，则通过第一阶段的回滚日志进行反向补偿。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本章描述 Seata in AT mode 的工作原理使用的电商微服务模型如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2440944881889764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5ORRW2eiaJESv0YyxfNQAuR78nibPibYPCQFiabSjhD6LORxttFiaKYLHsNBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;381&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，协调者 shopping-service 先调用参与者 repo-service 扣减库存，后调用参与者 order-service 生成订单。这个业务流使用 Seata in XA mode 后的全局事务流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9425113464447806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OyGdkslGbeFtwvuf8Iic138nocN06p7WNjuIx8pXicL7ibbOxgRGF7WOpg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;661&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图描述的全局事务执行流程为：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;shopping-service 向 Seata 注册全局事务，并产生一个全局事务标识 XID&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 repo-service.repo_db、order-service.order_db 的本地事务执行到待提交阶段，事务内容包含对 repo-service.repo_db、order-service.order_db 进行的查询操作以及写每个库的 undo_log 记录&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;repo-service.repo_db、order-service.order_db 向 Seata 注册分支事务，并将其纳入该 XID 对应的全局事务范围&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提交 repo-service.repo_db、order-service.order_db 的本地事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;repo-service.repo_db、order-service.order_db 向 Seata 汇报分支事务的提交状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Seata 汇总所有的 DB 的分支事务的提交状态，决定全局事务是该提交还是回滚&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Seata 通知 repo-service.repo_db、order-service.order_db 提交/回滚本地事务，若需要回滚，采取的是补偿式方法&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 1）2）3）4）5）属于第一阶段，6）7）属于第二阶段。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2. Seata in AT mode 工作流程详述&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的电商业务场景中，购物服务调用库存服务扣减库存，调用订单服务创建订单，显然这两个调用过程要放在一个事务里面。即：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;start global_trx&lt;br/&gt;&lt;br/&gt; call 库存服务的扣减库存接口&lt;br/&gt;&lt;br/&gt; call 订单服务的创建订单接口&lt;br/&gt;&lt;br/&gt;commit global_trx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在库存服务的数据库中，存在如下的库存表 t_repo：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;10001&lt;/td&gt;&lt;td&gt;20001&lt;/td&gt;&lt;td&gt;xx 键盘&lt;/td&gt;&lt;td&gt;98&lt;/td&gt;&lt;td&gt;200.0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;10002&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;yy 鼠标&lt;/td&gt;&lt;td&gt;199&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在订单服务的数据库中，存在如下的订单表 t_order：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;order_code&lt;/th&gt;&lt;th&gt;user_id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;30001&lt;/td&gt;&lt;td&gt;2020102500001&lt;/td&gt;&lt;td&gt;40001&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;30002&lt;/td&gt;&lt;td&gt;2020102500001&lt;/td&gt;&lt;td&gt;40001&lt;/td&gt;&lt;td&gt;20001&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;400.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，id 为 40002 的用户要购买一只商品代码为 20002 的鼠标，整个分布式事务的内容为：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）在库存服务的库存表中将记录&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;10002&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;yy 鼠标&lt;/td&gt;&lt;td&gt;199&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改为&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;10002&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;yy 鼠标&lt;/td&gt;&lt;td&gt;198&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）在订单服务的订单表中添加一条记录&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;order_code&lt;/th&gt;&lt;th&gt;user_id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;30003&lt;/td&gt;&lt;td&gt;2020102500002&lt;/td&gt;&lt;td&gt;40002&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上操作，在 AT 模式的第一阶段的流程图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4167623421354765&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OOxsngRHRibdaZNwOtfLLbr4ffLUuP8OIzr92CfQK6FS5urJpDnAeviag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;871&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 AT 模式第一阶段的流程来看，分&lt;strong&gt;支的本地事务在第一阶段提交完成之后，就会释放掉本地事务锁定的本地记录&lt;/strong&gt;。这是 AT 模式和 XA 最大的不同点，在 XA 事务的两阶段提交中，被锁定的记录直到第二阶段结束才会被释放。所以 &lt;strong&gt;AT 模式减少了锁记录的时间，从而提高了分布式事务的处理效率&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;AT 模式之所以能够实现第一阶段完成就释放被锁定的记录，是因为 Seata 在每个服务的数据库中维护了一张 undo_log 表&lt;/strong&gt;，其中记录了对 t_order / t_repo 进行操作前后记录的镜像数据，即便第二阶段发生异常，只需回放每个服务的 undo_log 中的相应记录即可实现全局回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;undo_log 的表结构：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;branch_id&lt;/th&gt;&lt;th&gt;xid&lt;/th&gt;&lt;th&gt;context&lt;/th&gt;&lt;th&gt;rollback_info&lt;/th&gt;&lt;th&gt;log_status&lt;/th&gt;&lt;th&gt;log_created&lt;/th&gt;&lt;th&gt;log_modified&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;……&lt;/td&gt;&lt;td&gt;分支事务 ID&lt;/td&gt;&lt;td&gt;全局事务 ID&lt;/td&gt;&lt;td&gt;……&lt;/td&gt;&lt;td&gt;分支事务操作的记录在事务前后的记录镜像，即 beforeImage 和 afterImage&lt;/td&gt;&lt;td&gt;……&lt;/td&gt;&lt;td&gt;……&lt;/td&gt;&lt;td&gt;……&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一阶段结束之后，Seata 会接收到所有分支事务的提交状态，然后决定是提交全局事务还是回滚全局事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1）若所有分支事务本地提交均成功，则 Seata 决定全局提交。&lt;/strong&gt; Seata 将分支提交的消息发送给各个分支事务，各个分支事务收到分支提交消息后，会将消息放入一个缓冲队列，然后直接向 Seata 返回提交成功。之后，每个本地事务会慢慢处理分支提交消息，处理的方式为：删除相应分支事务的 undo_log 记录。之所以只需删除分支事务的 undo_log 记录，而不需要再做其他提交操作，是因为提交操作已经在第一阶段完成了（这也是 AT 和 XA 不同的地方）。这个过程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6545012165450121&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OibuibmFbqjPx25ibiabf7w6RTdpwT73oPAnQkKFbZBNvEIfZ48DFA1ZVRw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;822&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分支事务之所以能够直接返回成功给 Seata，是因为真正关键的提交操作在第一阶段已经完成了，清除 undo_log 日志只是收尾工作，即便清除失败了，也对整个分布式事务不产生实质影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2）若任一分支事务本地提交失败，则 Seata 决定全局回滚&lt;/strong&gt;，将分支事务回滚消息发送给各个分支事务，由于在第一阶段各个服务的数据库上记录了 undo_log 记录，分支事务回滚操作只需根据 undo_log 记录进行补偿即可。全局事务的回滚流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7567298105682951&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OtBLLPhVMSkNyFg5Mnl075Kuia52teiaVIBf5pcUUatibUM5FHZ6wuyaGA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1003&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里对图中的 2、3 步做进一步的说明：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由于上文给出了 undo_log 的表结构，所以可以通过 xid 和 branch_id 来找到当前分支事务的所有 undo_log 记录；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拿到当前分支事务的 undo_log 记录之后，首先要做数据校验，如果 afterImage 中的记录与当前的表记录不一致，说明从第一阶段完成到此刻期间，有别的事务修改了这些记录，这会导致分支事务无法回滚，向 Seata 反馈回滚失败；如果 afterImage 中的记录与当前的表记录一致，说明从第一阶段完成到此刻期间，没有别的事务修改这些记录，分支事务可回滚，进而根据 beforeImage 和 afterImage 计算出补偿 SQL，执行补偿 SQL 进行回滚，然后删除相应 undo_log，向 Seata 反馈回滚成功。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OJ6P9q3q6nV7Ug24TQaPnmtt2zmWPWDJQtf59fbJQQJufibIauvySzJQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务具有 ACID 特性，全局事务解决方案也在尽量实现这四个特性。以上关于 Seata in AT mode 的描述很显然体现出了 AT 的原子性、一致性和持久性。下面着重描述一下 AT 如何保证多个全局事务的隔离性的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 AT 中，当多个全局事务操作同一张表时，通过全局锁来保证事务的隔离性。下面描述一下全局锁在读隔离和写隔离两个场景中的作用原理：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）&lt;strong&gt;写隔离&lt;/strong&gt;（若有全局事务在改/写/删记录，另一个全局事务对同一记录进行的改/写/删要被隔离起来，即写写互斥）：写隔离是为了在多个全局事务对同一张表的同一个字段进行更新操作时，避免一个全局事务在没有被提交成功之前所涉及的数据被其他全局事务修改。写隔离的基本原理是：在第一阶段本地事务（开启本地事务的时候，本地事务会对涉及到的记录加本地锁）提交之前，确保拿到全局锁。如果拿不到全局锁，就不能提交本地事务，并且不断尝试获取全局锁，直至超出重试次数，放弃获取全局锁，回滚本地事务，释放本地事务对记录加的本地锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设有两个全局事务 gtrx_1 和 gtrx_2 在并发操作库存服务，意图扣减如下记录的库存数量：&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;10002&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;yy 鼠标&lt;/td&gt;&lt;td&gt;198&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AT 实现写隔离过程的时序图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5651340996168582&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5O1J2BzCm9X9lkuhLEvNEic6SL8d7bFnT75BQADGQtFUUv4P5eicfeXBzQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1044&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图中，1、2、3、4 属于第一阶段，5 属于第二阶段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中 gtrx_1 和 gtrx_2 均成功提交，如果 gtrx_1 在第二阶段执行回滚操作，那么 gtrx_1 需要重新发起本地事务获取本地锁，然后根据 undo_log 对这个 id=10002 的记录进行补偿式回滚。此时 gtrx_2 仍在等待全局锁，且持有这个 id=10002 的记录的本地锁，因此 gtrx_1 会回滚失败（gtrx_1 回滚需要同时持有全局锁和对 id=10002 的记录加的本地锁），回滚失败的 gtrx_1 会一直重试回滚。直到旁边的 gtrx_2 获取全局锁的尝试次数超过阈值，gtrx_2 会放弃获取全局锁，发起本地回滚，本地回滚结束后，自然会释放掉对这个 id=10002 的记录加的本地锁。此时，gtrx_1 终于可以成功对这个 id=10002 的记录加上了本地锁，同时拿到了本地锁和全局锁的 gtrx_1 就可以成功回滚了。整个过程，全局锁始终在 gtrx_1 手中，并不会发生脏写的问题。整个过程的流程图如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.687962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OpXV1Jzj6Gh6vCoJiapTgwCViaHHlSpNHjeF20VObGMyY6Wa0gUe00iaDQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）&lt;strong&gt;读隔离&lt;/strong&gt;（若有全局事务在改/写/删记录，另一个全局事务对同一记录的读取要被隔离起来，即读写互斥）：在数据库本地事务的隔离级别为读已提交、可重复读、串行化时（读未提交不起什么隔离作用，一般不使用），Seata AT 全局事务模型产生的隔离级别是读未提交，也就是说一个全局事务会看到另一个全局事务未全局提交的数据，产生脏读，从前文的第一阶段和第二阶段的流程图中也可以看出这一点。这在最终一致性的分布式事务模型中是可以接受的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要求 AT 模型一定要实现读已提交的事务隔离级别，可以利用 Seata 的 SelectForUpdateExecutor 执行器对 SELECT FOR UPDATE 语句进行代理。SELECT FOR UPDATE 语句在执行时会申请全局锁，如果全局锁已经被其他全局事务占有，则回滚 SELECT FOR UPDATE 语句的执行，释放本地锁，并且重试 SELECT FOR UPDATE 语句。在这个过程中，查询请求会被阻塞，直到拿到全局锁（也就是要读取的记录被其他全局事务提交），读到已被全局事务提交的数据才返回。这个过程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5722222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5Ohz4OheD3PNeibsGnFX0rREpUBicYCM4r6JXeZtpvhgXpCDKOLsj5Mapg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OLeBdUoUwavsbVPliasUqvq03JuFaMDDASq3l0CjK4kKHiamLwGZ3pgfQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;4. 结束语&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;XA 协议是 X/Open 提出的分布式事务处理标准。文中提到的 2PC、3PC、TCC、本地事务表、Seata in AT mode，无论哪一种，本质都是事务协调者协调各个事务参与者的本地事务的进度，使使所有本地事务共同提交或回滚，最终达成一种全局的 ACID 特性。在协调的过程中，协调者需要收集各个本地事务的当前状态，并根据这些状态发出下一阶段的操作指令。这个思想就是 XA 协议的要义，我们可以说这些事务模型遵守或大致遵守了 XA 协议。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;基于消息中间件的最终一致性事务方案是互联网公司在高并发场景中探索出的一种创新型应用模式，利用 MQ 实现微服务之间的异步调用、解耦合和流量削峰，保证分布式数据记录的最终一致性。它显然不遵守 XA 协议。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于某项技术，可能存在业界标准或协议，但实践者针对具体应用场景的需求或者出于简便的考虑，给出与标准不完全相符的实现，甚至完全不相符的实现，这在工程领域是一种常见的现象。TCC 方案如此、基于消息中间件的最终一致性事务方案如此、Seata in AT mode 模式也如此。而新的标准往往就在这些创新中产生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你难道真的没有发现 2.6 节（基于消息中间件的最终一致性事务方案）给出的正确方案中存在的业务漏洞吗？请各位重新看下这张图，仔细品一品两个微服务的调用方向，把你的想法留在评论区吧 :-)&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.36018518518518516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OSWufbwc1iahgpyuxuk4HBjNbqk4BhZwMalMMnFiaN7U8a8iaPjs77RJHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>29259e0f21e815f59cdb5b9a80b0d7df</guid>
<title>Kafka 浅谈：什么是 AR、OSR、ISR、HW 和 LEO 以及之间的关系</title>
<link>https://toutiao.io/k/wyi8d8m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content post-body&quot;&gt;&lt;h3 id=&quot;kafka-多副本&quot;&gt;&lt;a href=&quot;#kafka-多副本&quot; class=&quot;headerlink&quot; title=&quot;kafka 多副本&quot;/&gt;kafka 多副本&lt;/h3&gt;&lt;p&gt;Kafka 为分区引入了多副本（Replica）机制，通过增加副本数量可以提升容灾能力。同一分区的不同副本中保存的是相同的消息（当然在同一时刻，副本之间可能并非完全一样），副本之间是“一主多从”的关系，其中leader副本负责处理读写请求，follower副本只负责与leader副本的消息同步。副本处于不同的broker中，当leader副本出现故障时，从follower副本中重新选举新的leader副本对外提供服务。Kafka通过多副本机制实现了故障的自动转移，当Kafka集群中某个broker失效时仍然能保证服务可用。&lt;/p&gt;
&lt;p&gt;Kafka集群中有4个broker，某个主题中有3个分区，且副本因子（即副本个数）也为3，如此每个分区便有1个leader副本和2个follower副本。生产者和消费者只与leader副本进行交互，而follower副本只负责消息的同步，很多时候follower副本中的消息相对leader副本而言会有一定的滞后。&lt;/p&gt;
&lt;p&gt;Kafka 消费端也具备一定的容灾能力。Consumer 使用拉（Pull）模式从服务端拉取消息，并且保存消费的具体位置，当消费者宕机后恢复上线时可以根据之前保存的消费位置重新拉取需要的消息进行消费，这样就不会造成消息丢失。&lt;/p&gt;
&lt;h3 id=&quot;AR、LSR、OSR&quot;&gt;&lt;a href=&quot;#AR、LSR、OSR&quot; class=&quot;headerlink&quot; title=&quot;AR、LSR、OSR&quot;/&gt;AR、LSR、OSR&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;分区中的所有副本统称为AR（Assigned Replicas）。&lt;/li&gt;
&lt;li&gt;所有与leader副本保持一定程度同步的副本（包括leader副本在内）组成ISR（In-Sync Replicas），ISR集合是AR集合中的一个子集。&lt;/li&gt;
&lt;li&gt;与leader副本同步滞后过多的副本（不包括leader副本）组成OSR（Out-of-Sync Replicas）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;消息会先发送到leader副本，然后follower副本才能从leader副本中拉取消息进行同步，同步期间内follower副本相对于leader副本而言会有一定程度的滞后。前面所说的“一定程度的同步”是指可忍受的滞后范围，这个范围可以通过参数进行配置。，由此可见，AR=ISR+OSR。在正常情况下，所有的 follower 副本都应该与 leader 副本保持一定程度的同步，即 AR=ISR，OSR集合为空.&lt;/p&gt;
&lt;h3 id=&quot;LSR-与-OSR-转换、LSR集合中的副本才允许选举为leader&quot;&gt;&lt;a href=&quot;#LSR-与-OSR-转换、LSR集合中的副本才允许选举为leader&quot; class=&quot;headerlink&quot; title=&quot;LSR 与 OSR 转换、LSR集合中的副本才允许选举为leader&quot;/&gt;LSR 与 OSR 转换、LSR集合中的副本才允许选举为leader&lt;/h3&gt;&lt;p&gt;leader副本负责维护和跟踪ISR集合中所有follower副本的滞后状态，当follower副本落后太多或失效时，leader副本会把它从ISR集合中剔除。如果OSR集合中有follower副本“追上”了leader副本，那么leader副本会把它从OSR集合转移至ISR集合。默认情况下，当leader副本发生故障时，只有在ISR集合中的副本才有资格被选举为新的leader，而在OSR集合中的副本则没有任何机会（不过这个原则也可以通过修改相应的参数配置来改变）。ISR与HW和LEO也有紧密的关系。&lt;/p&gt;
&lt;h3 id=&quot;什么是HW高水位&quot;&gt;&lt;a href=&quot;#什么是HW高水位&quot; class=&quot;headerlink&quot; title=&quot;什么是HW高水位&quot;/&gt;什么是HW高水位&lt;/h3&gt;&lt;p&gt;HW是High Watermark的缩写，俗称高水位，它标识了一个特定的消息偏移量（offset），消费者只能拉取到这个offset之前的消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.studytime.xin/article/2020/11/16043177212192.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，它代表一个日志文件，这个日志文件中有 9 条消息，第一条消息的 offset（LogStartOffset）为0，最后一条消息的offset为8，offset为9的消息用虚线框表示，代表下一条待写入的消息。日志文件的HW为6，表示消费者只能拉取到offset在0至5之间的消息，而offset为6的消息对消费者而言是不可见的。&lt;/p&gt;
&lt;h3 id=&quot;什么是LEO&quot;&gt;&lt;a href=&quot;#什么是LEO&quot; class=&quot;headerlink&quot; title=&quot;什么是LEO&quot;/&gt;什么是LEO&lt;/h3&gt;&lt;p&gt;LEO是Log End Offset的缩写，它标识当前日志文件中下一条待写入消息的offset，图中offset为9的位置即为当前日志文件的LEO，LEO的大小相当于当前日志分区中最后一条消息的offset值加1。分区ISR集合中的每个副本都会维护自身的LEO，而ISR集合中最小的LEO即为分区的HW，对消费者而言只能消费HW之前的消息。&lt;/p&gt;
&lt;h3 id=&quot;ISR集合，以及HW和LEO之间的关系&quot;&gt;&lt;a href=&quot;#ISR集合，以及HW和LEO之间的关系&quot; class=&quot;headerlink&quot; title=&quot;ISR集合，以及HW和LEO之间的关系&quot;/&gt;ISR集合，以及HW和LEO之间的关系&lt;/h3&gt;&lt;p&gt;为了更好地理解ISR集合，以及HW和LEO之间的关系，下面通过一个简单的示例来进行相关的说明。如图所示，假设某个分区的ISR集合中有3个副本，即一个leader副本和2个follower副本，此时分区的LEO和HW都为3。消息3和消息4从生产者发出之后会被先存入leader副本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.studytime.xin/article/2020/11/16043177369600.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.studytime.xin/article/2020/11/16043177502794.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.studytime.xin/article/2020/11/16043177624510.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.studytime.xin/article/2020/11/16043177728479.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在消息写入leader副本之后，follower副本会发送拉取请求来拉取消息3和消息4以进行消息同步。&lt;/p&gt;
&lt;p&gt;在同步过程中，不同的 follower 副本的同步效率也不尽相同。在某一时刻follower1完全跟上了leader副本而follower2只同步了消息3，如此leader副本的LEO为5，follower1的LEO为5，follower2的LEO为4，那么当前分区的HW取最小值4，此时消费者可以消费到offset为0至3之间的消息。&lt;/p&gt;
&lt;p&gt;当所有的副本都成功写入了消息3和消息4，整个分区的HW和LEO都变为5，因此消费者可以消费到offset为4的消息了。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;/&gt;总结&lt;/h3&gt;&lt;p&gt;由此可见，Kafka 的复制机制既不是完全的同步复制，也不是单纯的异步复制。事实上，同步复制要求所有能工作的 follower 副本都复制完，这条消息才会被确认为已成功提交，这种复制方式极大地影响了性能。而在异步复制方式下，follower副本异步地从leader副本中复制数据，数据只要被leader副本写入就被认为已经成功提交。在这种情况下，如果follower副本都还没有复制完而落后于leader副本，突然leader副本宕机，则会造成数据丢失。Kafka使用的这种ISR的方式则有效地权衡了数据可靠性和性能之间的关系。&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>196a577d3fc40edd3e997f9b887315e9</guid>
<title>编程体系结构：Spring.Mvc.Boot 框架</title>
<link>https://toutiao.io/k/pxayd4y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1&gt;&lt;span&gt;一、Spring框架&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.85078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAKvYwXwtB61IfSvZhzmG98seHWOQRyayktnz3YIshQiaEaEQ4SXtichDggzcGaHIeEQI1E5T0Toffw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1、框架概述&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Spring是一个开源框架，框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。Spring是一个分层的轻量级开源框架。&lt;/p&gt;&lt;p&gt;基本特性：分层架构、高内聚低耦合、支持AOP编程、事务管理、集成测试、集成各种框架。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、核心组件&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6793388429752066&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAKvYwXwtB61IfSvZhzmG98icyIHsu9y6giaG70rPWsqLnICJAdbXNODHtfgic4mZjwpvkQkCAU0HiaLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;605&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;核心容器&lt;/strong&gt;：包含Bean的创建、配置、管理等功能。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;AOP切面编程&lt;/strong&gt;：可以帮助应用程序解耦。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;数据访问&lt;/strong&gt;：集成了JDBC，常用的Dao层框架hibernate，mybatis等。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Web编程&lt;/strong&gt;：集成流程的MVC框架，实现界面逻辑和应用程序分离。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、Bean对象理解&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Spring容器负责创建，装配，设置属性，进而管理整个生命周期的对象，称为Bean对象。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;装配方式&lt;/strong&gt;：XML格式、注解扫描、Java代码装配。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;作用域&lt;/strong&gt;：用于确定spring创建bean实例个数，比如单例Bean,原型Bean。singleton默认单例、prototype多例、request请求、session会话级、global-session。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;生命周期&lt;/strong&gt;：实例化，属性加载，初始化前后管理，销毁。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4、常用核心注解&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Controller：标记一个类是Handler，基于@Mapping相关注解（@GetMapping、@PostMapping、@PutMapping、@DeleteMapping），用来关联请求和Controller方法之间的映射关系，这样的Controller 就可以被请求访问。&lt;/p&gt;&lt;p&gt;RequestMapping：处理请求地址映射的注解，可作用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以类上标注地址作为父路径。&lt;/p&gt;&lt;p&gt;Resource：按照ByName自动注入，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。&lt;/p&gt;&lt;p&gt;Service：可以取代具体配置文件的Bean管理，定义的bean默认是单例的，默认名称是类名且首字母小写。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;5、IOC与DI思想&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;IOC容器&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Java系统中对象耦合关系十分复杂，系统的各模块之间依赖，微服务模块之间的相互调用请求，都是这个道理。降低系统模块之间、对象之间、微服务的服务之间耦合度，是软件工程核心问题之一。因为Spring框架中核心思想就是IOC控制反转，用来实现对象之间的解耦。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;依赖注入&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;IOC给对象直接建立关系的动作，称为DI依赖注入(Dependency Injection);依赖：对象A需要使用对象B的功能，则称对象A依赖对象B。注入：在对象A中实例化对象B，从而使用对象B的功能，该动作称为注入。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;6、Aop切面编程&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。核心作用：可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的复用性和开发效率。AOP提供了取代继承和委托的一种新的方案，而且使用起来更加简洁清晰，是软件开发中的一个热点理念。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;实现方式&lt;/strong&gt;：JDK动态代理、CgLib字节码增强、Spring半自动代理、Spring全自动代理。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;7、事务管理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;事务是指作为单个逻辑工作单元执行的一系列操作（SQL语句）。这些操作要么全部成功，要么全部不成功。Spring事务管理的本质就是封装了数据库对事务支持的操作，使用JDBC的事务管理机制,就是利用java.sql.Connection对象完成对事务的提交和回滚。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;核心API封装&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;PlatformTransactionManager：平台事务管理器，Spring管理事务，必须使用事务管理器进行事务配置时，核心方法：获取事务，提交事务，回滚事务。&lt;/p&gt;&lt;p&gt;TransactionDefinition：该对象封装事务详情（事务定义、事务属性），例如：隔离级别、是否只读、超时时间 等。&lt;/p&gt;&lt;p&gt;TransactionStatus：用于记录当前事务运行状态。例如：是否有保存点，事务是否完成。Spring底层根据状态进行相应操作。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;8、配置文件&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在Spring的配置文件中，通常会配置下列核心内容；&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;读取外部配置文件，例如JDBC参数；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;配置数据库连接池，例如Druid、C3P0等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;整合环境配置，例如SSM或者SSH集成；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;管理Transaction事务的控制方式；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;整合常用组件，例如邮件、任务、MQ等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在实际开发中，复杂的项目配置十分繁杂且不好管理，可能项目中涉及不同环境的配置文件都有几十个，所在在SpringBoot框架中采用统一约定的方式简化。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;9、环境整合SSM、SSH&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Spring框架聚合很强的整合能力，例如常见的整合Mybatis，Mvc，Hibernate，Redis等系列组件，为开发环境的集成提供很大的便利，整体职责上分为几层：控制层、业务逻辑层、数据持久层、域模块层、中间件层，以帮助开发人员在短期内搭建结构清晰、可复用性好、维护方便的Web应用程序。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;10、设计模式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;单例模式：Spring框架中Bean对象的管理，默认单例，也可以显式标识为多例模式。&lt;/p&gt;&lt;p&gt;工厂模式：通过对应的工厂来生成类的对象，这种设计方式符合“开闭”原则。Spring框架中BeanFactory和Bean的用法。&lt;/p&gt;&lt;p&gt;适配器模式：SpringMvc执行控制中，前段控制器DispatcherServlet调用处理器适配器去执行Handler，处理器适配器去执行Handler，给适配器返回ModelAndView。&lt;/p&gt;&lt;p&gt;责任链模式：DispatcherServlet核心方法doDispatch。HandlerExecutionChain只是维护HandlerInterceptor的集合，可以向其中注册相应的拦截器，本身不直接处理请求，将请求分配给责任链上注册处理器执行，降低职责链本身与处理逻辑之间的耦合程度。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、SpringMvc模式&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、Mvc模式理念&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;SpringMVC是一种基于Java实现的MVC设计模式的请求驱动类型的轻量级Web框架，出自Spring框架全家桶，与Spring框架无缝整合，使用了MVC架构模式的思想，将Web层进行职责解耦。结构松散，几乎可以在SpringMVC中使用各类视图，各个模块分离而且耦合度非常低，且易于扩展。与Spring无缝集成，且简单，灵活，容易上手。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、执行流程&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5435005117707267&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAKvYwXwtB61IfSvZhzmG98s9SgPhUf0VKkYSE1Crgdyh3mQq9zLcgNHiaaQNsIOwoCsFXEUO8pP4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;977&quot;/&gt;&lt;/p&gt;&lt;p&gt;发起请求到前端控制器DispatcherServlet;前端控制器请求HandlerMapping查找,Handler可以根据xml配置、注解进行查找;&lt;/p&gt;&lt;p&gt;处理器映射器HandlerMapping向前端控制器返回Handler;前端控制器调用处理器适配器去执行Handler;处理器适配器去执行Handler;&lt;/p&gt;&lt;p&gt;Handler执行完成给适配器返回ModelAndView;处理器适配器向前端控制器返回ModelAndView,ModelAndView是springmvc框架的一个底层对象,包括Model和view;&lt;/p&gt;&lt;p&gt;前端控制器请求视图解析器去进行视图解析，根据逻辑视图名解析成真正的视图;视图解析器向前端控制器返回View;前端控制器进行视图渲染,视图渲染将模型数据(在ModelAndView对象中)填充到request域中;前端控制器向用户响应结果;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、核心组件&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;前端控制器：请求离开浏览器后，最先到达的就是DispatcherServlet，是整个流程控制的中心。&lt;/p&gt;&lt;p&gt;处理器映射器：根据请求的url路由到指定接口，用户请求找到Handler处理器。&lt;/p&gt;&lt;p&gt;处理器适配器：按照特定规则去执行Handler，支持多种处理器，各种处理器中的处理方法各不相同。&lt;/p&gt;&lt;p&gt;处理器：处理用户请求，涉及具体业务逻辑，需要根据业务需求开发。&lt;/p&gt;&lt;p&gt;视图解析器：将请求的响应结果生成View，根据逻辑视图名解析成物理视图名，就是具体页面地址。&lt;/p&gt;&lt;p&gt;视图：Mvc框架提供很多的View视图类型的支持，包括：jsp、freemarker、pdf等。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4、参数处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;requestParam：主要用于在SpringMvc框架的控制层获取参数，三个常用参数：defaultValue表示设置默认值，required 通过boolean设置是否是必须要传入的参数，value值表示传入的参数名称。&lt;/p&gt;&lt;p&gt;RequestBody：接收请求体中传递给后端的Json字符串数据的，GET方式无请求体，所以使用@RequestBody接收数据时，不能使用GET方式提交数据，需要用POST方式进行提交。&lt;/p&gt;&lt;p&gt;ResponseBody：该注解用于方法的返回对象，可以通过配置转换器为指定数据响应格式，如果希望返回的数据不是View试图页面，而是指定数据格式的时候使用，例如：Json、Xml等。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;5、整合Spring框架&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;配置扫描接口文件；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;启动MVC默认的注解映射的方式；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;配置视图解析器；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Web.xml配置加载Spring-Mvc文件；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;6、对比WebFlux&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;响应式编程是一种基于数据流和变化传递的声明式的编程范式，WebFlux是Web控制端响应式编程中的组成部分，在Spring官网上有说明，不是为了替代SpringMvc，是用来提供更多场景的解决方案。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、SpringBoot框架&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、常用基础功能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、整合数据源&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、集成常用中间件&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;整个SpringBoot框架是基于Spring框架之上多个很多约定的规范，底层原理并没有改变，更多是熟悉各种用法，用多就会明白。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、对比分析&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;Spring框架相对Spring开源生态是最底层的实现原理，SpringMvc是基于之上而来的，主要简化Web控制层的开发，例如之前的Struts、Servlet都逐渐被替换。&lt;/p&gt;&lt;p&gt;SpringBoot则在Spring+Mvc基础上，实现很强大的约定配置，对复杂的环境做了约定的集成，简化开发配置，业务性开发还是一样的，在SSM环境下不管项目配置启动调试都十分的复杂，到SpringBoot层面之后被不断简化，所以SpringBoot学习在理解约定的配置规范后，基本很容易上手。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;五、源代码地址&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https:&lt;span&gt;//github.com/cicadasmile&lt;/span&gt;&lt;br/&gt;GitEE·地址&lt;br/&gt;https:&lt;span&gt;//gitee.com/cicadasmile&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3783359497645212&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCjMheLZtcM2iaVMBOpIUKR4CDRCG9FLT5K6NmGXvG7exrW0TSuDjnTKJQ5PDq8j8Y7PHDd17Z3gicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d726eaec049ff13855d023d77acd0230</guid>
<title>用 LeetCode 官方推荐的动画解《买卖股票的最佳时机》</title>
<link>https://toutiao.io/k/el051zc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1299342105263158&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JDtbHnrHRnMpIuTiaib1W7V0AkYNvfFEmsicdDdicT9T57dD1EYgMKwjXjJjmdSK5qBmN0yQkaQA2gUzricFLCMMPXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;608&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近看到 LeetCode 官方公众号推送了一条《&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI4Mzc5NDk4MA==&amp;amp;mid=2247488677&amp;amp;idx=1&amp;amp;sn=95fac03e06921365b3ce84d1e3e06232&amp;amp;chksm=eb841feedcf396f8592e21f601e90867bdbeb54b1cbfab4dd585eedb96d18a42106268743d4a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;5 分钟轻松制作力扣题解动画&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》，用 PPT 做解题的 GIF 动画，感觉很有意思。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;老张手痒痒，自己找了一个动态规划的题目《121. &lt;span&gt;买卖股票的最佳时机》，尝试一下用 GIF 动画讲解解题过程。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先来看题目：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;注意：你不能在买入股票前卖出股票。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;示例 1:&lt;/p&gt;&lt;p&gt;输入: [7,1,5,3,6,4]&lt;/p&gt;&lt;p&gt;输出: 5&lt;/p&gt;&lt;p&gt;解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。&lt;/p&gt;&lt;p&gt;     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;示例 2:&lt;/p&gt;&lt;p&gt;输入: [7,6,4,3,1]&lt;/p&gt;&lt;p&gt;输出: 0&lt;/p&gt;&lt;p&gt;解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;来源：力扣（LeetCode）&lt;/p&gt;&lt;p&gt;链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看到这种求最优解的题目，很容易让人想到动态规划。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们来尝试一下找到状态转移方程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每天的股票价格为 &lt;em&gt;prices[]&lt;/em&gt; ，定义数组 &lt;em&gt;dp[]&lt;/em&gt; ，其中 &lt;em&gt;dp[i] &lt;/em&gt;表示第 &lt;em&gt;i &lt;/em&gt;天以 &lt;em&gt;prices[i] &lt;/em&gt;卖出股票可以获得的最大利润。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以得到方程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;     &lt;/span&gt;&lt;em&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;dp[x] = max(dp[x-1],  dp[x] - min(prices[0:x]))&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;即第 &lt;em&gt;x &lt;/em&gt;天的最大利润，要么是第 &lt;em&gt;x-1&lt;/em&gt; 天的最大利润，要么是当天的价格减去历史最低价。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;考虑到历史最低价以及最大利润都是区间范围内的极限值，均可以用单个变量来优化时间和空间复杂度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;过程没看懂？是时候展示 PPT 动画了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/JDtbHnrHRnNWpT2sUTp0D4gYQKtNaicGo5oXjGJNh5EagZDr87o1ktdMFNOsCKTiaty9unfe6Ncjyj3aTxpDnVnw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-qa class=&quot;js_uneditable custom_select_card qa_iframe&quot; data-pluginname=&quot;insertquestion&quot; data-id=&quot;1586483398775275524&quot; data-bizuin=&quot;MzU3Mzc3NDUyOA==&quot; data-title=&quot;此处应该有掌声&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解题代码如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;maxProfit&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(self, prices: List[int])&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;not&lt;/span&gt; prices:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        max_profit = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        min_price = prices[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; p &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; prices[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;:]:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; p &amp;lt;= min_price:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                min_price = p&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                max_profit = max(max_profit, p - min_price)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; max_profit&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;是不是很有意思？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;感兴趣的小伙伴可以点击&lt;span&gt;《&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI4Mzc5NDk4MA==&amp;amp;mid=2247488677&amp;amp;idx=1&amp;amp;sn=95fac03e06921365b3ce84d1e3e06232&amp;amp;chksm=eb841feedcf396f8592e21f601e90867bdbeb54b1cbfab4dd585eedb96d18a42106268743d4a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;5 分钟轻松制作力扣题解动画&lt;/a&gt;&lt;span&gt;》&lt;/span&gt;阅读制作教程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;169&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.29140625&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z08UWq352tkicAqPAHJH1nydR37gWegDcEEgmibGWrCMZSGfIwzcvVJCK7JWa0ebDDdibbbkTTHmNcTcPkrnA0MfQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.47890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JDtbHnrHRnMhTsML3qUwPuD0zZo30VS7h1AbCiaJK7F4LsyrWX6wMRXZt5dbsPvibB0fbCLJMd30icBh2zoXaDVDw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>