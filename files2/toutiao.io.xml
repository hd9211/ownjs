<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>36bf5613f4ce0afa37e628f16623f145</guid>
<title>我做Go项目的一些实战经验</title>
<link>https://toutiao.io/k/n4zn8vb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;由于 Golang 不像 Java 一样有一个统一的编码模式，所以我们和其他团队一样，采用了《Go 面向包的设计和架构分层[1]》这篇文章介绍的一些理论，然后再结合以往的项目经验来进行分包：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;├── cmd/&lt;br/&gt;│   └── main.go //启动函数&lt;br/&gt;├── etc&lt;br/&gt;│   └── dev_conf.yaml              // 配置文件&lt;br/&gt;├── global&lt;br/&gt;│   └── global.go //全局变量引用，如数据库、kafka等&lt;br/&gt;├── internal/&lt;br/&gt;│       └── service/&lt;br/&gt;│           └── xxx_service.go //业务逻辑处理类&lt;br/&gt;│           └── xxx_service_test.go&lt;br/&gt;│       └── model/&lt;br/&gt;│           └── xxx_info.go//结构体&lt;br/&gt;│       └── api/&lt;br/&gt;│           └── xxx_api.go//路由对应的接口实现&lt;br/&gt;│       └── router/&lt;br/&gt;│           └── router.go//路由&lt;br/&gt;│       └── pkg/&lt;br/&gt;│           └── datetool//时间工具类&lt;br/&gt;│           └── jsontool//json 工具类&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;其实上面的这个划分只是简单的将功能分了一下包，在项目实践的过程中还是有很多问题。比如：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对于功能实现我是通过 function 的参数传递还是通过结构体的变量传递？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;使用一个数据库的全局变量引用传递是否安全？是否存在过度耦合？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在代码实现过程中几乎全部都是依赖于实现，而不是依赖于接口，那么将 MySQL 切换为 MongDB 是不是要修改所有的实现？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;所以现在在我们工作中随着代码越来越多，代码中各种 init，function，struct，全局变量感觉也越来越乱。每个模块不独立，看似按逻辑分了模块，但没有明确的上下层关系，每个模块里可能都存在配置读取，外部服务调用，协议转换等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;久而久之服务不同包函数之间的调用慢慢演变成网状结构，数据流的流向和逻辑的梳理变得越来越复杂，很难不看代码调用的情况下搞清楚数据流向。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.731418918918919&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzClIXCibHRE76dPCpnEIaImiaqdGZzKvSgcaSOlLCtiagQk53qRvjNKBP4ic8LgyILsJIClPTsBLaERHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;592&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;不过就像《重构》中所说：&lt;/span&gt;&lt;span&gt;先让代码工作起来&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;-如果代码不能工作，就不能产生价值；然后再试图将它变好-通过对代码进行重构，让我们自己和其他人更好地理解代码，并能按照需求不断地修改代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;所以我觉得是时候自我改变一下。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;1&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;The Clean Architecture&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在简洁架构里面对我们的项目提出了几点要求：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;独立于框架。该架构不依赖于某些功能丰富的软件库的存在。这允许你把这些框架作为工具来使用，而不是把你的系统塞进它们有限的约束中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;可测试。业务规则可以在没有 UI、数据库、Web 服务器或任何其他外部元素的情况下被测试。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;独立于用户界面。UI 可以很容易地改变，而不用改变系统的其他部分。例如，一个 Web UI 可以被替换成一个控制台 UI，而不改变业务规则。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;独立于数据库。你可以把 Oracle 或 SQL Server 换成 Mongo、BigTable、CouchDB 或其他东西。你的业务规则不受数据库的约束。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;独立于任何外部机构。事实上，你的业务规则根本不知道外部世界的任何情况。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7344559585492227&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas7ZJjbRFkHmYsjMFO7Gvpia1Mic3QVs9ohKJicsI0n0ia2x8EQTWxwwiaA3jrSKLEzox7Ak4iaDiaRkuVKg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;772&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;上图中同心圆代表各种不同领域的软件。一般来说，越深入代表你的软件层次越高。外圆是战术实现机制，内圆的是战略核心策略。对于我们的项目来说，代码依赖应该由外向内，单向单层依赖，这种依赖包含代码名称，或类的函数，变量或任何其他命名软件实体。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对于简洁架构来说分为了四层：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Entities：实体&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Usecase：表达应用业务规则，对应的是应用层，它封装和实现系统的所有用例；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Interface Adapters：这一层的软件基本都是一些适配器，主要用于将用例和实体中的数据转换为外部系统如数据库或 Web 使用的数据；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Framework &amp;amp; Driver：最外面一圈通常是由一些框架和工具组成，如数据库 Database、Web 框架等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;那么对于我的项目来说，也分为了四层：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5564814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas7ZJjbRFkHmYsjMFO7GvpiaOV1uicwcx1wjU7LWLQhAtf4Vlk2KOT9ktnHK2QQ8DwBsJIAwrSCQiaRg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;span&gt;代码分层 Models&lt;/span&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;封装了各种实体类对象，与数据库交互的、与 UI 交互的等等，任何的实体类都应该放在这里。如：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;import &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Article struct {&lt;br/&gt; ID        int64     `json:&lt;span&gt;&quot;id&quot;&lt;/span&gt;`&lt;br/&gt; Title     string    `json:&lt;span&gt;&quot;title&quot;&lt;/span&gt;`&lt;br/&gt; Content   string    `json:&lt;span&gt;&quot;content&quot;&lt;/span&gt;`&lt;br/&gt; UpdatedAt time.Time `json:&lt;span&gt;&quot;updated_at&quot;&lt;/span&gt;`&lt;br/&gt; CreatedAt time.Time `json:&lt;span&gt;&quot;created_at&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Repo&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这里存放的是数据库操作类，数据库 CRUD 都在这里。需要注意的是，这里不包含任何的业务逻辑代码，很多同学喜欢将业务逻辑也放到这里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如果使用 ORM，那么这里放入的 ORM 操作相关的代码；如果使用微服务，那么这里放的是其他服务请求的代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Service&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这里是业务逻辑层，所有的业务过程处理代码都应该放在这里。这一层会决定是请求 Repo 层的什么代码，是操作数据库还是调用其他服务；所有的业务数据计算也应该放在这里；这里接受的入参应该是 controller 传入的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;API&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这里是接收外部请求的代码，如：gin 对应的 handler、gRPC、其他 REST API 框架接入层等等。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;2&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;面向接口编程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;除了 Models 层，层与层之间应该通过接口交互，而不是实现。如果要用 Service 调用 Repo 层，那么应该调用 Repo 的接口。那么修改底层实现的时候我们上层的基类不需要变更，只需要更换一下底层实现即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;例如我们想要将所有文章查询出来，那么可以在 Repo 提供这样的接口：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;package repo&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt; &lt;span&gt;&quot;context&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/models&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;// IArticleRepo represent the article&lt;span&gt;&#x27;s repository contract&lt;br/&gt;type IArticleRepo interface {&lt;br/&gt; Fetch(ctx context.Context, createdDate time.Time, num int) (res []models.Article, err error)&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这个接口的实现类就可以根据需求变更，比如说当我们想要 mysql 来作为存储查询，那么只需要提供一个这样的基类：&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;type&lt;/span&gt; mysqlArticleRepository struct {&lt;br/&gt; DB *gorm.DB&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// NewMysqlArticleRepository will create an object that represent the article.Repository interface&lt;br/&gt;func NewMysqlArticleRepository(DB *gorm.DB) IArticleRepo {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;mysqlArticleRepository{DB}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (m *mysqlArticleRepository) Fetch(ctx context.Context, createdDate time.Time,&lt;br/&gt; num int) (res []models.Article, err error) {&lt;br/&gt;&lt;br/&gt; err = m.DB.WithContext(ctx).Model(&amp;amp;models.Article{}).&lt;br/&gt;  Select(&lt;span&gt;&quot;id,title,content, updated_at, created_at&quot;&lt;/span&gt;).&lt;br/&gt;  Where(&lt;span&gt;&quot;created_at &amp;gt; ?&quot;&lt;/span&gt;, createdDate).Limit(num).Find(&amp;amp;res).Error&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如果改天想要换成 MongoDB 来实现我们的存储，那么只需要定义一个结构体实现 IArticleRepo 接口即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;那么在 Service 层实现的时候就可以按照我们的需求来将对应的 Repo 实现注入即可，从而不需要改动 Service 层的实现：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;type&lt;/span&gt; articleService struct {&lt;br/&gt; articleRepo repo.IArticleRepo&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// NewArticleService will create new an articleUsecase object representation of domain.ArticleUsecase interface&lt;br/&gt;func NewArticleService(a repo.IArticleRepo) IArticleService {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;articleService{&lt;br/&gt;  articleRepo: a,&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// Fetch&lt;br/&gt;func (a *articleService) Fetch(ctx context.Context, createdDate time.Time, num int) (res []models.Article, err error) {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; num == 0 {&lt;br/&gt;  num = 10&lt;br/&gt; }&lt;br/&gt; res, err = a.articleRepo.Fetch(ctx, createdDate, num)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;3&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;依赖注入 DI&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;依赖注入，英文名 dependency injection，简称 DI 。DI 以前在 Java 工程里面经常遇到，但是在 Go 里面很多人都说不需要，但是我觉得在大型软件开发过程中还是有必要的，否则只能通过全局变量或者方法参数来进行传递。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;至于具体什么是 DI，简单来说就是被依赖的模块，在创建模块时，被注入到（即当作参数传入）模块的里面。想要更加深入的了解什么是 DI 这里再推荐一下《Dependency injection[2]》和《Inversion of Control Containers and the Dependency Injection pattern[3]》这两篇文章。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如果不用 DI 主要有两大不方便的地方，一个是底层类的修改需要修改上层类，在大型软件开发过程中基类是很多的，一条链路改下来动辄要修改几十个文件；另一方面就是就是层与层之间单元测试不太方便。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;因为采用了依赖注入，在初始化的过程中就不可避免的会写大量的 new，比如我们的项目中需要这样：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/api&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/api/handlers&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/app&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/repo&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/service&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; // 初始化db&lt;br/&gt; db := app.InitDB()&lt;br/&gt; //初始化 repo&lt;br/&gt; repository := repo.NewMysqlArticleRepository(db)&lt;br/&gt; //初始化service&lt;br/&gt; articleService := service.NewArticleService(repository)&lt;br/&gt; //初始化api&lt;br/&gt; handler := handlers.NewArticleHandler(articleService)&lt;br/&gt; //初始化router&lt;br/&gt; router := api.NewRouter(handler)&lt;br/&gt; //初始化gin&lt;br/&gt; engine := app.NewGinEngine()&lt;br/&gt; //初始化server&lt;br/&gt; server := app.NewServer(engine, router)&lt;br/&gt; //启动&lt;br/&gt; server.Start()&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;那么对于这么一段代码，我们有没有办法不用自己写呢？这里我们就可以借助框架的力量来生成我们的注入代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在 Go 里面 DI 的工具相对来说没有 Java 这么方便，技术框架一般主要有：wire、dig、fx 等。由于 wire 是使用代码生成来进行注入，性能会比较高，并且它是 Google 推出的 DI 框架，所以我们这里使用 wire 进行注入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;wire 的要求很简单，新建一个 wire.go 文件（文件名可以随意），创建我们的初始化函数。比如，我们要创建并初始化一个 Server 对象，我们就可以这样：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;//+build wireinject&lt;br/&gt;&lt;br/&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt; &lt;span&gt;&quot;github.com/google/wire&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/api&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/api/handlers&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/app&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/repo&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/service&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func InitServer() *app.Server {&lt;br/&gt; wire.Build(&lt;br/&gt;  app.InitDB,&lt;br/&gt;  repo.NewMysqlArticleRepository,&lt;br/&gt;  service.NewArticleService,&lt;br/&gt;  handlers.NewArticleHandler,&lt;br/&gt;  api.NewRouter,&lt;br/&gt;  app.NewServer,&lt;br/&gt;  app.NewGinEngine)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;app.Server{}&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;需要注意的是，第一行的注解：+build wireinject，表示这是一个注入器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在函数中，我们调用wire.Build()将创建 Server 所依赖的类型的构造器传进去。写完 wire.go 文件之后执行 wire 命令，就会自动生成一个 wire_gen.go 文件。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;// Code generated by Wire. DO NOT EDIT.&lt;br/&gt;&lt;br/&gt;//go:generate go run github.com/google/wire/cmd/wire&lt;br/&gt;//+build !wireinject&lt;br/&gt;&lt;br/&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/api&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/api/handlers&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/app&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/repo&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/service&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;// Injectors from wire.go:&lt;br/&gt;&lt;br/&gt;func InitServer() *app.Server {&lt;br/&gt; engine := app.NewGinEngine()&lt;br/&gt; db := app.InitDB()&lt;br/&gt; iArticleRepo := repo.NewMysqlArticleRepository(db)&lt;br/&gt; iArticleService := service.NewArticleService(iArticleRepo)&lt;br/&gt; articleHandler := handlers.NewArticleHandler(iArticleService)&lt;br/&gt; router := api.NewRouter(articleHandler)&lt;br/&gt; server := app.NewServer(engine, router)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; server&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;可以看到 wire 自动帮我们生成了 InitServer 方法，此方法中依次初始化了所有要初始化的基类。之后在我们的 main 函数中就只需调用这个 InitServer 即可。&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; server := InitServer()&lt;br/&gt; server.Start()&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;4&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;测试&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在上面我们定义好了每一层应该做什么，那么对于每一层我们应该都是可单独测试的，即使另外一层不存在。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Models 层：这一层就很简单了，由于没有依赖任何其他代码，所以可以直接用 Go 的单测框架直接测试即可；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Repo 层：对于这一层来说，由于我们使用了 MySQL 数据库，那么我们需要 Mock MySQL，这样即使不用连 MySQL 也可以正常测试，我这里使用 github.com/DATA-DOG/go-sqlmock 这个库来 Mock 我们的数据库；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Service 层：因为 Service 层依赖了 Repo 层，因为它们之间是通过接口来关联，所以我这里使用 github.com/golang/mock/gomock 来 mock repo 层；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;API 层：这一层依赖 Service 层，并且它们之间是通过接口来关联，所以这里也可以使用 gomock 来 mock service 层。不过这里稍微麻烦了一点，因为我们接入层用的是 gin，所以还需要在单测的时候模拟发送请求。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;由于我们是通过 github.com/golang/mock/gomock 来进行 mock ，所以需要执行一下代码生成，生成的 mock 代码我们放入到 mock 包中：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;mockgen -destination .\mock\repo_mock.go -&lt;span&gt;source&lt;/span&gt; .\repo\repo.go -package mock&lt;br/&gt;&lt;br/&gt;mockgen -destination .\mock\service_mock.go -&lt;span&gt;source&lt;/span&gt; .\service\service.go -package mock&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;上面这两个命令会通过接口帮我自动生成 mock 函数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Repo 层测试&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在项目中，由于我们用了 gorm 来作为我们的 orm 库，所以我们需要使用 github.com/DATA-DOG/go-sqlmock 结合 gorm 来进行 mock：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;func getSqlMock() (mock sqlmock.Sqlmock, gormDB *gorm.DB) {&lt;br/&gt; //创建sqlmock&lt;br/&gt; var err error&lt;br/&gt; var db *sql.DB&lt;br/&gt; db, mock, err = sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  panic(err)&lt;br/&gt; }&lt;br/&gt; //结合gorm、sqlmock&lt;br/&gt; gormDB, err = gorm.Open(mysql.New(mysql.Config{&lt;br/&gt;  SkipInitializeWithVersion: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  Conn:                      db,&lt;br/&gt; }), &amp;amp;gorm.Config{})&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; nil != err {&lt;br/&gt;  log.Fatalf(&lt;span&gt;&quot;Init DB with sqlmock failed, err %v&quot;&lt;/span&gt;, err)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func Test_mysqlArticleRepository_Fetch(t *testing.T) {&lt;br/&gt; createAt := time.Now()&lt;br/&gt; updateAt := time.Now()&lt;br/&gt; //id,title,content, updated_at, created_at&lt;br/&gt; var articles = []models.Article{&lt;br/&gt;  {1, &lt;span&gt;&quot;test1&quot;&lt;/span&gt;, &lt;span&gt;&quot;content&quot;&lt;/span&gt;, updateAt, createAt},&lt;br/&gt;  {2, &lt;span&gt;&quot;test2&quot;&lt;/span&gt;, &lt;span&gt;&quot;content2&quot;&lt;/span&gt;, updateAt, createAt},&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;limit&lt;/span&gt; := 2&lt;br/&gt; mock, db := getSqlMock()&lt;br/&gt;&lt;br/&gt; mock.ExpectQuery(&lt;span&gt;&quot;SELECT id,title,content, updated_at, created_at FROM `articles` WHERE created_at &amp;gt; ? LIMIT 2&quot;&lt;/span&gt;).&lt;br/&gt;  WithArgs(createAt).&lt;br/&gt;  WillReturnRows(sqlmock.NewRows([]string{&lt;span&gt;&quot;id&quot;&lt;/span&gt;, &lt;span&gt;&quot;title&quot;&lt;/span&gt;, &lt;span&gt;&quot;content&quot;&lt;/span&gt;, &lt;span&gt;&quot;updated_at&quot;&lt;/span&gt;, &lt;span&gt;&quot;created_at&quot;&lt;/span&gt;}).&lt;br/&gt;   AddRow(articles[0].ID, articles[0].Title, articles[0].Content, articles[0].UpdatedAt, articles[0].CreatedAt).&lt;br/&gt;   AddRow(articles[1].ID, articles[1].Title, articles[1].Content, articles[1].UpdatedAt, articles[1].CreatedAt))&lt;br/&gt;&lt;br/&gt; repository := NewMysqlArticleRepository(db)&lt;br/&gt; result, err := repository.Fetch(context.TODO(), createAt, &lt;span&gt;limit&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; assert.Nil(t, err)&lt;br/&gt; assert.Equal(t, articles, result)&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Service 层测试&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这里主要就是用我们 gomock 生成的代码来 mock repo 层：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;func Test_articleService_Fetch(t *testing.T) {&lt;br/&gt; ctl := gomock.NewController(t)&lt;br/&gt; defer ctl.Finish()&lt;br/&gt; now := time.Now()&lt;br/&gt; mockRepo := mock.NewMockIArticleRepo(ctl)&lt;br/&gt;&lt;br/&gt; gomock.InOrder(&lt;br/&gt;  mockRepo.EXPECT().Fetch(context.TODO(), now, 10).Return(nil, nil),&lt;br/&gt; )&lt;br/&gt;&lt;br/&gt; service := NewArticleService(mockRepo)&lt;br/&gt;&lt;br/&gt; fetch, _ := service.Fetch(context.TODO(), now, 10)&lt;br/&gt; fmt.Println(fetch)&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;API 层测试&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对于这一层，我们不仅要 mock service 层，还需要发送 httptest 来模拟请求发送：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;func TestArticleHandler_FetchArticle(t *testing.T) {&lt;br/&gt;&lt;br/&gt; ctl := gomock.NewController(t)&lt;br/&gt; defer ctl.Finish()&lt;br/&gt; createAt, _ := time.Parse(&lt;span&gt;&quot;2006-01-02&quot;&lt;/span&gt;, &lt;span&gt;&quot;2021-12-26&quot;&lt;/span&gt;)&lt;br/&gt; mockService := mock.NewMockIArticleService(ctl)&lt;br/&gt;&lt;br/&gt; gomock.InOrder(&lt;br/&gt;  mockService.EXPECT().Fetch(gomock.Any(), createAt, 10).Return(nil, nil),&lt;br/&gt; )&lt;br/&gt;&lt;br/&gt; article := NewArticleHandler(mockService)&lt;br/&gt;&lt;br/&gt; gin.SetMode(gin.TestMode)&lt;br/&gt;&lt;br/&gt; // Setup your router, just like you did &lt;span&gt;in&lt;/span&gt; your main &lt;span&gt;function&lt;/span&gt;, and&lt;br/&gt; // register your routes&lt;br/&gt; r := gin.Default()&lt;br/&gt; r.GET(&lt;span&gt;&quot;/articles&quot;&lt;/span&gt;, article.FetchArticle)&lt;br/&gt;&lt;br/&gt; req, err := http.NewRequest(http.MethodGet, &lt;span&gt;&quot;/articles?num=10&amp;amp;create_date=2021-12-26&quot;&lt;/span&gt;, nil)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  t.Fatalf(&lt;span&gt;&quot;Couldn&#x27;t create request: %v\n&quot;&lt;/span&gt;, err)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; w := httptest.NewRecorder()&lt;br/&gt; // Perform the request&lt;br/&gt; r.ServeHTTP(w, req)&lt;br/&gt;&lt;br/&gt; // Check to see &lt;span&gt;if&lt;/span&gt; the response was what you expected&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; w.Code != http.StatusOK {&lt;br/&gt;  t.Fatalf(&lt;span&gt;&quot;Expected to get status %d but instead got %d\n&quot;&lt;/span&gt;, http.StatusOK, w.Code)&lt;br/&gt; }&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;5&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;以上就是我对 golang 的项目中发现问题的一点点总结与思考，思考的先不管对不对，总归是解决了我们当下的一些问题。不过，项目总归是需要不断重构完善的，所以下次有问题的时候下次再改呗。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对于我上面的总结和描述感觉有不对的地方，请随时指出来一起讨论。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;项目代码位置：https://github.com/devYun/go-clean-architecture&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;相关链接：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://en.wikipedia.org/wiki/Dependency_injection&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://martinfowler.com/articles/injection.html&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;参考链接：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://github.com/bxcodec/go-clean-arch&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://medium.com/hackernoon/golang-clean-archithecture-efd6d7c43047&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https&lt;/span&gt;&lt;span&gt;://farer.org/2021/04/21/go-dependency-injection-wire/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;本文源自公众号luozhiyun很酷，分布式实验室已获完整授权。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;推荐阅读：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;点击下方卡片关注&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分布式实验室&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;，和&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;我们&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一起&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关注分布式最佳实践&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UibM134tIsO1j5yqHyNhh9arj090oAL7zGhRJRq6cFqFOlDZMleLl4pw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg5Mjc3MjIyMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzCwsauR1olj2b0tyPJXRBicSkuNEiaBuN8AQ61xkz4dH9DBr1PypYtFlEnczVkAeQvLz7rjsjttotCg/0?wx_fmt=png&quot; data-nickname=&quot;分布式实验室&quot; data-alias=&quot;DistributedLab&quot; data-signature=&quot;关注分布式相关的开源项目和基础架构，致力于分析并报道这些新技术是如何以及将会怎样影响企业的软件构建方式。&quot; data-from=&quot;2&quot; has-insert-preloading=&quot;1&quot; wah-hotarea=&quot;click&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;▲&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;点击上方卡片关注分布式实验室，掌握前沿分布式技术&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;团队对新技术认知少，团队遇到问题不知道怎么解决，想快速提升团队技术能力，想看别人的最佳实践，可扫描下方二维码咨询详情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4791666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzBicSCAQ1YLCTn9VxRE0DxWI0hwSiazicBSdJ11ECOkGckTewS0xUGDPtRrYTwb2uriaQb9ibeTPtOZX3A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3b37496e2e2cddb13ea48579c5666967</guid>
<title>十年编程，我意识到除了给客户带来价值外，没有什么是真正重要的</title>
<link>https://toutiao.io/k/57ytcg4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfOWKVYh2Q0zpKYLr6nLEf57gibJPPXFpx7tkC5a3XCLkSaKgf610Ko6iaMqTdNWib6xMBt5c5nM6AazQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;作者｜Thorsten Ball&lt;/section&gt;&lt;section&gt;
译者｜平川&lt;/section&gt;&lt;section&gt;
策划｜闫园园&lt;/section&gt;&lt;section&gt;
截至上个月，即 2022 年 4 月，我的职业程序员生涯已达 10 周年。以下是我回顾过去 10 年时想到的一些散乱无序的想法。我学到的东西，我没有学到的东西，我改变了看法的东西，以及我从来没有想过我会相信现在却信了的东西。&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;本文最初发布于 Thorsten Ball 的个人博客，经原作者授权由 InfoQ 中文站翻译并分享。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;截至上个月，即 2022 年 4 月，我的职业程序员生涯已达 10 周年。&lt;/p&gt;&lt;p&gt;我接触编程的时间比这更早，只是那时没赚工资。十几岁时，我创建过网站和 IRC 机器人，并编写了简短的 Python 脚本。然后我停下来，弹了几年吉他。在我二十多岁的时候，在相当巧合的情况下，我再次发现了自己是多么喜欢编程。当时，我按照要求创建了另一个网站，并发现，在我离开的这段时间里，Web 发生了很大的变化（现在是 HTML5 的了）。&lt;/p&gt;&lt;p&gt;于是我就想弄清楚，与继续在大学学习哲学相比，编程是否是更好的职业选择。Robin 为我回答了这个问题，他慷慨地给我提供了一个带薪实习的机会。&lt;/p&gt;&lt;p&gt;现在已经过去 10 年了，说实话，不管是对于我作为程序员的成长过程，还是对于我的职业生涯，这都不是一个重要的标志。但意识到已经过去 10 年了，我认为有必要停下来思考一下。&lt;/p&gt;&lt;p&gt;以下是我回顾过去 10 年时想到的一些散乱无序的想法。我学到的东西，我没有学到的东西，我改变了看法的东西，以及我从来没有想过我会相信现在却信了的东西。&lt;/p&gt;&lt;p&gt;在很大程度上，它们源于我参与软件开发的环境：作为 Robin 的实习生，作为德国一家小型创业公司的软件开发人员，作为德国一家大型公司内部的创业公司的高级软件开发人员，以及现在作为一家完全远程、异步的美国创业公司的资深工程师。接下来这句话就当作免责声明吧。我敢打赌，如果我是在游戏工作室、硬件公司和大型科技公司工作，这篇文章的内容会很不一样。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;1&lt;/span&gt; 大无畏精神的价值被低估了&lt;/section&gt;&lt;p&gt;我作为学习榜样的大多数程序员都有一个很少被提及的特质：大无畏精神。&lt;/p&gt;&lt;p&gt;他们会毫无畏惧地钻入一个未知的代码库。他们会毫无畏惧地打开他们怀疑存在不正常依赖关系的代码。他们会在不知道如何完成的情况下开始工作。&lt;/p&gt;&lt;p&gt;看到别人无所畏惧非常令人鼓舞，但自己变得无所畏惧是我发现的最好的学习加速器之一。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;2&lt;/span&gt; 未来不可预测，试一下可能给自己惹来麻烦&lt;/section&gt;&lt;p&gt;我们都知道，未来不可预测。但我花了很多年才真正在编程时考虑这一点。&lt;/p&gt;&lt;p&gt;在我职业生涯的前三分之一，我会想：我们会需要这个的，所以让我们现在就构建它。在第二个三分之一，我会想：我们可能需要这个，所以让我们做好准备。现在，我会想：我们不知道我们是否会需要这个，这是一种可能性。当然，看起来我们可能需要，没错。但事情一直在变化，所以让我们构建现在已知需要的东西。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;3&lt;/span&gt; 编写的代码要易于测试&lt;/section&gt;&lt;p&gt;编写代码时要秉持这样一个理念：我写代码不只是为了让计算机执行，我写代码也是为了让它易于阅读和理解，或易于删除，或易于修改，或易于审查。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;4&lt;/span&gt; 除了给客户带来价值外，没有什么是真正重要的&lt;/section&gt;&lt;p&gt;类型安全，测试覆盖率 100%，在代码中流畅表达业务逻辑的能力，完美的开发工具，不浪费资源的高效系统，在工作中使用最好的编程语言，优雅的 API 设计，快速反馈回路，编写良好的代码——这些都不是目标。&lt;/p&gt;&lt;p&gt;目标应该是：为你的客户提供价值，通过交付软件来解决他们的问题，不断重复这个过程。前面那些事可以帮助你做到这一点——更快、更便宜、更有效、更安全、更快乐——但它们不是目标。目标是为你的客户提供价值。&lt;/p&gt;&lt;p&gt;陷阱：编写软件往往比交付软件更容易。但是，交付才是最重要的。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;5&lt;/span&gt; 完美是不可能的&lt;/section&gt;&lt;p&gt;我或许曾经认为那是可能的，但现在我确定那不可能。一切都是权衡的结果。&lt;/p&gt;&lt;p&gt;你永远无法在你关心的每个方面都达到 100%。有些东西必须要让步。当你认为自己做到了完美，你很快就会意识到自己忘记了一些东西。&lt;/p&gt;&lt;p&gt;我的审美观也发生了变化。我现在不再寻求完美之美，而是认为尽管有缺陷但仍能成功的程序就是美。看看那个小程序吧，尽管里面有 17 个 TODO，但它还是维系了互联网的发展。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;6&lt;/span&gt; 如果你不能把它与业务联系起来，那就无所谓了&lt;/section&gt;&lt;p&gt;你可以重构一个代码库，对其进行大幅清理，使每个人都更容易理解，也让代码库更容易扩展，但如果该代码库在四个月后因为该项目对业务没有帮助而被删除，那么所有这些就都不重要了。&lt;/p&gt;&lt;p&gt;你可以花几周时间为你写的所有代码添加跟踪和可观察性，但你会意识到，没有人会去看，因为这些代码每天都会运行三次，而且从未引起任何问题。&lt;/p&gt;&lt;p&gt;你可以调整和优化代码，使其高效运行，以至于公司可以将运行代码所需的机器数量减半，尽管所节省的成本与你在优化时得到的工资相比显得微不足道。&lt;/p&gt;&lt;p&gt;你可以把时间花在绝妙的技术工作上，但那仍然是时间的浪费。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;7&lt;/span&gt; 弄清楚规则试图防止什么，然后考虑该规则的可选性&lt;/section&gt;&lt;p&gt;如果你在 5 年前问我 TDD、清洁代码、软件工匠精神和其他学派是否是教条主义，我会说：“不！你看不出来吗？干净、良好的代码很重要！”&lt;/p&gt;&lt;p&gt;现在，回过头来看，当我思考“一个方法不应该超过 5 行”这样的规则是否有用的时候，我摇了摇头。&lt;/p&gt;&lt;p&gt;这不是关于规则的问题！而是这些规则所要防止的问题。如果你没有规则试图防止的问题，或者你可以用另一种方式来防止它，那么你就不需要这个规则。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;8&lt;/span&gt; 编写测试让你可以相信系统能正常工作&lt;/section&gt;&lt;p&gt;不要太在意一个测试是集成测试还是端到端测试，是单元测试还是功能测试。不要和别人争论是否应该测试私有方法。不要再为是否应该在测试中访问数据库费神。&lt;/p&gt;&lt;p&gt;相反，编写能让你知道系统是否能正常工作的测试。理想情况下，只需 3 次点击，并且在 1 秒钟内就可以完成。&lt;/p&gt;&lt;p&gt;关于这一点，我花了很长时间，做了很多无用的讨论，并以诸多代码缺陷为代价才学到。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;9&lt;/span&gt; 最佳实践通常是基于这样的假设：你知道代码应该做什么&lt;/section&gt;&lt;p&gt;如果你确切地知道要构建什么，那么最佳实践和模式可以给你带来帮助，为你提供如何进行构建的建议。&lt;/p&gt;&lt;p&gt;但是，如果你还不知道这个程序应该做什么，或者它在四周后会是什么样子，那么有些最佳实践会使事情变得更加困难。&lt;/p&gt;&lt;p&gt;有些实践在重写时使用非常合适，但在探索时使用却非常糟糕。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;10&lt;/span&gt; 使用别人的代码并不像我想象的那么好&lt;/section&gt;&lt;p&gt;我的职业生涯是从编写 Ruby 和 JavaScript 代码开始的，因为有包管理器可以使用，所以我总是会问，“难道没有一个包能做这个吗？”。&lt;/p&gt;&lt;p&gt;常识告诉我们：如果可以，尽量使用库，而不是自己编写。尽可能地重用代码，不要重新发明轮子，不要复制和粘贴。这是我多年来的信念。&lt;/p&gt;&lt;p&gt;但这也有弊端。有时候，自己写一个函数可能比添加一个依赖更好。&lt;/p&gt;&lt;p&gt;依赖是有成本的，你必须保持它们最新，它们会增加编译或加载时间。它们会在堆栈跟踪信息中添加奇怪的东西。而且，很多时候，它们所做的比你需要的多得多，这意味着你付出的比得到的多得多。&lt;/p&gt;&lt;p&gt;当你把别人的代码粘在一起的时候，有一个非常现实的危险，那就是胶水代码的复杂度会不断累积。但这是你最不希望复杂性存在的地方。它会隐藏复杂性。你所要做的是尽可能地让复杂性显露出来，并想办法消除。&lt;/p&gt;&lt;p&gt;有时候，自己写比用别人的代码更好。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;11&lt;/span&gt; 有些公司做到了，有些公司没做到，但没有谁是完美的&lt;/section&gt;&lt;p&gt;为软件公司开发软件和为迫不得已雇用软件开发人员的公司开发软件之间有很大的区别。在一个领导层了解软件及其生产方式的公司工作是一件很快乐的事。&lt;/p&gt;&lt;p&gt;话虽如此，我不认为有哪家公司能解决所有问题。每家公司都有某种程度的发挥空间。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;12&lt;/span&gt; 在反馈回路上投入绝对不会白费功夫&lt;/section&gt;&lt;p&gt;我从来没有后悔改进反馈回路。更快的测试，更好的测试输出，更快的部署，把一个手动的反馈回路变成一个可以一键反馈信号的东西。&lt;/p&gt;&lt;p&gt;不过要注意：一旦你看到软件开发可以具有真正快速、高效的反馈回路，你就会永远渴望它。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;13&lt;/span&gt; 总是在一天结束的时候留点未完成的事&lt;/section&gt;&lt;p&gt;一个失败的测试，一个编译错误，一个未写完的语句——以其中某一项结束你的一天，第二天早上你就可以坐下来继续你的工作，完全跳过了“嗯，我今天应该做什么……”。&lt;/p&gt;&lt;p&gt;没有什么比一个需要通过的测试失败了更能让我快速开始。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;14&lt;/span&gt; 完美主义是个陷阱&lt;/section&gt;&lt;p&gt;完美主义基于谎言。你永远无法做到完美，总会有一些东西差强人意。接受不完美的存在，交付并继续构建。&lt;/p&gt;&lt;p&gt;以 80% 为目标，将其他 20% 视为可选项，给自己留下可以自由呼吸的空间。你最终可能达到 99%，谁知道呢？&lt;/p&gt;&lt;section&gt;
&lt;span&gt;15&lt;/span&gt; 工欲善其事必先利其器&lt;/section&gt;&lt;p&gt;我把大量的精力投入到了工具上：Vim、git、shells、Unix 环境、测试框架。我真的很享受在 Vim 配置中度过一个周日的早晨。&lt;/p&gt;&lt;p&gt;但也有可能做得过头，陷入配置阶段无法自拔，做着无休止的修补工作。你必须先使用工具，然后才能知道如何配置和使用最好。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;16&lt;/span&gt; 招聘很难&lt;/section&gt;&lt;p&gt;我现在已经做过数百次面试，我获得的最重要的见解是，招聘真的非常非常难。面试评价受很多随机因素影响，让人在“强烈同意”和“强烈反对”之间摇摆不定。&lt;/p&gt;&lt;p&gt;我常常希望有一种方法可以发现人们是否有“搞定”基因。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;17&lt;/span&gt; 开发人员最重要的特质：因为必须要完成，所以撸起袖子就干&lt;/section&gt;&lt;p&gt;所有我喜欢的人都有一个共同点：他们做工作任劳任怨。他们知道有些任务并不好玩，也不刺激，更不有趣。但因为必须有人去做，所以他们就做。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;18&lt;/span&gt; 在一段比较长的时间内与其他人一起在同一个代码库上工作&lt;/section&gt;&lt;p&gt;与一群人在同一个代码库中工作多年，没有什么能比这个更能帮助我提升软件工程方面的水平了。&lt;/p&gt;&lt;p&gt;你会看到决策是如何进行的。&lt;/p&gt;&lt;p&gt;你会看到最终哪些事情是重要的，哪些不重要。&lt;/p&gt;&lt;p&gt;当你的同事在你写完代码 3 年后试图修改它时，你会看到你代码真正的可扩展性。&lt;/p&gt;&lt;p&gt;你会看到你的预测——我们现在有 2 个，但我肯定将来会有 5 个——是否会变成现实，并在做其他预测时考虑这个结果。&lt;/p&gt;&lt;p&gt;会有些代码让你后悔，也会有其他一些代码让你感到高兴。反思这两者的区别，你就可以学习提升。&lt;/p&gt;&lt;p&gt;你会看到工具出故障，只是因为某个地方的某个东西发生了变化，虽然与你无关，但你仍然要修复。&lt;/p&gt;&lt;p&gt;对于软件的某些部分，你会说“我三年来从未考虑过这个问题”，并把它们视为珍宝。&lt;/p&gt;&lt;p&gt;你会看到代码库中有哪些部分新同事很难理解，哪些部分他们马上就会有收获。&lt;/p&gt;&lt;p&gt;你会看到你编写的代码在 4 年后是什么样子。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;19&lt;/span&gt; 了解全栈&lt;/section&gt;&lt;p&gt;对我来说，很少有什么事情能像听到“你并不一定需要知道它是如何工作的...... ”这句话那样让我备受激励。&lt;/p&gt;&lt;p&gt;当然，我可能不需要，但如果我没有设法理解 GC 的工作原理，或 Unix 的工作原理，或多线程的工作原理，或数据库如何存储数据，或解释器和编译器如何工作，我就无法做到今天这个程度。&lt;/p&gt;&lt;p&gt;这对我的工作也有好处。我可以做出更好的技术决策，因为我能够更准确地权衡取舍，知道底层发生了什么。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;20&lt;/span&gt; 打字可能成为瓶颈&lt;/section&gt;&lt;p&gt;我之前说过。不要让打字成为瓶颈。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;21&lt;/span&gt; 代码审查并非密不透风&lt;/section&gt;&lt;p&gt;在很长一段时间里，如果我在代码审查时漏掉了 Bug，我就会认为这是我的错。我漏掉了！我怎么会漏掉呢？如此明显的 Bug！&lt;/p&gt;&lt;p&gt;后来我发现，不仅仅是我：其他人在代码审查也会漏掉 Bug。事实上，他们已经接受了这种情况，并且毫无顾忌地说，代码审查并非无懈可击。我松了一口气。&lt;/p&gt;&lt;p&gt;这改变了我对代码审查的看法：它是一种不完美的东西，需要与其他方式相结合来验证代码。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;22&lt;/span&gt; 并非每次代码审查都是值得的&lt;/section&gt;&lt;p&gt;并非每条代码都需要进行彻底地审查。有时候，如果风险可接受，那么快速扔下一句 “LGTM!”就可以了。这可以释放同事的潜能，保持势头，潜移默化地建立信任。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;23&lt;/span&gt; 消极滋生消极&lt;/section&gt;&lt;p&gt;如果你屈服于消极，那么你就会越来越消极。你得到的总是比你想要的多得多。&lt;/p&gt;&lt;p&gt;它是病毒式的。它始于讽刺，然后变成愤世嫉俗，最终演变为“一切都很糟糕”。不久之后，无论做什么事情都要问“为什么要这么做？”久而久之，人们会对你隐瞒兴奋、喜悦和想法。&lt;/p&gt;&lt;p&gt;做一个消极的人太容易了。我认为，在某种程度上，指着什么说它的坏处，然后耸耸肩说，我早就料到这不是什么好事（每件事都是坏事，对吗？）——这很容易。这很容易做到，也很容易被误认为是一种能够发现缺陷和最坏情况的工程思维（其实不是这样的）。&lt;/p&gt;&lt;p&gt;困难的是看到事物的本来面目，看到它们的美好之处。对别人的想法给予鼓励，即使它们几乎没有什么可谈的东西。创造和培育快乐，这很有挑战性。&lt;/p&gt;&lt;p&gt;所以，最终在某个时候，我决定克服消极，并试图做有挑战的事情。到目前为止，这对我很有帮助。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;24&lt;/span&gt; 你无法什么都做百分之百&lt;/section&gt;&lt;p&gt;我不可能一直把所有事情都做得同样好。我不能一边写书，一边在事业上取得进展，一边做一个伟大的父亲，一边在健身房里创造记录，还一边读着两本书。这种状态维持不了一两个星期。这是不可持续的。&lt;/p&gt;&lt;p&gt;现在，我会在重要的事情之间做好切换：当我想在一件特定的事情上取得进展时，我就会在一段时间内专注于这件事情，并接受其他事情必须进入保持模式。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;25&lt;/span&gt; 代码是有重量的&lt;/section&gt;&lt;p&gt;代码是有重量的。你不需要的每一行代码都是压舱物，它会增加代码库的重量，这会让你更难掌控和改变方向。你需要的代码越少越好。&lt;/p&gt;&lt;p&gt;代码必须易于阅读，必须经过测试，必须保持兼容，必须保持安全，必须可以工作。即使它现在没有做任何有用的工作，有它在身边也无妨，不是吗？不是的。务必删除它并继续前进。如果有必要，从版本控制中恢复即可。&lt;/p&gt;&lt;p&gt;对测试来说也是如此，我要是早知道就好了。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;26&lt;/span&gt; 编程是我生活的一部分&lt;/section&gt;&lt;p&gt;自从开始做实习生以来，我在工作之外花了相当多的时间在编程上：阅读技术书籍，写书，做业余项目，写博客文章，做讲座，去参加会议，学习新语言和工具。&lt;/p&gt;&lt;p&gt;有一些公司并不关心你的大学学位，只要你能证明你真的很擅长编程，这是我多年来的动力。&lt;/p&gt;&lt;p&gt;我喜欢在工作之外花时间进行编程，但不是所有时间。有些感觉像是工作，有些技术书籍读起来很耗费精力。但就是有些事情在做的时候感觉不是很好。&lt;/p&gt;&lt;p&gt;如果我只在白天的工作中编程和学习编程知识，那么我的职业生涯将完全不同。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;27&lt;/span&gt; 计算机速度很快&lt;/section&gt;&lt;p&gt;构建 Web 应用程序使我认为 100 毫秒很快，50 毫秒是真的快。编写编译器让我知道，对于现代计算机来说，1 毫秒就是永恒。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;28&lt;/span&gt; 我还是那么喜欢编程&lt;/section&gt;&lt;p&gt;我写的一些内容可能会被说成是我多年来变得愤世嫉俗。我的意思是“什么都不重要，完美不可能实现”吗？&lt;/p&gt;&lt;p&gt;不，恰恰相反。我有在意的事情，而且非常在意，只是在意的事情比之前少了，但我还是那么喜欢编程。&lt;/p&gt;&lt;p&gt;欢迎在 Twitter 上关注我（@thorstenball），或者给我发邮件（me@thorstenball.com），或者在 interpreterbook.com 和 compilerbook.com 网站上阅读我写的书。&lt;/p&gt;&lt;p&gt;我还维护着一个邮件列表，我偶尔会在那里发布关于我的书或这个博客的更新，欢迎订阅。我不会向你发送垃圾邮件，你可以在任何时候取消订阅。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原文链接：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://thorstenball.com/blog/2022/05/17/professional-programming-the-first-10-years/&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
今日文章推荐&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;amp;mid=2247523596&amp;amp;idx=1&amp;amp;sn=03751fe161000ef47ed2d68d1f7144dc&amp;amp;chksm=e8d462cedfa3ebd8c02e29606dfa58a16eede8dcfb36d02523ceeafe880cc0c86336d351adfc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2022 年无服务器应用程序开发的最新趋势&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;2022 年无服务器应用程序开发的最新趋势&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;amp;mid=2247523561&amp;amp;idx=1&amp;amp;sn=20587ade389ea756fe93aa393b95711b&amp;amp;chksm=e8d4632bdfa3ea3dd9713c70db754f806b3a494586c55e28ca25fa7f86f4af6625f84349aeac&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Database Mesh 2.0 如何在云原生场景下提高数据库治理性能？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Database Mesh 2.0 如何在云原生场景下提高数据库治理性能？&lt;/a&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
活动推荐&lt;/section&gt;&lt;p&gt;今年 7 月，ArchSummit 全球架构师峰会将落地深圳。目前已经邀请到了顺丰集团 CTO 耿艳坤、美的集团 IoT 副总裁兼 CTO 向江旭、度小满金融数据智能部总经理 / 技术委员会执行主席杨青、Shopee 技术委员会主席叶绍志博士等多位专家来大会现场分享，更多大咖正在陆续邀请中...&lt;/p&gt;&lt;p&gt;ArchSummit 深圳站的主题是数字化转型下的架构升级，根据这一主题，以及广东地区金融业、制造业发达的特色，我们设置了金融领域数字化转型、数字化转型时代的数据治理、AICon 全球人工智能与机器学习大会、 可观测性技术落地探索、单云架构到多云架构转型、 IoT 系统架构设计、微服务架构落地实践、云原生前沿技术应用、架构师能力模型、出海业务架构、开源和自研选型思考、架构稳定性保障等专题，点击阅读原文了解详情。&lt;/p&gt;&lt;p&gt;现在购票即可享受 9 折特惠，单人立减 880 元，购票请扫码或联系：1851454922&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfOWKVYh2Q0zpKYLr6nLEf57LmqFeUMNiamGtv0DOz25wWBCYhYeJWicbsiaUS1IyC693XgXlYYXq9lGw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f8028b4fcba6fdffdceecadd411cf538</guid>
<title>欢迎加入读者圈子，一起交流！</title>
<link>https://toutiao.io/k/mtrqmru</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎加入读者圈子，一起交流！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;圈子剧透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、600+圈子成员，以中高级程序员为主，更有架构师、CTO坐镇交流；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、1000+优质主题，数十G独家资料，每日分享，精挑细选；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、全年52期专属邮件周报，让你轻松掌握业界资讯、技术干货，提升认知水平；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、全年52本好书共读，让你花最少的时间，获取更好的知识；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如行动，赶快加入吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9b4cc6d73c52df64aa9060eddc576f71</guid>
<title>页面可视化搭建工具前生今世</title>
<link>https://toutiao.io/k/8arwx3r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;85&quot; data-source-title=&quot;&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;来自：CntChen_cntchen.github.io&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;链接：https://github.com/CntChen/cntchen.github.io/issues/15&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;h3&gt;&lt;span&gt;引子&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;页面可视化搭建, 是一个历久弥新的话题. 更广义上讲, 页面是 GUI 的一部分, GUI 的拖拉生成在各种开发工具上很常见, 如 Android Studio, Xcode, Visual Studio 等. 前端页面早在十几年前就能用 Dreamweaver, Frontpage 等工具可视化搭建出来.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;Dreamweaver 操作页面示例:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7222222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvmjHZibeCI5zpMHyk6UhbY5mljmK6USCeHSWn5iavIeII5lq9M03f9Niaag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;但是现在已经很少人使用 Dreamweaver 了, 其主要原因是页面承载的内容已经和页面源码分离, 由后端接口返回再渲染到页面, 静态页面网站无法承载大量的动态内容.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;Dreamweaver 死了, 但是页面可视化搭建工具依然广泛需要和使用, 所以这个话题依然值得探讨.&lt;/p&gt;&lt;h3&gt;&lt;span&gt;文章内容&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;页面构成和页面组件化.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;页面可视化搭建工具的必要性.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;页面可视化搭建工具的区分维度.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;业界的实践实例.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;页面&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__6&quot;&gt;页面是 HTML / DOM&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;页面可视化搭建的操作对象是页面. 页面是一份 HTML 文档, 不管是静态页面还是动态渲染出来的页面, 在页面上看到的内容, 都是 HTML 文档的一部分.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;对 HTML 文档的实例化和操作, 通过文档对象模型(DOM)来实现, 也可以说页面是一个 DOM. 本文没有严格区分 HTML 和 DOM 这两个概念, 以下行文都用 HTML 这个概念.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;HTML 使用一种树形结构来表示页面, 树的每个节点为一个页面元素或文本节点, 一个页面元素可以包含多个页面元素节点或文本节点. 页面元素通常称为标签, 页面元素类型由 HTML 规范定义.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;HTML 结构示例:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5473251028806584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvmuwcwFpibNppDq1vMFlrgljPQC3Dyj5VAd6LwOhk3ibrR3dHZvF5krD3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;486&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__8&quot;&gt;页面是 HTML Tree + Data&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;从前端开发的角度, 可以认为页面是由 HTML Tree 和 Data 组成, HTML Tree 是页面元素的树形结构, Data 是页面元素的属性或文本节点. 下图中蓝色框所示的节点可以认为是数据.&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5473251028806584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvmMHpJ0Q7LHUiammf4OyTQxBrg0hYPx1WZnt6V8Dw4jO0yYrap2GlIHVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;486&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;为什么从前端开发角度会说页面是 HTML Tree + Data? 举一个常见场景来说明: 在开发新页面时, 我们是可以复制已有页面(好吧, 我就是这样的前端工程师), 然后只修改页面 HTML, 或者只修改数据, 或同时修改 HTML 和数据, 从而完成新页面的开发.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__10&quot;&gt;静态页面和动态逻辑页面&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;上一节说页面的由 HTML Tree 和 Data 组成, 讨论的是静态页面.&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.225&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvmicRDoMHDe9qJfrEkh68rj9MicJeXtCVtuCWayzibwHPBeQtQL6lETeETg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;浏览器请求静态页面, 网络返回的 HTML 源码就是页面渲染完成后的 HTML. 静态页面的源码和页面渲染结果一致:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2851851851851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvm3g0zDjOgoW2GfiahEKh2fJhmWXYFicseMNGajxPZ5MHPw4TiadibCCsJoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;当下, 前端页面更多的是有动态逻辑的页面, 在页面中引入和使用动态脚本(Javascript)对页面进行修改和控制.&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30185185185185187&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvmmDiafmffqqTa0vx90xSLJTrqVsWEGFn8QLGoFfWkD3VGiaNyj7DeCqpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;浏览器请求动态逻辑页面, 网络返回的 HTML 源码与页面渲染完成后的 HTML 有差异. 动态逻辑页面的源码和渲染结果有差异:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32037037037037036&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvm7dOtb5bHEnGksdaowg6cQyb9N1QHV9yFjUeLasOC5MsGZBFlCS1iaQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__12&quot;&gt;页面组件化&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;页面渲染后是一棵 HTML 元素构成的树, 页面的可编辑粒度为 HTML 规范定义的 HTML 元素. 使用 Web Components 组合 HTML 元素, 实现了功能封装和可复用的页面组件. 在流行的前端框架中, 都提供了组件化的功能, 从前端框架的视角看, 页面是由组件树组成. 这些组件内部维护自身的 HTML 元素结构、样式和功能逻辑, 并通过组件的 props 获取外部传入的数据, 实现了功能封装和复用.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;Vue 组件树示例:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45925925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvm41icmEIH2W9QicyD0yBic2kZcA67PN083Tc7qOxJShoYwY9xZncfdTTRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__14&quot;&gt;并没有讨论 CSS&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;在以上的章节中, 我们并没有讨论决定页面样式的 CSS. 因为借助 Javascript 的动态逻辑, CSS 可以归入到 Data 的范围: 通过对页面元素 style attribute 的修改, 或将 CSS 属性动态添加到 style 标签中, 可以实现对页面元素样式的修改.&lt;/p&gt;&lt;h3&gt;&lt;span&gt;页面可视化搭建&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;有了对页面组成的认知基础, 可以对页面可视化搭建有更多的讨论: 页面可视化搭建是什么? 为什么需要?&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__17&quot;&gt;是什么&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;如前文所阐述, 动态逻辑页面分解为 HTML Tree, Data 和 Dynamic Logic. 前端开发工程师开发前端页面的过程, 本质上是用编程工具(IDE)对页面的 HTML Tree, Data 和 Dynamic Logic 进行增删和修改.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;页面可视化搭建, 是用可视化交互的方式对页面的 HTML Tree, Data 和 Dynamic Logic 进行增删和修改, 从而实现页面的生成. 页面可视化搭建工具是实现页面可视化编辑的软件工具.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;用页面可视化搭建工具来搭建页面与前端工程师在页面上搬砖, 都是搭建页面, 区别在于实现页面搭建的方式. 做个简单对比:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35648148148148145&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvmSLX5dDtAln1h7BAfA5V1BaBw5piczhHm9mZDkM1HSKpJ1eeOJZDkJjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__19&quot;&gt;为什么需要&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;任何工具的存在都是更高效地解决问题. 页面可视化搭建工具, 用于解决页面生成的效率问题. 可能前端工程师会觉得最有效率的页面生成方式是打代码, 但有搭建页面需求的不只是前端工程师. 而可视化页面搭建工具, 恰恰是面向&quot;就缺一个前端工程师&quot;的人员, 用于提升他们生成页面的效率. 我们可以从一些使用场景来窥探页面可视化搭建工具的应用场合.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__21&quot;&gt;页面小白做 H5&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;页面小白不需要任何页面相关的知识, 不需要了解 HTML/JS/CSS 这些概念, 只要像使用 Word 一样在 H5 制作工具上操作, 就可以做出一个挺漂亮的页面. H5 制作工具很多, 其中 百度H5 做很好不错.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;如: 小陈女票要生日了, 小陈为女票做了一个有创意的生日祝福页面:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8694444444444445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvmBROrXcoRYVvnArLOuPmC5aEicoKXmXiaC0K1sXIlTvbJsvWhvWTZ5J2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__23&quot;&gt;营销活动页面搭建&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;大多数互联网公司需要做许多的活动页面来承载运营业务. 运营活动页面的特点是: 页面功能大同小异、时间紧、下线快、研发性很比低. 前端工程师无法持续开发无穷无尽的活动页面, 需要采用活动页面可视化搭建工具, 由运营人员/产品人员直接生成活动页面. 研发人员的工作转变为提供满足活动页面业务需要的活动模板.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;如: 抽奖活动页面的可视化搭建:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7314814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvmXWicg0RSjbEXZaX1maDVkCawnX1Jxbnvq5WkIOGom0Gdno4HQCTbV3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__25&quot;&gt;中后台系统开发&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;在公司内部, 需要做许多的中后台支持系统, 这些系统的管理端一般用 web 页面承载. 那么问题来了, 中后台系统的前端工程, 怎么保障可用性、可维护性和页面呈现一致性? 这些系统与后台逻辑强关联, 一般由后台开发人员开发; 后台开发人员写代码逻辑是没有问题的, 但是其前端开发能力相对较弱. 所以需要增强他们开发前端页面的能力, 前端开发能力由前端服务化提供.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;前端服务化的第一种方式是提供一套组件库, 如 饿了么的 Element. 组件库一般由前端开发人员封装成模板工程, 模板工程提供公共样式和函数库, 并对编写的代码做校验和约束, 一定程度上降低了前端开发难度, 统一后台人员代码风格. 此时后台开发人员的开发方式为: 在代码中用组件拼凑页面, 然后写代码逻辑.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;前端服务化的第二种方式, 是提供页面可视化组装系统, 这个系统输出组装后的前端工程源码. 这样的系统比提供组件库和模板工程的方式走得更远: 通过可视化生成模板工程, 后台开发人员不需要在代码中拼凑前端页面, 不需要关注前端组件, 只需要编写代码逻辑. 这种方式可以参考阿里的 ice.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;阿里 ice 示例:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7101851851851851&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvmllKVvUUr9aJrTbCEZC5yAjZNaibrRTZibZZRnqgSkZoAD7MzUHyCD9lQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;前端服务化的终极方式, 是直接提供一个开发的 IDE, 将动态逻辑的书写也在 IDE 中完成. 如 美团外卖前端可视化界面组装平台 —— 乐高, 前端服务化——页面搭建工具的死与生.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;美团乐高示例:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3814814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvmQpPjoD5FiaFoWTvLfcHiahQSricnSpOriaOr1Izic69phibmJ5YNFRICDH2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__27&quot;&gt;前端服务化&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;更加广泛来说, 为页面小白/运营人员/产品人员提供的页面可视化生成工具, 也是赋予以上人员前端开发的能力. 所以页面可视化搭建, 本质上是前端服务化的一部分. 前端服务化总结, 可以看百度的 前端即服务-通向零成本开发之路.&lt;/p&gt;&lt;h3&gt;&lt;span&gt;页面可视化搭建工具区分维度&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;有了前文对页面的基础认知, 终于进入了本文的正题 -- 页面可视化搭建工具. 前面已经零星讨论过页面可视化搭建工具的定义, 再总结一下: 页面可视化搭建, 是指用可视化交互的方式(对比编写代码的方式), 实现页面的修改或生成; 页面可视化搭建工具, 增强了使用者的前端开发能力, 提升了使用者修改或生成页面的效率.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;思考一个更具体的问题: 当我们讨论页面可视化搭建工具时, 怎么进行描述和讨论? 换个角度提问题: 可以从什么维度对页面可视化搭建工具进行描述和区分?&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;页面可视化搭建工具的区分维度包括:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;下文会对页面可视化搭建工具的区分维度做介绍, 并对每个区分维度提供示例(这些示例不会展开讨论, 且在不同维度下会多次使用同个示例).&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__30&quot;&gt;系统功能&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;页面可视化搭建工具的系统功能是指该工具在解决特定页面可视化搭建问题上提供的核心能力. 页面是由HTML Tree, Data 和 Dynamic Logic 三部分组成, 一个页面可视化搭建工具提供的能力是编辑页面组成部分之一或多部分. 对基于组件的页面, 其可编辑单元为组件, 此时采用 Component Tree 概念取代 HTML Tree.&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23703703703703705&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvmCD0xI5Zkp7vUa9EIENI3swHkjTNl8vguRJFdQibvbDMFlHZ8kTtiawSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 16px; display: inline-block; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__31&quot;&gt;HTML Tree 编辑&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;这类页面搭建工具专注于可视化地编辑页面 HTML Tree 部分, 一般可以对页面做自由度较高的编辑. 其关键功能在于高自由度: 几乎可以编辑页面可见的所有元素, 能自由修改页面结构、页面元素样式和页面数据, 采用类似 Word, Photoshop 的可视化编辑方式. 这类工具一般只适用于生成逻辑比较简单的页面, 其中原因后续会讲. 常说的 H5 制作工具就是指这类工具.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;如: 百度H5、iH5&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 16px; display: inline-block; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__32&quot;&gt;Component Tree 编辑&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;这类页面搭建工具针对组件化的页面, 主要实现 Component Tree 的可视化编辑. 其核心功能在于页面布局设计: 在 UI 组件列表中选择合适的组件, 通过拖拉的方式将组件嵌入到页面中, 生成带布局和样式的页面.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;如: ice 阿里飞冰、vue-layout&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;vue-layout 示例:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9805555555555555&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvmNOJRJlIoXHh3jDib7iaerw6IFEmLuibv231d5bWbGvNNVg8Pd1xDsgDWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 16px; display: inline-block; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__33&quot;&gt;页面 Data 编辑&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;这类页面搭建工具专注于可视化地编辑页面的 Data 部分, 如图片URL、按钮文本、按钮跳转链接等. 这类搭建工具主要针对 HTML Tree 比较固定、能承载复杂业务逻辑的页面. HTML Tree 固定的常见方式是页面组件化, 只需修改页面组件的 Data 就能快速地生成页面. 其核心功能在于快速搭建承载业务逻辑的页面. 通常营销活动页面就采用这种方式来可视化搭建.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;如: 阿里云凤蝶、开源的 pipeline&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;阿里云凤蝶示例:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7092592592592593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvmN7PpCBeE1erqw7J5SADMYKYcpxsJ61RTQjWkz7kxWfvoestXRXZhGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__35&quot;&gt;#Dynamic Logic 编辑&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;这类页面搭建工具支持在界面上输入逻辑代码, 实现页面 Dynamic Logic 编辑, 如后台接口请求逻辑, 业务判断逻辑等. 这些逻辑代码需要有合适的插入点, 一般在事件钩子中提供插入点, 如页面 onload、网络请求状态变更、按钮事件、数据变更等. 做到可以支持编辑 Dynamic Logic 是超牛逼的事情, 这类工具对页面的理解最深入, 对开发者的技术能力、前端架构能力和开发能力都要求很高.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;如: 前端服务化——页面搭建工具的死与生&lt;/p&gt;&lt;h3&gt;&lt;span&gt;系统功能组合&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;还有其他系统功能的组合, 可以综合上面的典型类别来做讨论.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__38&quot;&gt;面向客群&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;页面可视化搭建工具的面向客群是指工具的的使用客群. 不同的使用客群, 其对页面技术的认知程度、搭建页面的诉求有所不同, 所以可以从工具的面向客群来区分不同工具.&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21481481481481482&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvm0hLwvf0Dhgk8zuo6GtpibCEsIIEkpPSGeVn55SMa3TDS01B76mpQPrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 16px; display: inline-block; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__39&quot;&gt;前端小白&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;前端小白是不具有前端知识的人群, 他们对页面可视化搭建工具的诉求是交互性越高越好. 最适合他们的工具是像 Word, Powerpoint, Photoshop 等具有丰富交互功能, 且所见即所得的页面搭建工具. 同时他们也不关心页面最后用什么方式托管到互联网上, 页面编辑完成后要帮他们在公网上托管页面, 并提供页面链接, 方便前端小白将页面发给自己的女朋友.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;如页面界的 Photoshop:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8037037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvm8Yia1J9vJPDRbfCDoGBuymQPWEIAUUnBxrarmwGcib1ObduNaiaxxPaRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 16px; display: inline-block; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__40&quot;&gt;运营/产品&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;运营、产品人员没有开发人员页面开发、逻辑编程的能力, 他们的诉求是可以快速搭建活动、产品页面. 活动、产品页面是承载着业务逻辑的: 如包含领取优惠券功能、背景音乐播放功能、产品购买功能等. 运营、产品对页面可视化搭建的另一个诉求是&quot;快速&quot;: 一天好几个活动, 怎么快怎么来. 面向运营、产品的可视化搭建工具, 需要将页面的逻辑功能封装在页面区块内, 支持通过点击来选择区块, 然后在表单中编辑区块所需数据, 只对页面进行少量编辑就完成业务页面搭建. 如领取优惠券的页面, 运营、产品只要在表单中填入优惠券的 ID, 然后就快速生成领取该优惠券的页面, 不需要关心优惠券在页面上如何展示和被领取的具体逻辑.&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 16px; display: inline-block; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__41&quot;&gt;中后台开发人员&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;中后台开发人员具有逻辑编程能力, 但其前端开发能力比较弱. 中后台开发人员的诉求是, 在开发中后台系统的 Web 管理端时, 不需要进行重度的前端页面结构和样式开发, 可以专注在逻辑和数据处理上. 这要求页面可视化搭建工具提供页面搭建的区块, 对区块进行可视化组合来输出一个基本的前端页面; 并在页面搭建工具上提供业务逻辑编写的输入点, 或将基本前端页面源码导出到 IDE 中供中后台开发人员进行业务逻辑的开发.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;如: ice 阿里飞冰&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 16px; display: inline-block; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__42&quot;&gt;前端工程师&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;要啥页面可视化搭建工具, 抓起键盘就开始干.&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.674074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvmt4yJMAOFNXEMTzupvibMmuDBciaYGGibFr1rxTZYNE8LWHibN5nV3IZXVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;编辑自由度&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;页面可视化搭建工具的编辑自由度, 是指页面可编辑单元的粒度. 前端页面的可编辑单元为 HTML 元素; 从前端页面组件化的角度, 页面可编辑单元为组件. 不同的编辑自由度的选择, 是可视化搭建工具在不同业务场景下编辑自由度与编辑效率的平衡.&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1787037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvmAkYuiavvjPndfhnXmiabQL4F4IXyqFKp7pETQJRWWUOibrTj2iaF58Y2dA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;编辑自由度为 HTML 元素(左)与自由度为组件(右)的示例:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9342592592592592&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvmJI1ZRjEI1xpJ9GgYo1ymmL3ZBAnDGHly508I0l7LQHOhTq0RvLugibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__45&quot;&gt;编辑自由度为 HTML 元素&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;编辑自由度为 HTML 元素的页面搭建工具有以下特点: 可编辑的元素丰富、页面结构灵活、可视化编辑效率较低、业务逻辑封装度较低. 这类工具的可编辑单元为 HTML 元素, 可以编辑元素的文本、样式和行为, 可编辑的元素较丰富; 并且可以组合各种 HTML 元素到页面中, 生成的页面结构灵活; 从生成页面的角度, 编辑出一个页面需要从基本的 HTML 元素开始搭建, 可视化编辑的工作量较大; 一个业务功能的实现, 通常需要渲染多个 HTML 元素, 而这类工具可以自由增删业务所需的 HTML 元素, 这导致无法固定地承载业务功能, 所以这类编辑工具生成的页面, 业务逻辑封装程度较低.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;如: iH5、vvveb&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;vvveb 示例:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9925925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvmTCIyPJXabmotpdptotq6pyvWPnfoyYUf4lSR6y1tibTibBibYeHMpfG8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__47&quot;&gt;编辑自由度为前端框架组件&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;编辑自由度为前端框架组件的页面搭建工具有以下特点: 可编辑的元素依赖搭建工具包含的组件, 可视化编辑效率较高、业务逻辑封装度较高. 这类工具的可编辑单元为前端框架的组件, 这些组件需要开发并导入到页面可视化搭建工具中; 组件的渲染结果包含了多个 HTML 元素, 所以从生成页面的角度, 编辑出一个页面只需要组合组件, 可以较快速完成页面生成; 组件本身承载了特定的业务功能, 所以这类编辑器生成的页面, 业务逻辑封装程度较高. 对于嵌套的组件, 需要重点解决组件数据流和组件布局适配.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;如: Vue-Layout&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;vue-layout 示例:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9120370370370371&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvmOuOEl8HnhPCxsoUu1CJCpRE0e07mWRo9pO4UWDIA30Vib07byjkuic7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__49&quot;&gt;不嵌套的前端框架组件&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;移动端的页面, 常用的布局策略是: 宽度铺满, 高度滚动. 如果前端框架组件都设置为铺满宽度, 页面展示时组件只需在浏览器垂直方向上顺序排列, 则组件组合时候不需要嵌套, 所有组件互为兄弟节点. 这种铺满宽度的组件, 非常适合搭建移动端页面的场景: 在承载页面逻辑的同时, 使得页面的编辑更加简单, 使用者只需要处理组件的顺序, 不需要处理组件的嵌套.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;如: 阿里云凤蝶、pipeline&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;pipeline 示例:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7379629629629629&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvmPAnZ1jQ024kMwGJHVEs3JhEuiabdh46Az3lanoDBdD69mwkNvAbC47Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__51&quot;&gt;理想的页面可视化搭建框架&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;页面可视化搭建工具, 需要对页面做一些约定和约束, 在可视化搭建时遵循工具约定和约束来编辑页面. 更全面讨论页面可视化搭建工具时, 不只是关注工具本身的功能, 还需要关注工具的依赖和约束, 如页面可视化搭建工具的组件化方式、模板组织方式、编辑功能实现方式等. 从工具开发的角度说, 页面可视化搭建工具是需要架构设计的, 不同工具的区分, 其实是不同的页面可视化搭建框架间的差异.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;在互联网公司中, 广泛运用页面可视化搭建工具来支持运营活动页面的生成, 本章我们只探讨运营页面搭建工具的理想框架.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;页面可视化搭建框架的核心是实现页面的可视化编辑. 运营页面搭建工具, 声明页面配置数据并提供配置表单, 通过对配置表单的数据填充, 实现基于模板的页面生成. 如图所示:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6574074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvmXiactiazoAc1ibeImTxVUOKKC3sYwUfaQC2kDw4s6pacAgKLy7iaWMXo6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;可视化编辑&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__54&quot;&gt;配置数据&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;对页面的可编辑部分, 需要准确描述可编辑部分所需的配置数据; 配置数据是异构的, 不同页面、不同区块的配置数据各不相同. 所以需要对不同页面、不同区块定义各自配置数据的数据结构和字段类型. 理想的配置数据格式为 JSON, 因为其格式灵活, 前端友好; 理想的配置数据描述格式为 JSON Schema, 因为其支持表单动态生成和数据校验.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__56&quot;&gt;配置表单生成&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;采用 JSON Schema, 容易生成配置表单, 只要按照 JSON Schema 对 JSON 数据的描述, 可以动态渲染出配置表单. 并且可以采用 JSON Schema 对编辑后的数据做格式校验, 避免编辑错误.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;如配置表单自动生成工具 json-editor:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3055555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvm19ALDOLHBdVR9KvJypubSQzDZY89eDAGPujoPM22vU7iatZePNicLoPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__58&quot;&gt;组件化&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;组件是对 HTML 元素、元素布局和样式、业务逻辑的封装, 通过组件化的方式, 将页面的搭建转化为对组件的组合, 大大减低了运营页面生成的编辑工作量, 实现快速搭建承载业务逻辑的运营页面.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;如 pipeline 的页面组件化:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9703703703703703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aEc4lo4sgr3bpAjfwXfV5tjGoXLDdTvmibwoTmRd5zM0fiaNMibTtCH6IM9Tz1UryRvibnxeYwHx6hibNBicCjT9pwZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__60&quot;&gt;模板&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;模板是带有默认数据的页面; 对于组件化的页面, 模板是从组件库中选取部分组件, 并带有各个组件的默认数据. 采用模板生成页面, 只需对模板进行少量编辑即可实现页面快速生成.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__62&quot;&gt;与编辑系统解偶&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;编辑系统和组件解偶，组件只需要遵循编辑系统的组织约定, 其具体开发过程和承载的逻辑与编辑系统无关, 支持自由拓展页面组件. 编辑系统与模板采用的前端框架解偶, 在遵循编辑系统约定下, 可以选择不同的前端框架.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__64&quot;&gt;理想的运营页面可视化搭建框架&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;采用 JSON Schema 声明配置数据, 配置表单自动生成.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;采用组件化和页面模板实现页面生成效率的提升.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;编辑系统与组件、前端框架、模板解耦.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;在遵循编辑系统约定下, 组件可以自由拓展, 前端框架可以自由选择.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;页面可视化搭建工具举例&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;列举一些页面可视化搭工具, 并附带少量点评.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__67&quot;&gt;阿里云凤蝶&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 16px; display: inline-block; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__68&quot;&gt;移动建站平台&lt;/span&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;支持页面 Data 编辑, 面向运营、产品人员, 编辑自由度为无嵌套的组件.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;目前制作运营、活动页面功能上最好的工具.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;提供页面搭建的模板, 并支持自定义模板.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;配置表单基于 Schema 生成, 配置表单操作功能完善.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__70&quot;&gt;ice 阿里飞冰&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 16px; display: inline-block; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__71&quot;&gt;飞冰 - 让前端开发简单而友好&lt;/span&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;支持 Component Tree 编辑, 面向中后台开发人员, 编辑自由度为无嵌套的组件.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;使用&quot;物料-区块&quot;, 非前端开发人员可以快速搭建出可用、符合规范的页面.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;页面以源码方式输出.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;前端服务化的一种方式.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__73&quot;&gt;百度H5&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 16px; display: inline-block; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__74&quot;&gt;创意，绝不雷同&lt;/span&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;支持 HTML Tree 编辑, 面向前端小白, 编辑自由度为 HTML 元素.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;做 H5 的好工具, 功能上很强大, 对动画的编辑功能做到细致.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__76&quot;&gt;美团外卖前端可视化界面组装平台 —— 乐高&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;支持 Dynamic Logic 编辑, 面向中后台开发人员, 编辑自由度为可嵌套的组件.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;前端服务化的一种方式.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;在美团内部支持了许多业务页面, 没有公网服务, 了解该系统只能通过其介绍文章.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__78&quot;&gt;esview&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 16px; display: inline-block; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__79&quot;&gt;Drag vue dynamic components to build your page，generate vue code.&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;开源项目, 模仿美团点评的乐高.&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;完整的可视化页面搭建框架, 面向中后台开发人员.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;页面布局结果看起来比较乱, 自定义组件写法比较诡异; 没有融合业务逻辑, 不支持在框架中写页面的代码逻辑.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__81&quot;&gt;gaea-editor&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 16px; display: inline-block; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__82&quot;&gt;Design websites in your browser&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;开源项目.&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;支持 Component Tree 编辑, 面向中后台开发人员, 编辑自由度为可嵌套的组件.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;页面的拖拉生成, 实现得很完整.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;用于页面设计, 所以偏向页面元素的样式控制.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;技术文章对可视化搭建工具数据流有深刻理解: 可视化在线编辑器架构设计.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__84&quot;&gt;Vue-Layout&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 16px; display: inline-block; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__85&quot;&gt;基于UI组件的Vue可视化布局、生成.vue代码的工具。&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;开源项目.&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;支持 Component Tree 编辑, 面向中后台开发人员, 编辑自由度为可嵌套的组件.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;工具的使用体验效果不错.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__87&quot;&gt;gen&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 16px; display: inline-block; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__88&quot;&gt;根据接口生成页面，减少重复性工作&lt;/span&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;开源项目, 用起来感觉不错.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;系统中有好几个概念, 开始比较难上手.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__90&quot;&gt;其他&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;请使用关键字 website-builder, site-builder 等关键字进行搜索.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;VvvebJs&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;grapesjs&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;Maha&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;有赞微页面&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;X-Page-Editor-Vue&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__92&quot;&gt;业界实践&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;列举一些业界在页面可视化搭工具上的实践, 并附带少量点评.&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 16px; display: inline-block; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__93&quot;&gt;前端服务化——页面搭建工具的死与生&lt;/span&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;支持 Dynamic Logic 的页面可视化搭建 IDE.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;讲解了页面可视化搭建框架支持 Dynamic Logic 的可行性和设计架构.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;作者在前端框架和 IDE 方面写了好几篇文章, 很深刻.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 16px; display: inline-block; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__94&quot;&gt;腾讯IMWeb: 积木系统，将运营系统做到极致&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;2015年的文章! 完全说到点上.&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;简单易用的、可视化的可编辑页面.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;通用的、简便地组件接入机制.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;组件: 开发过程和系统无关, 逻辑和系统无关.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__96&quot;&gt;美团外卖前端可视化界面组装平台 —— 乐高&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;把系统架构将得很清楚, 有借鉴意义.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;对页面组成做了分析, 阐述了可视化配置的原理.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__98&quot;&gt;前端即服务-通向零成本开发之路&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__100&quot;&gt;可视化在线编辑器架构设计&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;可视化在线编辑器属于前端开发引擎, 前端进入了前端工业时代.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;深入讨论了组件数据流.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__102&quot;&gt;QQ会员: 如何保证H5页面高质量低成本快速生成&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__104&quot;&gt;vue-design 桌面端页面可视化构建程序&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-color-16464492915968=&quot;rgb(68, 84, 180)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)|rgb(62, 76, 163)&quot; data-style=&quot;font-size: 18px; display: inline-block; margin-left: 8px; color: rgb(62, 76, 163);&quot; class=&quot;js_darkmode__106&quot;&gt;esview -- 这可能是目前最好的vue代码生成工具&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;页面由 HTML Tree, Data, Dynamic Login 组成.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;页面可视化搭建工具用于提升各类人员的页面搭建效率.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;页面可视化搭建其实是前端服务化的方式.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;页面可视化搭建工具需要平衡自由度和效率.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;组件和模板是页面可视化搭建框架的核心.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;全文结束, 本文对页面可视化搭建的思考和讨论可能还不够完整, 欢迎讨论和补充.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16464492915968=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16464492915968=&quot;#fff|rgb(0,0,0)&quot;&gt;后记: 终于写完了, 历时估计一个月! 写这篇文章的初衷是给我造的页面可视化搭建框架 -- pipeline 写背景, 但思考的点比较多, 所以就独立写了一篇文章. Pipeline 基本对标阿里的云凤蝶, 已经开源。&lt;/p&gt;&lt;pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-darkmode-color-16057140139831=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(0,0,0)&quot; data-style=&quot;padding-right: 10px; padding-left: 10px; color: rgb(0, 0, 0); font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif; letter-spacing: 0px; text-align: left; white-space: normal; font-size: 16px; line-height: 1.6; word-break: break-word;&quot; data-darkmode-color-16072568501583=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16072568501583=&quot;rgb(0, 0, 0)&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;figure&gt;&lt;span&gt;--- EOF ---&lt;br/&gt;&lt;/span&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;推荐↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3NTUzNjk1OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/oGp3ImQqDoarjsIfwTvcrG25u7Uu0NBoISHFWqFc4kOOXLaTMXfPmGpSTnee8P8fqRzYw6KNxn74CzvplX2tDQ/0?wx_fmt=png&quot; data-nickname=&quot;Web开发&quot; data-alias=&quot;WebDev1024&quot; data-signature=&quot;分享Web后端开发技术，分享PHP、Ruby、Python等用于后端网站、后台系统等后端开发技术；还包含ThinkPHP,WordPress等PHP网站开发框架、Django,Flask等Python网站开发框架。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>46b9ba456c3f3b8bedd88b05b332d189</guid>
<title>千万级数据查询：CK、ES、RediSearch怎么选?</title>
<link>https://toutiao.io/k/dgpcl68</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; powered-by=&quot;xmyeditor.com&quot;&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;文章来源：https://c1n.cn/EmgJv&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在开发中遇到一个业务诉求，需要在千万量级的底池数据中筛选出不超过 10W 的数据，并根据配置的权重规则进行排序、打散（如同一个类目下的商品数据不能连续出现 3 次）。下面对该业务诉求的实现，设计思路和方案优化进行介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对“千万量级数据中查询 10W 量级的数据”设计了如下方案：&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-2&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;初版设计方案&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整体方案设计为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;技术方案如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;①&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;每天运行导数任务，把现有的千万量级的底池数据（Hive 表）导入到 Clickhouse 中，后续使用 CK 表进行数据筛选。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;②&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;将业务配置的筛选规则和排序规则，构建为一个「筛选 + 排序」对象 SelectionQueryCondition。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;③&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;从 CK 底池表取「目标数据」时，开启多线程，进行分页筛选，将获取到的「目标数据」存放到 result 列表中。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;//分页大小  默认 5000&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; pageSize = &lt;span&gt;this&lt;/span&gt;.getPageSize();&lt;br/&gt;&lt;span&gt;//页码数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; pageCnt = totalNum / &lt;span&gt;this&lt;/span&gt;.getPageSize() + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;List&lt;/span&gt;&amp;lt;&lt;span&gt;Map&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Object&lt;/span&gt;&amp;gt;&amp;gt; result = Lists.newArrayList();&lt;br/&gt;&lt;span&gt;List&lt;/span&gt;&amp;lt;Future&amp;lt;&lt;span&gt;List&lt;/span&gt;&amp;lt;&lt;span&gt;Map&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Object&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; futureList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(pageCnt);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//开启多线程调用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= pageCnt; i++) {&lt;br/&gt;    &lt;span&gt;//将业务配置的筛选规则和排序规则 构建为 SelectionQueryCondition 对象&lt;/span&gt;&lt;br/&gt;    SelectionQueryCondition selectionQueryCondition = buildSelectionQueryCondition(selectionQueryRuleData);&lt;br/&gt;    selectionQueryCondition.setPageSize(pageSize);&lt;br/&gt;    selectionQueryCondition.setPage(i);&lt;br/&gt;    futureList.add(selectionQueryEventPool.submit(&lt;span&gt;new&lt;/span&gt; QuerySelectionDataThread(selectionQueryCondition)));&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (Future&amp;lt;&lt;span&gt;List&lt;/span&gt;&amp;lt;&lt;span&gt;Map&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Object&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; future : futureList) {&lt;br/&gt;    &lt;span&gt;//RPC 调用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;List&lt;/span&gt;&amp;lt;&lt;span&gt;Map&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Object&lt;/span&gt;&amp;gt;&amp;gt; queryRes = future.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;, TimeUnit.SECONDS);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (CollectionUtils.isNotEmpty(queryRes)) {&lt;br/&gt;        &lt;span&gt;// 将目标数据存放在 result 中&lt;/span&gt;&lt;br/&gt;        result.addAll(queryRes);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;④对目标数据 result 进行排序，得到最终的「结果数据」。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;CK 分页查询&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在「初版设计方案」章节的第 3 步提到了「从 CK 底池表取目标数据时，开启多线程，进行分页筛选」。此处对 CK 分页查询进行介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;①封装了 queryPoolSkuList 方法，负责从 CK 表中获得目标数据。该方法内部调用了 sqlSession.selectList 方法。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;public &lt;span&gt;List&lt;/span&gt;&amp;lt;&lt;span&gt;Map&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Object&lt;/span&gt;&amp;gt;&amp;gt; queryPoolSkuList( &lt;span&gt;Map&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Object&lt;/span&gt;&amp;gt; params ) {&lt;br/&gt;    &lt;span&gt;List&lt;/span&gt;&amp;lt;&lt;span&gt;Map&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Object&lt;/span&gt;&amp;gt;&amp;gt; resultMaps = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    QueryCondition queryCondition = parseQueryCondition(params);&lt;br/&gt;    &lt;span&gt;List&lt;/span&gt;&amp;lt;&lt;span&gt;Map&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Object&lt;/span&gt;&amp;gt;&amp;gt; mapList = lianNuDao.queryPoolSkuList(getCkDt(),queryCondition);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (CollectionUtils.isNotEmpty(mapList)) {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;Map&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;,&lt;span&gt;Object&lt;/span&gt;&amp;gt; data : mapList) {&lt;br/&gt;            resultMaps.add(camelKey(data));&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; resultMaps;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// lianNuDao.queryPoolSkuList&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Qualifier&lt;/span&gt;(&lt;span&gt;&quot;ckSqlNewSession&quot;&lt;/span&gt;)&lt;br/&gt;private SqlSession sqlSession;&lt;br/&gt;&lt;br/&gt;public &lt;span&gt;List&lt;/span&gt;&amp;lt;&lt;span&gt;Map&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Object&lt;/span&gt;&amp;gt;&amp;gt; queryPoolSkuList( &lt;span&gt;String&lt;/span&gt; dt, QueryCondition queryCondition ) {&lt;br/&gt;    queryCondition.setDt(dt);&lt;br/&gt;    queryCondition.checkMultiQueryItems();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; sqlSession.selectList(&lt;span&gt;&quot;LianNu.queryPoolSkuList&quot;&lt;/span&gt;,queryCondition);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;pre/&gt;&lt;p&gt;&lt;span&gt;②sqlSession.selectList 方法中调用了和 CK 交互的 queryPoolSkuList 查询方法，部分代码如下：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;&lt;span&gt;select&lt;/span&gt; id=&lt;span&gt;&quot;queryPoolSkuList&quot;&lt;/span&gt; parameterType=&lt;span&gt;&quot;com.jd.bigai.domain.liannu.QueryCondition&quot;&lt;/span&gt; resultType=&lt;span&gt;&quot;java.util.Map&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;    &lt;span&gt;select&lt;/span&gt; sku_pool_id,i&lt;br/&gt;    tem_sku_id,&lt;br/&gt;    skuPoolName,&lt;br/&gt;    price,&lt;br/&gt;    ...&lt;br/&gt;    ...&lt;br/&gt;    businessType&lt;br/&gt;    &lt;span&gt;from&lt;/span&gt; liannu_sku_pool_indicator_all&lt;br/&gt;    &lt;span&gt;where&lt;/span&gt;&lt;br/&gt;    dt=&lt;span&gt;#{dt}&lt;/span&gt;&lt;br/&gt;    and&lt;br/&gt;    &amp;lt;&lt;span&gt;foreach&lt;/span&gt; collection=&lt;span&gt;&quot;queryItems&quot;&lt;/span&gt; separator=&lt;span&gt;&quot; and &quot;&lt;/span&gt; item=&lt;span&gt;&quot;queryItem&quot;&lt;/span&gt; open=&lt;span&gt;&quot; &quot;&lt;/span&gt; close=&lt;span&gt;&quot; &quot;&lt;/span&gt; &amp;gt;&lt;br/&gt;        &amp;lt;choose&amp;gt;&lt;br/&gt;            &amp;lt;when test=&lt;span&gt;&quot;queryItem.type == &#x27;equal&#x27;&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;                ${queryItem.field} = &lt;span&gt;#{queryItem.value}&lt;/span&gt;&lt;br/&gt;            &amp;lt;/when&amp;gt;&lt;br/&gt;            ...&lt;br/&gt;            ...&lt;br/&gt;        &amp;lt;/choose&amp;gt;&lt;br/&gt;    &amp;lt;/&lt;span&gt;foreach&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&lt;span&gt;&quot;orderBy == null&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;        &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; sku_pool_id,item_sku_id&lt;br/&gt;    &amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&lt;span&gt;&quot;orderBy != null&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;        &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; sku_pool_id,item_sku_id,${orderBy} order &lt;span&gt;by&lt;/span&gt; ${orderBy} ${orderAd}&lt;br/&gt;    &amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&lt;span&gt;&quot;limitEnd != 0&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;        limit &lt;span&gt;#{limitStart},#{limitEnd}&lt;/span&gt;&lt;br/&gt;    &amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;&lt;br/&gt;&amp;lt;/&lt;span&gt;select&lt;/span&gt;&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;③可以看到，在 CK 分页查询时，是通过 limit #{limitStart}，#{limitEnd} 实现的分页。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;limit 分页方案，在「深翻页」时会存在性能问题。初版方案上线后，在 1000W 量级的底池数据中筛选 10W 的数据，最坏耗时会达到 10s~18s 左右。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;使用 ES Scroll Scan 优化深翻页&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于 CK 深翻页时候的性能问题，进行了优化，使用 Elasticsearch 的 scroll scan 翻页方案进行优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| ES 的翻页方案&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;ES 翻页，有下面几种方案：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;from + size 翻页&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;scroll 翻页&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;scroll scan 翻页&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;search after 翻页&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5827464788732394&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLYL5lnmjricu67UFiamwJicv80IngsbXGpTf0ScmaBBqnu2G2mzm55EYh5pibk5d70XBBgjgyMRU296sQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1136&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对上述几种翻页方案，查询不同数目的数据，耗时数据如下表：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3619854721549637&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLYL5lnmjricu67UFiamwJicv80vV091P9rmxibSNiaEWSibCI0hscdGSS1su9AZ9JybcWWBJkZgrAx0yIOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;826&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 耗时数据&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;此处，分别使用 Elasticsearch 的 scroll scan 翻页方案、初版中的 CK 翻页方案进行数据查询，对比其耗时数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37423312883435583&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLYL5lnmjricu67UFiamwJicv80fFFVcM1tvMF6I2ISZRUVopzwGNwicaZoFuj1VHqt0gOmTcYr9jlhNcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1304&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22469325153374234&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLYL5lnmjricu67UFiamwJicv804rUKMxY0FvWCVrrNiaaOVCBZL8F0bgq7I4ribdY1s4jPZwKpOR7DFuPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1304&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上测试数据，可以发现，以十万，百万，千万量级的底池为例：&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-7&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;ES+Hbase 组合查询方案&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在「使用 ES Scroll Scan 优化深翻页」中，使用 Elasticsearch 的 scroll scan 翻页方案对深翻页问题进行了优化，但在实现时为单线程调用，所以最终测试耗时数据并不是特别理想，和 CK 翻页方案性能差不多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在调研阶段发现，从底池中取出 10W 的目标数据时，一个商品包含多个字段的信息（CK 表中一行记录有 150 个字段信息），如价格、会员价、学生价、库存、好评率等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于一行记录，当减少获取字段的个数时，查询耗时会有明显下降。如对 sku1的商品，从之前获取价格、会员价、学生价、亲友价、库存等 100 个字段信息，缩减到只获取价格、库存这两个字段信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图所示，使用 ES 查询方案，对查询同样条数的场景（从千万级底池中筛选出 7W+ 条数据），获取的每条记录的字段个数从 32 缩减到 17，再缩减到 1个（其实是两个字段，一个是商品唯一标识 sku_id，另一个是 ES 对每条文档记录的 doc_id）时，查询的耗时会从 9.3s 下降到 4.2s，再下降到 2.4s。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.47162576687116564&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLYL5lnmjricu67UFiamwJicv80Kyf6N1Fia7nBKwtAWgAfW8c3uUpDcB3OZL7AK4vfYMSK66TZh6xxw0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1304&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从中可以得出如下结论：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面对结论中涉及的 query 和 fetch 查询阶段进行补充说明。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| ES 查询的两个阶段&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在 ES 中，搜索一般包括两个阶段：&lt;/span&gt;&lt;/p&gt;&lt;h3 data-id=&quot;heading-9&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 组合使用 Hbase&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&amp;amp;mid=2247507112&amp;amp;idx=1&amp;amp;sn=63ae734b17f0fb0c13734f43a6f396f4&amp;amp;chksm=fba534abccd2bdbd33eccc82cccfdc7b5f5d57a477132dfe01a178bf3117eada70827d72fae6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;ES 亿级数据检索优化，三秒返回突破性能瓶颈&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《ES 亿级数据检索优化，三秒返回突破性能瓶颈&lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&amp;amp;mid=2247507112&amp;amp;idx=1&amp;amp;sn=63ae734b17f0fb0c13734f43a6f396f4&amp;amp;chksm=fba534abccd2bdbd33eccc82cccfdc7b5f5d57a477132dfe01a178bf3117eada70827d72fae6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;ES 亿级数据检索优化，三秒返回突破性能瓶颈&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;一文调研的基础上，发现「减少不必要的查询展示字段」可以明显缩短查询耗时。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;沿着这个优化思路，设计了一种新的查询方案：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ES 仅用于条件筛选，ES 的查询结果仅包含记录的唯一标识 sku_id（其实还包含 ES 为每条文档记录的 doc_id）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Hbase 是列存储数据库，每列数据有一个 rowKey。利用 rowKey 筛选一条记录时，复杂度为 O(1)。（类似于从 HashMap 中根据 key 取 value）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;根据 ES 查询返回的唯一标识 sku_id，作为 Hbase 查询中的 rowKey，在 O(1) 复杂度下获取其他信息字段，如价格，库存等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5291411042944786&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLYL5lnmjricu67UFiamwJicv80zvYlL5jlrB3rJmrxPBzd0iccLMwyWzMghcmEqdYLUdfq1pxJhj7TYdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1304&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用 ES + Hbase 组合查询方案，在线上进行了小规模的灰度测试。在 1000W 量级的底池数据中筛选 10W 的数据，对比 CK 翻页方案，最坏耗时从 10~18s 优化到了 3~6s 左右。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也应该看到，使用 ES + Hbase 组合查询方案，会增加系统复杂度，同时数据也需要同时存储到 ES 和 Hbase。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;RediSearch+RedisJSON 优化方案&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RediSearch 是基于 Redis 构建的分布式全文搜索和聚合引擎，能以极快的速度在 Redis 数据集上执行复杂的搜索查询。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RedisJSON 是一个 Redis 模块，在 Redis 中提供 JSON 支持。RedisJSON 可以和 RediSearch 无缝配合，实现索引和查询 JSON 文档。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据一些参考资料，RediSearch + RedisJSON 可以实现极高的性能，可谓碾压其他 NoSQL 方案。在后续版本迭代中，可考虑使用该方案来进一步优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面给出 RediSearch + RedisJSON 的部分性能数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| RediSearch 性能数据&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在同等服务器配置下索引了 560 万个文档 (5.3GB)，RediSearch 构建索引的时间为 221 秒，而 Elasticsearch 为 349 秒。RediSearch 比 ES 快了 58%。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7769461077844312&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLYL5lnmjricu67UFiamwJicv805wFOtyOUUkw0tM1WibOdRTd8QHgWpWhekSuJNHFwZNrQF8Gwla3ia0vA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;668&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据建立索引后，使用 32 个客户端对两个单词进行检索，RediSearch 的吞吐量达到 12.5K ops/sec，ES 的吞吐量为 3.1K ops/sec，RediSearch 比 ES 要快 4 倍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时，RediSearch 的延迟为 8ms，而 ES 为 10ms，RediSearch 延迟稍微低些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| RedisJSON 性能数据&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;根据官网的性能测试报告，RedisJson + RedisSearch 可谓碾压其他 NoSQL：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在混合工作负载场景中，实时更新不会影响 RedisJSON 的搜索和读取性能，而 ES 会受到影响：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，RedisJSON 的读取、写入和负载搜索延迟，在更高的百分位数中远比 ES 和 MongoDB 稳定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当增加写入比率时，RedisJSON 还能处理越来越高的整体吞吐量。而当写入比率增加时，ES 会降低它可以处理的整体吞吐量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文从一个业务诉求触发，对“千万量级数据中查询 10W 量级的数据”介绍了不同的设计方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于在 1000W 量级的底池数据中筛选 10W 的数据的场景，不同方案的耗时如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;多线程+CK 翻页方案，最坏耗时为 10s~18s&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;单线程+ES scroll scan 深翻页方案，相比 CK 方案，并未见到明显优化&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ES+Hbase 组合方案，最坏耗时优化到了 3s~6s&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;RediSearch+RedisJSON 组合方案，后续会实测该方案的耗时&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAcKQomx1LPAAAAAstQy6ubaLX4KHWvLEZgBPE16I8DRs1N5L8zNPgMIuOmW5XMbLpxukwhqHeke5t&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7YmwgiahniaXswqzEJgvwZ1xlzspkfpE2KMKJ63vxzRszhPQicxgqMialRamaF00Sr8G4WjdZbdLRXKARw9jpEubHvhS4nMdX4ceYibjg&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=x5Y29zUxcibBmBJqO26VLicPuzzWKD9piaHuDYrqN4OdxhWLst10fiaf5RAt2Vqpjsc6vtQP8LJIbick&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/Q3auHgzwzM5nv7YHhmhvPsGGX04JCIgibK2x2Ru0TOY9HeZTGSIL1KQ/0&quot; data-username=&quot;v2_060000231003b20faec8c5e08a1fc3d5c807ec30b07756771265bc6b6234fb9e05062ae69ab4@finder&quot; data-nickname=&quot;儒猿IT&quot; data-desc=&quot;互联网大厂百亿级数据中心架构（HBase+Elasticsearch）是如何一步一步演变的？#数据中心 #架构设计 #java @微信时刻 &quot; data-nonceid=&quot;16485961045866149497&quot; data-type=&quot;video&quot; data-width=&quot;1920&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;-------------  END  -------------&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;扫码&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;免费&lt;/span&gt;&lt;span&gt;获取&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;600+页&lt;/span&gt;&lt;span&gt;&lt;strong&gt;石杉老师原创精品文章汇总PDF&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;266&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;267&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZ5icqLlExialiaCQxchGhiayjmvre9iaGxkcEbZ7nouMhzte6DQrdm66ygQWsZLgTquaNdXiaV55v7fiaqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;p&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/4Acg4lxHhCmfrJ0pDVibHNTZT9yPjQDtW34fia88kcXic4lkhDKpD2D43m2ZIFmK06HQtTiaFaiawhHfqgh3JJzcFDA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;原创技术文章汇总&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.5096045197740113&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLb1sI49A5HEg8H7tqAfMEhtgy64yFFyq3ibTTZZS36cToFCiaFZWA7ABjpbTkHXlTUDWkvQRTKkQkUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;885&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.19607843137254902&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tyspBV9djfmj4CQpUYhF0Wr0PoVybcdicFSfXGYyxueVI1UMO2GOtrCyYe0PaXwSsdbQCW1iaveicQaRovgrA3eog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;102&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点个&lt;span data-mid=&quot;&quot;&gt;在看&lt;/span&gt;你最好看&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.19607843137254902&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Zgt3gMUJ2LGbE25ticZVnaXibaNMqN2jHzc7IT1tcmFIktmDib2hsdO9IiaE4r4Cia4iaKWb8jzwWmLWicyZ7Foibhh9oQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;102&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>