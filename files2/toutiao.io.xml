<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b93b512443ed8f91b10007c6fa41f47e</guid>
<title>秋天的第一份 IT 技术周刊 | 码农周刊第 320 期</title>
<link>https://toutiao.io/k/9ew44gv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;秋天的第一份 IT 技术周刊 | 码农周刊第 320 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第320期（2020-09-29）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3200&quot; target=&quot;_blank&quot;&gt;秋天的第一份 IT 技术周刊，请查收！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3200&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_320.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;思考和实践&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;由 JavaScript 之父 Brendan Eich 与 ES6 规范首席作者 Allen Wirfs-Brock 联合编写，详细记载和解读了自 1995 年语言诞生到 2015 年 ES6 规范制定为止，共计 20 年的 JavaScript 语言演化经历。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;支持 mp4, flv, m3u8 及 rtmp 协议的直播，支持移动端，PC 端。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;利器&lt;/p&gt;
        
        &lt;p&gt;实打实的干货&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;容易踩的坑&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;细致分析&lt;/p&gt;
        
        &lt;p&gt;方案和思路&lt;/p&gt;
        
        &lt;p&gt;一些实践和工具&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;报告详情&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;深入探讨&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;java相关技术分享&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 444692 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 444414 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 435415 即可&lt;/p&gt;
        
        &lt;p&gt;不定期更新一些机器学习算法，方便大家浏览，然后一起学习，一起进步&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 104739 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 99181 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本书深入地讲解了 Go 语言常见特性的内部机制和实现方式，大部分内容源自对 Go 语言源码的分析，并从中提炼出实现原理。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;值得推荐&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;无代码开发平台&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ff94730a2ac27216b17b893d57d4ea19</guid>
<title>30 个 Go 语言常用文件操作汇总，总有一个你会用的到</title>
<link>https://toutiao.io/k/kps7o16</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go官方提供的文件操作标准库分散在&lt;code&gt;os&lt;/code&gt;、&lt;code&gt;ioutil&lt;/code&gt;等多个包中，里面有非常多的方法涵盖了文件操作的所有场景，不过因为我平时开发过程中需要直接操作文件的场景其实并不多，在加上Go标准库的文档太难搜索，每次遇到要使用文件函数时都是直接Google查对应的函数。偶然查到国外一个人在2015年写的博客，他&lt;strong&gt;用常用的文件函数汇总了30个文件操作场景&lt;/strong&gt;，包括四大类：&lt;strong&gt;基本操作、读写操作、文件压缩、其他操作&lt;/strong&gt;。每一个文件操作都给了代码示例。写的非常好，强烈推荐你阅读一下，浏览一下它的目录，然后放到收藏夹里吃灰&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f7Tw3INC9Rd88gnNnkkS2vFC7zpghkgHo1G2iaQZ1NN7H1iaJW3mgT3icjQomPM8V3Z9ibQk6gDvuFsDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f7Tw3INC9Rd88gnNnkkS2vFVPPjOOrNGypc1mEiciao4zQZhpwhfibBibUhxlpQMxONWu0eZ2RuNV8D6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;，万一哪天用到了还能拿来参考一下。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文链接：https://www.devdungeon.com/content/working-files-go&lt;/p&gt;&lt;p&gt;作者：&lt;strong&gt;NanoDano&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;作者主页：https://www.devdungeon.com/users/nanodano&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;介绍&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一切皆文件&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;UNIX 的一个基础设计就是&quot;万物皆文件&quot;(everything is a file)。我们不必知道操作系统的设备驱动把什么映射给了一个文件描述符，操作系统为设备提供了文件格式的接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go语言中的reader和writer接口也类似。我们只需简单的读写字节，不必知道reader的数据来自哪里，也不必知道writer将数据发送到哪里。你可以在&lt;code&gt;/dev&lt;/code&gt;下查看可用的设备，有些可能需要较高的权限才能访问。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;文件基本操作&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;创建空文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;var (&lt;br/&gt;    newFile *os.File&lt;br/&gt;    err     error&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    newFile, err = os.Create(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Println(newFile)&lt;br/&gt;    newFile.Close()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Truncate裁剪文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 裁剪一个文件到100个字节。&lt;br/&gt;    // 如果文件本来就少于100个字节，则文件中原始内容得以保留，剩余的字节以null字节填充。&lt;br/&gt;    // 如果文件本来超过100个字节，则超过的字节会被抛弃。&lt;br/&gt;    // 这样我们总是得到精确的100个字节的文件。&lt;br/&gt;    // 传入0则会清空文件。&lt;br/&gt;&lt;br/&gt;    err := os.Truncate(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, 100)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;获取文件信息&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;var (&lt;br/&gt;    fileInfo os.FileInfo&lt;br/&gt;    err      error&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 如果文件不存在，则返回错误&lt;br/&gt;    fileInfo, err = os.Stat(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;File name:&quot;&lt;/span&gt;, fileInfo.Name())&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Size in bytes:&quot;&lt;/span&gt;, fileInfo.Size())&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Permissions:&quot;&lt;/span&gt;, fileInfo.Mode())&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Last modified:&quot;&lt;/span&gt;, fileInfo.ModTime())&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Is Directory: &quot;&lt;/span&gt;, fileInfo.IsDir())&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;System interface type: %T\n&quot;&lt;/span&gt;, fileInfo.Sys())&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;System info: %+v\n\n&quot;&lt;/span&gt;, fileInfo.Sys())&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重命名和移动&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    originalPath := &lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;&lt;br/&gt;    newPath := &lt;span&gt;&quot;test2.txt&quot;&lt;/span&gt;&lt;br/&gt;    err := os.Rename(originalPath, newPath)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;删除文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    err := os.Remove(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;打开和关闭文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 简单地以只读的方式打开。下面的例子会介绍读写的例子。&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    file.Close()&lt;br/&gt;&lt;br/&gt;    // OpenFile提供更多的选项。&lt;br/&gt;    // 最后一个参数是权限模式permission mode&lt;br/&gt;    // 第二个是打开时的属性    &lt;br/&gt;    file, err = os.OpenFile(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, os.O_APPEND, 0666)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    file.Close()&lt;br/&gt;&lt;br/&gt;    // 下面的属性可以单独使用，也可以组合使用。&lt;br/&gt;    // 组合使用时可以使用 OR 操作设置 OpenFile的第二个参数，例如：&lt;br/&gt;    // os.O_CREATE|os.O_APPEND&lt;br/&gt;    // 或者 os.O_CREATE|os.O_TRUNC|os.O_WRONLY&lt;br/&gt;&lt;br/&gt;    // os.O_RDONLY // 只读&lt;br/&gt;    // os.O_WRONLY // 只写&lt;br/&gt;    // os.O_RDWR // 读写&lt;br/&gt;    // os.O_APPEND // 往文件中添建（Append）&lt;br/&gt;    // os.O_CREATE // 如果文件不存在则先创建&lt;br/&gt;    // os.O_TRUNC // 文件打开时裁剪文件&lt;br/&gt;    // os.O_EXCL // 和O_CREATE一起使用，文件不能存在&lt;br/&gt;    // os.O_SYNC // 以同步I/O的方式打开&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;检查文件是否存在&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;var (&lt;br/&gt;    fileInfo *os.FileInfo&lt;br/&gt;    err      error&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 文件不存在则返回error&lt;br/&gt;    fileInfo, err := os.Stat(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; os.IsNotExist(err) {&lt;br/&gt;            log.Fatal(&lt;span&gt;&quot;File does not exist.&quot;&lt;/span&gt;)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    log.Println(&lt;span&gt;&quot;File does exist. File information:&quot;&lt;/span&gt;)&lt;br/&gt;    log.Println(fileInfo)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;检查读写权限&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 这个例子测试写权限，如果没有写权限则返回error。&lt;br/&gt;    // 注意文件不存在也会返回error，需要检查error的信息来获取到底是哪个错误导致。&lt;br/&gt;    file, err := os.OpenFile(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, os.O_WRONLY, 0666)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; os.IsPermission(err) {&lt;br/&gt;            log.Println(&lt;span&gt;&quot;Error: Write permission denied.&quot;&lt;/span&gt;)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    file.Close()&lt;br/&gt;&lt;br/&gt;    // 测试读权限&lt;br/&gt;    file, err = os.OpenFile(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, os.O_RDONLY, 0666)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; os.IsPermission(err) {&lt;br/&gt;            log.Println(&lt;span&gt;&quot;Error: Read permission denied.&quot;&lt;/span&gt;)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    file.Close()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;改变权限、拥有者、时间戳&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 使用Linux风格改变文件权限&lt;br/&gt;    err := os.Chmod(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, 0777)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Println(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 改变文件所有者&lt;br/&gt;    err = os.Chown(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, os.Getuid(), os.Getgid())&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Println(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 改变时间戳&lt;br/&gt;    twoDaysFromNow := time.Now().Add(48 * time.Hour)&lt;br/&gt;    lastAccessTime := twoDaysFromNow&lt;br/&gt;    lastModifyTime := twoDaysFromNow&lt;br/&gt;    err = os.Chtimes(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, lastAccessTime, lastModifyTime)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Println(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;创建硬链接和软链接&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个普通的文件是一个指向硬盘的inode的地方。硬链接创建一个新的指针指向同一个地方。只有所有的链接被删除后文件才会被删除。硬链接只在相同的文件系统中才工作。你可以认为一个硬链接是一个正常的链接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;symbolic link，又叫软连接，和硬链接有点不一样，它不直接指向硬盘中的相同的地方，而是通过名字引用其它文件。他们可以指向不同的文件系统中的不同文件。并不是所有的操作系统都支持软链接。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 创建一个硬链接。&lt;br/&gt;    // 创建后同一个文件内容会有两个文件名，改变一个文件的内容会影响另一个。&lt;br/&gt;    // 删除和重命名不会影响另一个。&lt;br/&gt;    err := os.Link(&lt;span&gt;&quot;original.txt&quot;&lt;/span&gt;, &lt;span&gt;&quot;original_also.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;creating sym&quot;&lt;/span&gt;)&lt;br/&gt;    // Create a symlink&lt;br/&gt;    err = os.Symlink(&lt;span&gt;&quot;original.txt&quot;&lt;/span&gt;, &lt;span&gt;&quot;original_sym.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // Lstat返回一个文件的信息，但是当文件是一个软链接时，它返回软链接的信息，而不是引用的文件的信息。&lt;br/&gt;    // Symlink在Windows中不工作。&lt;br/&gt;    fileInfo, err := os.Lstat(&lt;span&gt;&quot;original_sym.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Link info: %+v&quot;&lt;/span&gt;, fileInfo)&lt;br/&gt;&lt;br/&gt;    //改变软链接的拥有者不会影响原始文件。&lt;br/&gt;    err = os.Lchown(&lt;span&gt;&quot;original_sym.txt&quot;&lt;/span&gt;, os.Getuid(), os.Getgid())&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;文件读写&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;复制文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 打开原始文件&lt;br/&gt;    originalFile, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer originalFile.Close()&lt;br/&gt;&lt;br/&gt;    // 创建新的文件作为目标文件&lt;br/&gt;    newFile, err := os.Create(&lt;span&gt;&quot;test_copy.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer newFile.Close()&lt;br/&gt;&lt;br/&gt;    // 从源中复制字节到目标文件&lt;br/&gt;    bytesWritten, err := io.Copy(newFile, originalFile)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Copied %d bytes.&quot;&lt;/span&gt;, bytesWritten)&lt;br/&gt;&lt;br/&gt;    // 将文件内容flush到硬盘中&lt;br/&gt;    err = newFile.Sync()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;跳转到文件指定位置(Seek)&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    file, _ := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    defer file.Close()&lt;br/&gt;&lt;br/&gt;    // 偏离位置，可以是正数也可以是负数&lt;br/&gt;    var offset int64 = 5&lt;br/&gt;&lt;br/&gt;    // 用来计算offset的初始位置&lt;br/&gt;    // 0 = 文件开始位置&lt;br/&gt;    // 1 = 当前位置&lt;br/&gt;    // 2 = 文件结尾处&lt;br/&gt;    var &lt;span&gt;whence&lt;/span&gt; int = 0&lt;br/&gt;    newPosition, err := file.Seek(offset, &lt;span&gt;whence&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Just moved to 5:&quot;&lt;/span&gt;, newPosition)&lt;br/&gt;&lt;br/&gt;    // 从当前位置回退两个字节&lt;br/&gt;    newPosition, err = file.Seek(-2, 1)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Just moved back two:&quot;&lt;/span&gt;, newPosition)&lt;br/&gt;&lt;br/&gt;    // 使用下面的技巧得到当前的位置&lt;br/&gt;    currentPosition, err := file.Seek(0, 1)&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Current position:&quot;&lt;/span&gt;, currentPosition)&lt;br/&gt;&lt;br/&gt;    // 转到文件开始处&lt;br/&gt;    newPosition, err = file.Seek(0, 0)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Position after seeking 0,0:&quot;&lt;/span&gt;, newPosition)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;写文件&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用&lt;code&gt;os&lt;/code&gt;包写入一个打开的文件。因为Go可执行包是静态链接的可执行文件，你import的每一个包都会增加你的可执行文件的大小。其它的包如&lt;code&gt;io&lt;/code&gt;、｀ioutil｀、｀bufio｀提供了一些方法，但是它们不是必须的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 可写方式打开文件&lt;br/&gt;    file, err := os.OpenFile(&lt;br/&gt;        &lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;,&lt;br/&gt;        os.O_WRONLY|os.O_TRUNC|os.O_CREATE,&lt;br/&gt;        0666,&lt;br/&gt;    )&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer file.Close()&lt;br/&gt;&lt;br/&gt;    // 写字节到文件中&lt;br/&gt;    byteSlice := []byte(&lt;span&gt;&quot;Bytes!\n&quot;&lt;/span&gt;)&lt;br/&gt;    bytesWritten, err := file.Write(byteSlice)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Wrote %d bytes.\n&quot;&lt;/span&gt;, bytesWritten)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;快写文件&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ioutil&lt;/code&gt;包有一个非常有用的方法&lt;code&gt;WriteFile()&lt;/code&gt;可以处理创建或者打开文件、写入字节切片和关闭文件一系列的操作。如果你需要简洁快速地写字节切片到文件中，你可以使用它。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;io/ioutil&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    err := ioutil.WriteFile(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, []byte(&lt;span&gt;&quot;Hi\n&quot;&lt;/span&gt;), 0666)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用缓存写&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;bufio&lt;/code&gt;包提供了带缓存功能的writer，所以你可以在写字节到硬盘前使用内存缓存。当你处理很多的数据很有用，因为它可以节省操作硬盘I/O的时间。在其它一些情况下它也很有用，比如你每次写一个字节，把它们攒在内存缓存中，然后一次写入到硬盘中，减少硬盘的磨损以及提升性能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;bufio&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 打开文件，只写&lt;br/&gt;    file, err := os.OpenFile(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, os.O_WRONLY, 0666)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer file.Close()&lt;br/&gt;&lt;br/&gt;    // 为这个文件创建buffered writer&lt;br/&gt;    bufferedWriter := bufio.NewWriter(file)&lt;br/&gt;&lt;br/&gt;    // 写字节到buffer&lt;br/&gt;    bytesWritten, err := bufferedWriter.Write(&lt;br/&gt;        []byte{65, 66, 67},&lt;br/&gt;    )&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Bytes written: %d\n&quot;&lt;/span&gt;, bytesWritten)&lt;br/&gt;&lt;br/&gt;    // 写字符串到buffer&lt;br/&gt;    // 也可以使用 WriteRune() 和 WriteByte()   &lt;br/&gt;    bytesWritten, err = bufferedWriter.WriteString(&lt;br/&gt;        &lt;span&gt;&quot;Buffered string\n&quot;&lt;/span&gt;,&lt;br/&gt;    )&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Bytes written: %d\n&quot;&lt;/span&gt;, bytesWritten)&lt;br/&gt;&lt;br/&gt;    // 检查缓存中的字节数&lt;br/&gt;    unflushedBufferSize := bufferedWriter.Buffered()&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Bytes buffered: %d\n&quot;&lt;/span&gt;, unflushedBufferSize)&lt;br/&gt;&lt;br/&gt;    // 还有多少字节可用（未使用的缓存大小）&lt;br/&gt;    bytesAvailable := bufferedWriter.Available()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Available buffer: %d\n&quot;&lt;/span&gt;, bytesAvailable)&lt;br/&gt;&lt;br/&gt;    // 写内存buffer到硬盘&lt;br/&gt;    bufferedWriter.Flush()&lt;br/&gt;&lt;br/&gt;    // 丢弃还没有flush的缓存的内容，清除错误并把它的输出传给参数中的writer&lt;br/&gt;    // 当你想将缓存传给另外一个writer时有用&lt;br/&gt;    bufferedWriter.Reset(bufferedWriter)&lt;br/&gt;&lt;br/&gt;    bytesAvailable = bufferedWriter.Available()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Available buffer: %d\n&quot;&lt;/span&gt;, bytesAvailable)&lt;br/&gt;&lt;br/&gt;    // 重新设置缓存的大小。&lt;br/&gt;    // 第一个参数是缓存应该输出到哪里，这个例子中我们使用相同的writer。&lt;br/&gt;    // 如果我们设置的新的大小小于第一个参数writer的缓存大小， 比如10，我们不会得到一个10字节大小的缓存，&lt;br/&gt;    // 而是writer的原始大小的缓存，默认是4096。&lt;br/&gt;    // 它的功能主要还是为了扩容。&lt;br/&gt;    bufferedWriter = bufio.NewWriterSize(&lt;br/&gt;        bufferedWriter,&lt;br/&gt;        8000,&lt;br/&gt;    )&lt;br/&gt;&lt;br/&gt;    // resize后检查缓存的大小&lt;br/&gt;    bytesAvailable = bufferedWriter.Available()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Available buffer: %d\n&quot;&lt;/span&gt;, bytesAvailable)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;读取最多N个字节&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;os.File&lt;/code&gt;提供了文件操作的基本功能， 而&lt;code&gt;io&lt;/code&gt;、&lt;code&gt;ioutil&lt;/code&gt;、&lt;code&gt;bufio&lt;/code&gt;提供了额外的辅助函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 打开文件，只读&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer file.Close()&lt;br/&gt;&lt;br/&gt;    // 从文件中读取len(b)字节的文件。&lt;br/&gt;    // 返回0字节意味着读取到文件尾了&lt;br/&gt;    // 读取到文件会返回io.EOF的error&lt;br/&gt;    byteSlice := make([]byte, 16)&lt;br/&gt;    bytesRead, err := file.Read(byteSlice)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Number of bytes read: %d\n&quot;&lt;/span&gt;, bytesRead)&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Data read: %s\n&quot;&lt;/span&gt;, byteSlice)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;读取正好N个字节&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // Open file &lt;span&gt;for&lt;/span&gt; reading&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // file.Read()可以读取一个小文件到大的byte slice中，&lt;br/&gt;    // 但是io.ReadFull()在文件的字节数小于byte slice字节数的时候会返回错误&lt;br/&gt;    byteSlice := make([]byte, 2)&lt;br/&gt;    numBytesRead, err := io.ReadFull(file, byteSlice)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Number of bytes read: %d\n&quot;&lt;/span&gt;, numBytesRead)&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Data read: %s\n&quot;&lt;/span&gt;, byteSlice)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;读取至少N个字节&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 打开文件，只读&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    byteSlice := make([]byte, 512)&lt;br/&gt;    minBytes := 8&lt;br/&gt;    // io.ReadAtLeast()在不能得到最小的字节的时候会返回错误，但会把已读的文件保留&lt;br/&gt;    numBytesRead, err := io.ReadAtLeast(file, byteSlice, minBytes)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Number of bytes read: %d\n&quot;&lt;/span&gt;, numBytesRead)&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Data read: %s\n&quot;&lt;/span&gt;, byteSlice)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;读取全部字节&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io/ioutil&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // os.File.Read(), io.ReadFull() 和&lt;br/&gt;    // io.ReadAtLeast() 在读取之前都需要一个固定大小的byte slice。&lt;br/&gt;    // 但ioutil.ReadAll()会读取reader(这个例子中是file)的每一个字节，然后把字节slice返回。&lt;br/&gt;    data, err := ioutil.ReadAll(file)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Data as hex: %x\n&quot;&lt;/span&gt;, data)&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Data as string: %s\n&quot;&lt;/span&gt;, data)&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Number of bytes read:&quot;&lt;/span&gt;, len(data))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;快读到内存&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io/ioutil&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 读取文件到byte slice中&lt;br/&gt;    data, err := ioutil.ReadFile(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Data read: %s\n&quot;&lt;/span&gt;, data)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用缓存读&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有缓存写也有缓存读。缓存reader会把一些内容缓存在内存中。它会提供比&lt;code&gt;os.File&lt;/code&gt;和&lt;code&gt;io.Reader&lt;/code&gt;更多的函数,缺省的缓存大小是4096，最小缓存是16。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;bufio&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 打开文件，创建buffered reader&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    bufferedReader := bufio.NewReader(file)&lt;br/&gt;&lt;br/&gt;    // 得到字节，当前指针不变&lt;br/&gt;    byteSlice := make([]byte, 5)&lt;br/&gt;    byteSlice, err = bufferedReader.Peek(5)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Peeked at 5 bytes: %s\n&quot;&lt;/span&gt;, byteSlice)&lt;br/&gt;&lt;br/&gt;    // 读取，指针同时移动&lt;br/&gt;    numBytesRead, err := bufferedReader.Read(byteSlice)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Read %d bytes: %s\n&quot;&lt;/span&gt;, numBytesRead, byteSlice)&lt;br/&gt;&lt;br/&gt;    // 读取一个字节, 如果读取不成功会返回Error&lt;br/&gt;    myByte, err := bufferedReader.ReadByte()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Read 1 byte: %c\n&quot;&lt;/span&gt;, myByte)     &lt;br/&gt;&lt;br/&gt;    // 读取到分隔符，包含分隔符，返回byte slice&lt;br/&gt;    dataBytes, err := bufferedReader.ReadBytes(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Read bytes: %s\n&quot;&lt;/span&gt;, dataBytes)           &lt;br/&gt;&lt;br/&gt;    // 读取到分隔符，包含分隔符，返回字符串&lt;br/&gt;    dataString, err := bufferedReader.ReadString(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Read string: %s\n&quot;&lt;/span&gt;, dataString)     &lt;br/&gt;&lt;br/&gt;    //这个例子读取了很多行，所以test.txt应该包含多行文本才不至于出错&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用 scanner&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Scanner&lt;/code&gt;是&lt;code&gt;bufio&lt;/code&gt;包下的类型,在处理文件中以分隔符分隔的文本时很有用。通常我们使用换行符作为分隔符将文件内容分成多行。在CSV文件中，逗号一般作为分隔符。&lt;code&gt;os.File&lt;/code&gt;文件可以被包装成&lt;code&gt;bufio.Scanner&lt;/code&gt;，它就像一个缓存reader。我们会调用&lt;code&gt;Scan()&lt;/code&gt;方法去读取下一个分隔符，使用&lt;code&gt;Text()&lt;/code&gt;或者&lt;code&gt;Bytes()&lt;/code&gt;获取读取的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分隔符可以不是一个简单的字节或者字符，有一个特殊的方法可以实现分隔符的功能，以及将指针移动多少，返回什么数据。如果没有定制的&lt;code&gt;SplitFunc&lt;/code&gt;提供，缺省的&lt;code&gt;ScanLines&lt;/code&gt;会使用&lt;code&gt;newline&lt;/code&gt;字符作为分隔符，其它的分隔函数还包括&lt;code&gt;ScanRunes&lt;/code&gt;和&lt;code&gt;ScanWords&lt;/code&gt;,皆在&lt;code&gt;bufio&lt;/code&gt;包中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// To define your own split &lt;span&gt;function&lt;/span&gt;, match this fingerprint&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)&lt;br/&gt;&lt;br/&gt;// Returning (0, nil, nil) will tell the scanner&lt;br/&gt;// to scan again, but with a bigger buffer because&lt;br/&gt;// it wasn&lt;span&gt;&#x27;t enough data to reach the delimiter&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面的例子中，为一个文件创建了&lt;code&gt;bufio.Scanner&lt;/code&gt;，并按照单词逐个读取：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;bufio&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    scanner := bufio.NewScanner(file)&lt;br/&gt;&lt;br/&gt;    // 缺省的分隔函数是bufio.ScanLines,我们这里使用ScanWords。&lt;br/&gt;    // 也可以定制一个SplitFunc类型的分隔函数&lt;br/&gt;    scanner.Split(bufio.ScanWords)&lt;br/&gt;&lt;br/&gt;    // scan下一个token.&lt;br/&gt;    success := scanner.Scan()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; success == &lt;span&gt;false&lt;/span&gt; {&lt;br/&gt;        // 出现错误或者EOF是返回Error&lt;br/&gt;        err = scanner.Err()&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; err == nil {&lt;br/&gt;            log.Println(&lt;span&gt;&quot;Scan completed and reached EOF&quot;&lt;/span&gt;)&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            log.Fatal(err)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 得到数据，Bytes() 或者 Text()&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;First word found:&quot;&lt;/span&gt;, scanner.Text())&lt;br/&gt;&lt;br/&gt;    // 再次调用scanner.Scan()发现下一个token&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;文件压缩&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;打包(zip) 文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// This example uses zip but standard library&lt;br/&gt;// also supports tar archives&lt;br/&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;archive/zip&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 创建一个打包文件&lt;br/&gt;    outFile, err := os.Create(&lt;span&gt;&quot;test.zip&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer outFile.Close()&lt;br/&gt;&lt;br/&gt;    // 创建zip writer&lt;br/&gt;    zipWriter := zip.NewWriter(outFile)&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    // 往打包文件中写文件。&lt;br/&gt;    // 这里我们使用硬编码的内容，你可以遍历一个文件夹，把文件夹下的文件以及它们的内容写入到这个打包文件中。&lt;br/&gt;    var filesToArchive = []struct {&lt;br/&gt;        Name, Body string&lt;br/&gt;    } {&lt;br/&gt;        {&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, &lt;span&gt;&quot;String contents of file&quot;&lt;/span&gt;},&lt;br/&gt;        {&lt;span&gt;&quot;test2.txt&quot;&lt;/span&gt;, &lt;span&gt;&quot;\x61\x62\x63\n&quot;&lt;/span&gt;},&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 下面将要打包的内容写入到打包文件中，依次写入。&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; _, file := range filesToArchive {&lt;br/&gt;            fileWriter, err := zipWriter.Create(file.Name)&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;                    log.Fatal(err)&lt;br/&gt;            }&lt;br/&gt;            _, err = fileWriter.Write([]byte(file.Body))&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;                    log.Fatal(err)&lt;br/&gt;            }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 清理&lt;br/&gt;    err = zipWriter.Close()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;            log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;抽取(unzip) 文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// This example uses zip but standard library&lt;br/&gt;// also supports tar archives&lt;br/&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;archive/zip&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;path/filepath&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    zipReader, err := zip.OpenReader(&lt;span&gt;&quot;test.zip&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer zipReader.Close()&lt;br/&gt;&lt;br/&gt;    // 遍历打包文件中的每一文件/文件夹&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; _, file := range zipReader.Reader.File {&lt;br/&gt;        // 打包文件中的文件就像普通的一个文件对象一样&lt;br/&gt;        zippedFile, err := file.Open()&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;            log.Fatal(err)&lt;br/&gt;        }&lt;br/&gt;        defer zippedFile.Close()&lt;br/&gt;&lt;br/&gt;        // 指定抽取的文件名。&lt;br/&gt;        // 你可以指定全路径名或者一个前缀，这样可以把它们放在不同的文件夹中。&lt;br/&gt;        // 我们这个例子使用打包文件中相同的文件名。&lt;br/&gt;        targetDir := &lt;span&gt;&quot;./&quot;&lt;/span&gt;&lt;br/&gt;        extractedFilePath := filepath.Join(&lt;br/&gt;            targetDir,&lt;br/&gt;            file.Name,&lt;br/&gt;        )&lt;br/&gt;&lt;br/&gt;        // 抽取项目或者创建文件夹&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; file.FileInfo().&lt;span&gt;&lt;span&gt;IsDir&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            // 创建文件夹并设置同样的权限&lt;br/&gt;            log.Println(&lt;span&gt;&quot;Creating directory:&quot;&lt;/span&gt;, extractedFilePath)&lt;br/&gt;            os.MkdirAll(extractedFilePath, file.Mode())&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            //抽取正常的文件&lt;br/&gt;            log.Println(&lt;span&gt;&quot;Extracting file:&quot;&lt;/span&gt;, file.Name)&lt;br/&gt;&lt;br/&gt;            outputFile, err := os.OpenFile(&lt;br/&gt;                extractedFilePath,&lt;br/&gt;                os.O_WRONLY|os.O_CREATE|os.O_TRUNC,&lt;br/&gt;                file.Mode(),&lt;br/&gt;            )&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;                log.Fatal(err)&lt;br/&gt;            }&lt;br/&gt;            defer outputFile.Close()&lt;br/&gt;&lt;br/&gt;            // 通过io.Copy简洁地复制文件内容&lt;br/&gt;            _, err = io.Copy(outputFile, zippedFile)&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;                log.Fatal(err)&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;压缩文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 这个例子中使用gzip压缩格式，标准库还支持zlib, bz2, flate, lzw&lt;br/&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;compress/gzip&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    outputFile, err := os.Create(&lt;span&gt;&quot;test.txt.gz&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    gzipWriter := gzip.NewWriter(outputFile)&lt;br/&gt;    defer gzipWriter.Close()&lt;br/&gt;&lt;br/&gt;    // 当我们写如到gizp writer数据时，它会依次压缩数据并写入到底层的文件中。&lt;br/&gt;    // 我们不必关心它是如何压缩的，还是像普通的writer一样操作即可。&lt;br/&gt;    _, err = gzipWriter.Write([]byte(&lt;span&gt;&quot;Gophers rule!\n&quot;&lt;/span&gt;))&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    log.Println(&lt;span&gt;&quot;Compressed data written to file.&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解压缩文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 这个例子中使用gzip压缩格式，标准库还支持zlib, bz2, flate, lzw&lt;br/&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;compress/gzip&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 打开一个gzip文件。&lt;br/&gt;    // 文件是一个reader,但是我们可以使用各种数据源，比如web服务器返回的gzipped内容，&lt;br/&gt;    // 它的内容不是一个文件，而是一个内存流&lt;br/&gt;    gzipFile, err := os.Open(&lt;span&gt;&quot;test.txt.gz&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    gzipReader, err := gzip.NewReader(gzipFile)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer gzipReader.Close()&lt;br/&gt;&lt;br/&gt;    // 解压缩到一个writer,它是一个file writer&lt;br/&gt;    outfileWriter, err := os.Create(&lt;span&gt;&quot;unzipped.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer outfileWriter.Close()&lt;br/&gt;&lt;br/&gt;    // 复制内容&lt;br/&gt;    _, err = io.Copy(outfileWriter, gzipReader)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;文件其它操作&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;临时文件和目录&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ioutil&lt;/code&gt;提供了两个函数: &lt;code&gt;TempDir()&lt;/code&gt; 和 &lt;code&gt;TempFile()&lt;/code&gt;。使用完毕后，调用者负责删除这些临时文件和文件夹。有一点好处就是当你传递一个空字符串作为文件夹名的时候，它会在操作系统的临时文件夹中创建这些项目（/tmp on Linux）。&lt;code&gt;os.TempDir()&lt;/code&gt;返回当前操作系统的临时文件夹。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;     &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&quot;io/ioutil&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;     // 在系统临时文件夹中创建一个临时文件夹&lt;br/&gt;     tempDirPath, err := ioutil.TempDir(&lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;myTempDir&quot;&lt;/span&gt;)&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;          log.Fatal(err)&lt;br/&gt;     }&lt;br/&gt;     fmt.Println(&lt;span&gt;&quot;Temp dir created:&quot;&lt;/span&gt;, tempDirPath)&lt;br/&gt;&lt;br/&gt;     // 在临时文件夹中创建临时文件&lt;br/&gt;     tempFile, err := ioutil.TempFile(tempDirPath, &lt;span&gt;&quot;myTempFile.txt&quot;&lt;/span&gt;)&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;          log.Fatal(err)&lt;br/&gt;     }&lt;br/&gt;     fmt.Println(&lt;span&gt;&quot;Temp file created:&quot;&lt;/span&gt;, tempFile.Name())&lt;br/&gt;&lt;br/&gt;     // ... 做一些操作 ...&lt;br/&gt;&lt;br/&gt;     // 关闭文件&lt;br/&gt;     err = tempFile.Close()&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 删除我们创建的资源&lt;br/&gt;     err = os.Remove(tempFile.Name())&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;     err = os.Remove(tempDirPath)&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;通过HTTP下载文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;     &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&quot;net/http&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;     newFile, err := os.Create(&lt;span&gt;&quot;devdungeon.html&quot;&lt;/span&gt;)&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;          log.Fatal(err)&lt;br/&gt;     }&lt;br/&gt;     defer newFile.Close()&lt;br/&gt;&lt;br/&gt;     url := &lt;span&gt;&quot;http://www.devdungeon.com/archive&quot;&lt;/span&gt;&lt;br/&gt;     response, err := http.Get(url)&lt;br/&gt;     defer response.Body.Close()&lt;br/&gt;&lt;br/&gt;     // 将HTTP response Body中的内容写入到文件&lt;br/&gt;     // Body满足reader接口，因此我们可以使用ioutil.Copy&lt;br/&gt;     numBytesWritten, err := io.Copy(newFile, response.Body)&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;          log.Fatal(err)&lt;br/&gt;     }&lt;br/&gt;     log.Printf(&lt;span&gt;&quot;Downloaded %d byte file.\n&quot;&lt;/span&gt;, numBytesWritten)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;哈希和摘要&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;crypto/md5&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;crypto/sha1&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;crypto/sha256&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;crypto/sha512&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io/ioutil&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 得到文件内容&lt;br/&gt;    data, err := ioutil.ReadFile(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 计算Hash&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Md5: %x\n\n&quot;&lt;/span&gt;, md5.Sum(data))&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Sha1: %x\n\n&quot;&lt;/span&gt;, sha1.Sum(data))&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Sha256: %x\n\n&quot;&lt;/span&gt;, sha256.Sum256(data))&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Sha512: %x\n\n&quot;&lt;/span&gt;, sha512.Sum512(data))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的例子复制整个文件内容到内存中，传递给hash函数。另一个方式是创建一个hash writer, 使用&lt;code&gt;Write&lt;/code&gt;、&lt;code&gt;WriteString&lt;/code&gt;、&lt;code&gt;Copy&lt;/code&gt;将数据传给它。下面的例子使用 md5 hash,但你可以使用其它的Writer。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;crypto/md5&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer file.Close()&lt;br/&gt;&lt;br/&gt;    //创建一个新的hasher,满足writer接口&lt;br/&gt;    hasher := md5.New()&lt;br/&gt;    _, err = io.Copy(hasher, file)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 计算&lt;span&gt;hash&lt;/span&gt;并打印结果。&lt;br/&gt;    // 传递 nil 作为参数，因为我们不通参数传递数据，而是通过writer接口。&lt;br/&gt;    sum := hasher.Sum(nil)&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Md5 checksum: %x\n&quot;&lt;/span&gt;, sum)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注公众号，获取更多精选技术原创文章&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0188679245283019&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;318&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4icJbGAQ8RjXUUVdUZsGADuMBVWePgn7tfrWjjHyc6b8kXTQ7Sdkp0QQFFK4mel5tniczqooMna1CA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>106154ad048f87c40f8ce3cf253e633f</guid>
<title>工具 | Ant Design Pro 的 Vue 实现版本</title>
<link>https://toutiao.io/k/qqcei25</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>393c68919b18c7d59f353b87fffad6ba</guid>
<title>线上发生死锁异常了，该怎么办</title>
<link>https://toutiao.io/k/41hxqdd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;点击上方&quot;&lt;span&gt;程序员历小冰&lt;/span&gt;&quot;，选择“置顶或者星标”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;   你的关注意义重大!&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n103&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;MySQL 死锁异常是我们经常会遇到的线上异常类别，一旦线上业务日间复杂，各种业务操作之间往往会产生锁冲突，有些会导致死锁异常。这种死锁异常一般要在特定时间特定数据和特定业务操作才会复现，并且分析解决时还需要了解 MySQL 锁冲突相关知识，所以一般遇到这些偶尔出现的死锁异常，往往一时没有头绪，不好处理。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n99&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n101&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;本篇文章会讲解一下如果线上发生了死锁异常，如何去排查和处理。除了系列前文讲解的有关加锁和锁冲突的原理还，还需要对 MySQl 死锁日志和 binlog 日志进行分析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5179372197309418&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMteYT3ZLt0C76sicvu7Gp54h8peBdIVibHEMeCQhmcbZsOSkeXLBy04U29KgEo0Cy1Lyjfrj6qsVVCEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;446&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n165&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;日常工作中，应对各类线上异常都要有我们自己的 SOP (标准作业流程) &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; ，这样不仅能够提高自己的处理问题效率，也有助于将好的处理流程推广到团队，提高团队的整体处理异常能力。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n124&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;所以，面对线上偶发的 MySQL 死锁问题，我的排查处理过程如下：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; cid=&quot;n172&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n175&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;线上错误日志报警发现死锁异常&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;2&quot; cid=&quot;n151&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n177&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;查看错误日志的堆栈信息&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;3&quot; cid=&quot;n145&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n179&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;查看 MySQL 死锁相关的日志&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;4&quot; cid=&quot;n148&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n181&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;根据 binlog 查看死锁相关事务的执行内容&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;5&quot; cid=&quot;n154&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n183&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;根据上述信息找出两个相互死锁的事务执行的 SQL 操作，根据本系列介绍的锁相关理论知识，进行分析推断死锁原因&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;6&quot; cid=&quot;n161&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n185&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;修改业务代码&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n15&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n315&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;根据1，2步骤可以找到死锁异常时进行回滚事务的具体业务，也就能够找到该事务执行的 SQL 语句。然后我们需要通过 3，4步骤找到死锁异常时另外一个事务，也就是最终获得锁的事务所执行的 SQL 语句，然后再进行锁冲突相关的分析。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n311&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;第一二步的线上错误日志和堆栈信息一般比较容易获得，第五步的分析 SQL 锁冲突原因中涉及的锁相关的理论在系列文章中都有介绍，没有了解的同学可以自行去阅读以下。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n309&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;下面我们就来重点说一下其中的第三四步骤，也就是如何查看死锁日志和 binlog 日志来找到死锁相关的 SQL 操作。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;死锁日志的获取&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n195&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;发生死锁异常后，我们可以直接使用 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;show engine innodb status&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 命令获取死锁信息，但是该命令只能获取最近一次的死锁信息。所以，我们可以通过开启 InnoDB 的监控机制来获取实时的死锁信息，它会周期性（每隔 15 秒）打印 InnoDb 的运行状态到 mysqld 服务的错误日志文件中。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n213&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;InnoDb 的监控较为重要的有标准监控（Standard InnoDB Monitor）和 锁监控（InnoDB Lock Monitor），通过对应的系统参数可以将其开启。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5561224489795918&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMteYT3ZLt0C76sicvu7Gp54h8omV1N6csq3fjV5q1jTn3zLGuUia5q6xzoHEichsphcAuic5G6KCBfq0ibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;392&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n208&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;另外，MySQL 提供了一个系统参数 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;innodb_print_all_deadlocks&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 专门用于记录死锁日志，当发生死锁时，死锁日志会记录到 MySQL 的错误日志文件中。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n213&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;另外，MySQL 提供了一个系统参数 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;innodb_print_all_deadlocks&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 专门用于记录死锁日志，当发生死锁时，死锁日志会记录到 MySQL 的错误日志文件中。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n208&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;/&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n209&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;set GLOBAL innodb_print_all_deadlocks=ON;&lt;/span&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;死锁日志的分析&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n230&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;通过上述手段，我们可以拿到死锁日志，下图是我做实验触发死锁异常时获取的日志(省略的部分信息)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.634765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMteYT3ZLt0C76sicvu7Gp54h8CIdNaGdw3RIuqDaTf7ctSvEibgsfJMlvrlnrcAHp5ANwVGoRCFc1h2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p mdtype=&quot;paragraph&quot; cid=&quot;n20&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;该日志会列出死锁发生的时间，死锁相关的事务，并显示出两个事务(可惜，多事务发生死锁时，也只显示两个事务)在&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;发生死锁时执行的 SQL 语句、持有或等待的锁信息和最终回滚的事务&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n234&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;下面，我们来一段一段的解读该日志中给出的信息，我们按照图中标注的顺序来介绍：&lt;/span&gt;&lt;/p&gt;&lt;pre mdtype=&quot;fences&quot; cid=&quot;n256&quot; lang=&quot;bash&quot; spellcheck=&quot;false&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;TRANSACTION &lt;span&gt;2078&lt;/span&gt;, ACTIVE &lt;span&gt;74&lt;/span&gt; sec starting index read // &lt;span&gt;-1&lt;/span&gt; 事务一的基础信息，包括事务ID、活跃时间，当前运行状态&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n259&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;表示的是 ACTIVE 74 sec 表示事务活动时间，starting index read 为事务当前正在运行的状态，可能的事务状态有：fetching rows，updating，deleting，inserting, starting index read 等状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.12222222222222222&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMteYT3ZLt0C76sicvu7Gp54h8QYIHUiaWE5OUMyTMBk6jzJHiacoD7j3RQIAnz7Y00TicacoZwR6hSUzMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n263&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;其中第一行，tables in use 1 表示有一个表被使用，locked 1 表示有一个表锁。第二行中的 LOCK WAIT 表示事务正在等待锁，3 lock struct(s) 表示该事务的锁链表的长度为 3，每个链表节点代表该事务持有的一个锁结构，包括表锁，记录锁或 autoinc 锁等。heap size 1136 为事务分配的锁堆内存大小。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n273&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;第二行后半段中，2 row lock(s) 表示当前事务持有的行锁个数，通过遍历上面提到的 11 个锁结构，找出其中类型为 LOCK_REC 的记录数。undo log entries 1 表示当前事务有 1 个 undo log 记录，说明该事务已经更新了 1条记录。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n238&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;下面就是死锁日志中最为重要的持有或者待获取锁信息，如图中-5和-6行所示，&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;通过它可以分析锁的具体类型和涉及的表，这些信息能辅助你按照系列文章的锁相关的知识来分析 SQL 的锁冲突&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.142578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMteYT3ZLt0C76sicvu7Gp54h82o0c5Akx5hX3IqexaiaD7iaXF4WdEwGPCkPmqY82iaoIDOJialomWPtNfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n288&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在 &lt;/span&gt;&lt;span md-inline=&quot;link&quot;&gt;&lt;a spellcheck=&quot;false&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2NjE5NDQyOA==&amp;amp;mid=2247483991&amp;amp;idx=1&amp;amp;sn=309b79caa7ac6df004747c8999c62c0f&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;《锁类型和加锁原理》&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 一文中我们说过，一共有四种类型的行锁：记录锁，间隙锁，Next-key 锁和插入意向锁。这四种锁对应的死锁日志各不相同，如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n289&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n291&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;记录锁（LOCK_REC_NOT_GAP）: lock_mode X locks rec but not gap&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n293&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;间隙锁（LOCK_GAP）: lock_mode X locks gap before rec&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n295&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Next-key 锁（LOCK_ORNIDARY）: lock_mode X&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n297&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;插入意向锁（LOCK_INSERT_INTENTION）: lock_mode X locks gap before rec insert intention&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n236&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;所以，按照死锁日志，我们发现事务一持有了 test.t 表上的记录锁，并且等待另一个记录锁。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n307&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n321&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;通过死锁日志，我们可以找到最终获得锁事务最后执行的 SQL，但是如果该事务执行了多条 SQL，这些信息就可能不够用的啦，我们需要完整的了解该事务所有执行的 SQL语句。这时，我们就需要从 binlog 日志中获取。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;binlog的获取和分析&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n24&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;binlog 日志会完整记录事务执行的所有 SQL，借助它，我们就能找到最终获取锁事务所执行的全部 SQL。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;然后再进行具体的锁冲突分析。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n327&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n330&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;我们可以使用 MySQL 的命令行工具 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;Mysqlbinlog&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 远程获取线上数据库的 binlog 日志。具体命令如下所示：&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;bash&quot; cid=&quot;n334&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;Mysqlbinlog &lt;span&gt;-h127&lt;/span&gt;.0.0.1 &lt;span&gt;-u&lt;/span&gt; root &lt;span&gt;-p&lt;/span&gt; &lt;span&gt;--read-from-remote-server&lt;/span&gt; binlog.000001 &lt;span&gt;--base64-output&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;decode-rows &lt;span&gt;-v&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n27&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;其中 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;--base64-output=decode-rows&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 表示 row 模式 binlog日志，所以该方法只适用于 row 模式的 binlog日志，但是目前主流 MySQL 运维也都是把 binlog 日志设置为 row 模式，所以这点限制也就无伤大雅。&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 则表示将行事件重构成被注释掉的伪SQL语句。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n345&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n368&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;我们可以&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;通过死锁日志中死锁发生的具体事件和最终获取锁事务正在执行的SQL的参数信息找到 binlog 中该事务的对应信息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;，比如我们可以直接通过死锁日志截图中的具体的时间 10点57分和 Tom1、Teddy2 等 SQL 的具体数据信息在 binlog 找到对应的位置，具体如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.58203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMteYT3ZLt0C76sicvu7Gp54h8a9iaLsOtZSniaSwSo33wZicqyKnzopEKTPZ3TMvYCqSC9HngPdibATicCBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n354&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;根据 binlog 的具体信息，我们可以清晰的找到最终获取锁事务所执行的所有 SQL 语句，也就能找到其对应的业务代码，接下来我们就能进行具体的锁冲突分析。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n378&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;死锁系列终于告一段落，如果大伙有什么疑问或者文中有什么错误，欢迎在下方留言讨论。也希望大家继续持续关注。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;-关注我&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5075921908893709&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtehL5KdOC0Uib7CdHkxwGibQdibjs4kC3FpEO9ehCCjHwFa1ZSS8QoEgb9AtomP8cDZmz8jC1gR8qvzg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;922&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;amp;mid=2247483766&amp;amp;idx=1&amp;amp;sn=3d5a23891a03c7394493d52adda2fdaf&amp;amp;chksm=fc04c516cb734c00e9412cc9f5d580dba45c08980c31e8bed305292dbe7781a7c4ac083f5f09&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;TCP/IP的底层队列&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;amp;mid=2247483788&amp;amp;idx=1&amp;amp;sn=e47726a14f622fc0015d9628838ad2fe&amp;amp;chksm=fc04c5eccb734cfad8de3b624e2e26f2ac6a6790508b212146ff9e1d97d5026870b1e5af021a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;基于Redis和Lua的分布式限流&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;amp;mid=2247483716&amp;amp;idx=1&amp;amp;sn=22e5160b1fb1068b262d1b0f4fcfc0a0&amp;amp;chksm=fc04c524cb734c327b823acd2cc3ea3ef8620ab2c6c0c1dc1ac6545904f1c3259afd4f2e7450&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;AbstractQueuedSynchronizer超详细原理解析&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>890f0ded3267abacc018d080867c592f</guid>
<title>服务器开发通信协议设计介绍</title>
<link>https://toutiao.io/k/fb8iwln</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5950782997762863&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TufFCFqd0g3KvXhOKYiaVDFSI6ISoJmVND9ONtbeVdVNCqpSUicKjJia14Btecic82XONfaEMuWXhYicsauuF5MoWaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;894&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;一、选择TCP还是UDP协议&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;由于我们的即时通讯软件的用户存在用户状态问题，即用户登录成功以后可以在他的好友列表中看到哪些好友在线，所以客户端和服务器需要保持长连接状态。另外即时通讯软件一般要求信息准确、有序、完整地到达对端，而这也是TCP协议的特点之一。综合这两个所以这里我们选择TCP协议，而不是UDP协议。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;二、协议的结构&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;由于TCP协议是流式协议，所谓流式协议即通讯的内容是无边界的字节流：如A给B连续发送了三个数据包，每个包的大小都是100个字节，那么B可能会一次性收到300个字节；也可能先收到100个字节，再收到200个字节；也可能先收到100个字节，再收到50个字节，再收到150个字节；或者先收到50个字节，再收到50个字节，再收到50个字节，最后收到150个字节。也就是说，B可能以任何组合形式收到这300个字节。即像水流一样无明确的边界。为了能让对端知道如何给包分界，目前一般有三种做法：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;以固定大小字节数目来分界，上文所说的就是属于这种类型，如每个包100个字节，对端每收齐100个字节，就当成一个包来解析；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;以特定符号来分界，如每个包都以特定的字符来结尾（如\n），当在字节流中读取到该字符时，则表明上一个包到此为止。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;固定包头+包体结构，这种结构中一般包头部分是一个固定字节长度的结构，并且包头中会有一个特定的字段指定包体的大小。这是目前各种网络应用用的最多的一种包格式。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;上面三种分包方式各有优缺点，方法1和方法2简单易操作，但是缺点也很明显，就是很不灵活，如方法一当包数据不足指定长度，只能使用占位符如0来凑，比较浪费；方法2中包中不能有包界定符，否则就会引起歧义，也就是要求包内容中不能有某些特殊符号。而方法3虽然解决了方法1和方法2的缺点，但是操作起来就比较麻烦。我们的即时通讯协议就采用第三种分包方式。所以我们的协议包的包头看起来像这样：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;package_header&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;    &lt;span&gt;int32_t&lt;/span&gt; bodysize;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个应用中，有许多的应用数据，拿我们这里的即时通讯来说，有注册、登录、获取好友列表、好友消息等各种各样的协议数据包，而每个包因为业务内容不一样可能数据内容也不一样，所以各个包可能看起来像下面这样：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;package_header&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;    &lt;span&gt;int32_t&lt;/span&gt; bodysize;&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;};&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;&lt;span&gt;//登录数据包&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;register_package&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;    package_header header;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;//命令号&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;    &lt;span&gt;int32_t&lt;/span&gt; cmd;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;    &lt;span&gt;//注册用户名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;    &lt;span&gt;char&lt;/span&gt; username[&lt;span&gt;16&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;    &lt;span&gt;//注册密码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;    &lt;span&gt;char&lt;/span&gt; password[&lt;span&gt;16&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;    &lt;span&gt;//注册昵称&lt;/span&gt;&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;    &lt;span&gt;char&lt;/span&gt; nickname[&lt;span&gt;16&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;    &lt;span&gt;//注册手机号&lt;/span&gt;&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;    &lt;span&gt;char&lt;/span&gt; mobileno[&lt;span&gt;16&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;};&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span&gt;22&lt;/span&gt;&lt;span&gt;//登录数据包&lt;/span&gt;&lt;br/&gt;&lt;span&gt;23&lt;/span&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;login_package&lt;/span&gt;&lt;br/&gt;&lt;span&gt;24&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;25&lt;/span&gt;    package_header header;&lt;br/&gt;&lt;span&gt;26&lt;/span&gt;    &lt;span&gt;//命令号&lt;/span&gt;&lt;br/&gt;&lt;span&gt;27&lt;/span&gt;    &lt;span&gt;int32_t&lt;/span&gt; cmd;&lt;br/&gt;&lt;span&gt;28&lt;/span&gt;    &lt;span&gt;//登录用户名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;29&lt;/span&gt;    &lt;span&gt;char&lt;/span&gt; username[&lt;span&gt;16&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;30&lt;/span&gt;    &lt;span&gt;//密码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;31&lt;/span&gt;    &lt;span&gt;char&lt;/span&gt; password[&lt;span&gt;16&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;32&lt;/span&gt;    &lt;span&gt;//客户端类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;33&lt;/span&gt;    &lt;span&gt;int32_t&lt;/span&gt; clienttype;&lt;br/&gt;&lt;span&gt;34&lt;/span&gt;    &lt;span&gt;//上线类型，如在线、隐身、忙碌、离开等&lt;/span&gt;&lt;br/&gt;&lt;span&gt;35&lt;/span&gt;    &lt;span&gt;int32_t&lt;/span&gt; onlinetype;&lt;br/&gt;&lt;span&gt;36&lt;/span&gt;};&lt;br/&gt;&lt;span&gt;37&lt;/span&gt;&lt;br/&gt;&lt;span&gt;38&lt;/span&gt;&lt;span&gt;//获取好友列表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;39&lt;/span&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;getfriend_package&lt;/span&gt;&lt;br/&gt;&lt;span&gt;40&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;41&lt;/span&gt;    package_header header;&lt;br/&gt;&lt;span&gt;42&lt;/span&gt;    &lt;span&gt;//命令号&lt;/span&gt;&lt;br/&gt;&lt;span&gt;43&lt;/span&gt;    &lt;span&gt;int32_t&lt;/span&gt; cmd;&lt;br/&gt;&lt;span&gt;44&lt;/span&gt;};&lt;br/&gt;&lt;span&gt;45&lt;/span&gt;&lt;br/&gt;&lt;span&gt;46&lt;/span&gt;&lt;span&gt;//聊天内容&lt;/span&gt;&lt;br/&gt;&lt;span&gt;47&lt;/span&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;chat_package&lt;/span&gt;&lt;br/&gt;&lt;span&gt;48&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;49&lt;/span&gt;    package_header header;&lt;br/&gt;&lt;span&gt;50&lt;/span&gt;    &lt;span&gt;//命令号&lt;/span&gt;&lt;br/&gt;&lt;span&gt;51&lt;/span&gt;    &lt;span&gt;int32_t&lt;/span&gt; cmd;&lt;br/&gt;&lt;span&gt;52&lt;/span&gt;    &lt;span&gt;//发送人userid&lt;/span&gt;&lt;br/&gt;&lt;span&gt;53&lt;/span&gt;    &lt;span&gt;int32_t&lt;/span&gt; senderid;&lt;br/&gt;&lt;span&gt;54&lt;/span&gt;    &lt;span&gt;//接收人userid&lt;/span&gt;&lt;br/&gt;&lt;span&gt;55&lt;/span&gt;    &lt;span&gt;int32_t&lt;/span&gt; targetid;&lt;br/&gt;&lt;span&gt;56&lt;/span&gt;    &lt;span&gt;//消息内容&lt;/span&gt;&lt;br/&gt;&lt;span&gt;57&lt;/span&gt;    &lt;span&gt;char&lt;/span&gt; chatcontent[&lt;span&gt;8192&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;58&lt;/span&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看到没有？由于每一个业务的内容不一样，定义的结构体也不一样。如果业务比较多的话，我们需要定义各种各样的这种结构体，这简直是一场噩梦。那么有没有什么方法可以避免这个问题呢？有，我受jdk中的流对象的WriteInt32、WriteByte、WriteInt64、WriteString，这样的接口的启发，也发明了一套这样的协议，而且这套协议基本上是通用协议，可用于任何场景。我们的包还是分为包头和包体两部分，包头和上文所说的一样，包体是一个不固定大小的二进制流，其长度由包头中的指定包体长度的字段决定。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;package_protocol&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;    &lt;span&gt;int32_t&lt;/span&gt; bodysize;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;    &lt;span&gt;//注意：C/C++语法不能这么定义结构体，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;    &lt;span&gt;//这里只是为了说明含义的伪代码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;    &lt;span&gt;//bodycontent即为一个不固定大小的二进制流&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;    &lt;span&gt;char&lt;/span&gt;    binarystream[bodysize];&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来的核心部分就是如何操作这个二进制流，我们将流分为二进制读和二进制写两种流，下面给出接口定义：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;    &lt;span&gt;//写&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BinaryWriteStream&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;        BinaryWriteStream(&lt;span&gt;string&lt;/span&gt;* data);&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;        &lt;span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* &lt;span&gt;GetData()&lt;/span&gt; &lt;span&gt;const&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;        &lt;span&gt;size_t&lt;/span&gt; GetSize() &lt;span&gt;const&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;        &lt;span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;WriteCString(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* str, &lt;span&gt;size_t&lt;/span&gt; len)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;        &lt;span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;WriteString(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&amp;amp; str)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;        &lt;span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;WriteDouble(&lt;span&gt;double&lt;/span&gt; value, &lt;span&gt;bool&lt;/span&gt; isNULL = &lt;span&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;        &lt;span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;WriteInt64(&lt;span&gt;int64_t&lt;/span&gt; value, &lt;span&gt;bool&lt;/span&gt; isNULL = &lt;span&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;        &lt;span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;WriteInt32(&lt;span&gt;int32_t&lt;/span&gt; i, &lt;span&gt;bool&lt;/span&gt; isNULL = &lt;span&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;        &lt;span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;WriteShort(&lt;span&gt;short&lt;/span&gt; i, &lt;span&gt;bool&lt;/span&gt; isNULL = &lt;span&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;        &lt;span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;WriteChar(&lt;span&gt;char&lt;/span&gt; c, &lt;span&gt;bool&lt;/span&gt; isNULL = &lt;span&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;        &lt;span&gt;size_t&lt;/span&gt; GetCurrentPos() &lt;span&gt;const&lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; m_data-&amp;gt;length(); }&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;        &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Flush()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;        &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;Clear()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt;:&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;        &lt;span&gt;string&lt;/span&gt;* m_data;&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;    };&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;    &lt;span&gt;//读&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BinaryReadStream&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; IReadStream&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt;:&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;        &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* &lt;span&gt;const&lt;/span&gt; ptr;&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;        &lt;span&gt;const&lt;/span&gt; &lt;span&gt;size_t&lt;/span&gt;      len;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;        &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*       cur;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;        BinaryReadStream(&lt;span&gt;const&lt;/span&gt; BinaryReadStream&amp;amp;);&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;        BinaryReadStream&amp;amp; &lt;span&gt;operator&lt;/span&gt;=(&lt;span&gt;const&lt;/span&gt; BinaryReadStream&amp;amp;);&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;        BinaryReadStream(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* ptr, &lt;span&gt;size_t&lt;/span&gt; len);&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;        &lt;span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* &lt;span&gt;GetData()&lt;/span&gt; &lt;span&gt;const&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;        &lt;span&gt;size_t&lt;/span&gt; GetSize() &lt;span&gt;const&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;        &lt;span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;IsEmpty()&lt;/span&gt; &lt;span&gt;const&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;        &lt;span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;ReadString(&lt;span&gt;string&lt;/span&gt;* str, &lt;span&gt;size_t&lt;/span&gt; maxlen, &lt;span&gt;size_t&lt;/span&gt;&amp;amp; outlen)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;        &lt;span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;ReadCString(&lt;span&gt;char&lt;/span&gt;* str, &lt;span&gt;size_t&lt;/span&gt; &lt;span&gt;strlen&lt;/span&gt;, &lt;span&gt;size_t&lt;/span&gt;&amp;amp; len)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;        &lt;span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;ReadCCString(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;** str, &lt;span&gt;size_t&lt;/span&gt; maxlen, &lt;span&gt;size_t&lt;/span&gt;&amp;amp; outlen)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;        &lt;span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;ReadInt32(&lt;span&gt;int32_t&lt;/span&gt;&amp;amp; i)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;        &lt;span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;ReadInt64(&lt;span&gt;int64_t&lt;/span&gt;&amp;amp; i)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;        &lt;span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;ReadShort(&lt;span&gt;short&lt;/span&gt;&amp;amp; i)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;        &lt;span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;ReadChar(&lt;span&gt;char&lt;/span&gt;&amp;amp; c)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;22&lt;/span&gt;        &lt;span&gt;size_t&lt;/span&gt; ReadAll(&lt;span&gt;char&lt;/span&gt;* szBuffer, &lt;span&gt;size_t&lt;/span&gt; iLen) &lt;span&gt;const&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;23&lt;/span&gt;        &lt;span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;IsEnd()&lt;/span&gt; &lt;span&gt;const&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;24&lt;/span&gt;        &lt;span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* &lt;span&gt;GetCurrent()&lt;/span&gt; &lt;span&gt;const&lt;/span&gt;&lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; cur; }&lt;br/&gt;&lt;span&gt;25&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;span&gt;26&lt;/span&gt;        &lt;span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;ReadLength(&lt;span&gt;size_t&lt;/span&gt; &amp;amp; len)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;27&lt;/span&gt;        &lt;span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;ReadLengthWithoutOffset(&lt;span&gt;size_t&lt;/span&gt; &amp;amp;headlen, &lt;span&gt;size_t&lt;/span&gt; &amp;amp; outlen)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;28&lt;/span&gt;    };&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样如果是上文的一个登录数据包，我们只要写成如下形式就可以了：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; outbuf;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;BinaryWriteStream &lt;span&gt;stream(&amp;amp;outbuf)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;stream.WriteInt32(cmd);&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;stream.WriteCString(username, &lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;stream.WriteCString(password, &lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;stream.WriteInt32(clienttype);&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;stream.WriteInt32(onlinetype);&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;//最终数据就存储到outbuf中去了&lt;/span&gt;&lt;br/&gt;&lt;span&gt;9&lt;/span&gt;stream.Flush();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接着我们再对端，解得正确的包体后，我们只要按写入的顺序依次读出来即可：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;BinaryWriteStream&lt;/span&gt; &lt;span&gt;stream&lt;/span&gt;(&lt;span&gt;outbuf&lt;/span&gt;&lt;span&gt;.c_str&lt;/span&gt;(), &lt;span&gt;outbuf&lt;/span&gt;&lt;span&gt;.length&lt;/span&gt;());&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;int32_t&lt;/span&gt; &lt;span&gt;cmd&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;stream&lt;/span&gt;&lt;span&gt;.WriteInt32&lt;/span&gt;(&lt;span&gt;cmd&lt;/span&gt;);&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; &lt;span&gt;username&lt;/span&gt;&lt;span&gt;[16]&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;&lt;span&gt;stream&lt;/span&gt;&lt;span&gt;.ReadCString&lt;/span&gt;(&lt;span&gt;username&lt;/span&gt;, 16, &lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; &lt;span&gt;password&lt;/span&gt;&lt;span&gt;[16]&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;&lt;span&gt;stream&lt;/span&gt;&lt;span&gt;.WriteCString&lt;/span&gt;(&lt;span&gt;password&lt;/span&gt;, 16, &lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;&lt;span&gt;int32_t&lt;/span&gt; &lt;span&gt;clienttype&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;&lt;span&gt;stream&lt;/span&gt;&lt;span&gt;.WriteInt32&lt;/span&gt;(&lt;span&gt;clienttype&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;int32_t&lt;/span&gt; &lt;span&gt;onlinetype&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;stream&lt;/span&gt;&lt;span&gt;.WriteInt32&lt;/span&gt;(&lt;span&gt;onlinetype&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里给出BinaryReadStream和BinaryWriteStream的完整实现：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;  1&lt;/span&gt;    &lt;span&gt;//计算校验和&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  2&lt;/span&gt;    &lt;span&gt;&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;short&lt;/span&gt; &lt;span&gt;checksum(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;short&lt;/span&gt; *buffer, &lt;span&gt;int&lt;/span&gt; size)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  3&lt;/span&gt;    &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;  4&lt;/span&gt;        &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; cksum = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;  5&lt;/span&gt;        &lt;span&gt;while&lt;/span&gt; (size &amp;gt; &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;  6&lt;/span&gt;        {&lt;br/&gt;&lt;span&gt;  7&lt;/span&gt;            cksum += *buffer++;&lt;br/&gt;&lt;span&gt;  8&lt;/span&gt;            size -= &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;short&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;  9&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt; 10&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (size)&lt;br/&gt;&lt;span&gt; 11&lt;/span&gt;        {&lt;br/&gt;&lt;span&gt; 12&lt;/span&gt;            cksum += *(&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*)buffer;&lt;br/&gt;&lt;span&gt; 13&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt; 14&lt;/span&gt;        &lt;span&gt;//将32位数转换成16&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 15&lt;/span&gt;        &lt;span&gt;while&lt;/span&gt; (cksum &amp;gt;&amp;gt; &lt;span&gt;16&lt;/span&gt;)&lt;br/&gt;&lt;span&gt; 16&lt;/span&gt;            cksum = (cksum &amp;gt;&amp;gt; &lt;span&gt;16&lt;/span&gt;) + (cksum &amp;amp; &lt;span&gt;0xffff&lt;/span&gt;);&lt;br/&gt;&lt;span&gt; 17&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;short&lt;/span&gt;)(~cksum);&lt;br/&gt;&lt;span&gt; 18&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt; 19&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt; 20&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;compress_(&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;char&lt;/span&gt; *buf, &lt;span&gt;size_t&lt;/span&gt; &amp;amp;len)&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 21&lt;/span&gt;    &lt;/span&gt;{&lt;br/&gt;&lt;span&gt; 22&lt;/span&gt;        len = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 23&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;4&lt;/span&gt;; a &amp;gt;= &lt;span&gt;0&lt;/span&gt;; a--)&lt;br/&gt;&lt;span&gt; 24&lt;/span&gt;        {&lt;br/&gt;&lt;span&gt; 25&lt;/span&gt;            &lt;span&gt;char&lt;/span&gt; c;&lt;br/&gt;&lt;span&gt; 26&lt;/span&gt;            c = i &amp;gt;&amp;gt; (a * &lt;span&gt;7&lt;/span&gt;) &amp;amp; &lt;span&gt;0x7f&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 27&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;0x00&lt;/span&gt; &amp;amp;&amp;amp; len == &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;span&gt; 28&lt;/span&gt;                &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 29&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt; (a == &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;span&gt; 30&lt;/span&gt;                c &amp;amp;= &lt;span&gt;0x7f&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 31&lt;/span&gt;            &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 32&lt;/span&gt;                c |= &lt;span&gt;0x80&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 33&lt;/span&gt;            buf[len] = c;&lt;br/&gt;&lt;span&gt; 34&lt;/span&gt;            len++;&lt;br/&gt;&lt;span&gt; 35&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt; 36&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (len == &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;span&gt; 37&lt;/span&gt;        {&lt;br/&gt;&lt;span&gt; 38&lt;/span&gt;            len++;&lt;br/&gt;&lt;span&gt; 39&lt;/span&gt;            buf[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 40&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt; 41&lt;/span&gt;        &lt;span&gt;//cout &amp;lt;&amp;lt; &quot;compress:&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 42&lt;/span&gt;        &lt;span&gt;//cout &amp;lt;&amp;lt; &quot;compress len:&quot; &amp;lt;&amp;lt; len &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 43&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 44&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt; 45&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt; 46&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;uncompress_(&lt;span&gt;char&lt;/span&gt; *buf, &lt;span&gt;size_t&lt;/span&gt; len, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &amp;amp;i)&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 47&lt;/span&gt;    &lt;/span&gt;{&lt;br/&gt;&lt;span&gt; 48&lt;/span&gt;        i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 49&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;; index &amp;lt; (&lt;span&gt;int&lt;/span&gt;)len; index++)&lt;br/&gt;&lt;span&gt; 50&lt;/span&gt;        {&lt;br/&gt;&lt;span&gt; 51&lt;/span&gt;            &lt;span&gt;char&lt;/span&gt; c = *(buf + index);&lt;br/&gt;&lt;span&gt; 52&lt;/span&gt;            i = i &amp;lt;&amp;lt; &lt;span&gt;7&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 53&lt;/span&gt;            c &amp;amp;= &lt;span&gt;0x7f&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 54&lt;/span&gt;            i |= c;&lt;br/&gt;&lt;span&gt; 55&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt; 56&lt;/span&gt;        &lt;span&gt;//cout &amp;lt;&amp;lt; &quot;uncompress:&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 57&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 58&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt; 59&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 60&lt;/span&gt;    BinaryReadStream::BinaryReadStream(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* ptr_, &lt;span&gt;size_t&lt;/span&gt; len_)&lt;br/&gt;&lt;span&gt; 61&lt;/span&gt;        : ptr(ptr_), len(len_), cur(ptr_)&lt;br/&gt;&lt;span&gt; 62&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt; 63&lt;/span&gt;        cur += BINARY_PACKLEN_LEN_2 + CHECKSUM_LEN;&lt;br/&gt;&lt;span&gt; 64&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt; 65&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 66&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; BinaryReadStream::IsEmpty() &lt;span&gt;const&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 67&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt; 68&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; len &amp;lt;= BINARY_PACKLEN_LEN_2;&lt;br/&gt;&lt;span&gt; 69&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt; 70&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 71&lt;/span&gt;    &lt;span&gt;size_t&lt;/span&gt; BinaryReadStream::GetSize() &lt;span&gt;const&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 72&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt; 73&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; len;&lt;br/&gt;&lt;span&gt; 74&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt; 75&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 76&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; BinaryReadStream::ReadCString(&lt;span&gt;char&lt;/span&gt;* str, &lt;span&gt;size_t&lt;/span&gt; &lt;span&gt;strlen&lt;/span&gt;, &lt;span&gt;/* out */&lt;/span&gt; &lt;span&gt;size_t&lt;/span&gt;&amp;amp; outlen)&lt;br/&gt;&lt;span&gt; 77&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt; 78&lt;/span&gt;        &lt;span&gt;size_t&lt;/span&gt; fieldlen;&lt;br/&gt;&lt;span&gt; 79&lt;/span&gt;        &lt;span&gt;size_t&lt;/span&gt; headlen;&lt;br/&gt;&lt;span&gt; 80&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (!ReadLengthWithoutOffset(headlen, fieldlen)) {&lt;br/&gt;&lt;span&gt; 81&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 82&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt; 83&lt;/span&gt;        &lt;span&gt;// user buffer is not enough&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 84&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (fieldlen &amp;gt; &lt;span&gt;strlen&lt;/span&gt;) {&lt;br/&gt;&lt;span&gt; 85&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 86&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt; 87&lt;/span&gt;        &lt;span&gt;// 偏移到数据的位置&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 88&lt;/span&gt;        &lt;span&gt;//cur += BINARY_PACKLEN_LEN_2;    &lt;/span&gt;&lt;br/&gt;&lt;span&gt; 89&lt;/span&gt;        cur += headlen;&lt;br/&gt;&lt;span&gt; 90&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (cur + fieldlen &amp;gt; ptr + len)&lt;br/&gt;&lt;span&gt; 91&lt;/span&gt;        {&lt;br/&gt;&lt;span&gt; 92&lt;/span&gt;            outlen = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 93&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 94&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt; 95&lt;/span&gt;        &lt;span&gt;memcpy&lt;/span&gt;(str, cur, fieldlen);&lt;br/&gt;&lt;span&gt; 96&lt;/span&gt;        outlen = fieldlen;&lt;br/&gt;&lt;span&gt; 97&lt;/span&gt;        cur += outlen;&lt;br/&gt;&lt;span&gt; 98&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 99&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;100&lt;/span&gt;&lt;br/&gt;&lt;span&gt;101&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; BinaryReadStream::ReadString(&lt;span&gt;string&lt;/span&gt;* str, &lt;span&gt;size_t&lt;/span&gt; maxlen, &lt;span&gt;size_t&lt;/span&gt;&amp;amp; outlen)&lt;br/&gt;&lt;span&gt;102&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;103&lt;/span&gt;        &lt;span&gt;size_t&lt;/span&gt; headlen;&lt;br/&gt;&lt;span&gt;104&lt;/span&gt;        &lt;span&gt;size_t&lt;/span&gt; fieldlen;&lt;br/&gt;&lt;span&gt;105&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (!ReadLengthWithoutOffset(headlen, fieldlen)) {&lt;br/&gt;&lt;span&gt;106&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;107&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;108&lt;/span&gt;        &lt;span&gt;// user buffer is not enough&lt;/span&gt;&lt;br/&gt;&lt;span&gt;109&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (maxlen != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; fieldlen &amp;gt; maxlen) {&lt;br/&gt;&lt;span&gt;110&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;111&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;112&lt;/span&gt;        &lt;span&gt;// 偏移到数据的位置&lt;/span&gt;&lt;br/&gt;&lt;span&gt;113&lt;/span&gt;        &lt;span&gt;//cur += BINARY_PACKLEN_LEN_2;    &lt;/span&gt;&lt;br/&gt;&lt;span&gt;114&lt;/span&gt;        cur += headlen;&lt;br/&gt;&lt;span&gt;115&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (cur + fieldlen &amp;gt; ptr + len)&lt;br/&gt;&lt;span&gt;116&lt;/span&gt;        {&lt;br/&gt;&lt;span&gt;117&lt;/span&gt;            outlen = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;118&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;119&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;120&lt;/span&gt;        str-&amp;gt;assign(cur, fieldlen);&lt;br/&gt;&lt;span&gt;121&lt;/span&gt;        outlen = fieldlen;&lt;br/&gt;&lt;span&gt;122&lt;/span&gt;        cur += outlen;&lt;br/&gt;&lt;span&gt;123&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;124&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;125&lt;/span&gt;&lt;br/&gt;&lt;span&gt;126&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; BinaryReadStream::ReadCCString(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;** str, &lt;span&gt;size_t&lt;/span&gt; maxlen, &lt;span&gt;size_t&lt;/span&gt;&amp;amp; outlen)&lt;br/&gt;&lt;span&gt;127&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;128&lt;/span&gt;        &lt;span&gt;size_t&lt;/span&gt; headlen;&lt;br/&gt;&lt;span&gt;129&lt;/span&gt;        &lt;span&gt;size_t&lt;/span&gt; fieldlen;&lt;br/&gt;&lt;span&gt;130&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (!ReadLengthWithoutOffset(headlen, fieldlen)) {&lt;br/&gt;&lt;span&gt;131&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;132&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;133&lt;/span&gt;        &lt;span&gt;// user buffer is not enough&lt;/span&gt;&lt;br/&gt;&lt;span&gt;134&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (maxlen != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; fieldlen &amp;gt; maxlen) {&lt;br/&gt;&lt;span&gt;135&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;136&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;137&lt;/span&gt;        &lt;span&gt;// 偏移到数据的位置&lt;/span&gt;&lt;br/&gt;&lt;span&gt;138&lt;/span&gt;        &lt;span&gt;//cur += BINARY_PACKLEN_LEN_2;    &lt;/span&gt;&lt;br/&gt;&lt;span&gt;139&lt;/span&gt;        cur += headlen;&lt;br/&gt;&lt;span&gt;140&lt;/span&gt;        &lt;span&gt;//memcpy(str, cur, fieldlen);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;141&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (cur + fieldlen &amp;gt; ptr + len)&lt;br/&gt;&lt;span&gt;142&lt;/span&gt;        {&lt;br/&gt;&lt;span&gt;143&lt;/span&gt;            outlen = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;144&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;145&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;146&lt;/span&gt;        *str = cur;&lt;br/&gt;&lt;span&gt;147&lt;/span&gt;        outlen = fieldlen;&lt;br/&gt;&lt;span&gt;148&lt;/span&gt;        cur += outlen;&lt;br/&gt;&lt;span&gt;149&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;150&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;151&lt;/span&gt;&lt;br/&gt;&lt;span&gt;152&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; BinaryReadStream::ReadInt32(&lt;span&gt;int32_t&lt;/span&gt;&amp;amp; i)&lt;br/&gt;&lt;span&gt;153&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;154&lt;/span&gt;        &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; VALUE_SIZE = &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int32_t&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;155&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (cur + VALUE_SIZE &amp;gt; ptr + len)&lt;br/&gt;&lt;span&gt;156&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;157&lt;/span&gt;        &lt;span&gt;memcpy&lt;/span&gt;(&amp;amp;i, cur, VALUE_SIZE);&lt;br/&gt;&lt;span&gt;158&lt;/span&gt;        i = ntohl(i);&lt;br/&gt;&lt;span&gt;159&lt;/span&gt;        cur += VALUE_SIZE;&lt;br/&gt;&lt;span&gt;160&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;161&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;162&lt;/span&gt;&lt;br/&gt;&lt;span&gt;163&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; BinaryReadStream::ReadInt64(&lt;span&gt;int64_t&lt;/span&gt;&amp;amp; i)&lt;br/&gt;&lt;span&gt;164&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;165&lt;/span&gt;        &lt;span&gt;char&lt;/span&gt; int64str[&lt;span&gt;128&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;166&lt;/span&gt;        &lt;span&gt;size_t&lt;/span&gt; length;&lt;br/&gt;&lt;span&gt;167&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (!ReadCString(int64str, &lt;span&gt;128&lt;/span&gt;, length))&lt;br/&gt;&lt;span&gt;168&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;169&lt;/span&gt;        i = atoll(int64str);&lt;br/&gt;&lt;span&gt;170&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;171&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;172&lt;/span&gt;&lt;br/&gt;&lt;span&gt;173&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; BinaryReadStream::ReadShort(&lt;span&gt;short&lt;/span&gt;&amp;amp; i)&lt;br/&gt;&lt;span&gt;174&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;175&lt;/span&gt;        &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; VALUE_SIZE = &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;short&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;176&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (cur + VALUE_SIZE &amp;gt; ptr + len) {&lt;br/&gt;&lt;span&gt;177&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;178&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;179&lt;/span&gt;        &lt;span&gt;memcpy&lt;/span&gt;(&amp;amp;i, cur, VALUE_SIZE);&lt;br/&gt;&lt;span&gt;180&lt;/span&gt;        i = ntohs(i);&lt;br/&gt;&lt;span&gt;181&lt;/span&gt;        cur += VALUE_SIZE;&lt;br/&gt;&lt;span&gt;182&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;183&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;184&lt;/span&gt;&lt;br/&gt;&lt;span&gt;185&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; BinaryReadStream::ReadChar(&lt;span&gt;char&lt;/span&gt;&amp;amp; c)&lt;br/&gt;&lt;span&gt;186&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;187&lt;/span&gt;        &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; VALUE_SIZE = &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;char&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;188&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (cur + VALUE_SIZE &amp;gt; ptr + len) {&lt;br/&gt;&lt;span&gt;189&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;190&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;191&lt;/span&gt;        &lt;span&gt;memcpy&lt;/span&gt;(&amp;amp;c, cur, VALUE_SIZE);&lt;br/&gt;&lt;span&gt;192&lt;/span&gt;        cur += VALUE_SIZE;&lt;br/&gt;&lt;span&gt;193&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;194&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;195&lt;/span&gt;&lt;br/&gt;&lt;span&gt;196&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; BinaryReadStream::ReadLength(&lt;span&gt;size_t&lt;/span&gt; &amp;amp; outlen)&lt;br/&gt;&lt;span&gt;197&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;198&lt;/span&gt;        &lt;span&gt;size_t&lt;/span&gt; headlen;&lt;br/&gt;&lt;span&gt;199&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (!ReadLengthWithoutOffset(headlen, outlen)) {&lt;br/&gt;&lt;span&gt;200&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;201&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;202&lt;/span&gt;        &lt;span&gt;//cur += BINARY_PACKLEN_LEN_2;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;203&lt;/span&gt;        cur += headlen;&lt;br/&gt;&lt;span&gt;204&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;205&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;206&lt;/span&gt;&lt;br/&gt;&lt;span&gt;207&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; BinaryReadStream::ReadLengthWithoutOffset(&lt;span&gt;size_t&lt;/span&gt;&amp;amp; headlen, &lt;span&gt;size_t&lt;/span&gt; &amp;amp; outlen)&lt;br/&gt;&lt;span&gt;208&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;209&lt;/span&gt;        headlen = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;210&lt;/span&gt;        &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *temp = cur;&lt;br/&gt;&lt;span&gt;211&lt;/span&gt;        &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;5&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;212&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;size_t&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i&amp;lt;&lt;span&gt;sizeof&lt;/span&gt;(buf); i++)&lt;br/&gt;&lt;span&gt;213&lt;/span&gt;        {&lt;br/&gt;&lt;span&gt;214&lt;/span&gt;            &lt;span&gt;memcpy&lt;/span&gt;(buf + i, temp, &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;char&lt;/span&gt;));&lt;br/&gt;&lt;span&gt;215&lt;/span&gt;            temp++;&lt;br/&gt;&lt;span&gt;216&lt;/span&gt;            headlen++;&lt;br/&gt;&lt;span&gt;217&lt;/span&gt;            &lt;span&gt;//if ((buf[i] &amp;gt;&amp;gt; 7 | 0x0) == 0x0)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;218&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt; ((buf[i] &amp;amp; &lt;span&gt;0x80&lt;/span&gt;) == &lt;span&gt;0x00&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;219&lt;/span&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;220&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;221&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (cur + headlen &amp;gt; ptr + len)&lt;br/&gt;&lt;span&gt;222&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;223&lt;/span&gt;        &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; value;&lt;br/&gt;&lt;span&gt;224&lt;/span&gt;        uncompress_(buf, headlen, value);&lt;br/&gt;&lt;span&gt;225&lt;/span&gt;        outlen = value;&lt;br/&gt;&lt;span&gt;226&lt;/span&gt;        &lt;span&gt;/*if ( cur + BINARY_PACKLEN_LEN_2 &amp;gt; ptr + len ) {&lt;br/&gt;&lt;span&gt;227&lt;/span&gt;        return false;&lt;br/&gt;&lt;span&gt;228&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;229&lt;/span&gt;        unsigned int tmp;&lt;br/&gt;&lt;span&gt;230&lt;/span&gt;        memcpy(&amp;amp;tmp, cur, sizeof(tmp));&lt;br/&gt;&lt;span&gt;231&lt;/span&gt;        outlen = ntohl(tmp);*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;232&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;233&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;234&lt;/span&gt;&lt;br/&gt;&lt;span&gt;235&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; BinaryReadStream::IsEnd() &lt;span&gt;const&lt;/span&gt;&lt;br/&gt;&lt;span&gt;236&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;237&lt;/span&gt;        assert(cur &amp;lt;= ptr + len);&lt;br/&gt;&lt;span&gt;238&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; cur == ptr + len;&lt;br/&gt;&lt;span&gt;239&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;240&lt;/span&gt;&lt;br/&gt;&lt;span&gt;241&lt;/span&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* BinaryReadStream::GetData() &lt;span&gt;const&lt;/span&gt;&lt;br/&gt;&lt;span&gt;242&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;243&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; ptr;&lt;br/&gt;&lt;span&gt;244&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;245&lt;/span&gt;&lt;br/&gt;&lt;span&gt;246&lt;/span&gt;    &lt;span&gt;size_t&lt;/span&gt; BinaryReadStream::ReadAll(&lt;span&gt;char&lt;/span&gt; * szBuffer, &lt;span&gt;size_t&lt;/span&gt; iLen) &lt;span&gt;const&lt;/span&gt;&lt;br/&gt;&lt;span&gt;247&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;248&lt;/span&gt;        &lt;span&gt;size_t&lt;/span&gt; iRealLen = min(iLen, len);&lt;br/&gt;&lt;span&gt;249&lt;/span&gt;        &lt;span&gt;memcpy&lt;/span&gt;(szBuffer, ptr, iRealLen);&lt;br/&gt;&lt;span&gt;250&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; iRealLen;&lt;br/&gt;&lt;span&gt;251&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;252&lt;/span&gt;&lt;br/&gt;&lt;span&gt;253&lt;/span&gt;    &lt;span&gt;//=================class BinaryWriteStream implementation============//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;254&lt;/span&gt;    BinaryWriteStream::BinaryWriteStream(&lt;span&gt;string&lt;/span&gt; *data) :&lt;br/&gt;&lt;span&gt;255&lt;/span&gt;        m_data(data)&lt;br/&gt;&lt;span&gt;256&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;257&lt;/span&gt;        m_data-&amp;gt;clear();&lt;br/&gt;&lt;span&gt;258&lt;/span&gt;        &lt;span&gt;char&lt;/span&gt; str[BINARY_PACKLEN_LEN_2 + CHECKSUM_LEN];&lt;br/&gt;&lt;span&gt;259&lt;/span&gt;        m_data-&amp;gt;append(str, &lt;span&gt;sizeof&lt;/span&gt;(str));&lt;br/&gt;&lt;span&gt;260&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;261&lt;/span&gt;&lt;br/&gt;&lt;span&gt;262&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; BinaryWriteStream::WriteCString(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* str, &lt;span&gt;size_t&lt;/span&gt; len)&lt;br/&gt;&lt;span&gt;263&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;264&lt;/span&gt;        &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;5&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;265&lt;/span&gt;        &lt;span&gt;size_t&lt;/span&gt; buflen;&lt;br/&gt;&lt;span&gt;266&lt;/span&gt;        compress_(len, buf, buflen);&lt;br/&gt;&lt;span&gt;267&lt;/span&gt;        m_data-&amp;gt;append(buf, &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;char&lt;/span&gt;)*buflen);&lt;br/&gt;&lt;span&gt;268&lt;/span&gt;        m_data-&amp;gt;append(str, len);&lt;br/&gt;&lt;span&gt;269&lt;/span&gt;        &lt;span&gt;//unsigned int ulen = htonl(len);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;270&lt;/span&gt;        &lt;span&gt;//m_data-&amp;gt;append((char*)&amp;amp;ulen,sizeof(ulen));&lt;/span&gt;&lt;br/&gt;&lt;span&gt;271&lt;/span&gt;        &lt;span&gt;//m_data-&amp;gt;append(str,len);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;272&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;273&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;274&lt;/span&gt;&lt;br/&gt;&lt;span&gt;275&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; BinaryWriteStream::WriteString(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&amp;amp; str)&lt;br/&gt;&lt;span&gt;276&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;277&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; WriteCString(str.c_str(), str.length());&lt;br/&gt;&lt;span&gt;278&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;279&lt;/span&gt;&lt;br/&gt;&lt;span&gt;280&lt;/span&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* BinaryWriteStream::GetData() &lt;span&gt;const&lt;/span&gt;&lt;br/&gt;&lt;span&gt;281&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;282&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; m_data-&amp;gt;data();&lt;br/&gt;&lt;span&gt;283&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;284&lt;/span&gt;&lt;br/&gt;&lt;span&gt;285&lt;/span&gt;    &lt;span&gt;size_t&lt;/span&gt; BinaryWriteStream::GetSize() &lt;span&gt;const&lt;/span&gt;&lt;br/&gt;&lt;span&gt;286&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;287&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; m_data-&amp;gt;length();&lt;br/&gt;&lt;span&gt;288&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;289&lt;/span&gt;&lt;br/&gt;&lt;span&gt;290&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; BinaryWriteStream::WriteInt32(&lt;span&gt;int32_t&lt;/span&gt; i, &lt;span&gt;bool&lt;/span&gt; isNULL)&lt;br/&gt;&lt;span&gt;291&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;292&lt;/span&gt;        &lt;span&gt;int32_t&lt;/span&gt; i2 = &lt;span&gt;999999999&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;293&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (isNULL == &lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;294&lt;/span&gt;            i2 = htonl(i);&lt;br/&gt;&lt;span&gt;295&lt;/span&gt;        m_data-&amp;gt;append((&lt;span&gt;char&lt;/span&gt;*)&amp;amp;i2, &lt;span&gt;sizeof&lt;/span&gt;(i2));&lt;br/&gt;&lt;span&gt;296&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;297&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;298&lt;/span&gt;&lt;br/&gt;&lt;span&gt;299&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; BinaryWriteStream::WriteInt64(&lt;span&gt;int64_t&lt;/span&gt; value, &lt;span&gt;bool&lt;/span&gt; isNULL)&lt;br/&gt;&lt;span&gt;300&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;301&lt;/span&gt;        &lt;span&gt;char&lt;/span&gt; int64str[&lt;span&gt;128&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;302&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (isNULL == &lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;303&lt;/span&gt;        {&lt;br/&gt;&lt;span&gt;304&lt;/span&gt;        &lt;span&gt;#&lt;span&gt;ifndef&lt;/span&gt; _WIN32&lt;/span&gt;&lt;br/&gt;&lt;span&gt;305&lt;/span&gt;            &lt;span&gt;sprintf&lt;/span&gt;(int64str, &lt;span&gt;&quot;%ld&quot;&lt;/span&gt;, value);&lt;br/&gt;&lt;span&gt;306&lt;/span&gt;        &lt;span&gt;#&lt;span&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;307&lt;/span&gt;            &lt;span&gt;sprintf&lt;/span&gt;(int64str, &lt;span&gt;&quot;%lld&quot;&lt;/span&gt;, value);&lt;br/&gt;&lt;span&gt;308&lt;/span&gt;        &lt;span&gt;#&lt;span&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;309&lt;/span&gt;            WriteCString(int64str, &lt;span&gt;strlen&lt;/span&gt;(int64str));&lt;br/&gt;&lt;span&gt;310&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;311&lt;/span&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;&lt;span&gt;312&lt;/span&gt;            WriteCString(int64str, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;313&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;314&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;315&lt;/span&gt;&lt;br/&gt;&lt;span&gt;316&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; BinaryWriteStream::WriteShort(&lt;span&gt;short&lt;/span&gt; i, &lt;span&gt;bool&lt;/span&gt; isNULL)&lt;br/&gt;&lt;span&gt;317&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;318&lt;/span&gt;        &lt;span&gt;short&lt;/span&gt; i2 = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;319&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (isNULL == &lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;320&lt;/span&gt;            i2 = htons(i);&lt;br/&gt;&lt;span&gt;321&lt;/span&gt;        m_data-&amp;gt;append((&lt;span&gt;char&lt;/span&gt;*)&amp;amp;i2, &lt;span&gt;sizeof&lt;/span&gt;(i2));&lt;br/&gt;&lt;span&gt;322&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;323&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;324&lt;/span&gt;&lt;br/&gt;&lt;span&gt;325&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; BinaryWriteStream::WriteChar(&lt;span&gt;char&lt;/span&gt; c, &lt;span&gt;bool&lt;/span&gt; isNULL)&lt;br/&gt;&lt;span&gt;326&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;327&lt;/span&gt;        &lt;span&gt;char&lt;/span&gt; c2 = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;328&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (isNULL == &lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;329&lt;/span&gt;            c2 = c;&lt;br/&gt;&lt;span&gt;330&lt;/span&gt;        (*m_data) += c2;&lt;br/&gt;&lt;span&gt;331&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;332&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;333&lt;/span&gt;&lt;br/&gt;&lt;span&gt;334&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; BinaryWriteStream::WriteDouble(&lt;span&gt;double&lt;/span&gt; value, &lt;span&gt;bool&lt;/span&gt; isNULL)&lt;br/&gt;&lt;span&gt;335&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;336&lt;/span&gt;        &lt;span&gt;char&lt;/span&gt;   doublestr[&lt;span&gt;128&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;337&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (isNULL == &lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;338&lt;/span&gt;        {&lt;br/&gt;&lt;span&gt;339&lt;/span&gt;            &lt;span&gt;sprintf&lt;/span&gt;(doublestr, &lt;span&gt;&quot;%f&quot;&lt;/span&gt;, value);&lt;br/&gt;&lt;span&gt;340&lt;/span&gt;            WriteCString(doublestr, &lt;span&gt;strlen&lt;/span&gt;(doublestr));&lt;br/&gt;&lt;span&gt;341&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;342&lt;/span&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;&lt;span&gt;343&lt;/span&gt;            WriteCString(doublestr, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;344&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;345&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;346&lt;/span&gt;&lt;br/&gt;&lt;span&gt;347&lt;/span&gt;    &lt;span&gt;void&lt;/span&gt; BinaryWriteStream::Flush()&lt;br/&gt;&lt;span&gt;348&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;349&lt;/span&gt;        &lt;span&gt;char&lt;/span&gt; *ptr = &amp;amp;(*m_data)[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;350&lt;/span&gt;        &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ulen = htonl(m_data-&amp;gt;length());&lt;br/&gt;&lt;span&gt;351&lt;/span&gt;        &lt;span&gt;memcpy&lt;/span&gt;(ptr, &amp;amp;ulen, &lt;span&gt;sizeof&lt;/span&gt;(ulen));&lt;br/&gt;&lt;span&gt;352&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;353&lt;/span&gt;&lt;br/&gt;&lt;span&gt;354&lt;/span&gt;    &lt;span&gt;void&lt;/span&gt; BinaryWriteStream::Clear()&lt;br/&gt;&lt;span&gt;355&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt;356&lt;/span&gt;        m_data-&amp;gt;clear();&lt;br/&gt;&lt;span&gt;357&lt;/span&gt;        &lt;span&gt;char&lt;/span&gt; str[BINARY_PACKLEN_LEN_2 + CHECKSUM_LEN];&lt;br/&gt;&lt;span&gt;358&lt;/span&gt;        m_data-&amp;gt;append(str, &lt;span&gt;sizeof&lt;/span&gt;(str));&lt;br/&gt;&lt;span&gt;359&lt;/span&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里详细解释一下上面的实现原理，即如何把各种类型的字段写入这种所谓的流中，或者怎么从这种流中读出各种类型的数据。上文的字段在流中的格式如下图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.12612612612612611&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/TufFCFqd0g3KvXhOKYiaVDFSI6ISoJmVNA6mWYl0qqibBdhuF5xic9RqjHelfsxk0RYOCMK1QRytxD3yyCb6NOWDw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;555&quot; title=&quot;enter image description here&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里最简便的方式就是每个字段的长度域都是固定字节数目，如4个字节。但是这里我们并没有这么做，而是使用了一个小小技巧去对字段长度进行了一点压缩。&lt;span&gt;对于字符串类型的字段，我们将表示其字段长度域的整型值（int32类型，4字节）按照其数值的大小压缩成1～5个字节，对于每一个字节，如果我们只用其低7位。最高位为标志位，为1时，表示其左边的还有下一个字节，反之到此结束。例如，对于数字127，我们二进制表示成01111111，由于最高位是0，那么如果字段长度是127及以下，一个字节就可以存储下了。如果一个字段长度大于127，如等于256，对应二进制&lt;span&gt;100000000&lt;/span&gt;，那么我们按照刚才的规则，先填充最低字节（从左往右依次是从低到高），由于最低的7位放不下，还有后续高位字节，所以我们在最低字节的最高位上填1，即1&lt;span&gt;0000000&lt;/span&gt;，接着次高位为0&lt;span&gt;0000100&lt;/span&gt;，由于次高位后面没有更高位的字节了，所以其最高位为0，组合起来两个字节就是10000000 0000100。对于数字50000，其二进制是1100001101010000，根据每7个一拆的原则是：11 0000110 1010000再加上标志位就是：10000011 10000110 01010000。采用这样一种策略将原来占4个字节的整型值根据数值大小压缩成了1～5个字节（由于我们对数据包最大长度有限制，所以不会出现长度需要占5个字节的情形）。反过来，解析每个字段的长度，就是先取出一个字节，看其最高位是否有标志位，如果有继续取下一个字节当字段长度的一部分继续解析，直到遇到某个字节最高位不为1为止。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;对一个整形压缩和解压缩的部分从上面的代码中摘录如下：&lt;/p&gt;&lt;p&gt;压缩：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;    &lt;span&gt;//将一个四字节的整形数值压缩成1~5个字节&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;bool&lt;/span&gt; compress_(unsigned &lt;span&gt;int&lt;/span&gt; i, char *buf, size_t &amp;amp;&lt;span&gt;len&lt;/span&gt;)&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;    {&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;        &lt;span&gt;len&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;4&lt;/span&gt;; a &amp;gt;= &lt;span&gt;0&lt;/span&gt;; a--)&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;        {&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;            char c;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;            c = i &amp;gt;&amp;gt; (a * &lt;span&gt;7&lt;/span&gt;) &amp;amp; &lt;span&gt;0x7f&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;0x00&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;len&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;                &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt; (a == &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;                c &amp;amp;= &lt;span&gt;0x7f&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;            &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;                c |= &lt;span&gt;0x80&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;            buf[&lt;span&gt;len&lt;/span&gt;] = c;&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;            &lt;span&gt;len&lt;/span&gt;++;&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;len&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;        {&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;            &lt;span&gt;len&lt;/span&gt;++;&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;            buf[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;22&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;23&lt;/span&gt;        &lt;span&gt;//cout &amp;lt;&amp;lt; &quot;compress:&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;24&lt;/span&gt;        &lt;span&gt;//cout &amp;lt;&amp;lt; &quot;compress len:&quot; &amp;lt;&amp;lt; len &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;25&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;26&lt;/span&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解压&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;    &lt;span&gt;//将一个1~5个字节的值还原成四字节的整形值&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;uncompress_(&lt;span&gt;char&lt;/span&gt; *buf, &lt;span&gt;size_t&lt;/span&gt; len, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &amp;amp;i)&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;    &lt;/span&gt;{&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;        i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;; index &amp;lt; (&lt;span&gt;int&lt;/span&gt;)len; index++)&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;        {&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;            &lt;span&gt;char&lt;/span&gt; c = *(buf + index);&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;            i = i &amp;lt;&amp;lt; &lt;span&gt;7&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;            c &amp;amp;= &lt;span&gt;0x7f&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;            i |= c;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;        &lt;span&gt;//cout &amp;lt;&amp;lt; &quot;uncompress:&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;三、关&lt;/span&gt;于跨系统与跨语言之间的网络通信协议解析与识别问题&lt;/h2&gt;&lt;p&gt;由于我们的即时通讯同时涉及到Java和C++两种编程语言，且有windows、linux、安卓三个平台，而我们为了保障学习的质量和效果，所以我们不用第三跨平台库（其实我们也是在学习如何编写这些跨平台库的原理），所以我们需要学习以下如何在Java语言中去解析C++的网络数据包或者反过来。安卓端发送的数据使用Java语言编写，pc与服务器发送的数据使用C++编写，这里以在Java中解析C++网络数据包为例。 这对于很多人来说是一件很困难的事情，所以只能变着法子使用第三方的库。其实只要你掌握了一定的基础知识，利用一些现成的字节流抓包工具（如tcpdump、wireshark）很容易解决这个问题。我们这里使用tcpdump工具来尝试分析和解决这个问题。&lt;br/&gt;首先，我们需要明确字节序列这样一个概念，即我们说的大端编码(big endian)和小端编码(little endian)，x86和x64系列的cpu使用小端编码，而数据在网络上传输，以及Java语言中，使用的是大端编码。那么这是什么意思呢？&lt;br/&gt;我们举个例子，看一个x64机器上的32位数值在内存中的存储方式：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.31313131313131315&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TufFCFqd0g3KvXhOKYiaVDFSI6ISoJmVNCh1Cf9MymvHr5zexwx7I5s8zFthqx29IYk8uxLSBGvbb1PUMTypptQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;396&quot; title=&quot;enter image description here&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;i在内存中的地址序列是0x003CF7C4~0x003CF7C8，值为40 e2 01 00。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.48577680525164113&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TufFCFqd0g3KvXhOKYiaVDFSI6ISoJmVNtubFFNM3gXZTtA8K0WZZjiaROkJoo68MoLTToZyTBfu2oWJje76y6nA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;457&quot; title=&quot;enter image description here&quot;/&gt;&lt;/figure&gt;&lt;p&gt;十六进制0001e240正好等于10进制123456，也就是说小端编码中权重高的的字节值存储在内存地址高（地址值较大）的位置，权重值低的字节值存储在内存地址低（地址值较小）的位置，也就是所谓的高高低低。&lt;br/&gt;相反，大端编码的规则应该是高低低高，也就是说权值高字节存储在内存地址低的位置，权值低的字节存储在内存地址高的位置。&lt;br/&gt;所以，如果我们一个C++程序的int32值123456不作转换地传给Java程序，那么Java按照大端编码的形式读出来的值是：十六进制40E20100 = 十进制1088553216。&lt;br/&gt;所以，我们要么在发送方将数据转换成网络字节序（大端编码），要么在接收端再进行转换。&lt;/p&gt;&lt;p&gt;下面看一下如果C++端传送一个如下数据结构，Java端该如何解析（由于Java中是没有指针的，也无法操作内存地址，导致很多人无从下手），下面利用tcpdump来解决这个问题的思路。&lt;br/&gt;我们客户端发送的数据包：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3781362007168459&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TufFCFqd0g3KvXhOKYiaVDFSI6ISoJmVNXXxcwwhpjurnSCP5Z42sl5xPo3Lh8mHiboiaibmguoveDypdVUtVNHzbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; title=&quot;enter image description here&quot; data-w=&quot;558&quot;/&gt;&lt;/figure&gt;&lt;p&gt;其结构体定义如下：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.32616487455197135&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TufFCFqd0g3KvXhOKYiaVDFSI6ISoJmVNibNGZSZLMLs6M7AjI7IWLHhFcfQTlOjcMXRJlJkMkaH9ZK82Fvop0wA/640?wx_fmt=png&quot; data-type=&quot;png&quot; title=&quot;enter image description here&quot; data-w=&quot;558&quot;/&gt;&lt;/figure&gt;&lt;p&gt;利用tcpdump抓到的包如下：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4521072796934866&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TufFCFqd0g3KvXhOKYiaVDFSI6ISoJmVNcicM0pl73LILlBlIZlJX27M9GJaX5k9ZicVBehwlOw2uaeahsXRYibu5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;522&quot; title=&quot;enter image description here&quot;/&gt;&lt;/figure&gt;&lt;p&gt;放大一点：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3010752688172043&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TufFCFqd0g3KvXhOKYiaVDFSI6ISoJmVNmXk1AKS1nW8auD416nHvcyol4dtEhLv8UrGRYQuNzkOc4iaL1V6xtTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; title=&quot;enter image description here&quot; data-w=&quot;558&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们白色标识出来就是我们收到的数据包。这里我想说明两点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果我们知道发送端发送的字节流，再比照接收端收到的字节流，我们就能检测数据包的完整性，或者利用这个来排查一些问题；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于Java程序只要按照这个顺序，先利用java.net.Socket的输出流java.io.DataOutputStream对象readByte、readInt32、readInt32、readBytes、readBytes方法依次读出一个char、int32、int32、16个字节的字节数组、63个字节数组即可，为了还原像int32这样的整形值，我们需要做一些小端编码向大端编码的转换。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;欢迎关注&lt;/span&gt;&lt;span&gt;公众号『高性能服务器开发』，本公众号&lt;span&gt;推崇基础学习与原理理解，不谈大而空的架构与技术术语，分享接地气的服务器开发实战技巧与项目经验，实实在在分享可用于实际编码的编程知识&lt;/span&gt;&lt;/span&gt;。如果对后端开发感兴趣，想加入 &lt;/span&gt;&lt;strong&gt;高性能服务器开发微信交流群 &lt;/strong&gt;进行交流，可以先加我微信 &lt;strong&gt;easy_coder&lt;/strong&gt;，备注&quot;加微信群&quot;，我拉你入群，备注不对不加哦。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.998567335243553&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;698&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ic8RqseyjxMNL1OoMv6icvXyw2MzMRL5maQ5v4IiboDzbWA14vgYrMpb5cNiaztmMwlJ9wvms7MDTmvvq4tM7aNTLQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;如果觉得受益&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;请别吝啬你的在看&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;__bg_gif&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zKBwDdu8U8EUh2cNXvZRZk1BULmyeYnjKibyKbx9SH0gAoXiadVhTta41Zh1It88iaKnreX0AtLApdUGgVfrYRVTg/640?wx_fmt=gif&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>