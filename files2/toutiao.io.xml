<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ad74e7676957b46695d55c75973fcfc1</guid>
<title>2021 年快结束了！抓紧啦！</title>
<link>https://toutiao.io/k/809c4m6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>edd9cb115878ca7b135465753515db48</guid>
<title>搞懂异地多活，看这篇就够了</title>
<link>https://toutiao.io/k/epd1pcc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;阅读本文大约需要 20 分钟。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，我是 Kaito。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在软件开发领域，「异地多活」是分布式系统架构设计的一座高峰，很多人经常听过它，但很少人理解其中的原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;异地多活到底是什么？为什么需要异地多活？它到底解决了什么问题？究竟是怎么解决的？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些疑问，想必是每个程序看到异地多活这个名词时，都想要搞明白的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有幸，我曾经深度参与过一个中等互联网公司，建设异地多活系统的设计与实施过程。所以今天，我就来和你聊一聊异地多活背后的的实现原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;认真读完这篇文章，我相信你会对异地多活架构，有更加深刻的理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;这篇文章干货很多，希望你可以耐心读完。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005574&quot; data-ratio=&quot;1.2792553191489362&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcf638Tkx0Rp6TSHkfWaCksDOJyqZlU5D10GZ8YamiblH4PfXpWmEAKjZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;376&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;01 系统可用性&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要想理解异地多活，我们需要从架构设计的原则说起。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现如今，我们开发一个软件系统，对其要求越来越高，如果你了解一些「架构设计」的要求，就知道一个好的软件架构应该遵循以下 3 个原则：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;高性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高可用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;易扩展&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，高性能意味着系统拥有更大流量的处理能力，更低的响应延迟。例如 1 秒可处理 10W 并发请求，接口响应时间 5 ms 等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;易扩展表示系统在迭代新功能时，能以最小的代价去扩展，系统遇到流量压力时，可以在不改动代码的前提下，去扩容系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而「高可用」这个概念，看起来很抽象，怎么理解它呢？通常用 2 个指标来衡量：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;平均故障间隔 MTBF&lt;/strong&gt;（Mean Time Between Failure）：表示两次故障的间隔时间，也就是系统「正常运行」的平均时间，这个时间越长，说明系统稳定性越高&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;故障恢复时间 MTTR&lt;/strong&gt;（Mean Time To Repair）：表示系统发生故障后「恢复的时间」，这个值越小，故障对用户的影响越小&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可用性与这两者的关系：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;可用性（Availability）= MTBF / (MTBF + MTTR) * 100%&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个公式得出的结果是一个「比例」，通常我们会用「N 个 9」来描述一个系统的可用性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005575&quot; data-ratio=&quot;0.35226179018286813&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcfRavWPSzHIgpE9MBUD00jSzyAv3Fj0g8UTaHNHhBROicrS7ibGavseX9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1039&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这张图你可以看到，要想达到 4 个 9 以上的可用性，平均每天故障时间必须控制在 10 秒以内。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，只有故障的时间「越短」，整个系统的可用性才会越高，每提升 1 个 9，都会对系统提出更高的要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，系统发生故障其实是不可避免的，尤其是规模越大的系统，发生问题的概率也越大。这些故障一般体现在 3 个方面：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;硬件故障&lt;/strong&gt;：CPU、内存、磁盘、网卡、交换机、路由器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;软件问题&lt;/strong&gt;：代码 Bug、版本迭代&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;不可抗力&lt;/strong&gt;：地震、水灾、火灾、战争&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些风险随时都有可能发生。所以，在面对故障时，我们的系统能否以「&lt;strong&gt;&lt;span&gt;最快&lt;/span&gt;&lt;/strong&gt;」的速度恢复，就成为了可用性的关键。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可如何做到快速恢复呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章要讲的「异地多活」架构，就是为了解决这个问题，而提出的高效解决方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面，我会从一个最简单的系统出发，带你一步步演化出一个支持「异地多活」的系统架构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个过程中，你会看到一个系统会遇到哪些可用性问题，以及为什么架构要这样演进，从而理解异地多活架构的意义。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;02 单机架构&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们从最简单的开始讲起。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设你的业务处于起步阶段，体量非常小，那你的架构是这样的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100005572&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.7092198581560283&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcfeL4AEsHBFyaA2ZotJSapdewM3RNkHwkxaibMn0uObDgZKmUNtcf3vPA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;282&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个架构模型非常简单，客户端请求进来，业务应用读写数据库，返回结果，非常好理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但需要注意的是，这里的数据库是「单机」部署的，所以它有一个致命的缺点：一旦遭遇意外，例如磁盘损坏、操作系统异常、误删数据，那这意味着所有数据就全部「丢失」了，这个损失是巨大的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何避免这个问题呢？我们很容易想到一个方案：&lt;strong&gt;&lt;span&gt;备份&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100005576&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.654510556621881&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcfSicasibvXwtpOQ6uQIbk3ST97lYkhbsVx6UevEUyFdTaG9MHsCZicct5g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2605&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以对数据做备份，把数据库文件「定期」cp 到另一台机器上，这样，即使原机器丢失数据，你依旧可以通过备份把数据「恢复」回来，以此保证数据安全。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方案实施起来虽然比较简单，但存在 2 个问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;恢复需要时间&lt;/strong&gt;：业务需先停机，再恢复数据，停机时间取决于恢复的速度，恢复期间服务「不可用」&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;数据不完整&lt;/strong&gt;：因为是定期备份，数据肯定不是「最新」的，数据完整程度取决于备份的周期&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显，你的数据库越大，意味故障恢复时间越久。那按照前面我们提到的「高可用」标准，这个方案可能连 1 个 9 都达不到，远远无法满足我们对可用性的要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那有什么更好的方案，既可以快速恢复业务？还能尽可能保证数据完整性呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时你可以采用这个方案：&lt;span&gt;&lt;strong&gt;主从副本&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;03 主从副本&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以在另一台机器上，再部署一个数据库实例，让这个新实例成为原实例的「副本」，让两者保持「实时同步」，就像这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005573&quot; data-ratio=&quot;0.6673189823874756&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcfAAJWeX8ibeZ3bW6oshVgDLY9ibwmadnpwrKia71W7sU1eWQH3jck9dglQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2555&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一般把原实例叫作主库（master），新实例叫作从库（slave）。这个方案的优点在于：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;数据完整性高&lt;/strong&gt;：主从副本实时同步，数据「差异」很小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;抗故障能力提升&lt;/strong&gt;：主库有任何异常，从库可随时「切换」为主库，继续提供服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;读性能提升&lt;/strong&gt;：业务应用可直接读从库，分担主库「压力」读压力&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方案不错，不仅大大提高了数据库的可用性，还提升了系统的读性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的思路，你的「业务应用」也可以在其它机器部署一份，避免单点。因为业务应用通常是「无状态」的（不像数据库那样存储数据），所以直接部署即可，非常简单。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005581&quot; data-ratio=&quot;0.6673189823874756&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcft1nic2lX96vDnfZLibwiaMmwjcyiaQ5VgNjy9r9aM3BBuSlfM91bG7dpkg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2555&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为业务应用部署了多个，所以你现在还需要部署一个「接入层」，来做请求的「负载均衡」（一般会使用 nginx 或 LVS），这样当一台机器宕机后，另一台机器也可以「接管」所有流量，持续提供服务。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005579&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcfGETkjFiadJMhMulmbibkfDTpPWw1wYCcOnicF8shHlvicGoYpeS7yQH7rw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2755&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这个方案你可以看出，提升可用性的关键思路就是：&lt;span&gt;&lt;strong&gt;冗余&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，担心一个实例故障，那就部署多个实例，担心一个机器宕机，那就部署多台机器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，你的架构基本已演变成主流方案了，之后开发新的业务应用，都可以按照这种模式去部署。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005580&quot; data-ratio=&quot;1.0564971751412429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcflx6JnOF1KgsGrYACshribvgcLTLuDcWaDO1DTiaGa7lSl04qBG2TDrDg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2655&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这种方案还有什么风险吗？&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;04 风险不可控&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在让我们把视角下放，把焦点放到具体的「部署细节」上来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照前面的分析，为了避免单点故障，你的应用虽然部署了多台机器，但这些机器的分布情况，我们并没有去深究。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而一个机房有很多服务器，这些服务器通常会分布在一个个「机柜」上，如果你使用的这些机器，刚好在一个机柜，还是存在风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果恰好连接这个机柜的交换机 / 路由器发生故障，那么你的应用依旧有「不可用」的风险。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;虽然交换机 / 路由器也做了路线冗余，但不能保证一定不出问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;部署在一个机柜有风险，那把这些机器打散，分散到不同机柜上，是不是就没问题了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样确实会大大降低出问题的概率。但我们依旧不能掉以轻心，因为无论怎么分散，它们总归还是在一个相同的环境下：&lt;span&gt;&lt;strong&gt;机房&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那继续追问，机房会不会发生故障呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来讲，建设一个机房的要求其实是很高的，地理位置、温湿度控制、备用电源等等，机房厂商会在各方面做好防护。但即使这样，我们每隔一段时间还会看到这样的新闻：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;2015 年 5 月 27 日，杭州市某地光纤被挖断，近 3 亿用户长达 5 小时无法访问支付宝&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2021 年 7 月 13 日，B 站部分服务器机房发生故障，造成整站持续 3 个小时无法访问&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2021 年 10 月 9 日，富途证券服务器机房发生电力闪断故障，造成用户 2 个小时无法登陆、交易&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;...&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见，即使机房级别的防护已经做得足够好，但只要有「概率」出问题，那现实情况就有可能发生。虽然概率很小，但一旦真的发生，影响之大可见一斑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里你可能会想，机房出现问题的概率也太小了吧，工作了这么多年，也没让我碰上一次，有必要考虑得这么复杂吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但你有没有思考这样一个问题：&lt;span&gt;&lt;strong&gt;不同体量的系统，它们各自关注的重点是什么？&lt;/strong&gt;&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;体量很小的系统，它会重点关注「用户」规模、增长，这个阶段获取用户是一切。等用户体量上来了，这个阶段会重点关注「性能」，优化接口响应时间、页面打开速度等等，这个阶段更多是关注用户体验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等体量再大到一定规模后你会发现，「可用性」就变得尤为重要。像微信、支付宝这种全民级的应用，如果机房发生一次故障，那整个影响范围可以说是非常巨大的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，再小概率的风险，我们在提高系统可用性时，也不能忽视。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析了风险，再说回我们的架构。那到底该怎么应对机房级别的故障呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，还是&lt;span&gt;&lt;strong&gt;冗余&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;05 同城灾备&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要抵御「机房」级别的风险，那应对方案就不能局限在一个机房内了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，你需要做机房级别的冗余方案，也就是说，你需要再搭建一个机房，来部署你的服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单起见，你可以在「同一个城市」再搭建一个机房，原机房我们叫作 A 机房，新机房叫 B 机房，这两个机房的网络用一条「专线」连通。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005577&quot; data-ratio=&quot;1.1027522935779817&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcfibxicNTgl52nvso1NzlYgnS2vjfddMibibUGO1C41U0ibqOC3EWicsgiaI7iaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2725&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了新机房，怎么把它用起来呢？这里还是要优先考虑「数据」风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了避免 A 机房故障导致数据丢失，所以我们需要把数据在 B 机房也存一份。最简单的方案还是和前面提到的一样：&lt;span&gt;&lt;strong&gt;备份&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;A 机房的数据，定时在 B 机房做备份（拷贝数据文件），这样即使整个 A 机房遭到严重的损坏，B 机房的数据不会丢，通过备份可以把数据「恢复」回来，重启服务。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100005578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0548672566371682&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcfBQhCeickLEkNbyVkviaGjuib53Th3icSFwhnTyPt0nXKftw1AlhbrE02rg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2825&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案，我们称之为「&lt;span&gt;&lt;strong&gt;冷备&lt;/strong&gt;&lt;/span&gt;」。为什么叫冷备呢？因为 B 机房只做备份，不提供实时服务，它是冷的，只会在 A 机房故障时才会启用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但备份的问题依旧和之前描述的一样：数据不完整、恢复数据期间业务不可用，整个系统的可用性还是无法得到保证。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们还是需要用「主从副本」的方式，在 B 机房部署 A 机房的数据副本，架构就变成了这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005584&quot; data-ratio=&quot;1.1211009174311926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcf8tYibauRrsDgEVGzgibShDBEGezgsApqEOyITRLEIXRRoUcmNqOVz7pA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2725&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，就算整个 A 机房挂掉，我们在 B 机房也有比较「完整」的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据是保住了，但这时你需要考虑另外一个问题：&lt;span&gt;&lt;strong&gt;如果 A 机房真挂掉了，要想保证服务不中断，你还需要在 B 机房「紧急」做这些事情&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;B 机房所有从库提升为主库&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 B 机房部署应用，启动服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部署接入层，配置转发规则&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DNS 指向 B 机房，接入流量，业务恢复&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到了么？A 机房故障后，B 机房需要做这么多工作，你的业务才能完全「恢复」过来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你看，整个过程需要人为介入，且需花费大量时间来操作，恢复之前整个服务还是不可用的，这个方案还是不太爽，如果能做到故障后立即「切换」，那就好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，要想缩短业务恢复的时间，你必须把这些工作在 B 机房「&lt;strong&gt;&lt;span&gt;提前&lt;/span&gt;&lt;/strong&gt;」做好，也就是说，你需要在 B 机房提前部署好接入层、业务应用，等待随时切换。架构就变成了这样：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100005585&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1211009174311926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcfQk91mRgye8G9963fcc86TdpGlIu49tI3VG4gdbniavrlkqZJfPflZWA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2725&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的话，A 机房整个挂掉，我们只需要做 2 件事即可：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;B 机房所有从库提升为主库&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DNS 指向 B 机房，接入流量，业务恢复&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一来，恢复速度快了很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里你会发现，B 机房从最开始的「空空如也」，演变到现在，几乎是「&lt;strong&gt;&lt;span&gt;镜像&lt;/span&gt;&lt;/strong&gt;」了一份 A 机房的所有东西，从最上层的接入层，到中间的业务应用，到最下层的存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个机房唯一的区别是，&lt;span&gt;&lt;strong&gt;A 机房的存储都是主库，而 B 机房都是从库&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案，我们把它叫做「&lt;span&gt;&lt;strong&gt;热备&lt;/strong&gt;&lt;/span&gt;」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;热的意思是指，B 机房处于「待命」状态，A 故障后 B 可以随时「接管」流量，继续提供服务。热备相比于冷备最大的优点是：&lt;span&gt;&lt;strong&gt;随时可切换&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是冷备还是热备，因为它们都处于「备用」状态，所以我们把这两个方案统称为：&lt;span&gt;&lt;strong&gt;同城灾备&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同城灾备的最大优势在于，我们再也不用担心「机房」级别的故障了，一个机房发生风险，我们只需把流量切换到另一个机房即可，可用性再次提高，是不是很爽？（后面还有更爽的）&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;06 同城双活&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们继续来看这个架构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然我们有了应对机房故障的解决方案，但这里有个问题是我们不能忽视的：&lt;span&gt;&lt;strong&gt;A 机房挂掉，全部流量切到 B 机房，B 机房能否真的如我们所愿，正常提供服务？&lt;/strong&gt;&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是个值得思考的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就好比有两支军队 A 和 B，A 军队历经沙场，作战经验丰富，而 B 军队只是后备军，除了有军人的基本素养之外，并没有实战经验，战斗经验基本为 0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 A 军队丧失战斗能力，需要 B 军队立即顶上时，作为指挥官的你，肯定也会担心 B 军队能否真的担此重任吧？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的架构也是如此，此时的 B 机房虽然是随时「待命」状态，但 A 机房真的发生故障，我们要把全部流量切到 B 机房，其实是不敢百分百保证它可以「如期」工作的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你想，我们在一个机房内部署服务，还总是发生各种各样的问题，例如：发布应用的版本不一致、系统资源不足、操作系统参数不一样等等。现在多部署一个机房，这些问题只会增多，不会减少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，从「成本」的角度来看，我们新部署一个机房，需要购买服务器、内存、硬盘、带宽资源，花费成本也是非常高昂的，只让它当一个后备军，未免也太「大材小用」了！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，我们需要让 B 机房也接入流量，实时提供服务，这样做的好处，&lt;span&gt;&lt;strong&gt;一是可以实时训练这支后备军，让它达到与 A 机房相同的作战水平，随时可切换，二是 B 机房接入流量后，可以分担 A 机房的流量压力&lt;/strong&gt;&lt;/span&gt;。这才是把 B 机房资源优势，发挥最大化的最好方案！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那怎么让 B 机房也接入流量呢？很简单，就是把 B 机房的接入层 IP 地址，加入到 DNS 中，这样，B 机房从上层就可以有流量进来了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005583&quot; data-ratio=&quot;1.2495412844036697&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcf78k4GXEy5AePldQzI9TKegaNyodnREkE59ThiawMia7beOZb1bLe4eIg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2725&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这里有一个问题：别忘了，B 机房的存储，现在可都是 A 机房的「从库」，从库默认可都是「不可写」的，B 机房的写请求打到本机房存储上，肯定会报错，这还是不符合我们预期。怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，你就需要在「业务应用」层做改造了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你的业务应用在操作数据库时，需要区分「&lt;span&gt;&lt;strong&gt;读写分离&lt;/strong&gt;&lt;/span&gt;」（一般用中间件实现），即两个机房的「读」流量，可以读任意机房的存储，但「写」流量，只允许写 A 机房，因为主库在 A 机房。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100005582&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2678899082568806&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcfXYiaVeWhbZgUDiaKC5ia7K7Lbuic1eUUAAibhJq1vOHGThTicdpX8L5tnDFQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2725&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这会涉及到你用的所有存储，例如项目中用到了 MySQL、Redis、MongoDB 等等，操作这些数据库，都需要区分读写请求，所以这块需要一定的业务「改造」成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 A 机房的存储都是主库，所以我们把 A 机房叫做「&lt;span&gt;&lt;strong&gt;主机房&lt;/strong&gt;&lt;/span&gt;」，B 机房叫「&lt;span&gt;&lt;strong&gt;从机房&lt;/strong&gt;&lt;/span&gt;」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个机房部署在「同城」，物理距离比较近，而且两个机房用「专线」网络连接，虽然跨机房访问的延迟，比单个机房内要大一些，但整体的延迟还是可以接受的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务改造完成后，B 机房可以慢慢接入流量，从 10%、30%、50% 逐渐覆盖到 100%，你可以持续观察 B 机房的业务是否存在问题，有问题及时修复，逐渐让 B 机房的工作能力，达到和 A 机房相同水平。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，因为 B 机房实时接入了流量，此时如果 A 机房挂了，那我们就可以「大胆」地把 A 的流量，全部切换到 B 机房，完成快速切换！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里你可以看到，我们部署的 B 机房，在物理上虽然与 A 有一定距离，但整个系统从「逻辑」上来看，我们是把这两个机房看做一个「整体」来规划的，也就是说，相当于把 2 个机房当作 1 个机房来用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种架构方案，比前面的同城灾备更「进了一步」，B 机房实时接入了流量，还能应对随时的故障切换，这种方案我们把它叫做「&lt;span&gt;&lt;strong&gt;同城双活&lt;/strong&gt;&lt;/span&gt;」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为两个机房都能处理业务请求，这对我们系统的内部维护、改造、升级提供了更多的可实施空间（流量随时切换），现在，整个系统的弹性也变大了，是不是更爽了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那这种架构有什么问题呢？&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;07 两地三中心&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是回到风险上来说。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然我们把 2 个机房当做一个整体来规划，但这 2 个机房在物理层面上，还是处于「一个城市」内，如果是整个城市发生自然灾害，例如地震、水灾（河南水灾刚过去不久），那 2 个机房依旧存在「全局覆没」的风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;真是防不胜防啊？怎么办？没办法，继续冗余。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这次冗余机房，就不能部署在同一个城市了，你需要把它放到距离更远的地方，部署在「异地」。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;通常建议两个机房的距离要在 1000 公里以上，这样才能应对城市级别的灾难。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设之前的 A、B 机房在北京，那这次新部署的 C 机房可以放在上海。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照前面的思路，把 C 机房用起来，最简单粗暴的方案还就是做「冷备」，即定时把 A、B 机房的数据，在 C 机房做备份，防止数据丢失。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100005586&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7933409873708381&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcfKmhvX0aecyGOuS0rYLwMjibiaXwuwejkjBIpXGibH9jKvhYdm6lvrDhfw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;4355&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案，就是我们经常听到的「&lt;span&gt;&lt;strong&gt;两地三中心&lt;/strong&gt;&lt;/span&gt;」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;两地是指 2 个城市，三中心是指有 3 个机房，其中 2 个机房在同一个城市，并且同时提供服务，第 3 个机房部署在异地，只做数据灾备。&lt;/strong&gt;&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种架构方案，通常用在银行、金融、政企相关的项目中。它的问题还是前面所说的，启用灾备机房需要时间，而且启用后的服务，不确定能否如期工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，要想真正的抵御城市级别的故障，越来越多的互联网公司，开始实施「&lt;span&gt;&lt;strong&gt;异地双活&lt;/strong&gt;&lt;/span&gt;」。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;08 伪异地双活&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里，我们还是分析 2 个机房的架构情况。我们不再把 A、B 机房部署在同一个城市，而是分开部署，例如 A 机房放在北京，B 机房放在上海。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们讲了同城双活，那异地双活是不是直接「照搬」同城双活的模式去部署就可以了呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事情没你想的那么简单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果还是按照同城双活的架构来部署，那异地双活的架构就是这样的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100005587&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2678899082568806&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcffxL80lJIUlaBRa8nk0X7na8wXvfAiaHH86agia8WMnFWFNpghb5Z6gxQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2725&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意看，两个机房的网络是通过「&lt;strong&gt;&lt;span&gt;跨城专线&lt;/span&gt;&lt;/strong&gt;」连通的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时两个机房都接入流量，那上海机房的请求，可能要去读写北京机房的存储，这里存在一个很大的问题：&lt;span&gt;&lt;strong&gt;网络延迟&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为两个机房距离较远，受到物理距离的限制，现在，两地之间的网络延迟就变成了「&lt;span&gt;&lt;strong&gt;不可忽视&lt;/strong&gt;&lt;/span&gt;」的因素了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;北京到上海的距离大约 1300 公里，即使架设一条高速的「网络专线」，光纤以光速传输，一个来回也需要近 10ms 的延迟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;况且，网络线路之间还会经历各种路由器、交换机等网络设备，实际延迟可能会达到 30ms ~ 100ms，如果网络发生抖动，延迟甚至会达到 1 秒。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;不止是延迟，远距离的网络专线质量，是远远达不到机房内网络质量的，专线网络经常会发生延迟、丢包、甚至中断的情况。总之，不能过度信任和依赖「跨城专线」。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可能会问，这点延迟对业务影响很大吗？影响非常大！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;试想，一个客户端请求打到上海机房，上海机房要去读写北京机房的存储，一次跨机房访问延迟就达到了 30ms，这大致是机房内网网络（0.5 ms）访问速度的 60 倍（30ms / 0.5ms），一次请求慢 60 倍，来回往返就要慢 100 倍以上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而我们在 App 打开一个页面，可能会访问后端几十个 API，每次都跨机房访问，整个页面的响应延迟有可能就达到了&lt;span&gt;&lt;strong&gt;秒级&lt;/strong&gt;&lt;/span&gt;，这个性能简直惨不忍睹，难以接受。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到了么，虽然我们只是简单的把机房部署在了「异地」，但「同城双活」的架构模型，在这里就不适用了，还是按照这种方式部署，这是「伪异地双活」！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那如何做到真正的异地双活呢？&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;09 真正的异地双活&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然「跨机房」调用延迟是不容忽视的因素，那我们只能尽量避免跨机房「调用」，规避这个延迟问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，上海机房的应用，不能再「跨机房」去读写北京机房的存储，只允许读写上海本地的存储，实现「就近访问」，这样才能避免延迟问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是之前提到的问题：上海机房存储都是从库，不允许写入啊，除非我们只允许上海机房接入「读流量」，不接收「写流量」，否则无法满足不再跨机房的要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很显然，只让上海机房接收读流量的方案不现实，因为很少有项目是只有读流量，没有写流量的。所以这种方案还是不行，这怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，你就必须在「&lt;span&gt;&lt;strong&gt;存储层&lt;/strong&gt;&lt;/span&gt;」做改造了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要想上海机房读写本机房的存储，那上海机房的存储不能再是北京机房的从库，而是也要变为「主库」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你没看错，两个机房的存储必须都是「&lt;span&gt;&lt;strong&gt;主库&lt;/strong&gt;&lt;/span&gt;」，而且两个机房的数据还要「&lt;span&gt;&lt;strong&gt;互相同步&lt;/strong&gt;&lt;/span&gt;」数据，即客户端无论写哪一个机房，都能把这条数据同步到另一个机房。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为只有两个机房都拥有「全量数据」，才能支持任意切换机房，持续提供服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么实现这种「双主」架构呢？它们之间如何互相同步数据？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你对 MySQL 有所了解，MySQL 本身就提供了双主架构，它支持双向复制数据，但平时用的并不多。而且 Redis、MongoDB 等数据库并没有提供这个功能，所以，你必须开发对应的「&lt;span&gt;&lt;strong&gt;数据同步中间件&lt;/strong&gt;&lt;/span&gt;」来实现双向同步的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，除了数据库这种有状态的软件之外，你的项目通常还会使用到消息队列，例如 RabbitMQ、Kafka，这些也是有状态的服务，所以它们也需要开发双向同步的中间件，支持任意机房写入数据，同步至另一个机房。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到了么，这一下子复杂度就上来了，单单针对每个数据库、队列开发同步中间件，就需要投入很大精力了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;业界也开源出了很多数据同步中间件，例如阿里的 Canal、RedisShake、MongoShake，可分别在两个机房同步 MySQL、Redis、MongoDB 数据。&lt;/p&gt;&lt;p&gt;很多有能力的公司，也会采用自研同步中间件的方式来做，例如饿了么、携程、美团都开发了自己的同步中间件。&lt;/p&gt;&lt;p&gt;我也有幸参与设计开发了 MySQL、Redis/Codis、MongoDB 的同步中间件，有时间写一篇文章详细聊聊实现细节，欢迎持续关注。:)&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，整个架构就变成了这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005588&quot; data-ratio=&quot;1.2820037105751392&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcfjI07neZaKfohiaQme7pDC5sSOhbwDGbSxIPZJib5UoefsmSucylcaN2w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2695&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意看，两个机房的存储层都互相同步数据的。有了数据同步中间件，就可以达到这样的效果：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;北京机房写入 X = 1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上海机房写入 Y = 2&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据通过中间件双向同步&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;北京、上海机房都有 X = 1、Y = 2 的数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们用中间件双向同步数据，就不用再担心专线问题，专线出问题，我们的中间件可以自动重试，直到成功，达到数据最终一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这里还会遇到一个问题，两个机房都可以写，操作的不是同一条数据那还好，如果修改的是同一条的数据，发生冲突怎么办？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户短时间内发了 2 个修改请求，都是修改同一条数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个请求落在北京机房，修改 X = 1（还未同步到上海机房）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另一个请求落在上海机房，修改 X = 2（还未同步到北京机房）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;两个机房以哪个为准？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，在很短的时间内，同一个用户修改同一条数据，两个机房无法确认谁先谁后，数据发生「冲突」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个很严重的问题，系统发生故障并不可怕，可怕的是数据发生「错误」，因为修正数据的成本太高了。我们一定要避免这种情况的发生。解决这个问题，有 2 个方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;第一个方案&lt;/strong&gt;&lt;/span&gt;，数据同步中间件要有自动「合并」数据、解决「冲突」的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方案实现起来比较复杂，要想合并数据，就必须要区分出「先后」顺序。我们很容易想到的方案，就是以「时间」为标尺，以「后到达」的请求为准。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这种方案需要两个机房的「时钟」严格保持一致才行，否则很容易出现问题。例如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第 1 个请求落到北京机房，北京机房时钟是 10:01，修改 X = 1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第 2 个请求落到上海机房，上海机房时钟是 10:00，修改 X = 2&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为北京机房的时间「更晚」，那最终结果就会是 X = 1。但这里其实应该以第 2 个请求为准，X = 2 才对。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见，完全「依赖」时钟的冲突解决方案，不太严谨。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，通常会采用&lt;strong&gt;&lt;span&gt;第二种方案&lt;/span&gt;&lt;/strong&gt;，从「&lt;strong&gt;&lt;span&gt;源头&lt;/span&gt;&lt;/strong&gt;」就避免数据冲突的发生。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10 如何实施异地双活&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然自动合并数据的方案实现成本高，那我们就要想，能否从源头就「避免」数据冲突呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个思路非常棒！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从源头避免数据冲突的思路是：&lt;span&gt;&lt;strong&gt;在最上层接入流量时，就不要让冲突的情况发生。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体来讲就是，要在最上层就把用户「区分」开，部分用户请求固定打到北京机房，其它用户请求固定打到上海 机房，进入某个机房的用户请求，之后的所有业务操作，都在这一个机房内完成，从根源上避免「跨机房」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这时，你需要在接入层之上，再部署一个「路由层」（通常部署在云服务器上），自己可以配置路由规则，把用户「分流」到不同的机房内。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100005591&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.4489795918367347&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcfqNvJXZU3WfXwcTCnkr6cmMpryTBkWWB4Gnhbnkeb5zT9KTUGkwu9gA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2695&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这个路由规则，具体怎么定呢？有很多种实现方式，最常见的我总结了 3 类：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;按业务类型分片&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;直接哈希分片&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;按地理位置分片&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;1、按业务类型分片&lt;/strong&gt;&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案是指，按应用的「业务类型」来划分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例：假设我们一共有 4 个应用，北京和上海机房都部署这些应用。但应用 1、2 只在北京机房接入流量，在上海机房只是热备。应用 3、4 只在上海机房接入流量，在北京机房是热备。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一来，应用 1、2 的所有业务请求，只读写北京机房存储，应用 3、4 的所有请求，只会读写上海机房存储。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100005589&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.4489795918367347&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcfDuGZ4o0p4lmic4ZJSibURuljic8OVFbvQzPGVcKUEibOepSGgOu0Qzt8HA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2695&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样按业务类型分片，也可以避免同一个用户修改同一条数据。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里按业务类型在不同机房接入流量，还需要考虑多个应用之间的依赖关系，要尽可能的把完成「相关」业务的应用部署在同一个机房，避免跨机房调用。&lt;/p&gt;&lt;p&gt;例如，订单、支付服务有依赖关系，会产生互相调用，那这 2 个服务在 A 机房接入流量。社区、发帖服务有依赖关系，那这 2 个服务在 B 机房接入流量。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;2、直接哈希分片&lt;/strong&gt;&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案就是，最上层的路由层，会根据用户 ID 计算「哈希」取模，然后从路由表中找到对应的机房，之后把请求转发到指定机房内。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例：一共 200 个用户，根据用户 ID 计算哈希值，然后根据路由规则，把用户 1 - 100 路由到北京机房，101 - 200 用户路由到上海机房，这样，就避免了同一个用户修改同一条数据的情况发生。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100005590&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.4489795918367347&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcfKokwm30Oj1hTGPp2ZluwibbIjiaYicKJTPExQp7UpkpCb91nOJJZvI8vw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2695&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;3、按地理位置分片&lt;/strong&gt;&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案，非常适合与地理位置密切相关的业务，例如打车、外卖服务就非常适合这种方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拿外卖服务举例，你要点外卖肯定是「就近」点餐，整个业务范围相关的有商家、用户、骑手，它们都是在相同的地理位置内的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这种特征，就可以在最上层，按用户的「地理位置」来做分片，分散到不同的机房。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例：北京、河北地区的用户点餐，请求只会打到北京机房，而上海、浙江地区的用户，请求则只会打到上海机房。这样的分片规则，也能避免数据冲突。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005596&quot; data-ratio=&quot;1.4489795918367347&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcfKVAZTG2nMVIiaCzEoPm8O2VMiaBeawEuqHlCN3q6ec6SfLRTJyQ55m2w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2695&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;提醒：这 3 种常见的分片规则，第一次看不太好理解，建议配合图多理解几遍。搞懂这 3 个分片规则，你才能真正明白怎么做异地多活。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之，分片的核心思路在于，&lt;span&gt;&lt;strong&gt;让同一个用户的相关请求，只在一个机房内完成所有业务「闭环」，不再出现「跨机房」访问。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阿里在实施这种方案时，给它起了个名字，叫做「&lt;span&gt;&lt;strong&gt;单元化&lt;/strong&gt;&lt;/span&gt;」。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;当然，最上层的路由层把用户分片后，理论来说同一个用户只会落在同一个机房内，但不排除程序 Bug 导致用户会在两个机房「漂移」。&lt;/p&gt;&lt;p&gt;安全起见，每个机房在写存储时，还需要有一套机制，能够检测「数据归属」，应用层操作存储时，需要通过中间件来做「兜底」，避免不该写本机房的情况发生。（篇幅限制，这里不展开讲，理解思路即可）&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，两个机房就可以都接收「读写」流量（做好分片的请求），底层存储保持「双向」同步，两个机房都拥有全量数据，当任意机房故障时，另一个机房就可以「接管」全部流量，实现快速切换，简直不要太爽。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不仅如此，因为机房部署在异地，我们还可以更细化地「优化」路由规则，让用户访问就近的机房，这样整个系统的性能也会大大提升。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里还有一种情况，是无法做数据分片的：&lt;strong&gt;全局数据&lt;/strong&gt;。例如系统配置、商品库存这类需要强一致的数据，这类服务依旧只能采用写主机房，读从机房的方案，不做双活。&lt;/p&gt;&lt;p&gt;双活的重点，是要优先保证「核心」业务先实现双活，并不是「全部」业务实现双活。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，我们才算实现了真正的「&lt;span&gt;&lt;strong&gt;异地双活&lt;/strong&gt;&lt;/span&gt;」！&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;到这里你可以看出，完成这样一套架构，需要投入的成本是巨大的。&lt;/p&gt;&lt;p&gt;路由规则、路由转发、数据同步中间件、数据校验兜底策略，不仅需要开发强大的中间件，同时还要业务配合改造（业务边界划分、依赖拆分）等一些列工作，没有足够的人力物力，这套架构很难实施。&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11 异地多活&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解了异地双活，那「异地多活」顾名思义，就是在异地双活的基础上，部署多个机房即可。架构变成了这样：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100005592&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0434153400868307&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcfVTJpgibGpeD09iaHBWDgZIvJBUiaEB71cuKQn8aaia4BdSZuUyRqxxia9Bg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3455&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些服务按照「单元化」的部署方式，可以让每个机房部署在任意地区，随时扩展新机房，你只需要在最上层定义好分片规则就好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这里还有一个小问题，随着扩展的机房越来越多，当一个机房写入数据后，需要同步的机房也越来越多，这个实现复杂度会比较高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以业界又把这一架构又做了进一步优化，把「网状」架构升级为「星状」：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100005595&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0434153400868307&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3P7ZQyj3f4FMb7M48Bv6qcfpDq3ykd22PK3ZzIPTHcqxHdXboxrEmnLkJbNVDnGIVWHPunkPoNLlQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3455&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案必须设立一个「中心机房」，任意机房写入数据后，都只同步到中心机房，再由中心机房同步至其它机房。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样做的好处是，一个机房写入数据，只需要同步数据到中心机房即可，不需要再关心一共部署了多少个机房，实现复杂度大大「简化」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但与此同时，这个中心机房的「稳定性」要求会比较高。不过也还好，即使中心机房发生故障，我们也可以把任意一个机房，提升为中心机房，继续按照之前的架构提供服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，我们的系统彻底实现了「&lt;span&gt;&lt;strong&gt;异地多活&lt;/strong&gt;&lt;/span&gt;」！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多活的优势在于，&lt;strong&gt;&lt;span&gt;可以任意扩展机房「就近」部署。任意机房发生故障，可以完成快速「切换」&lt;/span&gt;&lt;/strong&gt;，大大提高了系统的可用性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，我们也再也不用担心系统规模的增长，因为这套架构具有极强的「&lt;strong&gt;&lt;span&gt;扩展能力&lt;/span&gt;&lt;/strong&gt;」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么样？我们从一个最简单的应用，一路优化下来，到最终的架构方案，有没有帮你彻底理解异地多活呢？&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，总结一下这篇文章的重点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、一个好的软件架构，应该遵循高性能、高可用、易扩展 3 大原则，其中「高可用」在系统规模变得越来越大时，变得尤为重要&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、系统发生故障并不可怕，能以「最快」的速度恢复，才是高可用追求的目标，异地多活是实现高可用的有效手段&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、提升高可用的核心是「冗余」，备份、主从副本、同城灾备、同城双活、两地三中心、异地双活，异地多活都是在做冗余&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、同城灾备分为「冷备」和「热备」，冷备只备份数据，不提供服务，热备实时同步数据，并做好随时切换的准备&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、同城双活比灾备的优势在于，两个机房都可以接入「读写」流量，提高可用性的同时，还提升了系统性能。虽然物理上是两个机房，但「逻辑」上还是当做一个机房来用&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6、两地三中心是在同城双活的基础上，额外部署一个异地机房做「灾备」，用来抵御「城市」级别的灾害，但启用灾备机房需要时间&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7、异地双活才是抵御「城市」级别灾害的更好方案，两个机房同时提供服务，故障随时可切换，可用性高。但实现也最复杂，理解了异地双活，才能彻底理解异地多活&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;8、异地多活是在异地双活的基础上，任意扩展多个机房，不仅又提高了可用性，还能应对更大规模的流量的压力，扩展性最强，是实现高可用的最终方案&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;后记&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章我从「宏观」层面，向你介绍了异地多活架构的「核心」思路，整篇文章的信息量还是很大的，如果不太好理解，我建议你多读几遍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为篇幅限制，很多细节我并没有展开来讲。这篇文章更像是讲异地多活的架构之「道」，而真正实施的「术」，要考虑的点其实也非常繁多，因为它需要开发强大的「基础设施」才可以完成实施。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不仅如此，要想真正实现异地多活，还需要遵循一些原则，例如业务梳理、业务分级、数据分类、数据最终一致性保障、机房切换一致性保障、异常处理等等。同时，相关的运维设施、监控体系也要能跟得上才行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;宏观上需要考虑业务（微服务部署、依赖、拆分、SDK、Web 框架）、基础设施（服务发现、流量调度、持续集成、同步中间件、自研存储），微观上要开发各种中间件，还要关注中间件的高性能、高可用、容错能力，其复杂度之高，只有亲身参与过之后才知道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我曾经有幸参与过，存储层同步中间件的设计与开发，实现过「跨机房」同步 MySQL、Redis、MongoDB 的中间件，踩过的坑也非常多。当然，这些中间件的设计思路也非常有意思，有时间单独分享一下这些中间件的设计思路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得提醒你的是，只有真正理解了「异地双活」，才能彻底理解「异地多活」。在我看来，从同城双活演变为异地双活的过程，是最为复杂的，最核心的东西包括，&lt;span&gt;&lt;strong&gt;业务单元化划分、存储层数据双向同步、最上层的分片逻辑&lt;/strong&gt;&lt;/span&gt;，这些是实现异地多活的重中之重。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希望我分享的架构经验，对你有所启发。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在写这篇文章时，我又仔细阅读了阿里、饿了么、微博等公司，关于异地多活架构设计的相关资料，如果你想更深入地学习异地多活架构，可以在我的公众号后台回复「异地多活」获取。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3ac9a13c4a1f3fbd1995bcf4bd196338</guid>
<title>Netflix 实用 API 设计（下）</title>
<link>https://toutiao.io/k/4a6irp8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;gRPC如今被很多公司应用在大规模生产环境中，很多时候我们并不需要通过RPC请求所有数据，而只关心响应数据中的部分字段，Protobuf FieldMask就可以帮助我们实现这一目的。本文介绍了Netflix基于FieldMask设计更高效健壮的API的实践，全文分两个部分，这是第二部分。原文：Practical API Design at Netflix, Part 2: Protobuf FieldMask for Mutation Operations&lt;span&gt;[1]&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;背景&lt;/h1&gt;&lt;p&gt;在上一篇文章中，我们讨论了在设计API时如何利用FieldMask&lt;span&gt;[2]&lt;/span&gt;作为解决方案，以便消费者可以只请求他们需要的数据。在这篇文章中，我们将继续介绍Netflix Studio Engineering如何基于FieldMask进行更新和删除等变更操作。&lt;/p&gt;&lt;h1&gt;示例：Netflix工作室内容制作&lt;/h1&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6662857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0XOpuEsdG37b2DXs4eBOd4RgkSK2aEOW4KoPvnLjXRH0LSBFAY4k4hibehhvQYvsU45pLODqlqwuibA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;875&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;《纸钞屋》(La casa de papel) / Netflix&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTgxODgwNA==&amp;amp;mid=2247484187&amp;amp;idx=1&amp;amp;sn=66667c6c29ae80569556f148746d5804&amp;amp;chksm=fc73bec0cb0437d678e7c0600a51ca751424c16577934c2875670f67b2c54beca36bed79a043&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;上一篇文章&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;上一篇文章&lt;/a&gt;我们概述了什么是Production，以及Production服务如何对其他微服务（如Schedule服务和Script服务)进行gRPC调用，以检索特定产品（如《纸钞屋》）的日程和脚本（即剧本）。我们将继续利用这个示例并展示如何在生产中改变特定字段。&lt;/p&gt;&lt;h1&gt;改变制作细节&lt;/h1&gt;&lt;p&gt;假设我们为剧集添加了一些动画元素，因此想将&lt;code&gt;format&lt;/code&gt;字段从&lt;code&gt;LIVE_ACTION&lt;/code&gt;更新为&lt;code&gt;HYBRID&lt;/code&gt;。解决这个问题的简单方法是添加一个updateProductionFormatRequest方法以及对应的gRPC endpoint来更新productionFormat：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;message UpdateProductionFormatRequest &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  string id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;  ProductionFormat format &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;service ProductionService &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  rpc UpdateProductionFormat &lt;span&gt;(&lt;/span&gt;UpdateProductionFormatRequest&lt;span&gt;)&lt;/span&gt; &lt;br/&gt;      returns &lt;span&gt;(&lt;/span&gt;UpdateProductionFormatResponse&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这允许我们更新特定产品的生产格式，但如果我们想要更新其他字段，如&lt;code&gt;title&lt;/code&gt;，甚至多个字段，如&lt;code&gt;productionFormat&lt;/code&gt;, &lt;code&gt;schedule&lt;/code&gt;，等等，该怎么办?在此基础上，我们可以为每个字段执行一个更新方法：一个用于生产格式，另一个用于标题，等等：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// separate RPC for every field, not recommended&lt;/span&gt;&lt;br/&gt;service ProductionService &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  rpc UpdateProductionFormat &lt;span&gt;(&lt;/span&gt;UpdateProductionFormatRequest&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  rpc UpdateProductionTitle &lt;span&gt;(&lt;/span&gt;UpdateProductionTitleRequest&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  rpc UpdateProductionSchedule &lt;span&gt;(&lt;/span&gt;UpdateProductionScheduleRequest&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  rpc UpdateProductionScripts &lt;span&gt;(&lt;/span&gt;UpdateProductionScriptsRequest&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;message UpdateProductionFormatRequest &lt;span&gt;{&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;message UpdateProductionTitleRequest &lt;span&gt;{&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;message UpdateProductionScheduleRequest &lt;span&gt;{&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;message UpdateProductionScriptsRequest &lt;span&gt;{&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于Production上的字段数量太多，这将变得越来越难以维护。如果我们想要在单个RPC中以原子方式更新多个字段，该怎么办？为不同的字段组合创建额外的方法将导致变更API激增，因此这个解决方案是不可扩展的。&lt;/p&gt;&lt;p&gt;与其尝试创建所有可能的单一组合，另一种解决方案可能是定义一个&lt;code&gt;UpdateProduction&lt;/code&gt; endpoint，用来处理所有字段：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;message Production &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  string id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;  string title &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;  ProductionFormat format &lt;span&gt;=&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;  repeated ProductionScript scripts &lt;span&gt;=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;  ProductionSchedule schedule &lt;span&gt;=&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// ... more fields&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;service ProductionService &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  rpc UpdateProduction &lt;span&gt;(&lt;/span&gt;UpdateProductionRequest&lt;span&gt;)&lt;/span&gt; returns &lt;span&gt;(&lt;/span&gt;UpdateProductionResponse&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;message UpdateProductionRequest &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  Production production &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个解决方案有两个问题。首先，消费者必须知道并提供Production中每个必需的字段，即使他们只想更新一个字段，比如format。其次，由于Production有许多字段，所以请求的有效负载可能会变得非常大，尤其是在包含了schedule或script信息的时候。&lt;/p&gt;&lt;p&gt;如果我们只发送真正想要更新的字段，而不设置所有字段，会怎么样？在示例中，我们只设置production format字段（以及引用production的ID）：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;UpdateProduction updateProduction &lt;span&gt;=&lt;/span&gt; UpdateProduction&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newBuilder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;setProductionFormat&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;PRODUCTION_FORMAT_HYBRID&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Send the update request&lt;/span&gt;&lt;br/&gt;UpdateProductionResponse response &lt;span&gt;=&lt;/span&gt; client&lt;span&gt;.&lt;/span&gt;&lt;span&gt;updateProduction&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;LA_CASA_DE_PAPEL_PRODUCTION_ID&lt;span&gt;,&lt;/span&gt; &lt;br/&gt;    updateProductionRequest&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果我们永远不需要删除字段（或者把字段置为空），那这就可以工作了。但是，如果我们想要删除&lt;code&gt;title&lt;/code&gt;字段的值，该怎么办？同样，我们也可以引入一次性方案，如&lt;code&gt;RemoveProductionTitle&lt;/code&gt;，但正如上面讨论过的，这种解决方案伸缩性不好。如果我们想从日程计划中删除嵌套字段（如计划启动日期字段）的值，又该怎么办？我们最终会为每个可置空的子字段添加删除RPC。&lt;/p&gt;&lt;h1&gt;利用FieldMask进行变更操作&lt;/h1&gt;&lt;p&gt;除了定义大量的RPC，以及承受巨大的消息载荷，我们还可以利用FieldMask来实现所有的变更。FieldMask可以列出我们想明确更新的所有字段。首先，更新proto文件，加入&lt;code&gt;UpdateProductionRequest&lt;/code&gt;，包含我们想在Production中更新的数据，以及应该被更新的FieldMask。&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;message ProductionUpdateOperation &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  string production_id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;  string title &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;  ProductionFormat format &lt;span&gt;=&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;  ProductionSchedule schedule &lt;span&gt;=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;  repeated ProductionScript scripts &lt;span&gt;=&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt; &lt;span&gt;// more fields&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;message UpdateProductionRequest &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// contains production ID and fields to be updated&lt;/span&gt;&lt;br/&gt;  ProductionUpdateOperation update &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;  google&lt;span&gt;.&lt;/span&gt;protobuf&lt;span&gt;.&lt;/span&gt;FieldMask update_mask &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在，我们可以利用FieldMask进行变更，通过使用FieldMaskUtil.fromStringList()&lt;span&gt;[3]&lt;/span&gt;方法为&lt;code&gt;format&lt;/code&gt;字段创建一个FieldMask来更新format，该方法为特定类型的字段路径列表构造一个FieldMask。在本例中，我们设置了一个类型，稍后将在这个示例的基础上进行构建：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;FieldMask updateFieldMask &lt;span&gt;=&lt;/span&gt; FieldMaskUtil&lt;span&gt;.&lt;/span&gt;&lt;span&gt;fromStringList&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Production&lt;span&gt;.&lt;/span&gt;class&lt;span&gt;,&lt;/span&gt; &lt;br/&gt;    Collections&lt;span&gt;.&lt;/span&gt;&lt;span&gt;singletonList&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;“format”&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Update the production format type&lt;/span&gt;&lt;br/&gt;ProductionUpdateOperation productionUpdateOperation &lt;span&gt;=&lt;/span&gt; ProductionUpdateOperation&lt;br/&gt;    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;newBuilder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;setProductionId&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;LA_CASA_DE_PAPEL_PRODUCTION_ID&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;setProductionFormat&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;PRODUCTION_FORMAT_HYBRID&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Build the UpdateProductionRequest including the updatefieldmask&lt;/span&gt;&lt;br/&gt;UpdateProductionRequest updateProductionRequest &lt;span&gt;=&lt;/span&gt; UpdateProductionRequest&lt;br/&gt;    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;newBuilder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;setUpdate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;productionUpdateOperation&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;setUpdateMask&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;updateFieldMask&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Send the update request&lt;/span&gt;&lt;br/&gt;UpdateProductionResponse response &lt;span&gt;=&lt;/span&gt; &lt;br/&gt;    client&lt;span&gt;.&lt;/span&gt;&lt;span&gt;updateProduction&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;LA_CASA_DE_PAPEL_PRODUCTION_ID&lt;span&gt;,&lt;/span&gt; updateProductionRequest&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于我们在FieldMask中只指定了&lt;code&gt;format&lt;/code&gt;字段，因此即使我们在&lt;code&gt;ProductionUpdateOperation&lt;/code&gt;中提供了更多的数据，也只有&lt;code&gt;format&lt;/code&gt;会被更新。通过修改路径，可以容易的在FieldMask中添加或删除更多字段。在有效负载中提供但没有添加到FieldMask路径中的数据将不会被更新，并在操作中被忽略。但是，如果我们省略了一个值，它将在该字段上执行remove操作。我们修改上面的例子来展示，更新format，但删除计划的启动日期，这是&lt;code&gt;ProductionSchedule&lt;/code&gt;上的一个嵌套字段“schedule.planned_launch_date”：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;FieldMask updateFieldMask &lt;span&gt;=&lt;/span&gt; FieldMaskUtil&lt;span&gt;.&lt;/span&gt;&lt;span&gt;fromStringList&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Production&lt;span&gt;.&lt;/span&gt;class&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;    Arrays&lt;span&gt;.&lt;/span&gt;&lt;span&gt;asList&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;format&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;schedule.planned_launch_date&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Update the format, in addition remove schedule.planned_launch_date by not including it in our request&lt;/span&gt;&lt;br/&gt;ProductionUpdateOperation productionUpdateOperation &lt;span&gt;=&lt;/span&gt; ProductionUpdateOperation&lt;br/&gt;    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;newBuilder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;setProductionId&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;LA_CASA_DE_PAPEL_PRODUCTION_ID&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;setProductionFormat&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;PRODUCTION_FORMAT_HYBRID&lt;span&gt;)&lt;/span&gt;   &lt;br/&gt;    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;UpdateProductionRequest updateProductionRequest &lt;span&gt;=&lt;/span&gt; UpdateProductionRequest&lt;br/&gt;    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;newBuilder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;setUpdate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;productionUpdateOperation&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;setUpdateMask&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;updateFieldMask&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Send the update request&lt;/span&gt;&lt;br/&gt;UpdateProductionResponse response &lt;span&gt;=&lt;/span&gt; &lt;br/&gt;    client&lt;span&gt;.&lt;/span&gt;&lt;span&gt;updateProduction&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;LA_CASA_DE_PAPEL_PRODUCTION_ID&lt;span&gt;,&lt;/span&gt; updateProductionRequest&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;在这个例子中，我们添加了“format”和“schedule.planned_launch_date”，执行了一次更新和一次删除操作。如果我们在有效负载中提供了字段&lt;/span&gt;值&lt;span&gt;，对应的字段将被更新为新的值。&lt;/span&gt;&lt;span&gt;但是当构建有效负载时，我们只提供了&lt;/span&gt;&lt;code&gt;format&lt;/code&gt;&lt;span&gt;，而省略了&lt;/span&gt;&lt;code&gt;schedule.planned_launch_date&lt;/code&gt;&lt;span&gt;，像这样在FieldMask中有定义，但是在有效负载中没有，将作为一个remove操作：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3516666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0XOpuEsdG37b2DXs4eBOd4RCMM6ssHI3c7ceczrdaenxkzYpx3icEibO4GKzoSXvnqIyHn2rJP8BnbA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;空的/缺失的字段掩码&lt;/h1&gt;&lt;p&gt;当字段掩码未设置或没有路径时，更新操作将应用于所有有效负载字段。这意味着调用者必须发送整个有效负载，否则，如上所述，任何未设置的字段都将被删除。&lt;/p&gt;&lt;p&gt;这个约定会影响到schema的变更：当一个新字段被添加到消息中时，所有的消费者都必须在更新操作上发送它的值，否则它将被删除。&lt;/p&gt;&lt;p&gt;假设我们想添加一个新字段：生产预算。我们将同时扩展&lt;code&gt;Production&lt;/code&gt;消息和&lt;code&gt;ProductionUpdateOperation&lt;/code&gt;：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// update operation with new ‘budget’ field&lt;/span&gt;&lt;br/&gt;message ProductionUpdateOperation &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  string production_id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;  string title &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;  ProductionFormat format &lt;span&gt;=&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;  ProductionSchedule schedule &lt;span&gt;=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;  repeated ProductionScript scripts &lt;span&gt;=&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;  ProductionBudget budget &lt;span&gt;=&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;            &lt;span&gt;// new field&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果消费者不知道这个新字段或者还没有更新客户端，它可能会由于没有在更新请求中发送FieldMask字段而意外的把预算字段置空。&lt;/p&gt;&lt;p&gt;为了避免这种问题，生产者应该考虑为所有更新操作请求设置字段掩码。另一种选择是实现版本控制协议：强制所有调用者发送他们的版本号，并实现自定义逻辑以跳过旧版本中不存在的字段。&lt;/p&gt;&lt;h1&gt;最后&lt;/h1&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.4011428571428572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0XOpuEsdG37b2DXs4eBOd4RNia0gSxX3FPeC2HC5IU3yCaTOG44CnBeQp1ZBcnWPK0ykefKmAs49KQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;875&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在这个系列文章中，介绍了我们如何在Netflix使用FieldMask，以及如何设计一个实用的、可扩展的API解决方案。&lt;/p&gt;&lt;p&gt;API设计者应该以简单为目标，但要考虑API的扩展和演进。保持API的简单性和可预测性通常并不容易。通过使用FieldMask，可以帮助我们实现简单和灵活的API。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;References:&lt;/span&gt;&lt;br/&gt;[1] https://netflixtechblog.com/practical-api-design-at-netflix-part-2-protobuf-fieldmask-for-mutation-operations-2e75e1d230e4&lt;br/&gt;[2] https://developers.google.com/protocol-buffers/docs/reference/csharp/class/google/protobuf/well-known-types/field-mask&lt;br/&gt;[3] https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/util/FieldMaskUtil.html#fromStringList-java.lang.Class-java.lang.Iterable-&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。&lt;br/&gt;微信公众号：DeepNoMind&lt;/p&gt;&lt;/blockquote&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>25042e8fe08223de598644e58501a5de</guid>
<title>吃透负载均衡</title>
<link>https://toutiao.io/k/7tctele</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzk0MzI4OTI1Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHhKgtwWvzaYZodgfpphdA6WWKEMXTn6ImCCCuEzlPKicNBcpzBUyjK1XicWwqIwusqLGpwyyOc87JPQ/0?wx_fmt=png&quot; data-nickname=&quot;高性能架构探索&quot; data-alias=&quot;&quot; data-signature=&quot;85后程序员，毕业于中国科学技术大学。现任某互联网公司高级技术专家一职。分享一些工作中的心得，杂谈。聊聊架构，扯扯算法，就酱。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是雨乐。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先告诉大家一件事，在十一国庆期间，引擎的机器又又。。。又扛不住了流量。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100001144&quot; data-ratio=&quot;0.21746160064672596&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZybpN9t6ERsqX6dduqx43F3Z9nVug5BauLQ0OTw4DyLdW6Qz7NINoLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1237&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过监控分析，发现某个服务的一个实例所在的虚拟机扛不住了，所以采取临时措施&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247484677&amp;amp;idx=1&amp;amp;sn=dbf3afa848db5026227c1d87cfc3b3dc&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;流量控制&lt;/a&gt;之后，问题解决了，但还是造成了不小的损失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过此次故障，以及分析故障的过程中对负载均衡又有了新的更加深入的认识，所以将这部分写出来，算是做个故障总结吧&lt;img data-fileid=&quot;100001176&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZCz4AwVibhjMcfw3Amhmfl5BSaQSQvicCnDibQTZloIgA3syicbqRzEccRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;624&quot; data-backw=&quot;558&quot; data-fileid=&quot;100001177&quot; data-ratio=&quot;1.1177536231884058&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZsnycQ1BjVrcmeI7CYcHzRlEeqg8ribbq9vDK0LtQcRzGXUlEIpnLMoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1104&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;写在前面&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写本文的目的：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阅读这篇文章需要的条件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对OSI模型有些许了解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有耐心。本文涉及大量的知识点，且只能用文字才能讲清楚，所以文字比较多。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;收获：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;读完此篇文章，从宏观的角度理解了负载均衡的原理以及实现机制。加深对分布式架构的了解&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要内容：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;本文首先从概念开始，讲解什么是负载均衡，以及负载均衡在分布式系统中所承担的角色以及提供的功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;讲解负载均衡的分类。分别从 &lt;em&gt;&lt;strong&gt;软硬件角度&lt;/strong&gt;&lt;/em&gt;、&lt;em&gt;&lt;strong&gt;地域范围角度&lt;/strong&gt;&lt;/em&gt; 以及 &lt;em&gt;&lt;strong&gt;OSI模型角度&lt;/strong&gt;&lt;/em&gt; 进行分类讲解负载均衡的实现方案。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从负载均衡的策略角度来分析目前业界的负载均衡算法以及其优缺点&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，准备好了么，让我们开始这次愉快之旅。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100001147&quot; data-ratio=&quot;0.7866666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZMfhiaQ2fA0HtfmJIe36wGWMicXuLfOFm5798qbVZOT7b2TXocVq0Vd9Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/span&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先 &lt;em&gt;&lt;strong&gt;撇开对线上的影响&lt;/strong&gt;&lt;/em&gt;，如果线上突发来了流量,后端服务扛不住，我们会怎么做呢？无非两种方式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面两种方式，我们称之为纵向扩展和横向扩展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;纵向扩展，是从单机的角度通过增加硬件处理能力，比如CPU处理能力，内存容量，磁盘等方面，实现服务器处理能力的提升，不能满足大型分布式系统（网站），大流量，高并发，海量数据的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;横向扩展，通过添加机器来满足大型网站服务的处理能力。比如：一台机器不能满足，则增加两台或者多台机器，共同承担访问压力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;3&lt;/span&gt;&lt;/span&gt;&lt;span&gt;概念&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;负载均衡，英文名称为Load Balance，其含义就是指将负载（工作任务或者网络请求）进行平衡，分摊到多个操作单元(服务器或者组件)上进行运行。目的是尽量将网络流量 &lt;em&gt;&lt;strong&gt;平均&lt;/strong&gt;&lt;/em&gt; 发送到多个服务器上，以保证整个业务系统的高可用。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;417&quot; data-backw=&quot;558&quot; data-fileid=&quot;100001145&quot; data-ratio=&quot;0.7474949899799599&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZ0vU1o4Z6DQLZjmAFLcaEym9kmjR119pdoI0eHlUTtcxcB62Q5KrFoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;998&quot;/&gt;&lt;figcaption&gt;负载均衡&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在互联网的早期，网络还不是很发达，流量相对较小，业务也比较简单，单台服务器或者实例就有可能满足访问需要。但如今在互联网发达的今天，流量请求动辄百亿、甚至上千亿，单台服务器或者实例已完全不能满足需求，这就有了集群。不论是为了实现高可用还是高性能，都需要用到多台机器来扩展服务能力，用户的请求不管连接到哪台服务器，都能得到相同的相应处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一方面，如何构建和调度服务集群这事情，又必须对用户一侧保持足够的透明，即使请求背后是由一千台、一万台机器来共同响应的，也绝非用户所关心的事情，用户需记住的只有一个域名地址而已。调度后方的多台机器，以统一的接口对外提供服务，承担此职责的技术组件被称为 &lt;em&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;&lt;/em&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;负载均衡主要有以下作用：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;高并发。通过采取一定的算法策略，将流量尽可能的均匀发送给后端的实例，以此提高集群的并发处理能力。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;伸缩性。根据网络流量的大小，增加或者减少后端服务器实例，由负载均衡设备进行控制，这样使得集群具有伸缩性。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;高可用。负载均衡器通过算法或者其他性能数据来监控候选实例，当实例负载过高或者异常时，减少其流量请求或者直接跳过该实例，将请求发送个其他可用实例，这使得集群具有高可用的特性。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;安全防护。有些负载均衡器提供了安全防护功能。如：黑白名单处理、防火墙等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/span&gt;&lt;span&gt;分类&lt;/span&gt;&lt;/h2&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;根据载体类型分类&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从支持负载均衡的载体来看，可以将负载均衡分为两类：&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;硬件负载均衡&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;硬件负载平衡器是一种硬件设备，具有专门的操作系统。硬件负载平衡器位于传入流量和内部服务器之间，本质上充当“流量警察”。当用户访问网站或者使用app某个功能时，它们首先被发送到负载均衡器，然后负载均衡器根据一定的策略，将流量转发到后端不同的服务器。为确保最佳性能，硬件负载均衡器根据自定义规则分配流量，以免后端实例不堪重负。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传统上，硬件负载平衡器和应用服务器部署在本地数据中心，负载平衡器的数量取决于预期的峰值流量。负载均衡器通常成对部署，以防其中一个失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前业界领先的两款硬件负载均衡器：F5和A10&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;330&quot; data-backw=&quot;558&quot; data-fileid=&quot;100001146&quot; data-ratio=&quot;0.5915279878971256&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZJicTUIfKKSRlCJzJqEqAPMka4C7ule6AWfM71WyoDYjqh2tCEqiaEN0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1322&quot;/&gt;&lt;figcaption&gt;硬件负载均衡&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;功能强大：支持全局负载均衡并提供较全面的、复杂的负载均衡算法。&lt;/p&gt;&lt;p&gt;性能强悍：硬件负载均衡由于是在专用处理器上运行，因此吞吐量大，可支持单机百万以上的并发。&lt;/p&gt;&lt;p&gt;安全性高：往往具备防火墙，防 DDos 攻击等安全功能。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;成本昂贵：购买和维护硬件负载均衡的成本都很高(：F5价格在15w~55w不等，A10价格在55w-100w不等)。&lt;/p&gt;&lt;p&gt;扩展性差：当访问量突增时，超过限度不能动态扩容。&lt;/p&gt;&lt;/blockquote&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;软件负载均衡&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件负载均衡指的是在服务器的操作系统上安装负载均衡软件，从此服务器发出的请求经软件负载均衡算法路由到后端集群的某一台机器上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见负载均衡软件有：LVS、Nginx、Haproxy。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;321&quot; data-backw=&quot;558&quot; data-fileid=&quot;100001151&quot; data-ratio=&quot;0.5761973875181422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZqibffL3x9vc43L1ZmibOW6BSaN45ibHsHoe9M8U9qgicqnSVHtJOzibXh7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1378&quot;/&gt;&lt;figcaption&gt;软件负载均衡&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;扩展性好：适应动态变化，可以通过添加软件负载均衡实例，动态扩展到超出初始容量的能力。&lt;/p&gt;&lt;p&gt;成本低廉：软件负载均衡可以在任何标准物理设备上运行，降低了购买和运维的成本。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;性能略差：相比于硬件负载均衡，软件负载均衡的性能要略低一些。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;软硬件负载均衡器的区别&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;硬件负载平衡器与软件负载平衡器之间最明显的区别在于，硬件负载平衡器需要专有的机架堆叠硬件设备，而软件负载平衡器只需安装在标准 x86 服务器或虚拟机上。网络负载平衡器硬件通常是过度配置的——换句话说，它们的大小能够处理偶尔的高峰流量负载。此外，每个硬件设备都必须与一个额外的设备配对以获得高可用性，以防其他负载均衡器出现故障。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;硬件和软件负载平衡器之间的另一个关键区别在于扩展能力。随着网络流量的增长，数据中心必须提供足够的负载均衡器以满足峰值需求。对于许多企业来说，这意味着大多数负载均衡器在高峰流量时间（例如黑色星期五）之前一直处于空闲状态。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果流量意外超出容量，最终用户体验会受到显着影响。另一方面，软件负载平衡器能够弹性扩展以满足需求。无论网络流量是低还是高，软件负载平衡器都可以简单地实时自动扩展，消除过度配置成本和对意外流量激增的担忧。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;此外，硬件负载平衡器配置可能很复杂。基于软件定义原则构建的软件负载平衡器跨多个数据中心和混合/多云环境。事实上，硬件设备与云环境不兼容，而软件负载均衡器与裸机、虚拟、容器和云平台兼容。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;根据地域范围分类&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;负载均衡从其应用的地理结构上分为本地负载均衡(Local Load Balance)和全局负载均衡(Global Load Balance，也叫地域负载均衡)。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100001153&quot; data-ratio=&quot;0.79421768707483&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZ61u15fNmfPpp8wkHuh91J2zK16AGYUWkGqkyzu97sibfmRYczF4icCBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1176&quot;/&gt;&lt;figcaption&gt;地域负载均衡&lt;/figcaption&gt;&lt;/figure&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;本地负载均衡&lt;span/&gt;&lt;/h6&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本地负载均衡是指对本地的服务器群做负载均衡。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地负载均衡针对本地范围的服务器群做负载均衡，本地负载均衡不需要花费高额成本购置高性能服务器，只需利用现有设备资源,就可有效避免服务器单点故障造成数据流量的损失，通常用来解决数据流量过大、网络负荷过重的问题。同时它拥有形式多样的均衡策略把数据流量合理均衡的分配到各台服务器。如果需要在现在服务器上升级扩充，不需改变现有网络结构、停止现有服务，仅需要在服务群中简单地添加一台新服务器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地负载均衡能有效地解决数据流量过大、网络负荷过重的问题，并且不需花费昂贵开支购置性能卓越的服务器，充分利用现有设备，避免服务器单点故障造成数据流量的损失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其有灵活多样的均衡策略把数据流量合理地分配给服务器群内的服务器共同负担。即使是再给现有服务器扩充升级，也只是简单地增加一个新的服务器到服务群中，而不需改变现有网络结构、停止现有的服务。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;全局负载均衡&lt;span/&gt;&lt;/h6&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;全局负载均衡是指对分别放置在不同的地理位置、有不同网络结构的服务器群间作负载均衡。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全局负载均衡主要用于在一个多区域拥有自己服务器的站点，为了使全球用户只以一个IP地址或域名就能访问到离自己最近的服务器，从而获得最快的访问速度，也可用于子公司分散站点分布广的大公司通过Intranet(企业内部互联网)来达到资源统一合理分配的目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全局负载均衡，目前实现方式有以下几种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过运营商线路调度：这个主要是指国内，由于特殊原因国内不同运营商互联互通存在很大问题，比如联通用户访问电信机房服务器延迟很大，甚至有可能无法访问的情况。假如您的业务部署在不同运营商机房，可以通过运营商线路解析来实现调度，联通线路用户域名解析到联通机房IP，电信线路用户域名解析电信机房IP，这样保证不同用户访问最佳的服务器。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过地域线路调度：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我们都知道，网站服务器越近，访问速度越快，比如天津用户访问北京服务器会比广州服务器快很多。假如您的业务部署在华北，华南两个Region，可以通过地域线路解析，设置华北，东北，西北，华中用户访问域名解析到北京服务器IP，华东，华南，西南用户访问域名解析到广州服务器IP，这样用户访问离自己最近的服务器可以提升访问体验。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假如您的业务是面向全球的，国内部署有业务，海外也部署有业务，可以选择中国用户访问域名解析到国内服务器，海外用户访问域名解析到海外服务器。当然海外的还可以细分，比如选择亚太--新加坡的用户等，可以具体到洲，国家。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;权重轮询：比如一个域名解析到多个IP，可以根据不同IP服务器的配置，业务情况设置解析比重，比如2:1或者1:1等等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;健康检查，故障转移：可以创建监控任务实时监控后端服务器IP的健康状态，如果发现后端服务器异常，可以把解析流量切换到其他正常的服务器或者备用服务器，保证业务不会中断。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CDN的全称是Content Delivery Network，即内容分发网络。其就是采用的全局负载均衡。假如我们将图片存储在CDN上，且该CDN所在厂家在北京、杭州均有服务器。那么：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当天津的用户需要下载该图片的时候，会自动将流量请求转发至距离其最近的CDN服务器，也就是北京&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当安徽的用户需要下载图片的时候，就会将流量请求转发至杭州。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;根据OSI网络模型分类&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100001152&quot; data-ratio=&quot;0.7271241830065359&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZN0XfQsmm3AA456JJ7jO2tDXsSocNz7gYg2rv13b81BzOZP2avFmWeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1224&quot;/&gt;OSI是一个开放性的通信系统互连参考模型，如上图所示。在OSI参考模型中，分别有：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图可以看出：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;TELNET、HTTP、FTP、NFS、SMTP、DNS等属于第七层应用层的概念。&lt;/p&gt;&lt;p&gt;TCP、UDP、SPX等属于第四层传输层的概念。&lt;/p&gt;&lt;p&gt;IP、IPX等属于第三层网络层的概念。&lt;/p&gt;&lt;p&gt;ATM、FDDI等属于第二层数据链路层的概念。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据负载均衡技术实现在OSI七层模型的不同层次，我们给负载均衡分类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;七层负载均衡：工作在应用层的负载均衡称&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;四层负载均衡：工作在传输层的负载均衡称&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;三层负载均衡：工作在网络层的负载均衡，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;二层负载均衡：工作在数据链路层的负载均衡。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100001150&quot; data-ratio=&quot;0.7871720116618076&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZJDibsFYZ1hZe0mUdJDnhlrjO1Y5tTEBfsqyNQPhpytOMZ42z5VpqpTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1372&quot;/&gt;&lt;/figure&gt;&lt;br/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;&lt;strong&gt;其中最常用的是四层和七层负载均衡&lt;/strong&gt;&lt;/em&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们将从OSI模型从下往上的顺序，来详细讲解上述几种负载均衡。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;二层负载均衡&lt;span/&gt;&lt;/h6&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;工作在数据链路层的负载均衡称之为二层负载均衡(又称为数据链路层负载均衡)，通过在通信协议的数据链路层修改mac地址进行负载均衡。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二层负载均衡是基于数据链路层的负载均衡，即让负载均衡服务器和业务服务器绑定同一个虚拟IP（即VIP），客户端直接通过这个VIP进行请求集群。集群中不同的机器采用相同IP地址，但是机器的MAC地址不一样。当负载均衡服务器接受到请求之后，通过改写报文的目标MAC地址的方式将请求转发到目标机器实现负载均衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据链路层负载均衡所做的工作，是修改请求的数据帧中的 MAC 目标地址，让用户原本是发送给负载均衡器的请求的数据帧，被二层交换机根据新的 MAC 目标地址转发到服务器集群中对应的服务器（真实服务器）的网卡上，这样真实服务器就获得了一个原本目标并不是发送给它的数据帧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了便于理解，我们假设负载均衡器所在的ip地址为192.168.1.1，后端服务实例的mac地址分别为52:54:00:A1:CB:F7，61:52:00:A2:BD, 71:63:52:A3:CA。如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100001149&quot; data-ratio=&quot;0.6395348837209303&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZPibugJXtgo2zGBCHSmRLjmHGW4lp5Ir2eX7bfQzxYcI21ibIiaTf6G4Vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1204&quot;/&gt;&lt;figcaption&gt;二层负载均衡&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，用户的请求首先到达ip为192.168.1.1的二层负载均衡器，然后二层负载均衡器通过采取一定的策略，选中了mac地址为71:63:52:A3:CA，然后将流量转发至该服务实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是,上述只有请求经过负载均衡器，而服务的响应无须从负载均衡器原路返回的工作模式，整个请求、转发、响应的链路形成一个“三角关系”，所以这种负载均衡模式也常被很形象地称为“三角传输模式”，也有叫“单臂模式”或者“直接路由”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;二层负载均衡器直接改写目标 MAC 地址的工作原理决定了它与真实的服务器的通信必须是二层可达的，通俗地说就是必须位于同一个子网当中，无法跨 VLAN。优势（效率高）和劣势（不能跨子网）共同决定了数据链路层负载均衡最适合用来做数据中心的第一级均衡设备，用来连接其他的下级负载均衡器。&lt;/em&gt;&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三层负载均衡&lt;span/&gt;&lt;/h6&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;三层负载均衡是基于网络层的负载均衡，因此又叫网络层负载均衡。通俗的说就是按照不同机器不同IP地址进行转发请求到不同的机器上。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据 OSI 七层模型，在第三层网络层传输的单位是分组数据包，这是一种在分组交换网络中传输的结构化数据单位。以IP协议为例，一个IP 数据包由 Headers 和 Payload 两部分组成， Headers 长度最大为60Bytes，其中包括了20Bytes的固定数据和最长不超过40Bytes 的可选的额外设置组成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三层负载均衡服务器对外依然提供一个VIP（虚IP），但是集群中不同的机器采用不同的IP地址。当负载均衡服务器接受到请求之后，根据不同的负载均衡算法，通过IP将请求转发至不同的真实服务器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学过计算机网络的都知道，在IP分组的数据报header中有 &lt;em&gt;源IP&lt;/em&gt; 和 &lt;em&gt;目标IP&lt;/em&gt;。源IP和目标IP代表分组交换中数据是从哪台机器到哪台机器的，那么，我们可以采用跟修改二层负载均衡中MAC地址的方式一样，直接修改目标IP，以达到数据转发的目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改目标IP的方式有两种：1、原有的数据包保持不变，生成一个新的数据包，原数据包的Header和Payload作为新数据包的Payload，在这个新数据包的 Headers 中写入真实服务器的 IP 作为目标地址，然后把它发送出去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;真实服务器收到数据包后，必须在接收入口处设计一个针对性的拆包机制，把由负载均衡器自动添加的那层 Headers 扔掉，还原出原来的数据包来进行使用。这样，真实服务器就同样拿到了一个原本不是发给它（目标 IP 不是它）的数据包，达到了流量转发的目的。这种数据传输方式叫做 &lt;em&gt;IP隧道&lt;/em&gt; 传输。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管因为要封装新的数据包，IP 隧道的转发模式比起直接路由模式效率会有所下降，但由于并没有修改原有数据包中的任何信息，所以 IP 隧道的转发模式仍然具备三角传输的特性，即负载均衡器转发来的请求，可以由真实服务器去直接应答，无须在经过均衡器原路返回。而且由于 IP 隧道工作在网络层，所以可以跨越 VLAN，因此摆脱了直接路由模式中网络侧的约束。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此模式从请求到响应如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100001157&quot; data-ratio=&quot;0.6016806722689075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZpXSiciaib0GfLjWhjKgApwen0wpdSZNDuxywnW8vqciaY4P3mr79WBOgYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1190&quot;/&gt;&lt;figcaption&gt;IP隧道模式负载均衡&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可以跨越 VLAN
缺点：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;要求真实服务器必须支持IP隧道协议，也就是说服务器需要自己会拆包&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;必须通过专门的配置，必须保证所有的真实服务器与均衡器有着相同的虚拟 IP 地址，因为回复该数据包时，需要使用这个虚拟 IP 作为响应数据包的源地址，这样客户端收到这个数据包时才能正确解析。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于以上原因，就有了第二种修改方式。2、改变目标数据包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接把数据包 Headers 中的目标地址改为真实服务器地址，修改后原本由用户发给均衡器的数据包，也会被三层交换机转发送到真实服务器的网卡上，而且因为没有经过 IP 隧道的额外包装，也就无须再拆包了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为这种模式是通过修改目标 IP 地址才到达真实服务器的，如果真实服务器直接将应答包返回客户端的话，这个应答数据包的源 IP 是真实服务器的 IP，也即均衡器修改以后的 IP 地址，客户端不可能认识该 IP，自然就无法再正常处理这个应答了。因此，只能让应答流量继续回到负载均衡，由负载均衡把应答包的源 IP 改回自己的 IP，再发给客户端，这样才能保证客户端与真实服务器之间的正常通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种修改目标IP的方式叫NAT模式，这种通过修改目标IP的方式达到负载均衡目的的方式叫做NAT负载均衡。如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100001154&quot; data-ratio=&quot;0.627906976744186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZEICBGzsSz5c7Ndq0TTE0XC3ruP6uBp3d1qkGEwyOtXd8Wyk1t3R98w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1204&quot;/&gt;&lt;figcaption&gt;NAT模式负载均衡&lt;/figcaption&gt;&lt;/figure&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;四层负载均衡&lt;span/&gt;&lt;/h6&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;所谓四层负载均衡，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于四层负载均衡是作用在传输层，因此，我们就以常见的TCP进行举例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器IP），直接转发给该服务器。TCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100001155&quot; data-ratio=&quot;0.6020236087689713&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZ7FpXUIunbIYfsMaUuTt2O5ujMGOTPSBqyfmo13htHtYgmauLtoJGrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1186&quot;/&gt;&lt;figcaption&gt;四层负载均衡&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;四层负载均衡主要是基于tcp协议报文，可以做任何基于tcp/ip协议的软件的负载均衡，比如Haproxy、LVS等。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;七层负载均衡&lt;span/&gt;&lt;/h6&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;所谓七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用层协议较多，常用http、radius、dns等。七层负载就可以基于这些协议来负载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们仍然以TCP为例。负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。负载均衡设备在这种情况下，更类似于一个代理服务器。负载均衡和前端的客户端以及后端的服务器会分别建立TCP连接。所以从这个技术原理上来看，七层负载均衡明显的对负载均衡设备的要求更高，处理七层的能力也必然会低于四层模式的部署方式。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;七层负载均衡器会与客户端 以及 后端的服务实例分别建立连接&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100001158&quot; data-ratio=&quot;0.6085470085470085&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZxSPmiacW7AUIoYe2icjIdQ1A2vZaDUqlEfoLy6UNXAeSItUxsA5qniaHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1170&quot;/&gt;&lt;figcaption&gt;七层负载均衡&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;七层负载均衡基本都是基于http协议的，适用于web服务器的负载均衡，比如Nginx等。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;对比(四层和七层)&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;智能性&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;七层负载均衡由于具备OIS七层的所有功能，所以在处理用户需求上能更加灵活，从理论上讲，七层模型能对用户的所有跟服务端的请求进行修改。例如对文件header添加信息，根据不同的文件类型进行分类转发。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;四层模型仅支持基于网络层的需求转发，不能修改用户请求的内容。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;安全性&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;七层负载均衡由于具有OSI模型的全部功能，能更容易抵御来自网络的攻击&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;四层模型从原理上讲，会直接将用户的请求转发给后端节点，无法直接抵御网络攻击。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;复杂度&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;四层模型一般比较简单的架构，容易管理，容易定位问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;七层模型架构比较复杂，通常也需要考虑结合四层模型的混用情况，出现问题定位比较复杂。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;效率比&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;四层模型基于更底层的设置，通常效率更高，但应用范围有限&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;七层模型需要更多的资源损耗，在理论上讲比四层模型有更强的功能，现在的实现更多是基于http应用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;6&lt;/span&gt;&lt;/span&gt;&lt;span&gt;算法与实现&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的负载均衡算法分为以下两类：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的静态均衡算法：轮询法、随机法、源地址哈希法、一致性哈希法、加权轮询法、加权随机法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的动态负载均衡算法：最小连接数法、最快响应速度法。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;随机法(Random)&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;将请求随机分配到各个节点。由概率统计理论得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配，也就是轮询的结果。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随机策略会导致配置较低的机器Down机，从而可能引起雪崩，一般采用随机算法时建议后端集群机器配置最好同等的，随机策略的性能取决于随机算法的性能。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;优点：简单高效，易于水平扩展，每个节点满足字面意义上的均衡；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺点：没有考虑机器的性能问题，根据木桶最短木板理论，集群性能瓶颈更多的会受性能差的服务器影响。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100001156&quot; data-ratio=&quot;0.5759398496240602&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZGTsnQEcMYthfk2NtXZgRMEXBa7Yt9Hvjzde2xicPuURbWHOf4aLWTJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1330&quot;/&gt;&lt;figcaption&gt;随机法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;std::string Select(const std::vector&amp;lt;int&amp;gt; &amp;amp;ips) {&lt;br/&gt;  size_t size = ips.size();&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (size == 0) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ips[random() % size];&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;轮询法(Round Robin)&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;每一次来自网络的请求轮流分配给内部中的服务器，从1至N然后重新开始。此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设10台机器，从0-9，请求来临时从0号机器开始，后续每来一次请求对编号加1，这样一直循环，上面的随机策略其实最后就变成轮询了，这两种策略都不关心机器的负载和运行情况，而且对变量操作会引入锁操作，性能也会下会下降。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;优点：简单高效，易于水平扩展，每个节点满足字面意义上的均衡；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺点：没有考虑机器的性能问题，根据木桶最短木板理论，集群性能瓶颈更多的会受性能差的服务器影响。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100001161&quot; data-ratio=&quot;0.5820668693009119&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZj2lPrUDSbIRm5djfBl4byxrcBfMgPEmDkY6djicBlyJHCbNebkszv0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1316&quot;/&gt;&lt;figcaption&gt;轮询法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;static int idx = 0;&lt;br/&gt;std::string Select(const std::vector&amp;lt;int&amp;gt; &amp;amp;ips) {&lt;br/&gt;  size_t size = ips.size();&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (size == 0) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (idx == ips.size()) {&lt;br/&gt;    idx = 0;&lt;br/&gt;  }&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ips[idx++];&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;加权轮询法(Weighted Round Robin)&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请求；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设后端有3台服务器，分别为a b c，现在在负载均衡器中配置a服务器的权重为7，b服务的权重为2，c服务的权重为1。当来了10次请求的时候，其中有7次请求a，2次请求b，1次请求c。即最终结果是&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;aaaaaaabbc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;优点：可以将不同机器的性能问题纳入到考量范围，集群性能最优最大化；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺点：生产环境复杂多变，服务器抗压能力也无法精确估算，静态算法导致无法实时动态调整节点权重，只能粗糙优化。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100001163&quot; data-ratio=&quot;0.5752212389380531&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZybb9ZIKyicjvLQo8iazMjJ5ERVZk41dWygdR0zTS477JzDxyRXClBbxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1356&quot;/&gt;&lt;figcaption&gt;加权轮询&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;加权随机法(Weighted Random)&lt;/h4&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;与加权轮询法一样，加权随机法也根据服务器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在之前的文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247484656&amp;amp;idx=1&amp;amp;sn=aae935199378a31296bd28ec6c9c97c4&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;权重随机分配器&lt;/a&gt;我们有详细讲过各种实现方案，此处我们不再赘述，从里面摘抄了一种实现方案作为本方案的实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100001159&quot; data-ratio=&quot;0.5909774436090226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZ8rzXjuRNpX26erliaN41yNIWf3t44YOXmv4DkeLvBnBT8zgebnzdrDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1330&quot;/&gt;&lt;figcaption&gt;加权随机&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;优点：可以将不同机器的性能问题纳入到考量范围，集群性能最优最大化；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺点：生产环境复杂多变，服务器抗压能力也无法精确估算，静态算法导致无法实时动态调整节点权重，只能粗糙优化。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码实现&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;srtuct Item {&lt;br/&gt;  std::string ip;&lt;br/&gt;  int weight;&lt;br/&gt;};&lt;br/&gt;std::string select(const std::vector&amp;lt;Item&amp;gt; &amp;amp;items) {&lt;br/&gt;  int sum = 0;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (auto elem : items) {&lt;br/&gt;    sum += elem.weight;&lt;br/&gt;  }&lt;br/&gt;  &lt;br/&gt;  int rd = rand() % sum;&lt;br/&gt;  int s = 0;&lt;br/&gt;  std::string res;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (auto elem : items) {&lt;br/&gt;    s += elem.weight;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (s &amp;gt;= rd) {&lt;br/&gt;      res = elem.ip;&lt;br/&gt;      &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; res;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最快响应速度法(Response Time)&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;根据请求的响应时间，来动态调整每个节点的权重，将响应速度快的服务节点分配更多的请求，响应速度慢的服务节点分配更少的请求&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;负载均衡设备对内部各服务器发出一个探测请求（例如Ping），然后根据内部中各服务器对探测请求的最快响应时间来决定哪一台服务器来响应客户端的服务请求。此种均衡算法能较好的反映服务器的当前运行状态，但这最快响应时间仅仅指的是负载均衡设备与服务器间的最快响应时间，而不是客户端与服务器间的最快响应时间。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;优点：动态，实时变化，控制的粒度更细，更灵敏；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺点：复杂度更高，每次需要计算请求的响应速度；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100001160&quot; data-ratio=&quot;0.5783132530120482&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZ3wGnfj0QyuqN4VtO0F7xznftpib9bib2Y5rT8VQHjSdTZYVV6cPk4Asg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1328&quot;/&gt;&lt;figcaption&gt;最快响应速度&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最少连接数法(Least Connections)&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;将请求分发到连接数/请求数最少的候选服务器，已达到负载均衡的目的&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端的每一次请求服务在服务器停留的时间可能会有较大的差异，随着工作时间加长，如果采用简单的轮循或随机均衡算法，每一台服务器上的连接进程可能会产生极大的不同，并没有达到真正的负载均衡。最少连接数均衡算法对内部中需负载的每一台服务器都有一个数据记录，记录当前该服务器正在处理的连接数量，当有新的服务连接请求时，将把当前请求分配给连接数最少的服务器，使均衡更加符合实际情况，负载更加均衡。此种均衡算法适合长时处理的请求服务，如FTP。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;优点：动态，根据节点状况实时变化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺点：提高了复杂度，每次连接断开需要进行计数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100001162&quot; data-ratio=&quot;0.6549618320610687&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZQlibEzFQtOkBa8poh8ic4ROtXk7ffn54jhb99B9GQyZkalFEJUILuWMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1310&quot;/&gt;&lt;figcaption&gt;最少连接数&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;源地址哈希法(Source Hashing)&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;根据请求源 IP，通过哈希计算得到一个数值，用该数值在候选服务器列表的进行取模运算，得到的结果便是选中的服务器。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;能够让同一客户端的请求或者同一用户的请求总是请求在后端同一台机器上，这种算法根据客户端IP求出Hash值然后对端集群总数求余得到值就是服务器集合的下标，一般这种算法用于缓存命中，或者同一会话请求等，但这种算法也有一定的缺点，某一用户访问量(黑产)非常高时可能造成服务端压力过大或者后端服务Down掉，那么客户端就会无法访问，所以也需要一定的降级策略。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;优点：将来自同一IP地址的请求，同一会话期内，转发到相同的服务器；实现会话粘滞&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺点：目标服务器宕机后，会话会丢失&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100001167&quot; data-ratio=&quot;0.5758928571428571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZMnkM7h9bThJsZtdN8JLCEuJAIhj69Ria2sGxiaw802umibhqDicwajM4zQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1344&quot;/&gt;&lt;figcaption&gt;源地址哈希&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一致性哈希(Consistency hash)&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一些场景希望同样的请求尽量落到一台机器上，比如访问缓存集群时，我们往往希望同一种请求能落到同一个后端上，以充分利用其上已有的缓存，不同的机器承载不同的稳定请求量（也可以理解为固定批用户的请求）。而不是随机地散落到所有机器上，那样的话会迫使所有机器缓存所有的内容，最终由于存不下形成颠簸而表现糟糕。我们都知道hash能满足这个要求，比如当有n台服务器时，输入x总是会发送到第hash(x) % n台服务器上。但当服务器变为m台时，hash(x) % n和hash(x) % m很可能都不相等，这会使得几乎所有请求的发送目的地都发生变化，如果目的地是缓存服务，所有缓存将失效，继而对原本被缓存遮挡的数据库或计算服务造成请求风暴，触发雪崩。一致性哈希是一种特殊的哈希算法，在增加服务器时，发向每个老节点的请求中只会有一部分转向新节点，从而实现平滑的迁移。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100001168&quot; data-ratio=&quot;0.858600583090379&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHjNouaq0xmKWOJE7IG6OKNZ9ccGTBJW9oAQwXcCsYWiaazJmhRnsXyN0nic75icosgOg7Q5HthV5JEcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1372&quot;/&gt;&lt;figcaption&gt;一致性哈希&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;平衡性: 每个节点被选到的概率是O(1/n)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单调性: 当新节点加入时， 不会有请求在老节点间移动， 只会从老节点移动到新节点。当有节点被删除时，也不会影响落在别的节点上的请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分散性: 当上游的机器看到不同的下游列表时(在上线时及不稳定的网络中比较常见), 同一个请求尽量映射到少量的节点中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;负载: 当上游的机器看到不同的下游列表的时候， 保证每台下游分到的请求数量尽量一致。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在机器数量较少的时候，区间大小会不平衡。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当一台机器故障的时候，它的压力会完全转移到另外一台机器， 可能无法承载。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;7&lt;/span&gt;&lt;/span&gt;&lt;span&gt;结语&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;负载均衡并不是真正确保网络流量能够&quot;均匀&quot;的分配到后端服务实例。它只是抱着在意外情况发生时候，也能保证用户体验。良好的架构设计和弹性扩容，能够使得负载均衡的功能 &lt;em&gt;&lt;strong&gt;事半功倍&lt;/strong&gt;&lt;/em&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;90215&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; data-width=&quot;100%&quot;&gt;&lt;strong&gt;往期&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;精彩&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;回顾&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-bdless=&quot;spin&quot; data-bdlessp=&quot;280&quot; data-bdopacity=&quot;50%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247484677&amp;amp;idx=1&amp;amp;sn=dbf3afa848db5026227c1d87cfc3b3dc&amp;amp;chksm=c33763c2f440ead481486c8dd256b620d7b415fec4b334981465347087ef1a7ba13980fbf073&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;流量控制还能这么搞。。。&lt;/a&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247484677&amp;amp;idx=1&amp;amp;sn=dbf3afa848db5026227c1d87cfc3b3dc&amp;amp;chksm=c33763c2f440ead481486c8dd256b620d7b415fec4b334981465347087ef1a7ba13980fbf073&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247484671&amp;amp;idx=1&amp;amp;sn=9c677de01f9dd4d0292c35f79fad660c&amp;amp;chksm=c3376238f440eb2e0600e86b6bd853606d7a8de1b0e5e661c81366e627adb67a8acb88cea508&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;技术十年&lt;/a&gt;&lt;br/&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247484674&amp;amp;idx=1&amp;amp;sn=81ee9f363b4a7019ff1e77bcaecf234b&amp;amp;chksm=c33763c5f440ead351ebdb39a47fa922180dc2fc647dfd31de6407d8f97dfcb526332df463e6&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;聊聊服务注册与发现&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9c5467f1939d7d7717879780e0fd4043</guid>
<title>粗排扮演的角色和算法发展历程</title>
<link>https://toutiao.io/k/d7rng7u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;1.推荐系统经典的级联架构&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2.对粗排阶段的思考&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;2.1 粗排是必要的吗？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2.2 粗排与精排的异与同&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2.3 粗排与召回的差异&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2.4 粗排的优缺点&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;3.粗排技术的发展&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;3.1 静态的“质量分”&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3.2 机器学习模型&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3.3 基于向量内积的深度模型&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3.4 阿里粗排COLD框架&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3.5 精排模型的蒸馏&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.推荐系统经典的级联架构&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这里本来写的是「传统」的级联架构，后来思索万千，觉得不太合适，就改为了「经典」。因为级联架构目前依旧在各大互联网公司被应用，其扮演的角色也很重要。一般情况下我们常见级联架构主要是由四部分组成，但依据具体的业务和数据量适当的选择其中若干部分进行应用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 四部分及角色&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;四部分指的是：召回 / recall -&amp;gt; 粗排 / prerank -&amp;gt; 精排 / rank -&amp;gt; 重排 / rerank&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;416&quot; data-backw=&quot;542&quot; data-ratio=&quot;0.7673860911270983&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/02kicEWsIniciaVfFR7MzqcQMUvJ9nIc23OWYfhF21EPU6hJ7v0dBhYc5CwPibf5C1zR0qOBpExWsszeJFicMprnb1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1668&quot;/&gt;&lt;figcaption&gt;四级级联架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同的部分所扮演的角色也不相同，每个阶段都在为完成自己的使命而发光发热。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;召回：负责从最原始的候选集中选出用户感兴趣下一个错别字&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;和可能感兴趣的item，一般集合在几千到1万+，视具体的推荐架构和算力而定&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;粗排：减小精排排序的压力，对召回池中的商品进行排序，选出用户最喜欢的top N个item，N的取值一般是几百&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;精排：从粗排提供的候选池中选出用户最有可能点击的M个item，M的取值一般是几十个&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重排：从精排返回的结果中进行重新排序，返回给上游接口，继而展示给用户&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 结合业务数据选择模块&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前边也提到，这样的四级级联架构并非是所有推荐业务的必须选择，因为业务的特性和item的规模都是不一样的，因此在制定技术方案时不一定要严格遵循召回-&amp;gt;粗排-&amp;gt;精排-&amp;gt;重排的流程，而是结合业务选取若干部分，具体大家可以看下面举的案例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;eg 1：一个精选品电商业务，所有的item只有几千个，这时候可以跳过召回，直接全部item进粗排，然后是精排和重排&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;eg 2：传统的电商平台，所有的item数以亿计，这时候召回阶段是跳不过的，就需要走召回-&amp;gt;粗排-&amp;gt;精排-&amp;gt;重排的流程（或者是召回 -&amp;gt; 精排 -&amp;gt; 重排，需要严格限制召回的数量）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;eg 3：一个新的电商业务初期，数据比较少，能够构造的特征也比较少，这时候就可以抛弃传统的四部分级联架构，直接由cf得到的结果也是可以接受的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以并非严格遵循流程就是好的，适当的时候也要变通和尝试，结合业务才能做出好的效果。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.对粗排阶段的思考&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;粗排在推荐系统中扮演的角色是精排的前置阶段，其目标理论上应该和精排是一致的，这样能保证精排从粗排返回的结果中选出的top M一定是结果最优的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 粗排是必要的吗？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;粗排是不是必要的？伴随这个问题的还有召回是不是必要的？精排是不是必要的？重排是不是必要的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同的业务、不同的发展阶段，甚至可以说召回、排序都可能不是必须的。粗排当然也不是在所有业务、所有阶段都是必须的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分发物料少的业务，可以不用召回，精排模型打分就可以了；推荐架构刚刚搭建，甚至连内容标签都没有的阶段，多维度的特征无法建立的时候，也许只有协同召回的效果也是能接受的。同样，粗排是在发展到一定的阶段之后，有很多路不同维度召回，而且精排模型又已经达到一个很复杂很精细程度的时候，是夹在召回和精排中间的“折中”的产物。重排则是为了更大程度的保证用户体验，从而提高效果的一种手段，当前几个阶段都没有建立完整的链条时，又何必花费大力气去建设精排呢！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 粗排与精排的异与同&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;粗排和精排在一定程度是相同的，至少目标是一致的，但是也存在一些差异。同：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;目标一致：选出用户最感兴趣的top M、top N&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;特征一致：使用的特征粗排应该是精排的子集（选取区分度比较高的特征），或者大部分特征是一致的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;技术栈相同：比如精排是DNN，粗排一般也采样DNN，这样精排上验证有效的策略可以容易的迁移到粗排模型（但并不是一定要相同，主要看个人而定）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;量级不同：粗排因为是精排的前置阶段，所以粗排一般接受几千或者1万+的item进行排序，而精排则接受几百个商品进行排序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;延时要求不同：因为粗排和精排打分的item量级不一致，所以精排对延时的要求比粗排更加严格&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;特征不同：精排特征比粗排特征更细，更加丰富&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 粗排与召回的差异&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如以DSSM为例，它作为召回和作为粗排模型，做法一样吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目的不一样，样本构造不一样。作为召回，它要不遗漏，它可以从全库item中负采样。作为粗排，它要准确，要接近精排，它的可以用线上的曝光的负样本，或者从全体召回候选中负采样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像一些其他的召回方法是被严格限制在了召回阶段，是没有办法应用于粗排的，比如CF、标签召回等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一个例子，当算力满足粗排可以对全库的item进行打分时，是否需要保留召回模块？答案：是。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为召回有一个隐藏的任务：&lt;strong&gt;弥补排序的“贪婪”，限制排序模型对眼前的欲望，留点机会后面有潜力的item，不能只给排序模型它喜欢的item，即保证结果的多样性&lt;/strong&gt;。否则就会让用户陷入信息茧房，让用户觉得全世界都是我的！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 粗排的优缺点&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先假定推荐系统的级联架构只有：召回 -&amp;gt; 精排 -&amp;gt; 重排，且精排可以接受的排序量为1000。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么当构建若干召回通路时，各路召回的quota怎么控制？各路召回孰轻孰重？这时候就需要引入粗排来对各路召回的item进行统一打分和度量了（因为每路召回中的分值是不可比的）。同时因为召回为了保证多样性，召回的item量级是要比精排能够接受排序的量级大一些的，复杂的精排模型增加排序量会使得响应时间线性增大，于是我们需要一个简单有效、性能优良的模型来完成这一工作，这就是粗排模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;也可以在召回层面控制进入精排的item数量，比如设置一个总的quota和各路召回的权重，然后进行各路quota的动态分配。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是粗排使用不当也会带来很大的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对于新增的召回源，因为模型的选择偏差，对这一路并不友好&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当粗排和精排一致性差的时候，会拉低线上效果。即精排认为好的，粗排都没有排上来&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.粗排技术的发展&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前粗排模块一般使用的都是精准值预估的方法，即以业务导向为目标，预测出具体的数值，进行排序和截断，选取Top N送往精排。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;208&quot; data-backw=&quot;542&quot; data-ratio=&quot;0.3835051546391753&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/02kicEWsIniciaVfFR7MzqcQMUvJ9nIc23OVqa4E26yiaAHpmBQjQnNncDm1eU4VqWLv5hWSYPIwZBPnnzibe4jY9sA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1940&quot;/&gt;&lt;figcaption&gt;粗排技术发展&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 静态的“质量分”&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般情况下，算法团队都会为所有的item构建一个综合指标，离线评估这个item的好坏，大家一贯的称呼都是质量分，当然也有别的称呼，不过其表达的含义都是一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是这个质量分是静态的，T+1更新的，因此在使用了没有办法去考虑item当天的数据，但是由于其已经是离线计算好的，因此在性能上会很快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;除了离线质量分，也可以使用离线过去制定时间周期内的CTR、CVR、CXR等&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 机器学习模型&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;早期的则是逻辑回归（Logistics Regression，LR），因为其模型简单和有一定的模型表达能力，可以进行在线的更新和模型打分，因此应用十分广泛。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后期则是演变到了以GBDT为代表的树模型，相比LR，其个性化表达能力更加突出，结构简单，成为了各大公司的排序宠儿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再往后则是GBDT的演进版，XGB、Light GBM、GBDT+LR等技术，但其都是属于机器学习模型时代的优秀产物，其都是先在精排侧取得了不错的效果之后，过渡到粗排模型的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 基于向量内积的深度模型&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于向量内积的深度模型是目前应用最广泛的粗排模型，一般为双塔结构，两侧分别输入用户特征和item特征，经过深度网络计算后，分别产出用户向量和item向量，再通过内积等运算计算得到排序分数：&lt;/p&gt;&lt;span data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;score = \sigma (v_u ^T * v_i)&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -891.7 7742.8 1146.5&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;73&quot; d=&quot;M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(469, 0)&quot;&gt;&lt;path data-c=&quot;63&quot; d=&quot;M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(902, 0)&quot;&gt;&lt;path data-c=&quot;6F&quot; d=&quot;M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1387, 0)&quot;&gt;&lt;path data-c=&quot;72&quot; d=&quot;M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1838, 0)&quot;&gt;&lt;path data-c=&quot;65&quot; d=&quot;M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2581.8, 0)&quot;&gt;&lt;path data-c=&quot;3D&quot; d=&quot;M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3637.6, 0)&quot;&gt;&lt;path data-c=&quot;3C3&quot; d=&quot;M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(4208.6, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;msubsup&quot; transform=&quot;translate(4597.6, 0)&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;76&quot; d=&quot;M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(485, 413) scale(0.707)&quot;&gt;&lt;path data-c=&quot;54&quot; d=&quot;M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(485, -247) scale(0.707)&quot;&gt;&lt;path data-c=&quot;75&quot; d=&quot;M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(5852.6, 0)&quot;&gt;&lt;path data-c=&quot;2217&quot; d=&quot;M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;msub&quot; transform=&quot;translate(6574.8, 0)&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;76&quot; d=&quot;M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(485, -150) scale(0.707)&quot;&gt;&lt;path data-c=&quot;69&quot; d=&quot;M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(7353.8, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/section&gt;&lt;/span&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中典型代表为DSSM，关于DSSM的介绍可以参考：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247488050&amp;amp;idx=1&amp;amp;sn=5cbc4b48dc49f541d96a418769263d22&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;论文｜从DSSM语义匹配到Google的双塔深度模型召回和广告场景中的双塔模型思考&lt;/a&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3.1 经典的向量内积模型-以DSSM为例&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;329&quot; data-backw=&quot;542&quot; data-ratio=&quot;0.6073059360730594&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/02kicEWsIniciaVfFR7MzqcQMUvJ9nIc23O31kATBmDdRuBeEHMyQd0RsicPlBSqibp2LWFlDDXyZ549fqEm6TBrLnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1314&quot;/&gt;&lt;figcaption&gt;双塔网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双塔模型，两侧输入的分别是user的特征和item的特征，各自经过DNN变化后分别产出user向量和item向量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;向量内积模型相比之前的粗排模型，表达能力有了很显著的提升，其优点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;内积计算简单，节省线上打分算力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;item向量离线计算产出，user向量实时计算，然后进行实时向量检索&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;双塔结构的user侧网络可以引入transformer等复杂结构对&lt;strong&gt;用户实时行为序列&lt;/strong&gt;进行建模&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是也存在一些缺点，比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;模型表达能力仍然受限：向量内积虽然极大的提升了运算速度，节省了算力，但是也导致了模型无法使用交叉特征，能力受到极大限制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模型实时性较差：item向量一般需要提前计算好，而这种提前计算的时间会拖慢整个系统的更新速度，导致系统难以对数据分布的快速变化做出及时响应，这个问题在双十一等场景尤为明显&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存在冷启动问题，对新item、新用户不友好&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;迭代效率：user向量和item向量的版本同步影响迭代效率。因为每次迭代一个新版本的模型，分别要把相应user和item向量产出，其本身迭代流程就非常长，尤其是对于一个比较大型的系统来说，如果把user和item都做到了上亿的这种级别的话，可能需要一天才能把这些产出更新到线上，这种迭代效率很低&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此就基于传统的双塔模型进行很多改进，比如双塔版本的Wide&amp;amp;Deep模型。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3.2 双塔版本的Wide&amp;amp;Deep模型&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;305&quot; data-backw=&quot;542&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/02kicEWsIniciaVfFR7MzqcQMUvJ9nIc23Op1sjvWWCPJMYexA9MhRz8eemBAvH73OjFnsicxZQ57ZhndWs96569icA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图来自于王哲老师在DataFun的分享，没在网络上找到对应的论文，应该是其内部的实践。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;向量版Wide&amp;amp;Deep模型，deep部分仍然是向量内积结构，wide部分引入基于人工先验构造的user和item的交叉特征，一定程度上克服了向量内积模型无法使用交叉特征的问题。然而该方法仍然有一些问题，wide部分是线性的，受限于RT的约束，不能做的过于复杂，因此表达能力仍然受限。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3.3 双塔模型引入SeNet网络&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个主要采用的还是双塔网络结构， 在user塔和item塔侧各自引入一个SeNet模块，参考：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247499063&amp;amp;idx=1&amp;amp;sn=d62d53a687c6f55b54037eabf4da0fbe&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;SENet双塔模型在推荐领域召回粗排的应用及其它&lt;/a&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;391&quot; data-backw=&quot;542&quot; data-ratio=&quot;0.7222222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/02kicEWsIniciaVfFR7MzqcQMUvJ9nIc23O4gp2DCA2XLhBDibzcEfVChNNBUGcltnrJX4uu1ibuRO0SD3icjOedoGuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1440&quot;/&gt;&lt;figcaption&gt;SeNet&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4 阿里粗排COLD框架&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;COLD框架目前在其他公司应用的比较少，大多数还是基于向量内积的深度模型来计算打分的。COLD模型的结构如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;670&quot; data-backw=&quot;542&quot; data-ratio=&quot;1.2363636363636363&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/02kicEWsIniciaVfFR7MzqcQMUvJ9nIc23OL7C8JwSR4PnIh1jNAopj1VbVygD23WZjpfX6uiaV6T8Hsb8lrEltVDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;880&quot;/&gt;&lt;figcaption&gt;COLD框架&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为其在工程架构层面也进行了很多的优化，最终取得了不错的效果，工程的优化主要包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将计算分成并行的多个请求以同时进行计算，并在最后进行结果合并&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将行计算重构成列计算，对同一列上的稀疏数据进行连续存储，之后利用MKL优化单特征计算，使用SIMD (Single Instruction Multiple Data)优化组合特征算子，以达到加速的目的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于服务器考虑（NVIDIA的Turning架构对Float16和Int8的矩阵乘法有额外的加速），使用了Float16和MPS技术，可以带来接近2倍的QPS提升&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于COLD框架更加详细的介绍会在后续文章中展开介绍，如果大家着急的话可以先看看阿里的论文或者网上的一些文章：COLD- Towards the Next Generation of Pre-Ranking System。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.5 精排模型的蒸馏&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实在阿里提出的COLD框架之前，也会尝试将精排模型落地到粗排阶段，通过知识蒸馏技术来进行，所谓的知识蒸馏简单来理解就是模型压缩，这一技术的理论来自于2015年Hinton发表的一篇神作:论文：Distilling the Knowledge in a Nerual Network，感兴趣的可以去看看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知识蒸馏的主要思路就是“老师-&amp;gt;学生”，即：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;培养一个能很好表现和概括的大模型，这就是所谓的教师模式&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;取你所有的数据，计算教师模型的预测值，包含这些预测的总数据集称为知识，而预测本身通常称为软目标，这就是知识提炼的步骤&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;利用之前获得的知识来训练较小的网络，称为学生模型&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学生模型即为蒸馏后的小模型。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;301&quot; data-backw=&quot;542&quot; data-ratio=&quot;0.55625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/02kicEWsIniciaVfFR7MzqcQMUvJ9nIc23OXAoUPRajX6X8OSv8LJU2KE8cvSicGepdaYHJRFNlREcxuXN1yMRLr2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;figcaption&gt;知识蒸馏&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>