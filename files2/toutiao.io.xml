<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>35128aad9b33a273ba2024109b87a8ed</guid>
<title>sonic ：基于 JIT 技术的开源全场景高性能 JSON 库</title>
<link>https://toutiao.io/k/p9vuoir</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;项目仓库：https://github.com/bytedance/sonic&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sonic 是字节跳动&lt;strong&gt;开源&lt;/strong&gt;的一款 &lt;strong&gt;Golang JSON 库&lt;/strong&gt;，基于即时编译（Just-In-Time Compilation）与向量化编程（Single Instruction Multiple Data）技术，大幅提升了 Go 程序的 JSON 编解码性能。同时结合 lazy-load 设计思想，它也为不同业务场景打造了一套全面高效的 API。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自 2021 年 7 月份发布以来， sonic 已被抖音、今日头条等业务采用，累计为字节跳动&lt;strong&gt;节省了数十万 CPU 核&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么要自研 JSON 库&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JSON（JavaScript Object Notation） 以其简洁的语法和灵活的自描述能力，被广泛应用于各互联网业务。但是 JSON 由于本质是一种文本协议，且没有类似 Protobuf 的强制模型约束（schema），编解码效率往往十分低下。再加上有些业务开发者对 JSON 库的不恰当选型与使用，最终导致服务性能急剧劣化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在字节跳动，我们也遇到了上述问题。根据此前统计的公司 CPU 占比 TOP 50 服务的性能分析数据，JSON 编解码开销总体接近 10%，单个业务占比甚至超过 40%，提升 JSON 库的性能至关重要。因此我们对业界现有 Go JSON 库进行了一番评估测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，根据主流 JSON 库 API，我们将它们的使用方式分为三种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;泛型（generic）编解码&lt;/strong&gt;：JSON 没有对应的 schema，只能依据自描述语义将读取到的 value 解释为对应语言的运行时对象，例如：JSON object 转化为 Go map[string]interface{}；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;定型（binding）编解码&lt;/strong&gt;：JSON 有对应的 schema，可以同时结合模型定义（Go struct）与 JSON 语法，将读取到的 value 绑定到对应的模型字段上去，同时完成数据解析与校验；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;查找（get）&amp;amp; 修改（set）&lt;/strong&gt;：指定某种规则的查找路径（一般是 key 与 index 的集合），获取需要的那部分 JSON value 并处理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次，我们根据样本 JSON 的 key 数量和深度分为三个量级：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;小（small）&lt;/strong&gt;：400B，11 key，深度 3 层；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;中（medium）&lt;/strong&gt;：110KB，300+ key，深度 4 层（实际业务数据，其中有大量的嵌套 JSON string)；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;大（large）&lt;/strong&gt;：550KB，10000+ key，深度 6 层。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;352&quot; data-backw=&quot;558&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;352&quot; data-ratio=&quot;0.6304347826086957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaTEXRLjJ4sDdFQGTvfP2A0gXCYzMFBsFFl3n4ESrRtJzQ2IYiaFpolZGapib9lUmZibOUqYJ7tXMb1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1748&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不同数据量级下 JSON 库性能表现&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果显示：&lt;strong&gt;目前这些 JSON 库均无法在各场景下都保持最优性能，即使是当前使用最广泛的第三方库 json-iterator，在泛型编解码、大数据量级场景下的性能也满足不了我们的需要&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JSON 库的基准编解码性能固然重要，但是对不同场景的最优匹配更关键 —— 于是我们走上了自研 JSON 库的道路。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;开源库 sonic 技术原理&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 JSON 业务场景复杂，指望通过单一算法来优化并不现实。于是在设计 sonic 的过程中，我们借鉴了其他领域/语言的优化思想（不仅限于 JSON），将其融合到各个处理环节中。其中较为核心的技术有三块：&lt;strong&gt;JIT、lazy-load&lt;/strong&gt; 与 &lt;strong&gt;SIMD&lt;/strong&gt; 。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;JIT&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于有 schema 的&lt;strong&gt;定型编解码&lt;/strong&gt;场景而言，很多运算其实不需要在“运行时”执行。这里的“运行时”是指程序真正开始解析 JSON 数据的时间段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，如果业务模型中确定了某个 JSON key 的值一定是布尔类型，那么我们就可以在序列化阶段直接输出这个对象对应的 JSON 值（‘true’或‘false’），并不需要再检查这个对象的具体类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sonic-JIT 的核心思想就是：&lt;strong&gt;将模型解释与数据处理逻辑分离，让前者在“编译期”固定下来&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种思想也存在于标准库和某些第三方 JSON 库，如 json-iterator 的函数组装模式：把 Go struct 拆分解释成一个个字段类型的编解码函数，然后组装并缓存为整个对象对应的编解码器（codec），运行时再加载出来处理 JSON。但是这种实现难以避免转化成大量 interface 和 function 调用栈，随着 JSON 数据量级的增长，function-call 开销也成倍放大。只有&lt;strong&gt;将模型解释逻辑真正编译出来&lt;/strong&gt;，实现 stack-less 的执行体，才能最大化 schema 带来的性能收益。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业界实现方式目前主要有两种：&lt;strong&gt;代码生成 code-gen&lt;/strong&gt;（或&lt;strong&gt;模版 template&lt;/strong&gt;）和 &lt;strong&gt;即时编译 JIT&lt;/strong&gt;。前者的优点是库开发者实现起来相对简单，缺点是增加业务代码的维护成本和局限性，无法做到秒级热更新——这也是代码生成方式的 JSON 库受众并不广泛的原因之一。JIT 则将编译过程移到了程序的加载（或首次解析）阶段，只需要提供 JSON schema 对应的结构体类型信息，就可以一次性编译生成对应的 codec 并高效执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sonic-JIT 大致过程如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;321&quot; data-backw=&quot;558&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;321&quot; data-ratio=&quot;0.575925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5EcwYhllQOiaTEXRLjJ4sDdFQGTvfP2A0X6sJicMXefj3x9mE5GmnRb4KI4GZKiasuCU5q1h8MRvjWibAOhwPSR2Yg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;sonic-JIT 体系&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;初次运行时，基于 Go 反射来获取需要编译的 schema 信息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;结合 JSON 编解码算法生成一套自定义的中间代码 OP codes；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 OP codes 翻译为 Plan9 汇编；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用第三方库 golang-asm 将 Plan 9 转为机器码；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将生成的二进制码注入到内存 cache 中并封装为 go function；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后续解析，直接根据 type ID （rtype.hash）从 cache 中加载对应的 codec 处理 JSON。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从最终实现的结果来看，sonic-JIT 生成的 codec 性能不仅好于 json-iterator，甚至超过了代码生成方式的 easyjson（见后文“性能测试”章节）。这一方面跟底层文本处理算子的优化有关（见后文“SIMD &amp;amp; asm2asm”章节），另一方面来自于 sonic-JIT 能控制底层 CPU 指令，在运行时建立了一套独立高效的 ABI（Application Binary Interface）体系：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将使用频繁的变量放到固定的寄存器上（如 JSON buffer、结构体指针），尽量避免 memory load &amp;amp; store；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自己维护变量栈（内存池），避免 Go 函数栈扩展；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动生成跳转表，加速 generic decoding 的分支跳转；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用寄存器传递参数（当前 Go Assembly 并未支持，见“SIMD &amp;amp; asm2asm”章节）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Lazy-load&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于大部分 Go JSON 库，泛型编解码是它们性能表现最差的场景之一，然而由于业务本身需要或业务开发者的选型不当，它往往也是被应用得最频繁的场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型编解码性能差仅仅是因为没有 schema 吗？其实不然。我们可以对比一下 C++ 的 JSON 库，如 rappidjson、simdjson，它们的解析方式都是泛型的，但性能仍然很好（simdjson 可达 2GB/s 以上）。标准库泛型解析性能差的根本原因在于&lt;strong&gt;它采用了 Go 原生泛型——interface（map[string]interface{}）作为 JSON 的编解码对象&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这其实是一种糟糕的选择：首先是数据反序列化的过程中，map 插入的开销很高；其次在数据序列化过程中，map 遍历也远不如数组高效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回过头来看，JSON 本身就具有完整的自描述能力，如果我们用一种与 JSON AST 更贴近的数据结构来描述，不但可以让转换过程更加简单，甚至可以实现按需加载（lazy-load）——这便是 sonic-ast 的核心逻辑：&lt;strong&gt;它是一种 JSON 在 Go 中的编解码对象，用 node {type, length, pointer} 表示任意一个 JSON 数据节点，并结合树与数组结构描述节点之间的层级关系&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;623&quot; data-backw=&quot;558&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;359&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;401&quot; data-ratio=&quot;1.117794486215539&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaTEXRLjJ4sDdFQGTvfP2A0FHyUaCytibObOKKqycXdMmysapbE8FbkeAxZpTI9mYDrbt6ibeTWXEZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;399&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;sonic-ast 结构示意&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sonic-ast 实现了一种有状态、可伸缩的 JSON 解析过程：当使用者 get 某个 key 时，sonic 采用 skip 计算来轻量化跳过要获取的 key 之前的 json 文本；对于该 key 之后的 JSON 节点，直接不做任何的解析处理；仅使用者真正需要的 key 才完全解析（转为某种 Go 原始类型）。由于节点转换相比解析 JSON 代价小得多，在并不需要完整数据的业务场景下收益相当可观。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 skip 是一种轻量的文本解析（处理 JSON 控制字符“[”、“{”等），但是使用类似 gjson 这种纯粹的 JSON 查找库时，往往会有相同路径查找导致的重复开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对该问题，sonic 在对于子节点 skip 处理过程增加了一个步骤，将跳过 JSON 的 key、起始位、结束位记录下来，分配一个 Raw-JSON 类型的节点保存下来，这样二次 skip 就可以直接基于节点的 offset 进行。同时 sonic-ast 支持了节点的更新、插入和序列化，甚至支持将任意 Go types 转为节点并保存下来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换言之，sonic-ast 可以作为一种通用的泛型数据容器替代 Go interface，在&lt;strong&gt;协议转换、动态代理&lt;/strong&gt;等服务场景有巨大潜力。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;SIMD &amp;amp; asm2asm&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是定型编解码场景还是泛型编解码场景，核心都离不开 JSON 文本的处理与计算。其中一些问题在业界已经有比较成熟高效的解决方案，如浮点数转字符串算法 Ryu，整数转字符串的查表法等，这些都被实现到 sonic 的底层文本算子中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一些问题逻辑相对简单，但是可能会面对较大数量级的文本，如 JSON string 的 unquote\quote 处理、空白字符的跳过等。此时我们就需要某种技术手段来提升处理能力。SIMD 就是这样一种用于并行处理大规模数据的技术，目前大部分 CPU 已具备 SIMD 指令集（例如 Intel AVX），并且在 simdjson 中有比较成功的实践。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是一段 sonic 中 skip 空白字符的算法代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#if USE_AVX2&lt;/span&gt;&lt;br/&gt;    // 一次比较比较32个字符&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (likely(nb &amp;gt;= 32)) {&lt;br/&gt;        // vmovd 将单个字符转成YMM&lt;br/&gt;        __m256i x = _mm256_load_si256 ((const void *)sp);&lt;br/&gt;        // vpcmpeqb 比较字符，同时为了充分利用CPU 超标量特性使用4 倍循环&lt;br/&gt;        __m256i a = _mm256_cmpeq_epi8 (x, _mm256_set1_epi8(&lt;span&gt;&#x27; &#x27;&lt;/span&gt;));&lt;br/&gt;        __m256i b = _mm256_cmpeq_epi8 (x, _mm256_set1_epi8(&lt;span&gt;&#x27;\t&#x27;&lt;/span&gt;));&lt;br/&gt;        __m256i c = _mm256_cmpeq_epi8 (x, _mm256_set1_epi8(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;));&lt;br/&gt;        __m256i d = _mm256_cmpeq_epi8 (x, _mm256_set1_epi8(&lt;span&gt;&#x27;\r&#x27;&lt;/span&gt;));&lt;br/&gt;        // vpor 融合4次结果&lt;br/&gt;        __m256i u = _mm256_or_si256   (a, b);&lt;br/&gt;        __m256i v = _mm256_or_si256   (c, d);&lt;br/&gt;        __m256i w = _mm256_or_si256   (u, v);&lt;br/&gt;        // vpmovmskb  将比较结果按位展示&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ((ms = _mm256_movemask_epi8(w)) != -1) {&lt;br/&gt;            _mm256_zeroupper();&lt;br/&gt;            // tzcnt 计算末尾零的个数N&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; sp - ss + __builtin_ctzll(~(uint64_t)ms);&lt;br/&gt;        }&lt;br/&gt;        /* move to next block */&lt;br/&gt;        sp += 32;&lt;br/&gt;        nb -= 32;&lt;br/&gt;    }&lt;br/&gt;    /* clear upper half to avoid AVX-SSE transition penalty */&lt;br/&gt;    _mm256_zeroupper();&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;sonic 中 strnchr() 实现（SIMD 部分）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发者们会发现这段代码其实是用 C 语言编写的 —— 其实 sonic 中绝大多数文本处理函数都是用 C 实现的：一方面 SIMD 指令集在 C 语言下有较好的封装，实现起来较为容易；另一方面这些 C 代码通过 clang 编译能充分享受其编译优化带来的提升。为此我们开发了一套 x86 汇编转 Plan9 汇编的工具 asm2asm，将 clang 输出的汇编通过 Go Assembly 机制静态嵌入到 sonic 中。同时在 JIT 生成的 codec 中我们利用 asm2asm 工具计算好的 C 函数 PC 值，直接调用 CALL 指令跳转，从而绕过 Go Assembly 不能寄存器传参的限制，压榨最后一丝 CPU 性能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;其它&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上述提到的技术外，sonic 内部还有很多的细节优化，比如使用 RCU 替换 sync.Map 提升 codec cache 的加载速度，使用内存池减少 encode buffer 的内存分配，等等。这里限于篇幅便不详细展开介绍了，感兴趣的同学可以自行搜索阅读 sonic 源码进行了解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;性能测试&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以前文中的不同测试场景进行测试，得到结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;259&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.46440677966101696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaTEXRLjJ4sDdFQGTvfP2A0gaCk2VdgAN3nvdlQuZSkrRtETiazdkd1GaAKsN2xEaaCqcBHU2khDTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3245&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小数据（400B，11 个 key，深度 3 层）&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;251&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.44998461064943057&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaTEXRLjJ4sDdFQGTvfP2A0SGPLjjBa016SS1nMN9dXoCILibLroR6cJX9WicgKsweb61wGMzl28oiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3249&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;中数据（110KB，300+ key，深度 4 层）&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;250&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.44745762711864406&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaTEXRLjJ4sDdFQGTvfP2A0sEuykFSIIsEWWDGx7ibqCQHgGzX8aqzm68Wic72a22sWByKnLNuX9sPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3245&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大数据（550KB，10000+ key，深度 6 层）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到 sonic 在几乎所有场景下都处于领先（sonic-ast 由于直接使用了 Go Assembly 导入的 C 函数导致小数据集下有一定性能折损）&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;平均编码性能较 json-iterator 提升 240% ，平均解码性能较 json-iterator 提升 110% ；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单 key 修改能力较 sjson 提升 75% 。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且在生产环境中，sonic 中也验证了良好的收益，服务高峰期占用核数减少将近三分之一：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;338&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.60625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaTEXRLjJ4sDdFQGTvfP2A0ZibGPQxV6yFavpQKg3ODEgZyKkMwPRAayC3z05RZibEOknDibjibx5Tdgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;字节某服务在 sonic 上线前后的 CPU 占用（核数）对比&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;结语&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于底层基于汇编进行开发，sonic 当前仅支持 amd64 架构下的 darwin/linux 平台 ，后续会逐步扩展到其它操作系统及架构。除此之外，我们也考虑将 sonic 在 Go 语言上的成功经验移植到不同语言及序列化协议中。目前 sonic 的 C++ 版本正在开发中，其定位是基于 sonic 核心思想及底层算子实现一套通用的高性能 JSON 编解码接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;近日，sonic 发布了第一个大版本 v1.0.0，标志着其除了可被企业灵活用于生产环境，也正在积极响应社区需求、拥抱开源生态。我们期待 sonic 未来在使用场景和性能方面可以有更多突破，欢迎开发者们加入进来贡献 PR，一起打造业界最佳的 JSON 库！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;相关链接&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目地址：https://github.com/bytedance/sonic&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BenchMark：https://github.com/bytedance/sonic/blob/main/bench.sh&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d82b3112b8fffa5bb22b7572ea30a579</guid>
<title>也许你该找个人聊聊？</title>
<link>https://toutiao.io/k/1qrbh71</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bc6d5a44d41be344a0cfc26b993ef8b7</guid>
<title>十亿用户的系统！</title>
<link>https://toutiao.io/k/pqsnqhd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;前几天有朋友问了这么个问题，这是一道面试题：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;十亿用户的系统，用户可以用手机号、账号、邮箱、昵称等登录，这样的表结构应该怎样设计？登录流程大致是怎样的？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好家伙！十亿用户的系统……&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在我看来，这道面试题主要是想考察两点：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;面试者是否做过相关业务或者有非常扎实的数据库表设计能力&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;面试者是否真的了解在高并发下应该怎么分库分表&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们先看第一个问题：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;表结构怎么设计？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当出现多种登录方式的时候，就意味着一个用户对应的账号可能会有若干个。现在可能用手机和昵称登录，以后就可能用邮箱登录，甚至将来还可能通过微信、QQ、微博等第三方渠道登录。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，直觉上，咱们第一个冒出的念头是什么？对我个人来说，就是本能的想着，如果是多种登录类型，就在存储用户信息的表上加多个字段。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;比如，支持手机号登录，就加一个手机号字段，支持邮箱登录，就加一个邮箱字段等等。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;表结构类似下面这样：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;id&lt;span class=&quot;code-snippet__params&quot;&gt;|name|&lt;/span&gt;phone&lt;span class=&quot;code-snippet__params&quot;&gt;|email|&lt;/span&gt;nick_name&lt;span class=&quot;code-snippet__params&quot;&gt;|desc&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是仔细一想，这种设计存在问题：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;当用户登录的时候，我们需要根据用户的登录类型，先要知道去查找用户表的哪个字段才可以进行登录逻辑判断。例如，用户登录用手机号了，我们就要知道去表里查找对应的 phone 字段去校验登录；登录用邮箱了，我们就要知道去表里查找对应的 email 字段才可以。这样做，代码逻辑会很复杂。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;再增加一种登录方式的时候，我们还得给数据库的表里再增加一个字段，同时还得修改登录的代码。这种修改一不小心，还很容易修改不完善，造成线上 bug。每增加一种登录方式，就搞一次这种流程，成本有点过高了。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此，我们最好能找到另一种更灵活的办法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;更灵活的办法就意味着，我们设计的表，必须易扩展。怎么叫易扩展？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;加记录比加字段要更容易扩展。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样的话，我们只能想想是不是考虑列变行的思路了，即添加字段变成添加行记录来解决。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此方案如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;创建一张授权表，专门用来处理登录。当新增登录类型的时候，只需要考虑增加一条记录即可：记录登录类型、登录名称以及相关密码，同时有个 user_id 字段，去和用户表做关联。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6168032786885246&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KS7zNT0Jvu2ianT9eGK5kh2WbNoCEkC6mDD2VOcwtm6k788PqqiaCKpkJFzOUFjgBMUrj5HKmCjlkPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;976&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;用户表就存储一些非登录相关的额外信息即可。像这样：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9400630914826499&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KS7zNT0Jvu2ianT9eGK5kh2Wmmo4phibJqq0YUHPfIxOugPiax4uKIv4ofh9Nl3jaJT6qF7YyGLWJFEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;634&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样设计后，很明显就做到了易扩展。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假如我自己有两种登录方式，授权表（Author）的数据：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.17220543806646527&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQysy0HuQxRLZ4HSwT66pXeKFbLoRMV4bBvssia9yXT87bFG7Fg4BCKWWXgvyuTVfvqGn4Siatygopicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;993&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;用户表（User）的数据：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.12185297079556898&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQysy0HuQxRLZ4HSwT66pXeKfCkliclic09AxYviahwHhaUwqSUOXGWX0swLc0Jp91Sv4QiaQ34dW0kLOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;993&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种方案的缺点就是，改密码的时候，得一起改动。需要注意。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;说完表结构后，再来说下一个问题：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;十亿用户系统的登录流程&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;乍一看，这道题里有十亿用户，那基本可以算是高并发、大数据了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为十亿用户，哪怕有百分之一的活跃用户，也是千万级别的。所以，在这样的情况下，必然需要考虑分库分表。分库是为了应对高并发，分表则是为了应对大数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以 MySQL 为例， 一般来讲，在 4核CPU/8G内存/RAID10 的普通硬盘的服务器配置下，一台 &lt;span&gt;M&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt; 库能一直可靠运行的可承载压力是 1000TPS 左右。一张通常的 20 个字段以内的表，能保证查询性能没有大的下降的话，可承载的数据量大致是 1000 万条数据左右。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，咱们分表的时候就要尽量控制表数据不超过一千万条数据。也因此，十亿用户，分表就是分 100 张表。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同时呢，咱们说了，一台库大概能承载的可靠运行并发数是 1000TPS 左右。分库一般来说，100 张表分 10 个库，每个库 10 张表，就很绰绰有余了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好，现在问题来了，&lt;/span&gt;&lt;span&gt;分库分表的策略是什么呢？就是按什么分呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一般是按照 user_id 分。假如我们要分 10 个库 100 张表是吧， 一般来说就是先通过 user_id mod 10 去定义好库，再通过 user_id mod 100 定义好表。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;比如 user_id mod 10 = 3，user_id mod 100 = 33，那么这个用户的数据就被定位到了数据库 3 中的 33 号表。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注意，这里又来了一个问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设一个 user_id = 100 会怎么样？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;user_id  mod 10 = 0，user_id mod 100 = 0。它会被分在 0 号库，0 号表。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那如果我想分到 1 号库，0 号表呢，有对应的 user_id 吗？&lt;/span&gt;&lt;span&gt;是没有的。为什么呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为当一个 user_id mod 100 = 0 时，这个 user_id mod 10 也一定为 0 。所以，不会存在 1 号库，0 号表的情况。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，我们还需要对库进行调整，要把库变成 11 个库，然后呢，每个库有 100 张表。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原因就是：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;库数和表数之间不能存在公约数，也就是他们需要互质，只有这样，我们分配数据的时候，才会尽量均匀。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好了，当 user_id 分完之后，你会发现，按照咱们的设计，只能解决 User 表的问题。那登录在哪里？该怎么办？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;咱们继续看，前面说了，登录逻辑是靠 Author 表来验证。那 Author 表数据大，也得分库分表啊？它怎么分？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实挺简单，分库分表的时候，我们根据 Author 表的 user_name 的 Hash 去分。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设有个用户的 user_name 是 abc，然后将这个 abc 进行下 hash，再除以库的数量。现在是 11 个库，所以就是 hash(abc) mod 11 这样得到库的编号，然后再 hash(abc) mod 100 得到表的编号。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;于是，当我们登录的时候，流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;输入 abc 和密码；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;验证出账号类型；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将信息传递给服务器；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;服务器在数据库层之上会有一个路由层，根据 hash(abc) mod 11/100 定位数据库和表；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;查询 Author 表验证。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这道题到此为止，算是回答完毕了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是，我要在此再多说一点东西。面试题这里，其实是限制死了，只让你考虑数据库。但是在实际工作当中呢，对于这种高并发、大数据的解决，方向往往是多重索引，加外置缓存。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为，在面试题中，我们只需要考虑登录问题。而在实际工作里，我们往往还需要考虑数据重用、资源耗费等问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，实际上，很多这种高并发、大数据的登录，我们根据手头的资源，虽然依然会使用分库分表，但是，往往还会采用 ElasticSearch 缓存一些用户基本信息和用户数据所在的数据库和表的地址信息，将他们作为索引，去真正的做相关登录业务行为。并根据用户字段的使用热度，会在登录时，把一些用户关键字段读取出来，放到外置的 Redis 缓存中，供以后重用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样做的好处就是，分库分表我们可以根据资源随意增加减少，只需要到时候修改下 ElasticSearch 中的索引信息即可。同时，有了 Redis，也能减少后面分库分表资源的消耗。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651506905&amp;amp;idx=2&amp;amp;sn=be4dc72831a156ff656ca5c40e643944&amp;amp;chksm=bd25a4a68a522db0b135b5fb87ffc5b76c27aeeaf9407a3ca7beadda7b47b61e06a963556516&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;B站高可用架构实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;B站高可用架构实践&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651501882&amp;amp;idx=1&amp;amp;sn=5905a566d095ab63f2d3505b7fbfdd33&amp;amp;chksm=bd25d9458a5250537bd86cd82d3b8194bf14811e8a4e6888865fe528eee43d98570b0dc4dbc7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Kafka 架构设计的任督二脉&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Kafka 架构设计的任督二脉&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651501882&amp;amp;idx=1&amp;amp;sn=5905a566d095ab63f2d3505b7fbfdd33&amp;amp;chksm=bd25d9458a5250537bd86cd82d3b8194bf14811e8a4e6888865fe528eee43d98570b0dc4dbc7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Kafka 架构设计的任督二脉&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651501881&amp;amp;idx=1&amp;amp;sn=fedcb35a5a47b3a2ce9bef2073482429&amp;amp;chksm=bd25d9468a525050d6587dd3651913ccebf98e1b85a3acd7a18695750ca574719ddd52584e0c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;ElasticSearch让人叹为观止的分布式系统架构设计&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;ElasticSearch让人叹为观止的分布式系统架构设计&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>71f11aea97679613d0d0e02530d7b567</guid>
<title>TCP网络那点破事！三次握手、四次挥手、TIME-WAIT、HTTP 2.0 ....</title>
<link>https://toutiao.io/k/igh5e8c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;10&quot; data-source-title=&quot;&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;来自公众号：&lt;span&gt;微观技术&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是Tom哥~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天主要给各位分享&lt;code&gt;TCP网络&lt;/code&gt;的一些常见知识点，日常工作或面试会经常遇到。考虑内容篇幅不小，建议先收藏，慢慢咀嚼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有帮助，也请转给身边的朋友们，”独乐乐不如众乐乐“&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，来个目录，让大家对文章内容先有个直观了解&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.024945770065076&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwdRomH3FoIUyOnHOhxmENBvYWY9TIB7H14hiaic9lK8tjQN1gbQusSaQgWOvyYC9icVTPa0LX7W5ZKDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;922&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;网络的七层模型，简单介绍每层的作用？&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：分为7层，从下到上依次是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;应用层：计算机用户与网络之间的接口，常见的协议有：HTTP、FTP、 SMTP、TELNET&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表示层：数据的表示、安全、压缩。将应用处理的信息转换为适合网络传输的格式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;会话层：建立和管理本地主机与远程主机之间的会话。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;传输层：定义传输数据的&lt;code&gt;协议端口号&lt;/code&gt;，以及流控和差错校验，保证报文能正确传输。协议有TCP、UDP&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网络层：路由选择算法，进行逻辑地址寻址，实现不同网络之间的最佳路径选择。协议有IP、ICMP&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据链路层：接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层的数据叫做帧。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;物理层：建立、维护、断开物理连接。传输比特流（将1、0转化为电流强弱来进行传输，到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.63125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwdRomH3FoIUyOnHOhxmENBvMYUsbNmTZ8lezG0pEZ0X7whHQVyO6MbxS1hzOpzBDyPZDR5cl1NO4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;TCP 报文首部有哪些字段?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6567425569176882&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwdRomH3FoIUyOnHOhxmENBvaZ1PKzDu2mMvjvwlT1M5n9NR9F72xajuz4IicibJheSacQOFM0j3jxRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;源端口、目的端口：各占2个字节，表示数据从哪个进程来，去往哪个进程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;序号（Sequence Number）：占4个字节，TCP连接中传送的数据每一个字节都会有一个序号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;确认号（Acknowledgement Number）：占4个字节，另一方发送的tcp报文段的响应&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据偏移：头部长度，占4个字节，表示TCP报文段的数据距离TCP报文段的起始处有多远。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;6位标志位：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;URG：紧急指针是否有效&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ACK：表示确认号是否有效&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PSH：提示接收端应用程序立刻将数据从tcp缓冲区读走&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RST：表示要求对方重新建立连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SYN：这是一个连接请求或连接接受的报文&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;FIN：告知对方本端要关闭连接&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;窗口大小：占4个字节，用于TCP流量控制。告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;校验和：占2个字节，由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。检验的范围包括头部、数据两部分，是TCP可靠传输的一个重要保障。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;紧急指针：占2个字节，一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号，用于发送端向接收端发送紧急数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;TCP 三次握手过程？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：目的是同步连接双方的序列号和确认号，并交换TCP窗口。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一次握手，客户端发送(seq=x)，客户端进入&lt;/span&gt;&lt;code&gt;&lt;span&gt;SYN_SEND&lt;/span&gt;&lt;/code&gt;&lt;span&gt;状态&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二次握手，服务端响应(Seq=y, Ack=x+1)，服务器端就进入&lt;/span&gt;&lt;code&gt;&lt;span&gt;SYN_RCV&lt;/span&gt;&lt;/code&gt;&lt;span&gt;状态。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第三次握手，客户端收到服务端的确认后，发送(Ack=y+1)，客户端进入&lt;/span&gt;&lt;code&gt;&lt;span&gt;ESTABLISHED&lt;/span&gt;&lt;/code&gt;&lt;span&gt;状态。当服务器端接收到这个包时，也进入&lt;/span&gt;&lt;code&gt;&lt;span&gt;ESTABLISHED&lt;/span&gt;&lt;/code&gt;&lt;span&gt;状态。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8194444444444444&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwdRomH3FoIUyOnHOhxmENBvsxho6J2Z0LjgdMJibJOgO0qAT6NlQcazaaHSnWSu2Fj300Ay6PswhWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;792&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;br/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;为什么是三次握手，而不是两次或四次？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果只有两次握手，那么服务端向客户端发送 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SYN/ACK&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 报文后，就会认为连接建立。但是如果客户端没有收到报文，那么客户端是没有建立连接的，这就导致服务端会浪费资源。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用两次握手无法建立 TCP 连接，而使用三次握手是建立连接所需要的最小次数&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;TCP 四次挥手的过程？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一次挥手：客户端向服务端发送连接释放报文&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二次挥手：服务端收到连接释放报文后，立即发出确认报文。这时 TCP 连接处于半关闭状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三次挥手：服务端向客户端发送连接释放报文&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第四次挥手：客户端收到服务端的连接释放报文后，立即发出确认报文。此时，客户端就进入了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;TIME-WAIT&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 状态。注意此时客户端到 TCP 连接还没有释放，必须经过 2*MSL（最长报文段寿命）的时间后，才进入&lt;/span&gt;&lt;code&gt;&lt;span&gt;CLOSED&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 状态。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.725576289791438&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwdRomH3FoIUyOnHOhxmENBv7BicFBax3vfnWmRNC5p9Hx3gYiaibfIpPprOChqFcf7iawVF369XYX6RSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;911&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;为什么需要四次挥手？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：TCP 是&lt;/span&gt;&lt;code&gt;&lt;span&gt;全双工&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。一方关闭连接后，另一方还可以继续发送数据。所以四次挥手，将断开连接分成两个独立的过程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;客户端 TIME-WAIT ，为什么要等待 2MSL 才进入 CLOSED 状态？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：MSL 是报文段在网络上最大存活时间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;确保 ACK 报文能够到达服务端，从而使服务端正常关闭连接。客户端在发送完最后一个 ACK 报文段后，再经过 2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;一台 8G 内存服务器，可以同时维护多少个连接？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：发送、接收缓存各4k，还要考虑socket描述符，一个tcp连接需要占用的最小内存是8k，那么最大连接数为：&lt;/span&gt;&lt;code&gt;&lt;span&gt;8*1024*1024 K / 8 K = 1048576 个&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，即约100万个tcp长连接。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;什么是拆包？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：传输层封包不能太大，基于这个限制，往往以缓冲区大小为单位，将数据拆分成多个 TCP 段（&lt;/span&gt;&lt;code&gt;&lt;span&gt;TCP Segment&lt;/span&gt;&lt;/code&gt;&lt;span&gt;）传输。在接收数据的时候，一个个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;TCP 段&lt;/span&gt;&lt;/code&gt;&lt;span&gt;又被重组成原来的数据。简单来讲分为几个过程：拆分——传输——重组。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;什么是粘包？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：解决数据太小问题，防止&lt;/span&gt;&lt;code&gt;&lt;span&gt;多次发送&lt;/span&gt;&lt;/code&gt;&lt;span&gt;占用资源。TCP 协议将它们合并成一个 TCP 段发送，在目的地再还原成多个数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;缓冲区是做什么用？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：缓冲区是在内存中开辟的一块区域，目的是缓冲。当应用频繁地通过网卡收、发数据，网卡只能一个一个处理。当网卡忙不过来的时候，数据就需要排队，也就是将数据放入缓冲区。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注意：TCP Segment 的大小不能超过缓冲区大小。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;TCP 协议是如何保证数据的顺序？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.20234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwdRomH3FoIUyOnHOhxmENBv5FJQGXYRMxECxFc2Uzjm5vNyia2Bhg3hRFRpfsjWSHNBEfccymJc35w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大数据拆包成多个片段，发送可以保证有序，但是由于网络环境复杂，并不能保证它们到达时也是有序的，为了解决这个问题，对每个片段用&lt;/span&gt;&lt;code&gt;&lt;span&gt;Sequence Number&lt;/span&gt;&lt;/code&gt;&lt;span&gt;编号，接收数据的时候，通过 Seq 进行排序。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注意：seq是累计的发送字节数&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;TCP 协议如何解决丢包？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：丢包需要重发，关键是如何判断有没有丢包！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;每一个数据包，接收方都会给发送方发响应。每个 TCP 段发送时，接收方已经接收了多少数据，用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Acknowledgement Number&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（简写ACK） 表示。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注意：ack是累计的接收字节数，表示这个包之前的包都已经收到了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;什么是 MSS ?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：MSS 全称 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Maximun Segment Size&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。是TCP Header 中的可选项（Options），控制了 TCP 段的大小，不能由单方决定，需要双方协商。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;TCP 协议如何控制流量传输速度？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：简单讲通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;滑动窗口&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。发送、接收窗口的大小可以用来控制 TCP 协议的流速。窗口越大，同时可以发送、接收的数据就越多，吞吐量也就越大。但是窗口越大，如果数据发生错误，损失也就越大，因为需要重传越多的数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TCP每个请求都要有响应，如果一个请求没有收到响应，发送方就会认为这次发送出现了故障，会触发重发。为了提升吞吐量，一个TCP段再没有收到响应时，可以继续发送下一个段。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5450081833060556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwdRomH3FoIUyOnHOhxmENBvdoNu7Giaza2xicichwJvCpVK5P7pDaxbWPzYcuPWelonKzLNIzgQcibRww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1222&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;br/&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;窗口区域包含两类数据：已发送未确认、未发送（即将发送）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;窗口中序号最小的分组如果收到 ACK，窗口就会向右滑动&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;滑动窗口的size规格可能会变化，需要从ACK数据包实时取最新值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果最小序号的分组长时间没有收到 ACK，就会触发整个窗口的数据重新发送&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;HTTP 1.0 、1.1 和 HTTP 2.0 有什么区别？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、HTTP 1.0&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;默认是短连接，每次与服务器交互，都需要新开一个连接。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、HTTP 1.1&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;默认持久化连接，建立一次连接，多次请求均由这个连接完成。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、HTTP 2.0&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;二进制分帧：在应用层和传输层之间加了一个二进制分帧层，将所有传输的信息分割为更小的消息和帧（frame），并对它们采用二进制格式的编码。减少服务端的压力，内存占用更少，连接吞吐量更大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多路复用：允许同时通过单一的HTTP/2.0连接发起多次的请求-响应消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;头部压缩：采用了&lt;/span&gt;&lt;code&gt;&lt;span&gt;Hpack&lt;/span&gt;&lt;/code&gt;&lt;span&gt;头部压缩算法对Header进行压缩，减少重复发送。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务器推送：服务器主动将一些资源推送给浏览器并缓存起来。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;HTTP 与 HTTPS 的区别？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：HTTPS = HTTP + SSL/TLS&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;HTTP 采用明文通讯；端口 80&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;HTTPS 在HTTP的基础上加入了&lt;/span&gt;&lt;code&gt;&lt;span&gt;SSL/TLS协议&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，SSL/TLS依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。端口 443&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;HTTP 协议为什么要设计成无状态？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：HTTP是一种无状态协议，每个请求都是独立执行，请求/响应。这样设计的重要原因是，降低架构设计复杂度，毕竟服务器一旦带上了状态，&lt;/span&gt;&lt;code&gt;&lt;span&gt;扩容、缩容、路由&lt;/span&gt;&lt;/code&gt;&lt;span&gt;都会受到制约。无状态协议不要求服务器在多个请求期间保留每个用户的信息。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但，你可能会问，如果有登录要求的业务怎么办？HTTP协议提供扩展机制，Header中增加了Cookie，存储在客户端，每次请求时自动携带，采用空间换时间机制，满足上下请求关联。虽然浪费了些网络带宽，但是减少了复杂度。当然为了减轻网络负担，浏览器会限制Cookie的大小，不同浏览器的限制标准略有差异，如：Chrome 10，限制最多 180个，每个Cookie大小不能超过 4096 bytes&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;HTTPS 的访问流程是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;客户端发起一个http请求，告诉服务器自己支持哪些hash算法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;服务端把自己的信息以&lt;/span&gt;&lt;code&gt;&lt;span&gt;数字证书&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的形式返回给客户端（公钥在证书里面，私钥由服务器持有）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端收到服务器的响应后会先验证证书的合法性（证书中包含的地址与正在访问的地址是否一致，证书是否过期）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果证书验证通过，就会生成一个随机的&lt;/span&gt;&lt;code&gt;&lt;span&gt;对称密钥&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，用证书的公钥加密。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端将证书公钥加密后的密钥发送给服务端&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端用私钥解密，解密之后就得到客户端的密钥&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后，客户端与服务端就靠密钥完成明文加密、安全通信、对称解密&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;对称加密与非对称加密有什么区别？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对称加密。加密和解密使用同一个密钥。速度快。常用的如：AES、DES&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非对称加密。公钥与私钥配对出现，公钥对数据加密，私钥对数据解密。常用的如：RSA、DSS&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;TCP 抓包用什么工具？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：Wireshark，应用最广泛的网络协议分析器。功能非常丰富&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;支持数百个协议&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实时捕获、离线分析&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持 Windows、Linux、macOS、Solaris、FreeBSD、NetBSD等平台；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;界面化操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持 Gzip&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持 IPSec&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;span&gt;--- EOF ---&lt;/span&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;推荐↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAxNTcyNzAyOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/NW4iaKVI4GNOJHFfxs3Dq0jLTT7riaETbUFsDsjYiaOftPu1tdHm0icq8sgibZo5ZEiaHGbLLxSVrd3B5psBZVwVCdHQ/0?wx_fmt=png&quot; data-nickname=&quot;运维&quot; data-alias=&quot;Operation1024&quot; data-signature=&quot;分享网络管理、网络运维、运维规划、运维开发、Python运维、Linux运维等知识，推广围绕DevOps理念的自动化运维、精益运维、智能运维等优秀实践，让运维工程师更加专注于自动化。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1a978802eb39076705febe4251ff245e</guid>
<title>弄懂 SourceMap，前端开发提效 100%</title>
<link>https://toutiao.io/k/51qgzo1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3&gt;&lt;span&gt;一、什么是 Source Map&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;通俗的来说， &lt;/span&gt;&lt;code&gt;Source Map&lt;/code&gt;&lt;span&gt; 就是一个信息文件，里面存储了代码打包转换后的位置信息，实质是一个 &lt;/span&gt;&lt;code&gt;json&lt;/code&gt;&lt;span&gt; 描述文件，维护了打包前后的代码映射关系。&lt;/span&gt;&lt;span&gt;关于 &lt;/span&gt;&lt;code&gt;Source Map&lt;/code&gt;&lt;span&gt; 的解释可以看下 &lt;/span&gt;&lt;span&gt;Introduction to JavaScript Source Maps&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们线上的代码一般都是经过打包的，如果线上代码报错了，想要调试起来，那真是很费劲了，比如下面这个例子：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用打包工具 &lt;code&gt;Webpack&lt;/code&gt; ，编译这一段代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;source map!!!&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(a); &lt;span&gt;//这一行肯定会报错&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;浏览器打开后的效果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3381995133819951&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbY7ghicz1hX15rN6QGSdcIm2sNcMsxdlCia4DcAf4iaJjbXZ3ztA8hwmy1g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;822&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击进入报错文件之后：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8689320388349514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYddEmEFucSetP9e4icMdGIa2ZDFwglicll4DN9sZ8qSJ3XamEwJ0yB4sA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;824&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这根本没法找到具体位置以及原因，所以这个时候， &lt;code&gt;Source Map&lt;/code&gt; 的作用就来了， &lt;code&gt;Webpack&lt;/code&gt; 构建代码中，开启 &lt;code&gt;Source Map&lt;/code&gt; ：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5933908045977011&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYPKQwdE0ha0CQZd0hicggXogoWkyqQS9IK4bbZ3Js34ky740qibStkMwA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;696&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后重新执行构建，再次打开浏览器：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9087875417130145&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYbjWtJPYraTG5uufU7QiaQBErrLv17JtClLadibLBKjHfTb4saPP6CyKA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;899&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以发现，可以成功定位到具体的报错位置了，这就是 &lt;code&gt;Source Map&lt;/code&gt; 的作用。需要注意一点的是， &lt;code&gt;Source Map&lt;/code&gt; 并不是 &lt;code&gt;Webpack&lt;/code&gt; 特有的，其他打包工具同样支持 &lt;code&gt;Source Map&lt;/code&gt; ，打包工具只是将 &lt;code&gt;Source Map&lt;/code&gt; 这项技术通过配置化的方式引入进来。关于打包工具，下文会有介绍。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;二、Source Map 的作用&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;上面的案例只是 &lt;/span&gt;&lt;code&gt;Source Map&lt;/code&gt;&lt;span&gt; 的初体验，现在来说一下它的作用，我们为什么需要 &lt;/span&gt;&lt;code&gt;Source Map&lt;/code&gt;&lt;span&gt; ?&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阮一峰老师的&lt;span&gt;JavaScript Source Map 详解&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;指出，JavaScript 脚本正变得越来越复杂。大部分源码（尤其是各种函数库和框架）都要经过转换，才能投入生产环境。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的源码转换，主要是以下三种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;压缩，减小体积&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多个文件合并，减少 HTTP 请求数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其他语言编译成 JavaScript&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这三种情况，都使得实际运行的代码不同于开发代码，除错（ &lt;code&gt;debug&lt;/code&gt; ）变得困难重重，所以才需要 &lt;code&gt;Source Map&lt;/code&gt; 。结合上面的例子，即使打包过后的代码，也可以找到具体的报错位置，这使得我们 &lt;code&gt;debug&lt;/code&gt; 代码变得轻松简单，这就是 &lt;code&gt;Source Map&lt;/code&gt; 想要解决的问题。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;三、如何生成 Source Map&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;各种主流前端任务管理工具，打包工具都支持生成 &lt;/span&gt;&lt;code&gt;Source Map&lt;/code&gt;&lt;span&gt; 。&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.1 UglifyJS&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;UglifyJS&lt;/code&gt; 是命令行工具，用于压缩 &lt;code&gt;JavaScript&lt;/code&gt; 代码&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装 &lt;code&gt;UglifyJS&lt;/code&gt; ：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;npm install uglify - js - g&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;压缩代码的同时生成 &lt;code&gt;Source Map&lt;/code&gt; ：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;uglifyjs app.js - o app.min.js--source - map app.min.js.map&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Source Map&lt;/code&gt; 相关选项：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;--source - map Source &lt;span&gt;Map&lt;/span&gt;的文件的路径和名称&lt;br/&gt;    --source - map - root 源文件的路径&lt;br/&gt;    --source - map - url &lt;span&gt;//#sourceMappingURL的路径。 默认为--source-map指定的值。&lt;/span&gt;&lt;br/&gt;    --source - map - include - sources 是否将源代码的内容添加到sourcesContent数组&lt;br/&gt;    --source - map - inline 是否将Source &lt;span&gt;Map&lt;/span&gt;写到压缩代码的最后一行&lt;br/&gt;    -- &lt;span&gt;in&lt;/span&gt; -source - map 输入Source &lt;span&gt;Map&lt;/span&gt;， 当源文件已经经过变换时使用&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.2 Grunt&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Grunt&lt;/code&gt; 是 &lt;code&gt;JavaScript&lt;/code&gt; 项目构建工具&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置 &lt;code&gt;grunt-contrib-uglify&lt;/code&gt; 插件以生成 &lt;code&gt;Source Map&lt;/code&gt; ：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;grunt.initConfig({&lt;br/&gt;    &lt;span&gt;uglify&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;options&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;sourceMap&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;});&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;grunt-usemin&lt;/code&gt; 打包源码时， &lt;code&gt;grunt-usemin&lt;/code&gt; 会依次调用&lt;span&gt;grunt-contrib-concat&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;与&lt;span&gt;grunt-contrib-uglify&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;对源码进行打包和压缩。因此都需要进行配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;grunt.initConfig({&lt;br/&gt;    &lt;span&gt;concat&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;options&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;sourceMap&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;uglify&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;options&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;sourceMap&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;sourceMapIn&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;uglifySource&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; uglifySource + &lt;span&gt;&#x27;.map&#x27;&lt;/span&gt;;&lt;br/&gt;            },&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;});&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.3 Gulp&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Gulp&lt;/code&gt; 是 &lt;code&gt;JavaScript&lt;/code&gt; 项目构建工具&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;span&gt;gulp-sourcemaps&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;生成 &lt;code&gt;Source Map&lt;/code&gt; :&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; gulp = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;gulp&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; plugin1 = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;gulp-plugin1&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; plugin2 = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;gulp-plugin2&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; sourcemaps = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;gulp-sourcemaps&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;gulp.task(&lt;span&gt;&#x27;javascript&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;function&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;    gulp.src(&lt;span&gt;&#x27;src/**/*.js&#x27;&lt;/span&gt;)&lt;br/&gt;        .pipe(sourcemaps.init())&lt;br/&gt;        .pipe(plugin1())&lt;br/&gt;        .pipe(plugin2())&lt;br/&gt;        .pipe(sourcemaps.write(&lt;span&gt;&#x27;../maps&#x27;&lt;/span&gt;))&lt;br/&gt;        .pipe(gulp.dest(&lt;span&gt;&#x27;dist&#x27;&lt;/span&gt;));&lt;br/&gt;});&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.4 SystemJS&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SystemJS&lt;/code&gt; 是模块加载器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;span&gt;SystemJS Build Tool&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;生成 &lt;code&gt;Source Map&lt;/code&gt; :&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;builder.bundle(&lt;span&gt;&#x27;myModule.js&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;outfile.js&#x27;&lt;/span&gt;, {&lt;br/&gt;    &lt;span&gt;minify&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;sourceMaps&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;sourceMapContents&lt;/code&gt;选项可以指定是否将源码写入&lt;code&gt;Source Map&lt;/code&gt;文件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.5 Webpack&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Webpack&lt;/code&gt; 是前端打包工具（本文案例都会使用该打包工具）。在其配置文件 &lt;code&gt;webpack.config.js&lt;/code&gt; 中设置&lt;span&gt;devtool&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt;即可生成 &lt;code&gt;Source Map&lt;/code&gt; 文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; path = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;path&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;    &lt;span&gt;entry&lt;/span&gt;: &lt;span&gt;&#x27;./src/index.js&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;output&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;filename&lt;/span&gt;: &lt;span&gt;&#x27;bundle.js&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;path&lt;/span&gt;: path.resolve(__dirname, &lt;span&gt;&#x27;dist&#x27;&lt;/span&gt;)&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;devtool&lt;/span&gt;: &lt;span&gt;&quot;source-map&quot;&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;devtool&lt;/strong&gt;有 20 多种不同取值，分别生成不同类型的&lt;code&gt;Source Map&lt;/code&gt;，可以根据需要进行配置。下文会详细介绍，这里不再赘述。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.6 Closure Compiler&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用 &lt;span&gt;Closure Compiler&lt;/span&gt;&lt;sup&gt;[14]&lt;/sup&gt; 生成&lt;/p&gt;&lt;h3&gt;&lt;span&gt;四、如何使用 Source Map&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;生成 &lt;/span&gt;&lt;code&gt;Source Map&lt;/code&gt;&lt;span&gt; 之后，一般在浏览器中调试使用，前提是需要开启该功能，以 &lt;/span&gt;&lt;code&gt;Chrome&lt;/code&gt;&lt;span&gt; 为例：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打开开发者工具，找到 &lt;code&gt;Settins&lt;/code&gt; ：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5809128630705395&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYx9icLIbVK7e73cqe9fB4OwtBnNicCbNzHKfN27MB2Fza9hRftfUiaibibEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;482&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;勾选以下两个选项：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6755083996463307&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYUXrb25xXKhQKSXMaskElNH01D06uicKrjSbfIQOMhU5h09vXwhmGBvA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1131&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再回到上面的案例中，源代码文件变成了 &lt;code&gt;index.js&lt;/code&gt; ，点击进入后显示真实的源代码，即说明成功开启并使用了 &lt;code&gt;Source Map&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8337028824833703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYBerjichj4gyxlpGmAVwppjd26aWP6BBB3hNeOZCDM4uGexr0LIHdxOg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;902&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;五、Source Map 的工作原理&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是上面这个案例，执行打包后，生成 &lt;code&gt;dist&lt;/code&gt; 文件夹，打开 &lt;code&gt;dist/bundld.js&lt;/code&gt; ：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41203703703703703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbY7iaJ9s3xDDxsIgljSRSQKPEZV6HIsmo2f9Yw3DBibf21suPl9t5rL8Rw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;864&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到尾部有这句注释：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//# sourceMappingURL=bundle.js.map&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正是因为这句注释，标记了该文件的 &lt;code&gt;Source Map&lt;/code&gt; 地址，浏览器才可以正确的找到源代码的位置。&lt;code&gt;sourceMappingURL&lt;/code&gt; 指向 &lt;code&gt;Source Map&lt;/code&gt; 文件的 &lt;code&gt;URL&lt;/code&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了这种方式之外，&lt;span&gt;MDN&lt;/span&gt;&lt;sup&gt;[15]&lt;/sup&gt;中指出，可以通过 &lt;code&gt;response header&lt;/code&gt; 的 &lt;code&gt;SourceMap: &amp;lt;url&amp;gt;&lt;/code&gt; 字段来表明。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;gt; SourceMap: /path/to/file.js.map&lt;br/&gt;&amp;gt; ```&lt;br/&gt;&lt;br/&gt;`dist` 文件夹中，除了 `bundle.js` 还有 `bundle.js.map` ，这个文件才是 `Source Map` 文件，也是 `sourceMappingURL` 指向的 `URL`&lt;br/&gt;&lt;br/&gt;![](https://files.mdnice.com/user/20608/9124506c-2e1d-410e-b141-97062b36fc3f.png)&lt;br/&gt;&lt;br/&gt;* `version`：`Source map`的版本，目前为`v3`。&lt;br/&gt;* `sources`：转换前的文件。该项是一个数组，表示可能存在多个文件合并。&lt;br/&gt;* `names`：转换前的所有变量名和属性名。&lt;br/&gt;* `mappings`：记录位置信息的字符串，下文会介绍。&lt;br/&gt;* `file`：转换后的文件名。&lt;br/&gt;* `sourceRoot`：转换前的文件所在的目录。如果与转换前的文件在同一目录，该项为空。&lt;br/&gt;* `sourcesContent`：转换前文件的原始内容。&lt;br/&gt;&lt;br/&gt;&lt;span&gt;##### 5.1 关于Source map的版本&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;在2009年 `Google` 的一篇文章中，在介绍 `Cloure Compiler` 时， `Google` 也趁便推出了一款调试东西： `Firefox` 插件 `Closure Inspector` ，以便利调试编译后代码。这便是 `Source Map` 的初步代啦！&lt;br/&gt;&lt;br/&gt;&amp;gt; You can use the compiler with Closure Inspector , a Firebug extension that makes debugging the obfuscated code almost as easy as debugging the human-readable &lt;span&gt;source&lt;/span&gt;.&lt;br/&gt;&lt;br/&gt;2010年，在第二代即 `Closure Compiler Source Map 2.0` 中， `Source Map` 招认了共同的 `JSON` 格式及其他标准，已几乎具有现在的雏形。最大的差异在于 `mapping` 算法，也是 `Source Map` 的要害地址。第二代中的 `mapping` 已决定运用 `base 64` 编码，可是算法同现在有收支，所以生成的 `.map` 比较现在要大许多。&lt;br/&gt;2011年，第三代即[**Source Map Revision 3 Proposal**](https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit&lt;span&gt;#)出炉了，这也是咱们现在运用的 `Source Map` 版别。从文档的命名看来，此刻的 `Source Map` 已脱离 `Clousre Compiler` ，演化成了一款独立东西，也得到了浏览器的支撑。这一版相较于二代最大的改动是 `mapping` 算法的紧缩换代，运用[VLQ](https://en.wikipedia.org/wiki/Variable-length_quantity)编码生成[base64](https://zh.wikipedia.org/zh-cn/Base64)前的 `mapping` ，大大缩小了 `.map` 文件的体积。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;`Source Map` 发展史的诙谐之处在于，它作为一款辅佐东西被开发出来。毕竟它辅佐的方针日渐式微，而它却成为了技能主体，被写进了浏览器中。&lt;br/&gt;&lt;br/&gt;&amp;gt; Source Map V1最初步生成的Source Map文件大概有转化后文件的10倍大。Source Map V2将之减少了50%，V3又在V2的基础上减少了50%。所以现在133k的文件对应的Source Map文件巨细大概在300k左右。&lt;br/&gt;&lt;br/&gt;&lt;span&gt;##### 5.2 关于mappings属性&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;为了避免干扰，将案例改成如下不报错的情况：&lt;br/&gt;&lt;br/&gt;```js&lt;br/&gt;var a = 1;&lt;br/&gt;console.log(a);&lt;br/&gt;`&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打包编译的后 &lt;code&gt;bundle.js&lt;/code&gt; 文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/******/&lt;/span&gt;&lt;br/&gt;(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;span&gt;// webpackBootstrap&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; __webpack_exports__ = {};&lt;br/&gt;    &lt;span&gt;/*!**********************!*\&lt;br/&gt;      !*** ./src/index.js ***!&lt;br/&gt;      \**********************/&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; a = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(a);&lt;br/&gt;    &lt;span&gt;/******/&lt;/span&gt;&lt;br/&gt;})();&lt;br/&gt;&lt;span&gt;//# sourceMappingURL=bundle.js.map&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打包编译后的 &lt;code&gt;bundle.js.map&lt;/code&gt; 文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;{&lt;br/&gt;    &lt;span&gt;&quot;version&quot;&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;sources&quot;&lt;/span&gt;: [&lt;br/&gt;        &lt;span&gt;&quot;webpack://learn-source-map/./src/index.js&quot;&lt;/span&gt;&lt;br/&gt;    ],&lt;br/&gt;    &lt;span&gt;&quot;names&quot;&lt;/span&gt;: [],&lt;br/&gt;    &lt;span&gt;&quot;mappings&quot;&lt;/span&gt;: &lt;span&gt;&quot;AAAA;AACA,c&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;file&quot;&lt;/span&gt;: &lt;span&gt;&quot;bundle.js&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;sourcesContent&quot;&lt;/span&gt;: [&lt;br/&gt;        &lt;span&gt;&quot;var a = 1;\r\nconsole.log(a);&quot;&lt;/span&gt;&lt;br/&gt;    ],&lt;br/&gt;    &lt;span&gt;&quot;sourceRoot&quot;&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到 &lt;code&gt;mappings&lt;/code&gt; 属性的值是：&lt;code&gt;AAAA; AACA, c&lt;/code&gt; ，要想说清楚这个东西，需要先解释一下它的组成结构。这是一个字符串，它分成三层：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一层是&lt;strong&gt;行对应&lt;/strong&gt;，以分号（; ）表示，每个分号对应转换后源码的一行。所以，第一个分号前的内容，就对应源码的第一行，以此类推。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二层是&lt;strong&gt;位置对应&lt;/strong&gt;，以逗号（, ）表示，每个逗号对应转换后源码的一个位置。所以，第一个逗号前的内容，就对应该行源码的第一个位置，以此类推。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三层是&lt;strong&gt;位置转换&lt;/strong&gt;，以&lt;span&gt;VLQ 编码&lt;/span&gt;&lt;sup&gt;[16]&lt;/sup&gt;表示，代表该位置对应的转换前的源码位置。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在回到源代码，就可以分析出：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;因为源代码中有两行，所以有一个分号，分号前后表示了第一行和第二行。即&lt;code&gt;mappings&lt;/code&gt;中的&lt;code&gt;AAAA&lt;/code&gt;和&lt;code&gt;AACA,c&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分号后面表示第二行，也就是代码&lt;code&gt;console.log(a);&lt;/code&gt;可以拆分出两个位置，分别是&lt;code&gt;console&lt;/code&gt;和&lt;code&gt;log(a)&lt;/code&gt;，所以存在一个逗号。即&lt;code&gt;AACA,c&lt;/code&gt;中的&lt;code&gt;AACA&lt;/code&gt;和&lt;code&gt;c&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结，就是&lt;strong&gt;转换后的源码分成两行，第一行有一个位置，第二行有两个位置&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于这个 &lt;code&gt;AAAA&lt;/code&gt; ， &lt;code&gt;AAcA&lt;/code&gt; 等字母是怎么来的，可以参考阮一峰老师的&lt;span&gt;JavaScript Source Map 详解&lt;/span&gt;&lt;sup&gt;[17]&lt;/sup&gt;有作详细的介绍。笔者自己的理解是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;AAAA&lt;/code&gt; 和 &lt;code&gt;AAcA&lt;/code&gt; 以及 &lt;code&gt;c&lt;/code&gt; 都是代表了位置，正常来说，每个位置最多由 5 个字母组成，5 个字母的含义分别是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一位，表示这个位置在（转换后的代码的）的第几列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二位，表示这个位置属于 sources 属性中的哪一个文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三位，表示这个位置属于转换前代码的第几行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第四位，表示这个位置属于转换前代码的第几列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第五位，表示这个位置属于 names 属性中的哪一个变量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这里转换后最多只有 4 个字母，是因为没有 &lt;code&gt;names&lt;/code&gt; 属性。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一个位置都可以用&lt;span&gt;VLQ 编码&lt;/span&gt;&lt;sup&gt;[18]&lt;/sup&gt;转换，形成一种映射关系。可以在&lt;span&gt;这个网站&lt;/span&gt;&lt;sup&gt;[19]&lt;/sup&gt;自己转换测试，将 &lt;code&gt;AAAA; AACA, c&lt;/code&gt; 转换后的结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5297891842346472&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYGicuRRs4f9ibu0h8tw2O1zLVyE365hLX1JZu7uvOk4Sr7Tf4UpicmLNqw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1091&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以得到两组数据：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;[&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;], [&lt;span&gt;14&lt;/span&gt;]&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数字都是从 &lt;code&gt;0&lt;/code&gt; 开始的，拿位置 &lt;code&gt;AAAA&lt;/code&gt; 举例，转换后得到 &lt;code&gt;[0, 0, 0, 0]&lt;/code&gt; ，所以代表的含义分别是；&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;压缩代码的第一列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第一个源代码文件，即&lt;code&gt;index.js&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;源代码的第一行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;源代码第一列&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上解析，我们就能知道源代码中 &lt;code&gt;var a = 1;&lt;/code&gt; 在打包后文件中，即 &lt;code&gt;bundle.js&lt;/code&gt; 的具体位置了。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;六、Webpack 中的 Source Map&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;文介绍了 &lt;code&gt;Source Map&lt;/code&gt; 的作用，原理等。现在说一下打包工具 &lt;code&gt;WebPack&lt;/code&gt; 中对 &lt;code&gt;Source Map&lt;/code&gt; 的应用，毕竟我们在开发中，都离不开它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文有说道，只需要在 &lt;code&gt;webpack.config.js&lt;/code&gt; 文件中配置 &lt;code&gt;devtool&lt;/code&gt; 就可以使用 &lt;code&gt;Source Map&lt;/code&gt; ，这个 &lt;code&gt;devtool&lt;/code&gt; 具体的值有哪些，可以参考&lt;span&gt;webpack devtool&lt;/span&gt;&lt;sup&gt;[20]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;的介绍，官方罗列了 20 几种类型，我们当然不能全部都记住，可以记住几个关键的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5193687230989957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYicPVgW6ibyjB21ETc6R3RSxjaSjWpXjCB5fvOmtaBYSIiaS2P8j31HPsg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1394&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议以下 7 种可选方案：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;source-map&lt;/strong&gt;：外部。可以查看错误代码准确信息和源代码的错误位置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;inline-source-map&lt;/strong&gt;：内联。只生成一个内联 &lt;code&gt;Source Map&lt;/code&gt;，可以查看错误代码准确信息和源代码的错误位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;hidden-source-map&lt;/strong&gt;：外部。可以查看错误代码准确信息，但不能追踪源代码错误，只能提示到构建后代码的错误位置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;eval-source-map&lt;/strong&gt;：内联。每一个文件都生成对应的 &lt;code&gt;Source Map&lt;/code&gt;，都在 &lt;code&gt;eval&lt;/code&gt; 中，可以查看错误代码准确信息 和 源代码的错误位置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;nosources-source-map&lt;/strong&gt;：外部。可以查看错误代码错误原因，但不能查看错误代码准确信息，并且没有任何源代码信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;cheap-source-map&lt;/strong&gt;：外部。可以查看错误代码准确信息和源代码的错误位置，只能把错误精确到整行，忽略列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;cheap-module-source-map&lt;/strong&gt;：外部。可以错误代码准确信息和源代码的错误位置，&lt;code&gt;module&lt;/code&gt; 会加入 &lt;code&gt;loader&lt;/code&gt; 的 &lt;code&gt;Source Map&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内联和外部的区别：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;外部生成了文件（&lt;code&gt;.map&lt;/code&gt;），内联没有。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内联构建速度更快。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下通过具体的案例演示上面的 7 种类型：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，将案例改成报错状态，为了体现列的情况，将源代码修改成如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;source map!!!&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; a = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(a, b); &lt;span&gt;//这一行肯定会报错&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;6.1 source-map&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;devtool: &lt;span&gt;&#x27;source-map&#x27;&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译后，可以查看&lt;strong&gt;错误代码准确信息和源代码的错误位置&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7195121951219512&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYrCyuZy4O4T0npmNZeaVTehckRldPMAzIMPqzFsVicc2IjYeYNCnxOmw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;820&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成了 &lt;code&gt;.map&lt;/code&gt; 文件：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4198717948717949&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYic8CdvZ4Q4rgqwu9JqsJibyDia2Jx8lpeib920htdZ1TBrj1x6cYB8NXeQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;624&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;6.2 inline-source-map&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;devtool: &lt;span&gt;&#x27;inline-source-map&#x27;&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译后，可以查看&lt;strong&gt;错误代码准确信息和源代码的错误位置&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7195121951219512&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYrCyuZy4O4T0npmNZeaVTehckRldPMAzIMPqzFsVicc2IjYeYNCnxOmw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;820&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是没有生成 &lt;code&gt;.map文件&lt;/code&gt; ，而是以 &lt;code&gt;base64&lt;/code&gt; 的形式插入到 &lt;code&gt;sourceMappingURL&lt;/code&gt; 中：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34765875561257215&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYQAu2jS0EbrfjEbXd8DquHK0O6Fm2ZPNthXAfg7R1U2ibu3iczEWQlmWA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3118&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;6.3 hidden-source-map&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;devtool: &lt;span&gt;&#x27;hidden-source-map&#x27;&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译后，可以查看&lt;strong&gt;错误代码准确信息，但是无法查看源代码的位置&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7057387057387058&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYbD9H3A8jiaaqB84RSQcFEIdkBUEbYtT6McQMrUexiab986iaNAoXoudOg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;819&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成了 &lt;code&gt;.map&lt;/code&gt; 文件：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4198717948717949&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYic8CdvZ4Q4rgqwu9JqsJibyDia2Jx8lpeib920htdZ1TBrj1x6cYB8NXeQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;624&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;6.4 eval-source-map&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;devtool: &lt;span&gt;&#x27;eval-source-map&#x27;&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译后，可以查看&lt;strong&gt;错误代码准确信息和源代码的错误位置&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7234299516908212&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbY2OfnZLLBibB70CRKWpnScZ4Sw9ymbVeoCRwrazPL15PGStKUywEF7tg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是没有生成 &lt;code&gt;.map文件&lt;/code&gt; ，而是在 &lt;code&gt;eval函数&lt;/code&gt; 中，包括 &lt;code&gt;sourceMappingURL&lt;/code&gt; :&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33054123711340205&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYmicAMjtSkMSZWwfbLF9hPn6Tb6ykTciaKf4W1h92OA4nP01yPfOBBEHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3104&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31494547787042976&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYzwFU5ST0ScSv92AM38z3y4IcNa4ibPLmOxeQeUqnK9OpDBF7CK3q7vA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3118&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;6.5 nosources-source-map&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;devtool: &lt;span&gt;&#x27;nosources-source-map&#x27;&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译后，可以查看&lt;strong&gt;无法查看错误代码的准确位置和源代码的错误位置，只能提示错误原因&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7049576783555018&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYic5phT13hbdFvLsF0slZNk07MMTBDhkibu1icnDbkibWscN3hMNibRONCbw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;827&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成了 &lt;code&gt;.map&lt;/code&gt; 文件：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4198717948717949&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYic8CdvZ4Q4rgqwu9JqsJibyDia2Jx8lpeib920htdZ1TBrj1x6cYB8NXeQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;624&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;6.6 cheap-source-map&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;devtool: &lt;span&gt;&#x27;cheap-source-map&#x27;&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译后，可以查看&lt;strong&gt;错误代码准确信息和源代码的错误位置，但是忽略了具体的列（ &lt;code&gt;因为是b导致报错&lt;/code&gt; ）&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7195121951219512&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYrCyuZy4O4T0npmNZeaVTehckRldPMAzIMPqzFsVicc2IjYeYNCnxOmw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;820&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成了 &lt;code&gt;.map&lt;/code&gt; 文件：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4198717948717949&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYic8CdvZ4Q4rgqwu9JqsJibyDia2Jx8lpeib920htdZ1TBrj1x6cYB8NXeQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;624&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;6.7 cheap-module-source-map&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为需要 &lt;code&gt;module&lt;/code&gt; ，所以案例中增加 &lt;code&gt;loader&lt;/code&gt; ：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;module&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;rules&lt;/span&gt;: [{&lt;br/&gt;        &lt;span&gt;test&lt;/span&gt;: &lt;span&gt;/\.css$/&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;use&lt;/span&gt;: [&lt;br/&gt;            &lt;span&gt;// style-loader：创建style标签，将js中的样式资源插入进去，添加到head中生效&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&#x27;style-loader&#x27;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;// css-loader：将css文件变成commonjs模块加载到js中，里面内容是样式字符串&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&#x27;css-loader&#x27;&lt;/span&gt;&lt;br/&gt;        ]&lt;br/&gt;    }]&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;src&lt;/code&gt; 目录下新建 &lt;code&gt;index.css&lt;/code&gt; 文件，添加样式代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;body&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;margin&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;padding&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;100%&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;background-color&lt;/span&gt;: pink;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在 &lt;code&gt;src/index.js&lt;/code&gt; 中引入 &lt;code&gt;index.css&lt;/code&gt; ：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//引入index.css&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&#x27;./index.css&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;source map!!!&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; a = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(a, b); &lt;span&gt;//这一行肯定会报错&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改 &lt;code&gt;devtool&lt;/code&gt; ：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;devtool: &lt;span&gt;&#x27;cheap-module-source-map&#x27;&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打包后，打开浏览器，样式生效，说明 &lt;code&gt;loader&lt;/code&gt; 引入成功。可以查看&lt;strong&gt;错误代码准确信息和源代码的错误位置，但是忽略了具体的列（ &lt;code&gt;因为是b导致报错&lt;/code&gt; ）&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47491039426523296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYrmOxNBGSdu2PEGxibLnrEX9N7uJCWh9dopPVuicrxYFopODcGp7vqTPg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1674&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成了 &lt;code&gt;.map&lt;/code&gt; 文件，同时，将 &lt;code&gt;loader&lt;/code&gt; 的信息也一起打包进来:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3057442865966646&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYFktzuibw0DjtJkBjJXCorMWUMUxHiagaZuNgn5ibKib4AhGAaM0cv6je0A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3238&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3274282223579719&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSI1GlrH5gUjJlibDr4Z3qbYKSYX2dKeShGZZuv7HSjWXekgZRulyoDT0Zw6fhJ6kITnn5ECXw3vmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3274&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;6.8 总结&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）&lt;strong&gt;开发环境&lt;/strong&gt;：需要考虑速度快，调试更友好&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;速度快( &lt;code&gt;eval&lt;/code&gt; &amp;gt; &lt;code&gt;inline&lt;/code&gt; &amp;gt; &lt;code&gt;cheap&lt;/code&gt; &amp;gt;... )&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;eval-cheap-souce-map&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;eval-source-map&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;调试更友好&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;souce-map&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;cheap-module-souce-map&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;cheap-souce-map&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最终得出最好的两种方案 --&amp;gt; eval-source-map（完整度高，内联速度快） / eval-cheap-module-souce-map（错误提示忽略列但是包含其他信息，内联速度快）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）&lt;strong&gt;生产环境&lt;/strong&gt;：需要考虑源代码要不要隐藏，调试要不要更友好&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;内联会让代码体积变大，所以在生产环境不用内联&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;隐藏源代码&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;nosources-source-map&lt;/code&gt; 全部隐藏（打包后的代码与源代码）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;hidden-source-map&lt;/code&gt; 只隐藏源代码，会提示构建后代码错误信息&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最终得出最好的两种方案 --&amp;gt; source-map（最完整） / cheap-module-souce-map（错误提示一整行忽略列）&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;七、总结&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Source Map&lt;/code&gt;&lt;span&gt; 是我们日常开发过程中必不可少的，它可以帮助我们调试，定位错误。&lt;/span&gt;&lt;span&gt;尽管它涉及非常多的知识点，例如：&lt;/span&gt;&lt;span&gt;VLQ&lt;/span&gt;&lt;sup&gt;[21]&lt;/sup&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;base64&lt;/span&gt;&lt;sup&gt;[22]&lt;/sup&gt;&lt;span&gt;等，但是我们核心关注的是它的工作原理，以及在打包工具中，如 &lt;/span&gt;&lt;code&gt;webpack&lt;/code&gt;&lt;span&gt; 等对 &lt;/span&gt;&lt;code&gt;Source Map&lt;/code&gt;&lt;span&gt; 的应用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Source Map&lt;/code&gt; 非常强大，不仅在应用于日常开发，还可以做更多的事情，如 &lt;code&gt;性能异常监控平台&lt;/code&gt; 。比如&lt;span&gt;FunDebug&lt;/span&gt;&lt;sup&gt;[23]&lt;/sup&gt;这个网站就是通过 &lt;code&gt;Source Map&lt;/code&gt; 还原生产环境中的压缩代码，提供完整的堆栈信息，准确定位出错误源码，帮助用户快速修复 &lt;code&gt;Bug&lt;/code&gt; ，像这样的案例还有许多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之，学习 &lt;code&gt;Source Map&lt;/code&gt; 是非常有必要的。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;八、参考&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Introduction to JavaScript Source Maps&lt;/span&gt;&lt;sup&gt;[24]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;MDN&lt;/span&gt;&lt;sup&gt;[25]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;JavaScript Source Map 详解&lt;/span&gt;&lt;sup&gt;[26]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;VLQ&lt;/span&gt;&lt;sup&gt;[27]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;base64&lt;/span&gt;&lt;sup&gt;[28]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;base64vlq&lt;/span&gt;&lt;sup&gt;[29]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;FunDebug&lt;/span&gt;&lt;sup&gt;[30]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;绝了，没想到一个 source map 居然涉及到那么多知识盲区&lt;/span&gt;&lt;sup&gt;[31]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;谈谈我是如何获得知乎的前端源码的&lt;/span&gt;&lt;sup&gt;[32]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;p&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>