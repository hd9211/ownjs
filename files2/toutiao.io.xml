<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>a2826db69ab02873088afa621628d87f</guid>
<title>[推荐] Redis 进阶笔记</title>
<link>https://toutiao.io/k/ti0gb8i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;

                

                
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>13bba29722b85c8599defa2b56f153e7</guid>
<title>[推荐] 2.7w 字！Java 基础面试题/知识点总结（2021 最新版）</title>
<link>https://toutiao.io/k/0iue4f4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇《Java 基础知识总结》是 JavaGuide 上阅读量最高的一篇文章，由于我对其进行了重构完善并且修复了很多小问题，所以，在公号再同步一下！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章内容比较多，公号不太适合长文阅读。小伙伴们可以点击阅读原文进行在线阅读，体验会更好一点（有侧边目录）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整篇文章的目录如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;3.0180722891566263&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmccvaBDmUlibcWZlrZ4AMB3dYS6nibeSTgcDPY2nuDx1wljqZf32qJJfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基础概念与常识&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Java 语言有哪些特点?&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;简单易学；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面向对象（封装，继承，多态）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;平台无关性（ Java 虚拟机实现平台无关性）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可靠性；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安全性；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;编译与解释并存；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;修正（参见：issue#544）：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用&lt;code&gt;std::thread&lt;/code&gt;和&lt;code&gt;std::async&lt;/code&gt;来创建线程。参考链接：http://www.cplusplus.com/reference/thread/thread/?kw=thread&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;JVM vs JDK vs JRE&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;JVM&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;什么是字节码?采用字节码的好处是什么?&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在 Java 中，JVM 可以理解的代码就叫做&lt;code&gt;字节码&lt;/code&gt;（即扩展名为 &lt;code&gt;.class&lt;/code&gt; 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Java 程序从源代码到运行一般有下面 3 步：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2242503259452412&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmibxCRvs5tpciaTMwWibJwF9MBosS8cf62uHJk7wCncyYkv8xkBdhl4nIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;767&quot;/&gt;&lt;figcaption&gt;Java程序运行过程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要格外注意的是 .class-&amp;gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;JDK 和 JRE&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么说 Java 语言“编译与解释并存”？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读，
有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（&lt;code&gt;\*.class&lt;/code&gt; 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Oracle JDK 和 OpenJDK 的对比&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？&lt;/p&gt;&lt;p&gt;答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见：https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence 。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Oracle JDK 使用 BCL/OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🌈 拓展一下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;BCL 协议（Oracle Binary Code License Agreement）： 可以使用JDK（支持商用），但是不能进行修改。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;OTN 协议（Oracle Technology Network License Agreement）： 11 及之后新发布的JDK用的都是这个协议，可以自己私下用，但是商用需要付费。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5356466876971608&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmWG8SQZ1Q0pNLKQrpGLRarZicz7ZIyr1DJee1ZXdWyfxvfT1AibzXwic2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1585&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相关阅读👍：《Differences Between Oracle JDK and OpenJDK》&lt;/p&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Java 和 C++的区别?&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来！&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;都是面向对象的语言，都支持封装、继承和多态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Java 不提供指针来直接访问内存，程序内存更加安全&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;......&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;import java 和 javax 有什么区别？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，实际上 java 和 javax 没有区别。这都是一个名字。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基本语法&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;字符型常量和字符串常量的区别?&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;形式&lt;/strong&gt; : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;含义&lt;/strong&gt; : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;占内存大小&lt;/strong&gt; ：字符常量只占 2 个字节; 字符串常量占若干个字节 (&lt;strong&gt;注意：char 在 Java 中占两个字节&lt;/strong&gt;),&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;字符封装类 &lt;code&gt;Character&lt;/code&gt; 有一个成员常量 &lt;code&gt;Character.SIZE&lt;/code&gt; 值为 16,单位是&lt;code&gt;bits&lt;/code&gt;,该值除以 8(&lt;code&gt;1byte=8bits&lt;/code&gt;)后就可以得到 2 个字节&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;java 编程思想第四版：2.2.2 节&lt;img data-ratio=&quot;0.45161290322580644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0Pm33L3yUDLVRQdkLia00BU1VLrYaP7DzVcrrUBoHroKCDng9wlrm3CO7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;868&quot;/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;注释&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 中的注释有三种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;单行注释&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;多行注释&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;文档注释。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们编写代码的时候，如果代码量比较少，我们自己或者团队其他成员还可以很轻易地看懂代码，但是当项目结构一旦复杂起来，我们就需要用到注释了。注释并不会执行(编译器在编译代码之前会把代码中的所有注释抹掉,字节码中不保留注释)，是我们程序员写给自己看的，注释是你的代码说明书，能够帮助看代码的人快速地理清代码之间的逻辑关系。因此，在写程序的时候随手加上注释是一个非常好的习惯。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《Clean Code》这本书明确指出：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;举个例子：&lt;/p&gt;&lt;p&gt;去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// check to see if the employee is eligible for full benefits&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; ((employee.flags &amp;amp; HOURLY_FLAG) &amp;amp;&amp;amp; (employee.age &amp;gt; &lt;span&gt;65&lt;/span&gt;))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;应替换为&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (employee.isEligibleForFullBenefits())&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;标识符和关键字的区别是什么？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符，简单来说，标识符就是一个名字。但是有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这种特殊的标识符就是关键字。因此，关键字是被赋予特殊含义的标识符。比如，在我们的日常生活中 ，“警察局”这个名字已经被赋予了特殊的含义，所以如果你开一家店，店的名字不能叫“警察局”，“警察局”就是我们日常生活中的关键字。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Java 中有哪些常见的关键字？&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;访问控制&lt;/th&gt;&lt;th&gt;private&lt;/th&gt;&lt;th&gt;protected&lt;/th&gt;&lt;th&gt;public&lt;/th&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;类，方法和变量修饰符&lt;/td&gt;&lt;td&gt;abstract&lt;/td&gt;&lt;td&gt;class&lt;/td&gt;&lt;td&gt;extends&lt;/td&gt;&lt;td&gt;final&lt;/td&gt;&lt;td&gt;implements&lt;/td&gt;&lt;td&gt;interface&lt;/td&gt;&lt;td&gt;native&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;new&lt;/td&gt;&lt;td&gt;static&lt;/td&gt;&lt;td&gt;strictfp&lt;/td&gt;&lt;td&gt;synchronized&lt;/td&gt;&lt;td&gt;transient&lt;/td&gt;&lt;td&gt;volatile&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;程序控制&lt;/td&gt;&lt;td&gt;break&lt;/td&gt;&lt;td&gt;continue&lt;/td&gt;&lt;td&gt;return&lt;/td&gt;&lt;td&gt;do&lt;/td&gt;&lt;td&gt;while&lt;/td&gt;&lt;td&gt;if&lt;/td&gt;&lt;td&gt;else&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;for&lt;/td&gt;&lt;td&gt;instanceof&lt;/td&gt;&lt;td&gt;switch&lt;/td&gt;&lt;td&gt;case&lt;/td&gt;&lt;td&gt;default&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;错误处理&lt;/td&gt;&lt;td&gt;try&lt;/td&gt;&lt;td&gt;catch&lt;/td&gt;&lt;td&gt;throw&lt;/td&gt;&lt;td&gt;throws&lt;/td&gt;&lt;td&gt;finally&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;包相关&lt;/td&gt;&lt;td&gt;import&lt;/td&gt;&lt;td&gt;package&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;基本类型&lt;/td&gt;&lt;td&gt;boolean&lt;/td&gt;&lt;td&gt;byte&lt;/td&gt;&lt;td&gt;char&lt;/td&gt;&lt;td&gt;double&lt;/td&gt;&lt;td&gt;float&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;long&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;short&lt;/td&gt;&lt;td&gt;null&lt;/td&gt;&lt;td&gt;true&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;变量引用&lt;/td&gt;&lt;td&gt;super&lt;/td&gt;&lt;td&gt;this&lt;/td&gt;&lt;td&gt;void&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;保留字&lt;/td&gt;&lt;td&gt;goto&lt;/td&gt;&lt;td&gt;const&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;自增自减运算符&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（--）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;++和--运算符可以放在变量之前，也可以放在变量之后，当运算符放在变量之前时(前缀)，先自增/减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增/减。例如，当 &lt;code&gt;b = ++a&lt;/code&gt; 时，先自增（自己增加 1），再赋值（赋值给 b）；当 &lt;code&gt;b = a++&lt;/code&gt; 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“符号在前就先加/减，符号在后就后加/减”。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;continue、break、和 return 的区别是什么？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;continue ：指跳出当前的这一次循环，继续下一次循环。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;break ：指跳出整个循环体，继续执行循环下面的语句。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;return 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;return;&lt;/code&gt; ：直接使用 return 结束方法执行，用于没有返回值函数的方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;return value;&lt;/code&gt; ：return 一个特定值，用于有返回值函数的方法&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;list.add(&lt;span&gt;12&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//这里直接添加会报错&lt;/span&gt;&lt;br/&gt;list.add(&lt;span&gt;&quot;a&quot;&lt;/span&gt;);&lt;br/&gt;Class&amp;lt;? extends List&amp;gt; clazz = list.getClass();&lt;br/&gt;Method add = clazz.getDeclaredMethod(&lt;span&gt;&quot;add&quot;&lt;/span&gt;, Object&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//但是通过反射添加，是可以的&lt;/span&gt;&lt;br/&gt;add.invoke(list, &lt;span&gt;&quot;kl&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;System.out.println(list);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1.泛型类&lt;/strong&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//在实例化泛型类时，必须指定T的具体类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Generic&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; T key;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Generic&lt;/span&gt;&lt;span&gt;(T key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.key = key;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;getKey&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; key;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何实例化泛型类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Generic&amp;lt;Integer&amp;gt; genericInteger = &lt;span&gt;new&lt;/span&gt; Generic&amp;lt;Integer&amp;gt;(&lt;span&gt;123456&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.泛型接口&lt;/strong&gt; ：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Generator&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现泛型接口，不指定类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GeneratorImpl&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Generator&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现泛型接口，指定类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GeneratorImpl&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Generator&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;hello&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3.泛型方法&lt;/strong&gt; ：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt; E &amp;gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;printArray&lt;/span&gt;&lt;span&gt;( E[] inputArray )&lt;/span&gt;&lt;br/&gt;   &lt;/span&gt;{&lt;br/&gt;         &lt;span&gt;for&lt;/span&gt; ( E element : inputArray ){&lt;br/&gt;            System.out.printf( &lt;span&gt;&quot;%s &quot;&lt;/span&gt;, element );&lt;br/&gt;         }&lt;br/&gt;         System.out.println();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 创建不同类型数组：Integer, Double 和 Character&lt;/span&gt;&lt;br/&gt;Integer[] intArray = { &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt; };&lt;br/&gt;String[] stringArray = { &lt;span&gt;&quot;Hello&quot;&lt;/span&gt;, &lt;span&gt;&quot;World&quot;&lt;/span&gt; };&lt;br/&gt;printArray( intArray  );&lt;br/&gt;printArray( stringArray  );&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;常用的通配符为：T，E，K，V，？&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;？表示不确定的 java 类型&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;T (type) 表示具体的一个 java 类型&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;K V (key value) 分别代表 java 键值中的 Key Value&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;E (element) 代表 Element&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;==和 equals 的区别&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于基本数据类型来说，==比较的是值。对于引用数据类型来说，==比较的是对象的内存地址。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;code&gt;equals()&lt;/code&gt;&lt;/strong&gt; 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。&lt;code&gt;equals()&lt;/code&gt;方法存在于&lt;code&gt;Object&lt;/code&gt;类中，而&lt;code&gt;Object&lt;/code&gt;类是所有类的直接或间接父类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Object&lt;/code&gt; 类 &lt;code&gt;equals()&lt;/code&gt; 方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;equals&lt;/span&gt;&lt;span&gt;(Object obj)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt; == obj);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;equals()&lt;/code&gt; 方法存在两种使用情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;类没有覆盖 &lt;code&gt;equals()&lt;/code&gt;方法&lt;/strong&gt; ：通过&lt;code&gt;equals()&lt;/code&gt;比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 &lt;code&gt;Object&lt;/code&gt;类&lt;code&gt;equals()&lt;/code&gt;方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;类覆盖了 &lt;code&gt;equals()&lt;/code&gt;方法&lt;/strong&gt; ：一般我们都覆盖 &lt;code&gt;equals()&lt;/code&gt;方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;举个例子：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String a = &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;ab&quot;&lt;/span&gt;); &lt;span&gt;// a 为一个引用&lt;/span&gt;&lt;br/&gt;        String b = &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;ab&quot;&lt;/span&gt;); &lt;span&gt;// b为另一个引用,对象的内容一样&lt;/span&gt;&lt;br/&gt;        String aa = &lt;span&gt;&quot;ab&quot;&lt;/span&gt;; &lt;span&gt;// 放在常量池中&lt;/span&gt;&lt;br/&gt;        String bb = &lt;span&gt;&quot;ab&quot;&lt;/span&gt;; &lt;span&gt;// 从常量池中查找&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (aa == bb) &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;aa==bb&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (a == b) &lt;span&gt;// false，非同一对象&lt;/span&gt;&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;a==b&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (a.equals(b)) &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;aEQb&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;42&lt;/span&gt; == &lt;span&gt;42.0&lt;/span&gt;) { &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;true&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;String&lt;/code&gt; 中的 &lt;code&gt;equals&lt;/code&gt; 方法是被重写过的，因为 &lt;code&gt;Object&lt;/code&gt; 的 &lt;code&gt;equals&lt;/code&gt; 方法是比较的对象的内存地址，而 &lt;code&gt;String&lt;/code&gt; 的 &lt;code&gt;equals&lt;/code&gt; 方法比较的是对象的值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当创建 &lt;code&gt;String&lt;/code&gt; 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 &lt;code&gt;String&lt;/code&gt; 对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String&lt;/code&gt;类&lt;code&gt;equals()&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;equals&lt;/span&gt;&lt;span&gt;(Object anObject)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt; == anObject) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (anObject &lt;span&gt;instanceof&lt;/span&gt; String) {&lt;br/&gt;        String anotherString = (String)anObject;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; n = value.length;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (n == anotherString.value.length) {&lt;br/&gt;            &lt;span&gt;char&lt;/span&gt; v1[] = value;&lt;br/&gt;            &lt;span&gt;char&lt;/span&gt; v2[] = anotherString.value;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (n-- != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (v1[i] != v2[i])&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                i++;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;hashCode()与 equals()&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官可能会问你：“你重写过 &lt;code&gt;hashcode&lt;/code&gt; 和 &lt;code&gt;equals&lt;/code&gt;么，为什么重写 &lt;code&gt;equals&lt;/code&gt; 时必须重写 &lt;code&gt;hashCode&lt;/code&gt; 方法？”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1)hashCode()介绍:&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;hashCode()&lt;/code&gt; 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。&lt;code&gt;hashCode()&lt;/code&gt;定义在 JDK 的 &lt;code&gt;Object&lt;/code&gt; 类中，这就意味着 Java 中的任何类都包含有 &lt;code&gt;hashCode()&lt;/code&gt; 函数。另外需要注意的是：&lt;code&gt;Object&lt;/code&gt; 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;hashCode&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2)为什么要有 hashCode？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以“&lt;code&gt;HashSet&lt;/code&gt; 如何检查重复”为例子来说明为什么要有 hashCode？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你把对象加入 &lt;code&gt;HashSet&lt;/code&gt; 时，&lt;code&gt;HashSet&lt;/code&gt; 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，&lt;code&gt;HashSet&lt;/code&gt; 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 &lt;code&gt;equals()&lt;/code&gt; 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，&lt;code&gt;HashSet&lt;/code&gt; 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head First Java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3)为什么重写 &lt;code&gt;equals&lt;/code&gt; 时必须重写 &lt;code&gt;hashCode&lt;/code&gt; 方法？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。&lt;strong&gt;因此，equals 方法被覆盖过，则 &lt;code&gt;hashCode&lt;/code&gt; 方法也必须被覆盖。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;hashCode()&lt;/code&gt;的默认行为是对堆上的对象产生独特值。如果没有重写 &lt;code&gt;hashCode()&lt;/code&gt;，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4)为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 &lt;code&gt;hashCode()&lt;/code&gt; 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 &lt;code&gt;hashCode&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们刚刚也提到了 &lt;code&gt;HashSet&lt;/code&gt;,如果 &lt;code&gt;HashSet&lt;/code&gt; 在对比的时候，同样的 hashcode 有多个对象，它会使用 &lt;code&gt;equals()&lt;/code&gt; 来判断是否真的相同。也就是说 &lt;code&gt;hashcode&lt;/code&gt; 只是用来缩小查找成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多关于 &lt;code&gt;hashcode()&lt;/code&gt; 和 &lt;code&gt;equals()&lt;/code&gt; 的内容可以查看：Java hashCode() 和 equals()的若干问题解答&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基本数据类型&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 中有 8 种基本数据类型，分别为：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;6 种数字类型 ：&lt;code&gt;byte&lt;/code&gt;、&lt;code&gt;short&lt;/code&gt;、&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;long&lt;/code&gt;、&lt;code&gt;float&lt;/code&gt;、&lt;code&gt;double&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;1 种字符类型：&lt;code&gt;char&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;1 种布尔型：&lt;code&gt;boolean&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这 8 种基本数据类型的默认值以及所占空间的大小如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;基本类型&lt;/th&gt;&lt;th&gt;位数&lt;/th&gt;&lt;th&gt;字节&lt;/th&gt;&lt;th&gt;默认值&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;int&lt;/code&gt;&lt;/td&gt;&lt;td&gt;32&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;short&lt;/code&gt;&lt;/td&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;long&lt;/code&gt;&lt;/td&gt;&lt;td&gt;64&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;0L&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;byte&lt;/code&gt;&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;char&lt;/code&gt;&lt;/td&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;&#x27;u0000&#x27;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;float&lt;/code&gt;&lt;/td&gt;&lt;td&gt;32&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;0f&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;double&lt;/code&gt;&lt;/td&gt;&lt;td&gt;64&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;0d&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，对于 &lt;code&gt;boolean&lt;/code&gt;，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Java 里使用 &lt;code&gt;long&lt;/code&gt; 类型的数据一定要在数值后面加上 &lt;strong&gt;L&lt;/strong&gt;，否则将作为整型解析。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;char a = &#x27;h&#x27;&lt;/code&gt;char :单引号，&lt;code&gt;String a = &quot;hello&quot;&lt;/code&gt; :双引号。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这八种基本类型都有对应的包装类分别为：&lt;code&gt;Byte&lt;/code&gt;、&lt;code&gt;Short&lt;/code&gt;、&lt;code&gt;Integer&lt;/code&gt;、&lt;code&gt;Long&lt;/code&gt;、&lt;code&gt;Float&lt;/code&gt;、&lt;code&gt;Double&lt;/code&gt;、&lt;code&gt;Character&lt;/code&gt;、&lt;code&gt;Boolean&lt;/code&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;包装类型不赋值就是 &lt;code&gt;Null&lt;/code&gt; ，而基本类型有默认值且不是 &lt;code&gt;Null&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，这个问题建议还可以先从 JVM 层面来分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本数据类型直接存放在 Java 虚拟机栈中的局部变量表中，而包装类型属于对象类型，我们知道对象实例都存在于堆中。相比于对象类型， 基本数据类型占用的空间非常小。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;《深入理解 Java 虚拟机》 ：局部变量表主要存放了编译期可知的基本数据类型**（boolean、byte、char、short、int、float、long、double）**、&lt;strong&gt;对象引用&lt;/strong&gt;（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;自动装箱与拆箱&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;装箱&lt;/strong&gt;：将基本类型用它们对应的引用类型包装起来；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;拆箱&lt;/strong&gt;：将包装类型转换为基本数据类型；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer i = &lt;span&gt;10&lt;/span&gt;;  &lt;span&gt;//装箱&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; n = i;   &lt;span&gt;//拆箱&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这两行代码对应的字节码为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   L1&lt;br/&gt;&lt;br/&gt;    LINENUMBER &lt;span&gt;8&lt;/span&gt; L1&lt;br/&gt;&lt;br/&gt;    ALOAD &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    BIPUSH &lt;span&gt;10&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;&lt;br/&gt;&lt;br/&gt;    PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;&lt;br/&gt;&lt;br/&gt;   L2&lt;br/&gt;&lt;br/&gt;    LINENUMBER &lt;span&gt;9&lt;/span&gt; L2&lt;br/&gt;&lt;br/&gt;    ALOAD &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    ALOAD &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    GETFIELD AutoBoxTest.i : Ljava/lang/Integer;&lt;br/&gt;&lt;br/&gt;    INVOKEVIRTUAL java/lang/Integer.intValue ()I&lt;br/&gt;&lt;br/&gt;    PUTFIELD AutoBoxTest.n : I&lt;br/&gt;&lt;br/&gt;    RETURN&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从字节码中，我们发现装箱其实就是调用了 包装类的&lt;code&gt;valueOf()&lt;/code&gt;方法，拆箱其实就是调用了 &lt;code&gt;xxxValue()&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Integer i = 10&lt;/code&gt; 等价于 &lt;code&gt;Integer i = Integer.valueOf(10)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;int n = i&lt;/code&gt; 等价于 &lt;code&gt;int n = i.intValue()&lt;/code&gt;;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8 种基本类型的包装类和常量池&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 基本类型的包装类的大部分都实现了常量池技术。&lt;code&gt;Byte&lt;/code&gt;,&lt;code&gt;Short&lt;/code&gt;,&lt;code&gt;Integer&lt;/code&gt;,&lt;code&gt;Long&lt;/code&gt; 这 4 种包装类默认创建了数值 &lt;strong&gt;[-128，127]&lt;/strong&gt; 的相应类型的缓存数据，&lt;code&gt;Character&lt;/code&gt; 创建了数值在[0,127]范围的缓存数据，&lt;code&gt;Boolean&lt;/code&gt; 直接返回 &lt;code&gt;True&lt;/code&gt; Or &lt;code&gt;False&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Integer 缓存源码：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt;&lt;br/&gt;*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。&lt;br/&gt;&lt;br/&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Integer &lt;span&gt;valueOf&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; IntegerCache.cache[i + (-IntegerCache.low)];&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Integer(i);&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;IntegerCache&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; low = -&lt;span&gt;128&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; high;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Integer cache[];&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;code&gt;Character&lt;/code&gt; 缓存源码:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Character &lt;span&gt;valueOf&lt;/span&gt;&lt;span&gt;(&lt;span&gt;char&lt;/span&gt; c)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (c &amp;lt;= &lt;span&gt;127&lt;/span&gt;) { &lt;span&gt;// must cache&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; CharacterCache.cache[(&lt;span&gt;int&lt;/span&gt;)c];&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Character(c);&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CharacterCache&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;CharacterCache&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Character cache[] = &lt;span&gt;new&lt;/span&gt; Character[&lt;span&gt;127&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; cache.length; i++)&lt;br/&gt;&lt;br/&gt;            cache[i] = &lt;span&gt;new&lt;/span&gt; Character((&lt;span&gt;char&lt;/span&gt;)i);&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;code&gt;Boolean&lt;/code&gt; 缓存源码：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Boolean &lt;span&gt;valueOf&lt;/span&gt;&lt;span&gt;(&lt;span&gt;boolean&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (b ? TRUE : FALSE);&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两种浮点数类型的包装类 &lt;code&gt;Float&lt;/code&gt;,&lt;code&gt;Double&lt;/code&gt; 并没有实现常量池技术。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer i1 = &lt;span&gt;33&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;Integer i2 = &lt;span&gt;33&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;System.out.println(i1 == i2);&lt;span&gt;// 输出 true&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;Float i11 = &lt;span&gt;333f&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;Float i22 = &lt;span&gt;333f&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;System.out.println(i11 == i22);&lt;span&gt;// 输出 false&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;Double i3 = &lt;span&gt;1.2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;Double i4 = &lt;span&gt;1.2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;System.out.println(i3 == i4);&lt;span&gt;// 输出 false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下问题。下面的代码的输出结果是 &lt;code&gt;true&lt;/code&gt; 还是 &lt;code&gt;flase&lt;/code&gt; 呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer i1 = &lt;span&gt;40&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;Integer i2 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;40&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;System.out.println(i1==i2);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Integer i1=40&lt;/code&gt; 这一行代码会发生拆箱，也就是说这行代码等价于 &lt;code&gt;Integer i1=Integer.valueOf(40)&lt;/code&gt; 。因此，&lt;code&gt;i1&lt;/code&gt; 直接使用的是常量池中的对象。而&lt;code&gt;Integer i1 = new Integer(40)&lt;/code&gt; 会直接创建新的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，答案是 &lt;code&gt;false&lt;/code&gt; 。你答对了吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记住：&lt;strong&gt;所有整型包装类对象之间值的比较，全部使用 equals 方法比较&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2055944055944056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0Pm7Nm5N5J0MQ2DXPhoE5KjibiawxW4Pq2Uvic2wXtfdF2dQQ0sov5x6wwiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1430&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法（函数）&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是方法的返回值?&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法有哪几种类型？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1.无参数无返回值的方法&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 无参数无返回值的方法(如果方法没有返回值，不能不写，必须写void，表示没有返回值)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;无参数无返回值的方法&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.有参数无返回值的方法&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt;* 有参数无返回值的方法&lt;br/&gt;* 参数列表由零组到多组“参数类型+形参名”组合而成，多组参数之间以英文逗号（,）隔开，形参类型和形参名之间以英文空格隔开&lt;br/&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;f2&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a, String b, &lt;span&gt;int&lt;/span&gt; c)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    System.out.println(a + &lt;span&gt;&quot;--&amp;gt;&quot;&lt;/span&gt; + b + &lt;span&gt;&quot;--&amp;gt;&quot;&lt;/span&gt; + c);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3.有返回值无参数的方法&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 有返回值无参数的方法（返回值可以是任意的类型,在函数里面必须有return关键字返回对应的类型）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;f3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;有返回值无参数的方法&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4.有返回值有参数的方法&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 有返回值有参数的方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;f4&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; a * b;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;5.return 在无返回值方法的特殊使用&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// return在无返回值方法的特殊使用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;f5&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (a &amp;gt; &lt;span&gt;10&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;span&gt;//表示结束所在方法 （f5方法）的执行,下方的输出语句不会执行&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    System.out.println(a);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;在一个静态方法内调用一个非静态成员为什么是非法的?&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个需要结合 JVM 的相关知识，静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，然后通过类的实例对象去访问。在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。&lt;/p&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;静态方法和实例方法有何不同？&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在外部调用静态方法时，可以使用&quot;类名.方法名&quot;的方式，也可以使用&quot;对象名.方法名&quot;的方式。而实例方法只有后面这种方式。也就是说，&lt;strong&gt;调用静态方法可以无需创建对象。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么 Java 中只有值传递？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;按值调用(call by value)&lt;/strong&gt; 表示方法接收的是调用者提供的值，&lt;strong&gt;按引用调用（call by reference)&lt;/strong&gt; 表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。它用来描述各种程序设计语言（不只是 Java)中方法参数传递方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;下面通过 3 个例子来给大家说明&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;example 1&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; num1 = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; num2 = &lt;span&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    swap(num1, num2);&lt;br/&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;num1 = &quot;&lt;/span&gt; + num1);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;num2 = &quot;&lt;/span&gt; + num2);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;swap&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; temp = a;&lt;br/&gt;    a = b;&lt;br/&gt;    b = temp;&lt;br/&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;a = &quot;&lt;/span&gt; + a);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;b = &quot;&lt;/span&gt; + b);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a = 20&lt;br/&gt;b = 10&lt;br/&gt;num1 = 10&lt;br/&gt;num2 = 20&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解析：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8037190082644629&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmqnM3uJUBbVptT5fn3fr80YDp6yKfy386OzVgKx62XWIl6P8vxIzzKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;484&quot;/&gt;&lt;figcaption&gt;example 1&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;example 2&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt;[] arr = { &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt; };&lt;br/&gt;  System.out.println(arr[&lt;span&gt;0&lt;/span&gt;]);&lt;br/&gt;  change(arr);&lt;br/&gt;  System.out.println(arr[&lt;span&gt;0&lt;/span&gt;]);&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;change&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] array)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 将数组的第一个元素变为0&lt;/span&gt;&lt;br/&gt;  array[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1&lt;br/&gt;0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解析：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5437062937062938&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmlVsfdjOJ6iab6PZqg0BO5ZBWVc4bfSdLVZd6ejhyhaLZkAO21EKWNlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;572&quot;/&gt;&lt;figcaption&gt;example 2&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。因此，外部对引用对象的改变会反映到所对应的对象上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;很多程序设计语言（特别是，C++和 Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;example 3&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// TODO Auto-generated method stub&lt;/span&gt;&lt;br/&gt;  Student s1 = &lt;span&gt;new&lt;/span&gt; Student(&lt;span&gt;&quot;小张&quot;&lt;/span&gt;);&lt;br/&gt;  Student s2 = &lt;span&gt;new&lt;/span&gt; Student(&lt;span&gt;&quot;小李&quot;&lt;/span&gt;);&lt;br/&gt;  Test.swap(s1, s2);&lt;br/&gt;  System.out.println(&lt;span&gt;&quot;s1:&quot;&lt;/span&gt; + s1.getName());&lt;br/&gt;  System.out.println(&lt;span&gt;&quot;s2:&quot;&lt;/span&gt; + s2.getName());&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;swap&lt;/span&gt;&lt;span&gt;(Student x, Student y)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Student temp = x;&lt;br/&gt;  x = y;&lt;br/&gt;  y = temp;&lt;br/&gt;  System.out.println(&lt;span&gt;&quot;x:&quot;&lt;/span&gt; + x.getName());&lt;br/&gt;  System.out.println(&lt;span&gt;&quot;y:&quot;&lt;/span&gt; + y.getName());&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;x:小李&lt;br/&gt;y:小张&lt;br/&gt;s1:小张&lt;br/&gt;s2:小李&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解析：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;交换之前：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5125184094256259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmLHvjibV6Dy1lMUpds3EbjL9DQ0oXapL61ygGJ8ZZ4Y9M9At1bVia9gUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;679&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;交换之后：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5125184094256259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0Pm5NFHuHIqtbfZx0jYxic5vGxbVj2rmvs6ZW5WuRf4vHMaFUQzZiaaWQzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;679&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面两张图可以很清晰的看出：&lt;strong&gt;方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按
值传递的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面再总结一下 Java 中方法参数的使用情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个方法可以改变一个对象参数的状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个方法不能让对象参数引用一个新的对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《Java 核心技术卷 Ⅰ》基础知识第十版第四章 4.5 小节&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重载和重写的区别&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理&lt;/p&gt;&lt;p&gt;重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重载&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是《Java 核心技术》对重载这个概念的介绍：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6707105719237435&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmT56LEyPSGcHTpkmwILwvnsobm96zVElW6v6QKOUZ0KAByiaYAU9p1EQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2308&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重写&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果父类方法访问修饰符为 &lt;code&gt;private/final/static&lt;/code&gt; 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;构造方法无法被重写&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;暖心的 Guide 哥最后再来个图表总结一下！&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;区别点&lt;/th&gt;&lt;th&gt;重载方法&lt;/th&gt;&lt;th&gt;重写方法&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;发生范围&lt;/td&gt;&lt;td&gt;同一个类&lt;/td&gt;&lt;td&gt;子类&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;参数列表&lt;/td&gt;&lt;td&gt;必须修改&lt;/td&gt;&lt;td&gt;一定不能修改&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;返回类型&lt;/td&gt;&lt;td&gt;可修改&lt;/td&gt;&lt;td&gt;子类方法返回值类型应比父类方法返回值类型更小或相等&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;异常&lt;/td&gt;&lt;td&gt;可修改&lt;/td&gt;&lt;td&gt;子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;访问修饰符&lt;/td&gt;&lt;td&gt;可修改&lt;/td&gt;&lt;td&gt;一定不能做更严格的限制（可以降低限制）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;发生阶段&lt;/td&gt;&lt;td&gt;编译期&lt;/td&gt;&lt;td&gt;运行期&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;方法的重写要遵循“两同两小一大”&lt;/strong&gt;（以下内容摘录自《疯狂 Java 讲义》,issue#892 ）：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;“两同”即方法名相同、形参列表相同；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;⭐️ 关于 &lt;strong&gt;重写的返回值类&lt;/strong&gt;型 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Hero&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;name&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;超级英雄&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SuperMan&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Hero&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;name&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;超人&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Hero &lt;span&gt;hero&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Hero();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SuperSuperMan&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;SuperMan&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;name&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;超级超级英雄&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; SuperMan &lt;span&gt;hero&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; SuperMan();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;深拷贝 vs 浅拷贝&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;浅拷贝&lt;/strong&gt;：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;深拷贝&lt;/strong&gt;：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmeWI4yczObCLUDkRWlGmlk47UtbbQVCstSQmNs8ewnErAwuBc3jzQlg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;figcaption&gt;deep and shallow copy&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Java 面向对象&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;面向对象和面向过程的区别&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;面向过程&lt;/strong&gt; ：&lt;strong&gt;面向过程性能比面向对象高。&lt;/strong&gt; 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，&lt;strong&gt;面向过程没有面向对象易维护、易复用、易扩展。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;面向对象&lt;/strong&gt; ：&lt;strong&gt;面向对象易维护、易复用、易扩展。&lt;/strong&gt; 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，&lt;strong&gt;面向对象性能比面向过程低&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参见 issue : 面向过程 ：面向过程性能比面向对象高？？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。&lt;/p&gt;&lt;p&gt;而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;成员变量与局部变量的区别有哪些？&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 &lt;code&gt;public&lt;/code&gt;,&lt;code&gt;private&lt;/code&gt;,&lt;code&gt;static&lt;/code&gt; 等修饰符所修饰，而局部变量不能被访问控制修饰符及 &lt;code&gt;static&lt;/code&gt; 所修饰；但是，成员变量和局部变量都能被 &lt;code&gt;final&lt;/code&gt; 所修饰。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从变量在内存中的存储方式来看,如果成员变量是使用 &lt;code&gt;static&lt;/code&gt; 修饰的，那么这个成员变量是属于类的，如果没有使用 &lt;code&gt;static&lt;/code&gt; 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 &lt;code&gt;final&lt;/code&gt; 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;创建一个对象用什么运算符?对象实体与对象引用有何不同?&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;对象的相等与指向他们的引用相等,两者有什么不同?&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构造方法主要作用是完成对类对象的初始化工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;构造方法有哪些特点？是否可被 override?&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;名字与类名相同。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有返回值，但不能用 void 声明构造函数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生成类的对象时自动执行，无需调用。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;面向对象三大特征&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;封装&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Student&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id;&lt;span&gt;//id属性私有化&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;span&gt;//name属性私有化&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//获取id的方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getId&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; id;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//设置id的方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setId&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; id)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.id = id;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//获取name的方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; name;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//设置name的方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setName&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;继承&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;关于继承如下 3 点请记住：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，&lt;strong&gt;只是拥有&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子类可以拥有自己属性和方法，即子类可以对父类进行扩展。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子类可以用自己的方式实现父类的方法。（以后介绍）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;多态&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;多态的特点:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对象类型和引用类型之间具有继承（类）/实现（接口）的关系；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多态不能调用“只在子类存在但在父类不存在”的方法；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;可变性&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单的来说：&lt;code&gt;String&lt;/code&gt; 类中使用 final 关键字修饰字符数组来保存字符串，&lt;code&gt;private final char value[]&lt;/code&gt;，所以&lt;code&gt;String&lt;/code&gt; 对象是不可变的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;补充（来自issue 675）：在 Java 9 之后，String 、&lt;code&gt;StringBuilder&lt;/code&gt; 与 &lt;code&gt;StringBuffer&lt;/code&gt; 的实现改用 byte 数组存储字符串 &lt;code&gt;private final byte[] value&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 &lt;code&gt;StringBuilder&lt;/code&gt; 与 &lt;code&gt;StringBuffer&lt;/code&gt; 都继承自 &lt;code&gt;AbstractStringBuilder&lt;/code&gt; 类，在 &lt;code&gt;AbstractStringBuilder&lt;/code&gt; 中也是使用字符数组保存字符串&lt;code&gt;char[]value&lt;/code&gt; 但是没有用 &lt;code&gt;final&lt;/code&gt; 关键字修饰，所以这两种对象都是可变的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;StringBuilder&lt;/code&gt; 与 &lt;code&gt;StringBuffer&lt;/code&gt; 的构造方法都是调用父类构造方法也就是&lt;code&gt;AbstractStringBuilder&lt;/code&gt; 实现的，大家可以自行查阅源码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;AbstractStringBuilder.java&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractStringBuilder&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Appendable&lt;/span&gt;, &lt;span&gt;CharSequence&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * The value is used for character storage.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt;[] value;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * The count is the number of characters used.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; count;&lt;br/&gt;&lt;br/&gt;    AbstractStringBuilder(&lt;span&gt;int&lt;/span&gt; capacity) {&lt;br/&gt;        value = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[capacity];&lt;br/&gt;    }}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程安全性&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String&lt;/code&gt; 中的对象是不可变的，也就可以理解为常量，线程安全。&lt;code&gt;AbstractStringBuilder&lt;/code&gt; 是 &lt;code&gt;StringBuilder&lt;/code&gt; 与 &lt;code&gt;StringBuffer&lt;/code&gt; 的公共父类，定义了一些字符串的基本操作，如 &lt;code&gt;expandCapacity&lt;/code&gt;、&lt;code&gt;append&lt;/code&gt;、&lt;code&gt;insert&lt;/code&gt;、&lt;code&gt;indexOf&lt;/code&gt; 等公共方法。&lt;code&gt;StringBuffer&lt;/code&gt; 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。&lt;code&gt;StringBuilder&lt;/code&gt; 并没有对方法进行加同步锁，所以是非线程安全的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次对 &lt;code&gt;String&lt;/code&gt; 类型进行改变的时候，都会生成一个新的 &lt;code&gt;String&lt;/code&gt; 对象，然后将指针指向新的 &lt;code&gt;String&lt;/code&gt; 对象。&lt;code&gt;StringBuffer&lt;/code&gt; 每次都会对 &lt;code&gt;StringBuffer&lt;/code&gt; 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 &lt;code&gt;StringBuilder&lt;/code&gt; 相比使用 &lt;code&gt;StringBuffer&lt;/code&gt; 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对于三者使用的总结：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;操作少量的数据: 适用 &lt;code&gt;String&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单线程操作字符串缓冲区下操作大量数据: 适用 &lt;code&gt;StringBuilder&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多线程操作字符串缓冲区下操作大量数据: 适用 &lt;code&gt;StringBuffer&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Object 类的常见方法总结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; Class&amp;lt;?&amp;gt; getClass()&lt;span&gt;//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;hashCode&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;equals&lt;/span&gt;&lt;span&gt;(Object obj)&lt;/span&gt;&lt;span&gt;//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; Object &lt;span&gt;clone&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; CloneNotSupportedException&lt;span&gt;//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt;//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;notify&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt;//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;notifyAll&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt;//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;wait&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; timeout)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException&lt;span&gt;//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;wait&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; timeout, &lt;span&gt;int&lt;/span&gt; nanos)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException&lt;span&gt;//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;wait&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException&lt;span&gt;//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;finalize&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{ }&lt;span&gt;//实例被垃圾回收器回收的时候触发的操作&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;反射&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;何为反射？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;反射机制优缺点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;优点&lt;/strong&gt; ：可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;缺点&lt;/strong&gt; ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;反射的应用场景&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 &lt;code&gt;Method&lt;/code&gt; 来调用指定的方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DebugInvocationHandler&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;InvocationHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 代理类中的真实对象&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object target;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;DebugInvocationHandler&lt;/span&gt;&lt;span&gt;(Object target)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.target = target;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;invoke&lt;/span&gt;&lt;span&gt;(Object proxy, Method method, Object[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InvocationTargetException, IllegalAccessException &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;before method &quot;&lt;/span&gt; + method.getName());&lt;br/&gt;        Object result = method.invoke(target, args);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;after method &quot;&lt;/span&gt; + method.getName());&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，像 Java 中的一大利器 &lt;strong&gt;注解&lt;/strong&gt; 的实现也用到了反射。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么你使用 Spring 的时候 ，一个&lt;code&gt;@Component&lt;/code&gt;注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 &lt;code&gt;@Value&lt;/code&gt;注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;异常&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Java 异常类层次结构图&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6001712328767124&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmQSF4qmibjDCYDtwSVmb3QNj6n09shiaM60zoXpenJ1mvvXGiaM8Z6dS2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1168&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图片来自：https://simplesnippets.tech/exception-handling-in-java-part-1/&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4892086330935252&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmPFzMa8stp8C4AGhjboa5tr5Xhxol9fLQgYkX5oFp4Xjlq4rliahOD5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1946&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图片来自：https://chercher.tech/java-programming/exceptions-java&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Java 中，所有的异常都有一个共同的祖先 &lt;code&gt;java.lang&lt;/code&gt; 包中的 &lt;code&gt;Throwable&lt;/code&gt; 类。&lt;code&gt;Throwable&lt;/code&gt; 类有两个重要的子类 &lt;code&gt;Exception&lt;/code&gt;（异常）和 &lt;code&gt;Error&lt;/code&gt;（错误）。&lt;code&gt;Exception&lt;/code&gt; 能被程序本身处理(&lt;code&gt;try-catch&lt;/code&gt;)， &lt;code&gt;Error&lt;/code&gt; 是无法处理的(只能尽量避免)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Exception&lt;/code&gt; 和 &lt;code&gt;Error&lt;/code&gt; 二者都是 Java 异常处理的重要子类，各自都包含大量子类。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/strong&gt; :程序本身可以处理的异常，可以通过 &lt;code&gt;catch&lt;/code&gt; 来进行捕获。&lt;code&gt;Exception&lt;/code&gt; 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/strong&gt; ：&lt;code&gt;Error&lt;/code&gt; 属于程序无法处理的错误 ，我们没办法通过 &lt;code&gt;catch&lt;/code&gt; 来进行捕获 。例如，Java 虚拟机运行错误（&lt;code&gt;Virtual MachineError&lt;/code&gt;）、虚拟机内存不够错误(&lt;code&gt;OutOfMemoryError&lt;/code&gt;)、类定义错误（&lt;code&gt;NoClassDefFoundError&lt;/code&gt;）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;受检查异常&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 代码在编译过程中，如果受检查异常没有被 &lt;code&gt;catch&lt;/code&gt;/&lt;code&gt;throw&lt;/code&gt; 处理的话，就没办法通过编译 。比如下面这段 IO 操作的代码。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8247422680412371&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmadxU2vLkLL46qMToiaqxKia9Gs5MWiaRqaMHXF7VjJ8lL6I0ib7WoYcRsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;582&quot;/&gt;&lt;figcaption&gt;check-exception&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了&lt;code&gt;RuntimeException&lt;/code&gt;及其子类以外，其他的&lt;code&gt;Exception&lt;/code&gt;类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、&lt;code&gt;ClassNotFoundException&lt;/code&gt; 、&lt;code&gt;SQLException&lt;/code&gt;...。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;不受检查异常&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt; 及其子类都统称为非受检查异常，例如：&lt;code&gt;NullPointerException&lt;/code&gt;、&lt;code&gt;NumberFormatException&lt;/code&gt;（字符串转换为数字）、&lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt;（数组越界）、&lt;code&gt;ClassCastException&lt;/code&gt;（类型转换错误）、&lt;code&gt;ArithmeticException&lt;/code&gt;（算术错误）等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Throwable 类常用方法&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;public string getMessage()&lt;/code&gt;&lt;/strong&gt;:返回异常发生时的简要描述&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;public string toString()&lt;/code&gt;&lt;/strong&gt;:返回异常发生时的详细信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;public string getLocalizedMessage()&lt;/code&gt;&lt;/strong&gt;:返回异常对象的本地化信息。使用 &lt;code&gt;Throwable&lt;/code&gt; 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 &lt;code&gt;getMessage（）&lt;/code&gt;返回的结果相同&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;public void printStackTrace()&lt;/code&gt;&lt;/strong&gt;:在控制台上打印 &lt;code&gt;Throwable&lt;/code&gt; 对象封装的异常信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;try-catch-finally&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;try&lt;/code&gt;块：&lt;/strong&gt; 用于捕获异常。其后可接零个或多个 &lt;code&gt;catch&lt;/code&gt; 块，如果没有 &lt;code&gt;catch&lt;/code&gt; 块，则必须跟一个 &lt;code&gt;finally&lt;/code&gt; 块。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;catch&lt;/code&gt;块：&lt;/strong&gt; 用于处理 try 捕获到的异常。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;finally&lt;/code&gt; 块：&lt;/strong&gt; 无论是否捕获或处理异常，&lt;code&gt;finally&lt;/code&gt; 块里的语句都会被执行。当在 &lt;code&gt;try&lt;/code&gt; 块或 &lt;code&gt;catch&lt;/code&gt; 块中遇到 &lt;code&gt;return&lt;/code&gt; 语句时，&lt;code&gt;finally&lt;/code&gt; 语句块将在方法返回之前被执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在以下 3 种特殊情况下，&lt;code&gt;finally&lt;/code&gt; 块不会被执行：&lt;/strong&gt;&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在 &lt;code&gt;try&lt;/code&gt; 或 &lt;code&gt;finally&lt;/code&gt;块中用了 &lt;code&gt;System.exit(int)&lt;/code&gt;退出程序。但是，如果 &lt;code&gt;System.exit(int)&lt;/code&gt; 在异常语句之后，&lt;code&gt;finally&lt;/code&gt; 还是会被执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;程序所在的线程死亡。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关闭 CPU。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面这部分内容来自 issue:https://github.com/Snailclimb/JavaGuide/issues/190。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意：&lt;/strong&gt; 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; value * value;&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果调用 &lt;code&gt;f(2)&lt;/code&gt;，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用 &lt;code&gt;try-with-resources&lt;/code&gt; 来代替&lt;code&gt;try-catch-finally&lt;/code&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;适用范围（资源的定义）：&lt;/strong&gt; 任何实现 &lt;code&gt;java.lang.AutoCloseable&lt;/code&gt;或者 &lt;code&gt;java.io.Closeable&lt;/code&gt; 的对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;关闭资源和 finally 块的执行顺序：&lt;/strong&gt; 在 &lt;code&gt;try-with-resources&lt;/code&gt; 语句中，任何 catch 或 finally 块在声明的资源关闭后运行&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《Effecitve Java》中明确指出：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;面对必须要关闭的资源，我们总是应该优先使用 &lt;code&gt;try-with-resources&lt;/code&gt; 而不是&lt;code&gt;try-finally&lt;/code&gt;。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。&lt;code&gt;try-with-resources&lt;/code&gt;语句让我们更容易编写必须要关闭的资源的代码，若采用&lt;code&gt;try-finally&lt;/code&gt;则几乎做不到这点。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 中类似于&lt;code&gt;InputStream&lt;/code&gt;、&lt;code&gt;OutputStream&lt;/code&gt; 、&lt;code&gt;Scanner&lt;/code&gt; 、&lt;code&gt;PrintWriter&lt;/code&gt;等的资源都需要我们调用&lt;code&gt;close()&lt;/code&gt;方法来手动关闭，一般情况下我们都是通过&lt;code&gt;try-catch-finally&lt;/code&gt;语句来实现这个需求，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        &lt;span&gt;//读取文本文件的内容&lt;/span&gt;&lt;br/&gt;        Scanner scanner = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            scanner = &lt;span&gt;new&lt;/span&gt; Scanner(&lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;D://read.txt&quot;&lt;/span&gt;));&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (scanner.hasNext()) {&lt;br/&gt;                System.out.println(scanner.nextLine());&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (FileNotFoundException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (scanner != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                scanner.close();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Java 7 之后的 &lt;code&gt;try-with-resources&lt;/code&gt; 语句改造上面的代码:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt; (Scanner scanner = &lt;span&gt;new&lt;/span&gt; Scanner(&lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;))) {&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (scanner.hasNext()) {&lt;br/&gt;        System.out.println(scanner.nextLine());&lt;br/&gt;    }&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (FileNotFoundException fnfe) {&lt;br/&gt;    fnfe.printStackTrace();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然多个资源需要关闭的时候，使用 &lt;code&gt;try-with-resources&lt;/code&gt; 实现起来也非常简单，如果你还是用&lt;code&gt;try-catch-finally&lt;/code&gt;可能会带来很多问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过使用分号分隔，可以在&lt;code&gt;try-with-resources&lt;/code&gt;块中声明多个资源。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt; (BufferedInputStream bin = &lt;span&gt;new&lt;/span&gt; BufferedInputStream(&lt;span&gt;new&lt;/span&gt; FileInputStream(&lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)));&lt;br/&gt;             BufferedOutputStream bout = &lt;span&gt;new&lt;/span&gt; BufferedOutputStream(&lt;span&gt;new&lt;/span&gt; FileOutputStream(&lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;out.txt&quot;&lt;/span&gt;)))) {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; b;&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; ((b = bin.read()) != -&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;                bout.write(b);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;I\O 流&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是序列化?什么是反序列化?&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;序列化&lt;/strong&gt;：将数据结构或对象转换成二进制字节流的过程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;反序列化&lt;/strong&gt;：将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维基百科是如是介绍序列化的：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;序列化&lt;/strong&gt;（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上：&lt;strong&gt;序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4006024096385542&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmdkuOzRoF32s4L0ZPB6ib1MKfe2MflhRWqateEEl967ff0VSDr22Gnbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;664&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://www.corejavaguru.com/java/serialization/interview-questions-1&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Java 序列化中如果有些字段不想进行序列化，怎么办？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;对于不想进行序列化的变量，使用&lt;/code&gt;transient&lt;code&gt;关键字修饰。&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;transient&lt;/code&gt; 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 &lt;code&gt;transient&lt;/code&gt; 修饰的变量值不会被持久化和恢复。&lt;code&gt;transient&lt;/code&gt; 只能修饰变量，不能修饰类和方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;获取用键盘输入常用的两种方法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法 1：通过 &lt;code&gt;Scanner&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Scanner input = &lt;span&gt;new&lt;/span&gt; Scanner(System.in);&lt;br/&gt;String s  = input.nextLine();&lt;br/&gt;input.close();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法 2：通过 &lt;code&gt;BufferedReader&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BufferedReader input = &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; InputStreamReader(System.in));&lt;br/&gt;String s = input.readLine();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Java 中 IO 流分为几种?&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;按照流的流向分，可以分为输入流和输出流；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;按照操作单元划分，可以划分为字节流和字符流；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;按照流的角色划分为节点流和处理流。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按操作方式分类结构图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmDJPvAPWFTLWfq9o77Wicib5JL5QP3LiclXavTeIFOBCaNRicvc0WaUappA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;figcaption&gt;IO-操作方式分类&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按操作对象分类结构图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7430555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmNDp5EBPicwuWRITg2YVO2iciaCtIZX6FXI0Ce5rMwGicibiavkYXHAths6Sg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;figcaption&gt;IO-操作对象分类&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;既然有了字节流,为什么还要有字符流?&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题本质想问：&lt;strong&gt;不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 参考&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://www.educba.com/oracle-vs-openjdk/&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk?answertab=active#tab-top## 基础概念与常识&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>828f50e78a714feed7244574ef8eba43</guid>
<title>[推荐] 书单丨“1 本抵 10 本” 的好书，建议收藏</title>
<link>https://toutiao.io/k/08uadl6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;不用赞赏，在看就行（不点也行）&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7c5ba701aa6f2d440aa7349ee056f773</guid>
<title>[推荐] 如何设计一个高性能的秒杀系统</title>
<link>https://toutiao.io/k/6z3uu2m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;秒杀系统要如何架构，在做技术方案时要注意哪些问题，搞了个秒杀专辑，专门收集秒杀系列文章。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当你去一家公司面试时，很多面试官都会问你如何设计一个高性能秒杀系统。秒杀涉及的技术域从客户端、浏览器、网络、负载均衡、应用服务器、CDN、静态化、库存超卖、流量排队、流控、各种缓存组合、数据库存储等，非常之多，整个后端领域知识基本都会用到。比起普通的业务系统  ，秒杀对技术要求无论在深度还是广度都非常之高，很容易全面考察候选人的技术水平。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然不同公司、不同业务场景，在系统设计灵活性、技术框架选型可能也会有不同，如何用最少的成本满足业务需求，才是最靓的技术方案，所以也能考察候选人的思维应变能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;秒杀特征&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、活动一般都是整点开始，一瞬间会有大量的用户流量涌入，流量可能是平时&lt;/span&gt;&lt;span&gt;的几十倍，系统QPS非常高，因此对系统的性能要求非常高&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、虽然流量非常高，但是与常规业务不同，不是每个用户请求都是要对其负责并处理。&lt;/span&gt;&lt;span&gt;简单来说，可以响应标准化错误文案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、持续时间非常短，往往只有几秒钟，长的话也可能只有几分钟&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、活动商品一般都会有库存限制，一定要控制好并发，不能因为高并发引发了&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;库存超卖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;面临的挑战&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、现有业务的风险隔离&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;秒杀活动属于营销玩法，带动网站氛围。具有时间短、并发高的特点。对网站正常业务可能会有影响。我们一般会将秒杀系统单独部署，采用独立域名，从物理资源层面做到风险隔离。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、前台用户频繁刷新，数据库的负载较高&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般会引入缓存机制，商品详情页面静态化处理，放入CDN，用户可以从最近的CDN节点拉取内容。动态的内容，比如库存，采用ajax异步化形式从中心服务器获取，当然后面应用服务器也会有缓存机制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、秒杀器限制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了避免用户直接访问下单页面URL，需要将URL动态化，每次打开详情页时动态生成一个随机数，用于后端校验请求的合法性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、评估网络带宽&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;计算商品页面的大小，然后可以算出需要的网络带宽，（网络带宽= 单个页面大小*QPS），如果带宽不足需要及时购买。同时大部分的带宽都是图片资源，我们可以考虑将图片、js、css等信息缓存到CDN。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;架构原则&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、数据要尽量少。请求的数据包括上传给系统的数据和系统返回给用户的数据（通常就是网页）。因为首先这些数据在网络上传输需要时间，其次不管是请求数据还是返回数据都需要服务器做处理，而服务器在写网络时通常都要做压缩和字符编码，这些都非常消耗 CPU，所以减少传输的数据量可以显著减少 CPU 的使用。例如，我们可以简化秒杀页面的大小，去掉不必要的页面装修效果，等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、请求数要尽量少。用户请求的页面返回后，浏览器渲染这个页面还要包含其他的额外请求，比如说，这个页面依赖的 CSS/JavaScript、图片，以及 Ajax 请求等等都定义为“额外请求”，这些额外请求应该尽量少。因为浏览器每发出一个请求都多少会有一些消耗，例如建立连接要做三次握手，有的时候有页面依赖或者连接数限制，一些请求（例如 JavaScript）还需要串行加载等。另外，如果不同请求的域名不一样的话，还涉及这些域名的 DNS 解析，可能会耗时更久。所以你要记住的是，减少请求数可以显著减少以上这些因素导致的资源消耗。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如，减少请求数最常用的一个实践就是合并 CSS 和 JavaScript 文件，把多个 JavaScript 文件合并成一个文件，在 URL 中用逗号隔开（https://g.xxx.com/tm/xx-b/4.0.94/mods/??module-preview/index.xtpl.js,module-jhs/index.xtpl.js,module-focus/index.xtpl.js）。这种方式在服务端仍然是单个文件各自存放，只是服务端会有一个组件解析这个 URL，然后动态把这些文件合并起来一起返回。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、路径要尽量短。所谓“路径”，就是用户发出请求到返回数据这个过程中，需要经过的中间的节点数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以缩短请求路径不仅可以增加可用性，同样可以有效提升性能（减少中间节点可以减少数据的序列化与反序列化），并减少延时（可以减少网络传输耗时）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、依赖要尽量少。举个例子，比如说你要展示秒杀页面，而这个页面必须强依赖商品信息、用户信息，还有其他如优惠券、成交列表等这些对秒杀不是非要不可的信息（弱依赖），这些弱依赖在紧急情况下就可以去掉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5、系统中的单点可以说是系统架构上的一个大忌，因为单点意味着没有备份，风险不可控，我们设计分布式系统最重要的原则就是“消除单点”。避免将服务的状态和机器绑定，即把服务无状态化，这样服务就可以在机器中随意移动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;秒杀架构设计&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，从产品--&amp;gt;前端--&amp;gt;后端---&amp;gt;数据存储，庖丁解牛讲解各个模块的设计思路，以及要注意的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;产品层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;秒杀系统为秒杀而设计，不同于一般的网购行为，参与秒杀活动的用户更关心的是如何能快速刷新商品页面，在秒杀开始的时候抢先进入下单页面，而不是商品详情等用户体验细节，因此秒杀系统的页面设计应尽可能简单。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;商品页面中的购买按钮只有在秒杀活动开始的时候才变亮，在此之前及秒杀商品卖出后，该按钮都是灰色的，不可以点击。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下单表单也尽可能简单，&lt;/span&gt;&lt;span&gt;购买数量只能是一个且不可以修改，送货地址和付款方式都使用用户默认设置，没有默认也可以不填，允许在订单提交后再修改；&lt;/span&gt;&lt;span&gt;只有第一个提交的订单发送给网站的订单子系统，其余用户提交订单后只能看到秒杀结束页面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;前端层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、html页面一般比较大，即使做了压缩，http头和内容的大小也可能高达数十K，加上其他的css， js，图片等资源，如果同时有几千万人参与一个商品的抢购，一般机房带宽也就只有1G10G，&lt;strong&gt;网络带宽就极有可能成为瓶颈&lt;/strong&gt;，所以这个页面上&lt;strong&gt;各类静态资源首先应分开存放&lt;/strong&gt;&lt;strong&gt;，然后放到cdn节点上分散压力&lt;/strong&gt;，由于CDN节点遍布全国各地，能缓冲掉绝大部分的压力，而且还比机房带宽便宜&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、秒杀倒计时。这个时间可以从后端实时获取，避免本地时间不准（另外本地的系统时间可以随意更改）。如果活动时间未到，下单按钮置灰，不允许下单购买。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、用户点击“查询”或者“购票”后，按钮置灰，等待结果返回，禁止用户重复提交请求。JS层面，限制用户在x秒之内只能提交一次请求;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;后端层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前端层的请求拦截，只能拦住小白用户（不过这是99%的用户），高端的程序员根本不吃这一套，写个for循环，直接调用你后端的http请求，怎么整？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同一个uid，限制访问频度，做页面缓存，x秒内到达站点层的请求，均返回同一页面&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同一个item的查询，例如手机车次，做页面缓存，x秒内到达站点层的请求，均返回同一页面&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如此限流，又有99%的流量会被拦截在站点层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前两层只能拦住普通程序员，高级黑客，假设他控制了10w台肉鸡（并且假设买票不需要实名认证），这下uid的限制不行了吧？怎么整？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户请求分发模块：使用Nginx或Apache将用户的请求分发到不同的机器上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户请求预处理模块：判断商品是不是还有剩余来决定是不是要处理该请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户请求处理模块：把通过预处理的请求封装成事务提交给数据库，并返回是否成功。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据库接口模块：该模块是数据库的唯一接口，负责与数据库交互，提供RPC接口供查询是否秒杀结束、剩余数量等信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据库设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分片解决的是“数据量太大”的问题，也就是通常说的“水平切分”。一旦引入分片，势必有“数据路由”的概念，哪个数据访问哪个库。路由规则通常有3种方法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、范围：range&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优点：简单，容易扩展&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缺点：各库压力不均（新号段更活跃）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、哈希：hash 【大部分互联网公司采用的方案二：哈希分库，哈希路由】&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优点：简单，数据均衡，负载均匀&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缺点：迁移麻烦（2库扩3库数据要迁移）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、路由服务：router-config-server&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优点：灵活性强，业务与路由算法解耦&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缺点：每次访问数据库前多一次查询&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;库存超卖&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;秒杀的并发非常高，库存只有一条记录，如果控制不当，很容易产生超卖现象，解决思路无非就是加锁，分为两种：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、悲观锁&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.26022304832713755&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXIe5GQrnVAIRgal0Kvly3bv2VlAcaW9FEaq526vgIb9D1szYPYnbMtpkx0BGUsrK8MdM44TcwqeXQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1076&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;悲观锁，也就是在修改数据的时候，采用锁定状态，排斥外部请求的修改。遇到加锁的状态，就必须等待。虽然能解决安全问题，但是系统的吞吐量不高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、乐观锁&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.1625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3Ohm6WHibeXIe5GQrnVAIRgal0Kvly3bvcMZHiaAspCZFibCRmSTcjgH55jlOgGVZxrClqtCCzrfMbNgzMwJrEu0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;乐观锁采用“version”版本号控制更新，预设所有请求都有资格可以修改，并获得当前的版本号，如果版本号一致才能更新成功。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;稳定性方面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;重启与过载保护。如果系统发生“雪崩”，贸然重启服务，是无法解决问题的。最常见的现象是，启动起来后，立刻挂掉。这个时候，最好在入口层将流量拒绝，然后再将重启。如果是redis/memcache这种服务也挂了，重启的时候需要注意“预热”，并且很可能需要比较长的时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;秒杀和抢购的场景，流量往往是超乎我们系统的准备和想象的。这个时候，过载保护是必要的。如果检测到系统满负载状态，拒绝请求也是一种保护措施。在前端设置过滤是最简单的方式，但是，这种做法是被用户“千夫所指”的行为。更合适一点的是，将过载保护设置在CGI入口层，快速将客户的直接请求返回。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;风控方面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、识别一些”秒杀器”、“刷票软件”的请求，并能有效拦截，杜绝资损，保证活动效果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、一个账号，一次性发出多个请求，破坏了秒杀和抢购的公平性。后台服务有防刷机制，需要全局性的访问计数器控制，比如说一秒钟只允许一次请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、多个账号，一次性发送多个请求。很多公司的账号注册功能，在发展早期几乎是没有限制的，很容易就可以注册很多个账号。因此，也导致了出现了一些特殊的工作室，通过编写自动注册脚本，积累了一大批“僵尸账号”，数量庞大，几万甚至几十万的账号不等，专门做各种刷的行为（这就是微博中的“僵尸粉“的来源）。解决方案：可以通过检测指定机器IP请求频率就可以解决，如果发现某个IP请求频率很高，可以给它弹出一个验证码或者直接禁止它的请求，弹出验证码，可以分辨出真实用户。当然市面也有专门的打码服务，通过机器学习自动识别验证码，所以验证码的防识别难度也在不断加大。比如：有些验证码采用随机答题库，防止秒杀器抢单。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、多个账号，不同IP发送不同请求。目前市面上有专门卖代理服务的公司，提供代理IP，尽量模拟真实用户请求，这个时候，通常只能通过设置业务门槛高来限制这种请求了，或者通过账号行为的”数据挖掘“来提前清理掉它们。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;僵尸账号也还是有一些共同特征的，例如账号很可能属于同一个号码段甚至是连号的，活跃度不高，等级低，资料不全等等。根据这些特点，适当设置参与门槛，例如限制参与秒杀的账号等级。通过这些业务手段，也是可以过滤掉一些僵尸号。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;下面我们讲几个经典的设计案例&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;面对如此高的流量请求，如果是按常规模式，先让业务方评估秒杀规模，然后估算峰值流量，进而估算需要加多少台服务器，然后准备线上紧急扩容。活动结束后，还要将机器回收。劳民伤财，有没有更优的解决方案？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、异步下单&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;异步化处理可以对流量进行削峰，满足高性能需求，同时不需要扩容太多的机器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.53203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3Ohm6WHibeXIe5GQrnVAIRgal0Kvly3bveibKZm8icUsCJpv4L3E1bYcN6clhZJpPrSn55C5WDXnYz0oWw6SibEngQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设计方案中，我们在前端和下单系统之间，增加一个排队系统。我们简单看下详细的处理过程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、用户访问商品详情页，然后提交订单请求，订单请求首先是进入请求队列，同时返回一个排队号码&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、前端会跳转到一个中间态的等待页，这个页面会根据排队号，定时地查询排队系统，排队系统会返回预订单在队列中的位置信息，包括它前面还有多少未处理的预订单，以及后台系统大概还要多久会处理这个预订单，这样用户就不会焦虑；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、在排队系统的处理区，有很多消费者，它们依次从排队区的队列里获取预订单，然后调用后台下单系统生成实际的订单；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、随着预订单变成正式的订单，队列里的预订单会逐渐变少，如果当前的预订单已经从队列里被移除了，用户的等待页就会检测到这个情况，页面自动跳转到订单完成页，这就和常规的购物流程一样了，用户进行最后的支付，最终完成整个前台下单过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.1018957345971565&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3Ohm6WHibeXIe5GQrnVAIRgal0Kvly3bvnnA7GWpWgQNliaEY54lz4ECHKbRP9OEqaLEsNPrzPo6uxkn0dKhhzqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;844&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图是滴滴叫车的排队等待页，司机数代表系统的并发处理能力。如果，这片区域司机较少，叫车乘客较多的话，就会出现排队现象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于队列的技术选型，我们采用Redis 的List结构，更轻量级且性能更好。除了和 MQ 一样支持消息的先进先出以外，我们还可以获取队列的长度，以及通过排队号获取消息在队列中的位置，这样我们就可以给前端反馈预订单的处理进度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，秒杀系统一般都是直接下单，不会采用购物车形式，一个订单往往只有一件商品。所以我们可以为每个商品提供一个单独的队列，将数据分片，多个队列可以提供更好的性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于队列长度，为了保证用户能够买到商品，我们并不是把所有前台的下单请求都会放到队列里，而是根据参与活动的秒杀商品库存数量，按照 1:1 的比例，设置队列初始长度，这样就保证了进入队列的请求最终都能生成订单。这个可用队列长度会随着预订单进入队列，不断地减少，&lt;/span&gt;&lt;span&gt;当数值变为 0 时，排队系统会拒绝接受新请求进入队列，直接反馈用户下单失败。&lt;/span&gt;&lt;span&gt;当然，如果后台订单生成异常或用户取消订单后，可用队列长度会增加，前台会重新开放预订单进入队列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;任何事情都有两面性，有优势自然有不足。该方案适合瞬间有高并发流量，比如秒杀场景。如果该高峰期持续时间较长，同时注重用户体验，需要实时看到下单结果，则不适合采用异步下单方案。比如”外卖业务“，高峰期集中在中午11点到下午1点，从下单到送达一般在半个小时左右，对实时性要求很高。此时需要通过水平扩容，提升系统的处理能力。当然如果部署在阿里云，可以考虑弹性扩容、缩容，节省成本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;高可用建设&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、降级。所谓“降级”，就是当系统的容量达到一定程度时，限制或者关闭系统的某些非核心功能，从而把有限的资源保留给更核心的业务。它是一个有目的、有计划的执行过程，所以对降级我们一般需要有一套预案来配合执行。如果我们把它系统化，就可以通过预案系统和开关系统来实现降级。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、限流。如果说降级是牺牲了一部分次要的功能和用户的体验效果，那么限流就是更极端的一种保护措施了。限流就是当系统容量达到瓶颈时，我们需要通过限制一部分流量来保护系统，并做到既可以人工执行开关，也支持自动化保护的措施。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、拒绝服务。当系统负载达到一定阈值时，例如 CPU 使用率达到 90% 或者系统 load 值达到 2*CPU 核数时，系统直接拒绝所有请求。这种方式是最暴力但也最有效的系统保护方式。比如：在最上层的 Nginx 上设置过载保护，当机器负载达到某个值时直接拒绝 HTTP 请求并返回 503 错误码。拒绝服务可以说是一种不得已的兜底方案，防止最坏情况发生。防止因把服务器压跨而长时间彻底无法提供服务。像这种系统过载保护虽然在过载时无法提供服务，但是系统仍然可以运作，当负载下降时又很容易恢复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;往期推荐&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXJxE2KOULCAe2BQfUfcd9Lf2kqibBfdJrGWFPBdoialWJAiaG8FPicR15jW3s75tfS1hKNK9TdqdYjicAg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注&lt;/span&gt;&lt;span&gt;【微观技术】&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们热衷于收集&amp;amp;分享高并发、系统架构、微服务、消息中间件、 RPC框架、高性能缓存、搜索、分布式数据框架、分布式协同服务、分布式配置中心、中台架构、领域驱动设计、系统监控、系统稳定性等技术知识。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;关注公众号，后&lt;/span&gt;&lt;span&gt;台回复“&lt;/span&gt;&lt;span&gt;&lt;strong&gt;中台&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;，下载PDF学&lt;/span&gt;&lt;span&gt;习资料&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>76f3c6d7b95a1375791e8c715296f9c9</guid>
<title>[推荐] Kafka：这次分享我只想把原理讲清楚</title>
<link>https://toutiao.io/k/0etokja</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibxF1tBEhAfIrNS5CR1J2BlSKRjcOg1lqdOI6sAdgBpw9676R7g7MCBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.34748010610079577&quot; data-w=&quot;754&quot;/&gt;&lt;/p&gt;&lt;h2&gt;前言:&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;1.由来&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;为什么使用消息队列？&lt;/section&gt;&lt;section&gt;从系统之间有通信需求开始，就自然产生了消息队列。&lt;/section&gt;&lt;section&gt;在计算机科学中，消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的资料，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。&lt;br/&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2.特点&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;解耦：&lt;/p&gt;&lt;p&gt;允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;冗余：&lt;/p&gt;&lt;p&gt;消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;扩展性：&lt;/p&gt;&lt;p&gt;因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;灵活性 &amp;amp; 峰值处理能力：&lt;/p&gt;&lt;p&gt;在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可恢复性：&lt;/p&gt;&lt;p&gt;系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;顺序保证：&lt;/p&gt;&lt;p&gt;在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。（Kafka 保证一个 Partition 内的消息的有序性）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;缓冲：&lt;/p&gt;&lt;p&gt;有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;异步通信：&lt;/p&gt;&lt;p&gt;很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;span&gt;3.使用场景&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.271875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibiaHfg9kPF6jUbqsmdjQFNPz3ZISNoyE6libIf8xyhxZ67NMoKZTW6T5A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtiby03ZwSVnFXKzojo6kJAq69jkVNiapMoN5bJQIpZ2QPAvt6yXIsxsia9Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;4.两种模式&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibljibSwG8tkiba23K9C9Wic0hdd55N6DFFb9nMgzQSIejLJw2VGL1pJJfA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.35625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibGGuDEhtDP9xIYll15X0fkOmqNbg5hXzdVfibqnLDibWU0BnJor2ibAZTA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2&gt;1.名词解释&lt;/h2&gt;&lt;p&gt;kafka是一个分布式流处理平台。&lt;/p&gt;&lt;h2&gt;2.历史由来&lt;/h2&gt;&lt;p&gt;Kafka从何而来?我们为什么要开发Kafka? Kafka到底是什么?&lt;br/&gt;        Kafka 最初是 LinkedIn 的一个内部基础设施系统。我们发现虽然有很多数据库和系统可以用来存储数据，但在我们的架构里，&lt;strong&gt;刚好缺一个可以帮助处理持续数据流的组件&lt;/strong&gt;。在开发Kafka之前，我们实验了各种现成的解决方案，&lt;strong&gt;从消息系统到日志聚合系统，再到ETL工具，它们都无法满足我们的需求。&lt;/strong&gt;&lt;br/&gt;        最后，我们决定从头开发一个系统。&lt;strong&gt;我们不想只是开发一个能够存储数据的系统&lt;/strong&gt;，比如传统的关系型数据库、键值存储引擎、搜索引擎或缓存系统，&lt;strong&gt;我们希望能够把数据看成是持续变化和不断增长的流&lt;/strong&gt;，并基于这样的想法构建出一个数据系统。事实上，是一个数据架构。&lt;br/&gt;        这个想法实现后比我们最初预想的适用性更广。Kafka 一开始被用在社交网络的实时应用和数据流当中，而现在已经成为下一代数据架构的基础。大型零售商正在基于持续数据流改造他们的基础业务流程，汽车公司正在从互联网汽车那里收集和处理实时数据流，银行也在重新思考基于 Kafka 改造他们的基础。&lt;/p&gt;&lt;p&gt;它可以用于两大类别的应用:&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;构造实时流数据管道，它可以在系统或应用之间可靠地获取数据。(相当于message queue)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;构建实时流式应用程序，对这些流数据进行转换或者影响。(就是流处理，通过kafka stream topic和topic之间内部进行变化)&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;版本号&lt;/h3&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;版本号&lt;/th&gt;&lt;th&gt;备注&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;0.7&lt;/td&gt;&lt;td&gt;上古版本，提供了最基础的消息队列功能&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.8&lt;/td&gt;&lt;td&gt;引入了&lt;strong&gt;副本机制&lt;/strong&gt;，成为了一个真正意义上完备的分布式高可靠消息队列解决方案&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.8.2&lt;/td&gt;&lt;td&gt;&lt;strong&gt;新版本 Producer API&lt;/strong&gt;，即需要指定 Broker 地址的 Producer&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.9&lt;/td&gt;&lt;td&gt;增加了基础的安全认证 / 权限，Java 重写了新版本消费者 API&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.10.0.0&lt;/td&gt;&lt;td&gt;&lt;strong&gt;引入了 Kafka Streams&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.11.0.0&lt;/td&gt;&lt;td&gt;提供幂等性 Producer API 以及事务（Transaction） API，对 Kafka 消息格式做了重构。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1.0&lt;/td&gt;&lt;td&gt;Kafka Streams 的各种改进&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2.0&lt;/td&gt;&lt;td&gt;Kafka Streams 的各种改进&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;3.术语&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;消息：Record。这里的消息就是指 Kafka 处理的主要对象。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;服务：&lt;strong&gt;Broker&lt;/strong&gt;。一个 Kafka 集群由多个 Broker 组成，Broker 负责接收和处理客户端发送过来的请求，以及对消息进行持久化。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;主题：&lt;strong&gt;Topic&lt;/strong&gt;。主题是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;分区：&lt;strong&gt;Partition&lt;/strong&gt;。一个有序不变的消息序列。每个主题下可以有多个分区。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;消息位移：Offset。表示分区中每条消息的位置信息，是一个单调递增且不变的值。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;副本：Replica。Kafka 中同一条消息能够被拷贝到多个地方以提供数据冗余，这些地方就是所谓的副本。副本还分为领导者副本和追随者副本，各自有不同的角色划分。副本是在分区层级下的，即每个分区可配置多个副本实现高可用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;生产者：&lt;strong&gt;Producer&lt;/strong&gt;。向主题发布新消息的应用程序。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;消费者：&lt;strong&gt;Consumer&lt;/strong&gt;。从主题订阅新消息的应用程序。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;消费者位移：Consumer Offset。表征消费者消费进度，每个消费者都有自己的消费者位移。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;消费者组：Consumer Group。多个消费者实例共同组成的一个组，同时消费多个分区以实现高吞吐。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;重平衡：Rebalance。消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalance 是 Kafka 消费者端实现高可用的重要手段。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5404944586530265&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibdRLhGOwS5TP1ZicRpHIo38zh9If9R2HIrFQYBePKUnTbzaBahZnPr1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1173&quot;/&gt;&lt;/p&gt;&lt;h2&gt;4.Topic&lt;/h2&gt;&lt;h3&gt;日志&lt;/h3&gt;&lt;p&gt;日志可能是一种最简单的不能再简单的存储抽象，只能追加、按照时间完全有序（totally-ordered）的记录序列。日志看起来的样子：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4722222222222222&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibN6D0O2EAicdJhqt8IGqpwytLteB5PVgOClVKjpTCxAVo03DicCI3dvfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;396&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在日志的末尾添加记录，读取日志记录则从左到右。每一条记录都指定了一个唯一的顺序的日志记录编号。&lt;/p&gt;&lt;p&gt;日志记录的次序（ordering）定义了『时间』概念，因为位于左边的日志记录表示比右边的要早。日志记录编号可以看作是这条日志记录的『时间戳』。把次序直接看成是时间概念，刚开始你会觉得有点怪异，但是这样的做法有个便利的性质：解耦了 时间 和 任一特定的物理时钟（physical clock）。引入分布式系统后，这会成为一个必不可少的性质。&lt;/p&gt;&lt;p&gt;日志 和 文件或数据表（table）并没有什么大的不同。文件是一系列字节，表是由一系列记录组成，而日志实际上只是一种按照时间顺序存储记录的数据表或文件。&lt;/p&gt;&lt;p&gt;对于每一个topic， Kafka集群都会维持一个分区日志，如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6418269230769231&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibdMBQ983ymwzBAJJaxTQHyW1txkddpO1cLOhq164FCkyEq4RbibeUZIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;416&quot;/&gt;&lt;/p&gt;&lt;h3&gt;实操&lt;/h3&gt;&lt;p&gt;启动zk&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;cd&lt;/span&gt; /usr/&lt;span class=&quot;code-snippet__built_in&quot;&gt;local&lt;/span&gt;/kara/kafka_2.13-2.6.0/bin&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;zookeeper-server-start.sh ../config/zookeeper.properties&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;启动kafka服务器&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;kafka-server-start.sh ../config/server.properties&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;创建topic，4个分区，一个副本&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;kafka-topics&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.sh&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;--create&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;--zookeeper&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;localhost&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:2181&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;--replication-factor&lt;/span&gt; 1 &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;--partitions&lt;/span&gt; 4 &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;--topic&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;partition_test&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;发送一些消息&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;kafka-console-producer&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.sh&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;--broker-list&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;localhost&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:9092&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;--topic&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;partition_test&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;启动一个consumer&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;kafka-&lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;-consumer.sh --bootstrap-server localhost:&lt;span class=&quot;code-snippet__number&quot;&gt;9092&lt;/span&gt; --topic partition_test --&lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt;-beginning&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;分区&lt;/h3&gt;&lt;h4&gt;partition存储分布&lt;/h4&gt;&lt;p&gt;一个topic下有多个不同partition，每个partition为一个目录，partiton命名规则为&lt;strong&gt;topic名称+有序序号&lt;/strong&gt;，第一个partiton序号从0开始，序号最大值为partitions数量减1&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibzFtlicEevsHUSb8Zic71ibFX3UicR9rqS1icE3nxZs1QI9gE6WEWVeyGNWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.1824074074074074&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h4&gt;partition文件存储&lt;/h4&gt;&lt;p&gt;1.每个partion(目录)相当于一个巨型文件被平均分配到多个大小相等segment(段)数据文件中。但每个段segment file消息数量不一定相等，这种特性方便old segment file快速被删除。&lt;/p&gt;&lt;p&gt;2.每个partiton只需要支持顺序读写就行了，segment文件生命周期由服务端配置参数决定。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8472803347280334&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibe3via8ibTEnZWfuUmUN0ic8bID837EQpgF7H64ZFX3ZQlB3zNVbcxICmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;956&quot;/&gt;&lt;/p&gt;&lt;h4&gt;segment文件存储&lt;/h4&gt;&lt;p&gt;1.segment file组成：由2大部分组成，分别为index file和data file，此2个文件一一对应，成对出现，分别表示为segment索引文件、数据文件.&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7446808510638298&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibeR4Pe7mfxge7Sj8mdK0q2ibIrQLVWACuzqib1FvQDTOCbmMdNiaicmFq1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;282&quot;/&gt;&lt;/p&gt;&lt;p&gt;2.segment文件命名规则：partion全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset值。数值最大为64位long大小，19位数字字符长度，没有数字用0填充。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5978260869565217&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtib7dIIBsQkQutc09hpWmxVzQGY9EyDG3kzWriaKicELk1lzhGS3v3kSuuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;552&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;segment index file采取稀疏索引存储方式，它减少索引文件大小，通过mmap可以直接内存操作，稀疏索引为数据文件的每个对应message设置一个元数据指针,它比稠密索引节省了更多的存储空间，但查找起来需要消耗更多的时间。&lt;/p&gt;&lt;p&gt;3.segment中的消息message物理结构字段说明&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;关键字&lt;/th&gt;&lt;th&gt;解释说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;8 byte offset&lt;/td&gt;&lt;td&gt;在parition(分区)内的每条消息都有一个有序的id号，这个id号被称为偏移(offset),它可以唯一确定每条消息在parition(分区)内的位置。即offset表示partiion的第多少message&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4 byte message size&lt;/td&gt;&lt;td&gt;message大小&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4 byte CRC32&lt;/td&gt;&lt;td&gt;用crc32校验message&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1 byte “magic”&lt;/td&gt;&lt;td&gt;表示本次发布Kafka服务程序协议版本号&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1 byte “attributes”&lt;/td&gt;&lt;td&gt;表示为独立版本、或标识压缩类型、或编码类型。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4 byte key length&lt;/td&gt;&lt;td&gt;表示key的长度,当key为-1时，K byte key字段不填&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;K byte key&lt;/td&gt;&lt;td&gt;可选&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;value bytes payload&lt;/td&gt;&lt;td&gt;表示实际消息数据。&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;文件系统&lt;/h3&gt;&lt;p&gt;Kafka 对消息的存储和缓存严重依赖于文件系统。人们对于“磁盘速度慢”具有普遍印象，事实上，磁盘的速度比人们预期的要慢的多，也快得多，这取决于人们使用磁盘的方式。&lt;/p&gt;&lt;p&gt;使用6个7200rpm、SATA接口、RAID-5的磁盘阵列在JBOD配置下的顺序写入的性能约为600MB/秒，但随机写入的性能仅约为100k/秒，相差6000倍以上。&lt;/p&gt;&lt;p&gt;线性的读取和写入是磁盘使用模式中最有规律的，并且由操作系统进行了大量的优化。&lt;/p&gt;&lt;p&gt;关于该问题的进一步讨论可以参考 ACM Queue article，他们发现实际上顺序磁盘访问在某些情况下比随机内存访问还要快！&lt;/p&gt;&lt;p&gt;&lt;strong&gt;为了弥补这种性能差异，现代操作系统主动将所有空闲内存用作 disk caching（磁盘高速缓存），所有对磁盘的读写操作都会通过这个统一的 cache（ in-process cache）。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;即使进程维护了 in-process cache，该数据也可能会被复制到操作系统的 pagecache 中，事实上所有内容都被存储了两份。&lt;/p&gt;&lt;p&gt;此外，Kafka 建立在 JVM 之上，任何了解 Java 内存使用的人都知道两点：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;对象的内存开销非常高，通常是所存储的数据的两倍(甚至更多)。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;随着堆中数据的增加，Java 的垃圾回收变得越来越复杂和缓慢。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;kafka选择了一个非常简单的设计：相比于维护尽可能多的 in-memory cache，并且在空间不足的时候匆忙将数据 flush 到文件系统，我们把这个过程倒过来。&lt;strong&gt;所有数据一开始就被写入到文件系统的持久化日志中，而不用在 cache 空间不足的时候 flush 到磁盘&lt;/strong&gt;。实际上，这表明数据被转移到了内核的 pagecache 中。&lt;/p&gt;&lt;h4&gt;Pagecache页面缓存&lt;br/&gt;&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.65703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtib5PufCwTia5cPwyetbbO7TMph7Q7qxTlIOsW7rROkvFFN27rZVKXjsAA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Page cache（页面缓存）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Page cache 也叫页缓冲或文件缓冲，是由好几个磁盘块构成，大小通常为4k，在64位系统上为8k，构成的几个磁盘块在物理磁盘上不一定连续，文件的组织单位为一页， 也就是一个page cache大小，文件读取是由外存上不连续的几个磁盘块，到buffer cache，然后组成page cache，然后供给应用程序。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Buffer cache（块缓存）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Buffer cache 也叫块缓冲，是对物理磁盘上的一个磁盘块进行的缓冲，其大小为通常为1k，磁盘块也是磁盘的组织单位。设立buffer cache的目的是为在程序多次访问同一磁盘块时，减少访问时间。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Page cache（页面缓存）与Buffer cache（块缓存）的区别&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;磁盘的操作有逻辑级（文件系统）和物理级（磁盘块），这两种Cache就是分别缓存逻辑和物理级数据的。&lt;/p&gt;&lt;p&gt;我们通过文件系统操作文件，那么文件将被缓存到Page Cache，如果需要刷新文件的时候，Page Cache将交给Buffer Cache去完成，因为Buffer Cache就是缓存磁盘块的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;简单说来，page cache用来缓存文件数据，buffer cache用来缓存磁盘数据。在有文件系统的情况下，对文件操作，那么数据会缓存到page cache，如果直接采用dd等工具对磁盘进行读写，那么数据会缓存到buffer cache。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Buffer(Buffer Cache)以块形式缓冲了块设备的操作，定时或手动的同步到硬盘，它是为了缓冲写操作然后一次性将很多改动写入硬盘，避免频繁写硬盘，提高写入效率。&lt;/p&gt;&lt;p&gt;Cache(Page Cache)以页面形式缓存了文件系统的文件，给需要使用的程序读取，它是为了给读操作提供缓冲，避免频繁读硬盘，提高读取效率。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;降低时间复杂度&lt;/h4&gt;&lt;p&gt;消息系统使用的持久化数据结构通常是和 BTree 相关联的消费者队列或者其他用于存储消息源数据的通用随机访问数据结构。&lt;strong&gt;BTree 的操作复杂度是 O(log N)&lt;/strong&gt;，通常我们认为 O(log N) 基本等同于常数时间，但这条在磁盘操作中不成立。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7264957264957265&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibbsdictIBEn2KywkrqafBiabMpMiaj2HaIA8IrqmjfR3iaGL3ic80OApFkSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;存储系统将非常快的cache操作和非常慢的物理磁盘操作混合在一起，当数据随着 fixed cache 增加时，可以看到树的性能通常是非线性的——比如数据翻倍时性能下降不只两倍。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;kafka选择把持久化队列建立在简单的读取和向文件后追加两种操作之上&lt;/strong&gt;，这和日志解决方案相同。&lt;strong&gt;这种架构的优点在于所有的操作复杂度都是O(1)，而且读操作不会阻塞写操作，读操作之间也不会互相影响。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在不产生任何性能损失的情况下能够访问几乎无限的硬盘空间，Kafka 可以让消息保留相对较长的一段时间(比如一周)，而不是试图在被消费后立即删除。&lt;/p&gt;&lt;h4&gt;降低大量小型IO操作的影响&lt;/h4&gt;&lt;p&gt;小型的 I/O 操作发生在客户端和服务端之间以及服务端自身的持久化操作中。&lt;/p&gt;&lt;p&gt;为了避免这种情况，kafka的协议是建立在一个 “消息块” 的抽象基础上，合理将消息分组。将多个消息打包成一组，而不是每次发送一条消息，从而使整组消息分担网络中往返的开销。&lt;/p&gt;&lt;p&gt;这个简单的优化对速度有着数量级的提升。批处理允许更大的网络数据包，更大的顺序读写磁盘操作，连续的内存块等等，所有这些都使 KafKa 将随机流消息顺序写入到磁盘， 再由 consumers 进行消费。&lt;/p&gt;&lt;h4&gt;零拷贝&lt;/h4&gt;&lt;p&gt;字节拷贝是低效率的操作，在消息量少的时候没啥问题，但是在高负载的情况下，影响就不容忽视。为了避免这种情况，kafka使用 producer ，broker 和 consumer 都共享的标准化的二进制消息格式，这样数据块不用修改就能在他们之间传递。&lt;/p&gt;&lt;p&gt;保持这种通用格式可以&lt;strong&gt;对一些很重要的操作进行优化&lt;/strong&gt;: 持久化&lt;strong&gt;日志块的网络传输&lt;/strong&gt;。现代的unix 操作系统提供了一个高度优化的编码方式，用于将数据从 pagecache 转移到 socket 网络连接中；在 Linux 中系统调用 sendfile 做到这一点。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;传统IO &lt;strong&gt;(4次上下文切换4次拷贝)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;假如将磁盘上的文件读取出来，然后通过网络协议发送给客户端。&lt;/p&gt;&lt;p&gt;一般需要两个系统调用，&lt;strong&gt;但是一共4次上下文切换，4次拷贝&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;read(file, tmp_buf, len);&lt;br/&gt;write(socket, tmp_buf, len);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8754789272030651&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibktdm4AKia3xFejXkezBcyb5ZR5w3kghzic1xfzdMYqSLk8D6zjHhJpicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1044&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;mmap(&lt;strong&gt;4次上下文切换3次拷贝&lt;/strong&gt;)&lt;/p&gt;&lt;p&gt;mmap()系统调用函数会直接把内核缓冲区里的数据「&lt;strong&gt;映射&lt;/strong&gt;」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作，它替换了read()系统调用函数。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;buf = mmap(file, len);&lt;br/&gt;write(sockfd, buf, len);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8858800773694391&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibBV8fs5NH0Xdhib8f8ZkWaAeHBlHGFBktlbCp2KmWuVM7f8aV3FPQgQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1034&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;sendfile（&lt;strong&gt;2次上下文切换3次拷贝&lt;/strong&gt;）&lt;/p&gt;&lt;p&gt;Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 sendfile()&lt;/p&gt;&lt;p&gt;首先，它可以替代前面的 read()和 write()这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。&lt;/p&gt;&lt;p&gt;其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/socket.h&amp;gt;&lt;br/&gt;ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8659003831417624&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtib4iaPwE4cSBvT4iaXSdYKNwz0fA477PjEUVVOrnhbficzoBsSoDRvxerRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1044&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8517110266159695&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibBF3R1keibnmvzEXP2CZb9R1p12ib2KyRtfGco0ATCZG9ibLib5D5QXxM5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1052&quot;/&gt;&lt;/p&gt;&lt;h4&gt;kafka高效文件存储设计特点&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Kafka把topic中一个parition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过索引信息可以快速定位message和确定response的最大大小。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过index元数据全部映射到memory，可以避免segment file的IO磁盘操作。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过索引文件稀疏存储，可以大幅降低index文件元数据占用空间大小。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;5.Broker&lt;/h2&gt;&lt;h3&gt;broker端处理请求的流程&lt;/h3&gt;&lt;p&gt;请求处理的方案：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;顺序处理（同步）&lt;/p&gt;&lt;pre&gt;&lt;code&gt;while(true){&lt;br/&gt;    handle(request);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;吞吐量查，只适用于请求发送不频繁的系统&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;多线程处理（异步）&lt;/p&gt;&lt;pre&gt;&lt;code&gt;while(true){&lt;br/&gt;    () -&amp;gt; {&lt;br/&gt;        handle(request);&lt;br/&gt;    }.start();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不会阻塞下一个请求，但是开销很大&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Reactor模式&lt;/p&gt;&lt;p&gt;Reactor 模式是事件驱动架构的一种实现方式，特别适合应用于处理多个客户端并发向服务器端发送请求的场景.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.32153846153846155&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibIsv9eRF0xlnuu2QalRZIMgy1PvWzILRg6rWao78OE41MjR8dyEvIVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1950&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;该模式有个请求分发线程 Dispatcher，也就是图中的 Acceptor，它会使用&lt;strong&gt;轮询方式&lt;/strong&gt;将不同的请求下发到多个工作线程中处理。Acceptor 线程只是用于请求分发，不涉及具体的逻辑处理，非常得轻量级，因此有很高的吞吐量表现。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;kafka使用的就是Reactor模式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;kafka所有的请求都是通过TCP网络以Socket的方式进行通讯的，它也有对应的 Acceptor 线程和一个工作线程池，在 Kafka 中，这个工作线程池叫网络线程池。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.43435897435897436&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibdsryeciaibK9Bnx5ycJMjauwjSMeoEqFibdHMcmxvnFhR5MXzVBIojQEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1950&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Broker 端参数 &lt;strong&gt;num.network.threads&lt;/strong&gt;，用于调整该网络线程池的线程数。默认3个，专门处理客户端发送的请求。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# The number of threads that the server uses for receiving requests from the network and sending responses to the network&lt;br/&gt;num.network.threads=3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;客户端发来的请求会被 Broker 端的 Acceptor 线程分发到任意一个网络线程中，由它们来进行处理。那么，当网络线程接收到请求后，它是如何处理的？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Kafka 在这个环节又做了一层异步线程池的处理。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5912820512820512&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtib94YbhZpKric9MQWLu9ovabZte5ibaM0DQZ1vEHZ8UF4tAjPwGZyCReeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1950&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;当网络线程拿到请求后，它不是自己处理，而是将请求放入到一个共享请求队列中。Broker 端还有个 IO 线程池，负责从该队列中取出请求，执行真正的处理。&lt;/p&gt;&lt;p&gt;如果是 PRODUCE 生产请求，则将消息写入到底层的磁盘日志中；&lt;/p&gt;&lt;p&gt;如果是 FETCH 请求，则从磁盘或页缓存中读取消息。&lt;/p&gt;&lt;p&gt;Broker 端参数&lt;strong&gt;num.io.threads&lt;/strong&gt;，用于配置IO线程池中的线程数，默认创建8个IO线程处理请求。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# The number of threads that the server uses for processing requests, which may include disk I/O&lt;br/&gt;num.io.threads=8&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;请求队列是所有网络线程共享的，而响应队列则是每个网络线程专属的&lt;/strong&gt;，因为Dispatcher只用于请求的分发而不负责响应回传，因此只能让每个网络线程自己发送Response给客户端。&lt;/p&gt;&lt;p&gt;还有一个Purgatory组件，炼狱组件用于它是用来&lt;strong&gt;缓存延时请求&lt;/strong&gt;（Delayed Request）的。&lt;strong&gt;所谓延时请求，就是那些一时未满足条件不能立刻处理的请求&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;比如设置了 acks=all 的 PRODUCE 请求，一旦设置了 acks=all，那么该请求就必须等待 ISR 中所有副本都接收了消息后才能返回，此时处理该请求的 IO 线程就必须等待其他 Broker 的写入结果。当请求不能立刻处理时，它就会暂存在 Purgatory 中。稍后一旦满足了完成条件，IO 线程会继续处理该请求，并将 Response 放入对应网络线程的响应队列中。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;replication副本机制/备份机制&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;所谓副本，通产指分布式系统中不同机器中保存相同的数据拷贝，&lt;strong&gt;本质就是一个只能追加写消息的提交日志&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;提供数据冗余&lt;/strong&gt;。即使系统部分组件失效，系统依然能够继续运转，因而增加了整体可用性以及数据持久性。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;提供高伸缩性&lt;/strong&gt;。支持横向扩展，能够通过增加机器的方式来提升读性能，进而提高读操作吞吐量。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;改善数据局部性&lt;/strong&gt;。允许将数据放入与用户地理位置相近的地方，从而降低系统延时。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;假如kafka一个主题有3个分区3个副本部署在三台Broker上，在实际生产环境中，每台 Broker 都可能保存有各个主题下不同分区的不同副本，因此，单个 Broker 上存有成百上千个副本的现象是非常正常的。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4971751412429379&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibePribaicXCh02BE5nm6MySBEcU5ndhpsicXK3mvgfLAXRogHFQ5XJhIXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;708&quot;/&gt;&lt;/p&gt;&lt;h4&gt;关键性问题：如何保证副本中的数据是一致的？&lt;/h4&gt;&lt;p&gt;kafka采用了常见的解决方案：&lt;strong&gt;基于领导者（Leader-based）的副本机制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5194871794871795&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibw9MjSQMzgpp9jHqpIze6jspn9B9ZHNvhFGQQRIG06V5uKjUic8RP9bA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1950&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;每个分区在创建时都要选举一个副本，称为领导者副本(Leader Replica)，其余的副本自动称为追随者副本(Follower Replica)。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;所有的请求都必须由领导者副本(Leader Replica)来处理。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;追随者副本不处理客户端请求，它唯一的任务就是从领导者副本&lt;strong&gt;异步拉取&lt;/strong&gt;消息，并写入到自己的提交日志中，&lt;strong&gt;从而实现与领导者副本的同步&lt;/strong&gt;（如何实现同步？）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当领导者副本(Leader Replica)挂了，开启新一轮的领导者选举，依托zookeeper，先到先得&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这样做的优缺点：&lt;/p&gt;&lt;h4&gt;同步副本集合In-sync Replicas(ISR)&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3857721226142279&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtib3BdSHqROncXKDFkNqQ6sZWibIc5r7VtU83b30rSx4P0otRZ2cPRK5JQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1729&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;上图中哪些follower副本是同步的，kafka it depends，视情况而定，不一定是严格的相同&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Broker参数replica.lag.time.max.ms&lt;/strong&gt; ，默认10秒钟&lt;br/&gt;如果一个follower在这个时间内没有发送fetch请求或消费leader日志到结束的offset，leader将从ISR中移除这个follower，并认为这个follower已经挂了&lt;/p&gt;&lt;p&gt;倘若该副本后面慢慢地追上了 Leader 的进度，那么它是能够重新被加回 ISR 的。这也表明，ISR 是一个动态调整的集合，而非静态不变的。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;如果ISR为空该如何选举&lt;/h4&gt;&lt;p&gt;因为 Leader 副本天然就在 ISR 中，如果 ISR 为空了，就说明 Leader 副本也挂掉了，此时该怎么选举新 Leader 。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Kafka 把所有不在 ISR 中的存活副本都称为非同步副本&lt;/strong&gt;。通常来说，非同步副本落后 Leader 太多，如果选择这些副本作为新 Leader，就可能出现数据丢失的情况。在 Kafka 中，选举这种副本的过程称为 Unclean 领导者选举。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Broker 端参数 unclean.leader.election.enable 控制是否允许 Unclean 领导者选举&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;如果想保证数据的一致性，禁用Unclean&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;一个分布式系统通常只能同时满足一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）中的两个。显然，在这个问题上，Kafka 赋予你选择 C 或 A 的权利。&lt;/p&gt;&lt;h3&gt;ISR副本同步机制&lt;/h3&gt;&lt;p&gt;与 Leader 副本保持同步的条件有两个：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1.该远程 Follower 副本在 ISR 中。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.该远程 Follower 副本 LEO 值落后于 Leader 副本 LEO 值的时间&lt;/strong&gt;，不超过 Broker 端参数 replica.lag.time.max.ms 的值。如果使用默认值的话，就是不超过 10 秒。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Committed Message：已提交消息，已经被所有ISR同步的消息。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Lagging Message：未提交消息，没有达到所有ISR同步的消息。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Hight Watermark：副本高水位值，表示分区中最新一条已提交(Committed)的消息的Offset。&lt;strong&gt;位移值等于高水位的消息也属于未提交消息。也就是说，高水位上的消息是不能被消费者消费的&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;LEO：Log End Offset，Leader中最新消息的Offset，它表示副本写入下一条消息的位移值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6833046471600689&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibFz8B24T4lmw7qee9RwaXpanaXpqOD4CpCCqOicg2n0rU6rOMA7IexJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;581&quot;/&gt;&lt;/p&gt;&lt;h4&gt;高水位更新机制&lt;/h4&gt;&lt;p&gt;Kafka 所有副本都有对应的高水位和 LEO 值，在 Leader 副本所在的 Broker 上，还保存了其他 Follower 副本的 LEO 值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;leader副本更新HW和LEO流程&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;处理生产者请求的逻辑如下：&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;获取 Leader 副本所在 Broker 端保存的所有远程副本 LEO 值{LEO-1，LEO-2，……，LEO-n}。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;获取 Leader 副本高水位值：currentHW。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;更新 currentHW = min(currentHW, LEO-1，LEO-2，……，LEO-n)。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;写入消息到本地磁盘。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;更新分区高水位值。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;处理 Follower 副本拉取消息的逻辑如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;读取磁盘（或页缓存）中的消息数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用 Follower 副本发送请求中的位移值更新远程副本 LEO 值。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;更新分区高水位值（具体步骤与处理生产者请求的步骤相同）&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Follower 副本更新HW和LEO流程&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从 Leader 拉取消息的处理逻辑如下：&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;获取 Leader 发送的高水位值：currentHW。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;获取步骤 2 中更新过的 LEO 值：currentLEO。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;更新高水位为 min(currentHW, currentLEO)。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;写入消息到本地磁盘。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;更新 LEO 值。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;更新高水位值。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;副本同步机制&lt;/h4&gt;&lt;p&gt;当生产者发送一条消息时，Leader 和 Follower 副本对应的高水位是怎么被更新的。&lt;/p&gt;&lt;p&gt;初始初始状态时，所有值都是 0。当生产者给主题分区发送一条消息后，状态变更为：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3376932223543401&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibHuFZF4xzw8DqKgiaSSMQybtOQoQ3Y8HIy5uvdia0VicpvTdGsYicicH2QqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;841&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3547619047619048&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibVXxiaACqzc5Plvbg1Zz4Vv4aWnlr0MUdoNgl2xSKAKfMgdiaV2pCYAvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;840&quot;/&gt;&lt;/p&gt;&lt;p&gt;此时，Leader 副本成功将消息写入了本地磁盘，故 LEO 值被更新为 1。&lt;/p&gt;&lt;p&gt;Follower 再次尝试从 Leader 拉取消息，拉取到消息，Follower 副本也成功地更新 LEO 为 1。&lt;/p&gt;&lt;p&gt;Leader 和 Follower 副本的 LEO 都是 1，但各自的高水位依然是 0，还没有被更新。&lt;strong&gt;它们需要在下一轮的拉取中被更新&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5209790209790209&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibYskzicWfc1RtBiaAraJESkjnaibbqN4Z2Hg6pVqamGqdgicBiaWpwxgzRtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;858&quot;/&gt;&lt;/p&gt;&lt;p&gt;在新一轮的拉取请求中，Follower 副本这次请求拉取的是位移值 =1 的消息。Leader 副本接收到此请求后，更新远程副本 LEO 为 1，然后更新 Leader 高水位为 1。做完这些之后，它会将当前已更新过的高水位值 1 发送给 Follower 副本。Follower 副本接收到以后，也将自己的高水位值更新成 1。至此，一次完整的消息同步周期就结束了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Leader Epoch&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Leader 副本高水位更新和 Follower 副本高水位更新在时间上是存在错配的。这种错配是很多“数据丢失”或“数据不一致”问题的根源。0.11 版本正式引入了 Leader Epoch，来规避因高水位更新错配导致的各种不一致问题。&lt;/p&gt;&lt;p&gt;Leader Epoch由两部分数据组成:&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Epoch。一个单调增加的版本号。每当副本领导权发生变更时，都会增加该版本号。小版本号的 Leader 被认为是过期 Leader，不能再行使 Leader 权力。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;起始位移（Start Offset）。Leader 副本在该 Epoch 值上写入的首条消息的位移。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;pre&gt;&lt;code&gt;0 0&lt;br/&gt;1 120&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Kafka Broker 会在内存中为每个分区都缓存 Leader Epoch 数据，同时它还会定期地将这些信息持久化到一个 checkpoint 文件中&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;leader epoch 具体的工作机制如下：&lt;/p&gt;&lt;p&gt;1.当副本成为 leader 时：&lt;/p&gt;&lt;p&gt;这时，如果此时生产者有新消息发送过来，会首先新的 leader epoch 以及 LEO 添加到 leader-epoch-checkpoint 文件中。&lt;/p&gt;&lt;p&gt;2.当副本变成 follower 时：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;发送 LeaderEpochRequest 请求给 leader 副本，该请求包括了 follower 中最新的 epoch 版本；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;leader 返回给 follower 的相应中包含了一个 LastOffset，如果 follower last epoch = leader last epoch，则 LastOffset = leader LEO，否则取大于 follower last epoch 中最小的 leader epoch 的 start offset 值，举个例子：假设 follower last epoch = 1，此时 leader 有 (1, 20) (2, 80) (3, 120)，则 LastOffset = 80；&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;follower 拿到 LastOffset 之后，会对比当前 LEO 值是否大于 LastOffset，如果当前 LEO 大于 LastOffset，则从 LastOffset 截断日志；&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;follower 开始发送 fetch 请求给 leader 保持消息同步。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;数据丢失场景&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibO5OcCKJCwpfM9PHluEkhctyYib5N8I1O6gKlW4Sg3Gl10b20dpxg6BQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.9064814814814814&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;开始时，副本 A 和副本 B 都处于正常状态，A 是 Leader 副本。某个使用了默认 acks 设置的生产者程序向 A 发送了两条消息，A 全部写入成功，此时 Kafka 会通知生产者说两条消息全部发送成功。&lt;/p&gt;&lt;p&gt;现在我们假设 Leader 和 Follower 都写入了这两条消息，而且 Leader 副本的高水位也已经更新了，但 Follower 副本高水位还未更新——这是可能出现的。还记得吧，Follower 端高水位的更新与 Leader 端有时间错配。倘若此时副本 B 所在的 Broker 宕机，当它重启回来后，副本 B 会执行日志截断操作，将 LEO 值调整为之前的高水位值，也就是 1。这就是说，位移值为 1 的那条消息被副本 B 从磁盘中删除，此时副本 B 的底层磁盘文件中只保存有 1 条消息，即位移值为 0 的那条消息。&lt;/p&gt;&lt;p&gt;当执行完截断操作后，副本 B 开始从 A 拉取消息，执行正常的消息同步。如果就在这个节骨眼上，副本 A 所在的 Broker 宕机了，那么 Kafka 就别无选择，只能让副本 B 成为新的 Leader，此时，当 A 回来后，需要执行相同的日志截断操作，即将高水位调整为与 B 相同的值，也就是 1。这样操作之后，位移值为 1 的那条消息就从这两个副本中被永远地抹掉了。这就是这张图要展示的数据丢失场景。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Leader Epoch 如何规避这种数据丢失&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6602150537634408&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibzRNc1fgDibZh5kJmyaUgDZnKGSWJtOb64maTS6p4yZZYYeeJRvFibEicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1860&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;引用 Leader Epoch 机制后，Follower 副本 B 重启回来后，需要向 A 发送一个特殊的请求去获取 Leader 的 LEO 值。在这个例子中，该值为 2。当获知到 Leader LEO=2 后，B 发现该 LEO 值不比它自己的 LEO 值小，而且缓存中也没有保存任何起始位移值 &amp;gt; 2 的 Epoch 条目，因此 B 无需执行任何日志截断操作。这是对高水位机制的一个明显改进，即副本是否执行日志截断不再依赖于高水位进行判断。&lt;/p&gt;&lt;p&gt;现在，副本 A 宕机了，B 成为 Leader。同样地，当 A 重启回来后，执行与 B 相同的逻辑判断，发现也不用执行日志截断，至此位移值为 1 的那条消息在两个副本中均得到保留。后面当生产者程序向 B 写入新消息时，副本 B 所在的 Broker 缓存中，会生成新的 Leader Epoch 条目：[Epoch=1, Offset=2]。之后，副本 B 会使用这个条目帮助判断后续是否执行日志截断操作。这样，通过 Leader Epoch 机制，Kafka 完美地规避了这种数据丢失场景。&lt;/p&gt;&lt;h2&gt;6.Producer&lt;/h2&gt;&lt;h3&gt;生产者消息分区机制&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6418269230769231&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibdMBQ983ymwzBAJJaxTQHyW1txkddpO1cLOhq164FCkyEq4RbibeUZIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;416&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;分区的作用就是提供负载均衡的能力，或者为了实现系统的高伸缩性（Scalability）&lt;/p&gt;&lt;p&gt;每个节点的机器都能独立地执行各自分区的读写请求处理；还可以通过添加新的节点机器来增加整体系统的吞吐量&lt;/p&gt;&lt;p&gt;&lt;strong&gt;分区策略是决定生产者将消息发送到哪个分区的算法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.39766702014846234&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibzMNicAYh5WHgqHK2D9OuQAicMVS5at7kCfXmAsS0uEevPoKf0tWb3okQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;943&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.39766702014846234&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibibyF6fkpv5iaEDjWA1kGAjwQnbVVy4DxgN3YxwcR2WGjia527KY4Huryw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;943&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.39766702014846234&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nmLlmKr3AjLSoLq5xb5rPtibicyzvNT0GaHm9rBx2xVUmBo3PCkACY6XRGcXGp7VzYyNjkgZFvO0Rug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;943&quot;/&gt;&lt;/p&gt;&lt;h2&gt;7.无消息丢失如何配置&lt;/h2&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。记住，一定要使用带有回调通知的 send 方法。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;设置 acks = all。acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义。如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;设置 retries 为一个较大的值。这里的 retries 同样是 Producer 的参数，对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &amp;gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;设置 unclean.leader.election.enable = false。这是 Broker 端的参数，它控制的是哪些 Broker 有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;设置 replication.factor &amp;gt;= 3。这也是 Broker 端的参数。其实这里想表述的是，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;设置 min.insync.replicas &amp;gt; 1。这依然是 Broker 端参数，控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;确保 replication.factor &amp;gt; min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 replication.factor = min.insync.replicas + 1。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;确保消息消费完成再提交。Consumer 端有个参数 enable.auto.commit，最好把它设置成 false，并采用手动提交位移的方式。就像前面说的，这对于单 Consumer 多线程处理的场景而言是至关重要的。&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;8.参考链接&lt;/h2&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt;kafka documentation:https:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;1.&lt;/span&gt;The Log: What every software engineer should know about &lt;span class=&quot;code-snippet__built_in&quot;&gt;real&lt;/span&gt;-time data’s unifying abstraction ：https:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;https:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;2.&lt;/span&gt;分布式发布订阅消息系统 Kafka 架构设计 ：https:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;3.&lt;/span&gt;消息中间件部署及比较：https:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;4.&lt;/span&gt;零拷贝&lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt;张图：https:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;5.&lt;/span&gt;消息队列漫谈：https:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;6.&lt;/span&gt;深入浅出kafka设计：https:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;7.&lt;/span&gt;Kafka是个奇葩: https:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;8.&lt;/span&gt;kafka文件存储机制那些事：https:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;9.l&lt;/span&gt;inux中的pagecache和buffercache：https:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;10.&lt;/span&gt;Kafka之数据存储：https:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;11.&lt;/span&gt;消息中间件—Kafka数据存储：https:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;12.&lt;/span&gt;深入理解 Kafka 副本机制：https:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;13.&lt;/span&gt;Kafka ISR 副本同步机制: https:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;14.&lt;/span&gt;Kafka副本同步机制：https:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;15.&lt;/span&gt;极客-kafka核心技术与实战&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;16.&lt;/span&gt;《Kafka权威指南》&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;17.&lt;/span&gt;《Apache kafka 实战》&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>