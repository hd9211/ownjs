<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>38218c2e5d03bf32839f8fd37202bce5</guid>
<title>高吞吐、低延迟 Java 应用的 GC 优化实践</title>
<link>https://toutiao.io/k/92nisj7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;src-views-article-detail-main-module__content--2qOBd markdown-body&quot;&gt;&lt;p&gt;“以下信息节选自涤生的翻译内容”&lt;/p&gt;
&lt;p&gt;本篇原文作者是 LinkedIn 的 Swapnil Ghike，这篇文章讲述了 LinkedIn 的 Feed 产品的 GC 优化过程，虽然文章写作于 April 8, 2014，但其中的很多内容和知识点非常有学习和参考意义。&lt;/p&gt;
&lt;h1&gt;背景&lt;/h1&gt;
&lt;p&gt;高性能应用构成了现代网络的支柱。LinkedIn 内部有许多高吞吐量服务来满足每秒成千上万的用户请求。为了获得最佳的用户体验，以低延迟响应这些请求是非常重要的。&lt;/p&gt;
&lt;p&gt;例如，我们的用户经常使用的产品是 Feed —— 它是一个不断更新的专业活动和内容的列表。Feed 在 LinkedIn 的系统中随处可见，包括公司页面、学校页面以及最重要的主页资讯信息。基础 Feed 数据平台为我们的经济图谱（会员、公司、群组等）中各种实体的更新建立索引，它必须高吞吐低延迟地实现相关的更新。如下图，LinkedIn Feeds 信息展示：&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/233863&quot; alt=&quot;5.jpg&quot;/&gt;&lt;br/&gt;
为了将这些高吞吐量、低延迟类型的 Java 应用程序用于生产，开发人员必须确保在应用程序开发周期的每个阶段都保持一致的性能。确定最佳垃圾收集（Garbage Collection, GC）配置对于实现这些指标至关重要。&lt;/p&gt;
&lt;p&gt;这篇博文将通过一系列步骤来明确需求并优化 GC，它的目标读者是对使用系统方法进行 GC 优化来实现应用的高吞吐低延迟目标感兴趣的开发人员。在 LinkedIn 构建下一代 Feed 数据平台的过程中，我们总结了该方法。这些方法包括但不限于以下几点：并发标记清除（Concurrent Mark Sweep，CMS（参考[2]） 和 G1（参考 [3]） 垃圾回收器的 CPU 和内存开销、避免长期存活对象导致的持续 GC、优化 GC 线程任务分配提升性能，以及可预测 GC 停顿时间所需的 OS 配置。&lt;/p&gt;
&lt;h1&gt;优化 GC 的正确时机？&lt;/h1&gt;
&lt;p&gt;GC 的行为可能会因代码优化以及工作负载的变化而变化。因此，在一个已实施性能优化的接近完成的代码库上进行 GC 优化非常重要。而且在端到端的基本原型上进行初步分析也很有必要，该原型系统使用存根代码并模拟了可代表生产环境的工作负载。这样可以获取该架构延迟和吞吐量的真实边界，进而决定是否进行纵向或横向扩展。&lt;/p&gt;
&lt;p&gt;在下一代 Feed 数据平台的原型开发阶段，我们几乎实现了所有端到端的功能，并且模拟了当前生产基础设施提供的查询工作负载。这使我们在工作负载特性上有足够的多样性，可以在足够长的时间内测量应用程序性能和 GC 特征。&lt;/p&gt;
&lt;h1&gt;优化 GC 的步骤&lt;/h1&gt;
&lt;p&gt;下面是一些针对高吞吐量、低延迟需求优化 GC 的总体步骤。此外，还包括在 Feed 数据平台原型实施的具体细节。尽管我们还对 G1 垃圾收集器进行了试验，但我们发现 ParNew/CMS 具有最佳的 GC 性能。&lt;/p&gt;
&lt;h2&gt;1. 理解 GC 基础知识&lt;/h2&gt;
&lt;p&gt;由于 GC 优化需要调整大量的参数，因此理解 GC 工作机制非常重要。Oracle 的 Hotspot JVM 内存管理白皮书（参考 [4] ）是开始学习 Hotspot JVM GC 算法非常好的资料。而了解 G1 垃圾回收器的理论知识，可以参阅（参考 [3]）。&lt;/p&gt;
&lt;h2&gt;2. 仔细考量 GC 需求&lt;/h2&gt;
&lt;p&gt;为了降低对应用程序性能的开销，可以优化 GC 的一些特征。像吞吐量和延迟一样，这些 GC 特征应该在长时间运行的测试中观察到，以确保应用程序能够在经历多个 GC 周期中处理流量的变化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stop-the-world 回收器回收垃圾时会暂停应用线程。停顿的时长和频率不应该对应用遵守 SLA 产生不利的影响。&lt;/li&gt;
&lt;li&gt;并发 GC 算法与应用线程竞争 CPU 周期。这个开销不应该影响应用吞吐量。&lt;/li&gt;
&lt;li&gt;非压缩 GC 算法会引起堆碎片化，进而导致的 Full GC 长时间 Stop-the-world，因此，堆碎片应保持在最小值。&lt;/li&gt;
&lt;li&gt;垃圾回收工作需要占用内存。某些 GC 算法具有比其他算法更高的内存占用。如果应用程序需要较大的堆空间，要确保 GC 的内存开销不能太大。&lt;/li&gt;
&lt;li&gt;要清楚地了解 GC 日志和常用的 JVM 参数，以便轻松地调整 GC 行为。因为 GC 运行随着代码复杂性增加或工作负载特性的改变而发生变化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们使用 Linux 操作系统、Hotspot Java7u51、32GB 堆内存、6GB 新生代（Young Gen）和 -XX:CMSInitiatingOccupancyFraction 值为 70（Old GC 触发时其空间占用率）开始实验。设置较大的堆内存是用来维持长期存活对象的对象缓存。一旦这个缓存生效，晋升到 Old Gen 的对象速度会显著下降。&lt;/p&gt;
&lt;p&gt;使用最初的 JVM 配置，每 3 秒发生一次 80ms 的 Young GC 停顿，超过 99.9% 的应用请求延迟 100ms（999线）。这样的 GC 效果可能适合于 SLA 对延迟要求不太严格应用。然而，我们的目标是尽可能减少应用请求的 999 线。GC 优化对于实现这一目标至关重要。&lt;/p&gt;
&lt;h2&gt;3. 理解 GC 指标&lt;/h2&gt;
&lt;p&gt;衡量应用当前情况始终是优化的先决条件。了解 GC 日志的详细细节（参考 [5]）（使用以下选项）：&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps 
-XX:+PrintTenuringDistribution -XX:+PrintGCApplicationStoppedTime
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;可以对该应用的 GC 特征有总体的把握。&lt;/p&gt;
&lt;p&gt;在 LinkedIn 的内部监控 inGraphs 和报表系统 Naarad，生成了各种有用的指标可视化图形，比如 GC 停顿时间百分比、一次停顿最大持续时间以及长时间内 GC 频率。除了 Naarad，有很多开源工具比如 gclogviewer 可以从 GC 日志创建可视化图形。在此阶段，可以确定 GC 频率和暂停持续时间是否满足应用程序满足延迟的要求。&lt;/p&gt;
&lt;h2&gt;4. 降低 GC 频率&lt;/h2&gt;
&lt;p&gt;在分代 GC 算法中，降低 GC 频率可以通过：(1) 降低对象分配/晋升率；(2) 增加各代空间的大小。&lt;/p&gt;
&lt;p&gt;在 Hotspot JVM 中，Young GC 停顿时间取决于一次垃圾回收后存活下来的对象的数量，而不是 Young Gen 自身的大小。增加 Young Gen 大小对于应用性能的影响需要仔细评估：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果更多的数据存活而且被复制到 Survivor 区域，或者每次 GC 更多的数据晋升到 Old Gen，增加 Young Gen 大小可能导致更长的 Young GC 停顿。较长的 GC 停顿可能会导致应用程序延迟增加和(或)吞吐量降低。&lt;/li&gt;
&lt;li&gt;另一方面，如果每次垃圾回收后存活对象数量不会大幅增加，停顿时间可能不会延长。在这种情况下，降低 GC 频率可能会使整个应用总体延迟降低和(或)吞吐量增加。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于大部分为短期存活对象的应用，仅仅需要控制上述的参数；对于长期存活对象的应用，就需要注意，被晋升的对象可能很长时间都不能被 Old GC 周期回收。如果 Old GC 触发阈值（Old Gen 占用率百分比）比较低，应用将陷入持续的 GC 循环中。可以通过设置高的 GC 触发阈值可避免这一问题。&lt;/p&gt;
&lt;p&gt;由于我们的应用在堆中维持了长期存活对象的较大缓存，将 Old GC 触发阈值设置为&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;-XX:CMSInitiatingOccupancyFraction=92 -XX:+UseCMSInitiatingOccupancyOnly
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;来增加触发 Old GC 的阈值。我们也试图增加 Young Gen 大小来减少 Young GC 频率，但是并没有采用，因为这增加了应用的 999 线。&lt;/p&gt;
&lt;h2&gt;5. 缩短 GC 停顿时间&lt;/h2&gt;
&lt;p&gt;减少 Young Gen 大小可以缩短 Young GC 停顿时间，因为这可能导致被复制到 Survivor 区域或者被晋升的数据更少。但是，正如前面提到的，我们要观察减少 Young Gen 大小和由此导致的 GC 频率增加对于整体应用吞吐量和延迟的影响。Young GC 停顿时间也依赖于 tenuring threshold （晋升阈值）和 Old Gen 大小（如步骤 6 所示）。&lt;/p&gt;
&lt;p&gt;在使用 CMS GC 时，应将因堆碎片或者由堆碎片导致的 Full GC 的停顿时间降低到最小。通过控制对象晋升比例和减小 -XX:CMSInitiatingOccupancyFraction 的值使 Old GC 在低阈值时触发。所有选项的细节调整和他们相关的权衡，请参考 Web Services 的 Java 垃圾回收（参考 [5] ）和 Java 垃圾回收精粹（参考 [6]）。&lt;/p&gt;
&lt;p&gt;我们观察到 Eden 区域的大部分 Young Gen 被回收，几乎没有 3-8 年龄对象在 Survivor 空间中死亡，所以我们将 tenuring threshold 从 8 降低到 2 (使用选项：-XX:MaxTenuringThreshold=2 ),以降低 Young GC 消耗在数据复制上的时间。&lt;/p&gt;
&lt;p&gt;我们还注意到 Young GC 暂停时间随着 Old Gen 占用率上升而延长。这意味着来自 Old Gen 的压力使得对象晋升花费更多的时间。为解决这个问题，将总的堆内存大小增加到 40GB，减小 -XX:CMSInitiatingOccupancyFraction 的值到 80，更快地开始 Old GC。尽管 -XX:CMSInitiatingOccupancyFraction 的值减小了，增大堆内存可以避免频繁的 Old GC。在此阶段，我们的结果是 Young GC 暂停 70ms，应用的 999 线在 80ms。&lt;/p&gt;
&lt;h2&gt;6. 优化 GC 工作线程的任务分配&lt;/h2&gt;
&lt;p&gt;为了进一步降低 Young GC 停顿时间，我们决定研究 GC 线程绑定任务的参数来进行优化。&lt;/p&gt;
&lt;p&gt;-XX:ParGCCardsPerStrideChunk 参数控制 GC 工作线程的任务粒度，可以帮助不使用补丁而获得最佳性能，这个补丁用来优化 Young GC 中的 Card table（卡表）扫描时间（参考[7]）。有趣的是，Young GC 时间随着 Old Gen 的增加而延长。将这个选项值设为 32678，Young GC 停顿时间降低到平均 50ms。此时应用的 999 线在 60ms。&lt;/p&gt;
&lt;p&gt;还有一些的参数可以将任务映射到 GC 线程，如果操作系统允许的话，-XX:+BindGCTaskThreadsToCPUs 参数可以绑定 GC 线程到个别的 CPU 核（见解释 [1]）。使用亲缘性 -XX:+UseGCTaskAffinity 参数可以将任务分配给 GC 工作线程（见解释 [2]）。然而，我们的应用并没有从这些选项带来任何好处。实际上，一些调查显示这些选项在 Linux 系统不起作用。&lt;/p&gt;
&lt;h2&gt;7. 了解 GC 的 CPU 和内存开销&lt;/h2&gt;
&lt;p&gt;并发 GC 通常会增加 CPU 使用率。虽然我们观察到 CMS 的默认设置运行良好，但是 G1 收集器的并发 GC 工作会导致 CPU 使用率的增加，显著降低了应用程序的吞吐量和延迟。与 CMS 相比，G1 还增加了内存开销。对于不受 CPU 限制的低吞吐量应用程序，GC 导致的高 CPU 使用率可能不是一个紧迫的问题。&lt;/p&gt;
&lt;p&gt;下图是 ParNew/CMS 和 G1 的 CPU 使用百分比：相对来说 CPU 使用率变化明显的节点使用 G1 参数 -XX:G1RSetUpdatingPauseTimePercent=20：&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/233872&quot; alt=&quot;6.jpg&quot;/&gt;&lt;br/&gt;
下图是 ParNew/CMS 和 G1 每秒服务的请求数：吞吐量较低的节点使用 G1 参数 -XX:G1RSetUpdatingPauseTimePercent=20&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/233885&quot; alt=&quot;7.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;8. 为 GC 优化系统内存和 I/O 管理&lt;/h2&gt;
&lt;p&gt;通常来说，GC 停顿有两种特殊情况：(1) 低 user time，高 sys time 和高 real time (2) 低 user time，低 sys time 和高 real time。这意味着基础的进程/OS设置存在问题。情况 (1) 可能意味着 JVM 页面被 Linux 窃取；情况 (2) 可能意味着 GC 线程被 Linux 用于磁盘刷新，并卡在内核中等待 I/O。在这些情况下，如何设置参数可以参考该 PPT（参考 [8]）。&lt;/p&gt;
&lt;p&gt;另外，为了避免在运行时造成性能损失，我们可以使用 JVM 选项 -XX:+AlwaysPreTouch 在应用程序启动时先访问所有分配给它的内存，让操作系统把内存真正的分配给 JVM。我们还可以将 vm.swappability 设置为0，这样操作系统就不会交换页面到 swap（除非绝对必要）。&lt;/p&gt;
&lt;p&gt;可能你会使用 mlock 将 JVM 页固定到内存中，这样操作系统就不会将它们交换出去。但是，如果系统用尽了所有的内存和交换空间，操作系统将终止一个进程来回收内存。通常情况下，Linux 内核会选择具有高驻留内存占用但运行时间不长的进程（OOM 情况下杀死进程的工作流（参考[9]）进行终止。在我们的例子中，这个进程很有可能就是我们的应用程序。优雅的降级是服务优秀的属性之一，不过服务突然终止的可能性对于可操作性来说并不好 —— 因此，我们不使用 mlock，只是通过 vm.swapability 来尽可能避免交换内存页到 swap 的惩罚。&lt;/p&gt;
&lt;p&gt;LinkedIn 动态信息数据平台的 GC 优化&lt;/p&gt;
&lt;p&gt;对于该 Feed 平台原型系统，我们使用 Hotspot JVM 的两个 GC 算法优化垃圾回收：&lt;/p&gt;
&lt;p&gt;Young GC 使用 ParNew，Old GC 使用 CMS。&lt;br/&gt;
Young Gen 和 Old Gen 使用 G1。G1 试图解决堆大小为 6GB 或更大时，暂停时间稳定且可预测在 0.5 秒以下的问题。在我们用 G1 实验过程中，尽管调整了各种参数，但没有得到像 ParNew/CMS 一样的 GC 性能或停顿时间的可预测值。我们查询了使用 G1 发生内存泄漏相关的一个 bug（见解释[3]），但还不能确定根本原因。&lt;br/&gt;
使用 ParNew/CMS，应用每三秒进行一次 40-60ms 的 Young GC 和每小时一个 CMS GC。JVM 参数如下：&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;// JVM sizing options
-server -Xms40g -Xmx40g -XX:MaxDirectMemorySize=4096m -XX:PermSize=256m -XX:MaxPermSize=256m   
// Young generation options
-XX:NewSize=6g -XX:MaxNewSize=6g -XX:+UseParNewGC -XX:MaxTenuringThreshold=2 -XX:SurvivorRatio=8 -XX:+UnlockDiagnosticVMOptions -XX:ParGCCardsPerStrideChunk=32768
// Old generation  options
-XX:+UseConcMarkSweepGC -XX:CMSParallelRemarkEnabled -XX:+ParallelRefProcEnabled -XX:+CMSClassUnloadingEnabled  -XX:CMSInitiatingOccupancyFraction=80 -XX:+UseCMSInitiatingOccupancyOnly   
// Other options
-XX:+AlwaysPreTouch -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintTenuringDistribution -XX:+PrintGCApplicationStoppedTime -XX:-OmitStackTraceInFastThrow
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;使用这些参数，对于成千上万读请求的吞吐量，我们应用程序的 999 线降低到 60ms。&lt;/p&gt;
&lt;p&gt;解释&lt;/p&gt;
&lt;p&gt;[1] -XX:+BindGCTaskThreadsToCPUs 参数似乎在Linux 系统上不起作用，因为 hotspot/src/os/linux/vm/oslinux.cpp 的 distributeprocesses 方法在 JDK7 或 JDK8 中没有实现。&lt;/p&gt;
&lt;p&gt;[2] -XX:+UseGCTaskAffinity 参数在 JDK7 和 JDK8 的所有平台似乎都不起作用，因为任务的亲缘性属性永远被设置为 sentinelworker = (uint) -1。源码见 hotspot/src/share/vm/gcimplementation/parallelScavenge/{gcTaskManager.cpp，gcTaskThread.cpp, gcTaskManager.cpp}。&lt;/p&gt;
&lt;p&gt;[3] G1 存在一些内存泄露的 bug，可能 Java7u51 没有修改。这个 bug 仅在 Java 8 修正了。&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d46ce76e16e0d9530dbed664b3bfc079</guid>
<title>[推荐] 一文理解 Java 中的 SPI 机制</title>
<link>https://toutiao.io/k/3xscqep</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2 data-source-line=&quot;1&quot;&gt;SPI机制简介&lt;/h2&gt;&lt;p data-source-line=&quot;2&quot;&gt;服务提供者接口（Service Provider Interface，简写为SPI）是JDK内置的一种服务提供发现机制。可以用来加载框架扩展和替换组件，主要是被框架的开发人员使用。在java.util.ServiceLoader的文档里有比较详细的介绍。&lt;/p&gt;&lt;p data-source-line=&quot;4&quot;&gt;系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案、xml解析模块、jdbc模块的方案等。面向对象的设计推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则：如果需要替换组建的一种实现，就需要修改框架的代码。SPI机制正是解决这个问题。&lt;/p&gt;&lt;p data-source-line=&quot;6&quot;&gt;Java中SPI机制主要思想是将装配的控制权移到程序之外，是“基于接口的编程＋策略模式＋配置文件”组合实现的动态加载机制，有点类似Spring的IOC机制。在模块化设计中这个机制尤其重要，其核心思想就是解耦。&lt;/p&gt;&lt;p data-source-line=&quot;8&quot;&gt;&lt;img data-ratio=&quot;0.3325102880658436&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7FCcQCUsqaSExkBFHia0CdTFYjzqMgxlkGkLulWnWyZc05RVNgGhXADDtUqEOHnYexXgBPtYm53oLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1215&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;10&quot;&gt;SPI的接口是Java核心库的一部分，是由引导类加载器(Bootstrap Classloader)来加载的。SPI的实现类是由系统类加载器(System ClassLoader)来加载的。&lt;/p&gt;&lt;p data-source-line=&quot;12&quot;&gt;引导类加载器在加载时是无法找到SPI的实现类的，因为双亲委派模型中规定，引导类加载器BootstrapClassloader无法委派系统类加载器AppClassLoader来加载。该如何解决此问题？&lt;/p&gt;&lt;p data-source-line=&quot;14&quot;&gt;线程上下文类加载由此诞生，它的出现也破坏了类加载器的双亲委派模型，使得程序可以进行逆向类加载。有关这部分知识在最后补充说明。&lt;/p&gt;&lt;h2 data-source-line=&quot;16&quot;&gt;应用场景&lt;/h2&gt;&lt;p data-source-line=&quot;18&quot;&gt;Java提供了很多SPI，允许第三方为这些接口提供实现。&lt;/p&gt;&lt;p data-source-line=&quot;20&quot;&gt;常见的SPI使用场景：&lt;/p&gt;&lt;ol data-source-line=&quot;21&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;JDBC加载不同类型的数据库驱动。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;日志门面接口实现类加载，SLF4J加载不同提供商的日志实现类。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Spring中大量使用了SPI。可以在spring.factories中加上我们自定义的自动配置类，事件监听器或初始化器等。&lt;br/&gt;3.1 对servlet3.0规范。&lt;br/&gt;3.2 对ServletContainerInitializer的实现。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Dubbo里面有很多个组件，每个组件在框架中都是以接口的形成抽象出来。具体的实现又分很多种，在程序执行时根据用户的配置来按需取接口的实现。如果Dubbo的某个内置实现不符合业务需求，那么只需要利用其SPI机制将新的业务实现替换掉Dubbo的实现即可。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;28&quot;&gt;这些SPI的接口是由Java核心库来提供，而SPI的实现则是作为Java应用所依赖的jar包被包含进类路径（CLASSPATH）中。例如：JDBC的实现mysql就是通过Maven被依赖进来。&lt;/p&gt;&lt;h2 data-source-line=&quot;30&quot;&gt;SPI具体约定&lt;/h2&gt;&lt;p data-source-line=&quot;32&quot;&gt;Java SPI的具体约定：当服务的提供者，提供了服务接口的某种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。基于这样一个约定就能实现服务接口与实现的解耦。&lt;/p&gt;&lt;h2 data-source-line=&quot;34&quot;&gt;Java SPI机制的缺点&lt;/h2&gt;&lt;ol data-source-line=&quot;36&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;不能按需加载，需要遍历所有的实现，并实例化，然后在循环中才能找到我们需要的实现。如果不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;多个并发多线程使用ServiceLoader类的实例是不安全的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;扩展如果依赖其他的扩展，做不到自动注入和装配。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不提供类似于Spring的IOC和AOP功能。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;扩展很难和其他的框架集成，比如扩展里面依赖了一个Spring bean，原生的Java SPI不支持。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;42&quot;&gt;针对以上的不足点，在生产环境的SPI机制选择时，可以考虑使用dubbo实现的SPI机制。感兴趣的同学可以自行查看，或等博客的后续更新。&lt;/p&gt;&lt;h3 data-source-line=&quot;44&quot;&gt;SPI实例&lt;/h3&gt;&lt;p data-source-line=&quot;46&quot;&gt;下面用一个简单的代码实例，演示SPI的使用方法。&lt;/p&gt;&lt;ol data-source-line=&quot;48&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;代码编写&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;50&quot;&gt;定义需要的接口，然后编码接口的实现类。&lt;/p&gt;&lt;p data-source-line=&quot;52&quot;&gt;&lt;img data-ratio=&quot;0.4209714726291442&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7FCcQCUsqaSExkBFHia0CdTFyTgqQkEkeJc8TfUg3qS4RPYLRQjvDunfvgkxpzoREvoaAM9rWPQeyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1297&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;54&quot;&gt;&lt;img data-ratio=&quot;0.39067854694996573&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7FCcQCUsqaSExkBFHia0CdTFJ3uGYFpY8I4bvoepPX0OmJFwE10GV7liaYCdSia7xIoWgedANTtMwv5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1459&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;56&quot;&gt;&lt;img data-ratio=&quot;0.326875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7FCcQCUsqaSExkBFHia0CdTFJUSprdkOANhHvM6GHxIyxZNbWAhGX1vzeWydHfFVJS8U7XEPniba3Rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;ol start=&quot;2&quot; data-source-line=&quot;58&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;增加配置文件&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;60&quot;&gt;在项目的\src\main\resources\下创建\META-INF\services目录，并增加一个配置文件，这个文件必须以接口的全限定类名保持一致，例如：com.xiaohui.spi.HelloService。然后在配置文件中写入具体实现类的全限定类名，如有多个则换行写入。&lt;/p&gt;&lt;p data-source-line=&quot;62&quot;&gt;&lt;img data-ratio=&quot;0.45432497978981407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7FCcQCUsqaSExkBFHia0CdTF4krriaTicibRCKZLk0CC88zAsbTeiaxwtXla2avwgPJw7KDCXK8PXplpww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1237&quot;/&gt;&lt;/p&gt;&lt;ol start=&quot;3&quot; data-source-line=&quot;64&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;使用JDK来载入&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;66&quot;&gt;使用JDK提供的ServiceLoader.load()来加载配置文件中的描述信息，完成类加载操作。&lt;/p&gt;&lt;p data-source-line=&quot;68&quot;&gt;&lt;img data-ratio=&quot;0.5680044593088072&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7FCcQCUsqaSExkBFHia0CdTFwwbTtRiaQOoH74icoe6Q0P4XE1NiaUjiaVT0Wkkcb4VawoyFMkr0UZZCdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1794&quot;/&gt;&lt;/p&gt;&lt;h2 data-source-line=&quot;70&quot;&gt;补充说明SPI加载&lt;/h2&gt;&lt;p data-source-line=&quot;72&quot;&gt;有关双亲委派的讲解，请查看博客《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyNzgyNzAwNg==&amp;amp;mid=2247483853&amp;amp;idx=1&amp;amp;sn=e3c145cde37b4e08348a10de39682089&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;Java类加载及对象创建过程详解&lt;/a&gt;》&lt;/p&gt;&lt;h3 data-source-line=&quot;74&quot;&gt;为什么需要破坏双亲委派？&lt;/h3&gt;&lt;p data-source-line=&quot;76&quot;&gt;在某些情况下父类加载器需要委托子类加载器去加载class文件。受到双亲委派加载范围的限制，父类加载器无法加载到需要的文件。&lt;/p&gt;&lt;h3 data-source-line=&quot;78&quot;&gt;如何破坏双亲委派？&lt;/h3&gt;&lt;p data-source-line=&quot;80&quot;&gt;双亲委派模型并不是一个强制性的约束模型，而是java设计者推荐给开发者的类加载器实现方式，在java项目中大部分的类加载器都遵循这个模型，但也有例外，到目前为止，双亲委派模型主要出现过三次较大规模的“被破坏”情况。&lt;/p&gt;&lt;p data-source-line=&quot;82&quot;&gt;双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2发布之前。由于双亲委派模型是在JDK1.2之后才被引入的，而类加载器和抽象类java.lang.ClassLoader则是JDK1.0时候就已经存在，面对已经存在 的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK1.2之后的java.lang.ClassLoader添加了一个新的proceted方法findClass()，在此之前，用户去继承java.lang.ClassLoader的唯一目的就是重写loadClass()方法，因为虚拟在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的loadClass()。JDK1.2之后已不再提倡用户再去覆盖loadClass()方法，应当把自己的类加载逻辑写到findClass()方法中，在loadClass()方法的逻辑里，如果父类加载器加载失败，则会调用自己的findClass()方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派模型的。&lt;/p&gt;&lt;p data-source-line=&quot;84&quot;&gt;双亲委派模型的第二次“被破坏”是这个模型自身的缺陷所导致的，双亲委派模型很好地解决了各个类加载器的基础类统一问题(越基础的类由越上层的加载器进行加载)，基础类之所以被称为“基础”，是因为它们总是作为被调用代码调用的API。但是，如果基础类又要调用用户的代码，那该怎么办呢。&lt;/p&gt;&lt;p data-source-line=&quot;86&quot;&gt;为了解决这个困境，Java设计团队只好引入了一个不太优雅的设计：线程上下文件类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。使用这个线程上下文类加载器去加载所需要的代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI,JDBC,JCE,JAXB和JBI等。&lt;/p&gt;&lt;p data-source-line=&quot;88&quot;&gt;双亲委派模型的第三次“被破坏”是由于用户对程序的动态性的追求导致的，例如OSGi的出现。在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构。&lt;/p&gt;&lt;h3 data-source-line=&quot;90&quot;&gt;破坏双亲委派的举例&lt;/h3&gt;&lt;p data-source-line=&quot;92&quot;&gt;以tomcat为例，讲解如何破坏双亲委派，属于上述讲解的第二次破坏。&lt;/p&gt;&lt;p data-source-line=&quot;94&quot;&gt;&lt;img data-ratio=&quot;1.764525993883792&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7FCcQCUsqaSExkBFHia0CdTF9iaYgpiaMZlyVbdicSaWGwycbDkCXzXTdibNLPWIRb0hjPCcFLFxkeOiaLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;327&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;96&quot;&gt;如果有10个Web应用程序都用到了spring的话，可以把Spring的jar包放到common或shared目录下让这些程序共享。Spring的作用是管理每个web应用程序的bean，getBean时自然要能访问到应用程序的类，而用户的程序是放在/WebApp/WEB-INF目录中的（由WebAppClassLoader加载），那么在CommonClassLoader或SharedClassLoader中的Spring容器如何去加载并不在其加载范围的用户程序（/WebApp/WEB-INF/）中的Class呢？&lt;/p&gt;&lt;p data-source-line=&quot;98&quot;&gt;Spring统统使用线程上下文加载器(ContextClassLoade)来加载类，无需理会被放在哪里。ContextClassLoader默认存放了WebAppClassLoader的引用，由于它是在运行时被放在了线程中，所以不管当前程序处于何处（BootstrapClassLoader或是ExtClassLoader等），在任何需要的时候都可以用Thread.currentThread().getContextClassLoader()取出应用程序类加载器来完成需要的操作。&lt;/p&gt;&lt;p data-source-line=&quot;100&quot;&gt;参考：&lt;/p&gt;&lt;ol data-source-line=&quot;101&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;《深入理解java虚拟机》&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a55495939734773c60e46d283589dd01</guid>
<title>[推荐] 10 问 10 答：你真的了解线程池吗？</title>
<link>https://toutiao.io/k/b70jpzu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naJ90Ks7UHT87Q3foSu1rY6yPJBD1gMdaU0aia43hxU7nyWttYR9LicI2SktxPascfSAAyYsfMRuNKWw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;《Java开发手册》中强调，线程资源必须通过线程池提供，而创建线程池必须使用&lt;/span&gt;&lt;span&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span&gt;。手册主要强调利用线程池避免两个问题，一是线程过渡切换，二是避免请求过多时造成OOM。但是如果参数配置错误，还是会引发上面的两个问题。所以本节我们主要是讨论&lt;/span&gt;&lt;span&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span&gt;的一些技术细节，并且给出几个常用的最佳实践建议。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我在查找资料的过程中，发现有些问题存在争议。后面发现，一部分原因是因为不同JDK版本的现实是有差异的。因此，下面的分析是基于当下最常用的版本JDK1.8，并且对于存在争议的问题，我们分析源码，源码才是最准确的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;1  corePoolSize=0会怎么样&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这是一个争议点。我发现大部分博文，不论是国内的还是国外的，都是这样回答这个问题的：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;按照上面的描述，如果corePoolSize=0，则会判断等待队列的容量，如果还有容量，则排队，并且不会创建新的线程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;—— 但其实，这是老版本的实现方式，从1.6之后，实现方式就变了。我们直接看&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;的源码（submit也依赖它），我备注出了关键一行：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;      &lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;int c = ctl.get();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (workerCountOf(c) &amp;lt; corePoolSize) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (addWorker(&lt;span class=&quot;code-snippet__built_in&quot;&gt;command&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__built_in&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            c = ctl.get();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(&lt;span class=&quot;code-snippet__built_in&quot;&gt;command&lt;/span&gt;)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            int recheck = ctl.get();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (! isRunning(recheck) &amp;amp;&amp;amp; remove(&lt;span class=&quot;code-snippet__built_in&quot;&gt;command&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                reject(&lt;span class=&quot;code-snippet__built_in&quot;&gt;command&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            // 注意这一行代码，添加到等待队列成功后，判断当前池内线程数是否为0，如果是则创建一个firstTask为null的worker，这个worker会从等待队列中获取任务并执行。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (workerCountOf(recheck) == 0)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                addWorker(null, &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!addWorker(&lt;span class=&quot;code-snippet__built_in&quot;&gt;command&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            reject(&lt;span class=&quot;code-snippet__built_in&quot;&gt;command&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;答&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上述问题需区分JDK版本。在1.6版本之后，如果&lt;/span&gt;&lt;span&gt;corePoolSize=0&lt;/span&gt;&lt;span&gt;，提交任务时如果线程池为空，则会立即创建一个线程来执行任务（先排队再获取）；如果提交任务的时候，线程池不为空，则先在等待队列中排队，只有队列满了才会创建新线程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，优化在于，在队列没有满的这段时间内，会有一个线程在消费提交的任务；1.6之前的实现是，必须等队列满了之后，才开始消费。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2  线程池创建之后，会立即创建核心线程么&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;之前有人问过我这个问题，因为他发现应用中有些Bean创建了线程池，但是这个Bean一般情况下用不到，所以咨询我是否需要把这个线程池注释掉，以减少应用运行时的线程数（该应用运行时线程过多。）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;答&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不会。从上面的源码可以看出，在刚刚创建&lt;/span&gt;&lt;span&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span&gt;的时候，线程并不会立即启动，而是要等到有任务提交时才会启动，除非调用了&lt;/span&gt;&lt;span&gt;prestartCoreThread&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;prestartAllCoreThreads&lt;/span&gt;&lt;span&gt;事先启动核心线程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3  核心线程永远不会销毁么&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个问题有点tricky。首先我们要明确一下概念，虽然在JavaDoc中也使用了“core/non-core threads”这样的描述，但其实这是一个动态的概念，JDK并没有给一部分线程打上“core”的标记，做什么特殊化的处理。这个问题我认为想要探讨的是闲置线程终结策略的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在JDK1.6之前，线程池会尽量保持&lt;/span&gt;&lt;span&gt;corePoolSize&lt;/span&gt;&lt;span&gt;个核心线程，即使这些线程闲置了很长时间。这一点曾被开发者诟病，所以从JDK1.6开始，提供了方法&lt;/span&gt;&lt;span&gt;allowsCoreThreadTimeOut&lt;/span&gt;&lt;span&gt;，如果传参为true，则允许闲置的核心线程被终止。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;请注意这种策略和&lt;/span&gt;&lt;span&gt;corePoolSize=0&lt;/span&gt;&lt;span&gt;的区别。我总结的区别是：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以&lt;/span&gt;&lt;span&gt;corePoolSize=0&lt;/span&gt;&lt;span&gt;的效果，基本等同于&lt;/span&gt;&lt;span&gt;allowsCoreThreadTimeOut=true &amp;amp;&amp;amp; corePoolSize=1&lt;/span&gt;&lt;span&gt;，但实现细节其实不同。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;答&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在JDK1.6之后，如果&lt;/span&gt;&lt;span&gt;allowsCoreThreadTimeOut=true&lt;/span&gt;&lt;span&gt;，核心线程也可以被终止。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;4  如何保证线程不被销毁&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先我们要明确一下线程池模型。线程池有个内部类&lt;/span&gt;&lt;span&gt;Worker&lt;/span&gt;&lt;span&gt;，它实现了&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;span&gt;接口，首先，它自己要run起来。然后它会在合适的时候获取我们提交的&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;span&gt;任务，然后调用&lt;/span&gt;&lt;span&gt;任务的run()&lt;/span&gt;&lt;span&gt;接口。一个&lt;/span&gt;&lt;span&gt;Worker&lt;/span&gt;&lt;span&gt;不终止的话可以不断执行任务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们前面说的“线程池中的线程”，其实就是&lt;/span&gt;&lt;span&gt;Worker&lt;/span&gt;&lt;span&gt;；等待队列中的元素，是我们提交的&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;span&gt;任务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;每一个&lt;/span&gt;&lt;span&gt;Worker&lt;/span&gt;&lt;span&gt;在创建出来的时候，会调用它本身的&lt;/span&gt;&lt;span&gt;run()&lt;/span&gt;&lt;span&gt;方法，实现是&lt;/span&gt;&lt;span&gt;runWorker(this)&lt;/span&gt;&lt;span&gt;，这个实现的核心是一个&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;循环，这个循环不结束，&lt;/span&gt;&lt;span&gt;Worker&lt;/span&gt;&lt;span&gt;线程就不会终止，就是这个基本逻辑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;final &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;runWorker&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Worker w&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Thread wt = Thread.currentThread();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Runnable task = w.firstTask;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        w.firstTask = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        w.unlock(); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        boolean completedAbruptly = &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (task != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; || (task = getTask()) != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                w.&lt;span class=&quot;code-snippet__keyword&quot;&gt;lock&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; ((runStateAtLeast(ctl.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(), STOP) ||&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                     (Thread.interrupted() &amp;amp;&amp;amp;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                      runStateAtLeast(ctl.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(), STOP))) &amp;amp;&amp;amp;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    !wt.isInterrupted())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    wt.interrupt();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    beforeExecute(wt, task);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    Throwable thrown = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        task.run();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (RuntimeException x) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        thrown = x; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; x;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Error x) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        thrown = x; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; x;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Throwable x) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        thrown = x; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Error(x);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        afterExecute(task, thrown);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    task = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    w.completedTasks++;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    w.unlock();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            completedAbruptly = &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            processWorkerExit(w, completedAbruptly);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; Runnable &lt;span class=&quot;code-snippet__title&quot;&gt;getTask&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; timedOut = &lt;span class=&quot;code-snippet__keyword&quot;&gt;false&lt;/span&gt;; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (;;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; c = ctl.get();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; rs = runStateOf(c);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; (rs &amp;gt;= STOP || workQueue.isEmpty())) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                decrementWorkerCount();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; wc = workerCountOf(c);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; timed = allowCoreThreadTimeOut || wc &amp;gt; corePoolSize;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; ((wc &amp;gt; maximumPoolSize || (timed &amp;amp;&amp;amp; timedOut))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &amp;amp;&amp;amp; (wc &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; || workQueue.isEmpty())) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (compareAndDecrementWorkerCount(c))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                Runnable r = timed ?&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    workQueue.take();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (r != &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; r;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                timedOut = &lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException retry) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                timedOut = &lt;span class=&quot;code-snippet__keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;答&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;实现方式非常巧妙，核心线程（Worker）即使一直空闲也不终止，是通过&lt;/span&gt;&lt;span&gt;workQueue.take()&lt;/span&gt;&lt;span&gt;实现的，它会一直阻塞到从等待队列中取到新的任务。非核心线程空闲指定时间后终止是通过&lt;/span&gt;&lt;span&gt;workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)&lt;/span&gt;&lt;span&gt;实现的，一个空闲的&lt;/span&gt;&lt;span&gt;Worker&lt;/span&gt;&lt;span&gt;只等待&lt;/span&gt;&lt;span&gt;keepAliveTime&lt;/span&gt;&lt;span&gt;，如果还没有取到任务则循环终止，线程也就运行结束了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;引申思考&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;Worker&lt;/span&gt;&lt;span&gt;本身就是个线程，它再调用我们传入的&lt;/span&gt;&lt;span&gt;Runnable.run()&lt;/span&gt;&lt;span&gt;，会启动一个子线程么？如果你还没有答案，再回想一下&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;的关系。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;5  空闲线程过多会有什么问题&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;笼统地回答是会占用内存，我们分析一下占用了哪些内存。首先，比较普通的一部分，一个线程的内存模型：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我想额外强调是下面这几个内存占用，需要小心：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;答&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;6  keepAliveTime=0会怎么样&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这也是个争议点。有的博文说等于0表示空闲线程永远不会终止，有的说表示执行完立刻终止。还有的说等于-1表示空闲线程永远不会终止。其实稍微看一下源码知道了，这里我直接抛出答案。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;答&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在JDK1.8中，&lt;/span&gt;&lt;span&gt;keepAliveTime=0&lt;/span&gt;&lt;span&gt;表示非核心线程执行完立刻终止。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;默认情况下，&lt;/span&gt;&lt;span&gt;keepAliveTime&lt;/span&gt;&lt;span&gt;小于0，初始化的时候才会报错；但如果&lt;/span&gt;&lt;span&gt;allowsCoreThreadTimeOut&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;keepAliveTime&lt;/span&gt;&lt;span&gt;必须大于0，不然初始化报错。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;7  怎么进行异常处理&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;很多代码的写法，我们都习惯按照常见范式去编写，而没有去思考为什么。比如：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;—— 但是在上面，我提到过，&lt;/span&gt;&lt;span&gt;submit()&lt;/span&gt;&lt;span&gt;底层实现依赖&lt;/span&gt;&lt;span&gt;execute()&lt;/span&gt;&lt;span&gt;，两者应该统一呀，为什么有差异呢？下面再扒一扒&lt;/span&gt;&lt;span&gt;submit()&lt;/span&gt;&lt;span&gt;的源码，它的实现蛮有意思。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先，&lt;/span&gt;&lt;span&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span&gt;中没有&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;的代码，而是在它的父类&lt;/span&gt;&lt;span&gt;AbstractExecutorService&lt;/span&gt;&lt;span&gt;中，有三个&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;的重载方法，代码非常简单，关键代码就两行：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; Future&amp;lt;?&amp;gt; submit(Runnable task) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (task == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; NullPointerException();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        RunnableFuture&amp;lt;Void&amp;gt; ftask = newTaskFor(task, &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        execute(ftask);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; ftask;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=&quot;code-snippet__function&quot;&gt;Future&amp;lt;T&amp;gt; &lt;span class=&quot;code-snippet__title&quot;&gt;submit&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Runnable task, T result&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (task == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; NullPointerException();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task, result);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        execute(ftask);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; ftask;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=&quot;code-snippet__function&quot;&gt;Future&amp;lt;T&amp;gt; &lt;span class=&quot;code-snippet__title&quot;&gt;submit&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Callable&amp;lt;T&amp;gt; task&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (task == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; NullPointerException();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        execute(ftask);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; ftask;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;正是因为这三个重载方法，都调用了&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;，所以我才说&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;底层依赖&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;。通过查看这里&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;的实现，我们不难发现，它就是&lt;/span&gt;&lt;span&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span&gt;中的实现，所以，造成&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;的差异化的代码，不在这。那么造成差异的一定在&lt;/span&gt;&lt;span&gt;newTaskFor&lt;/span&gt;&lt;span&gt;方法中。这个方法也就&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;了一个&lt;/span&gt;&lt;span&gt;FutureTask&lt;/span&gt;&lt;span&gt;而已，&lt;/span&gt;&lt;span&gt;FutureTask&lt;/span&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span&gt;RunnableFuture&lt;/span&gt;&lt;span&gt;接口，&lt;/span&gt;&lt;span&gt;RunnableFuture&lt;/span&gt;&lt;span&gt;接口继承&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;span&gt;接口和&lt;/span&gt;&lt;span&gt;Future&lt;/span&gt;&lt;span&gt;接口。而&lt;/span&gt;&lt;span&gt;Callable&lt;/span&gt;&lt;span&gt;只是&lt;/span&gt;&lt;span&gt;FutureTask&lt;/span&gt;&lt;span&gt;的一个成员变量。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以讲到这里，就有另一个Java基础知识点：&lt;/span&gt;&lt;span&gt;Callable&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Future&lt;/span&gt;&lt;span&gt;的关系。我们一般用&lt;/span&gt;&lt;span&gt;Callable&lt;/span&gt;&lt;span&gt;编写任务代码，&lt;/span&gt;&lt;span&gt;Future&lt;/span&gt;&lt;span&gt;是异步返回对象，通过它的&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;方法，阻塞式地获取结果。&lt;/span&gt;&lt;span&gt;FutureTask&lt;/span&gt;&lt;span&gt;的核心代码就是实现了&lt;/span&gt;&lt;span&gt;Future&lt;/span&gt;&lt;span&gt;接口，也就是&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;方法的实现：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; V &lt;span class=&quot;code-snippet__title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; InterruptedException, ExecutionException &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; s = state;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (s &amp;lt;= COMPLETING)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            s = awaitDone(&lt;span class=&quot;code-snippet__keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0L&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; report(s);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;awaitDone&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; timed, &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; nanos)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; deadline = timed ? System.nanoTime() + nanos : &lt;span class=&quot;code-snippet__number&quot;&gt;0L&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        WaitNode q = &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; queued = &lt;span class=&quot;code-snippet__keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (;;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (Thread.interrupted()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                removeWaiter(q);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; InterruptedException();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; s = state;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (s &amp;gt; COMPLETING) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (q != &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    q.thread = &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; s;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (s == COMPLETING) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                Thread.yield();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (q == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                q = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; WaitNode();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!queued)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                queued = UNSAFE.compareAndSwapObject(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;, waitersOffset,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                                     q.next = waiters, q);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timed) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                nanos = deadline - System.nanoTime();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (nanos &amp;lt;= &lt;span class=&quot;code-snippet__number&quot;&gt;0L&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    removeWaiter(q);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; state;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                LockSupport.parkNanos(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;, nanos);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                LockSupport.park(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;的核心实现是有个&lt;/span&gt;&lt;span&gt;awaitDone&lt;/span&gt;&lt;span&gt;方法，这是一个死循环，只有任务的状态是“已完成”，才会跳出死循环；否则会依赖UNSAFE包下的&lt;/span&gt;&lt;span&gt;LockSupport.park&lt;/span&gt;&lt;span&gt;原语进行阻塞，等待&lt;/span&gt;&lt;span&gt;LockSupport.unpark&lt;/span&gt;&lt;span&gt;信号量。而这个信号量只有当运行结束获得结果、或者出现异常的情况下，才会发出来。分别对应方法&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;setException&lt;/span&gt;&lt;span&gt;。这就是异步执行、阻塞获取的原理，扯得有点远了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;回到最初我们的疑问，为什么&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;之后，通过&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;方法可以获取到异常？原因是&lt;/span&gt;&lt;span&gt;FutureTask&lt;/span&gt;&lt;span&gt;有一个&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;类型的&lt;/span&gt;&lt;span&gt;outcome&lt;/span&gt;&lt;span&gt;成员变量，用来记录执行结果。这个结果可以是传入的泛型，也可以是&lt;/span&gt;&lt;span&gt;Throwable&lt;/span&gt;&lt;span&gt;异常：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (state != NEW ||&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            !UNSAFE.compareAndSwapObject(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;, runnerOffset,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                         &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;, Thread.currentThread()))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Callable&amp;lt;V&amp;gt; c = callable;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (c != &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; state == NEW) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                V result;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; ran;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    result = c.call();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    ran = &lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Throwable ex) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    result = &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    ran = &lt;span class=&quot;code-snippet__keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    setException(ex);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (ran)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    set(result);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            runner = &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; s = state;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (s &amp;gt;= INTERRUPTING)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                handlePossibleCancellationInterrupt(s);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; V &lt;span class=&quot;code-snippet__title&quot;&gt;report&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; s)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; ExecutionException &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Object x = outcome;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (s == NORMAL)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; (V)x;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (s &amp;gt;= CANCELLED)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; CancellationException();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ExecutionException((Throwable)x);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;FutureTask&lt;/span&gt;&lt;span&gt;的另一个巧妙的地方就是借用&lt;/span&gt;&lt;span&gt;RunnableAdapter&lt;/span&gt;&lt;span&gt;内部类，将&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;span&gt;封装成&lt;/span&gt;&lt;span&gt;Callable&lt;/span&gt;&lt;span&gt;。所以就算你&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;的是&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;span&gt;，一样可以用&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;获取到异常。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;答&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;8  线程池需不需要关闭&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;答&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一般来讲，线程池的生命周期跟随服务的生命周期。如果一个服务（Service）停止服务了，那么需要调用&lt;/span&gt;&lt;span&gt;shutdown&lt;/span&gt;&lt;span&gt;方法进行关闭。所以&lt;/span&gt;&lt;span&gt;ExecutorService.shutdown&lt;/span&gt;&lt;span&gt;在Java以及一些中间件的源码中，是封装在Service的&lt;/span&gt;&lt;span&gt;shutdown&lt;/span&gt;&lt;span&gt;方法内的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果是Server端不重启就不停止提供服务，我认为是不需要特殊处理的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;9  shutdown和shutdownNow的区别&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;答&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本来想分析一下两者的源码的，但是发现本文的篇幅已经过长了，源码也贴了不少。感兴趣的朋友自己看一下即可。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;10  Spring中有哪些和ThreadPoolExecutor类似的工具&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;答&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Simp&lt;/span&gt;&lt;span&gt;leAsyncTaskExecutor&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;每次请求新开线程，没有最大线程数设置.不是真的线程池，这个类不重用线程，每次调用都会&lt;/span&gt;&lt;span&gt;创建一个新的线程。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;SyncTaskExecutor&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;不是异步的线程&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;同步可以用SyncTaskExecutor，但这个可以说不算一个线程池，因为还在原线程执行。这个类没有实现异步调用，只是一个同步操作。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;ConcurrentTaskExecutor&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span/&gt;&lt;span&gt;Executor的适配类，不推荐使用。如果ThreadPoolTaskExecutor不满足要求时，才用考虑使用这个类。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;SimpleThreadPoolTaskExecutor&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span/&gt;&lt;span&gt;监听Spring’s lifecycle callbacks，并且可以和Quartz的Component兼容.是Quartz的SimpleThreadPool的类。线程池同时被quartz和非quartz使用，才需要使用此类。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里我想着重强调的就是&lt;/span&gt;&lt;span&gt;SimpleAsyncTaskExecutor&lt;/span&gt;&lt;span&gt;，Spring中使用的&lt;/span&gt;&lt;span&gt;@Async&lt;/span&gt;&lt;span&gt;注解，底层就是基于&lt;/span&gt;&lt;span&gt;SimpleAsyncTaskExecutor&lt;/span&gt;&lt;span&gt;去执行任务，只不过它不是线程池，而是每次都新开一个线程。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外想要强调的是&lt;/span&gt;&lt;span&gt;Executor&lt;/span&gt;&lt;span&gt;接口。Java初学者容易想当然的以为&lt;/span&gt;&lt;span&gt;Executor&lt;/span&gt;&lt;span&gt;结尾的类就是一个线程池，而上面的都是反例。我们可以在JDK的&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;方法上看到这个注释：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，它的职责并不是提供一个线程池的接口，而是提供一个“将来执行命令”的接口。真正能代表线程池意义的，是&lt;/span&gt;&lt;span&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span&gt;类，而不是&lt;/span&gt;&lt;span&gt;Executor&lt;/span&gt;&lt;span&gt;接口。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;最佳实践总结&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4448742746615087&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ90Ks7UHT87Q3foSu1rY6y8e4XGCibgibia2R8iaYGogDHTAEVwb3O9eOUBuWMRhyL2iaNbx5ZvzplIbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1034&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;线程池初始化示例：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; ThreadPoolExecutor pool;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ThreadFactory threadFactory = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ThreadFactoryBuilder().setNameFormat(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;po-detail-pool-%d&quot;&lt;/span&gt;).build();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        pool = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;60L&lt;/span&gt;, TimeUnit.MILLISECONDS, &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;512&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            threadFactory, &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor.AbortPolicy());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        pool.allowCoreThreadTimeOut(&lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;免费领取&lt;strong&gt;&lt;span&gt;电子书&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;《Spring Boot 2.5开发实战》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本书包含了Spring Boot 2.5新特性、自动化配置原理、REST API开发、MySQL、Redis高并发缓存、MongoDB、MQ消息队列、安全机制、 性能监控等核心知识点，带你上手实战！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;扫码加阿里妹好友，回复“Spring Boot 2.5开发实战”获取吧~&lt;span&gt;(若扫码无效，可通过微信号alimei4、alimei5、alimei6、alimei7直接添加)&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;275&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naL8IbUFicUtMrdMwwUmawhUkKhoPB9Fbjo3NqH9WyXCqKMtyWpRX0Iaewf6NeGkIxB8ALgJYIyHO9Q/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ff7d90bd9ecb4c4323f6cea3e0de1049</guid>
<title>[推荐] 搜狗面试题：IO 多路复用之 select、poll、epoll 的区别</title>
<link>https://toutiao.io/k/d6e55fr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section data-support=&quot;96编辑器&quot; data-style-id=&quot;26075&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-form=&quot;0&quot; data-num=&quot;1&quot;&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;select&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;int select (int n, fd_set *readfds, fd_set *writefds, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                   fd_set *exceptfds, struct timeval *timeout);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// fd_set 结构体简化为：&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;typedef struct{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    long int fds_bits[32];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}fd_set;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、 单个进程可监视的&lt;/span&gt;&lt;span&gt;fd数量被限制&lt;/span&gt;&lt;span&gt;，即能监听端口的大小有限。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、 对socket进行扫描时是&lt;/span&gt;&lt;span&gt;线性扫描&lt;/span&gt;&lt;span&gt;，即采用轮询的方法，效率较低：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、需要维护一个用来存放大量fd的数据结构，每次调用select时把fd集合从&lt;/span&gt;&lt;span&gt;用户态拷贝到内核态&lt;/span&gt;&lt;span&gt;，这样会使得&lt;/span&gt;&lt;span&gt;用户空间和内核空间&lt;/span&gt;&lt;span&gt;在传递该结构时复制&lt;/span&gt;&lt;span&gt;开销大&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-support=&quot;96编辑器&quot; data-style-id=&quot;26075&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-form=&quot;0&quot; data-num=&quot;2&quot;&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;poll&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;int poll (struct pollfd *fds, unsigned int nfds, int timeout);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;struct pollfd {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    int fd; /* file descriptor */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    short events; /* requested events to watch */ // 请求监视的事件&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    short revents; /* returned events witnessed */ // 返回发生的事件&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;和select没有区别，它将用户传入的&lt;/span&gt;&lt;span&gt;数组拷贝到内核空间&lt;/span&gt;&lt;span&gt;，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次&lt;/span&gt;&lt;span&gt;无谓的遍历&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;它没有最大连接数的限制，原因是它是基于&lt;/span&gt;&lt;span&gt;链表&lt;/span&gt;&lt;span&gt;来存储的。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;1、大量的fd的数组被整体复制于&lt;/span&gt;&lt;span&gt;用户态和内核&lt;/span&gt;&lt;span&gt;地址空间之间，而不管这样的复制是不是有意义。                   &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、poll还有一个特点是“&lt;/span&gt;&lt;span&gt;水平触发&lt;/span&gt;&lt;span&gt;”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;LT模式&lt;/span&gt;：level trigger。当epoll_wait检测到描述符事件发生并将此事件通知应用程序，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;ET模式&lt;/span&gt;：edge trigger。当epoll_wait检测到描述符事件发生并将此事件通知应用程序，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。&lt;/span&gt;&lt;/p&gt;&lt;section data-support=&quot;96编辑器&quot; data-style-id=&quot;26075&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-form=&quot;0&quot; data-num=&quot;3&quot;&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;epoll&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;int epoll_create(int size)；&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;epoll_create&lt;/span&gt;：创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;epoll_ctl&lt;/span&gt;：对指定描述符fd执行op操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;-epfd：是epoll_create()的返回值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;-op操作：对应宏：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD，对应添加、删除和修改对fd的监听事件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- fd：是需要监听的fd（文件描述符）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- epoll_event：是告诉内核需要监听什么事件（读、写事件等）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;epoll_wait&lt;/span&gt;：等待epfd上的io事件，最多返回maxevents个事件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;-events：用来从内核得到事件的集合，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;-maxevents：告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;-timeout：是超时时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;epoll有EPOLLLT和EPOLLET两种触发模式，LT是默认的模式，ET是“高速”模式。LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作，而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值，或者遇到EAGAIN错误。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;epoll为什么要有EPOLLET触发模式？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如果采用EPOLLLT模式的话，系统中一旦有大量你不需要读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率.。而采用EPOLLET这种边沿触发模式的话，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！&lt;strong&gt;这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;epoll优点&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;1、&lt;span&gt;没有最大并发连接的限制&lt;/span&gt;，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;span&gt;效率提升&lt;/span&gt;，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、 &lt;span&gt;内存拷贝&lt;/span&gt;，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。&lt;/span&gt;&lt;/p&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1620212822188&quot; data-category_id_list=&quot;1|11|16|17|22|24|26|27|28|29|3|31|32|35|36|37|39|41|42|43|45|46|47|48|49|5|50|51|52|53|54|55|6|7|8&quot; data-id=&quot;1620212822188&quot;/&gt;&lt;section data-support=&quot;96编辑器&quot; data-style-id=&quot;26075&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-form=&quot;0&quot; data-num=&quot;3&quot;&gt;04&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;区别&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;0、底层数据结构&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;select：数组，poll：链表，epoll：红黑树。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;1、支持一个进程所能打开的最大连接数&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;select 单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32*32，同理64位机器上FD_SETSIZE为32*64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;poll本质上和select没有区别，但是它&lt;/span&gt;&lt;span&gt;没有最大连接数的限制&lt;/span&gt;&lt;span&gt;，原因是它是基于&lt;/span&gt;&lt;span&gt;链表&lt;/span&gt;&lt;span&gt;来存储的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;epoll 虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2、FD剧增后带来的IO效率问题&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;select/poll 因为每次调用时都会对连接进行&lt;/span&gt;&lt;span&gt;线性遍历&lt;/span&gt;&lt;span&gt;，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;epoll 因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3、消息传递方式&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;select/poll 内核需要将消息传递到用户空间，都需要内核拷贝动作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;epoll通过内核和用户空间共享一块内存来实现的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;select、poll与epoll之间的区别总结图：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7448478900883219&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9Shnibm5jEufxcKolbr2yZNkuJhynJkX2wtHHABXcIib7OqyctYkrWd6sLGEHia2ibFD1lTgmeKgFKkicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1019&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;历史背景&lt;/strong&gt;：&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;152&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;&lt;span&gt;1）select出现是1984年在BSD里面实现的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）14年之后也就是1997年才实现了poll，其实拖那么久也不是效率问题， 而是那个时代的硬件实在太弱，一台服务器处理1千多个链接简直就是神一样的存在了，select很长段时间已经满足需求 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）2002, 大神 Davide Libenzi 实现了epoll。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;参考资料：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.cnblogs.com/Anker/p/3265058.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.cnblogs.com/aspirant/p/9166944.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.cnblogs.com/dhcn/p/12731883.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;笔记系列&lt;img class=&quot;rich_pages&quot; data-backh=&quot;253&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.43684992570579495&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9Trgib1F9icTlVo1xlHsH3QgErvpia4d7jHeibicNaK6q8eNgCnxLbldROsqeicufA3wTJThStjKJM44QIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;673&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454934251&amp;amp;idx=1&amp;amp;sn=77f210efd1960589975422e9000fb9e4&amp;amp;chksm=871a1853b06d9145c104c8ba9b7ef6df9e223ce227048422359be76a334c2c9adc4e822f9c29&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Java对象探秘&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;笔记 | Java对象探秘&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454934264&amp;amp;idx=1&amp;amp;sn=9c08f626d627122645c78c18563c4cf9&amp;amp;chksm=871a1840b06d9156e3bbea12e17d5fff668b4c717005be6c7462cfd746b3af1961e423faf27f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;JVM内存区域结构：一计两栈一堆一区&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;笔记 | JVM内存区域结构：一计两栈一堆一区&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454934346&amp;amp;idx=1&amp;amp;sn=4067d49c5e56f5a805a46c7e6daebd8c&amp;amp;chksm=871a19f2b06d90e4ab8f3b4d9b4a1fdabd7f4ec91493a8fbc0572334b2ef97b6f1a57f96ba5a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;笔记 | 面试官问我：TCP与UDP的区别&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454934425&amp;amp;idx=1&amp;amp;sn=7ca25eafb3098ff3e2b5f98ce323be47&amp;amp;chksm=871a1921b06d9037257e123d7646141e936b53bbba448bed35b13b288132410426e4854c36b4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;笔记 | 网络编程基础：TCP如何保证可靠性&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454934505&amp;amp;idx=1&amp;amp;sn=388f9b70b5e5a1791f79ba66de471152&amp;amp;chksm=871a1951b06d9047bc697fdd4c912fb61783a17d45dd7f409819147576573bb6493449f56869&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;笔记 | 面试又挂了，只因问了：TCP三次握手和四次挥手&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454934925&amp;amp;idx=1&amp;amp;sn=15d7e4482090f917f3e8ecb5420e56b5&amp;amp;chksm=871a1f35b06d962346ba631dcd098f74118872f95c00ada3091e9e2cd3fb7152078388fc2dab&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;笔记 | 5种网络IO模型&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c1cb2fcf208d68c00e0268021580dedc</guid>
<title>[推荐] 2.3 万 Star！直追微软 Visio，这个简洁实用的在线绘图工具必须推荐给你</title>
<link>https://toutiao.io/k/msg8jaf</link>
<content:encoded>&lt;div&gt;&lt;div/&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>