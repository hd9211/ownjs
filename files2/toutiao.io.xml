<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d283a1dec40fcbcce4ee7ac29d8188d0</guid>
<title>Redis 存储对象信息是用 Hash 还是 String</title>
<link>https://toutiao.io/k/2rcud9q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;Redis 内部使用一个 RedisObject 对象来表示所有的 key 和 value，RedisObject 中的 type，则是代表一个 value 对象具体是何种数据类型，它包含字符串（String）、链表（List）、哈希结构（Hash）、集合（Set）、有序集合（Sorted set）。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b188fc9df3bb28ffbbc456f00ee63233_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;671&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-b188fc9df3bb28ffbbc456f00ee63233_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;671&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-b188fc9df3bb28ffbbc456f00ee63233_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b188fc9df3bb28ffbbc456f00ee63233_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;日常工作中我们存储对象信息的时候，一般有两种做法，一种是用 Hash 存储，另一种是 String 存储。但好像并没有所谓的最佳实践，那么实际上到底用什么数据结构存储更好呢？&lt;/p&gt;&lt;p&gt;首先简单回顾下，Redis 的 Hash 和 String 结构。&lt;/p&gt;&lt;h2&gt;String&lt;/h2&gt;&lt;p&gt;String 数据结构是简单的 key-value 类型，value 其实不仅是 String，也可以是数字。Redis 中的 String 可以表示很多语义：&lt;/p&gt;&lt;p&gt;这三种类型，Redis 会根据具体的场景完成自动转换，并且根据需要选取底层的承载方式。String 在Redis 内部存储默认就是一个字符串，被 RedisObject 所引用，当遇到 incr、decr 等操作时会转成数值型进行计算，此时 RedisObject 的 encoding 字段为int。&lt;/p&gt;&lt;p&gt;在存储过程中，我们可以将用户信息使用 Json 序列化成字符串，然后将序列化后的字符串存入 Redis 进行缓存。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-27f8be534bfc97f96460328e94a72c8e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;964&quot; data-rawheight=&quot;402&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-27f8be534bfc97f96460328e94a72c8e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;964&quot; data-rawheight=&quot;402&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-27f8be534bfc97f96460328e94a72c8e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-27f8be534bfc97f96460328e94a72c8e_b.jpg&quot;/&gt;&lt;figcaption&gt;String 数据结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;由于 Redis 的字符串是动态字符串，可以修改，内部结构类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。如上图所示，内部为当前字符串实际分配的空间 capacity，一般高于实际字符串长度 len。&lt;/p&gt;&lt;p&gt;假设我们要存储的结构是：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;1 {
2   &quot;name&quot;: &quot;xiaowang&quot;,
3   &quot;age&quot;: &quot;35&quot;
4 }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果此时将此用户信息的 name 改为“xiaoli”，再存到 Redis 中，Redis 是不需要重新分配空间的。而且我们在读取和存储数据的时候只需要对做 Json 序列化与反序列化，比较方便。&lt;/p&gt;&lt;h2&gt;Hash&lt;/h2&gt;&lt;p&gt;Hash 在很多编程语言中都有着很广泛的应用，而在 Redis 中也是如此。在 Redis 中，Hash 常常用来缓存一些对象信息，如用户信息、商品信息、配置信息等，因此也被称为字典（dictionary），Redis 的字典使用 Hash table 作为底层实现， 一个 Hash table 里面可以有多个哈希表节点，而每个哈希表节点保存了字典中的一个键值对。实际上，Redis 数据库底层也是采用 Hash table 来存储键值对的。&lt;/p&gt;&lt;p&gt;Redis 的 Hash 相当于 Java 的 HashMap，内部结构实现与 HashMap 一致，即数组+链表结构。只是 reHash 方式不一样。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b4bc1aa71667b1b437671aad442daf0d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;370&quot; data-rawheight=&quot;244&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;370&quot; data-rawheight=&quot;244&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b4bc1aa71667b1b437671aad442daf0d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;前面说到 String 适合存储用户信息，而 Hash 结构也可以存储用户信息，不过是对每个字段单独存储，因此可以在查询时获取部分字段的信息，节省网络流量。不过 Redis 的 Hash 的值只能是字符串，存储上面的那个例子还好，如果存储的用户信息变为：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;1 {
2   &quot;name&quot;: &quot;xiaowang&quot;,
3   &quot;age&quot;: 25,
4   &quot;clothes&quot;: {
5     &quot;shirt&quot;: &quot;gray&quot;,
6     &quot;pants&quot;: &quot;read&quot;
7   }
8 }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么该如何存储&quot;clothes&quot;属性又变成了该用 String 还是 Hash 的问题。&lt;/p&gt;&lt;h2&gt;String 和 Hash 占用内存的比较&lt;/h2&gt;&lt;p&gt;既然两种数据结构都可以存储结构体信息。到底哪种更加合适呢？&lt;/p&gt;&lt;p&gt;首先我们用代码先插入 10000 条数据，然后用可视化工具来看看内存的占用情况。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;1  const Redis = require(&quot;ioRedis&quot;);
2  const Redis0 = new Redis({port: 6370});
3  const Redis1 = new Redis({port: 6371});
4
5
6  const user = {
7   name: &#x27;name12345&#x27;,
8   age: 16,
9   avatar: &#x27;https://dss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=256767015,24101428&amp;amp;fm=26&amp;amp;gp=0.jpg&#x27;,
10  phone: &#x27;13111111111&#x27;,
11  email: &#x27;1111111@11.email&#x27;,
12  lastLogon: &#x27;2021-04-28 10:00:00&#x27;,
13 }
14
15
16 async function main() {
17  for (let i = 0; i &amp;lt; 10000; i++) {
18     await Redis0.set(`String:user:${i}`, Json.Stringify(user));
19     await Redis1.hmset(`Hash:user:${i}`, user);
20   }
21 }
22
23 main().then(process.exit);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;先看 Redis0：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-bb939848be9abcf4bd68095d4940f139_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;630&quot; data-rawheight=&quot;534&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-bb939848be9abcf4bd68095d4940f139_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;630&quot; data-rawheight=&quot;534&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-bb939848be9abcf4bd68095d4940f139_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-bb939848be9abcf4bd68095d4940f139_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;再来看看 Redis1：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-32e8929036b707955e9337668c57eaf3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;652&quot; data-rawheight=&quot;554&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-32e8929036b707955e9337668c57eaf3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;652&quot; data-rawheight=&quot;554&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-32e8929036b707955e9337668c57eaf3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-32e8929036b707955e9337668c57eaf3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;可以看到还是有点差距的，但是差距并不明显。&lt;/p&gt;&lt;h2&gt;网友讨论&lt;/h2&gt;&lt;p&gt;网上的用户也有同样的疑问， 因为值的长度是不确定的，所以不知道采用 String 还是 Hash 存储更有效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2ec5a5fc745eecba2893edb5a6572f9d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;765&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-2ec5a5fc745eecba2893edb5a6572f9d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;765&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-2ec5a5fc745eecba2893edb5a6572f9d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-2ec5a5fc745eecba2893edb5a6572f9d_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 截图来源于 StackOverflow（Redis Strings vs Redis Hashes to represent Json: efficiency?）&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这里我主要给大家翻译下该问题下优质的答案：&lt;/p&gt;&lt;p&gt;&lt;b&gt;适合用 String 存储的情况：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;每次需要访问大量的字段&lt;/li&gt;&lt;li&gt;存储的结构具有多层嵌套的时候&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;适合用 Hash 存储的情况：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在大多数情况中只需要访问少量字段&lt;/li&gt;&lt;li&gt;自己始终知道哪些字段可用，防止使用 mget 时获取不到想要的数据&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;本文主要介绍了Redis 存储对象信息是用 Hash 还是 String，我的建议是大部分情况下使用 String 存储就好，毕竟在存储具有多层嵌套的对象时方便很多，占用的空间也比 Hash 小。当我们需要存储一个特别大的对象时，而且在大多数情况中只需要访问该对象少量的字段时，可以考虑使用 Hash。&lt;/p&gt;&lt;p&gt;&lt;b&gt;推荐阅读：&lt;/b&gt;&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/563/%25E4%25B8%2589%25E5%2588%2586%25E9%2592%259F%25E4%25BA%2586%25E8%25A7%25A3%2520Python3%2520%25E7%259A%2584%25E5%25BC%2582%25E6%25AD%25A5%2520Web%2520%25E6%25A1%2586%25E6%259E%25B6%2520FastAPI.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic4.zhimg.com/v2-32db835da87060ffdd805ef17d07aec3_180x120.jpg&quot; data-image-width=&quot;957&quot; data-image-height=&quot;620&quot; class=&quot;LinkCard old LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;三分钟了解 Python3 的异步 Web 框架 FastAPI&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic4.zhimg.com/v2-32db835da87060ffdd805ef17d07aec3_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/558/QUIC%252FHTTP3%2520%25E5%258D%258F%25E8%25AE%25AE%25E7%25AE%2580%25E6%259E%2590.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic1.zhimg.com/v2-7a88939758f822892186586001fb0d2c_180x120.jpg&quot; data-image-width=&quot;1080&quot; data-image-height=&quot;608&quot; class=&quot;LinkCard old LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;QUIC/HTTP3 协议简析&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic1.zhimg.com/v2-7a88939758f822892186586001fb0d2c_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ea1682da98fa7e4bcf3c3cc85a3989a9</guid>
<title>终于明白什么是区块链了</title>
<link>https://toutiao.io/k/tzdqnhc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5620853080568721&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMou2EfEVz1Qm53BaBvM7NIS3qicCmgNK7H519nIwbsQeK4debSEwITwSeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2110&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.541015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouIGJdROuwqbenfurGHHuefD8yShWub02m8lic6EEbTDspkFPZtdSgicFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2048&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5785288270377733&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouvd5hneobWqQdwP87TUSszBl9iagj2uN00xibBBGesMic0YMERw7Wn5zicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2012&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5920344456404736&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMoux3NJvUNqIT6lzuDCtdL5hzia9ibZWSQ9LPicxib4TTrEDvYpQzXSw1QpibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1858&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5208768267223383&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouLO3GWczJzPgVUXv7aeKMXgTK7ibLGZGFVQuPP90DhUYcWwoZMSOicliaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1916&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如在幸福村，一天，张三想去李四那里买&lt;span&gt;1&lt;/span&gt;斤肉，但是兜里没有钱，于是跟李四说：我先欠着你的钱，让村里的帐房先生记一下，到了年底一起结账。李四觉得可以，于是就答应了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5804195804195804&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouJdbun5pXdShDlbA5oIBl7LXiaepfdsc3LNicdNctKWibOkVFDMwIe1JRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;572&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6787709497206704&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouLDiauWP543nn7A43yicGmmI7iapbNGdicu1iaRnJoriaDsPRxV5ODAcHQK2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;716&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;刚开始帐房先生不负众望，村里的大大小小的账目记的清清楚楚，可是后来意外发生了，由于账房先生家里电器老化失修，引起了大火，把账本烧的干干净净，村里人都慌了，大家都不知道欠了彼此多少钱。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3763837638376384&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouTkibkcsCEPNyhym1xhW5BYYU7bzA6JMjPtLEMhsSorx68NKICussyCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1626&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了不让这种事情再次发生，有人提议，村民每周轮番记账，这样可以降低账本被损毁的概率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7156488549618321&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMou7XW1BOAoPOKFWJafn43rmYuj1ln8DNHgtXFcicibSu7RoZuEpick87eWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1048&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可是没过多久又出事了，有人偷偷改了账本的数据，导致数据对不上，大家不得不再次想办法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5285714285714286&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouRqTqQwa4DJs6smmhmO42WtsG1DWxo4v8yZgjH8TCltr3Ury4DeMpPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;980&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这时，村里一个叫&lt;span&gt;中本聪&lt;/span&gt;的村民想了一个办法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7683982683982684&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouvn65PMbjiaAcICibdehVafEd92Lj90Sib5UtzhiccQpibCVlKBBYLicjR8Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;924&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;村民每个人都维护自己的账本，当村里每次发生交易时，就在拿着广播喊一声。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4081041968162084&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouuX9GMMyPMQmpicx6mdibpm9NacoescuicxshBhIPMAGT8YrXps09GgnvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1382&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全村人都知道，然后记在自己的账本上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8134490238611713&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouRxex8qloPxhKq1z0WNiczbfn12L8F2eB4bRCUUXSliaFmqdo8x62g9Gw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;922&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样，就算一个被毁掉或者偷改了账本也不要紧，因为大部分账本是没有问题的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7888198757763976&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouMKMqb5qTUSAO8WUHABQ51ibW6SrfUdFIjz7biaiahHhulia8XzFeyNIVCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;966&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可是，大家谁会主动的愿意记帐呢？&lt;span&gt;中本聪&lt;/span&gt;说了，交易的人需要缴纳一点点的手续费，凡是第一个抢到记账权利的人，记账就可以得到该手续费，而且，还额外得到村里发的奖励，这样一来，村民都抢着记账。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7368421052631579&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouO9LVRzeDDZlvOxBm934VEwTI3sFaoJYqIQYXGbriaCwII9CqjNJgcFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;988&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如，&lt;span&gt;x&lt;/span&gt;年&lt;span&gt;x&lt;/span&gt;月&lt;span&gt;x&lt;/span&gt;日，发生了&lt;span&gt;3&lt;/span&gt;次交易。参与记账的村民一边确认该交易信息是否是真实的，一边抢记账权利。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8234265734265734&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouVPvfDzO7xCDafJcGPG3icVJ9z7IKIicBtnlJEZk2mTrzNPQn42YKr6Sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1144&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;抢到记账权利的人将自己的记账信息告诉其他人，其他人需要将信息写到自己的账本上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8765432098765432&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouk0CWoBVcmfiauWHDt7w66CMCFc8JuicibYPG01TkTkRf2ZOAzMibziaiblYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;810&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9973045822102425&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouVFSgmPQ5fFYgzoGC4GV0HShgWa3DurB72HHJFOqaE8oICCPV1sibXoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;742&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着账本记的越来越多，大家把各自的账本按照时间的先后顺序串在一起，这就是&lt;span&gt;区块链&lt;/span&gt;的雏形。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5796568627450981&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouvLdmjHOhKaPH7Ty8RjictXwpDicPbTp7llE71PjrZ6KGsjmUpchUO95g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1632&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.562429696287964&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouXvhd7Al6GMkSFmRJcFW4YcmrDv05GdsLojfIdc8u1SfXqj6SJ7mzFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1778&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5658536585365853&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouiaic37iau6k7ZStoGpYibPyIT8THEyHDVYDyKHj4efM0tqzMyICfXh2vCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2050&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5976768743400211&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMoupAXPYyt6t2NJBjMjrpTny4yydcqasgWKz03TWdBmtfZ4A12nMEa36Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1894&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f75102d8eb1b3f0a514348b5ea86f6b2</guid>
<title>一文理解 JVM 线程属于用户态还是内核态</title>
<link>https://toutiao.io/k/gfo3iba</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-source-line=&quot;1&quot;&gt;Linux操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。&lt;/p&gt;&lt;p data-source-line=&quot;3&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7EQtQo2B1Fh96B5msCib1X1DYldoiaOIatiaNOErl9Y8Q7pfxwstmWtLnhNIt2VEibRKCMWV093jA7uuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;344&quot;/&gt;&lt;/p&gt;&lt;h2 data-source-line=&quot;5&quot;&gt;用户态与内核态&lt;/h2&gt;&lt;p data-source-line=&quot;7&quot;&gt;内核从本质上看是一种软件——控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态即上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。&lt;/p&gt;&lt;blockquote data-source-line=&quot;9&quot;&gt;&lt;p&gt;注：对操作系统来说，用户态线程具有不可见性，也称透明性。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;用户态线程调度完全由进程负责，通常就是由进程的主线程负责（用户可以为应用程序定制调度算法），相当于进程主线程的延展，使用的是操作系统分配给进程主线程的时间片段；内核线程由内核维护，由操作系统调度。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户态线程无法跨核心，一个进程的多个用户态线程不能并发，阻塞一个用户态线程会导致进程的主线程阻塞，直接交出执行权限。这些都是用户态线程的劣势。内核线程可以独立执行，操作系统会分配时间片段。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-source-line=&quot;13&quot;&gt;用户态的应用程序可以通过三种方式来访问内核态的资源：&lt;/p&gt;&lt;h3 data-source-line=&quot;19&quot;&gt;为什么需要区分用户态和内核态&lt;/h3&gt;&lt;p data-source-line=&quot;21&quot;&gt;在 CPU 的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如清内存、设置时钟等。如果允许所有的程序都可以使用这些指令，那么系统崩溃的概率将大大增加。&lt;/p&gt;&lt;p data-source-line=&quot;23&quot;&gt;所以，CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令。&lt;/p&gt;&lt;p data-source-line=&quot;25&quot;&gt;比如Intel的CPU将特权等级分为4个级别：Ring0~Ring3；Linux 系统只使用了Ring0和Ring3两个运行级别。&lt;/p&gt;&lt;p data-source-line=&quot;27&quot;&gt;当进程运行在Ring3级别时被称为运行在用户态，而运行在 Ring0 级别时被称为运行在内核态。&lt;/p&gt;&lt;h3 data-source-line=&quot;29&quot;&gt;从用户态到内核态的切换的时机&lt;/h3&gt;&lt;p data-source-line=&quot;31&quot;&gt;&lt;img data-ratio=&quot;0.4371584699453552&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7EQtQo2B1Fh96B5msCib1X1DDRmM8iaSFunVuN92ibV8o22eW6TfPZrF6xXiaP7JCBvP3W1oA6OPA0G2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;33&quot;&gt;很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。&lt;/p&gt;&lt;ol data-source-line=&quot;35&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;系统调用。操作系统对内核级别的指令进行封装，统一管理硬件资源，然后向用户程序提供系统服务，用户程序进行系统调用后，操作系统执行一系列的检查验证，确保这次调用是安全的，再进行相应的资源访问操作。比如C函数库中的内存分配函数malloc()，它具体是使用sbrk()系统调用来分配内存；当malloc调用sbrk()的时候就涉及一次从用户态到内核态的切换；类似的函数还有printf()，调用的是wirte()系统调用来输出字符串等等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;异常事件。当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，如缺页异常。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;外围设备的中断。当外围设备完成用户的请求操作后，会向CPU发出中断信号，此时，CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;41&quot;&gt;注意：系统调用的本质其实也是中断，相对于外围设备的硬中断，这种中断称为软中断，这是操作系统为用户特别开放的一种中断。所以，从触发方式和效果上来看，这三种切换方式是完全一样的，都相当于是执行了一个中断响应的过程。但是从触发的对象来看，系统调用是进程主动请求切换的，而异常和硬中断则是被动的。&lt;/p&gt;&lt;p data-source-line=&quot;43&quot;&gt;理解了这里，推荐看下《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyNzgyNzAwNg==&amp;amp;mid=2247483933&amp;amp;idx=1&amp;amp;sn=d9776b9efe054b30523adbe60cb7524a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;NIO效率高的原理之零拷贝与直接内存映射&lt;/a&gt;》中有关NIO零拷贝优化的知识。&lt;/p&gt;&lt;h2 data-source-line=&quot;46&quot;&gt;用户线程与内核线程的映射关系&lt;/h2&gt;&lt;p data-source-line=&quot;48&quot;&gt;用户线程一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程(Light Weight Process，LWP)。因此对于用户线程来说，用户程序必须让它的调度器采用用户线程，然后在内核线程上运行它。&lt;/p&gt;&lt;p data-source-line=&quot;50&quot;&gt;用户线程与内核线程的映射关系有三种模型：一对一模型、多对一模型、多对多模型。&lt;/p&gt;&lt;h3 data-source-line=&quot;52&quot;&gt;一对一模型&lt;/h3&gt;&lt;p data-source-line=&quot;54&quot;&gt;&lt;img data-ratio=&quot;0.5983606557377049&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OqTAl3WTC7EQtQo2B1Fh96B5msCib1X1DmmTaLwb2ibFHkvqj5FtGdUlsDmH690iaI3saDpKyKmolaewSkLwODAWA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;57&quot;&gt;有了内核线程，每个用户线程被映射到一个内核线程。用户线程在其生命期内都会映射到该内核线程。一旦用户线程终止，两个线程都将离开系统。这被称作&quot;一对一&quot;线程映射。&lt;/p&gt;&lt;p data-source-line=&quot;59&quot;&gt;缺点：&lt;/p&gt;&lt;ol data-source-line=&quot;61&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;操作系统限制了内核线程的数量，因此一对一模型会使用户线程的数量受到限制。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-source-line=&quot;64&quot;&gt;多对一模型&lt;/h3&gt;&lt;p data-source-line=&quot;66&quot;&gt;&lt;img data-ratio=&quot;0.5737704918032787&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OqTAl3WTC7EQtQo2B1Fh96B5msCib1X1DsD6mJOMiaHTArGwfgwCpU9btl7hGuZ2cicNC8KXO0CPB0g0aNIBCSM8g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;69&quot;&gt;多对一模型将多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行，因此相对一对一模型，多对一模型的线程切换速度要快许多。此外，多对一模型对用户线程的数量几乎无限制。&lt;/p&gt;&lt;p data-source-line=&quot;71&quot;&gt;缺点：&lt;/p&gt;&lt;ol data-source-line=&quot;73&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;如果其中一个用户线程阻塞，那么其它所有线程都将无法执行，因为此时内核线程也随之阻塞了。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在多处理器系统上，处理器数量的增加对多对一模型的线程性能不会有明显的增加，因为所有的用户线程都映射到一个处理器上了。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-source-line=&quot;76&quot;&gt;多对多模型&lt;/h3&gt;&lt;p data-source-line=&quot;78&quot;&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OqTAl3WTC7EQtQo2B1Fh96B5msCib1X1D6mal6ziakQZzDHf88xlYrHTicnuiamUkICJz2Yc6tAiccOgY3icNe92vo0w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;80&quot;&gt;多对多模型（又称为M对N模型）结合了一对一模型和多对一模型的优点，将多个用户线程映射到多个内核线程上。&lt;/p&gt;&lt;p data-source-line=&quot;82&quot;&gt;优点：&lt;/p&gt;&lt;ol data-source-line=&quot;83&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;一个用户线程的阻塞不会导致所有线程的阻塞，因为此时还有别的内核线程被调度来执行。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;多对多模型对用户线程的数量没有限制。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在多处理器的操作系统中，多对多模型的线程也能得到一定的性能提升，但提升的幅度不如一对一模型的高。在现在流行的操作系统中，大都采用多对多的模型。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-source-line=&quot;87&quot;&gt;JVM线程属于用户态还是内核态&lt;/h2&gt;&lt;p data-source-line=&quot;89&quot;&gt;java线程在jdk1.2之前，是基于名为“绿色线程”的用户线程实现的，这导致绿色线程只能同主线程共享CPU分片，从而无法利用多核CPU的优势。&lt;/p&gt;&lt;p data-source-line=&quot;91&quot;&gt;由于绿色线程和原生线程比起来在使用时有一些限制， jdk1.2中放弃绿色线程，转而使用原生线程。&lt;/p&gt;&lt;p data-source-line=&quot;93&quot;&gt;在目前的jdk版本中，操作系统支持怎样的线程模型，很大程度上决定了java虚拟机的线程是怎样映射的，这点在不同的平台上都没有办法达成一致。&lt;/p&gt;&lt;p data-source-line=&quot;95&quot;&gt;总的来说就是，虚拟机规范中并没有限定java线程需要使用哪种线程模型，要根据不同的平台来说，但是无论使用哪种线程模型，java程序的编码和运行都是没有差异的。&lt;/p&gt;&lt;p data-source-line=&quot;97&quot;&gt;例如，Java SE最常用的JVM是Oracle/Sun研发的HotSpot VM。在这个JVM所支持的所有平台上都是采用一对一的线程模型的，除了Solaris平台。&lt;/p&gt;&lt;p data-source-line=&quot;99&quot;&gt;参考文档：&lt;/p&gt;&lt;ol data-source-line=&quot;100&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;《深入理解Java虚拟机》&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bbe8b549c1b8d3e3815695282629a72e</guid>
<title>深入浅出协程、线程和并发问题</title>
<link>https://toutiao.io/k/kk111u2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;&lt;b&gt;&quot;协程是轻量级的线程&quot;&lt;/b&gt;，相信大家不止一次听到这种说法。但是您真的理解其中的含义吗？恐怕答案是否定的。接下来的内容会告诉大家&lt;b&gt;协程是如何在 Android 运行时中被运行的&lt;/b&gt;，它们和线程之间的关系是什么，以及在使用 Java 编程语言线程模型时所遇到的&lt;b&gt;并发问题&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;协程和线程&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;协程旨在简化异步执行的代码。对于 Android 运行时的协程，&lt;b&gt;lambda 表达式的代码块会在专门的线程中执行&lt;/b&gt;。例如，示例中的 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Fibonacci_number&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;斐波那契&lt;/a&gt;&lt;/b&gt; 运算:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 在后台线程中运算第十级斐波那契数
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;n&quot;&gt;someScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;fibonacci10&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;synchronousFibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;saveFibonacciInMemory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fibonacci10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;synchronousFibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面 async 协程的代码块，&lt;b&gt;会被分发到由协程库所管理的线程池中执行&lt;/b&gt;，实现了同步且阻塞的斐波那契数值运算，并且将结果存入内存，上例中的线程池属于 Dispatchers.Default。该代码块会在未来某些时间在线程池中的某一线程中执行，具体执行时间取决于线程池的策略。&lt;/p&gt;&lt;p&gt;请注意由于上述代码中未包含挂起操作，因此它会在同一个线程中执行。而协程是有可能在不同的线程中执行的，比如将执行部分移动到不同的分发器，或者在使用线程池的分发器中包含带有挂起操作的代码。&lt;/p&gt;&lt;p&gt;如果不使用协程的话，您还可以使用线程自行实现类似的逻辑，代码如下:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 创建包含 4 个线程的线程池
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;executorService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newFixedThreadPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 
&lt;span class=&quot;c1&quot;&gt;// 在其中的一个线程中安排并执行代码
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;n&quot;&gt;executorService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;execute&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;fibonacci10&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;synchronousFibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;saveFibonacciInMemory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fibonacci10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然您可以自行实现线程池的管理，&lt;b&gt;但是我们仍然推荐使用协程作为 Android 开发中首选的异步实现方案&lt;/b&gt;，它具备内置的取消机制，可以提供更便捷的异常捕捉和结构式并发，后者可以减少类似内存泄漏问题的发生几率，并且与 Jetpack 库集成度更高。&lt;/p&gt;&lt;p&gt;&lt;b&gt;工作原理&lt;/b&gt;&lt;/p&gt;&lt;p&gt;从您创建协程到代码被线程执行这期间发生了什么呢？当您使用标准的协程 builder 创建协程时，您可以指定该协程所运行的 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/CoroutineDispatcher.kt&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;CoroutineDispatcher&lt;/a&gt;&lt;/b&gt;，如果未指定，系统会默认使用 &lt;code&gt;Dispatchers.Default&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;CoroutineDispatcher 会负责将协程的执行分配到具体的线程&lt;/b&gt; 。在底层，当 &lt;code&gt;CoroutineDispatcher&lt;/code&gt; 被调用时，它会调用&lt;b&gt;封装了 Continuation (比如这里的协程)&lt;/b&gt; &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/CoroutineDispatcher.kt%23L99&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;interceptContinuation&lt;/a&gt;&lt;/b&gt; 方法来拦截协程。该流程是以 CoroutineDispatcher 实现了 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Kotlin/kotlinx.coroutines/blob/master/stdlib-stubs/src/ContinuationInterceptor.kt&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;CoroutineInterceptor&lt;/a&gt;&lt;/b&gt; 接口作为前提。&lt;/p&gt;&lt;blockquote&gt;如果您阅读了我之前的关于 &lt;b&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/145001592&quot; class=&quot;internal&quot;&gt;协程在底层是如何实现&lt;/a&gt;&lt;/b&gt; 的文章，您应该已经知道了编译器会创建状态机，以及关于状态机的相关信息 (比如接下来要执行的操作) 是被存储在 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-continuation.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Continuation&lt;/a&gt;&lt;/b&gt;对象中。&lt;/blockquote&gt;&lt;p&gt;一旦 Continuation 对象需要在另外的 Dispatcher 中执行，&lt;code&gt;DispatchedContinuation&lt;/code&gt; 的 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/internal/DispatchedContinuation.kt%23L178&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;resumeWith&lt;/a&gt;&lt;/b&gt; 方法会负责将协程分发到合适的 Dispatcher。&lt;/p&gt;&lt;p&gt;此外，在 Java 编程语言的实现中，&lt;b&gt;继承自&lt;/b&gt; &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/internal/DispatchedTask.kt&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;DispatchedTask&lt;/a&gt;&lt;/b&gt; &lt;b&gt;抽象类的 DispatchedContinuation&lt;/b&gt; 也属于 &lt;code&gt;Runnable&lt;/code&gt; 接口的一种实现类型。因此，&lt;code&gt;DispatchedContinuation&lt;/code&gt; 对象也可以在线程中执行。其中的好处是当指定了 &lt;code&gt;CoroutineDispatcher&lt;/code&gt; 时，协程就会转换为 &lt;code&gt;DispatchedTask&lt;/code&gt;，并且作为 &lt;code&gt;Runnable&lt;/code&gt; 在线程中执行。&lt;/p&gt;&lt;p&gt;那么当您创建协程后，&lt;code&gt;dispatch&lt;/code&gt; 方法如何被调用呢？当您使用标准的协程 builder 创建协程时，您可以指定启动参数，它的类型是 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/index.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;CoroutineStart&lt;/a&gt;&lt;/b&gt;。例如，您可以设置协程在需要的时候才启动，这时可以将参数设置为 &lt;code&gt;CoroutineStart.LAZY&lt;/code&gt;。默认情况下，系统会使用 &lt;code&gt;CoroutineStart.DEFAULT&lt;/code&gt; 根据 &lt;code&gt;CoroutineDispatcher&lt;/code&gt; 来安排执行时机。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d7360940cd41295a712354151db056fb_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot; data-rawheight=&quot;362&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-d7360940cd41295a712354151db056fb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot; data-rawheight=&quot;362&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-d7360940cd41295a712354151db056fb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-d7360940cd41295a712354151db056fb_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 协程的代码块如何在线程中执行的示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;分发器和线程池&lt;/b&gt;&lt;/p&gt;&lt;p&gt;您可以使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.util.concurrent.-executor/as-coroutine-dispatcher.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Executor.asCoroutineDispatcher()&lt;/a&gt;&lt;/b&gt; 扩展函数将协程转换为 &lt;code&gt;CoroutineDispatcher&lt;/code&gt; 后，即可在应用中的任何线程池中执行该协程。此外，您还可以使用协程库默认的 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/Dispatchers.kt&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Dispatchers&lt;/a&gt;&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;您可以看到 &lt;b&gt;&lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/CoroutineContext.kt%23L22&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;createDefaultDispatcher&lt;/a&gt;&lt;/code&gt;&lt;/b&gt; 方法中是如何初始化 &lt;code&gt;Dispatchers.Default&lt;/code&gt; 的。默认情况下，系统会使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/CoroutineContext.kt%23L22&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;DefaultScheduler&lt;/a&gt;&lt;/b&gt;。如果您看一下 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/Dispatchers.kt%23L118&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Dispatcher.IO&lt;/a&gt;&lt;/b&gt; 的实现代码，它也使用了 &lt;code&gt;DefaultScheduler&lt;/code&gt;，支持按需创建至少 64 个线程。&lt;code&gt;Dispatchers.Default&lt;/code&gt; 和 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/Dispatchers.kt%23L118&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Dispatchers.IO&lt;/a&gt;&lt;/b&gt; 是隐式关联的，因为它们使用了同一个线程池，这就引出了我们下一个话题，使用不同的分发器调用 withContext 会带来哪些运行时的开销呢？&lt;/p&gt;&lt;p&gt;&lt;b&gt;线程和 withContext 的性能表现&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在 Android 运行时中，如果运行的线程比 CPU 的可用内核数多，那么切换线程会带来一定的运行时开销。&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Context_switch&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;上下文切换&lt;/a&gt;&lt;/b&gt; 并不轻松！操作系统需要保存和恢复执行的上下文，而且 CPU 除了执行实际的应用功能之外，还需要花时间规划线程。除此之外，当线程中所运行代码阻塞的时候也会造成上下文切换。如果上述的问题是针对线程的，那么在不同的 Dispatchers 中使用 withContext 会带来哪些性能上的损失呢？&lt;/p&gt;&lt;p&gt;还好线程池会帮我们解决这些复杂的操作，它会尝试尽量多地执行任务 (这也是为什么在线程池中执行操作要优于手动创建线程)。协程由于被安排在线程池中执行，所以也会从中受益。基于此，协程不会阻塞线程，它们反而会挂起自己的工作，因而更加有效。&lt;/p&gt;&lt;p&gt;Java 编程语言中默认使用的线程池是 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/scheduling/CoroutineScheduler.kt&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;CoroutineScheduler&lt;/a&gt;&lt;/b&gt; 。&lt;b&gt;它以最高效的方式将协程分发到工作线程&lt;/b&gt;。由于 &lt;code&gt;Dispatchers.Default&lt;/code&gt;和 Dispatchers.IO 使用相同的线程池，在它们之间切换会尽量避免线程切换。协程库会优化这些切换调用，保持在同一个分发器和线程上，并且尽量走捷径。&lt;/p&gt;&lt;p&gt;由于 Dispatchers.Main 在带有 UI 的应用中通常属于不同的线程，所以协程中 Dispatchers.Default和 Dispatchers.Main 之间的切换并不会带来太大的性能损失，因为协程会挂起 (比如在某个线程中停止执行)，然后会被安排在另外的线程中继续执行。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;协程中的并发问题&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;协程由于其能够简单地在不同线程上规划操作，的确使得异步编程更加轻松。但是另一方面，便捷是一把双刃剑: &lt;b&gt;由于协程是运行在 Java 编程语言的线程模型之上，它们难以逃脱线程模型所带来的并发问题&lt;/b&gt;。因此，您需要注意并且尽量避免该问题。&lt;/p&gt;&lt;p&gt;近年来，像不可变性这样的策略相对减轻了由线程所引发的问题。然而，有些场景下，不可变性策略也无法完全避免问题的出现。所有并发问题的源头都是状态管理！尤其是在一个多线程环境下访问&lt;b&gt;可变的状态&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;在多线程应用中，操作的执行顺序是不可预测的。与编译器优化操作执行顺序不同，线程无法保证以特定的顺序执行，而上下文切换会随时发生。如果在访问可变状态时没有采取必要的防范措施，线程就会访问到过时的数据，丢失更新，或者遇到 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Race_condition&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;资源竞争&lt;/a&gt;&lt;/b&gt; 问题等等。&lt;/p&gt;&lt;blockquote&gt;请注意这里所讨论的可变状态和访问顺序并不仅限于 Java 编程语言。它们在其它平台上同样会影响协程执行。&lt;/blockquote&gt;&lt;p&gt;使用了协程的应用本质上就是多线程应用。&lt;b&gt;使用了协程并且涉及可变状态的类必须采取措施使其可控&lt;/b&gt;，比如保证协程中的代码所访问的数据是最新的。这样一来，不同的线程之间就不会互相干扰。并发问题会引起潜在的 bug，使您很难在应用中调试和定位问题，甚至出现 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Heisenbug&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;海森堡 bug&lt;/a&gt;&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;这一类型的类非常常见。比如该类需要将用户的登录信息缓存在内存中，或者当应用在活跃状态时缓存一些值。如果您稍有大意，那么并发问题就会乘虚而入！使用 withContext(defaultDispatcher) 的挂起函数无法保证会在同一个线程中执行。&lt;/p&gt;&lt;p&gt;比如我们有一个类需要缓存用户所做的交易。如果缓存没有被正确访问，比如下面代码所示，就会出现并发问题:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TransactionsRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;defaultDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineDispatcher&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Default&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;transactionsCache&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutableMapOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 注意！访问缓存的操作未被保护！
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// 会出现并发问题：线程会访问到过期数据
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// 并且出现资源竞争问题
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;n&quot;&gt;withContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;defaultDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;oldList&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;newList&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toMutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;即使我们这里所讨论的是 Kotlin，由 Brian Goetz 所编撰的《Java 并发编程实践》对于了解本文主题和 Java 编程语言系统是非常好的参考材料。此外，Jetbrains 针对 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//kotlinlang.org/docs/shared-mutable-state-and-concurrency.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;共享可变的状态和并发&lt;/a&gt;&lt;/b&gt; 的主题也提供了相关的文档。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;保护可变状态&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;对于如何保护可变状态，或者找到合适的 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Synchronization_%28computer_science%29&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;同步&lt;/a&gt;&lt;/b&gt; 策略，取决于数据本身和相关的操作。本节内容启发大家注意可能会遇到的并发问题，而不是简单罗列保护可变状态的方法和 API。总而言之，这里为大家准备了一些提示和 API 可以帮助大家针对可变变量实现线程安全。&lt;/p&gt;&lt;p&gt;&lt;b&gt;封装&lt;/b&gt;&lt;/p&gt;&lt;p&gt;可变状态应该属于并被封装在类里。该类应该将状态的访问操作集中起来，根据应用场景使用同步策略保护变量的访问和修改操作。&lt;/p&gt;&lt;p&gt;&lt;b&gt;线程限制&lt;/b&gt;&lt;/p&gt;&lt;p&gt;一种方案是将读取和写入操作限制在一个线程里。可以使用队列基于生产者-消费者模式实现对可变状态的访问。Jetbrains 对此提供了很棒的 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//kotlinlang.org/docs/reference/coroutines/shared-mutable-state-and-concurrency.html%23thread-confinement-fine-grained&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;文档&lt;/a&gt;&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;避免重复工作&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在 Android 运行时中，包含线程安全的数据结构可供您保护可变变量。比如，在计数器示例中，您可以使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;AtomicInteger&lt;/a&gt;&lt;/b&gt;。又比如，要保护上述代码中的 Map，您可以使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ConcurrentHashMap&lt;/a&gt;&lt;/b&gt;。&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 是线程安全的，并且优化了 map 的读取和写入操作的吞吐量。&lt;/p&gt;&lt;p&gt;请注意，线程安全的数据结构并不能解决调用顺序问题，它们只是确保内存数据的访问是原子操作。当逻辑不太复杂的时候，它们可以避免使用 lock。比如，它们无法用在上面的 transactionCache 示例中，因为它们之间的操作顺序和逻辑需要使用线程并进行访问保护。&lt;/p&gt;&lt;p&gt;而且，当已修改的对象已经存储在这些线程安全的数据结构中时，其中的数据需要保持不可变或者受保护状态来避免资源竞争问题。&lt;/p&gt;&lt;p&gt;&lt;b&gt;自定义方案&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果您有复合的操作需要被同步，&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-volatile/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;@Volatile&lt;/a&gt;&lt;/b&gt; 和线程安全的数据结构也不会有效果。有可能内置的 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-synchronized/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;@Synchronized&lt;/a&gt;&lt;/b&gt; 注解的粒度也不足以达到理想效果。&lt;/p&gt;&lt;p&gt;在这些情况下，您可能需要使用并发工具创建您自己的同步机制，比如 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;latches&lt;/a&gt;&lt;/b&gt;、&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Semaphore_%28programming%29&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;semaphores&lt;/a&gt;&lt;/b&gt; 或者 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Barrier_%28computer_science%29&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;barriers&lt;/a&gt;&lt;/b&gt;。其它场景下，您可以使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Lock_%28computer_science%29&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;lock&lt;/a&gt;&lt;/b&gt; 和 mutex 无条件地保护多线程访问。&lt;/p&gt;&lt;p&gt;Kotlin 中的 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/index.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Mute&lt;/a&gt;&lt;/b&gt; 包含挂起函数 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/lock.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;lock&lt;/a&gt;&lt;/b&gt; 和 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/unlock.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;unlock&lt;/a&gt;&lt;/b&gt;，可以手动控制保护协程的代码。而扩展函数 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Mutex.withLock&lt;/a&gt;&lt;/b&gt; 使其更加易用:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TransactionsRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;defaultDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineDispatcher&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Default&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Mutex 保护可变状态的缓存
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;cacheMutex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;transactionsCache&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutableMapOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;withContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;defaultDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Mutex 保障了读写缓存的线程安全
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;n&quot;&gt;cacheMutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;withLock&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;oldList&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;newList&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toMutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;newList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于使用 Mutex 的协程在可以继续执行之前会挂起操作，因此要比 Java 编程语言中的 lock 高效很多，因为后者会阻塞整个线程。在协程中请谨慎使用 Java 语言中的同步类，因为它们会阻塞整个协程所处的线程，并且引发 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Liveness&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;活跃度&lt;/a&gt;&lt;/b&gt; 问题。&lt;/p&gt;&lt;p&gt;传入协程中的代码最终会在一个或者多个线程中执行。同样的，协程在 Android 运行时的线程模型下依然需要遵循约束条件。所以，使用协程也同样会出现存在隐患的多线程代码。所以，在代码中请谨慎访问共享的可变状态。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5da716dcede5110864128db4499f8477</guid>
<title>Presto 在腾讯资讯业务中的应用</title>
<link>https://toutiao.io/k/w9fekde</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;团队：腾讯医疗资讯与服务部-技术研发中心&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;前言：随着产品矩阵和团队规模的扩张，跨业务、APP的数据处理、分析总是不可避免。一个显而易见的问题就是异构数据源的连通。我们基于PrestoDB构建了业务线内适应腾讯生态的联邦查询引擎，连通了部门内部20+数据源实例，涵盖了90%的查询场景。同时，我们参与公司级的Presto Oteam进行协同共建，在引擎层面做了诸多改造。在实际使用Presto的过程中，也发现其SQL表达能力的过人之处。本文将从Presto使用者和开发者两种角度，给大家分享一些技术落地过程中的干货。&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 简介&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Presto是facebook研发的基于SQL进行大数据分析的高性能分布式计算引擎，最开始是用来解决Hive速度慢以及异构数据源互通的问题。在大数据家族中属于MPP（Massive Parallel Processing）计算引擎范畴，其原理是火山（Volcano）模型：将SQL抽象成一个个算子（Operator），形成管线（Pipeline）。目前能够支持Hive、HBase、ES、Kudu、Kafka、MySQL、Redis等几十种数据源的读取。它有如下特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;基于SQL语言，上手成本低，而且功能强大，支持reduce和lambda函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;纯计算引擎，解耦底层存储，可快速缩扩容&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;纯内存计算，速度快，提供交互式的查询体验&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过插件的方式实现拓展功能，二次开发友好&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过不同的连接器（Connector）插件读取异构数据源，进行联邦查询&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4916129032258065&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41mhKiaPoTgTvVIwOxDGgFDJ4m6JjyZnDEYqWGlxXjdciaXBL7gERa0f2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1550&quot;/&gt;&lt;figcaption&gt;1.Presto架构图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 业务现状&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是传统信息流业务，或是医疗业务，或多或少都会遇到&lt;strong&gt;异构数据源整合&lt;/strong&gt;问题。比如医生、患者的状态数据，由后台维护，前端上报数据则在Hive中。另外，由于相同数据源不同版本间差异较大，往往没有完整的解决方案，导致&lt;strong&gt;查询分析速度慢&lt;/strong&gt;，业务叫苦不迭，e.g. Hive不同实例仅通过MR引擎进行互通。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 业务构成&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前，个人接触过的业务包括资讯类的腾讯看点、腾讯医典，以及医生问诊相关的腾讯云医。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6112&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41F8S0fsQPK8EVSHxcLBwDzqCpwfjDWx9wXBN4iaQmLywoAegg7BbEicUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1250&quot;/&gt;&lt;figcaption&gt;2.业务构成&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 痛点问题&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据互通的时候，底层的数据源可能是同一数据源的多个实例，或是不同版本、魔改版本，e.g. 司内tHive与Venus都是Hive数据源。在跨业务/APP分析时，这种问题会更加明显。同时，由于应用场景的不同（离线计算、快速索引），天然也会存在多数据源问题。原因总结如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;团队技术栈差异&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同类产品较多&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;架构、历史遗留&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用场景不同&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6969253294289898&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41CtL0wIBcnbeZRatvMHC9Jpib5LQkuAURaWqoHx2ia7bvic0SzcGJ4YE3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1366&quot;/&gt;&lt;figcaption&gt;3.异构数据源问题&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 主要工作&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对Hive查询提速的问题，我们在联邦查询引擎中适配了内部的Hive数据源，并且参与中台Oteam项目进行Hive兼容、Presto引擎层优化、改造。同时，我们进行了技术运营工作来帮助大家更好地使用Presto。针对异构数据源打通的问题，我们进行了联邦查询引擎的调研与开发，在引擎层面对内部不同种类的数据源进行适配。最后是一些技术输出的规划工作。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Presto技术运营&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;联邦查询引擎改造适配&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Presto Oteam引擎研发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;技术输出&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 技术运营&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于身处业务的数据团队中，除了参与中台的技术研发，平时也会使用Presto，并且负责SQL相关问题的答疑，既是开发者，也是使用者。大多数人对Presto的印象，仅仅停留在“都是SQL引擎”上，其实不然。Presto的SQL语言能力非常出色。如slogan说宣传的那样，&lt;code&gt;SQL on Everything&lt;/code&gt;：不仅能够连接各种数据源，还能满足复杂的处理逻辑。如果认为“Presto在SQL层面上做到兼容Hive就差不多了”，那就没有真正发挥出Presto的威力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 Reduce + Lambda&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下来自一个真实案例，数据分析同学根据APP上报的用户行为日志进行清理、建模。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;v1版本：对用户路径按时间排序，然后输入模型进行建模。通过以下SQL片段可以满足需求。首先用array_agg将用户所有行为按照event_time排序，收集成数组，然后用&#x27;/&#x27;连接符进行拼接。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;array_join(array_agg(data order by event_time asc), &#x27;/&#x27;)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;v2版本：
由于上报时机的原因，总是会有些相邻的重复上报，分析同学希望把这些相邻数据剔除掉，例如有些行为定时10s上报一次，期望达到如下的效果：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不是别人问，自己是不会想到可以用SQL来完成这种操作的。&lt;strong&gt;数组相邻元素去重&lt;/strong&gt;，乍看是非常特化的需求，SQL不太可能满足，但后来发现还真的可以实现。不得不说Presto的reduce函数，加上自由度极高的lambda表达式，以及可以承载多个变量的&lt;code&gt;Row&lt;/code&gt;类型，使得我们几乎可以在SQL中“编程”（这里使用针对array类型的reduce函数，更通用的聚合函数为reduce_agg）。最终解法如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;-- 逻辑：6/4/6/6/10/20 -&amp;gt; 6/4/6/10/20&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-- distinct adjacent elements&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; reduce(&lt;br/&gt;                &lt;span&gt;ARRAY&lt;/span&gt; [&lt;span&gt;&#x27;6&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;4&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;6&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;6&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;10&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;20&#x27;&lt;/span&gt;], &lt;span&gt;-- 输入&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;CAST&lt;/span&gt;(&lt;br/&gt;                        &lt;span&gt;ROW&lt;/span&gt;(&lt;span&gt;ARRAY&lt;/span&gt;[], &lt;span&gt;&#x27;&#x27;&lt;/span&gt;) &lt;br/&gt;                        &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;ROW&lt;/span&gt;(arr &lt;span&gt;ARRAY&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;), prev_ele &lt;span&gt;VARCHAR&lt;/span&gt;)&lt;br/&gt;                    ),  &lt;span&gt;-- 初始状态S&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                (S, T) -&amp;gt; &lt;span&gt;CAST&lt;/span&gt;(&lt;br/&gt;                                &lt;span&gt;ROW&lt;/span&gt;(&lt;span&gt;IF&lt;/span&gt;(S.prev_ele=T, S.arr, S.arr||T), T) &lt;br/&gt;                                &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;ROW&lt;/span&gt;(arr &lt;span&gt;ARRAY&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;), prev_ele &lt;span&gt;VARCHAR&lt;/span&gt;)&lt;br/&gt;                              ),  &lt;span&gt;-- lambda输入函数I&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                S -&amp;gt; array_join(S.arr, &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;) &lt;span&gt;-- lambda输出函数O&lt;/span&gt;&lt;br/&gt;             );&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以作用对象为数组的reduce函数为例，包含以下4个参数：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;长度为N的数组。每个元素将会依次送入lambda输入函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;初始状态。第一个元素和该状态作为lambda输入函数第一次调用的参数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个lambda输入函数。调用N次。它接收一个状态和一个元素，产生一个新的状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个lambda输出函数。调用一次。对3中处理完的最终状态做一次变换&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;reduce(array(T), initialState S, inputFunction(S, T, S), outputFunction(S, R)) → R&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，示例中的状态S是一个&lt;code&gt;Row&lt;/code&gt;类型的变量，它可以存储多个元素。第一个是去重数组arr，第二个是上一个元素的值prev_ele。lambda输入函数每次接收到一个新的值，和prev_ele比较，相等则什么也也不做，不等则将新值放入去重数组中，同时更新prev_ele。reduce是一种通用的模型，lambda则最大程度地利用了SQL的现有能力，使得Presto的SQL表现力更加强大。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 窗口函数&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Presto中的聚合函数都可以被用在窗口函数中，使用array_agg可以把当前的窗口截取下来，结合Window Frame可以操纵窗口大小，衍生出很多窗口类型。主要由两个维度组成：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先是相同行的处理方式，记为dim1：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;RANGE: 当前窗口&lt;strong&gt;会&lt;/strong&gt;包含值相同的相邻行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ROWS: 当前窗口&lt;strong&gt;不会&lt;/strong&gt;包含值相同的相邻行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后是窗口的边界指定，最后两种仅支持与ROWS连用，记为dim2：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;UNBOUND PRECEDING: 排序后第一个元素&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;UNBOUND FOLLOWING: 排序后最后一个元素&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;N PRECEDING: 排序后，当前行的前N行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;N FOLLOWING: 排序后，当前行的后N行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.655705996131528&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41Y2Ky2XpDP0Kf1LlGARbXrJxJ1nPu1tzU8IEXibzXTDfVmEnc6rlQYkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;517&quot;/&gt;&lt;figcaption&gt;4. window frame[1]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以下SQL的结果，应该能对窗口函数有更进一步的认识。为了简化我们假设只有一个partition，排序为asc。列名取值如下所示方便大家理解：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46676737160120846&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41cMM53GsINKRbdjVF0bqNwficxeBaQBTwiaxRX2YzMR0W3TE1DOBZ2O4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;&lt;figcaption&gt;5. 命名方式&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;-- value为关心的值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-- 以index进行排序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;WITH&lt;/span&gt;&lt;br/&gt;    t1 (&lt;span&gt;value&lt;/span&gt;, &lt;span&gt;index&lt;/span&gt;) &lt;span&gt;AS&lt;/span&gt; &lt;br/&gt;    (&lt;br/&gt;        &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; (&lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;&#x27;a&#x27;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;),&lt;br/&gt;        (&lt;span&gt;&#x27;b&#x27;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;),&lt;br/&gt;        (&lt;span&gt;&#x27;c&#x27;&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;),&lt;br/&gt;        (&lt;span&gt;&#x27;d&#x27;&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;),&lt;br/&gt;        (&lt;span&gt;&#x27;e&#x27;&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;),&lt;br/&gt;        (&lt;span&gt;&#x27;f&#x27;&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;),&lt;br/&gt;        (&lt;span&gt;&#x27;g&#x27;&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;),&lt;br/&gt;        (&lt;span&gt;&#x27;h&#x27;&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;))&lt;br/&gt;    )&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; *,&lt;br/&gt;    &lt;span&gt;-- 默认&lt;/span&gt;&lt;br/&gt;    array_agg(&lt;span&gt;value&lt;/span&gt;) &lt;span&gt;OVER&lt;/span&gt; &lt;br/&gt;        (&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;) res, &lt;br/&gt;    &lt;span&gt;-- [开头, 当前值]&lt;/span&gt;&lt;br/&gt;    array_agg(&lt;span&gt;value&lt;/span&gt;) &lt;span&gt;OVER&lt;/span&gt; &lt;br/&gt;        (&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; &lt;span&gt;RANGE&lt;/span&gt; &lt;span&gt;BETWEEN&lt;/span&gt; &lt;span&gt;UNBOUNDED&lt;/span&gt; &lt;span&gt;PRECEDING&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;CURRENT&lt;/span&gt; &lt;span&gt;ROW&lt;/span&gt;) res_range_uc,&lt;br/&gt;    &lt;span&gt;-- [开头, 当前行]&lt;/span&gt;&lt;br/&gt;    array_agg(&lt;span&gt;value&lt;/span&gt;) &lt;span&gt;OVER&lt;/span&gt; &lt;br/&gt;        (&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; &lt;span&gt;ROWS&lt;/span&gt;  &lt;span&gt;BETWEEN&lt;/span&gt; &lt;span&gt;UNBOUNDED&lt;/span&gt; &lt;span&gt;PRECEDING&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;CURRENT&lt;/span&gt; &lt;span&gt;ROW&lt;/span&gt;) res_rows_uc,&lt;br/&gt;    &lt;span&gt;-- [当前值, 末尾]&lt;/span&gt;&lt;br/&gt;    array_agg(&lt;span&gt;value&lt;/span&gt;) &lt;span&gt;OVER&lt;/span&gt; &lt;br/&gt;        (&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; &lt;span&gt;RANGE&lt;/span&gt; &lt;span&gt;BETWEEN&lt;/span&gt; &lt;span&gt;CURRENT&lt;/span&gt; &lt;span&gt;ROW&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;UNBOUNDED&lt;/span&gt; &lt;span&gt;FOLLOWING&lt;/span&gt;) res_range_cu,&lt;br/&gt;    &lt;span&gt;-- [当前行, 末尾]&lt;/span&gt;&lt;br/&gt;    array_agg(&lt;span&gt;value&lt;/span&gt;) &lt;span&gt;OVER&lt;/span&gt; &lt;br/&gt;        (&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; &lt;span&gt;ROWS&lt;/span&gt;  &lt;span&gt;BETWEEN&lt;/span&gt; &lt;span&gt;CURRENT&lt;/span&gt; &lt;span&gt;ROW&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;UNBOUNDED&lt;/span&gt; &lt;span&gt;FOLLOWING&lt;/span&gt;) res_rows_cu,&lt;br/&gt;    &lt;span&gt;-- [前1个值，后1个值] 不支持&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-- array_agg(value) OVER (ORDER BY index RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING) res_range_11, not support&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-- [前1行，后1行]&lt;/span&gt;&lt;br/&gt;    array_agg(&lt;span&gt;value&lt;/span&gt;) &lt;span&gt;OVER&lt;/span&gt; &lt;br/&gt;        (&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; &lt;span&gt;ROWS&lt;/span&gt;  &lt;span&gt;BETWEEN&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;PRECEDING&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;FOLLOWING&lt;/span&gt;) res_rows_11&lt;br/&gt;&lt;span&gt;FROM&lt;/span&gt; t1;&lt;br/&gt;&lt;br/&gt;presto&amp;gt;&lt;br/&gt;&lt;br/&gt; value | index |           res            |       res_range_uc       |       res_rows_uc        |       res_range_cu       |       res_rows_cu        | res_rows_11 &lt;br/&gt;&lt;span&gt;-------+-------+--------------------------+--------------------------+--------------------------+--------------------------+--------------------------+-------------&lt;/span&gt;&lt;br/&gt; a     |     1 | [a]                      | [a]                      | [a]                      | [a, b, c, d, e, f, g, h] | [a, b, c, d, e, f, g, h] | [a, b]      &lt;br/&gt; b     |     2 | [a, b]                   | [a, b]                   | [a, b]                   | [b, c, d, e, f, g, h]    | [b, c, d, e, f, g, h]    | [a, b, c]   &lt;br/&gt; c     |     3 | [a, b, c]                | [a, b, c]                | [a, b, c]                | [c, d, e, f, g, h]       | [c, d, e, f, g, h]       | [b, c, d]   &lt;br/&gt; d     |     4 | [a, b, c, d, e]          | [a, b, c, d, e]          | [a, b, c, d]             | [d, e, f, g, h]          | [d, e, f, g, h]          | [c, d, e]   &lt;br/&gt; e     |     4 | [a, b, c, d, e]          | [a, b, c, d, e]          | [a, b, c, d, e]          | [d, e, f, g, h]          | [e, f, g, h]             | [d, e, f]   &lt;br/&gt; f     |     5 | [a, b, c, d, e, f, g]    | [a, b, c, d, e, f, g]    | [a, b, c, d, e, f]       | [f, g, h]                | [f, g, h]                | [e, f, g]   &lt;br/&gt; g     |     5 | [a, b, c, d, e, f, g]    | [a, b, c, d, e, f, g]    | [a, b, c, d, e, f, g]    | [f, g, h]                | [g, h]                   | [f, g, h]   &lt;br/&gt; h     |     6 | [a, b, c, d, e, f, g, h] | [a, b, c, d, e, f, g, h] | [a, b, c, d, e, f, g, h] | [h]                      | [h]                      | [g, h]      &lt;br/&gt;(8 rows)&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 高阶运营&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，通过官方文档就可以解答大部分问题。但有时候文档也没说明的细节，只能看源码了。关于语法特点的问题，需要查看&lt;code&gt;SqlBase.g4&lt;/code&gt;。比如以下SQL为什么可以运行？不是所有查询语句都需要select开头：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;presto&amp;gt; (&lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;&#x27;a&#x27;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;),(&lt;span&gt;&#x27;b&#x27;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;));&lt;br/&gt; _col0 | _col1 &lt;br/&gt;&lt;span&gt;-------+-------&lt;/span&gt;&lt;br/&gt; a     |     1 &lt;br/&gt; b     |     2 &lt;br/&gt;(2 rows)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;语义分析中的问题，需要查看&lt;code&gt;StatementAnalyzer&lt;/code&gt;。比如窗口函数执行完成后，用标量函数做一些加工处理，必须写在整个窗口函数&lt;code&gt;func2(func1() over ())&lt;/code&gt;的外面，而不是&lt;code&gt;func2(func1()) over ()&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;--报错&lt;/span&gt;&lt;br/&gt;array_join(array_agg(concat(col1, col2)), &#x27;/&#x27;) &lt;br/&gt;  over (partition by user_id order by event_time)&lt;br/&gt;&lt;br/&gt;vs&lt;br/&gt;&lt;br/&gt;&lt;span&gt;--成功&lt;/span&gt;&lt;br/&gt;array_join(&lt;br/&gt;  array_agg(concat(col1, col2)) &lt;br/&gt;    over (partition by user_id order by event_time),&lt;br/&gt;  &#x27;/&#x27;)&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4 语法、语义错误&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有个问题，到底怎么区分语法、语义错误？对于使用者而言，不建议了解。对于开发者来说，还是很有必要了解的。语法错误是指通过简单规则捕获的SQL错误，在Antlr层面就可以截获，跟上下文关系不大，e.g. select * from from table1;
语义错误需要上下文信息，比如库表、字段是否合法？对于Presto而言，lambda表达式出现的位置是否合法？了解语法、语义的区别，对问题的排查也是十分高效的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 联邦查询引擎&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异构数据源导致的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;搭建各种ETL Pipeline，维护成本高&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据分析速度&lt;strong&gt;严重拖慢&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为此，我们引入Presto作为联邦查询引擎，一方面利用多数据源能力，减少ETL相关工作量。另一方面，利用Presto的速度为业务分析提速。本次介绍两个数据源适配的工作：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为了适配内部的tHive，我们在MetaStore的Thrift RPC协议中植入了内部鉴权机制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对云上ES的网络情况，禁用了自动嗅探逻辑。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 tHive连接器适配&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Presto的Hive连接器通过与HMS（Hive MetaStore）通信获取Hive库表的位置信息，然后拉取数据。腾讯tHive有自己的一套鉴权体系TAUTH，我们需要将这种鉴权机制引入到Hive连接器中。外部一般通过Thrift RPC协议与HMS通信。那么如何加入鉴权能力呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7191011235955056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41XWek6YZTkpiaO91cCLHYTAguiauAt9C2dkzdBicpCdRxQKUwv6Nof5WJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1068&quot;/&gt;&lt;figcaption&gt;6.获取Hive库表元数据&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考Hive连接器中&lt;code&gt;Kerberos&lt;/code&gt;机制的实现（下图），可以看到rawTransport作为参数，用来构建一个新的SaslTransport。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5427083333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41ds7NGucogVctqjoHsODsIsgSrnP7ia3vsicAldoReSQn9qFTtlgYC0lQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;7. KerberosHiveMetastoreAuthentication&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合&lt;code&gt;TSaslClientTransport&lt;/code&gt;的源码可以发现，这里其实是计算机网络分层思想的典型应用。在可靠传输层rawTransport的基础上，再包装了一个Sasl层。利用底层rawTransport提供的可靠传输能力，进一步提供安全策略。e.g. 某些QoS条件下，调用Sasl层的&lt;code&gt;write()&lt;/code&gt;，会对数据进行加密，Sasl进而调用下一层的&lt;code&gt;write()&lt;/code&gt;函数，将加密后的数据发送到可靠的传输通道中。它们都实现了&lt;code&gt;TTtransport&lt;/code&gt;接口，I/O函数如下所示：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;open()&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;close()&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;flush()&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;readAll()&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;write()&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.47&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD410bajuuqDDRic80xMVe4iaXibESzFI1xLEFQ2AoibS3IpFxAxWTllVpiaxxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;figcaption&gt;8.本质为网络协议栈&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sasl层本身并不绑定特定的鉴权机制，它是一个框架。通过JCA注册的鉴权机制都可以在运行时被指定。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3568&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41Hxibrl3hRrWONw26yDnEJgw8uH4MHQZd3iauTMKte2o7iagYHD2mbbQMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;625&quot;/&gt;&lt;figcaption&gt;9.鉴权机制插件化&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果想整合自定义的鉴权机制，需要注册对应的&lt;code&gt;SecurityProvider&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.45592705167173253&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41eEAQltvoibGdu2icv7r3TKEzFIvOzOicuzPs94EJ0f6FZkBibDGfESTzcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1316&quot;/&gt;&lt;figcaption&gt;10.底层原理&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结：对于小白来说，“为Hive连接器增加一种鉴权机制”是个很难理解的技术需求，通过前文的探索，我们发现其本质是：“如何在HMS的Thrift RPC中，为SASL鉴权层增加一种自定义的安全协议。”这里的上下文比较多，需要对HMS、THrift RPC、SASL、JCA、Kerberos等概念有个大概的了解，才知道需要做什么。对技术的提升还是很有帮助的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 ES连接器踩坑&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个case：调研ES连接器的时候，发现Presto启动时第一次连接ES集群是成功的。但是后面哪怕没有执行ES相关查询也会无故报错，堆栈信息显示网络连接失败。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2173076923076923&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD4108NicBFYA452dsSdhhwTaWgZtw3cehVibhXEsV8gYARcuLgicR0JwlhKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1040&quot;/&gt;&lt;figcaption&gt;11. 报错信息&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过排查，发现与定时嗅探逻辑有关。Presto底层依赖了facebook内部的&lt;code&gt;Airlift&lt;/code&gt;后台框架。在这个场景下，通过&lt;code&gt;Bootstrap&lt;/code&gt;注册的类会被生命周期管理器识别，&lt;code&gt;@PostConstruct&lt;/code&gt;注解（Annotation）标记的函数会在类实例化后被自动调用。可以看到，一个&lt;code&gt;refreshNodes()&lt;/code&gt;函数被定期调用了，该函数会获取ES集群中所有的可用节点IP，并在下次将请求发送到其中一个节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34173669467787116&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41Ya6z8SyMoP6cF1IqqXdz2YPrQabUGvOyXDKByxCCjsnEgWDG28PlbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;714&quot;/&gt;&lt;figcaption&gt;12. @PostConstruct&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于云上ES集群只开放了一个主节点的访问端口，嗅探获得的IP其实是不能用的。这也解释了为什么第一次访问是成功的（第一次访问的主节点开放），后续访问大概率是失败的（其它节点端口不开放）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.963924963924964&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41u6gBZJiaAnhHVZUJ26ZMvJiadjTgsHNrq7nAaYl9SR3ia1F92BWXqnn7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;693&quot;/&gt;&lt;figcaption&gt;13.自动嗅探逻辑&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要的改造就是禁用自动更新节点逻辑，位于&lt;code&gt;ElasticSearchClint&lt;/code&gt;文件。在改造的过程中，发现已经有参数&lt;code&gt;elasticsearch.ignore-publish-address&lt;/code&gt;可以满足需求，但是在去年8月的时候DB、SQL的文档里竟然没有记录这个参数，github上搜索一波发现已有issue了，目前社区已经补齐了文档。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5464547677261614&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41hBcibkEoxHBSLvlu9YWBNyEYgbJwVj8b2DM9PUXLvdPmBC0GDOpEUSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;818&quot;/&gt;&lt;figcaption&gt;14.忽略嗅探IP&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结：&lt;code&gt;Airlift&lt;/code&gt;后台框架虽然没有文档，但开发者还是要认真看。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. Oteam共建&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在去年，随着Presto在腾讯内部的应用场景越来越多，为了整合各部门的研发能力和技术成果，公司内部由PCG欧拉数据中台牵头发起了Presto Oteam项目，主要for Presto引擎的研发。作为资讯业务的数据工程同学，我们也有幸参与共建。Oteam部分工作内容如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Hive语义兼容，函数迁移&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RBO/CBO执行解析器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Worker Tag能力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分析函数开发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;语法/语义扩展&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;动态数据源支持&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;查询性能优化专项&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Coordinator执行流程优化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bug fix
...&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限于篇幅，简单介绍第一点：标量函数开发原理。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 函数开发&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同于Hive UDF函数可以由用户直接上传，在Presto引擎中所有扩展部件都以插件形式被统一整合。除了最常见的连接器（Connector）插件以外，函数也是一种插件。如果业务需要自定义函数，就需要单独开发函数插件。Presto引擎自带了很多函数，可以作为开发者的参考。总共有两种函数开发方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用注解框架的普通函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用字节码适配的变长参数函数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种方式需要使用Presto引擎的注解框架，官网给的例子比较简单，各种注解搭配使用的方式实际比较复杂。同时函数的数据类型需要涉及到Presto引擎的&lt;code&gt;Slice&lt;/code&gt;，&lt;code&gt;Block&lt;/code&gt;等类型，有一定学习成本。第二种方式比较少见，而且不支持通过插件进行开发，只能写到&lt;code&gt;presto-main&lt;/code&gt;模块中，它基于Presto自带的字节码框架动态生成字节码（包&lt;code&gt;com.facebook.presto.sql.gen&lt;/code&gt;），是比较hack的实现，可以参考&lt;code&gt;ArrayConcatFunction&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 函数注解框架&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以标量函数为例。函数开发和普通的Java方法编写本质上是一样的，但是也有很多差异点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;需要使用注解（annotation）标记出该函数是一个可供调用的标量函数，包括函数名，返回类型、参数类型等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;java原生类型和Presto类型有一一对应的关系。Java的&lt;code&gt;Slice&lt;/code&gt;对应Presto中的&lt;code&gt;Varchar&lt;/code&gt;类型，Java的&lt;code&gt;Block&lt;/code&gt;对应Presto中的&lt;code&gt;Array&lt;/code&gt;类型。（下文分别称为Java类型和SQL类型）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这些特定的Java类型逻辑上等价于&lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Array数组&lt;/code&gt;，但是API差别很大，前期有一定的上手成本。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;函数有两套签名。基于反射可以获取Java类型的形参、返回值类型，称为&lt;strong&gt;方法签名&lt;/strong&gt;。基于&lt;code&gt;@SqlType&lt;/code&gt;注解可以获取Presto引擎使用的参数、返回值类型，称为&lt;strong&gt;函数签名&lt;/strong&gt;。这里做个严格的区分。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以使用&lt;code&gt;@TypeParameter&lt;/code&gt;函数注解引入&lt;strong&gt;泛型变量&lt;/strong&gt;。在函数体声明相关的泛型参数，供&lt;code&gt;SqlType&lt;/code&gt;引用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以使用&lt;code&gt;@LiteralParameter&lt;/code&gt;函数注解引入字面量变量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以使用形参注解&lt;code&gt;@TypeParameter&lt;/code&gt;、&lt;code&gt;@LiteralParameter&lt;/code&gt;、&lt;code&gt;@FunctionDependency&lt;/code&gt;、&lt;code&gt;@OperatorDependency&lt;/code&gt;声明一些&lt;strong&gt;依赖型参数&lt;/strong&gt;，在调用函数之前，Presto会根据解析出来的元数据，自动注入参数依赖。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们把写在函数体/类名上的注解称为&lt;strong&gt;函数注解&lt;/strong&gt;，写在函数形参前面的注解称为&lt;strong&gt;形参注解&lt;/strong&gt;，方便下文引用。一般来说，关注前四点就够了。后面是一些进阶的使用技巧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按注解类型区分：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;函数注解&lt;/th&gt;&lt;th&gt;形参注解&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;@SqlScalarFunction&lt;/td&gt;&lt;td&gt;定义函数名，函数属性&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Description&lt;/td&gt;&lt;td&gt;定义函数描述信息&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@SqlNullale&lt;/td&gt;&lt;td&gt;返回值是否可以是null&lt;/td&gt;&lt;td&gt;形参是否接收null&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@SqlType&lt;/td&gt;&lt;td&gt;返回值的SQL类型&lt;/td&gt;&lt;td&gt;形参的SQL类型&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@TypeParameter&lt;/td&gt;&lt;td&gt;定义泛型变量&lt;/td&gt;&lt;td&gt;引入依赖型参数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@LiteralParameters&lt;/td&gt;&lt;td&gt;定义字面量变量&lt;/td&gt;&lt;td&gt;引入依赖型参数&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是官网[2]的一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ExampleNullFunction&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@ScalarFunction&lt;/span&gt;(&lt;span&gt;&quot;is_null&quot;&lt;/span&gt;, calledOnNullInput = &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@Description&lt;/span&gt;(&lt;span&gt;&quot;Returns TRUE if the argument is NULL&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@SqlType&lt;/span&gt;(StandardTypes.BOOLEAN)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isNull&lt;/span&gt;&lt;span&gt;(@SqlNullable @SqlType(StandardTypes.VARCHAR)&lt;/span&gt; Slice string)&lt;br/&gt;    &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (string == &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应刚刚说到的几点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;isNull函数体有三个注解，&lt;code&gt;@ScalarFunction&lt;/code&gt;定义了函数名和&lt;code&gt;calledOnNullInput&lt;/code&gt;属性。&lt;code&gt;@Description&lt;/code&gt;定义了函数的描述字段，在Presto客户端用show functions命令可以看到函数的描述信息。&lt;code&gt;@SqlType&lt;/code&gt;描述了函数的返回值类型。这些是&lt;strong&gt;函数注解&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;形参的SQL类型是VARCHAR，Java类型是Slice。如果Slice换成其它类型，函数调用会失败。这个是&lt;strong&gt;形参注解&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回值、形参都有&lt;code&gt;@SqlType&lt;/code&gt;注解，它们定义了SQL类型。在Presto引擎层面，基本都是使用SQL类型来进行解析。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来看另外一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@ScalarFunction&lt;/span&gt;(name = &lt;span&gt;&quot;is_null&quot;&lt;/span&gt;, calledOnNullInput = &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Description&lt;/span&gt;(&lt;span&gt;&quot;Returns TRUE if the argument is NULL&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;IsNullFunction&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@TypeParameter&lt;/span&gt;(&lt;span&gt;&quot;T&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@SqlType&lt;/span&gt;(StandardTypes.BOOLEAN)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isNullSlice&lt;/span&gt;&lt;span&gt;(@SqlNullable @SqlType(&lt;span&gt;&quot;T&quot;&lt;/span&gt;)&lt;/span&gt; Slice value)&lt;br/&gt;    &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@TypeParameter&lt;/span&gt;(&lt;span&gt;&quot;T&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@SqlType&lt;/span&gt;(StandardTypes.BOOLEAN)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isNullLong&lt;/span&gt;&lt;span&gt;(@SqlNullable @SqlType(&lt;span&gt;&quot;T&quot;&lt;/span&gt;)&lt;/span&gt; Long value)&lt;br/&gt;    &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@TypeParameter&lt;/span&gt;(&lt;span&gt;&quot;T&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@SqlType&lt;/span&gt;(StandardTypes.BOOLEAN)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isNullDouble&lt;/span&gt;&lt;span&gt;(@SqlNullable @SqlType(&lt;span&gt;&quot;T&quot;&lt;/span&gt;)&lt;/span&gt; Double value)&lt;br/&gt;    &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// ...and so on for each native container type&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在函数体，多了&lt;code&gt;@TypeParameter&lt;/code&gt;&lt;strong&gt;函数注解&lt;/strong&gt;，引入了一个泛型变量&lt;code&gt;T&lt;/code&gt;，可以在&lt;strong&gt;形参注解&lt;/strong&gt;中被@SqlType引用。&lt;code&gt;@SqlType&lt;/code&gt;注解的类型声明为&lt;code&gt;T&lt;/code&gt;以后，这几个函数的&lt;strong&gt;函数签名&lt;/strong&gt;都是一样的。在&lt;code&gt;Presto&lt;/code&gt;引擎看来，这几个函数拥有相同的函数签名，是一类函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，有很多细节的问题其实需要看源码才知道需要怎么写。比如，细心的同学从上面两个例子可以发现：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;问：为什么第二个例子的&lt;code&gt;@ScalarFunction&lt;/code&gt;和&lt;code&gt;@Description&lt;/code&gt;注解是写在类名上面而不是函数名上面？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;答：写在类名上，代表这个类中的所有方法的函数签名都是一样的，由一个&lt;code&gt;ParameticScalar&lt;/code&gt;类进行管理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;问：Slice和Java的String是什么关系，需要怎么处理转换？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;答：参考其它函数的实现，可以调用&lt;code&gt;toStringUtf8()&lt;/code&gt;转换成&lt;code&gt;String&lt;/code&gt;类型再做处理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;问：哪些注解是一定要写的？哪些是可选的？哪些是在某些条件下需要同时出现的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;答：比如说&lt;code&gt;@ScalarFunction&lt;/code&gt;中的&lt;code&gt;calledOnNullInput&lt;/code&gt;属性，当形参中有以下任意注解(&lt;code&gt;@SqlNullable&lt;/code&gt;,&lt;code&gt;@BlockPosition&lt;/code&gt;,&lt;code&gt;@IsNull&lt;/code&gt;)的时候，需要指定为true，默认为false。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然Presto文档只讲了冰山一角，但是引擎内部自带了很多函数，是非常有价值的参考资料。这里有很多细节，需要看Presto源码才能得到答案。以上只是注解的使用，具体这个自定义函数后续如何被Presto引擎解析，不关注问题也不大，注解写错了大部分case也会在插件装载的时候被识别出来。推荐高阶开发者看看&lt;code&gt;ParametricScalarImplementation&lt;/code&gt;中标量函数的解析流程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 常用注解参考手册&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下总结了注解框架中的一些常用注解。建议有一定基础后作为参考来看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;@ScalarFunction&lt;/strong&gt;: 函数注解。定义函数的名称，别名，可见性，纯函数性，是否处理空值。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;元数据&lt;/th&gt;&lt;th&gt;含义&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;value&lt;/td&gt;&lt;td&gt;函数名&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;alias&lt;/td&gt;&lt;td&gt;函数别名&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;visibility&lt;/td&gt;&lt;td&gt;函数可见性&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;deterministic&lt;/td&gt;&lt;td&gt;纯函数性&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;calledOnNullInput&lt;/td&gt;&lt;td&gt;函数的形参是否可以处理空值&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;@Description&lt;/strong&gt;: 函数注解。描述函数功能的字符串。在presto客户端使用&lt;code&gt;show functions&lt;/code&gt;命令可以查看。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;@TypeParameter&lt;/strong&gt;: 函数注解、形参注解。对于函数注解，声明一个泛型变量，形参注解中的@SqlType可以使用它，在解析函数调用的时候会尝试将泛型类型和具体类型进行绑定。对于形参注解，它引入一个依赖型参数。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;@LiteralParameters&lt;/strong&gt;: 函数注解、形参注解。对于函数注解，定义一些字面量变量，长整数类型。如果有&lt;code&gt;@Constraint&lt;/code&gt;函数注解，则需要满足它定义的表达式条件。对于形参注解，它引入一个依赖型参数。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;@SqlType&lt;/strong&gt;: 函数注解、形参注解。定义形参、返回值的SQL类型。大概可以分以下几种：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;&lt;th&gt;含义&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;varchar&lt;/td&gt;&lt;td&gt;原始类型，无参数，无字面量变量或泛型变量。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;array(varchar)&lt;/td&gt;&lt;td&gt;原始类型，有一个参数varchar，无字面量变量或泛型变量。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;T&lt;/td&gt;&lt;td&gt;泛型，必须是@TypeParameter声明的泛型变量，不能带参数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;varchar(x)&lt;/td&gt;&lt;td&gt;原始类型，带参数(字面量变量)&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;@SqlNullale&lt;/strong&gt;：函数注解、形参注解。对于函数注解，表示返回值类型是否可能为空。原始类型（e.g. int）不需要注解，包装类型和其它类型需要声明该注解。对于形参注解，如果该位置的实参是null，依然执行函数体。默认情况遇到null直接返回null。参考&lt;code&gt;InterpretedFunctionInvoker&lt;/code&gt;的空值处理逻辑。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;依赖型参数&lt;/strong&gt;：一种形参注解。函数中需要用到的一些变量，从SQL语句自动推导而来。这些形参由框架处理，用户不感知。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.535687453042825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41ibcuCG1GffGc1o7dkozLwkAvc8nuO4uL8wZu0eZhUJ1oktQpDVKTxgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1331&quot;/&gt;&lt;figcaption&gt;15.contains函数&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，&lt;code&gt;contains&lt;/code&gt;函数有多种类型，但是&lt;strong&gt;函数签名&lt;/strong&gt;都是一样的。由于在函数中需要根据实际类型来调用接口读取元素，T的实际类型必须通过形参的方式传递进来，但是用户写SQL的时候并不用显式指定类型，因为它可以自动推导出来，这里涉及到methodHandle的绑定参数，就不详细展开了。总之，虽然&lt;code&gt;contains()&lt;/code&gt;有四个参数，但是用户只感知最后两个。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.4 变长参数函数&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一些变长参数的函数，比如tHive中的&lt;code&gt;parse_simple_json&lt;/code&gt;函数，在ETL任务中一次调用解多个key，是比较高效的。虽然是变长参数，但是这里的变长，是相对不同用户提交的SQL语句而言。而用户每一次提交的SQL，其实参数个数都是确定的，没有必要用变长参数，e.g. 对于一个SQL，代码中的&lt;code&gt;parse_simple_json(d4, &#x27;key1&#x27;, &#x27;key2&#x27;)&lt;/code&gt;，其实参数就是三个。函数声明为变长，但是实际中根据每个SQL语句转成定长参数。针对这种情况，Presto引擎并没有使用注解框架。而是采用了比较hack的方式，直接定义一个内部函数类，里面有一个形参为数组的业务函数。通过引擎自带的字节码生成模块，把它适配成一个定长参数函数。大概原理如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4307692307692308&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41fiakiaFQVwcRgVMRJoiaG80X81Cqb9JXCflvHKDdicYEusfpJCtVOpDO4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1690&quot;/&gt;&lt;figcaption&gt;16.字节码动态适配&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后附上标量函数注册的流程图，希望能对函数注册的流程有更直观的理解。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4776006074411541&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41GtwQLich80ukibOicib7UNlAF5NFpJlP1jD7yUqHibr4acO11yaySwAR8gQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1317&quot;/&gt;&lt;figcaption&gt;17.函数注册流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. 技术输出&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从去年下半年开始入门Presto引擎开发，接触下来感觉从零起步确实不易。虽然仔细搜索还是能找到一些不错的资料，但是Presto相关的官方文档相对于其他大数据组件来说是偏少的。比如基础的Airlift框架，官方文档仅有一句话介绍。为了降低后续同事的学习成本，这里特地把一些知识点梳理成脑图（逐步完善中），也供大家参考。大多数子节点都能用一章的篇幅来展开描述，可见快速培养出一个优秀的Presto开发者还是不太容易。以后有机会我们也会输出一系列技术文集。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.989522700814901&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41n4EjPdRBQt6F9Gz6HgUicKNDjm2FE0zvIGlhHoU7wLb6Lcia6p3Aw6rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;859&quot;/&gt;&lt;figcaption&gt;18.基础知识&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.6054054054054054&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41lXWsgn28sXeXCHvWz1REeOVlOXYEzmBdFMibTmLIw7nSVZpU4KV752Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;925&quot;/&gt;&lt;figcaption&gt;19.执行相关概念&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7. 腾讯内部应用概览&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后列出部分腾讯内部应用的Presto情况。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1 应用场景&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;TEG-大数据平台统一SQL引擎SuperSQL，Presto作为计算引擎融合的一部分，实现联邦数据访问，计算加速等功能，支持交互式数据分析场景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PCG-欧拉中台，在数据质量监控和资产洞察以及在线数据服务的数据装载中，作为计算查询引擎&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TEG/CSIG联合-云原生数据湖计算DLC，用户使用标准 SQL 即可完成对象存储服务（COS）及其他云端数据设施的联合建模、分析，无服务器架构（Serverless Presto）作为底层计算引擎&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CSIG-云日志服务CLS，扩展了大量自定义SQL函数，以丰富PB级日志实时SQL分析能力。Presto支持底层存储解耦，提供不同场景日志需求，以及异构存储联合查询&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CSIG-医疗资讯与服务部，作为业务线数据服务平台联邦查询引擎，统一查询前端语言，计划打通用户状态存储的MySQL、流水日志存储的ES、用户行为数仓的Hive/Clickhouse/Iceberg等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PCG-腾讯看点，连接部门内20余个异构数据源的联邦查询引擎，适配了腾讯内部的Hive/ES/CH/Redis等数据源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;IEG-数据中台，作为数据查询服务联邦查询，Adhoc场景执行引擎&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.2 合作生态&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;腾讯内部通过&lt;code&gt;Oteam&lt;/code&gt;的方式来组织跨BG/部门的开源协同共建。目前和Presto关系比较密切的Oteam有Alluxio、Iceberg、Impala。Alluxio缓存技术已经在TEG的部分场景落地使用了。TEG大数据团队也和Presto/Trino社区同时提出了各自的Iceberg Connector PR。Impala在腾讯灯塔平台已经有非常成熟的应用落地，未来和Presto一起加强对MPP引擎发展的探讨。期待未来Oteam组织以及其它大数据团队能有更深入的合作，助力Presto在更多业务中落地推广。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8. 后续计划&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了继续在Presto引擎层面进行深耕优化，联邦查询引擎的应用层功能需要继续丰富，还有很多用例需要去探索。基于数据分析同学的反馈，很多复杂的预处理逻辑以往需要spark scala或者pyspark进行处理，现在基本都可以用Presto代替了，后续如果能把模型训练等调包流程整合到一起，也许能够提供上手成本更低的数据分析体验，也是一个值得探索的方向。最后，我们希望在服务好业务的前提下，进行一系列高质量的技术输出来提升部门的技术影响力。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;结合业务场景，完成引擎和相关连接器的优化改造&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;丰富联邦查询引擎应用层功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据科学引擎&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;强化技术输出&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9. 新书推荐&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;封面第一印象：Presto运行SQL，就像青蛙吃虫子一样快？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本书的内容质量是毋庸置疑的。对于初学者来说，左手官网文档，右手《Presto实战》进行入门应该是标准姿势。其行文的层次性、结构性，内容的完整性、权威性，对高手来说是一本非常好的字典。推荐给有兴趣的同学～&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Matt Fuller、Manfred Moser、Martin Traverso 著&lt;br/&gt;张晨 黄鹏程 傅宇 译&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;SQL领域重磅力作，Presto官方指南&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Presto创始团队、Kafka联合创作者推荐&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多位国内一线技术大咖力荐&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;亚马逊全五星好评&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8472222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41pnpzFJ3lUSvCSWibcqogQqZyAB4iav0YhxW5gBibtzuFcWdEcsibyJAnhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.402659069325736&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD4146vMgK1kPLq2icBfbHMJ52xzgnj3sCrqwHyj29ibZQUqicujgXUGbquMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1053&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;文章封面介绍：CH-54 Tarhe “塔赫”运输直升机。虽然没有运输舱，仅是一个飞行载具，但是它可以灵活运输集装箱、火炮、轻型载具、直升机等物资，如果真要丢个炸弹，也是可以的。这和Presto存算分离的思想如出一辙，结合当前部门特性选择了挂载医疗舱的“塔赫”作为封面。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>