<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>27d538b8454ac774b86b28fce52ee20d</guid>
<title>过去的 2020 年，我经历了什么？</title>
<link>https://toutiao.io/k/r56x1n3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;2020 年，终于过去了！过去的一年，你经历了什么？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;感谢开发者头条上的分享者们&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;复制文章/项目链接，打开开发者头条 App，分享只需 3 秒！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;我们选取了其中一些作者的分享，希望在新的一年，你我都可以成为更好的自己。&lt;br/&gt;我的微信号：&lt;/span&gt;&lt;span&gt;toutiaoio007&lt;/span&gt;&lt;span&gt; ，欢迎加我，拉你入群！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;weapp_text_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wxdf0163eaa1cf1699&quot; data-miniprogram-path=&quot;pages/articles/detail?id=2161763&amp;amp;share=1&quot; data-miniprogram-nickname=&quot;开发者热榜&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;0&quot; href=&quot;&quot;&gt;&lt;span&gt;2020 年，我在编程时遇见的几个好物&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;年年都写年终总结，确实没什么新意，虽然今年也做了总结，但写完之后总觉得过于悲观，只是到了年底应该要有些什么表示，想着今年是该换个花样了，于是便有了这篇。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这篇文章介绍的，有框架，有工具，有软件，都是自己在编程时遇到的有用的，而且自己比较喜欢的，这里分享给大家。(雇个城管打天下)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;weapp_text_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wxdf0163eaa1cf1699&quot; data-miniprogram-path=&quot;pages/articles/detail?id=2161947&amp;amp;share=1&quot; data-miniprogram-nickname=&quot;开发者热榜&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;0&quot; href=&quot;&quot;&gt;&lt;span&gt;靠写作杀出一条 “血” 路：我的 2020 年终总结&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2012 年到 2020 年，持续 8 年坚持博客输出，鬼知道经历了什么？！&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我天资 “愚笨” 一些，并不聪明。经历过鲜有人经历的：中考失败、高考失败、考研失败。但，还是咬牙都挺过来了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;11 年前的考研失败，我买的唯一一本书就是俞敏洪的《永不言败》，二战前我分析自己的利弊得失，写了很详细的备战战略。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;白天工作晚上备战，几乎没有耽误一天上班时间，乏力的时候就听俞敏洪的小草和大树、河流的演讲鼓励自己，热泪盈眶并嚎啕大哭之后，继续刷题备战。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这也是很多读者留言反馈：“怎么你的文章都多少有点励志的味道？”，经历和阅历使然。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;人和人的经历不同，那些越苦的经历越是刻骨铭心，那些心底的反思更是会指引我们前行。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之前也说过，当时陆陆续续写过几个厚本子的内容，现在还 “陈列” 在老家的橱子里，每每想起，都激动万分。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当时，不觉得有什么？当我把：写作、积累、坚持、长远串联起来的时候，仿佛就找到了人生的意义和方向。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总得给后代留下点什么吧？财富那是身外之物，没有意义。唯有文字是永恒的精神财富、价值没法也不能用金钱衡量。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当看到《曾国藩家书》、《傅雷家书》、计算机科学家吴军老师的《态度》后，我更坚信写作的意义重大。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，从去年开始，每到我家孩子生日前夕，我都会写一篇生日寄语，并且，这份寄语我承诺至少会写 18 年。特殊的日期，如：新冠复工前夕还会加一篇，完完整整的通过文字记录下当时的想法。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;的确，短期看真没有太大意义，但是 18 年甚至 N 多年以后，这终将变成传家宝、可传承的家族财富。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那为什么要杀出 “血” 路呢？是因为：比我厉害的人、比我们聪明的人多的去了，人外有人，天外有天。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举个例子：我有幸跟黑客一起共事过，和黑客相比，我们所谓的开发无非是相对小儿科。道理是相通的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比不过怎么办？那就学呗！&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;学不会怎么办？那就多练习几遍，反复积累呗！&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;做长远的事儿，在大方向正确的前提下苦哈哈的坚持，然后等待时间的回报！(铭毅天下001)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;weapp_text_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wxdf0163eaa1cf1699&quot; data-miniprogram-path=&quot;pages/articles/detail?id=2162111&amp;amp;share=1&quot; data-miniprogram-nickname=&quot;开发者热榜&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;0&quot; href=&quot;&quot;&gt;&lt;span&gt;YourBatman 2020 年感悟关键词：科比、裁员、管理层、活着&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今年是近十年最差的一年，却是将来十年最好的一年。与其忧心忡忡，惴惴不安，倒不如多多思考、多多学习。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后想说一句：滚蛋吧，2020。虽然这句话说得毫不客气，但 who care？毕竟 2020 也没对咱客气过，不是麽！(YourBatman)&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;加入「码农周刊 VIP 会员」，与上市公司 CTO 一起成长！&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利，你值得拥有！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;原价 365 元/年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;，现价仅需 108 元！&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;260&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;350&quot; data-ratio=&quot;1.3478260869565217&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav9pqkGat4y9Liby9Umh4V4ssMvlqB4u4iau7xTfKzerArGc4SOo34g5tgibFAhPWNrlbicpraIr2RBNeQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c96d40c5001975a1791e5a1bb2ac414b</guid>
<title>2021 年管理 Monorepo 代码库的 11 种出色工具</title>
<link>https://toutiao.io/k/tjw1lqq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.531&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMPbOLhQAHkTo9fY9ZKPtVlgmathcJJfb0mFnia0PLcVzEPxZa0eMibibDt1qicbEwwCLogcXw9E6XcUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;如今，许多工具可以在20个不同的文件夹中运行“npm install”和“npm run build”。但是，并不是所有的工具都能促进正确的monorepo。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;促进一个正确的单体开发意味着要解决一些挑战，比如为分离的模块运行测试和构建过程，能够从项目中独立发布模块，以及管理变更对项目中每个受影响的依赖模块的部分影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;挑战的清单还在继续，甚至包括“琐碎”的事情，比如你如何管理issues和PRs，这可能会随着你的开发规模而变得困难。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;请注意，&lt;strong&gt;一个monorepo不是一个整体的应用程序(!)&lt;/strong&gt; ——它不是一次性构建或部署的，它是一组单独开发的应用程序。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是 monorepo？&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;国庆期间10月5日尤大公开了vue3.0已完成的源码，也是采用了monorepo管理模式，看来monorepo确实有其独到的优势。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;monorepo是一种将多个package放在一个repo中的代码管理模式，摒弃了传统的多个package多个repo的模式。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;目前 Babel, React, Angular, Ember, Meteor, Jest等许多开源项目都使用该种模式来管理代码。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;解决的问题&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;多个repo难以管理，编辑器需要打开多个项目；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;某个模块升级，依赖改模块的其他模块需要手动升级，容易疏漏；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;公用的npm包重复安装，占据大量硬盘容量，比如打包工具webpack会在每个项目中安装一次；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对新人友好，一句命令即可完成所有模块的依赖安装，且整个项目模块不用到各个仓库去找；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;带来的问题&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;所有package代码集中在一个项目，单个项目体积较大；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;所有package代码对所有人可见，无法做权限管理；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;还不知道monorpo的同学可以阅读以下文章（&lt;/span&gt;&lt;span&gt;&lt;strong&gt;带链接版文章请点击文末左下角&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;阅读原文&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;链接&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;精读《Monorepo 的优势》&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Vue3.0中的monorepo管理模式的实现&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Lerna包管理&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;在这篇综述中，我收集了一些世界上最好的工具来构建一个“monorepo”，你可以在一个项目里面构建多个模块，并且有不错的开发者体验，可以扩展。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个列表并没有进行排名，旨在根据每个工具的优点来概述其优势。希望能帮助你节省时间，找到合适的工具。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;欢迎在下方评论，分享自己的心得。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. Yarn Workspaces&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Yarn Workspaces&lt;/strong&gt; 的目标是简化与monorepos的工作，以更明确的方式解决 &lt;/span&gt;&lt;code&gt;&lt;span&gt;yarn link&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的一个主要用例。你的依赖关系可以链接在一起，这意味着你的工作空间可以相互依赖，同时总是使用最新的代码。这也是比 &lt;/span&gt;&lt;code&gt;&lt;span&gt;yarn link&lt;/span&gt;&lt;/code&gt;&lt;span&gt;更好的机制，因为它只影响你的工作空间树而不是你的整个系统。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Workspaces有助于解决一些问题，使其成为一个很好的单兵装备。&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;它设置了一个单一的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;node_modules&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，不需要在项目中的不同包中重复或克隆依赖关系。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;你的所有项目依赖都将被安装在一起，从而给Yarn更大的空间来更好地优化它们。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Yarn将使用一个单一的锁文件，而不是为每个项目使用不同的锁文件，这意味着更少的冲突和更容易的审查。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;它允许你改变你的一个软件包的代码，并让使用它的其他软件包立即看到这些变化。对一个包的源代码的任何修改都会立即应用到其他包中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;因此，Yarn Workspaces是一个非常强大的组合，可以和列表中的几乎所有工具，特别是Bit、Nx和Lerna等工具一起使用，作为你的monorepo管理抽象的下层。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不过，你也可以直接用workspaces发布。当一个工作空间被打包到一个存档中时，它会动态地将任何 &lt;/span&gt;&lt;code&gt;&lt;span&gt;workspace:&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 依赖关系替换为一个包的版本，因此您可以将结果包发布到远程注册表，而无需运行中间步骤——消费者将能够像使用任何其他包一样使用发布的工作空间。太酷了！&lt;/span&gt;&lt;/section&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1608912879699&quot; data-category_id_list=&quot;1|16|24|26|29|36|37|42|43|48|5|50|51|53|54|55&quot; data-id=&quot;1608912879699&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;参考阅读&lt;/strong&gt;：基于lerna和yarn workspace的monorepo工作流&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. Bit&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Bit&lt;/strong&gt;是用于构建模块化项目的下一代工具。这是一种新的、令人兴奋的单仓库方法，在这种方法中，由同一个项目（同一个Bit工作空间）管理的模块实际上分布在不同的范围内，而不考虑仓库。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Bit让你以完全解耦的方式拆分模块的开发，享受简单的、整体的开发体验来协调一切。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4863588667366212&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMPbOLhQAHkTo9fY9ZKPtVlZ71DKI7ib7Vdme0EV91bphF9Un42Z0Xd1MS7c8Nib3SBm5cUicYwZl5Aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1906&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;使用bit，你可以在你的项目中解耦组件，这样每个组件都是独立开发、构建、测试和发布的。每个组件都是使用特殊的环境进行开发和构建的，这些环境是可扩展和可重用的，这样你就可以快速定制和再次使用它们。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Bit的工作空间管理着项目中所有组件之间的关系。当你对任何组件进行更改时，Bit会单独构建和测试它，并将更改传播到依赖关系图中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;组件可以作为独立的包，批量发布到NPM和/或bit.dev平台，用于协作、消费和文档。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5621428571428572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMPbOLhQAHkTo9fY9ZKPtVln9JK7F1ziaPQurm6Ne7Ov207RsoicXLia0zggiaiaGRXx8SVykbfx2iafkvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;Bit的UI可以帮助你查看你的monorepo的开发情况。当你编写代码时，每个组件都会被记录、测试、构建等，你可以通过实时反馈和热重载直观地看到正在发生的事情。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Bit提供了解耦的开发环境--可重用和可定制的模块，这些模块将独立组件整个生命周期所需的不同服务配置和“捆绑”在一起，如编译、捆绑、测试、磨合、文档等。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1819444444444445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMPbOLhQAHkTo9fY9ZKPtVl2ib6kwC7ib8A2xXy2rO6SiauW7EIuQeuuc9qvAHoQytN4FiauAbQ1pHL2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;figcaption&gt;Bit的工作空间以简单而全面的方式解耦组件开发&lt;/figcaption&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;掌握组件图&lt;/strong&gt;——Bit定义、管理并帮助你利用项目中所有组件之间的关系。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;图形驱动的构建&lt;/strong&gt;——当您对某个组件进行更改时，Bit会自动检测依赖于它的其他组件，并“知道”只构建依赖组件的受影响的图形。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“图形驱动的构建”也意味着，万一一个组件被标记了新的发布版本（在被导出到Bit的云端之前），Bit不仅会在每个受影响的组件上运行构建，而且会确保给它们标记一个新的发布版本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;隔离的测试和构建&lt;/strong&gt;——每个组件都是在项目外部隔离地构建和测试的，因此您可以确切地看到更改的影响。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;组件构建管道&lt;/strong&gt;——您可以在可重用的管道中构建作业，该管道可应用于项目或所有项目中的所有组件。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;批量发布&lt;/strong&gt;——在Bit monorepo中开发的每个组件都可以作为一个独立的包发布。Bit去掉了配置每个组件的“package.json”和其他设置文件的所有开销。你要做的就是运行&#x27;bit tag&#x27;，这样Bit就会自动给所有修改过的组件打上版本补丁（支持semver规则），然后批量发布修改。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;可重复使用的文档模板&lt;/strong&gt;——每个组件都使用可重复使用和可定制的模板进行文档化，Bit为您自动完成大部分工作。用MDX工作？也许还可以添加一些可视化的例子？没问题。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5621428571428572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMPbOLhQAHkTo9fY9ZKPtVl2KHXlicMq9Ber8G4oY1btKozhWCLibe3OoopJE3q8GayJ7Y0UomI0Xcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;独立渲染的组合&lt;/strong&gt;——每个组件都是完全独立渲染的，完全在项目之外渲染，渲染的视觉效果(在编写代码时热重新加载)成为每个组件文档的一部分。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. NX&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;NX&lt;/strong&gt;是一套先进的可扩展的开发工具，适用于monorepos，非常强调现代全栈Web技术。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8225152129817445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMPbOLhQAHkTo9fY9ZKPtVl9NscKqDhTLDbsXe9h5Dqia8gQpaPrXMQLGzvYibNgOHKO0IHUhJhBtfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;986&quot;/&gt;&lt;figcaption&gt;空NX monorepo&lt;/figcaption&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;NX的目标是通过CLI（带编辑器插件）提供整体的开发体验，并提供可控代码共享和一致代码生成的功能。它还提供了增量构建，因此它不会在你的每一次提交中重建和重新测试所有内容，从而加快构建时间。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0230263157894737&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMPbOLhQAHkTo9fY9ZKPtVlsKS5ewlyemGweRxd3BvdLrnV2v4A4HkQjibI2MlfaahYic9LbMrF8hMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;608&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;有了Nx，你可以使用你喜欢的框架，集成你可能已经在使用的现代工具。例如，NX可以让你使用与Cypress、Jest、Typescript、Prettier和其他工具的开箱即用的集成。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;NX团队还提供了NX云，通过云中的智能计算记忆和更快的构建来帮助使用NX的团队更快地交付。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6905882352941176&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMPbOLhQAHkTo9fY9ZKPtVlsRQxI68bUDnCe0B8XTk34kT9gYsSCwgaN2q4hmmf2BnBkNCuibZJfJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;850&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6725978647686833&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMPbOLhQAHkTo9fY9ZKPtVl6Y7KrPw86caS2cOlWPLFCsXiaYUrnAevvuXoRgQ0rIIyKKXpULX5icbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;843&quot;/&gt;&lt;figcaption&gt;8&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. Rush&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;Rush是由微软+开源的一个强大的monorepo基础设施，它的目的是帮助你在一个仓库中构建和发布许多包。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40959119496855345&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMPbOLhQAHkTo9fY9ZKPtVlYibe1NyiczA05mWcHO7AgCURAZGcFhjarzrOOhGAOsiaq9jEepjctdsmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1272&quot;/&gt;&lt;figcaption&gt;登陆页面和一些组件，两个项目，一个仓库&lt;/figcaption&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;rush的一些主要功能包括一个单一的NPM安装（也可以和Yarn和pnpm一起使用），所以你可以将所有项目的所有依赖关系安装到一个共同的文件夹中，使用隔离的符号链接为每个项目重新构建一个准确的“node_modules”文件夹。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这也有助于确保没有幻影依赖，所以你不会意外地导入一个在package.json中缺失的库，也不会在node_modules中发现10份lib的依赖重复。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3042198233562316&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMPbOLhQAHkTo9fY9ZKPtVlN7Kjpoe7Kbzrte093BoBicticFvn7TWZJOSGXJcj4Tb5fia8kcvnXB8LA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1019&quot;/&gt;&lt;figcaption&gt;Rush交互式CLI不错&lt;/figcaption&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;自动本地链接意味着你所有的项目都会自动地相互建立符号链接，当你做了一个改变，你可以看到下游的效果，而不需要发布任何东西，也没有任何 &lt;/span&gt;&lt;code&gt;&lt;span&gt;npm link&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的麻烦。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/WYoaOn5t0AMPbOLhQAHkTo9fY9ZKPtVl3j0U1wS2AWkJIwc2LCJpmJmcYdLlxLFDP01XDjmI5ibcq0IicNkxl1yQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;Rush独特的安装策略为你的所有项目生成一个快速安装的单一收缩/锁定文件。Rush会检测你的依赖关系图，并以正确的顺序构建你的项目，所以如果两个包之间没有直接的依赖关系，Rush会将它们作为单独的进程并行构建。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你只打算使用你的repo中的几个项目，Rush提供了子集和增量构建，所以 &lt;/span&gt;&lt;code&gt;&lt;span&gt;rush rebuild --to &amp;lt;project&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 只对你的上游依赖进行干净的构建。在你做了修改之后，&lt;/span&gt;&lt;code&gt;&lt;span&gt;rush rebuild --from &amp;lt;project&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 只对受影响的下游项目进行清理。而 &lt;/span&gt;&lt;code&gt;&lt;span&gt;rush build&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 则提供了强大的跨项目增量构建，Rush甚至可以通过分离项目的版本来处理循环依赖关系。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当你想发布的时候，Rush支持批量发布，所以它会检测哪些包有变化，自动跳转所有相关的版本号，并在每个文件夹中运行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;npm publish&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Rush还有助于实施和执行发展政策。例如，当创建PR时，你可以要求开发人员提供受影响项目的主要/次要/补丁日志条目，这些条目随后将在发布时汇总到一个变更日志文件中。它还可以帮助你执行诸如发布前的审查、特定的依赖版本等东西。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5. Lerna&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;Lerna（以多头野兽Hydra的家命名）是一个“用于管理带有多个包的JavaScript项目的工具”。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3710280373831776&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMPbOLhQAHkTo9fY9ZKPtVlMUvG0nlESfuPf98nE6nN7BHHWjeQp07l2C0MyOwQDqG37FQlxJtHNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1070&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;Lerna的创建是为了解决Babel的多包问题，以优化使用git和npm管理多包仓库的工作流程，它本质上是一种工具和脚本，可以有效地管理和发布许多独立版本的包在一个Git仓库中。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;my-lerna-repo/&lt;br/&gt;  package.json&lt;br/&gt;  packages/&lt;br/&gt;    package-1/&lt;br/&gt;      package.json&lt;br/&gt;    package-2/&lt;br/&gt;      package.json&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;Lerna 的两个主要命令是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;lerna bootstrap&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;lerna publish&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;code&gt;&lt;span&gt;bootstrap&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 会将 repo 中的依赖关系连接在一起，&lt;/span&gt;&lt;code&gt;&lt;span&gt;publish&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 会帮助发布任何更新的包。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;您可以使用以下两种模式之一来管理项目：固定(Fixed)或独立(Independent)。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;固定模式的Lerna项目是以单一的版本行来操作的，版本是保存在你的项目根目录下的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;lerna.json&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件中的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;version&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 键。当您运行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;lerna publish&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 时，如果一个模块在上次发布后被更新，它将被更新到您发布的新版本。这是Babel目前使用的模式。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8942857142857142&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMPbOLhQAHkTo9fY9ZKPtVliaC6MBXvQKE3Hicudud6hE6F2wAt6WmGoe9QRmfMYX93IDIFic2c4NnNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;figcaption&gt;一个带有Yarn Workspaces的Lerna例子&lt;/figcaption&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;独立模式Lerna项目允许维护者相互独立地增加包的版本，每次发布时，你都会收到一个提示，提示你每一个已经改变的软件包，以指定它是一个补丁，小的，大的或自定义的变化。独立模式可以让你更具体地更新每个包的版本，对于一组包来说是有意义的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“lerna.json”文件是一个匹配包含 &lt;/span&gt;&lt;code&gt;&lt;span&gt;package.json&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的目录的globs列表，这也是lerna识别“叶子”包的方式(相对于管理整个repo的开发依赖和脚本)。例子：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;version&quot;&lt;/span&gt;: &lt;span&gt;&quot;1.1.3&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;npmClient&quot;&lt;/span&gt;: &lt;span&gt;&quot;npm&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;command&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;publish&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;ignoreChanges&quot;&lt;/span&gt;: [&lt;span&gt;&quot;ignored-file&quot;&lt;/span&gt;, &lt;span&gt;&quot;*.md&quot;&lt;/span&gt;],&lt;br/&gt;      &lt;span&gt;&quot;message&quot;&lt;/span&gt;: &lt;span&gt;&quot;chore(release): publish&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;registry&quot;&lt;/span&gt;: &lt;span&gt;&quot;https://npm.pkg.github.com&quot;&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;&quot;bootstrap&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;ignore&quot;&lt;/span&gt;: &lt;span&gt;&quot;component-*&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;npmClientArgs&quot;&lt;/span&gt;: [&lt;span&gt;&quot;--no-package-lock&quot;&lt;/span&gt;]&lt;br/&gt;    }&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;packages&quot;&lt;/span&gt;: [&lt;span&gt;&quot;packages/*&quot;&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;即使你不打算发布到NPM，Lerna仍然可以在monorepo中帮助管理版本管理和常见的开发任务。&lt;/span&gt;&lt;/section&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1608912910198&quot; data-category_id_list=&quot;1|16|24|26|29|36|37|42|43|48|5|50|51|53|54|55&quot; data-id=&quot;1608912910198&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;6. Bazel构建系统 (Google)&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;谷歌推出了&lt;strong&gt;Bazel build system&lt;/strong&gt;，它是一个类似于Make、Maven和Gradle的开源构建和测试工具，使用的是人类可读的高级构建语言。Bazel支持多种语言的项目，并为多种平台构建输出。它支持大型单一仓库中的大型代码库或跨多个仓库的大型代码库和大量用户。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6398916967509025&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMPbOLhQAHkTo9fY9ZKPtVlHfiblTpWUV1hWnPyThc8geefmxNw0daU1Lhpba2aWHEOgmRXRIghBSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1108&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;Uber开发者使用Bazel来构建他们的Go monorepo。Uber用Go编写了大部分的后端服务和库，在2018年，这些服务和库都被归纳到一个大型的Go monorepo中，现在有超过10万个文件。Bazel让这个项目得以扩展，缩短了构建时间，并支持其发展。&lt;/span&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;这是一个不错的小型开源项目，以Bazel作为演示：thundergolfer/example-bazel-monorepo&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;Bazel被设计成大规模工作，并支持跨分布式基础设施的增量密封构建，这是大型代码库所必需的。有了Bazel的远程缓存，构建服务器还可以共享它们的构建工件。Bazel缓存所有以前完成的工作，并跟踪对文件内容和构建命令的更改。只有在包或包的依赖关系发生更改时，才构建和测试包。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Bazel可以在Linux、macOS和Windows上运行。Bazel可以从同一个项目为多个平台构建二进制文件和可部署的包，包括桌面、服务器和移动设备。支持许多语言，你可以扩展Bazel来支持任何其他语言或框架。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7. Buck构建系统 (Facebook)&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;Buck是一个鼓励创建由代码和资源组成的小型可重用模块的构建系统，支持不同平台上的各种语言。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4409090909090909&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/WYoaOn5t0AMPbOLhQAHkTo9fY9ZKPtVl4ZdeN4gTySL7rUia4HMhqHBHzZ8JTHr3Ed9TpSQc9by7AfKy5lLph2A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;440&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;它是由Facebook开发和使用的，作为FB单体的官方构建系统，由于被Uber开发者等团队使用，大大缩短了构建时间，因此名声大噪。而AirbnbEng的团队则将构建速度提高了50%，将应用程序缩小了30%。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5209125475285171&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/WYoaOn5t0AMPbOLhQAHkTo9fY9ZKPtVlT6vhuGVeLfNMxrnRPUsAvvHia12WAm56LTicjZ9hqfVUthDboJWEHlHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;526&quot;/&gt;&lt;figcaption&gt;Uber凭借buck获得了更好的构建结果&lt;/figcaption&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;Buck被设计用来构建一个monorepo，而对monorepo设计的支持激发了Buck对cell和项目的支持。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Facebook的经验是，将所有的依赖关系维护在同一个版本库中，可以更容易地确保所有开发者拥有正确的代码版本，并简化了进行原子提交的过程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Buck常用于Android和iOS开发。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8. Pants构建系统(Twitter)&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;2014年，Twitter推出了名为Pants的monorepo构建系统。今天，在v2版本上，Pants的目标是成为一个快速、可扩展的构建系统，以适应不断增长的代码库。目前，它的重点是Python，很快就会支持其他语言。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7692307692307693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/WYoaOn5t0AMPbOLhQAHkTo9fY9ZKPtVlJujAxKq0HZZyMsawSKPzI7VsqOh66Kibibt7LibybcDZu6baXdmNoj0KQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;884&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;Pants使用细粒度的工作流，并将每个工作单元与副作用隔离，因此可以利用所有可用的内核。Pant的一些最佳特性包括明确的依赖建模、细粒度的无效化、共享结果缓存、并发执行、远程执行，以及通过插件API的可扩展性和可定制性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Pants引擎是用Rust写的，为的是性能。构建规则是用类型化的Python 3写的，为了熟悉和简单。该引擎的设计使得细粒度的无效化、并发性、密封性、缓存和远程执行自然发生，而无需规则作者的干预。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;9. Please构建系统&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Please&lt;/strong&gt;是一个跨语言的构建系统，强调高性能、可移植性、可扩展性和正确性。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.36745886654478976&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMPbOLhQAHkTo9fY9ZKPtVlgg5jbnLboPKcDOQGVkZ8icS8DXm7pdIgvvdwRSzuMxgXUGkawW7RL4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1094&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;请确保构建步骤是在自己的密封环境中执行的，只能访问被赋予权限的文件和env变量。增量构建意味着它只构建它需要的东西，它还提供了任务并行性，以及分布式缓存，以实现大规模的可靠和高性能的构建系统。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Please的目标也是专注于开发体验，所以你可以享受一个常用的CLI，并为使用自动完成的常见任务定义别名。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Please用Go编写，Please提供所有这些用户体验，没有运行时依赖。并且，没有需要处理太多配置的单个大工作区文件。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;10. Oao&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;Oao并不是列表中最成熟、最丰富、最容易使用的工具，但它还是很有趣。它是一个基于Yarn的，有意见的monorepo管理工具，p提供monorepo功能，如安装所有的依赖关系，添加/删除/升级子包的依赖关系，验证版本号，确定更新的子包，一次性发布所有的东西，更新变更日志等。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8139904610492846&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/WYoaOn5t0AMPbOLhQAHkTo9fY9ZKPtVlUZk40lQ86HJvUgaQVLW3XjYFLexpYNS2icrjhd5aVVbTiaT3JoeV30Jw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;629&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;Oao可以让你在所有子包上运行命令或 &lt;/span&gt;&lt;code&gt;&lt;span&gt;package.json&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 脚本，串行或并行，可选择遵循反向依赖树。而且，它支持yarn workspaces，从整体上优化了monorepo依赖树，简化了bootstrap以及依赖的添加/升级/删除。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;支持非单包发布：从&lt;em&gt;oao&lt;/em&gt;’s的发布前检查、标签、版本选择、变更日志更新等方面受益，也可以在你的单包、非单包中使用。需要注意的是，Oao使用的是同步版本方案，所以在根级的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;package.json&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中配置了一个主版本，而子包也将与该版本同步。你可以在这里尝试一下。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;11. Bolt&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;Boltpkg旨在成为一个“超级功能JavaScript项目管理工具”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Bolt在Yarn的基础上实现了workspaces的概念。Bolt CLI在很大程度上是Yarn CLI的替代品，你可以在任何Yarn项目中使用它。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们知道，workspaces是嵌套在一个更大的项目/repo中的，每个workspaces都可以有自己的依赖关系，有自己的代码和脚本。workspaces也可以归入子目录进行组织。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用Bolt，你可以一次安装所有这些包的依赖关系（而且你可以做得非常非常快）。而且，当你从一个工作区指定一个依赖关系到另一个工作区时，它将被链接到源代码。这样，当你去测试你的代码时，你所有的变化都会被一起测试。&lt;/span&gt;&lt;/section&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;来源：https://blog.bitsrc.io/11-tools-to-build-a-monorepo-in-2021-7ce904821cc2&lt;br/&gt;&lt;/span&gt;&lt;span&gt;作者：&lt;/span&gt;&lt;span&gt;Jonathan Saring&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;粉丝福利&lt;/h4&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;149期留言+在看幸运用户：暂无&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;临走前留下，&lt;span&gt;今天的福利&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;福利1：&lt;/span&gt;&lt;span&gt;&lt;span&gt;《MongoDB 4.0从入门到达人》&lt;/span&gt;&lt;span&gt;获取资源请在公众号对话框中回复关键字：&lt;/span&gt;&lt;span&gt;043，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;如果没有关注请扫下面的二维码。更多福利资料请查看公众号菜单&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;福利2：&lt;/span&gt;&lt;span&gt;在看+留言&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;我随机抽取一位认真留言的小伙伴，给他发一个红包奖励&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;最近文章&lt;/h4&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;点赞 + 在看 + 留言，下一个幸运儿就是你！&lt;br/&gt;走心的分享更容易被抽中~&lt;/span&gt;&lt;br/&gt;&lt;span&gt;开奖时间 下期文末&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5555555555555556&quot; data-type=&quot;png&quot; data-w=&quot;900&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0APOE4dXIpvXLgmGfqHMfYFFGudrHkx4trR7YbXKKmNCd3fJRlY56qIUibCibq00k2kky5DdPxrJCyWA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-type=&quot;gif&quot; data-ratio=&quot;0.1732283464566929&quot; data-w=&quot;635&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/aVp1YC8UV0fXSy8oK0h6qL36nlWgib6lHDTj0Ykkiab2FufBJIumwMrDEBZ1wHteh6pzsQiaP4007ox4ichic8pNw3Q/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>26c53f1f4eb9926ba6c7578311457144</guid>
<title>Hadoop 框架：Yarn 基本结构和运行原理</title>
<link>https://toutiao.io/k/xdig57t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1&gt;&lt;span&gt;一、Yarn基本结构&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;Hadoop三大核心组件：分布式文件系统HDFS、分布式计算框架MapReduce，分布式集群资源调度框架Yarn。Yarn并不是在Hadoop初期就有的，是在Hadoop升级发展才诞生的，典型的Master-Slave架构。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6222222222222222&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvC88S3yYZxNkRAZ9zGFYqhtpeOrIBlFOErd2GgY6v09wLsaWVYwibayj6Y7Z18bwSTOjadzAnpgEKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1260&quot;/&gt;&lt;/p&gt;&lt;p&gt;Yarn包括两个主要进程：资源管理器Resource-Manager，节点管理器Node-Manager。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;资源管理器&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通常部署在独立的服务器，处理客户端请求；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;处理集群中的资源分配和调度管理；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;节点管理器&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;管理当前节点上的资源；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;执行处理各种具体的命令；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;监视节点资源情况，并上报资源管理器；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;ApplicationMaster&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;提供容错能力，切割数据；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;给应用程序申请资源并分配任务；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Container&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Yarn中的一个动态资源分配的概念；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;容器包含了一定量的内存、CPU等计算资源；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由NodeManager进程启动和管理；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;&lt;span&gt;二、基本执行流程&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5328185328185329&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvC88S3yYZxNkRAZ9zGFYqhtqojZ7f2QGVs0LDuU75HUHOfylsdXyGcq6aakcE9sibPRqmgpq47FzQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1036&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;向Yarn提交MapReduce应用程序程序进行调度；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;RM组件返回资源提交路径和ApplicationId;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;RM进程NM进程通信，根据集群资源分配容器；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将MRAppMaster分发到上面分配的容器上面；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;运行所需资源提交到HDFS上申请运行MRAppMaster；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;RM经过上述操作把客户端请求转换为Task任务；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;容器中运行的就是Map或者Reduce任务；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;任务在运行期间和MRAppMaster通信上报状态；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;任务执行结束后进程注销并且释放容器资源；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;MapReduce应用开发遵循Yarn规范的MapReduceApplicationMaster，所以可以在Yarn上运行，其它计算框架如果也遵守该规范，这样就实现资源的统一调度管理。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、资源调度器&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;调度器的基本作用就是根据节点资源的使用情况和作业需求，将任务调度到各个节点上执行。单理解任务队列的话关键的因素有如下几个：进出方式，优先级，容量等。&lt;/p&gt;&lt;p&gt;Hadoop作业调度器主要有三种：FIFO、CapacityScheduler和FairScheduler，默认的资源调度器是CapacityScheduler。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;先进先出调度器&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;FIFO一种批处理调度器，调度策略先按照作业的优先级高低，再按照到达时间的先后选择被执行的作业。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;容量调度器&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;CapacityScheduler支持多个队列，每个队列可配置一定的资源量，每个队列采用FIFO调度策略，计算队列中正在运行的任务书和计算资源的比值，选中比值小相对空闲的队列，然后安装作业优先级和提交时间的排序。为了防止同一个用户的作业独占队列中的资源，该调度器会对同一用户提交的作业所占资源量进行限定。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.38140417457305503&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvC88S3yYZxNkRAZ9zGFYqhtFRHze3FvdBVAicjcfzcg7icf2OGenDNzd6clNYGH42AIDZqoyyIKJBibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1054&quot;/&gt;&lt;/p&gt;&lt;p&gt;例如上面图例，假设100个slot分为三个队列(ABC)，按照如下分配规则：队列A给20%的资源，队列B给50%的资源，队列C给30%的资源；三个队列都按照任务的先后顺序依次执行，上面的job11、job21、job31是最先运行，也是并行运行。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;公平调度器&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;和容量调度器原理类似，支持多队列多用户，每个队列中的资源量可以配置，同一队列中的作业公平共享队列中所有资源。&lt;/p&gt;&lt;p&gt;比如有三个队列(ABC)，每个队列中的job按照优先级分配资源，优先级越高分配的资源越多，但是每个job都会分配到资源以确保公平。在资源有限的情况下，每个job理想情况下获得的计算资源与实际获得的计算资源存在一种差距,，这个差距就叫做缺额。在同一个队列中，job的资源缺额越大，越先获得资源优先执行，作业是按照缺额的高低来先后执行的。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、源代码地址&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https:&lt;span&gt;//github.com/cicadasmile/big-data-parent&lt;/span&gt;&lt;br/&gt;GitEE·地址&lt;br/&gt;https:&lt;span&gt;//gitee.com/cicadasmile/big-data-parent&lt;/span&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3783359497645212&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCjMheLZtcM2iaVMBOpIUKR4CDRCG9FLT5K6NmGXvG7exrW0TSuDjnTKJQ5PDq8j8Y7PHDd17Z3gicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>45286945dae4f7341dea57382ee62654</guid>
<title>一文读懂微内核架构</title>
<link>https://toutiao.io/k/c7mebu3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是微内核架构？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微内核是一种典型的架构模式 ，区别于普通的设计模式，架构模式是一种高层模式，用于描述系统级的结构组成、相互关系及相关约束。微内核架构在开源框架中的应用非常广泛，比如常见的 ShardingSphere 还有Dubbo都实现了自己的微内核架构。那么，在介绍什么是微内核架构之前，我们有必要先阐述这些开源框架会使用微内核架构的原因。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;为什么要使用微内核架构？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微内核架构本质上是为了提高系统的扩展性 。所谓扩展性，是指系统在经历不可避免的变更时所具有的灵活性，以及针对提供这样的灵活性所需要付出的成本间的平衡能力。也就是说，当在往系统中添加新业务时，不需要改变原有的各个组件，只需把新业务封闭在一个新的组件中就能完成整体业务的升级，我们认为这样的系统具有较好的可扩展性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就架构设计而言，扩展性是软件设计的永恒话题。而要实现系统扩展性，一种思路是提供可插拔式的机制来应对所发生的变化。当系统中现有的某个组件不满足要求时，我们可以实现一个新的组件来替换它，而整个过程对于系统的运行而言应该是无感知的，我们也可以根据需要随时完成这种新旧组件的替换。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.519298245614035&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iaJMNZQNBlG8aQ4S7nXzRicqVgS2uGLLXSMXBnQUjrnrcYftibZ1abqx6JnibroGcDFBMcYlvVu12o6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;570&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;比如在 ShardingSphere 中提供的分布式主键功能，分布式主键的实现可能有很多种，而扩展性在这个点上的体现就是， 我们可以使用任意一种新的分布式主键实现来替换原有的实现，而不需要依赖分布式主键的业务代码做任何的改变 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微内核架构模式为这种实现扩展性的思路提供了架构设计上的支持，ShardingSphere 基于微内核架构实现了高度的扩展性。在介绍如何实现微内核架构之前，我们先对微内核架构的具体组成结构和基本原理做简要的阐述。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;什么是微内核架构？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从组成结构上讲， 微内核架构包含两部分组件：内核系统和插件 。这里的内核系统通常提供系统运行所需的最小功能集，而插件是独立的组件，包含自定义的各种业务代码，用来向内核系统增强或扩展额外的业务能力。在 ShardingSphere 中，前面提到的分布式主键就是插件，而 ShardingSphere 的运行时环境构成了内核系统。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4939759036144578&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iaJMNZQNBlG8aQ4S7nXzRicqblnCbwZmOdwmCcbeibXdRQnrgoNx5xic8pNCS0r5j4rmoDkQqAq0RS5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;498&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这里的插件具体指的是什么呢？这就需要我们明确两个概念，一个概念就是经常在说的 API ，这是系统对外暴露的接口。而另一个概念就是 SPI（Service Provider Interface，服务提供接口），这是插件自身所具备的扩展点。就两者的关系而言，API 面向业务开发人员，而 SPI 面向框架开发人员，两者共同构成了 ShardingSphere 本身。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3967741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iaJMNZQNBlG8aQ4S7nXzRicqDicmJ4xTwQxjYcMKR95prqjdmFLZhYpCVyqnFaKNE4uHlib1zMRUSnvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;620&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可插拔式的实现机制说起来简单，做起来却不容易，我们需要考虑两方面内容。一方面，我们需要梳理系统的变化并把它们抽象成多个 SPI 扩展点。另一方面， 当我们实现了这些 SPI 扩展点之后，就需要构建一个能够支持这种可插拔机制的具体实现，从而提供一种 SPI 运行时环境 。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;如何实现微内核架构？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，JDK 已经为我们提供了一种微内核架构的实现方式，就是JDK SPI。这种实现方式针对如何设计和实现 SPI 提出了一些开发和配置上的规范，ShardingSphere、Dubbo 使用的就是这种规范，只不过在这基础上进行了增强和优化。所以要理解如何实现微内核架构，我们不妨先看看JDK SPI 的工作原理。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;JDK SPI&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SPI（Service Provider Interface）主要是被框架开发人员使用的一种技术。例如，使用 Java 语言访问数据库时我们会使用到 &lt;code&gt;java.sql.Driver&lt;/code&gt; 接口，不同数据库产品底层的协议不同，提供的 &lt;code&gt;java.sql.Driver&lt;/code&gt; 实现也不同，在开发 &lt;code&gt;java.sql.Driver&lt;/code&gt; 接口时，开发人员并不清楚用户最终会使用哪个数据库，在这种情况下就可以使用 Java SPI 机制在实际运行过程中，为 &lt;code&gt;java.sql.Driver&lt;/code&gt; 接口寻找具体的实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们通过一个简单的示例演示一下JDK SPI的使用方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先我们定义一个生成id键的接口，用来模拟id生成&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IdGenerator&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 生成id&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;generateId&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;然后创建两个接口实现类，分别用来模拟uuid和序列id的生成&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UuidGenerator&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IdGenerator&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;generateId&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; UUID.randomUUID().toString();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SequenceIdGenerator&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IdGenerator&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicLong atomicId = &lt;span&gt;new&lt;/span&gt; AtomicLong(&lt;span&gt;100L&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;generateId&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; leastId = &lt;span&gt;this&lt;/span&gt;.atomicId.incrementAndGet();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; String.valueOf(leastId);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在项目的&lt;code&gt;resources/META-INF/services&lt;/code&gt; 目录下添加一个名为&lt;code&gt;com.github.jianzh5.spi.IdGenerator&lt;/code&gt;的文件，这是 JDK SPI 需要读取的配置文件，内容如下：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;com.github.jianzh5.spi.impl.UuidGenerator&lt;br/&gt;com.github.jianzh5.spi.impl.SequenceIdGenerator&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;创建main方法，让其加载上述的配置文件，创建全部IdGenerator 接口实现的实例，并执行生成id的方法。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GeneratorMain&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ServiceLoader&amp;lt;IdGenerator&amp;gt; serviceLoader = ServiceLoader.load(IdGenerator&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        Iterator&amp;lt;IdGenerator&amp;gt; iterator = serviceLoader.iterator();&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;(iterator.hasNext()){&lt;br/&gt;            IdGenerator generator = iterator.next();&lt;br/&gt;            String id = generator.generateId();&lt;br/&gt;            System.out.println(generator.getClass().getName() + &lt;span&gt;&quot;  &amp;gt;&amp;gt;id:&quot;&lt;/span&gt; + id);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;执行结果如下：&lt;img data-ratio=&quot;0.10125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iaJMNZQNBlG8aQ4S7nXzRicqv3FSZBHibE1VRia0q6GEolePs6tlNAzMDDml36AWc4YVj4aLDKRS7BwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;JDK SPI 源码分析&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上述示例，我们可以看到 JDK SPI 的入口方法是 ServiceLoader.load() 方法，在这个方法中首先会尝试获取当前使用的 ClassLoader，然后调用 reload() 方法，调用关系如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1847457627118644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iaJMNZQNBlG8aQ4S7nXzRicqlLSsbZaWkVeIZibZXkZ1wvlEQVpgWX6afiaoLZE4crcvUq2S6C1GKcHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;590&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;调用关系&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 reload() 方法中，首先会清理 providers 缓存（LinkedHashMap 类型的集合），该缓存用来记录 ServiceLoader 创建的实现对象，其中 Key 为实现类的完整类名，Value 为实现类的对象。之后创建 LazyIterator 迭代器，用于读取 SPI 配置文件并实例化实现类对象。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;reload&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; providers.clear();&lt;br/&gt; lookupIterator = &lt;span&gt;new&lt;/span&gt; LazyIterator(service, loader);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面的示例中，main() 方法中使用的迭代器底层就是调用了 &lt;code&gt;ServiceLoader.LazyIterator&lt;/code&gt; 实现的。Iterator 接口有两个关键方法：&lt;code&gt;hasNext()&lt;/code&gt; 方法和 &lt;code&gt;next()&lt;/code&gt; 方法。这里的 LazyIterator 中的 &lt;code&gt;next()&lt;/code&gt; 方法最终调用的是其 &lt;code&gt;nextService()&lt;/code&gt; 方法，&lt;code&gt;hasNext()&lt;/code&gt; 方法最终调用的是 &lt;code&gt;hasNextService()&lt;/code&gt; 方法，我们来看看 &lt;code&gt;hasNextService()&lt;/code&gt;方法的具体实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String PREFIX = &lt;span&gt;&quot;META-INF/services/&quot;&lt;/span&gt;; &lt;br/&gt;Enumeration&amp;lt;URL&amp;gt; configs = &lt;span&gt;null&lt;/span&gt;; &lt;br/&gt;Iterator&amp;lt;String&amp;gt; pending = &lt;span&gt;null&lt;/span&gt;; &lt;br/&gt;String nextName = &lt;span&gt;null&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;hasNextService&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (nextName != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (configs == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;//META-INF/services/com.github.jianzh5.spi.IdGenerator&lt;/span&gt;&lt;br/&gt;   String fullName = PREFIX + service.getName();&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (loader == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;    configs = ClassLoader.getSystemResources(fullName);&lt;br/&gt;   &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;    configs = loader.getResources(fullName);&lt;br/&gt;  } &lt;span&gt;catch&lt;/span&gt; (IOException x) {&lt;br/&gt;   fail(service, &lt;span&gt;&quot;Error locating configuration files&quot;&lt;/span&gt;, x);&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 按行SPI遍历配置文件的内容 &lt;/span&gt;&lt;br/&gt; &lt;span&gt;while&lt;/span&gt; ((pending == &lt;span&gt;null&lt;/span&gt;) || !pending.hasNext()) {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!configs.hasMoreElements()) {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 解析配置文件 &lt;/span&gt;&lt;br/&gt;  pending = parse(service, configs.nextElement());&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 更新 nextName字段 &lt;/span&gt;&lt;br/&gt; nextName = pending.next();&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 hasNextService() 方法中完成 SPI 配置文件的解析之后，再来看 LazyIterator.nextService() 方法，该方法&lt;strong&gt;「负责实例化 hasNextService() 方法读取到的实现类」&lt;/strong&gt;，其中会将实例化的对象放到 providers 集合中缓存起来，核心实现如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; S &lt;span&gt;nextService&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;br/&gt;    String cn = nextName; &lt;br/&gt;    nextName = &lt;span&gt;null&lt;/span&gt;; &lt;br/&gt;    &lt;span&gt;// 加载 nextName字段指定的类 &lt;/span&gt;&lt;br/&gt;    Class&amp;lt;?&amp;gt; c = Class.forName(cn, &lt;span&gt;false&lt;/span&gt;, loader); &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!service.isAssignableFrom(c)) { &lt;span&gt;// 检测类型 &lt;/span&gt;&lt;br/&gt;        fail(service, &lt;span&gt;&quot;Provider &quot;&lt;/span&gt; + cn  + &lt;span&gt;&quot; not a subtype&quot;&lt;/span&gt;); &lt;br/&gt;    } &lt;br/&gt;    S p = service.cast(c.newInstance()); &lt;span&gt;// 创建实现类的对象 &lt;/span&gt;&lt;br/&gt;    providers.put(cn, p); &lt;span&gt;// 将实现类名称以及相应实例对象添加到缓存 &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; p; &lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是在 main() 方法中使用的迭代器的底层实现。最后，我们再来看一下 main() 方法中使用 &lt;code&gt;ServiceLoader.iterator()&lt;/code&gt; 方法拿到的迭代器是如何实现的，这个迭代器是依赖 LazyIterator 实现的一个匿名内部类，核心实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Iterator&amp;lt;S&amp;gt; &lt;span&gt;iterator&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Iterator&amp;lt;S&amp;gt;() { &lt;br/&gt;        &lt;span&gt;// knownProviders用来迭代providers缓存 &lt;/span&gt;&lt;br/&gt;        Iterator&amp;lt;Map.Entry&amp;lt;String,S&amp;gt;&amp;gt; knownProviders &lt;br/&gt;            = providers.entrySet().iterator(); &lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;hasNext&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;br/&gt;            &lt;span&gt;// 先走查询缓存，缓存查询失败，再通过LazyIterator加载 &lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (knownProviders.hasNext())  &lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;; &lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; lookupIterator.hasNext(); &lt;br/&gt;        } &lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; S &lt;span&gt;next&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;br/&gt;            &lt;span&gt;// 先走查询缓存，缓存查询失败，再通过 LazyIterator加载 &lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (knownProviders.hasNext()) &lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; knownProviders.next().getValue(); &lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; lookupIterator.next(); &lt;br/&gt;        } &lt;br/&gt;        &lt;span&gt;// 省略remove()方法 &lt;/span&gt;&lt;br/&gt;    }; &lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;JDK SPI 在 JDBC 中的应用&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解了 JDK SPI 实现的原理之后，我们再来看实践中 JDBC 是如何使用 JDK SPI 机制加载不同数据库厂商的实现类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 中只定义了一个 &lt;code&gt;java.sql.Driver&lt;/code&gt; 接口，具体的实现是由不同数据库厂商来提供的。这里我们就以 MySQL 提供的 JDBC 实现包为例进行分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 mysql-connector-java-*.jar 包中的 META-INF/services 目录下，有一个 java.sql.Driver 文件中只有一行内容，如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;com.mysql.cj.jdbc.Driver&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用 &lt;code&gt;mysql-connector-java-*.jar&lt;/code&gt; 包连接 MySQL 数据库的时候，我们会用到如下语句创建数据库连接：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String url = &lt;span&gt;&quot;jdbc:xxx://xxx:xxx/xxx&quot;&lt;/span&gt;; &lt;br/&gt;Connection conn = DriverManager.getConnection(url, username, pwd); &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「DriverManager 是 JDK 提供的数据库驱动管理器」&lt;/strong&gt;，其中的代码片段，如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; { &lt;br/&gt;    loadInitialDrivers();&lt;br/&gt;    println(&lt;span&gt;&quot;JDBC DriverManager initialized&quot;&lt;/span&gt;); &lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在调用 &lt;code&gt;getConnection()&lt;/code&gt; 方法的时候，DriverManager 类会被 Java 虚拟机加载、解析并触发 static 代码块的执行；在 &lt;code&gt;loadInitialDrivers()&lt;/code&gt;方法中通过 JDK SPI 扫描 Classpath 下 &lt;code&gt;java.sql.Driver&lt;/code&gt; 接口实现类并实例化，核心实现如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;loadInitialDrivers&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;br/&gt;    String drivers = System.getProperty(&lt;span&gt;&quot;jdbc.drivers&quot;&lt;/span&gt;) &lt;br/&gt;    &lt;span&gt;// 使用 JDK SPI机制加载所有 java.sql.Driver实现类 &lt;/span&gt;&lt;br/&gt;    ServiceLoader&amp;lt;Driver&amp;gt; loadedDrivers =  &lt;br/&gt;           ServiceLoader.load(Driver&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;; &lt;br/&gt;    Iterator&amp;lt;Driver&amp;gt; driversIterator = loadedDrivers.iterator(); &lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(driversIterator.hasNext()) { &lt;br/&gt;        driversIterator.next(); &lt;br/&gt;    } &lt;br/&gt;    String[] driversList = drivers.split(&lt;span&gt;&quot;:&quot;&lt;/span&gt;); &lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (String aDriver : driversList) { &lt;span&gt;// 初始化Driver实现类 &lt;/span&gt;&lt;br/&gt;        Class.forName(aDriver, &lt;span&gt;true&lt;/span&gt;, &lt;br/&gt;            ClassLoader.getSystemClassLoader()); &lt;br/&gt;    } &lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 MySQL 提供的 &lt;code&gt;com.mysql.cj.jdbc.Driver&lt;/code&gt; 实现类中，同样有一段 static 静态代码块，这段代码会创建一个 &lt;code&gt;com.mysql.cj.jdbc.Driver&lt;/code&gt; 对象并注册到 &lt;code&gt;DriverManager.registeredDrivers&lt;/code&gt; 集合中（CopyOnWriteArrayList 类型），如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; { &lt;br/&gt;   java.sql.DriverManager.registerDriver(&lt;span&gt;new&lt;/span&gt; Driver()); &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;getConnection()&lt;/code&gt; 方法中，DriverManager 从该 registeredDrivers 集合中获取对应的 Driver 对象创建 Connection，核心实现如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Connection &lt;span&gt;getConnection&lt;/span&gt;&lt;span&gt;(String url, java.util.Properties info, Class&amp;lt;?&amp;gt; caller)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; SQLException &lt;/span&gt;{ &lt;br/&gt;    &lt;span&gt;// 省略 try/catch代码块以及权限处理逻辑 &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(DriverInfo aDriver : registeredDrivers) { &lt;br/&gt;        Connection con = aDriver.driver.connect(url, info); &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; con; &lt;br/&gt;    } &lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们详细讲述了微内核架构的一些基本概念并通过一个示例入手，介绍了 JDK 提供的 SPI 机制的基本使用，然后深入分析了 JDK SPI 的核心原理和底层实现，对其源码进行了深入剖析，最后我们以 MySQL 提供的 JDBC 实现为例，分析了 JDK SPI 在实践中的使用方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;掌握了JDK的SPI机制就等于掌握了微内核架构的核心，以上，希望对你有所帮助！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7fe39fc2ee56c66efce59b816170d0af</guid>
<title>当年，我的架构师之路差点完蛋，幸亏了它</title>
<link>https://toutiao.io/k/10zqtkl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次和大家讲讲分布式事务的 BASE 理论，保证通俗易懂。为了阅读顺畅，开始之前先请大家记住几个名词：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BASE——Basically Available（基本可用），Soft state（软状态），Eventually consistent（最终一致性）&lt;br/&gt;2PC——两阶段提交&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不用懂，先记住就好了。你负责记住，我负责让你懂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正文开始：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;深夜，我嗒嗒嗒的敲着键盘，我在屏幕上敲下了这么一段话：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;“2008 年 Dan Pritchett 提出一个与两阶段提交截然不同的分布式事务理论: BASE（Basically Available，Soft state，Eventually consistent）理论。BASE 理论打破了传统解决分布式事务的思维，放弃 ACID 特性以换取系统的可用性，BASE 理论强调基本可用、软状态、最终一致，而不像 ACID 坚持强一致性。&lt;strong&gt;BASE 理论是一种处理分布式事务的思想，没有具体的操作步骤，要理解 BASE 理论需要结合具体的例子&lt;/strong&gt;。”&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;敲完这段话以后，我顿了下，完全停下了打字。思考了很久，我决定把准备了四五天的，各种为了讲清楚 BASE 理论的应用实例全部删掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为我很想谈谈自身的一些经历。也许，那些折腾和熬人的经历能更清楚的告诉大家，为什么会有 BASE 理论这套东西出来。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.08703703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KQfWicGWkcmdPw7bfIia7h1pUxw8Qxics0ljRcyztmADoet52nKWT6jnxgOxeU6mfmDjxaIDTrSPm9KA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前些年，互联网行业里对架构师这个岗位的标准还不是很清晰。所以，很多架构师的工作往往就是一些技术被公司认可的资深工程师负责。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;彼时，正巧我也是这类人员之一，故也得到了一个从零开始架设一套广告投放平台的机会。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我很喜欢钻研技术，对这种机会自然很看重。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那时候，架构并无如今这么复杂，一开始就是前面搞几个 Web 应用，后面共享个数据库。大致像这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0343053173241852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KQfWicGWkcmdPw7bfIia7h1pUPmtH1IM8bUibgoIO7fZicJPicDVKQPA1bd8pErgA98Ocs2EzNe9aXs87g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;583&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，上面的架构其实做了很多简化，省略了很多细节。比如，为了提高性能做的缓存，为了提高吞吐做的负载均衡统统没有在上图给出。因为这些和本章话题无关，暂时咱们就忽略这些东西，只看核心部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这套架构初期运行还是没什么问题的，再加上一些缓存机制，初期一些性能问题都通过调整缓存提升缓存的碰撞率应付了过去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可是，随着广告投放量的增大，广告的访问量也在暴涨。这些暴涨的访问量引发了性能问题。当时，由于前端有负载均衡，应用层倒是没出现什么问题……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;问题出在后面的数据库上&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.08703703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KQfWicGWkcmdPw7bfIia7h1pUM60CgY9S4lh6kajalGeK80icSVdDT26icLy7zaKhX2C2PrAfnicgkpzNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这套架构数据库用的是 MySQL，本身也只有一台主库在对外服务，另外一台备库采用了 MySQL 自己的全同步机制做实时备份。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当广告访问量暴涨的时候，因为业务需要，很多数据需要在数据库中做实时插入，这就导致了大量的磁盘 IO 产生。这些大量的磁盘 IO 造成了数据库本身性能的急剧下降。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;悲催的是，整套广告平台的所有功能又都是共享一个数据库的，所以随着数据库本身的性能下降，平台的所有功能都受到了影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于问题主要在于大量广告流量的写入，所以，靠读写分离的方案去缓解问题这条路就走不通了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只好先升级硬件了。在经过了几轮硬件升级和数据库调优之后，单数据库再也无法支撑不断上涨的流量了。没办法，要考虑搞数据库切分了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那时候，我个人是很恐惧数据库切分的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因不仅仅在于需要在应用层多写很多复杂的逻辑，其根本原因是当时流行的 2PC（两阶段提交）方案，这个方案本身能保证在数据库切分的情况下，原来的事务依然保留着自身的 ACID 性质。即:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Atomicity（原子性），不管事务里执行多少命令，对外它们都是一体的，要么都执行，要么都不执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Consistency（一致性），正因为事务里要么做要么都不做，所以数据库的状态变化只能由事务变更后，才会叫一致性状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Isolation（隔离性），事务里做的事儿事务外面谁也看不到，就跟个盒子把数据罩起来一样，到底中间怎么变化的，事务外面的观察不到。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Durability（持久性），事务确认成功了，那这状态就永久不变了。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但也正因为这 4 个特性，2PC 才让我顾虑重重。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;顾虑1&lt;/strong&gt;：首先，数据库拆分了，那么根据事务的原子性，事务自身必须是一体的，那么事务涉及到的不同的数据库就必须都访问一遍，而这本身就意味着很高的通信成本。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.3993506493506493&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KQfWicGWkcmdPw7bfIia7h1pU5cUQoqBic80wG1xfVym9HLLptoqTRGvP7jNLBHoBIV5ia9TqL0tUBmEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;616&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再加上，为了保持一致性，事务失败后，还必须恢复各个数据库原来的状态，这就必须让已经成功执行过本地事务的数据库全部回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而稍微懂点数据库的人都知道，这个成本有多大。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;2.3108808290155443&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KQfWicGWkcmdPw7bfIia7h1pUVH5TK1PtNGEEaaV1aYzhLKrouwM4Iq0fyM2lYCicj2Is3jO5cKkeBRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;386&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更可怕的是，本身事务的隔离性还可能加上锁。一旦一个热点数据区域被大量访问，最差情况就可能出现串行访问。而这对此套平台，包括我自己都将是个悲剧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;顾虑2&lt;/strong&gt;：数据库的拆分会造成整个平台的可用性下降。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我现在有一台数据库，它的可用性是 99.9%。如果因为分库，数据库从一台变成两台，那么平台的可用性就会变成：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;平台的可用性 = 99.9% * 99.9% = 99.8%&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 99.9% 变成了 99.8%，这意味着可用性下降了 0.1%，每个月的不可用时间会增加 43 分钟之多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一边是硬件升级已经到顶，单机数据库也优化到了极限，再不做数据库拆分，平台可能随时瘫痪。一边是没有好的策略，可能拆分数据库后，每个月都有宕机的风险，同时性能也可能会出现剧烈的下降。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我被逼入了死角。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.08703703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KQfWicGWkcmdPw7bfIia7h1pU6NnicAdlFA4DfDhlWIVf3awKfWqWrk48PlDiam1prGAqCWTAtBEQYicAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种痛苦的纠结折磨了我大概一周，直到我看到了 CAP 定理。当 CAP 定理说分布式系统在分区容错的时候，只能一致性和可用性二选一时，我高兴的蹦了起来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原来，可用性和一致性是不能兼得的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为何我会那么高兴？因为逼我入死角的可不仅是技术上的问题了，我还承受着来自于业务方和领导的压力。每天一上班，我就需要面对业务各方的抱怨，以及领导一轮又一轮的催促。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了 CAP 定理的支持，我知道我最终是要面临选择的。既然在这个世界上做分布式架构的所有人都要面临选择，那我又怎么可能独善其身呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在对单机数据库引发的各种问题做了一次彻底的各种归因以后，我下了决心：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一定要搞定拆分数据库并给出良好方案。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只是，2PC 这个拦路虎，它成为了我的大敌。通过 CAP 定理，我非常肯定，只要我选了 2PC 方案，可用性就一定会出现严重的问题，这个方案也肯定不可能拿出来丢人现眼的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我唯一的方向就是去牺牲一些一致性，往可用性方向走。可是，怎么走呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也许是老天眷顾，也许是大家都承受着和我一样夜不能寐的压力，很快，BASE 理论在国内传开了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BASE 理论让我知道了，这个世上能排到前几名的技术大公司也一样会出问题，也一样会对这些问题进行妥协。而且 BASE 理论的思想让我的思路一下子就打开了，苦思而不得的问题开始有了头绪。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我要开始着手制定技术方案了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.08703703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KQfWicGWkcmdPw7bfIia7h1pUdQfL5OiasJQ7T02K1LsicrMpru8EPCF6KoBNCgiceCxv2LibZbXMOrWhMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BASE 思想中的 BA（Basically Available）&lt;strong&gt;基本可用&lt;/strong&gt;，是鼓励通过预先的架构设计或者前期规划，尽量在分布式的系统中，&lt;strong&gt;把以前可能影响全平台的严重问题，变成只会影响平台中的一部分数据或者功能的非严重问题。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这个思想之后，我就对广告平台中的很多重要的数据表进行了拆分，并将这些表的数据分散到了不同的数据库中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，有个广告流量详情表，每当用户点击广告或者广告展示出来的时候，为了保证不丢失，这些数据都是实时插入到这个表里的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我对这张表是怎么切分的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当有人点击广告了，他的点击记录会被传到我的应用层，然后我会在应用层根据广告 ID 做哈希，再根据哈希结果的不同，分别存到不同的数据库中去。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7708978328173375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KQfWicGWkcmdPw7bfIia7h1pUT5k93XqNN2ibwlZhWiabkVWgicGVImlYPHI9RmWSycA1icog9Tc0FYIqsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1292&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如这三个数据库中的一个出现了问题，则只会有三分之一的数据受到影响。这就实现了 BASE 理论中的 BA——基本可用了。&lt;strong&gt;基本可用&lt;/strong&gt;其实也真的就是表达的这么一回事：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过一些架构设计，即使平台中某部分组件出现了问题，也不会导致整个平台不可用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，既然采取了数据库拆分的策略，又根据 BASE 理论中的 BA 思想拆分了一些重要的表，那么，到了现在，可能也无从后悔，只能继续沿着 BASE 这条路，一条路走到黑了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.08703703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KQfWicGWkcmdPw7bfIia7h1pUgGlqZN1GWM04IW9XcHodj648adBAt5YMO4wCxVl7JAdqsvRklJSSFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，需要着手解决性能问题了。2PC 方案……算了……它疯狂的一致性性格会要了我的狗命的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么极端点，我们不搞事务可不可以呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还用前面说的那套广告平台举例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当时，从业务上，要求广告的访问数据都要保证及时入库不能丢，因为丢了就可能造成计费的损失，而这些损失全是钱。所以，每当用户点击广告或者广告展示出来的时候，为了保证不丢失，这些数据都是实时入库的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又根据业务需求，当广告流量入库时，还需要往广告预算表和媒体流水表里同时根据这笔流量进行记账，以供后续财务计算。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.986870897155361&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KQfWicGWkcmdPw7bfIia7h1pUicOicXLZruyiakM3XnRuctNZuba0hhuJx8Suu2KfZDhiahwseS0ib0RuvIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;457&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果完全不考虑事务，则拆分库后，操作可能会是这个样子。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7633228840125392&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KQfWicGWkcmdPw7bfIia7h1pUWicBlydteP2AFwCKk3L3SCvCj9GfewdgW89qI6yORiaot7N6ZYRlcKYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1276&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这三个操作可能会并行发往不同的数据库执行。由于三个操作之间没有事务的约束，所以，一个操作出问题了，另外的操作并不会受到影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这却也引发了另外一个问题，数据状态不一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在上面的业务中，插入广告流量表的操作失败了，但其余两张表插入成功了，业务就会面临一个很尴尬的情况：他们算出的财务报表没有依据。财务流水中找不到产生了这笔流水的依据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这种不一致的状态由于已经被持久化到了数据库中，就会导致这种不一致的状态永久存在了数据库中。这业务能接受吗？但凡有点职业精神的程序员能接受吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要有折中的办法！！！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.08703703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KQfWicGWkcmdPw7bfIia7h1pUXJdh9uRjI3zriafv4k8k4dlDPsSlQ3hNeCF8H0DHz4Qql4NiaO0XwGYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在再回过头来看看 2PC 的问题。假设 2PC 的实现是一步步执行的（当然，不管是一步一步还是异步并发，他们总是要确保大家要么一起成功要么一起失败的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，即使并发操作，也不会节省多少性能，因为短板在执行最慢的那条语句上。如果执行我们上面的事务需要几步呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如现在要执行事务 A：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;协调器发出事务 A 中的第一条语句 Insert into 流量表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;协调器等待结果&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;协调器发出事务 A 中的第二条语句 Insert into 预算表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;协调器等待结果&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;协调器发出事务 A 中的第三条语句 Insert into 流水表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;协调器等待结果&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果中间有失败的，协调器还需要做额外的操作：&lt;/p&gt;&lt;ol start=&quot;7&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;协调器告诉事务 A 中第一条语句做回滚操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;协调器等待结果&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;协调器告诉事务 A 中第二条语句做回滚操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;协调器等待结果&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;协调器告诉事务 A 中第三条语句做回滚操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;协调器等待结果&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“天哪，这么多步操作啊！！！”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这简直是让人窒息的操作步骤了。如果有一种方法既能节省步骤又能节省事务执行时间该有多好啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;嗯……我只能说当时的自己实在是长得丑却想的美。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;世上尚不存在这种方法的。但是，世上还存在另外的解决此类事情的方式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;异步处理，时间分摊&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们分析下关于插入广告流量这块儿的业务。你会发现一个神奇的现象，即广告流量表中的数据才是核心，而预算表和流水表统统都是广告流量表中数据的一种缓存而已。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果，嗯，我是说如果有这么一种办法，即我们先把广告流量数据插入数据库，成功以后，再把以广告流量数据作为根基的附属操作（这里是插入预算表和流水表）放到一个地方持久化。然后，我们再从那个存放附属操作的地方把操作信息取出来，专门对这些操作信息进行处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这种处理方式可能会非常灵活，要么可以对这些操作信息进行批量处理，要么可以对他们异步的在后台处理。处理这些操作信息成功以后，再把以前持久化好的操作信息给删除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个方法实施下来，相当于把应该在 A 时刻在前台阻塞着花 3 秒处理业务的操作，变成了在 A 时刻前台花 1 秒，然后在 B 时刻后台花 2 秒处理业务的操作，这不也可以变相的达到我们想节省步骤和事务执行时间的目标了吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这真的是一个好的思路啊，还记得当时的自己想到这个思路的时候，忍不住在内心大喊了起来：“那个存附属操作信息的地方就是 MQ 啊。用 MQ，MQ 就能做这件事情。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么就一起来看下 MQ 是如何帮我解决这个大难题的吧，针对上面的广告流量详情的业务，我们用了 MQ 之后会有如下的步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;执行 Insert into 流量表语句&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等待结果&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发消息到 MQ 里，内容为 Insert into 预算表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等待 MQ 持久化成功&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发消息到 MQ 里，内容为 Insert into 流水表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等待 MQ 持久化成功&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果发给 MQ 消息失败：&lt;/p&gt;&lt;ol start=&quot;7&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可以降级写到本地日志中&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OK，那么这改进后的方法是怎么提升性能的呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先，我们发给 MQ 的消息可以批量发送；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其次，发给 MQ 并持久化消息要比数据库执行一次事务快了一个数量级；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后，失败后，回滚操作成本降低了不止一个数量级。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法本质上，在应用层其实就执行了一条语句而已，剩下的完全可以根据业务需求的不同，选择处理 MQ 中的消息的方式。比如，处理消息既可以异步慢慢处理，也可以推迟一段时间后处理，更可以凌晨定时处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，使用 MQ 方案后，对广告流量这个业务需求而言，其实，出现了一个中间状态：广告流量表有数据，但是以这条数据为基准的预算表和流水表暂时还没有数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中间这个状态此时是不满足业务需求的。而这种状态，在 BASE 理论中就被称为：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;软状态（Soft state）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于广告流量表当时没有及时插入到预算表和流水表中的数据呢，它们最终也将会随着后续对 MQ 消息的处理而被补充完整的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而对于这种当时不符合业务需求的软状态，通过一些后续内部的自动化操作把数据状态补充完整从而最终满足业务需求的情况，在 BASE 理论中就被称为了：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最终一致性（Eventually consistent）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此，我通过不断利用 BASE 理论中的软状态和最终一致性的思路，最终补上了平台数据库切分需要的最后一块拼图——&lt;strong&gt;平台性能大提升&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我蜕变了！！！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最后&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是 BASE 理论是如何把我救于水火的经历，不知道你从此又会对 BASE 理论理解了多少呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再重复一次，BASE 理论本质上只是一种架构思想，它告诉人们世界上还存在着这么一些事情：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;能通过巧妙地设计，通过局部轻微的损失减少全局严重的损失；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;能通过一些解耦、异步、推迟执行、批量执行等技巧，构造出一种中间状态，从而提高系统的整体性能；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;平台是为业务服务的，业务的核心是数据状态，而数据状态无论中间变成什么样，最终还要恢复到它应该处于的正确状态。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是BASE理论的基本可用、软状态和最终一致性了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了写这篇，又熬了好几个夜，如果觉得写的不赖，愿意让更多人看到，期待你的点赞和转发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;今天你若点在看，&lt;br/&gt;明年工资涨一半！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后祝各位新年快乐！&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微信公众号改变了推送规则，为了能正常看到文章，可以把“四猿外”公众号加上星标。&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7068645640074211&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KQfWicGWkcmdPw7bfIia7h1pU2p1FzwVqiaPBuo0wUE65M0TnibjV2bYXOJalOoQKTxbxtRgfet8Sstbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;539&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我最近建了一个读者交流群，里面大部分是程序员，一起聊技术、工作、八卦。欢迎加我微信，拉你入群。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9852216748768473&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6nbNnibOq5KQibCDibpTo0kqofPehQvDDibibcb3bQUELdY3Knsl4r0RcgsV9l4icr3icmZQfaBXtSFNTxmdQlAZT1OQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;609&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247484916&amp;amp;idx=1&amp;amp;sn=afb3997f6ae24fdff6ea23c96a383a4f&amp;amp;chksm=fcd8c9b5cbaf40a34e5d33f70e6050fbffa1b60b0f78d8f47a3fb150ad57f3e2dcb1caa3cd6d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;肝了3版才满意：分布式系统之CAP理论，我们对它的理解和误解&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247484862&amp;amp;idx=1&amp;amp;sn=be1f32643415f605da7080f791ed64f9&amp;amp;chksm=fcd8c9ffcbaf40e936ac5aedde29c3b259026a2b2945ea195613087caab036df144f7c2d8937&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;优秀！一鼓作气学会“一致性哈希”，就靠这 18 张图了&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247484883&amp;amp;idx=1&amp;amp;sn=ae8c6aced4797e859fd2c224a11fea75&amp;amp;chksm=fcd8c992cbaf40848d237c4e499ec1ba7eff9fe5c3e9863af3a91e47782b5285b1673523e9cc&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;架构师的成长之路，第一步该怎么迈？我给大家准备好了&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247484826&amp;amp;idx=1&amp;amp;sn=35378fc344195edc643c5a68f896bc40&amp;amp;chksm=fcd8c9dbcbaf40cdcad84dd15b972afed8cf477f584748167ee67dc3a2a3532474497aa4d6c1&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;一个技术总监的忠告：精通那么多技术，你为何还是受不到重用？&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>