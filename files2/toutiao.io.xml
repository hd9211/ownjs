<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>87ae1ccde85f18cc0356e3ab9f888986</guid>
<title>我竟然被 “双亲委派” 给虐了</title>
<link>https://toutiao.io/k/l9vnnm6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;article-content&quot;&gt;
&lt;p&gt;最近一段时间，我在面试的过程中，很喜欢问双亲委派的一些问题，因为我发现这个问题真的可以帮助我全方位的了解一个候选人。&lt;/p&gt;
&lt;p&gt;记得前几天一次面试过程中，我和一位候选人聊到了JVM的类加载机制的问题，他谈到了双亲委派，并且很自信的给我讲了一下他对于双亲委派的理解。&lt;/p&gt;
&lt;p&gt;因为难得碰到一个对着块知识了解的比较多的候选人，于是我们展开了”300回合”的交锋，当问完这些问题的之后，大概半个小时已经过去了。&lt;/p&gt;
&lt;p&gt;最后，这个后续人和我说：”&lt;strong&gt;我万万没想到，我一个工作7年的技术经理，竟然被双亲委派给虐了！！！&lt;/strong&gt;“&lt;/p&gt;
&lt;p&gt;先来回顾下我都问了他哪些问题，看看你能回答上来多少个：&lt;/p&gt;
&lt;p&gt;1、什么是双亲委派？ 2、为什么需要双亲委派，不委派有什么问题？ 3、”父加载器”和”子加载器”之间的关系是继承的吗？ 4、双亲委派是怎么实现的？ 5、我能不能主动破坏这种双亲委派机制？怎么破坏？ 6、为什么重写loadClass方法可以破坏双亲委派，这个方法和findClass（）、defineClass（）区别是什么？ 7、说一说你知道的双亲委派被破坏的例子吧 8、为什么JNDI、JDBC等需要破坏双亲委派？ 9、为什么TOMCAT要破坏双亲委派？ 10、谈谈你对模块化技术的理解吧！&lt;/p&gt;
&lt;p&gt;以上，10个问题，从头开始答，你大概可以坚持到第几题？&lt;/p&gt;
&lt;h3&gt;什么是双亲委派机制&lt;/h3&gt;
&lt;p&gt;首先，我们知道，虚拟机在加载类的过程中需要使用类加载器进行加载，而在Java中，类加载器有很多，那么当JVM想要加载一个.class文件的时候，到底应该由哪个类加载器加载呢？&lt;/p&gt;
&lt;p&gt;这就不得不提到”双亲委派机制”。&lt;/p&gt;
&lt;p&gt;首先，我们需要知道的是，Java语言系统中支持以下4种类加载器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bootstrap ClassLoader 启动类加载器&lt;/li&gt;
&lt;li&gt;Extention ClassLoader 标准扩展类加载器&lt;/li&gt;
&lt;li&gt;Application ClassLoader 应用类加载器&lt;/li&gt;
&lt;li&gt;User ClassLoader 用户自定义类加载器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这四种类加载器之间，是存在着一种层次关系的，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hollischuang.com/wp-content/uploads/2021/01/16102749464329.jpg&quot; alt=&quot;-w704&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;一般认为上一层加载器是下一层加载器的父加载器，那么，除了BootstrapClassLoader之外，所有的加载器都是有父加载器的。&lt;/p&gt;
&lt;p&gt;那么，所谓的双亲委派机制，指的就是：&lt;strong&gt;当一个类加载器收到了类加载的请求的时候，他不会直接去加载指定的类，而是把这个请求委托给自己的父加载器去加载。只有父加载器无法加载这个类的时候，才会由当前这个加载器来负责类的加载。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么，什么情况下父加载器会无法加载某一个类呢？&lt;/p&gt;
&lt;p&gt;其实，Java中提供的这四种类型的加载器，是有各自的职责的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bootstrap ClassLoader ，主要负责加载Java核心类库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。&lt;/li&gt;
&lt;li&gt;Extention ClassLoader，主要负责加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件。&lt;/li&gt;
&lt;li&gt;Application ClassLoader ，主要负责加载当前应用的classpath下的所有类&lt;/li&gt;
&lt;li&gt;User ClassLoader ， 用户自定义的类加载器,可加载指定路径的class文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么也就是说，一个用户自定义的类，如com.hollis.ClassHollis 是无论如何也不会被Bootstrap和Extention加载器加载的。&lt;/p&gt;
&lt;h3&gt;为什么需要双亲委派？&lt;/h3&gt;
&lt;p&gt;如上面我们提到的，因为类加载器之间有严格的层次关系，那么也就使得Java类也随之具备了层次关系。&lt;/p&gt;
&lt;p&gt;或者说这种层次关系是优先级。&lt;/p&gt;
&lt;p&gt;比如一个定义在java.lang包下的类，因为它被存放在rt.jar之中，所以在被加载过程汇总，会被一直委托到Bootstrap ClassLoader，最终由Bootstrap ClassLoader所加载。&lt;/p&gt;
&lt;p&gt;而一个用户自定义的com.hollis.ClassHollis类，他也会被一直委托到Bootstrap ClassLoader，但是因为Bootstrap ClassLoader不负责加载该类，那么会在由Extention ClassLoader尝试加载，而Extention ClassLoader也不负责这个类的加载，最终才会被Application ClassLoader加载。&lt;/p&gt;
&lt;p&gt;这种机制有几个好处。&lt;/p&gt;
&lt;p&gt;首先，&lt;strong&gt;通过委派的方式，可以避免类的重复加载&lt;/strong&gt;，当父加载器已经加载过某一个类时，子加载器就不会再重新加载这个类。&lt;/p&gt;
&lt;p&gt;另外，&lt;strong&gt;通过双亲委派的方式，还保证了安全性&lt;/strong&gt;。因为Bootstrap ClassLoader在加载的时候，只会加载JAVA_HOME中的jar包里面的类，如java.lang.Integer，那么这个类是不会被随意替换的，除非有人跑到你的机器上， 破坏你的JDK。&lt;/p&gt;
&lt;p&gt;那么，就可以避免有人自定义一个有破坏功能的java.lang.Integer被加载。这样可以有效的防止核心Java API被篡改。&lt;/p&gt;
&lt;h3&gt;“父子加载器”之间的关系是继承吗？&lt;/h3&gt;
&lt;p&gt;很多人看到父加载器、子加载器这样的名字，就会认为Java中的类加载器之间存在着继承关系。&lt;/p&gt;
&lt;p&gt;甚至网上很多文章也会有类似的错误观点。&lt;/p&gt;
&lt;p&gt;这里需要明确一下，&lt;strong&gt;双亲委派模型中，类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下为ClassLoader中父加载器的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class ClassLoader {
    // The parent class loader for delegation
    private final ClassLoader parent;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;双亲委派是怎么实现的？&lt;/h3&gt;
&lt;p&gt;双亲委派模型对于保证Java程序的稳定运作很重要，但它的实现并不复杂。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现双亲委派的代码都集中在java.lang.ClassLoader的loadClass()方法之中&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class&amp;lt;?&amp;gt; c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码不难理解，主要就是以下几个步骤：&lt;/p&gt;
&lt;p&gt;1、先检查类是否已经被加载过 2、若没有加载则调用父加载器的loadClass()方法进行加载 3、若父加载器为空则默认使用启动类加载器作为父加载器。 4、如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。&lt;/p&gt;
&lt;h3&gt;如何主动破坏双亲委派机制？&lt;/h3&gt;
&lt;p&gt;知道了双亲委派模型的实现，那么想要破坏双亲委派机制就很简单了。&lt;/p&gt;
&lt;p&gt;因为他的双亲委派过程都是在loadClass方法中实现的，那么&lt;strong&gt;想要破坏这种机制，那么就自定义一个类加载器，重写其中的loadClass方法，使其不进行双亲委派即可。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;loadClass（）、findClass（）、defineClass（）区别&lt;/h3&gt;
&lt;p&gt;ClassLoader中和类加载有关的方法有很多，前面提到了loadClass，除此之外，还有findClass和defineClass等，那么这几个方法有什么区别呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;loadClass()
&lt;ul&gt;
&lt;li&gt;就是主要进行类加载的方法，默认的双亲委派机制就实现在这个方法中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;findClass()

&lt;/li&gt;
&lt;li&gt;definclass()

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里面需要展开讲一下loadClass和findClass，我们前面说过，当我们想要自定义一个类加载器的时候，并且像破坏双亲委派原则时，我们会重写loadClass方法。&lt;/p&gt;
&lt;p&gt;那么，如果我们想定义一个类加载器，但是不想破坏双亲委派模型的时候呢？&lt;/p&gt;
&lt;p&gt;这时候，就可以继承ClassLoader，并且重写findClass方法。findClass()方法是JDK1.2之后的ClassLoader新添加的一个方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; /**
 * @since  1.2
 */
protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException {
    throw new ClassNotFoundException(name);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个方法只抛出了一个异常，没有默认实现。&lt;/p&gt;
&lt;p&gt;JDK1.2之后已不再提倡用户直接覆盖loadClass()方法，而是建议把自己的类加载逻辑实现到findClass()方法中。&lt;/p&gt;
&lt;p&gt;因为在loadClass()方法的逻辑里，如果父类加载器加载失败，则会调用自己的findClass()方法来完成加载。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，如果你想定义一个自己的类加载器，并且要遵守双亲委派模型，那么可以继承ClassLoader，并且在findClass中实现你自己的加载逻辑即可。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;双亲委派被破坏的例子&lt;/h3&gt;
&lt;p&gt;双亲委派机制的破坏不是什么稀奇的事情，很多框架、容器等都会破坏这种机制来实现某些功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一种被破坏的情况是在双亲委派出现之前。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于双亲委派模型是在JDK1.2之后才被引入的，而在这之前已经有用户自定义类加载器在用了。所以，这些是没有遵守双亲委派原则的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二种，是JNDI、JDBC等需要加载SPI接口实现类的情况。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三种是为了实现热插拔热部署工具。&lt;/strong&gt;为了让代码动态生效而无需重启，实现方式时把模块连同类加载器一起换掉就实现了代码的热替换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四种时tomcat等web容器的出现。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第五种时OSGI、Jigsaw等模块化技术的应用。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;为什么JNDI，JDBC等需要破坏双亲委派？&lt;/h3&gt;
&lt;p&gt;我们日常开发中，大多数时候会通过API的方式调用Java提供的那些基础类，这些基础类时被Bootstrap加载的。&lt;/p&gt;
&lt;p&gt;但是，调用方式除了API之外，还有一种SPI的方式。&lt;/p&gt;
&lt;p&gt;如典型的JDBC服务，我们通常通过以下方式创建数据库连接：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mysql&quot;, &quot;root&quot;, &quot;1234&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码执行之前，DriverManager会先被类加载器加载，因为java.sql.DriverManager类是位于rt.jar下面的 ，所以他会被根加载器加载。&lt;/p&gt;
&lt;p&gt;类加载时，会执行该类的静态方法。其中有一段关键的代码是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ServiceLoader&amp;lt;Driver&amp;gt; loadedDrivers = ServiceLoader.load(Driver.class);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码，会尝试加载classpath下面的所有实现了Driver接口的实现类。&lt;/p&gt;
&lt;p&gt;那么，问题就来了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DriverManager是被根加载器加载的，那么在加载时遇到以上代码，会尝试加载所有Driver的实现类，但是这些实现类基本都是第三方提供的，根据双亲委派原则，第三方的类不能被根加载器加载。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么，怎么解决这个问题呢？&lt;/p&gt;
&lt;p&gt;于是，就&lt;strong&gt;在JDBC中通过引入ThreadContextClassLoader（线程上下文加载器，默认情况下是AppClassLoader）的方式破坏了双亲委派原则。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们深入到ServiceLoader.load方法就可以看到：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static &amp;lt;S&amp;gt; ServiceLoader&amp;lt;S&amp;gt; load(Class&amp;lt;S&amp;gt; service) {
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    return ServiceLoader.load(service, cl);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一行，获取当前线程的线程上下⽂类加载器 AppClassLoader，⽤于加载 classpath 中的具体实现类。&lt;/p&gt;
&lt;h3&gt;为什么Tomcat要破坏双亲委派&lt;/h3&gt;
&lt;p&gt;我们知道，Tomcat是web容器，那么一个web容器可能需要部署多个应用程序。&lt;/p&gt;
&lt;p&gt;不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。&lt;/p&gt;
&lt;p&gt;如多个应用都要依赖hollis.jar，但是A应用需要依赖1.0.0版本，但是B应用需要依赖1.0.1版本。这两个版本中都有一个类是com.hollis.Test.class。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果采用默认的双亲委派类加载机制，那么是无法加载多个相同的类。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;Tomcat破坏双亲委派原则，提供隔离的机制，为每个web容器单独提供一个WebAppClassLoader加载器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Tomcat的类加载机制：为了实现隔离性，优先加载 Web 应用自己定义的类，所以没有遵照双亲委派的约定，每一个应用自己的类加载器——WebAppClassLoader负责加载本身的目录下的class文件，加载不到时再交给CommonClassLoader加载，这和双亲委派刚好相反。&lt;/p&gt;
&lt;h3&gt;模块化技术与类加载机制&lt;/h3&gt;
&lt;p&gt;近几年模块化技术已经很成熟了，在JDK 9中已经应用了模块化的技术。&lt;/p&gt;
&lt;p&gt;其实早在JDK 9之前，OSGI这种框架已经是模块化的了，&lt;strong&gt;而OSGI之所以能够实现模块热插拔和模块内部可见性的精准控制都归结于其特殊的类加载机制，加载器之间的关系不再是双亲委派模型的树状结构，而是发展成复杂的网状结构。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hollischuang.com/wp-content/uploads/2021/01/16102754973998.jpg&quot; alt=&quot;-w942&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在JDK中，双亲委派也不是绝对的了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在JDK9之前，JVM的基础类以前都是在rt.jar这个包里，这个包也是JRE运行的基石。&lt;/p&gt;
&lt;p&gt;这不仅是违反了单一职责原则，同样程序在编译的时候会将很多无用的类也一并打包，造成臃肿。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在JDK9中，整个JDK都基于模块化进行构建，以前的rt.jar, tool.jar被拆分成数十个模块，编译的时候只编译实际用到的模块，同时各个类加载器各司其职，只加载自己负责的模块。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; c = findLoadedClass(cn);
if (c == null) {
    // 找到当前类属于哪个模块
    LoadedModule loadedModule = findLoadedModule(cn);
    if (loadedModule != null) {
        //获取当前模块的类加载器
        BuiltinClassLoader loader = loadedModule.loader();
        //进行类加载
        c = findClassInModuleOrNull(loadedModule, cn);
     } else {
          // 找不到模块信息才会进行双亲委派
            if (parent != null) {
              c = parent.loadClassOrNull(cn);
            }
      }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;以上，从什么是双亲委派，到如何实现与破坏双亲委派，又从破坏双亲委派的示例等多个方面全面介绍了关于双亲委派的知识。&lt;/p&gt;
&lt;p&gt;相信通过学习本文，你一定对双亲委派机制有了更加深刻的了解。&lt;/p&gt;
&lt;p&gt;阅读过本文之后，反手在简历上写下：熟悉Java的类加载机制，不服来问！&lt;/p&gt;
&lt;center&gt;&lt;b&gt;(全文完)&lt;/b&gt;&lt;/center&gt;&lt;hr/&gt;&lt;center&gt;&lt;b&gt;扫描二维码，关注作者微信公众号&lt;/b&gt;&lt;/center&gt;&lt;img src=&quot;http://www.hollischuang.com/wp-content/uploads/2019/04/二维码.png&quot;/&gt;
&lt;/article&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0e3226abb2561066f629d96123c61f76</guid>
<title>Spring Boot 中的多数据源配置方案</title>
<link>https://toutiao.io/k/qvw7yq6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p cid=&quot;n0&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;/&gt;多数据源可以理解为多数据库，甚至可以是多个不同类型的数据库，比如一个是MySql，一个是Oracle。随着项目的扩大，有时需要数据库的拆分或者引入另一个数据库，这时就需要配置多个数据源。&lt;/p&gt;&lt;p cid=&quot;n4&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;SpringBoot中使用多数据源还是比较简单的，为了演示方便，我们在MySql中创建两个数据库：ds1、ds2，并在ds1数据库中创建student表，在ds2数据库中创建teacher表。数据库脚本如下：&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n22&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;SET NAMES utf8mb4;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;SET FOREIGN_KEY_CHECKS = 0;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;-- ----------------------------&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;-- Table structure for student&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;-- ----------------------------&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;DROP TABLE IF EXISTS `student`;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;CREATE TABLE `student`  (&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  `id` varchar(16) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  `name` varchar(64) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  `class` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  PRIMARY KEY (`id`) USING BTREE&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Dynamic;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;-- ----------------------------&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;-- Records of student&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;-- ----------------------------&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;INSERT INTO `student` VALUES (&#x27;123456&#x27;, &#x27;zhangsan&#x27;, &#x27;北京&#x27;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;INSERT INTO `student` VALUES (&#x27;123457&#x27;, &#x27;lisi&#x27;, &#x27;上海&#x27;);&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;SET FOREIGN_KEY_CHECKS = 1;&lt;/span&gt;&lt;/pre&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n45&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;SET NAMES utf8mb4;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;SET FOREIGN_KEY_CHECKS = 0;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;-- ----------------------------&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;-- Table structure for teacher&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;-- ----------------------------&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;DROP TABLE IF EXISTS `teacher`;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;CREATE TABLE `teacher`  (&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  `id` varchar(16) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  `name` varchar(32) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  `class` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  PRIMARY KEY (`id`) USING BTREE&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Dynamic;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;-- ----------------------------&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;-- Records of teacher&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;-- ----------------------------&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;INSERT INTO `teacher` VALUES (&#x27;0000001&#x27;, &#x27;wangwu&#x27;, &#x27;上海&#x27;);&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;SET FOREIGN_KEY_CHECKS = 1;&lt;/span&gt;&lt;/pre&gt;&lt;h5 cid=&quot;n43&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;基于MyBatis的多数据源实现&lt;/span&gt;&lt;/h5&gt;&lt;p cid=&quot;n57&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;首先创建一个MyBatis项目，项目结构如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.0554675118858954&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pdtTfnFrsKpDaFNbEjoGxKrBrCaMic01cN16pwt2PfHnEv3kSS7M2Zc45gPvUYL6X3ozjLuLJY7BKwtVzqnKzLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;631&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n59&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这里有一点需要注意，&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;StudentMapper&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;接口和&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;TeacherMapper&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;接口是分开的，它们位于不同子目录下，这个后面会提到。&lt;/span&gt;&lt;/p&gt;&lt;h6 cid=&quot;n61&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;数据库连接配置&lt;/span&gt;&lt;/h6&gt;&lt;p cid=&quot;n63&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;既然是多数据源，数据库连接的信息就有可能存在不同，所以需要在配置文件中配置各个数据源的连接信息（这里使用了druid数据库连接池）。&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n65&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;spring: &lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  datasource:&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    ds1: #数据源1，默认数据源&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      url: jdbc:mysql://localhost:3306/ds1?serverTimezone=GMT&amp;amp;useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      username: root&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      password: root&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      typ: com.alibaba.druid.pool.DruidDataSource&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      driver-class-name: com.mysql.cj.jdbc.Driver&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      filters: stat&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      maxActive: 2&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      initialSize: 1&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      maxWait: 60000&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      minIdle: 1&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      timeBetweenEvictionRunsMillis: 60000&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      minEvictableIdleTimeMillis: 300000&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      validationQuery: SELECT 1&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      testWhileIdle: true&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      testOnBorrow: false&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      testOnReturn: false&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      poolPreparedStatements: true&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      maxOpenPreparedStatements: 20&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      &lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    ds2: #数据源2&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      url: jdbc:mysql://localhost:3306/ds2?serverTimezone=GMT&amp;amp;useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      username: root&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      password: root&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      typ: com.alibaba.druid.pool.DruidDataSource&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      driver-class-name: com.mysql.cj.jdbc.Driver&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      filters: stat&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      maxActive: 2&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      initialSize: 1&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      maxWait: 60000&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      minIdle: 1&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      timeBetweenEvictionRunsMillis: 60000&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      minEvictableIdleTimeMillis: 300000&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      validationQuery: SELECT 1&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      testWhileIdle: true&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      testOnBorrow: false&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      testOnReturn: false&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      poolPreparedStatements: true&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      maxOpenPreparedStatements: 20&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n67&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;注意不同的数据源要用不同的属性名区分。&lt;/span&gt;&lt;/p&gt;&lt;h6 cid=&quot;n68&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;重写SpringBoot的数据源配置&lt;/span&gt;&lt;/h6&gt;&lt;p cid=&quot;n70&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;1、数据源1的配置&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n74&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;@MapperScan(basePackages = {&quot;com.chou.easyspringboot.multipledatasource.mapper.ds1&quot;}, sqlSessionFactoryRef = &quot;sqlSessionFactory1&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;public class Datasource1Configuration {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Value(&quot;${mybatis.mapper-locations}&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    private String mapperLocation;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Value(&quot;${spring.datasource.ds1.url}&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    private String jdbcUrl;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Value(&quot;${spring.datasource.ds1.driver-class-name}&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    private String driverClassName;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Value(&quot;${spring.datasource.ds1.username}&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    private String username;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Value(&quot;${spring.datasource.ds1.password}&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    private String password;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Value(&quot;${spring.datasource.ds1.initialSize}&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    private int initialSize;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Value(&quot;${spring.datasource.ds1.minIdle}&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    private int minIdle;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Value(&quot;${spring.datasource.ds1.maxActive}&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    private int maxActive;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Bean(name = &quot;dataSource1&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Primary&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    public DataSource dataSource() {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        DruidDataSource dataSource = new DruidDataSource();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        dataSource.setUrl(jdbcUrl);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        dataSource.setDriverClassName(driverClassName);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        dataSource.setUsername(username);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        dataSource.setPassword(password);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        dataSource.setInitialSize(initialSize);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        dataSource.setMinIdle(minIdle);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        dataSource.setMaxActive(maxActive);&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        return dataSource;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Bean(&quot;sqlSessionFactory1&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    public SqlSessionFactory sqlSessionFactory(@Qualifier(&quot;dataSource1&quot;) DataSource dataSource) throws Exception {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        sqlSessionFactoryBean.setDataSource(dataSource);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        sqlSessionFactoryBean.setMapperLocations(&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;                new PathMatchingResourcePatternResolver().getResources(mapperLocation));&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        return sqlSessionFactoryBean.getObject();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Bean(&quot;sqlSessionTemplate1&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    public SqlSessionTemplate sqlSessionTemplate(@Qualifier(&quot;sqlSessionFactory1&quot;) SqlSessionFactory sqlSessionFactory) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        return new SqlSessionTemplate(sqlSessionFactory);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Bean(&quot;transactionManager1&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    public DataSourceTransactionManager transactionManager(@Qualifier(&quot;dataSource1&quot;)DataSource dataSource) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        return new DataSourceTransactionManager(dataSource);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n76&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2、数据源2的配置&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n81&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;@MapperScan(basePackages = {&quot;com.chou.easyspringboot.multipledatasource.mapper.ds2&quot;}, sqlSessionFactoryRef = &quot;sqlSessionFactory2&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;public class Datasource2Configuration {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Value(&quot;${mybatis.mapper-locations}&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    private String mapperLocation;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Value(&quot;${spring.datasource.ds2.url}&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    private String jdbcUrl;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Value(&quot;${spring.datasource.ds2.driver-class-name}&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    private String driverClassName;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Value(&quot;${spring.datasource.ds2.username}&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    private String username;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Value(&quot;${spring.datasource.ds2.password}&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    private String password;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Value(&quot;${spring.datasource.ds2.initialSize}&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    private int initialSize;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Value(&quot;${spring.datasource.ds2.minIdle}&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    private int minIdle;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Value(&quot;${spring.datasource.ds2.maxActive}&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    private int maxActive;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Bean(name = &quot;dataSource2&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    public DataSource dataSource() {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        DruidDataSource dataSource = new DruidDataSource();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        dataSource.setUrl(jdbcUrl);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        dataSource.setDriverClassName(driverClassName);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        dataSource.setUsername(username);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        dataSource.setPassword(password);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        dataSource.setInitialSize(initialSize);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        dataSource.setMinIdle(minIdle);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        dataSource.setMaxActive(maxActive);&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        return dataSource;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Bean(&quot;sqlSessionFactory2&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    public SqlSessionFactory sqlSessionFactory(@Qualifier(&quot;dataSource2&quot;) DataSource dataSource) throws Exception {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        sqlSessionFactoryBean.setDataSource(dataSource);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        sqlSessionFactoryBean.setMapperLocations(&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;                new PathMatchingResourcePatternResolver().getResources(mapperLocation));&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        return sqlSessionFactoryBean.getObject();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Bean(&quot;sqlSessionTemplate2&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    public SqlSessionTemplate sqlSessionTemplate(@Qualifier(&quot;sqlSessionFactory2&quot;) SqlSessionFactory sqlSessionFactory) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        return new SqlSessionTemplate(sqlSessionFactory);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Bean(&quot;transactionManager2&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    public DataSourceTransactionManager transactionManager(@Qualifier(&quot;dataSource2&quot;) DataSource dataSource) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        return new DataSourceTransactionManager(dataSource);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n83&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这里和单数据源不同的地方在于对&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;dataSource&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;、&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;sqlSessionFactory&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;、&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;sqlSessionTemplate&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;、&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;transactionManager&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;都进行了单独的配置。另外，数据源1和数据源2主要存在两点不同：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; cid=&quot;n106&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n103&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;@MapperScan&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;中的包扫描路径不一样，数据源1只扫描&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;com.chou.easyspringboot.multipledatasource.mapper.ds1&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;路径下的&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;Mapper&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;，数据源2负责&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;com.chou.easyspringboot.multipledatasource.mapper.ds2下Mapper&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;，所以在前面创建的时候我们要把&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;StudentMapper&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;和&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;TeacherMapper&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;分开。因为在这里已经配置了&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;@MapperScan&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;，所以在启动类中必须不能在存在&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;@MapperScan&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;注解&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n107&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;数据源1中多一个&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;@Primary&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;注解，这是告诉Spring我们使用的默认数据源，也是多数据源项目中必不可少的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h6 cid=&quot;n117&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;测试&lt;/span&gt;&lt;/h6&gt;&lt;p cid=&quot;n118&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;编写相应的Controller和Service层代码，查询所有的Student和Teacher信息，并使用postman模拟发送请求，会有如下的运行结果：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.49921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pdtTfnFrsKpDaFNbEjoGxKrBrCaMic01cmhB7uzMUcySjpNVsKyaibmiaT77fibEjI10S1aYROAo5Yic26rUqy6vEuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pdtTfnFrsKpDaFNbEjoGxKrBrCaMic01cf3znHvma5jl1diaxuKFh4400iaPOadUYWukn9ELzVBvdur6FOkHsvXuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n134&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;我们连续发送两个不同的请求，都得出了想要的结果，说明MyBatis自动帮我们切换到了对应的数据源上。&lt;/span&gt;&lt;/p&gt;&lt;h5 cid=&quot;n135&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;基于自定义注解实现多数据源&lt;/span&gt;&lt;/h5&gt;&lt;p cid=&quot;n136&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;上面我们提高到数据源自动切换主要依靠MyBatis，如果项目中没有使用MyBatis该如何做呢？&lt;/span&gt;&lt;/p&gt;&lt;h6 cid=&quot;n146&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;多数据源自动切换原理&lt;/span&gt;&lt;/h6&gt;&lt;p cid=&quot;n151&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这里介绍一种基于自定义注解的方法实现多数据源的动态切换。SpringBoot中有一个&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;AbstractRoutingDataSource&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;抽象类，我们可以实现其抽象方法&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;determineCurrentLookupKey()&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;去指定数据源。并通过AOP编写自定义注解处理类，在sql语句执行前，切换到自定义注解中设置的数据源以实现数据源的自动切换。&lt;/span&gt;&lt;/p&gt;&lt;h6 cid=&quot;n137&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;数据库连接配置&lt;/span&gt;&lt;/h6&gt;&lt;p cid=&quot;n139&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;同上配置两个数据库连接信息。&lt;/span&gt;&lt;/p&gt;&lt;h6 cid=&quot;n140&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;创建数据源存放类&lt;/span&gt;&lt;/h6&gt;&lt;p cid=&quot;n174&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;是和线程绑在一起的，因此，我们需要一个线程安全的类来存放&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;，在&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;determineCurrentLookupKey()&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;中通过该类获取数据源。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n175&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;AbstractRoutingDataSource&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;类中，&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;以键值对的形式保存，可以使用&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;来保存key，从而实现多数据源的自动切换。&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n143&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;public class DataSourceContextHolder {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    private static Logger logger = LoggerFactory.getLogger(DataSourceContextHolder.class);&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    // 使用ThreadLocal线程安全的使用变量副本&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    private static final ThreadLocal&amp;lt;String&amp;gt; CONTEXT_HOLDER = new ThreadLocal&amp;lt;String&amp;gt;();&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    /**&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;     * 设置数据源&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;     * */&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    public static void setDataSource(String dataSource) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        logger.info(&quot;切换到数据源：{}&quot;, dataSource);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        CONTEXT_HOLDER.set(dataSource);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    /**&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;     * 获取数据源&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;     * */&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    public static String getDataSource() {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        return CONTEXT_HOLDER.get();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    /**&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;     * 清空数据源&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;     * */&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    public static void clearDataSource() {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        CONTEXT_HOLDER.remove();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;p mdtype=&quot;paragraph&quot; cid=&quot;n159&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;数据源持有类定义了三个方法，分别用于数据源的设置、获取和清除。&lt;/span&gt;&lt;/p&gt;&lt;h6 cid=&quot;n165&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;创建数据源枚举类&lt;/span&gt;&lt;/h6&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n162&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;public enum DataSourceEnum {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    PRIMARY, //默认数据源&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    DATASOURCE1&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;h6 cid=&quot;n180&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;实现 determineCurrentLookupKey 方法指定数据源&lt;/span&gt;&lt;/h6&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n182&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;public class DynamicDataSource extends AbstractRoutingDataSource {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Override&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    protected Object determineCurrentLookupKey() {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        return DataSourceContextHolder.getDataSource();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;h6 cid=&quot;n186&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;配置数据源&lt;/span&gt;&lt;/h6&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n189&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;public class DynamicDataSourceConfiguration {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Bean(name = &quot;primaryDataSource&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @ConfigurationProperties(prefix = &quot;spring.datasource.ds1&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    public DataSource primaryDataSource(){&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        return new DruidDataSource();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Bean(name = &quot;dataSource1&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @ConfigurationProperties(prefix = &quot;spring.datasource.ds2&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    public DataSource dataSource1(){&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        return new DruidDataSource();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Bean(&quot;dynamicDataSource&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Primary&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    public DataSource dynamicDataSource() {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        DynamicDataSource dynamicDataSource = new DynamicDataSource();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        //配置默认数据源&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        dynamicDataSource.setDefaultTargetDataSource(primaryDataSource());&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        //配置多数据源&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        HashMap&amp;lt;Object, Object&amp;gt; dataSourceMap = new HashMap();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        dataSourceMap.put(DataSourceEnum.PRIMARY.name(),primaryDataSource());&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        dataSourceMap.put(DataSourceEnum.DATASOURCE1.name(),dataSource1());&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        dynamicDataSource.setTargetDataSources(dataSourceMap);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        return dynamicDataSource;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;h6 cid=&quot;n192&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;自定义注解&lt;/span&gt;&lt;/h6&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n195&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;@Target(ElementType.METHOD)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;@Retention(RetentionPolicy.RUNTIME)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;@Documented&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;public @interface DataSource {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    DataSourceEnum value() default DataSourceEnum.PRIMARY;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n197&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;自定义注解指定作用于方法上并在运行期生效（可以在网上查下如何自定义注解，这里不在讲述）。&lt;/span&gt;&lt;/p&gt;&lt;h6 cid=&quot;n198&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;AOP拦截&lt;/span&gt;&lt;/h6&gt;&lt;p cid=&quot;n200&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;通过AOP在执行sql语句前拦截，并切换到自定义注解指定的数据源上。有一点需要注意，自定义数据源注解与&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;@Transaction&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;注解同一个方法时会先执行&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;@Transaction&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;，即获取数据源在切换数据源之前，所以会导致自定义注解失效，因此需要使用&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;@Order&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;(@Order的value越小，就越先执行)，保证该AOP在&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;@Transactional&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;之前执行。&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n203&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;@Aspect&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;@Order(-1)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;public class DataSourceAspect {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Pointcut(&quot;@annotation(com.chou.easyspringboot.multipledatasource.annotation.DataSource)&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    public void dataSourcePointCut() {&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    @Around(&quot;dataSourcePointCut()&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    public Object dataSourceArround(ProceedingJoinPoint proceed) throws Throwable {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        MethodSignature methodSignature = (MethodSignature) proceed.getSignature();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        Method method = methodSignature.getMethod();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        DataSource dataSource = method.getAnnotation(DataSource.class);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        if(dataSource != null) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;            DataSourceContextHolder.setDataSource(dataSource.value().name());&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        try {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;            return proceed.proceed();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        } finally {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;            // 方法执行后销毁数据源&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;            DataSourceContextHolder.clearDataSource();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;h6 cid=&quot;n207&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;创建启动类，编写Controller、Service层代码&lt;/span&gt;&lt;/h6&gt;&lt;p cid=&quot;n208&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;需要在启动类的&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;@SpringBootApplication&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;注解中移除DataSource自动配置类，否则会默认自动配置，而不会使用我们自定义的DataSource，并且启动会有循环依赖的错误。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n218&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;public class EasyspringbootMultipledatasourceApplication {&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;   public static void main(String[] args) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;      SpringApplication.run(EasyspringbootMultipledatasourceApplication.class, args);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;   }&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;h6 cid=&quot;n220&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;测试&lt;/span&gt;&lt;/h6&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.49921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pdtTfnFrsKpDaFNbEjoGxKrBrCaMic01cmhB7uzMUcySjpNVsKyaibmiaT77fibEjI10S1aYROAo5Yic26rUqy6vEuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pdtTfnFrsKpDaFNbEjoGxKrBrCaMic01cf3znHvma5jl1diaxuKFh4400iaPOadUYWukn9ELzVBvdur6FOkHsvXuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n237&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;我们得到了正确的结果，数据源自动切换了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n238&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n240&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;项目完整代码：&lt;/span&gt;&lt;span md-inline=&quot;link&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;https://github.com/Mark-Chou20/easy-springboot&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>95ff2d4b8c4ca4e977f45d69263d3c02</guid>
<title>云原生数据中心网络设计 (O&#x27;Reilly 2019)</title>
<link>https://toutiao.io/k/po18xi1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post&quot;&gt;
  
  &lt;h1 class=&quot;postTitle&quot;&gt;[笔记] Cloud Native Data Center Networking (O&#x27;Reilly 2019)&lt;/h1&gt;
  &lt;p class=&quot;meta&quot;&gt;Published at 2021-01-10 | Last Update 2021-01-10&lt;/p&gt;

  
  
  &lt;h3 id=&quot;关于本文&quot;&gt;关于本文&lt;/h3&gt;

&lt;p&gt;本文是读 &lt;a href=&quot;https://www.oreilly.com/library/view/cloud-native-data/9781492045595/&quot;&gt;Cloud Native Data Center Networking&lt;/a&gt; （
O’Reilly, 2019）时的所做的一些笔记。这本书理论和实践兼备，是现代数据中心网络、云
原生数据中心网络设计和 BGP 的很好入门参考。&lt;/p&gt;

&lt;p&gt;作者 Dinesh G. Dutt 是一家网络公司的首席科学家，在网络行业有 20 多年工作经验，曾
是 Cisco Fellow，是 TRILL、VxLAN 等协议的合作者（co-author）之一。&lt;/p&gt;

&lt;hr/&gt;



&lt;hr/&gt;

&lt;h1 id=&quot;1-传统网络架构面临瓶颈&quot;&gt;1 传统网络架构面临瓶颈&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;分布式应用&lt;/strong&gt;（distributed application）正在与&lt;strong&gt;网络&lt;/strong&gt;（network）共舞，而且
前者是主角。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分布式应用突然变换了舞步，现代数据中心的故事也由此开始。&lt;/strong&gt;
&lt;mark&gt;理解这种转变对网络从业人员至关重要，否则只会不断被一些新名词带着走&lt;/mark&gt;。&lt;/p&gt;

&lt;p&gt;本章回答以下问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;新一代应用（new applications）有哪些特征？&lt;/li&gt;
  &lt;li&gt;什么是接入-汇聚-核心（access-aggregation-core）网络？&lt;/li&gt;
  &lt;li&gt;接入-汇聚-核心网络架构在哪些方面已经无法满足新一代应用的需求？&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;11-应用-网络架构演进&quot;&gt;1.1 “应用-网络”架构演进&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/cloud-native-dc-networking/1-1.png&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;Fig 1-1. The evolution of application architecture&lt;/p&gt;

&lt;p&gt;应用架构演进：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;单体应用&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;通常部署在 mainframe 上。&lt;/li&gt;
      &lt;li&gt;特定的厂商提供网络方案，&lt;strong&gt;协议是私有的&lt;/strong&gt;（不是 TCP/IP 协议）。&lt;/li&gt;
      &lt;li&gt;以今天的眼光看，应用所需的带宽极小。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;客户端-服务器应用&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;工作站和 PC 时代。&lt;/li&gt;
      &lt;li&gt;LAN 开始兴起。&lt;strong&gt;充斥着各种 L2、L3 和更上层协议&lt;/strong&gt;。
        &lt;ul&gt;
          &lt;li&gt;以太网、Token Ring、FDDI 等是比较流行的互连方式。带宽上限 100Mbps。&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;TCP/IP 体系开始发展&lt;/strong&gt;，但还没用成为主流。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Web 应用&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;mark&gt;以太网和 TCP/IP 一统互联网&lt;/mark&gt;，其他绝大部分协议成为历史。&lt;/li&gt;
      &lt;li&gt;计算和网络虚拟化：&lt;strong&gt;虚拟机时代&lt;/strong&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;微服务（分布式应用）&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;大规模的数据处理（例如 MapReduce），使数据中心网络的带宽瓶颈&lt;strong&gt;从南北向变成东西向&lt;/strong&gt;，这是一个历史性的转变。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;容器时代&lt;/strong&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;12-21-世纪以来的网络设计&quot;&gt;1.2 21 世纪以来的网络设计&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/cloud-native-dc-networking/1-2.png&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;Fig 1-2. Access-aggregation-core network architecture&lt;/p&gt;

&lt;p&gt;图 1-2 是在上世纪末开始占据统治地位的网络架构：接入-汇聚-核心三级网络架构。&lt;/p&gt;

&lt;p&gt;图中&lt;strong&gt;没有画出汇聚和核心之间的连接&lt;/strong&gt;，是因为这些连接&lt;strong&gt;因方案和厂商而异&lt;/strong&gt;，而且
不影响接下来的讨论。&lt;/p&gt;

&lt;h3 id=&quot;桥接bridging的魅力&quot;&gt;桥接（Bridging）的魅力&lt;/h3&gt;

&lt;p&gt;这种网络架构&lt;strong&gt;重度依赖交换&lt;/strong&gt;（或称桥接，bridging），而在同时期，互联网（the
internet）真正快速发展成型。&lt;/p&gt;

&lt;p&gt;&lt;mark&gt;既然支撑互联网的是 IP 路由（IP routing）技术，为什么数据中心网络没有选择路
由（routing），而是选择的交换（bridging）呢？&lt;/mark&gt;三方面原因：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;交换芯片&lt;/strong&gt;的出现（silicon switched packet forwarding）&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;做数据转发的芯片原先主要用在&lt;strong&gt;网卡&lt;/strong&gt;，现在用于功能更强大的&lt;strong&gt;交换设备&lt;/strong&gt;。&lt;/li&gt;
      &lt;li&gt;这种设备显然要求芯片具备&lt;strong&gt;更高密度的接口&lt;/strong&gt;，而这样的芯片在当时&lt;strong&gt;只支持交换&lt;/strong&gt;（bridging），不支持路由（routing）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;厂商特定的软件栈&lt;/strong&gt;（proprietary network software stacks）在企业中占据主导地位&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;“客户端-服务器”模型所处的时代，TCP/IP 只是众多协议种的一种，并没有今天所处的统治地位。&lt;/li&gt;
      &lt;li&gt;但各家的协议有一个共同点：&lt;strong&gt;二层协议是一样的，都是走交换&lt;/strong&gt;（bridging）。因
此&lt;strong&gt;汇聚层以下走交换&lt;/strong&gt;就是顺理成章也是唯一的选择。&lt;/li&gt;
      &lt;li&gt;接入-汇聚-核心成为了一种&lt;strong&gt;通用的网络架构&lt;/strong&gt;：
        &lt;ul&gt;
          &lt;li&gt;汇聚以下走交换（bridging），不区分厂商&lt;/li&gt;
          &lt;li&gt;汇聚以上走各家的三层协议&lt;/li&gt;
          &lt;li&gt;这样就避免了为每家厂商的设备单独搭建一张网络。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;交换网络&lt;/strong&gt;所宣称的&lt;strong&gt;零配置&lt;/strong&gt;（zero configuration of bridging）&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;路由网络很难配置，甚至对某些厂商的设备来说，直到今天仍然如此。需要很多显式
配置。&lt;/li&gt;
      &lt;li&gt;相比交换，路由的延迟更大，更消耗 CPU 资源。&lt;/li&gt;
      &lt;li&gt;交换网络是自学习的（self-learning），也是所谓的“零配置”（zero
configurations）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;构建和扩展的桥接网络&quot;&gt;构建和扩展的桥接网络&lt;/h3&gt;

&lt;p&gt;厂商设备无关、高性能芯片加上零配置，使得桥接网络在那个年代取得很大成功。但这种网
络也存在一些&lt;strong&gt;限制&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;广播风暴和 STP：这是自学习的机制决定的，&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;MAC 头中没有 TTL 字段，因此一旦形成环路就无法停下来。&lt;/li&gt;
      &lt;li&gt;STP（生成树协议）：避免交换网络出现环路，非常复杂，因此很难做到没有 bug。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;泛洪成本&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;大的交换网络的泛洪&lt;/li&gt;
      &lt;li&gt;缓解：划分 VLAN，使得泛洪域限制到 VLAN 内。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;网关高可用&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;网关&lt;/strong&gt;配置在&lt;strong&gt;汇聚交换机&lt;/strong&gt;。&lt;/li&gt;
      &lt;li&gt;为保证高可用，一组汇聚配置同一个网关；一台挂掉后自动切换到另一台。需要协议
支持，这种协议称为&lt;strong&gt;第一跳路由协议&lt;/strong&gt;（First Hop Routing Protocol, &lt;strong&gt;FHRP&lt;/strong&gt;）。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;FHRP 原理&lt;/strong&gt;：几台路由器之间互相检测状态，确保永远有且只有一台在应答对网关的 ARP 请求。&lt;/p&gt;

    &lt;p&gt;FHRP 协议举例：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;HSRP（Hot Standby Routing Protocol）：思科的私有协议。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;VRRP&lt;/strong&gt;（Virtual Router Rundundency Protocol）：目前用的最多的协议。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;13-接入-汇聚-核心网络架构存在的问题&quot;&gt;1.3 接入-汇聚-核心网络架构存在的问题&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;广播风暴&lt;/strong&gt;是所有在那个年代运维过这种网络的网工们的噩梦 —— 即便已经开启了 STP。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;应用（applications）变了&lt;/strong&gt; —— 服务器之间的东西向流量开始成为瓶颈，而这种网络架构主要面向的是“客
户端-服务器”模式的南北向流量时代。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;应用的规模&lt;/strong&gt;显著变大，在故障、复杂性和敏捷度方面对网络提出了完全不同于以往的新需求。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现有网络架构无法解决以上问题。&lt;/p&gt;

&lt;h3 id=&quot;不可扩展性unscalability&quot;&gt;不可扩展性（Unscalability）&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;泛洪&lt;/p&gt;

    &lt;p&gt;自学习机制是 “flood-and-learn”，因此泛洪是不可避免的。当网络规模非常大时
（例如大规模虚拟机场景），定期地会有上百万的泛洪包，终端计算节点不堪重负。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;VLAN 限制&lt;/p&gt;

    &lt;p&gt;VLAn 总共 4096 个，无法满足云计算时代的多租户需求。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;汇聚应答 ARP 的负担&lt;/p&gt;

    &lt;p&gt;汇聚负责应答 ARP。ARP 数量可能非常多，导致汇聚交换机 CPU 飙升。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;交换机水平扩展性和 STP 限制&lt;/p&gt;

    &lt;p&gt;理论上，增加汇聚交换机数量似乎就能增加东西向带宽。但是，&lt;strong&gt;STP 不支持两个以上
  的交换机&lt;/strong&gt;场景，否则后果无法预测。因此汇聚交换机就固定在了两个，无法扩展。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;复杂性complexity&quot;&gt;复杂性（Complexity）&lt;/h3&gt;

&lt;p&gt;交换网络需要运行大量不同类型的协议，例如：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;STP&lt;/li&gt;
  &lt;li&gt;FHRP&lt;/li&gt;
  &lt;li&gt;链路检测协议&lt;/li&gt;
  &lt;li&gt;厂商特定的协议，例如 VLAN Trunking Protocol（VTP）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;显著增加了网络的复杂性。&lt;/p&gt;

&lt;p&gt;STP 使得网络只能用到一半的链路带宽。&lt;/p&gt;

&lt;h3 id=&quot;故障域failure-domain&quot;&gt;故障域（Failure Domain）&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;一条链路挂掉，可用带宽减半。&lt;/li&gt;
  &lt;li&gt;一台汇聚挂掉，整个网络的带宽减半；而且此时所有流量都会打到同组的另一台汇聚，很
容易导致这一台也扛不住，即发生级联故障。&lt;/li&gt;
  &lt;li&gt;级联故障的另一种场景：广播风暴，整个系统全挂。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;不可预测性unpredictability&quot;&gt;不可预测性（Unpredictability）&lt;/h3&gt;

&lt;p&gt;STP 的行为无法预测。一些常规故障或设备维护都可能导致 STP 故障。&lt;/p&gt;

&lt;h3 id=&quot;欠灵活性inflexibility&quot;&gt;欠灵活性（Inflexibility）&lt;/h3&gt;

&lt;p&gt;&lt;mark&gt;VLAN 在汇聚交换机终结&lt;/mark&gt;，即在交换（bridging）和路由（routing）的边界终结。&lt;/p&gt;

&lt;p&gt;网工无法灵活地将任意可用接口分配给用
户的VLAN（需要端到端的链路都有可用接口才行）。&lt;/p&gt;

&lt;h3 id=&quot;欠敏捷性lack-of-agility&quot;&gt;欠敏捷性（Lack of Agility）&lt;/h3&gt;

&lt;p&gt;云计算场景下，需要非常快速的网络资源交付。&lt;/p&gt;

&lt;p&gt;VLAN 需要整条链路端到端的配置和感知，而且配置会引起控制平面的 STP 等协议震荡（收
敛），容易引起网络故障。因此添加或删除 VLAN 都需要天级别的时间。&lt;/p&gt;

&lt;h2 id=&quot;14-the-stories-not-told&quot;&gt;1.4 The Stories Not Told&lt;/h2&gt;

&lt;p&gt;一些对这种网络方案的改进尝试：TRILL 和 MLAG。&lt;/p&gt;

&lt;p&gt;经过时间沉淀，&lt;strong&gt;其他各种上层协议（L3+）已经退潮，IP 协议成为唯一主流&lt;/strong&gt;。
&lt;mark&gt;是时候从网络需求出发，设计一种新的架构了&lt;/mark&gt;。&lt;/p&gt;

&lt;h2 id=&quot;15-小结&quot;&gt;1.5 小结&lt;/h2&gt;

&lt;p&gt;本章我们看到了&lt;strong&gt;应用架构&lt;/strong&gt;（application architecture）是如何驱动&lt;strong&gt;网络架构&lt;/strong&gt;演进的。&lt;/p&gt;

&lt;h1 id=&quot;2-clos新一代网络架构&quot;&gt;2 CLOS：新一代网络架构&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Form is destiny — in networking even more than in life. The structure of the
network lays the foundation for everything that follows.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;形式决定结果 —— 在网络世界尤其如此。&lt;strong&gt;网络结构&lt;/strong&gt;为后面的所有东西
奠定了基础，正如树根与树干、树冠的关系一样。&lt;strong&gt;新一代的结构就是&lt;/strong&gt;：CLOS 拓扑。&lt;/p&gt;

&lt;p&gt;云原生数据中心基础设施的先行者们希望打造一种&lt;mark&gt;具备大规模扩展性的东西&lt;/mark&gt;。
CLOS 拓扑就像红杉树，用一种类似&lt;strong&gt;分形&lt;/strong&gt;的模型（fractal model）实现了&lt;strong&gt;水平扩展&lt;/strong&gt;（scale out）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本书主要内容就是 CLOS 拓扑中的网络设计&lt;/strong&gt;。&lt;mark&gt;CLOS 拓扑及其特性，
是每一位网络工程师和网络架构师的必修课&lt;/mark&gt;。&lt;/p&gt;

&lt;h2 id=&quot;21-introducing-the-clos-topology&quot;&gt;2.1 Introducing the Clos Topology&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/cloud-native-dc-networking/2-1.png&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;Fig 2-1. Illustration of a common Clos topology&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Spine 和 Leaf 可以是同一种交换机&lt;/strong&gt;，这虽然不是强制要求，但&lt;strong&gt;同构设备&lt;/strong&gt;的使用会
给这种架构带来明显收益。&lt;/p&gt;

&lt;p&gt;Spine-Leaf 架构的容量（capacity）很高，因为&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;任何两台服务器之间都有多条可达路径。&lt;/li&gt;
  &lt;li&gt;添加 Spine 节点可以直接扩展 Leaf 之间的可用带宽。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;mark&gt;Spine 交换机只有一个目的&lt;/mark&gt;：连接所有的 Leaf 节点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;服务器不会直连到 Spine。&lt;/li&gt;
  &lt;li&gt;Spine 也不承担其他的功能。因此 Spine 与三级架构中的汇聚交换机的角色是不一样的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总结起来就是，Spine-Leaf 架构中，&lt;mark&gt;所有功能都下放到了边缘节点&lt;/mark&gt;（Leaf
和服务器），&lt;mark&gt;中心节点（Spine）只提供连接功能&lt;/mark&gt;。&lt;/p&gt;

&lt;p&gt;水平扩展（scale-out）和垂直扩展（scale-in）：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Spine-Leaf 架构可以实现良好的水平扩展（scale-out)：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;添加 Leaf 和服务器节点：扩展系统容量。&lt;/li&gt;
      &lt;li&gt;增加 Spine 节点：扩展互连带宽。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Access-Aggregation-Core 架构扩展容量的方式：只能替换成性能更强的设备，称为垂直扩展（scale-in）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;22-深入理解-clos-架构&quot;&gt;2.2 深入理解 Clos 架构&lt;/h2&gt;

&lt;h3 id=&quot;使用同构设备&quot;&gt;使用同构设备&lt;/h3&gt;

&lt;p&gt;CLOS 架构的一个好处是：&lt;strong&gt;只用一种设备就能构建出超大型网络&lt;/strong&gt;（build very large
packet-switched networks using simple fixed-form-factor switches）。&lt;/p&gt;

&lt;p&gt;从根本上改变了我们思考网络故障、管理网络设备，以及设计和管理网络的方式。&lt;/p&gt;

&lt;h3 id=&quot;使用路由作为基本互连模型&quot;&gt;使用路由作为基本互连模型&lt;/h3&gt;

&lt;p&gt;接入-汇聚-核心三级网络架构的一个固有限制是：&lt;mark&gt;只能支持两台汇聚交换机&lt;/mark&gt;。
那 CLOS 架构是如何支持多台 Spine 的呢？答案是：CLOS 中不再使用 STP，交换机之间的
互连不再走桥接（bridging），而是走路由（routing）。&lt;/p&gt;

&lt;p&gt;但并不是说 CLOS 中不再有桥接，只不过转发已经限制到了边缘节点，即
Leaf 交换机和服务器之间。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;同一个机柜内，同网段之间：走桥接（bridging）。&lt;/li&gt;
  &lt;li&gt;跨机柜实现 bridging：可以借助 VxLAN。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前面提到，用交换（bridging）做交换机互连的原因之一是：&lt;strong&gt;各厂商有不同的三层协议，
只有二层是相同的，都是以太网&lt;/strong&gt;。发展到后来，各种三层协议逐渐淘汰，IP 协议作为唯一
的三层协议一统江湖，因此&lt;strong&gt;用 bridging 方式做交换机互连&lt;/strong&gt;已经不是必须的了。&lt;/p&gt;

&lt;p&gt;那&lt;mark&gt;路由方式（routing）到底是如何支持多台 Spine 的呢&lt;/mark&gt;？答案：ECMP。&lt;/p&gt;

&lt;p&gt;从本质上来说，CLOS 拓扑是用路由（routing）替代了原来的交换（switching），作为最
主要的数据包转发方式（primary packet forwarding model）。&lt;/p&gt;

&lt;h3 id=&quot;收敛比oversubscription&quot;&gt;收敛比（Oversubscription）&lt;/h3&gt;

&lt;p&gt;&lt;mark&gt;收敛比：下行带宽 / 上行带宽。&lt;/mark&gt;&lt;/p&gt;

&lt;p&gt;收敛比是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1:1&lt;/code&gt; 的网络称为&lt;strong&gt;无阻塞网络&lt;/strong&gt;（nonblocking network）。&lt;/p&gt;

&lt;p&gt;如果 Spine 和 Leaf 都是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; 端口交换机，那 CLOS 拓扑&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;mark&gt;支持的最大服务器数量&lt;/mark&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n*n/2&lt;/code&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;n=64 时，支持 2048 台服务器&lt;/li&gt;
      &lt;li&gt;n=128 时，支持 8192 台服务器&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;mark&gt;所需的交换机数量&lt;/mark&gt;（假设无阻塞网络）：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n + n/2&lt;/code&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;n 台 leaf，n/2 台 spine&lt;/li&gt;
      &lt;li&gt;n=64 时，需要 96 台交换机&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;互连带宽&quot;&gt;互连带宽&lt;/h3&gt;

&lt;p&gt;ISL: inter-switch link。&lt;/p&gt;

&lt;p&gt;更大的 Spine-Leaf 互连带宽的好处：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;减少布线成本（cost of cabling）。&lt;/li&gt;
  &lt;li&gt;减少 Spine 交换机数量。&lt;/li&gt;
  &lt;li&gt;减小运维负担。&lt;/li&gt;
  &lt;li&gt;任何一条互连链路被单个大象流打爆的概率更低。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;实际中的一些限制&quot;&gt;实际中的一些限制&lt;/h3&gt;

&lt;p&gt;考虑到制冷、机柜尺寸、服务器封装、交换机芯片等方面的原因，以上的理论并不能原封不
动落实到实际的数据中心中。&lt;/p&gt;

&lt;p&gt;受电源功率限制，单个机柜一般不超过 20 台服务器。考虑到散热能力，这个限制可能会更
小。&lt;/p&gt;

&lt;p&gt;实际中很少需要无阻塞网络，Spine 和 Leaf 也使用不同类似的设备。商业芯片厂商一般会
&lt;strong&gt;提供配套的 Spine 和 Leaf 交换芯片&lt;/strong&gt;，例如 Broadcom 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Trident&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Tomahawk&lt;/code&gt;
系列。&lt;/p&gt;

&lt;h3 id=&quot;更细粒度的故障域&quot;&gt;更细粒度的故障域&lt;/h3&gt;

&lt;p&gt;有了多台 Spine 之后，挂掉一台就不会产生灾难性的影响。例如，假如有 16 台 Spine，
那平均来说，挂掉一台只会影响 1/16 的流量。而在传统网络中，挂掉一台汇聚会影响 1/2
的流量。&lt;/p&gt;

&lt;p&gt;另外，挂掉一条链路（link）时，只影响一台 leaf 到一台 spine 之间的流量，这台 leaf
到其他 spine 的流量是不受影响的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;there are no systemic failures of the style found in access-agg networks due
to the use of routing, not bridging, for packet switching.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;用路由代替交换，使得 CLOS 架构消除了&lt;strong&gt;系统性故障&lt;/strong&gt;（systemic failures）的风险，
而接入-汇聚-核心三级网络架构是无法消除这种风险的（例如，全网广播风暴）。&lt;/p&gt;

&lt;h2 id=&quot;23-扩展-close-拓扑scaling-the-clos-topology&quot;&gt;2.3 扩展 Close 拓扑（Scaling the Clos Topology）&lt;/h2&gt;

&lt;p&gt;前面看到，128 端口的两级 CLOS 架构最多支持 8192 台服务器。如何设计出能支撑更多服
务器的 CLOS 架构呢？答案是三级（甚至更多级）CLOS 架构。&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/cloud-native-dc-networking/2-5.png&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;Fig 2-5. Three-tier Clos topology with four-port switches&lt;/p&gt;

&lt;p&gt;上图中有两种三级 CLOS 的设计：&lt;/p&gt;



&lt;p&gt;三级 CLOS 服务器和交换机数量：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;支撑的最大服务器数量：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n*n*n/4&lt;/code&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;n=64 时，支撑 65536 台服务器。&lt;/li&gt;
      &lt;li&gt;n=128 时，支撑 524288 台服务器。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;所需交换机数量：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n + n*n&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;24-对比两种-three-tier-models&quot;&gt;2.4 对比两种 Three-Tier Models&lt;/h2&gt;

&lt;h2 id=&quot;25-clos-拓扑带来的其他变化&quot;&gt;2.5 Clos 拓扑带来的其他变化&lt;/h2&gt;

&lt;h3 id=&quot;重新思考-failures-and-troubleshooting&quot;&gt;重新思考 Failures and Troubleshooting&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;设备类型更单一，故障类型更明确。&lt;/li&gt;
  &lt;li&gt;从少数大型设备变成数量较多的小型设备：出故障时直接拉出和替换（swap-out failing
switches），而不是现场排障（troubleshooting a failure in a live network）。&lt;/li&gt;
  &lt;li&gt;以前更看重设备的新功能提供能量，现在更看重遇到故障时网络的弹性（resilience）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;布线&quot;&gt;布线&lt;/h3&gt;

&lt;p&gt;CLOS 架构是富连接（richly connected）或称全连接（full mesh）网络，因此所需的布线
工作量大大增加。&lt;/p&gt;

&lt;h3 id=&quot;inventory-management-更简单&quot;&gt;Inventory Management 更简单&lt;/h3&gt;

&lt;p&gt;设备都是一致的，没有特殊性，管理起来更简单。管理交换机就像管理 Linux 服务器一样。&lt;/p&gt;

&lt;h3 id=&quot;网络自动化&quot;&gt;网络自动化&lt;/h3&gt;

&lt;p&gt;便于自动化。&lt;/p&gt;

&lt;h2 id=&quot;26-some-best-practices-for-a-clos-network&quot;&gt;2.6 Some Best Practices for a Clos Network&lt;/h2&gt;

&lt;h3 id=&quot;use-of-multiple-links-between-switches&quot;&gt;Use of Multiple Links Between Switches&lt;/h3&gt;

&lt;h3 id=&quot;use-of-spines-as-only-a-connector&quot;&gt;Use of Spines as Only a Connector&lt;/h3&gt;

&lt;h3 id=&quot;use-of-chassis-as-a-spine-switch&quot;&gt;Use of Chassis as a Spine Switch&lt;/h3&gt;

&lt;h2 id=&quot;27-服务器接入模型host-attach-models&quot;&gt;2.7 服务器接入模型（Host Attach Models）&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;单接入（single-attach）&lt;/li&gt;
  &lt;li&gt;双接入（dual-attach）&lt;/li&gt;
&lt;/ul&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/cloud-native-dc-networking/2-7.png&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;Fig 2-7. Dual-attached host models&lt;/p&gt;

&lt;h2 id=&quot;28-summary&quot;&gt;2.8 Summary&lt;/h2&gt;

&lt;p&gt;a primary implication of Clos topology: the rise of network disaggregation.&lt;/p&gt;

&lt;h1 id=&quot;3-network-disaggregation网络分解&quot;&gt;3 Network Disaggregation（网络分解）&lt;/h1&gt;

&lt;h2 id=&quot;31-什么是-network-disaggregation&quot;&gt;3.1 什么是 Network Disaggregation?&lt;/h2&gt;

&lt;p&gt;交换机不再是厂商提供的一体机，而是分解为各个软件和硬件部分，每个部分可以独立设计
、采购和升级。&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/cloud-native-dc-networking/3-1.png&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;Fig 3-1. High-level components of a network switch&lt;/p&gt;

&lt;p&gt;组装一台交换机就像组装一台 PC 机。&lt;/p&gt;

&lt;h2 id=&quot;32-为什么-network-disaggregation-很重要&quot;&gt;3.2 为什么 Network Disaggregation 很重要？&lt;/h2&gt;

&lt;p&gt;交换机分解&lt;strong&gt;更多的是出于商业或业务考虑，而非技术&lt;/strong&gt;（a business model, not a
technical issue）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;控制成本。&lt;/p&gt;

    &lt;p&gt;后期的运维成本比前期的采购成本高的多。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;避免厂商锁定。&lt;/li&gt;
  &lt;li&gt;功能的标准化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;33-哪些方面使得-network-disaggregation-如今成为可能&quot;&gt;3.3 哪些方面使得 Network Disaggregation 如今成为可能？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;传统数据中心已经开始拖慢业务发展速度。&lt;/li&gt;
  &lt;li&gt;CLOS 架构减少了对特定功能的厂商设备的依赖，更多地依赖标准化的设备。&lt;/li&gt;
  &lt;li&gt;专门设计和生产交换芯片（称为商用芯片）的出现，这些厂商只设计和生产芯片，不做成品交换机。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;34-difference-in-network-operations-with-disaggregation&quot;&gt;3.4 Difference in Network Operations with Disaggregation&lt;/h2&gt;

&lt;h2 id=&quot;35-open-network-installer-environment&quot;&gt;3.5 Open Network Installer Environment&lt;/h2&gt;

&lt;p&gt;Facebook 发起了 Open Compute Project (OCP)。&lt;/p&gt;

&lt;p&gt;在裸交换机上安装网络操作系统（NOS）：Open Network Installer Environment (ONIE)，类似于服务
器领域的 PXE。&lt;/p&gt;

&lt;p&gt;为什么没有直接用 PXE？PXE 只支持 x86。ARM 和 PowerPC 用的 u-boot。&lt;/p&gt;

&lt;h2 id=&quot;36-the-players-in-network-disaggregation-hardware&quot;&gt;3.6 The Players in Network Disaggregation: Hardware&lt;/h2&gt;

&lt;h3 id=&quot;packet-switching-silicon&quot;&gt;Packet-Switching Silicon&lt;/h3&gt;

&lt;p&gt;VxLAN 的硬件支持最早出现在商用芯片（merchant silicon），而不是传统交换机厂商的芯片上。&lt;/p&gt;

&lt;p&gt;芯片厂商：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Broadcom 是商用芯片领域的拓荒者和领导者，&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Trident 系列：主要用在 Leaf&lt;/li&gt;
      &lt;li&gt;Tomahawk 系列：主要用在 Spine&lt;/li&gt;
      &lt;li&gt;Jericho 系统：主要用在 edge&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mellanox 是另一个有力竞争者，&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Spectrum 系列：Leaf 和 Spine 都可以用。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Barefoot 是这个领域的新秀，Cisco 和 Arista 都有基于 barefoot 芯片的交换机。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他：Innovium, Marvell&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;芯片配置：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;主流：单芯片 64x100G&lt;/li&gt;
  &lt;li&gt;顶配：单芯片 128x100G，例如 Tomahawk 3&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;odm-厂商&quot;&gt;ODM 厂商&lt;/h3&gt;

&lt;p&gt;Edgecore, Quanta, Agema, and Celestica, Dell.&lt;/p&gt;

&lt;h1 id=&quot;4-network-operating-system-choices&quot;&gt;4 Network Operating System Choices&lt;/h1&gt;

&lt;h1 id=&quot;5-routing-protocol-choices&quot;&gt;5 Routing Protocol Choices&lt;/h1&gt;


  
  
&lt;/div&gt;


          

      &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5d2d2ad22cc948d8387abd175c6bb5b7</guid>
<title>详解 defer 实现机制</title>
<link>https://toutiao.io/k/xdjpf4t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;!! &lt;/span&gt;嗨，大家好，我是asong，鸽了好久，其实元旦就想写一下这篇文章，但是因为喝酒喝断片了，养了三天才缓过来，就推迟到这个周末了，不过多追溯了，有点丢人。今天与大家来聊一聊&lt;code&gt;go&lt;/code&gt;中的关键字&lt;code&gt;defer&lt;/code&gt;，目前很多编程语言中都有&lt;code&gt;defer&lt;/code&gt;关键字，而&lt;code&gt;go&lt;/code&gt;语言的&lt;code&gt;defer&lt;/code&gt;用于资源的释放，会在函数返回之前进行调用，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。下面我们就深入&lt;code&gt;Go&lt;/code&gt;语言源码介绍&lt;code&gt;defer&lt;/code&gt;关键字的实现原理。文末尾给你们留了三道题，检测一下学习成果吧～&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基本使用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们首先来看一看&lt;code&gt;defer&lt;/code&gt;关键字是怎么使用的，一个经典的场景就是我们在使用事务时，发生错误需要回滚，这时我们就可以用使用defer来保证程序退出时保证事务回滚，示例代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 代码摘自之前写的 Leaf-segment数据库获取ID方案：https://github.com/asong2020/go-algorithm/blob/master/leaf/dao/leaf_dao.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(l *LeafDao)&lt;/span&gt; &lt;span&gt;NextSegment&lt;/span&gt;&lt;span&gt;(ctx context.Context, bizTag &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(*model.Leaf, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 开启事务&lt;/span&gt;&lt;br/&gt; tx, err := l.sql.Begin()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   l.rollback(tx)&lt;br/&gt;  }&lt;br/&gt; }()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err = l.checkError(err); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; err = l.db.UpdateMaxID(ctx, bizTag, tx)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err = l.checkError(err); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; leaf, err := l.db.Get(ctx, bizTag, tx)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err = l.checkError(err); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 提交事务&lt;/span&gt;&lt;br/&gt; err = tx.Commit()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err = l.checkError(err); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; leaf, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面只是一个简单的应用，&lt;code&gt;defer&lt;/code&gt;还有一些特性，如果你不知道，使用起来可能会踩到一些坑，尤其是跟带命名的返回参数一起使用时。下面我们我先来带大家踩踩坑。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;defer&lt;/code&gt;的注意事项和细节&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;defer&lt;/code&gt;调用顺序&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看一道题，你能说他的答案吗？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;reciprocal&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;        &lt;span&gt;defer&lt;/span&gt; fmt.Println(i)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;reciprocal&lt;br/&gt;&lt;span&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到答案，你是不是产生了疑问？这就对了，我最开始学&lt;code&gt;golang&lt;/code&gt;时也有这个疑问，这个跟栈一样，即&quot;先进后出&quot;特性，越后面的defer表达式越先被调用。所以这里大家关闭依赖资源时一定要注意&lt;code&gt;defer&lt;/code&gt;调用顺序。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;defer&lt;/code&gt;拷贝&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看这样一段代码，你能说出&lt;code&gt;defer&lt;/code&gt;中&lt;code&gt;num1&lt;/code&gt;和&lt;code&gt;num2&lt;/code&gt;的值是多少吗？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(Sum(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Sum&lt;/span&gt;&lt;span&gt;(num1, num2 &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; fmt.Println(&lt;span&gt;&quot;num1:&quot;&lt;/span&gt;, num1)&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; fmt.Println(&lt;span&gt;&quot;num2:&quot;&lt;/span&gt;, num2)&lt;br/&gt; num1++&lt;br/&gt; num2++&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; num1 + num2&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;聪明的你一定会说：&quot;这也太简单了，答案就是num1等于2，num2等于3&quot;。很遗憾的告诉你，错了，正确的答案是&lt;code&gt;num1&lt;/code&gt;为&lt;code&gt;1&lt;/code&gt;,&lt;code&gt;num2&lt;/code&gt;为2，这两个变量并不受&lt;code&gt;num1++、num2++&lt;/code&gt;的影响，&lt;span&gt;因为&lt;code&gt;defer&lt;/code&gt;将语句放入到栈中时，也会将相关的值拷贝同时入栈。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;defer&lt;/code&gt;与&lt;code&gt;return&lt;/code&gt;的返回时机&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我先说结论，总结一下就是，函数的整个返回过程应该是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;return&lt;/code&gt; 对返回变量赋值，如果是匿名返回值就先声明再赋值；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行 &lt;code&gt;defer&lt;/code&gt; 函数；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;return&lt;/code&gt; 携带返回值返回。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看两道题，你知道他们的返回值是多少吗？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 匿名函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Anonymous&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; i &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  i++&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;defer2 value is &quot;&lt;/span&gt;, i)&lt;br/&gt; }()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  i++&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;defer1 in value is &quot;&lt;/span&gt;, i)&lt;br/&gt; }()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; i&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;HasName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(j &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  j++&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;defer2 in value&quot;&lt;/span&gt;, j)&lt;br/&gt; }()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  j++&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;defer1 in value&quot;&lt;/span&gt;, j)&lt;br/&gt; }()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; j&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来公布一下答案吧：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;1.&lt;/span&gt; Anonymous()的返回值为&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.&lt;/span&gt; HasName()的返回值为&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这我们可以看出命名返回值的函数的返回值被 &lt;code&gt;defer&lt;/code&gt; 修改了。这里想必大家跟我一样，都很疑惑，带着疑惑我查阅了一下&lt;code&gt;go&lt;/code&gt;官方文档，文档指出，&lt;code&gt;defer&lt;/code&gt;的执行顺序有以下三个规则：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;A deferred function’s arguments are evaluated when the defer statement is evaluated.&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Deferred function calls are executed in Last In First Out order after the surrounding function returns.&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Deferred functions may read and assign to the returning function’s named return values.&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;规则3就可以印证为什么命名返回值的函数的返回值被更改了，其实在函数最终返回前，&lt;code&gt;defer&lt;/code&gt; 函数就已经执行了，在命名返回值的函数 中，由于返回值已经被提前声明，所以 &lt;code&gt;defer&lt;/code&gt; 函数能够在 &lt;code&gt;return&lt;/code&gt; 语句对返回值赋值之后，继续对返回值进行操作，操作的是同一个变量，而匿名返回值函数中return先返回，已经进行了一次值拷贝r=i，&lt;code&gt;defer&lt;/code&gt;函数中再次对变量&lt;code&gt;i&lt;/code&gt;的操作并不会影响返回值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里可能有些小伙伴还不是很懂，我在讲一下&lt;code&gt;return&lt;/code&gt;返回步骤，相信你们会豁然开朗。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;函数在返回时，首先函数返回时会自动创建一个返回变量假设为ret(如果是命名返回值的函数则不会创建)，函数返回时要将变量&lt;code&gt;i&lt;/code&gt;赋值给ret，即有ret = i。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后检查函数中是否有defer存在，若有则执行defer中部分。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后返回ret&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在你们应该知道上面是什么原因了吧～。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;解密&lt;code&gt;defer&lt;/code&gt;源码&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写在开头：go版本1.15.3&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来写一段代码，查看一下汇编代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;asong 真帅&quot;&lt;/span&gt;)&lt;br/&gt; }()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行如下指令：&lt;code&gt;go tool compile -N -l -S main.go&lt;/code&gt;，截取部分汇编指令如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5088&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/k5430ljpYPM7h1HuzN3PcicgYB2vLcjjwI0AfiacmoV1mbiaib2XfLOBOob3Drsceiba7jtdicoDoLiaiao6jg70QQyzbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;625&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看出来，从执行流程来看首先会调用&lt;code&gt;deferproc&lt;/code&gt;来创建&lt;code&gt;defer&lt;/code&gt;，然后在函数返回时插入了指令&lt;code&gt;CALL runtime.deferreturn&lt;/code&gt;。知道了&lt;code&gt;defer&lt;/code&gt;在流程中是通过这两个方法是调用的，接下来我们来看一看&lt;code&gt;defer&lt;/code&gt;的结构：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// go/src/runtime/runtime2.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; _defer &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; siz     &lt;span&gt;int32&lt;/span&gt; &lt;span&gt;// includes both arguments and results&lt;/span&gt;&lt;br/&gt; started &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt; heap    &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// openDefer indicates that this _defer is for a frame with open-coded&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// defers. We have only one defer record for the entire frame (which may&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// currently have 0, 1, or more defers active).&lt;/span&gt;&lt;br/&gt; openDefer &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt; sp        &lt;span&gt;uintptr&lt;/span&gt;  &lt;span&gt;// sp at time of defer&lt;/span&gt;&lt;br/&gt; pc        &lt;span&gt;uintptr&lt;/span&gt;  &lt;span&gt;// pc at time of defer&lt;/span&gt;&lt;br/&gt; fn        *funcval &lt;span&gt;// can be nil for open-coded defers&lt;/span&gt;&lt;br/&gt; _panic    *_panic  &lt;span&gt;// panic that is running defer&lt;/span&gt;&lt;br/&gt; link      *_defer&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// If openDefer is true, the fields below record values about the stack&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// frame and associated function that has the open-coded defer(s). sp&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// above will be the sp for the frame, and pc will be address of the&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// deferreturn call in the function.&lt;/span&gt;&lt;br/&gt; fd   unsafe.Pointer &lt;span&gt;// funcdata for the function associated with the frame&lt;/span&gt;&lt;br/&gt; varp &lt;span&gt;uintptr&lt;/span&gt;        &lt;span&gt;// value of varp for the stack frame&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// framepc is the current pc associated with the stack frame. Together,&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// with sp above (which is the sp associated with the stack frame),&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// framepc/sp can be used as pc/sp pair to continue a stack trace via&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// gentraceback().&lt;/span&gt;&lt;br/&gt; framepc &lt;span&gt;uintptr&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里简单介绍一下&lt;code&gt;runtime._defer&lt;/code&gt;结构体中的几个字段：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;siz&lt;/code&gt;代表的是参数和结果的内存大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;sp&lt;/code&gt;和&lt;code&gt;pc&lt;/code&gt;分别代表栈指针和调用方的程序计数器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;fn&lt;/code&gt;代表的是&lt;code&gt;defer&lt;/code&gt;关键字中传入的函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;_panic&lt;/code&gt;是触发延迟调用的结构体，可能为空&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;openDefer&lt;/code&gt;表示的是当前&lt;code&gt;defer&lt;/code&gt;是否已经开放编码优化(1.14版本新增)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;link&lt;/code&gt;所有&lt;code&gt;runtime._defer&lt;/code&gt;结构体都通过该字段串联成链表&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来我们也知道了&lt;code&gt;defer&lt;/code&gt;关键字的数据结构了，下面我们就来重点分析一下&lt;code&gt;deferproc&lt;/code&gt;和&lt;code&gt;deferreturn&lt;/code&gt;函数是如何调用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;deferproc&lt;/code&gt;函数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;deferproc&lt;/code&gt;函数也不长，我先贴出来代码；&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// proc/panic.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Create a new deferred function fn with siz bytes of arguments.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// The compiler turns a defer statement into a call to this.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//go:nosplit&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;deferproc&lt;/span&gt;&lt;span&gt;(siz &lt;span&gt;int32&lt;/span&gt;, fn *funcval)&lt;/span&gt;&lt;/span&gt; { &lt;span&gt;// arguments of fn follow fn&lt;/span&gt;&lt;br/&gt; gp := getg()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; gp.m.curg != gp {&lt;br/&gt;  &lt;span&gt;// go code on the system stack can&#x27;t defer&lt;/span&gt;&lt;br/&gt;  throw(&lt;span&gt;&quot;defer on system stack&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// the arguments of fn are in a perilous state. The stack map&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// for deferproc does not describe them. So we can&#x27;t let garbage&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// collection or stack copying trigger until we&#x27;ve copied them out&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// to somewhere safe. The memmove below does that.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// Until the copy completes, we can only call nosplit routines.&lt;/span&gt;&lt;br/&gt; sp := getcallersp()&lt;br/&gt; argp := &lt;span&gt;uintptr&lt;/span&gt;(unsafe.Pointer(&amp;amp;fn)) + unsafe.Sizeof(fn)&lt;br/&gt; callerpc := getcallerpc()&lt;br/&gt;&lt;br/&gt; d := newdefer(siz)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; d._panic != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  throw(&lt;span&gt;&quot;deferproc: d.panic != nil after newdefer&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt; d.link = gp._defer&lt;br/&gt; gp._defer = d&lt;br/&gt; d.fn = fn&lt;br/&gt; d.pc = callerpc&lt;br/&gt; d.sp = sp&lt;br/&gt; &lt;span&gt;switch&lt;/span&gt; siz {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;// Do nothing.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; sys.PtrSize:&lt;br/&gt;  *(*&lt;span&gt;uintptr&lt;/span&gt;)(deferArgs(d)) = *(*&lt;span&gt;uintptr&lt;/span&gt;)(unsafe.Pointer(argp))&lt;br/&gt; &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;  memmove(deferArgs(d), unsafe.Pointer(argp), &lt;span&gt;uintptr&lt;/span&gt;(siz))&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// deferproc returns 0 normally.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// a deferred func that stops a panic&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// makes the deferproc return 1.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// the code the compiler generates always&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// checks the return value and jumps to the&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// end of the function if deferproc returns != 0.&lt;/span&gt;&lt;br/&gt; return0()&lt;br/&gt; &lt;span&gt;// No code can go here - the C return register has&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// been set and must not be clobbered.&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面介绍了&lt;code&gt;rumtiem._defer&lt;/code&gt;结构想必这里的入参是什么意思就不用我介绍了吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;deferproc&lt;/code&gt;的函数流程很清晰，首先他会通过&lt;code&gt;newdefer&lt;/code&gt;函数分配一个&lt;code&gt;_defer&lt;/code&gt;结构对象，然后把需要延迟执行的函数以及该函数需要用到的参数、调用&lt;code&gt;deferproc&lt;/code&gt;函数时的&lt;code&gt;rps&lt;/code&gt;寄存器的值以及&lt;code&gt;deferproc&lt;/code&gt;函数的返回地址保存在&lt;code&gt;_defer&lt;/code&gt;结构体对象中，最后通过&lt;code&gt;return0()&lt;/code&gt;设置&lt;code&gt;rax&lt;/code&gt;寄存器的值为0隐性的给调用者返回一个0值。&lt;code&gt;deferproc&lt;/code&gt;主要是靠&lt;code&gt;newdefer&lt;/code&gt;来分配&lt;code&gt;_defer&lt;/code&gt;结构体对象的，下面我们一起来看看&lt;code&gt;newdefer&lt;/code&gt;实现，代码有点长：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// proc/panic.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Allocate a Defer, usually using per-P pool.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Each defer must be released with freedefer.  The defer is not&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// added to any defer chain yet.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// This must not grow the stack because there may be a frame without&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// stack map information when this is called.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//go:nosplit&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;newdefer&lt;/span&gt;&lt;span&gt;(siz &lt;span&gt;int32&lt;/span&gt;)&lt;/span&gt; *_&lt;span&gt;defer&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; d *_defer&lt;br/&gt; sc := deferclass(&lt;span&gt;uintptr&lt;/span&gt;(siz))&lt;br/&gt; gp := getg()&lt;span&gt;//获取当前goroutine的g结构体对象&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; sc &amp;lt; &lt;span&gt;uintptr&lt;/span&gt;(&lt;span&gt;len&lt;/span&gt;(p{}.deferpool)) {&lt;br/&gt;  pp := gp.m.p.ptr() &lt;span&gt;//与当前工作线程绑定的p&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(pp.deferpool[sc]) == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; sched.deferpool[sc] != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// Take the slow path on the system stack so&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// we don&#x27;t grow newdefer&#x27;s stack.&lt;/span&gt;&lt;br/&gt;   systemstack(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    lock(&amp;amp;sched.deferlock) &lt;br/&gt;         &lt;span&gt;//把新分配出来的d放入当前goroutine的_defer链表头&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(pp.deferpool[sc]) &amp;lt; &lt;span&gt;cap&lt;/span&gt;(pp.deferpool[sc])/&lt;span&gt;2&lt;/span&gt; &amp;amp;&amp;amp; sched.deferpool[sc] != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;     d := sched.deferpool[sc]&lt;br/&gt;     sched.deferpool[sc] = d.link&lt;br/&gt;     d.link = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;     pp.deferpool[sc] = &lt;span&gt;append&lt;/span&gt;(pp.deferpool[sc], d)&lt;br/&gt;    }&lt;br/&gt;    unlock(&amp;amp;sched.deferlock)&lt;br/&gt;   })&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; n := &lt;span&gt;len&lt;/span&gt;(pp.deferpool[sc]); n &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   d = pp.deferpool[sc][n&lt;span&gt;-1&lt;/span&gt;]&lt;br/&gt;   pp.deferpool[sc][n&lt;span&gt;-1&lt;/span&gt;] = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;   pp.deferpool[sc] = pp.deferpool[sc][:n&lt;span&gt;-1&lt;/span&gt;]&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; d == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;//如果p的缓存中没有可用的_defer结构体对象则从堆上分配&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;// Allocate new defer+args.&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;//因为roundupsize以及mallocgc函数都不会处理扩栈，所以需要切换到系统栈执行&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// Allocate new defer+args.&lt;/span&gt;&lt;br/&gt;  systemstack(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   total := roundupsize(totaldefersize(&lt;span&gt;uintptr&lt;/span&gt;(siz)))&lt;br/&gt;   d = (*_defer)(mallocgc(total, deferType, &lt;span&gt;true&lt;/span&gt;))&lt;br/&gt;  })&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; debugCachedWork {&lt;br/&gt;   &lt;span&gt;// Duplicate the tail below so if there&#x27;s a&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// crash in checkPut we can tell if d was just&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// allocated or came from the pool.&lt;/span&gt;&lt;br/&gt;   d.siz = siz&lt;br/&gt;       &lt;span&gt;//把新分配出来的d放入当前goroutine的_defer链表头&lt;/span&gt;&lt;br/&gt;   d.link = gp._defer&lt;br/&gt;   gp._defer = d&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; d&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; d.siz = siz&lt;br/&gt; d.heap = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; d&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;newdefer&lt;/code&gt;函数首先会尝试从当前工作线程绑定的&lt;code&gt;p&lt;/code&gt;的&lt;code&gt;_defer&lt;/code&gt;对象池和全局对象池中获取一个满足大小要求&lt;code&gt;(sizeof(_defer) + siz向上取整至16的倍数)&lt;/code&gt;的&lt;code&gt;_defer&lt;/code&gt; 结构体对象，如果没有能够满足要求的空闲 &lt;code&gt;_defer&lt;/code&gt;对象则从堆上分一个，最后把分配到的对象链入当前 &lt;code&gt;goroutine&lt;/code&gt;的&lt;code&gt;_defer&lt;/code&gt; 链表的表头。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到此&lt;code&gt;deferproc&lt;/code&gt;函数就分析完了，你们懂了吗? 没懂不要紧，我们再来总结一下这个过程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先编译器把&lt;code&gt;defer&lt;/code&gt;语句翻译成对应的&lt;code&gt;deferproc&lt;/code&gt;函数的调用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后&lt;code&gt;deferproc&lt;/code&gt;函数通过&lt;code&gt;newdefer&lt;/code&gt;函数分配一个&lt;code&gt;_defer&lt;/code&gt;结构体对象并放入当前的&lt;code&gt;goroutine&lt;/code&gt;的&lt;code&gt;_defer&lt;/code&gt;链表的表头；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 _defer 结构体对象中保存被延迟执行的函数 fn 的地址以及 fn 所需的参数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回到调用 deferproc 的函数继续执行后面的代码。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;deferreturn&lt;/code&gt;函数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Run a deferred function if there is one.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// The compiler inserts a call to this at the end of any&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// function which calls defer.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// If there is a deferred function, this will call runtime·jmpdefer,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// which will jump to the deferred function such that it appears&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// to have been called by the caller of deferreturn at the point&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// just before deferreturn was called. The effect is that deferreturn&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// is called again and again until there are no more deferred functions.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Declared as nosplit, because the function should not be preempted once we start&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// modifying the caller&#x27;s frame in order to reuse the frame to call the deferred&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// function.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// The single argument isn&#x27;t actually used - it just has its address&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// taken so it can be matched against pending defers.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//go:nosplit&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;deferreturn&lt;/span&gt;&lt;span&gt;(arg0 &lt;span&gt;uintptr&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; gp := getg() &lt;span&gt;//获取当前goroutine对应的g结构体对象&lt;/span&gt;&lt;br/&gt; d := gp._defer &lt;span&gt;//获取当前goroutine对应的g结构体对象&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; d == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;//没有需要执行的函数直接返回，deferreturn和deferproc是配对使用的&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;//为什么这里d可能为nil？因为deferreturn其实是一个递归调用，这个是递归结束条件之一&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; sp := getcallersp() &lt;span&gt;//获取调用deferreturn时的栈顶位置&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; d.sp != sp { &lt;span&gt;// 递归结束条件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//如果保存在_defer对象中的sp值与调用deferretuen时的栈顶位置不一样，直接返回&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//因为sp不一样表示d代表的是在其他函数中通过defer注册的延迟调用函数，比如:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//a()-&amp;gt;b()-&amp;gt;c()它们都通过defer注册了延迟函数，那么当c()执行完时只能执行在c中注册的函数&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; d.openDefer {&lt;br/&gt;  done := runOpenDeferFrame(gp, d)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; !done {&lt;br/&gt;   throw(&lt;span&gt;&quot;unfinished open-coded defers in deferreturn&quot;&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;  gp._defer = d.link&lt;br/&gt;  freedefer(d)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Moving arguments around.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// Everything called after this point must be recursively&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// nosplit because the garbage collector won&#x27;t know the form&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// of the arguments until the jmpdefer can flip the PC over to&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// fn.&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;//把保存在_defer对象中的fn函数需要用到的参数拷贝到栈上，准备调用fn&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//注意fn的参数放在了调用调用者的栈帧中，而不是此函数的栈帧中&lt;/span&gt;&lt;br/&gt; &lt;span&gt;switch&lt;/span&gt; d.siz {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;// Do nothing.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; sys.PtrSize:&lt;br/&gt;  *(*&lt;span&gt;uintptr&lt;/span&gt;)(unsafe.Pointer(&amp;amp;arg0)) = *(*&lt;span&gt;uintptr&lt;/span&gt;)(deferArgs(d))&lt;br/&gt; &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;  memmove(unsafe.Pointer(&amp;amp;arg0), deferArgs(d), &lt;span&gt;uintptr&lt;/span&gt;(d.siz))&lt;br/&gt; }&lt;br/&gt; fn := d.fn&lt;br/&gt; d.fn = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; gp._defer = d.link &lt;span&gt;// 使gp._defer指向下一个_defer结构体对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//因为需要调用的函数d.fn已经保存在了fn变量中，它的参数也已经拷贝到了栈上，所以释放_defer结构体对象&lt;/span&gt;&lt;br/&gt; freedefer(d)&lt;br/&gt; &lt;span&gt;// If the defer function pointer is nil, force the seg fault to happen&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// here rather than in jmpdefer. gentraceback() throws an error if it is&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// called with a callback on an LR architecture and jmpdefer is on the&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// stack, because the stack trace can be incorrect in that case - see&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// issue #8153).&lt;/span&gt;&lt;br/&gt; _ = fn.fn&lt;br/&gt; jmpdefer(fn, &lt;span&gt;uintptr&lt;/span&gt;(unsafe.Pointer(&amp;amp;arg0)))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;deferreturn&lt;/code&gt;函数主要流程还是简单一些的，我们来分析一下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先我们通过当前&lt;code&gt;goroutine&lt;/code&gt;对应的&lt;code&gt;g&lt;/code&gt;结构体对象的&lt;code&gt;_defer&lt;/code&gt;链表判断是否有需要执行的&lt;code&gt;defered&lt;/code&gt;函数，如果没有则返回；这里的没有是指g._defer== nil 或者&lt;code&gt;defered&lt;/code&gt;函数不是在&lt;code&gt;deferteturn&lt;/code&gt;的&lt;code&gt;caller&lt;/code&gt;函数中注册的函数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后我们在从&lt;code&gt;_defer&lt;/code&gt;对象中把&lt;code&gt;defered&lt;/code&gt;函数需要的参数拷贝到栈上，并释放&lt;code&gt;_defer&lt;/code&gt;的结构体对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最红调用&lt;code&gt;jmpderfer&lt;/code&gt;函数调用&lt;code&gt;defered&lt;/code&gt;函数，也就是&lt;code&gt;defer&lt;/code&gt;关键字中传入的函数.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;jmpdefer&lt;/code&gt;函数实现挺优雅的，我们一起来看看他是如何实现的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// runtime/asm_amd64.s : 581&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// func jmpdefer(fv *funcval, argp uintptr)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// argp is a caller SP.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// called from deferreturn.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 1. pop the caller&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 2. sub 5 bytes from the callers return&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 3. jmp to the argument&lt;/span&gt;&lt;br/&gt;TEXT runtime·jmpdefer(SB), NOSPLIT, $&lt;span&gt;0&lt;/span&gt;&lt;span&gt;-16&lt;/span&gt;&lt;br/&gt; MOVQ fv+&lt;span&gt;0&lt;/span&gt;(FP), DX &lt;span&gt;// fn&lt;/span&gt;&lt;br/&gt; MOVQ argp+&lt;span&gt;8&lt;/span&gt;(FP), BX &lt;span&gt;// caller sp&lt;/span&gt;&lt;br/&gt; LEAQ &lt;span&gt;-8&lt;/span&gt;(BX), SP &lt;span&gt;// caller sp after CALL&lt;/span&gt;&lt;br/&gt; MOVQ &lt;span&gt;-8&lt;/span&gt;(SP), BP &lt;span&gt;// restore BP as if deferreturn returned (harmless if framepointers not in use)&lt;/span&gt;&lt;br/&gt; SUBQ $&lt;span&gt;5&lt;/span&gt;, (SP) &lt;span&gt;// return to CALL again&lt;/span&gt;&lt;br/&gt; MOVQ &lt;span&gt;0&lt;/span&gt;(DX), BX&lt;br/&gt; JMP BX &lt;span&gt;// but first run the deferred function&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里都是汇编，大家可能看不懂，没关系，我只是简单介绍一下这里，有兴趣的同学可以去查阅一下相关知识再来深入了解。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;MOVQfv+0(FP), DX&lt;/code&gt;这条指令会把&lt;code&gt;jmpdefer&lt;/code&gt;的第一个参数也就是结构体对象&lt;code&gt;fn&lt;/code&gt;的地址存放入&lt;code&gt;DX&lt;/code&gt;寄存器，之后的代码就可以通过寄存器访问到&lt;code&gt;fn&lt;/code&gt;，&lt;code&gt;fn&lt;/code&gt;就可以拿到&lt;code&gt;defer&lt;/code&gt;关键字中传入的函数，对应上面的例子就是匿名函数&lt;code&gt;func(){}()&lt;/code&gt;.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;MOVQargp+8(FP), BX&lt;/code&gt;这条指令就是把&lt;code&gt;jmpdefer&lt;/code&gt;的第二个参数放入&lt;code&gt;BX&lt;/code&gt;寄存器，该参数是一个指针，他指向&lt;code&gt;defer&lt;/code&gt;关键字中传入的函数的第一个参数.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;LEAQ-8(BX), SP&lt;/code&gt;这条指令的作用是让 &lt;code&gt;SP&lt;/code&gt; 寄存器指向 &lt;code&gt;deferreturn&lt;/code&gt; 函数的返回地址所在的栈内存单元.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;MOVQ-8(SP), BP&lt;/code&gt;这条指令的作用是调整 BP 寄存器的值，此时&lt;code&gt;SP_8&lt;/code&gt;的位置存放的是&lt;code&gt;defer&lt;/code&gt;关键字当前所在的函数的&lt;code&gt;rbp&lt;/code&gt;寄存器的值，所以这条指令在调整&lt;code&gt;rbp&lt;/code&gt;寄存器的值使其指向当前所在函数的栈帧的适当位置.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;SUBQ$5, (SP)&lt;/code&gt;这里的作用是完成&lt;code&gt;defer&lt;/code&gt;函数的参数以及执行完函数后返回地址在栈上的构造.因为在执行这条指令时，rsp寄存器指向的是&lt;code&gt;deferreturn&lt;/code&gt;函数的返回地址.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;MOVQ0(DX), BX&lt;/code&gt;和&lt;code&gt;JMPBX&lt;/code&gt;放到一起说吧，目的是跳转到对应&lt;code&gt;defer&lt;/code&gt;函数去执行，完成&lt;code&gt;defer&lt;/code&gt;函数的调用.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大概分析了一下&lt;code&gt;defer&lt;/code&gt;的实现机制，但还是有点蒙圈，最后在总结一下这里：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先编译器会把&lt;code&gt;defer&lt;/code&gt;语句翻译成对&lt;code&gt;deferproc&lt;/code&gt;函数的调用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后&lt;code&gt;deferproc&lt;/code&gt;函数会负责调用&lt;code&gt;newdefer&lt;/code&gt;函数分配一个&lt;code&gt;_defer&lt;/code&gt;结构体对象并放入当前的&lt;code&gt;goroutine&lt;/code&gt;的&lt;code&gt;_defer&lt;/code&gt;链表的表头；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后编译起会在&lt;code&gt;defer&lt;/code&gt;所在函数的结尾处插入对&lt;code&gt;deferreturn&lt;/code&gt;的调用，&lt;code&gt;deferreturn&lt;/code&gt;负责递归的调用某函数(defer语句所在函数)通过&lt;code&gt;defer&lt;/code&gt;语句注册的函数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体来说就是这三个步骤，go语言对&lt;code&gt;defer&lt;/code&gt;的实现机制就是这样啦，你明白了吗？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小试牛刀&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面我们也细致学习了一下&lt;code&gt;defer&lt;/code&gt;，下面出几道题吧，看看你们真的学会了吗？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;问题1&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 测试1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(r &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; i := &lt;span&gt;1&lt;/span&gt;&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  i = i + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt; }()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; i&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回结果是什么？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;问题2&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(r &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(r &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  r = r + &lt;span&gt;2&lt;/span&gt;&lt;br/&gt; }(r)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回结果是什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果改成这样呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Test3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(r &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(r *&lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  *r = *r + &lt;span&gt;2&lt;/span&gt;&lt;br/&gt; }(&amp;amp;r)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;问题3&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  e1()&lt;br/&gt;  e2()&lt;br/&gt;  e3()&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;e1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; err error&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; fmt.Println(err)&lt;br/&gt; err = errors.New(&lt;span&gt;&quot;e1 defer err&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;e2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; err error&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  fmt.Println(err)&lt;br/&gt; }()&lt;br/&gt; err = errors.New(&lt;span&gt;&quot;e2 defer err&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;e3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; err error&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  fmt.Println(err)&lt;br/&gt; }(err)&lt;br/&gt; err = errors.New(&lt;span&gt;&quot;e3 defer err&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个返回结果又是什么呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后这三道题这里就当作思考题吧，自己运行一下，看看你们想的和运行结果是否一致呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有问题欢迎来找我讨论，因为目前没有留言功能，大家可以加入我的交流群，我们一起交流成长。因为是微信群，会有过期时间，所以大家关注我的公众号，获取入群二维码，或者添加我的个人微信，我拉你入群。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好啦，这篇文章就到这里啦，素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我是asong，一名普普通通的程序猿，让gi我一起慢慢变强吧。欢迎各位的关注，我们下期见~~~&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/k5430ljpYPM7h1HuzN3PcicgYB2vLcjjwtXbib35EsuNGWHjZKH1S2g56NdCpGKQSPMcTricgjxvR65AnDo3DexGw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐往期文章：&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ae5b4341c9c035084db2a0b6771b99bb</guid>
<title>2021，一个长期主义者的年度计划</title>
<link>https://toutiao.io/k/4rdacqm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;2021，给自己立一些Flag，年底不要打脸啊。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;db5396995cef5c2cfc43abceefb6124a&quot;&gt;&lt;/p&gt;&lt;h1 data-lake-id=&quot;4edff1ec5a0ad6e84134528663da41b5&quot;&gt;2020&lt;/h1&gt;&lt;p data-lake-id=&quot;e433584f23d7fbc7d6066c0cc36c311f&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;1bd8c108b53d3f251999d89de09066d7&quot;&gt;2020年，看了不少精彩的电视剧和电影，比如《是，大臣》、《想见你》、《正常人》、《摩天大楼》、《请回答1988》、《阳光普照》、《绅士们》、《小妇人》、《误杀》。刷剧刷电影还是很开心的，感谢才华横溢的导演、编剧、演员们，期待新的1年。&lt;/p&gt;&lt;p data-lake-id=&quot;b9ee83fab9300f83e0652ef1c257ba73&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;7e2cfc9e5aa548d15edd593ecadb0f05&quot;&gt;2020年，看了一个貌似很严肃其实很有趣的在线课程《投资银行学》，冯科教授在券商呆过的，有点江湖气，讲课非常幽默。在金融圈赚够钱之后，去北大教书，&lt;span&gt;事了拂衣去，深藏身与名&lt;/span&gt;，高人呐。&lt;/p&gt;&lt;p data-lake-id=&quot;81a429f974235cfebb13368e905f1409&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;53cf153133d8ecf1be3c2684faa354f4&quot;&gt;2020年，看了不少优秀的技术内容，写了10年代码，依然还是热爱技术啊，最喜欢的技术内容有这些：&lt;/p&gt;&lt;p data-lake-id=&quot;74e413af9b086649dda64b5a09715396&quot;&gt;&lt;/p&gt;&lt;ul data-lake-id=&quot;841a0eb2ce4e2e1585b22479199de43c&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Vue.js: The Documentary&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;GraphQL: The Documentary&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;140: Evan You - Reimagining the Modern Dev Server with Vite&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;React Today and Tomorrow and 90% Cleaner React With Hooks&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Data Fetching with React Server Components&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Hax - JavaScript: The World&#x27;s Best Programming Language&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;前端开发编程语言的过去、现在和未来&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;amp;mid=2649828469&amp;amp;idx=1&amp;amp;sn=92d23d5def4cc39b0aad027700e995bd&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;dart：失之东隅收之桑榆&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;《构建下一代HTTPAPI》系列博客&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-lake-id=&quot;0a62dfdbd2375399ff868c024671fb07&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;cd2f1bfd253fa47620673ce265302d1c&quot;&gt;2020年，最喜欢的软件是语雀，每天都用它写工作文档，最近写博客用的也是语雀。但是，我依然觉得，OneNote其实更好用一点，笔记本/分区/页面这样的三层结构才能真正满足复杂的知识管理需求，分类更加清楚，找起来更方便。&lt;/p&gt;&lt;p data-lake-id=&quot;52cf7e1a009c2b113ed0a0586f4863f8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;ece1e6dc1c988f074eeccff01adb07a9&quot;&gt;2020年，最喜欢的电子产品是Airpod Pro，有了它Coding速度瞬间提升了50%，集齐了Apple全家桶，不过，Watch只是偶尔跑步有点用，iPad和Kindle一样只能用来泡面，iPhone 11砖头版是我最讨厌的产品，半斤重啊。&lt;/p&gt;&lt;p data-lake-id=&quot;22df09345fb861211aa60112df25c3ac&quot;&gt;&lt;/p&gt;&lt;h1 data-lake-id=&quot;beef31544365b169e8cd60dbf7fb5587&quot;&gt;读书&lt;/h1&gt;&lt;p data-lake-id=&quot;4572f7467b0b9384c60443c78075c815&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;ad14e73122a5a028e95b549032a7a6cd&quot;&gt;2020年，听的书很多，看的书比较少，印象比较深的有这些：&lt;/p&gt;&lt;p data-lake-id=&quot;9212ab4278e6cfbe59126f5a7e752b62&quot;&gt;&lt;/p&gt;&lt;ul data-lake-id=&quot;ed4c3ca5ba7ea4ec41afd9e8aac4f382&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;《史蒂夫·乔布斯传》&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;《硅谷钢铁侠: 埃隆·马斯克的冒险人生》&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;《一生的旅程：迪士尼CEO自述》&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;《曾国藩传》&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;《时间的玫瑰：但斌投资札记》&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;《以色列：一个国家的诞生》&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-lake-id=&quot;fbe88c9387c94e27f282e1e084d7cc7a&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;b5f9f4e539e5d47c28c88021ae70265d&quot;&gt;4本传记，1本讲价值投资，1本聊中东战争。&lt;/p&gt;&lt;p data-lake-id=&quot;913690e6f23e2d89a3efb73072a284f0&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;a97d34d0e881a985bf541f93f710b5ad&quot;&gt;其实，我主要是听书，这些年一直用的听书APP是&lt;strong&gt;静雅思听&lt;/strong&gt;，可惜它要关闭了，最近开始用微信读书的AI听书，机器人的声音有点奇怪，不过也习惯了。&lt;/p&gt;&lt;p data-lake-id=&quot;c4c6e4a313e6ad1b1d3175271bbce2d5&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;2363df53f82af1f1c84e392693f8f28a&quot;&gt;2021年，打算读这些书：&lt;/p&gt;&lt;p data-lake-id=&quot;c9ca457fee1b589cb0123c8e2deab8dd&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;147a1a0b35d7819ceff65d800158edb9&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;ad9c3ad3f3f41c48b4a83f710d5418b5&quot;&gt;《褚时健传》是元旦假期开始看的，已经看完了，挺喜欢看传记的，&lt;span&gt;向优秀的人学习，站在巨人的肩膀上&lt;/span&gt;。&lt;/p&gt;&lt;p data-lake-id=&quot;fb12b204032f893a42231868309234c0&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;575131ae19afe8fe3fd2721412ab20be&quot;&gt;《算法（第4版）》有点硬核，目测得花不少时间。作者的课程《Algorithms, Part I》我已经看完了，老教授讲得非常清晰，今年应该可以把《Algorithms, Part II》看完。&lt;/p&gt;&lt;h1 data-lake-id=&quot;a3589dadb2a92655a1f73ede59eccaa3&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 data-lake-id=&quot;2fb7c22d610f6769e0f9dec1ebcb185f&quot;&gt;写作&lt;/h1&gt;&lt;p data-lake-id=&quot;4960c37e25c5c909e99596ab05a15360&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;5f32c6f202e38bf1bc0691c3c3b7a8d5&quot;&gt;2020年，开通了微信公众号&lt;strong&gt;寒雁Talk，&lt;/strong&gt;但是因为工作太忙，写的博客少了很多：&lt;/p&gt;&lt;p data-lake-id=&quot;a0fddc416f39247bfe50c12e82496416&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;df5f5fdb47f59de09a6116d926085831&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;691a9e76ee2518b4b505de59762bda59&quot;&gt;还有2篇博客发在公司内网，总得来说，&lt;strong&gt;数量很少，质量也有待提高！&lt;/strong&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;1a3eef79a5235c7fa3be1ae862ad049d&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;04bff2cabc802fca29d2823b7d580b00&quot;&gt;2020年，我还写一个《寒雁周刊》，一共写了26期，不过最近又停更了，有点尴尬。之前写的周刊比较简单，后来在主管的提醒下有所改进：&lt;/p&gt;&lt;p data-lake-id=&quot;4fa994808764e640396c9311b043f91a&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;32cf25a67c4900a8429a21a81eac9fc6&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;ff8cf9851b2f31cc434f79fb023b1198&quot;&gt;阅读优秀的技术博客，自己再调研一下，写一些自己的看法和思考，还是很有收获的，《寒雁周刊》我还是会写下去的。&lt;/p&gt;&lt;p data-lake-id=&quot;8d2a47ce51cd74f3018411920964fc62&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;1f66d4e26ce1bd82a4b535aeb448d468&quot;&gt;2021年，&lt;span&gt;希望公众号的粉丝数可以达到10000&lt;/span&gt;，这个小目标有点挑战性，不过也不是没有可能，写几篇质量更好的博客就行了。&lt;/p&gt;&lt;p data-lake-id=&quot;cb95b5a73e1f71a1e247fdd461e45087&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;222bef36d175709e78bc2643b56c5ad5&quot;&gt;很早就已经动笔，但是还没有发表的博客有这些：&lt;/p&gt;&lt;p data-lake-id=&quot;af0c87c67c6eea3a2fca40487da995d3&quot;&gt;&lt;/p&gt;&lt;ul data-lake-id=&quot;4e3a98adc12d7694d7989c39dc2012c2&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;《聊聊Docker的崛起与衰落》，完成70%了&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;《如何提高写作质量：10万+背后的思考》，完成50%了&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;《深入理解Linux容器技术》，这篇是翻译我几年前写的英文博客《Linux Container Technology Overview》，完成50%了&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;《JavaScript深入浅出第6课：Visual Studio Code是如何成功的？》，完成50%了&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;《安利一下微信读书》，完成50%&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-lake-id=&quot;d94c95121676aa7358c82373f3e5ea35&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;3133e993d0763a5c425364a5e382a39d&quot;&gt;&lt;span&gt;感兴趣的话题，希望可以写成博客的有这些：&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;287a22b999c5146c94f2829330752ccb&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Promise与Monat的关系&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从React Hooks看函数式编程&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;理解React Server Component&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;React源码阅读&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;详解AST&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-lake-id=&quot;20c985adb4a8667692f72d726fa7542d&quot;&gt;&lt;/p&gt;&lt;h1 data-lake-id=&quot;e232d85ef09bd31962c7c1a69955b0d0&quot;&gt;投资&lt;/h1&gt;&lt;p data-lake-id=&quot;fb46e22d5e5450a152ec769f75e2ebef&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;2e7328f4f3f653fe864255f7ea545aa2&quot;&gt;2020年，开始研究价值投资，关注了一些价值投资大佬，比如巴菲特、芒格、彼得林奇、但斌、张磊、段永平等，看了一些书&lt;strong&gt;。&lt;/strong&gt;对于价值投资，有了一些自己的理解：&lt;/p&gt;&lt;p data-lake-id=&quot;15d7e9d788c9833c31cbaedeb87f2caf&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;72e6a04b514dc1d03aaf508a9d218df5&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;0de4fb12d2ec3fae414c2f20dd2fc416&quot;&gt;实践是检验真理的唯一标准，我买的股票和基金有这些：&lt;/p&gt;&lt;p data-lake-id=&quot;3080f86d055b93f6ca34a82d40ea0671&quot;&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p data-lake-id=&quot;1f8e9e32240657b33f2234ecfae00765&quot;&gt;&lt;strong&gt;股票/基金&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p data-lake-id=&quot;6a93646548a9d7586a1364f17b04ca3a&quot;&gt;&lt;strong&gt;投资收益&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p data-lake-id=&quot;c2649dcd28ef529c3a22371f13957dcd&quot;&gt;Apple&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p data-lake-id=&quot;79ffc877ada2edf030869df68dde29d8&quot;&gt;11.99%&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p data-lake-id=&quot;4b824c5fafe9501d8488d97cc609c4af&quot;&gt;美的集团&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p data-lake-id=&quot;e2b28e397c4fda902d8a221996541110&quot;&gt;24.72%&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;1&quot;&gt;&lt;p data-lake-id=&quot;a20d224c568e48b9d67847a2c66a8c01_p_0&quot;&gt;顺丰控股&lt;/p&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot;&gt;&lt;p data-lake-id=&quot;a20d224c568e48b9d67847a2c66a8c01_p_0&quot;&gt;9.24%&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;1&quot;&gt;&lt;p data-lake-id=&quot;a20d224c568e48b9d67847a2c66a8c01_p_0&quot;&gt;立讯精密&lt;/p&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot;&gt;&lt;p data-lake-id=&quot;a20d224c568e48b9d67847a2c66a8c01_p_0&quot;&gt;15.29%&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;1&quot;&gt;&lt;p data-lake-id=&quot;a20d224c568e48b9d67847a2c66a8c01_p_0&quot;&gt;华安纳斯达克100指数（QDII）&lt;/p&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot;&gt;&lt;p data-lake-id=&quot;a20d224c568e48b9d67847a2c66a8c01_p_0&quot;&gt;5.93%&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;1&quot;&gt;&lt;p data-lake-id=&quot;a20d224c568e48b9d67847a2c66a8c01_p_0&quot;&gt;长城创业板指数增强A&lt;/p&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot;&gt;&lt;p data-lake-id=&quot;a20d224c568e48b9d67847a2c66a8c01_p_0&quot;&gt;10.99%&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;1&quot;&gt;&lt;p data-lake-id=&quot;a20d224c568e48b9d67847a2c66a8c01_p_0&quot;&gt;易方达上证50指数A&lt;/p&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot;&gt;&lt;p data-lake-id=&quot;a20d224c568e48b9d67847a2c66a8c01_p_0&quot;&gt;16.54%&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-lake-id=&quot;a2a1427cbd9d4c87e78832e01abd94f4&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;5e49d56ad34b02046d6522f1cce21540&quot;&gt;2020年，整体投资收益率是14.17%，是低于大盘的，但是符合我的个人预期。赚钱的主要是原因运气还行，大盘走势强，只要不乱来，就能赚钱。2020年炒股赚钱，并没什么好炫耀的。&lt;/p&gt;&lt;p data-lake-id=&quot;c72f8b6f1db1974fbda994e6c0be4dfb&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;9f4c80364930c89e3aea4e28e4430237&quot;&gt;但是，投资最难的是坚持。2020年，我严格遵守了价值投资的规则，无论股票基金涨跌，我都是只买入没有卖出。如果我卖了自己买的股票和基金，那我当时买它们干嘛？是不是买入的时候没看懂？说好了长期投资呢？&lt;/p&gt;&lt;p data-lake-id=&quot;f15fa147843060ded23bf4beebb2e793&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;069f524b72ba2ad90f207768764fec94&quot;&gt;2021年，最想买入的股票是茅台，躺着赚钱的印钞机啊，另外Apple和美的应该会继续加仓，其他标的也在看。指数基金的定投会继续坚持，但是股票型基金不会考虑，既然有信心看得懂公司，那就直接买股票就好了，&lt;span&gt;自己当自己的基金经理&lt;/span&gt;。&lt;/p&gt;&lt;p data-lake-id=&quot;55d4bf82fbc7de3910e3d4ec4c8232d2&quot;&gt;&lt;/p&gt;&lt;h1 data-lake-id=&quot;c658bf0a7ca148ae440bd2a505acc9a4&quot;&gt;总结&lt;/h1&gt;&lt;p data-lake-id=&quot;3aef332527422dc0c092d22488039a25&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;40ec238efb7d929ef5edb69b8e9500e2&quot;&gt;作为一个长期主义者，对于读书、写作、投资这些需要时间积累的事情都很感兴趣，1年时间过得很快，但是10年时间可以做很多事情，共勉~&lt;/p&gt;&lt;p data-lake-id=&quot;b7a833a46704a9b00ab68c119f2e808e&quot;&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;117&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;Most people overestimate what they can do in one year and underestimate what they can do in ten years. -- Bill Gates.&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;h1 data-lake-id=&quot;7467942e7b003185e405ad2344325e45&quot;&gt;&lt;span&gt;招聘&lt;/span&gt;&lt;/h1&gt;&lt;p data-lake-id=&quot;de4835ddf7e7a214a5403d922704bfe4&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;51f066d09a71deb3b7c38119d4f34e3d&quot;&gt;&lt;span&gt;&lt;span&gt;阿里巴巴业务平台事业部长期招聘P6及以上前端大佬，参与建设最前沿的阿里前端生态系统，推动行业技术发展，内推地址：&lt;/span&gt;&lt;span&gt;hanyan.lk@alibaba-inc.com&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;欢迎大家关注我的微信公众号&lt;/span&gt;&lt;strong&gt;寒雁Talk&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UnKibSlmUib8hQxPlpiaFxBs15sjiaeBQicnBdZU9zDvK2siaAPK2I0Eib1m6XthEG4EDEN4AibicibyibJwtNVTRdrZib33Bw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;ee439062b5aaeb81de305cc80f7c5c8e&quot;&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>