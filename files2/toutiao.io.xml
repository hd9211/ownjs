<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>73284fc8941ed16fcde4a5a0ec7a0586</guid>
<title>跟 Kafka 学技术系列之时间轮</title>
<link>https://toutiao.io/k/77iozz6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;src-views-article-detail-main-module__content--2qOBd markdown-body&quot;&gt;&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;kafka是一个分布式消息中间件，其高可用高吞吐的特点是大数据领域首选的消息中间件，Kafka是分布式消息队列的顺序读写文件分段组织串联起来思想的鼻祖，包括RocketMq这些消息队列都是借鉴了Kafka早期的架构和设计思路改造而来，所以在架构设计层面，Kafka有非常多值得借鉴的地方。本文是作者介绍Kafka优秀架构设计文章中的一篇，文中的代码和流程图均是base on 0.10.2.0版本。&lt;/p&gt;
&lt;h1&gt;引出环形队列和延迟队列&lt;/h1&gt;
&lt;p&gt;从2个面试题说起，第1个问题，如果一台机器上有10w个定时任务，如何做到高效触发？&lt;/p&gt;
&lt;p&gt;具体场景是：&lt;/p&gt;
&lt;p&gt;有一个APP实时消息通道系统，对每个用户会维护一个APP到服务器的TCP连接，用来实时收发消息，对这个TCP连接，有这样一个需求：“如果连续30s没有请求包（例如登录，消息，keepalive包），服务端就要将这个用户的状态置为离线”。&lt;/p&gt;
&lt;p&gt;其中，单机TCP同时在线量约在10w级别，keepalive请求包较分散大概30s一次，吞吐量约在3000qps。&lt;/p&gt;
&lt;p&gt;怎么做？&lt;/p&gt;
&lt;p&gt;常用方案使用time定时任务，每秒扫描一次所有连接的集合Map&amp;lt;uid, last_packet_time&amp;gt;，把连接时间（每次有新的请求更新对应连接的连接时间）比当前时间的差值大30s的连接找出来处理。&lt;/p&gt;
&lt;p&gt;另一种方案，使用环形队列法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200308202309477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1poaVp1aUNodW5GZW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;小桔车服 &amp;gt; 跟Kafka学技术-时间轮 &amp;gt; image2020-1-17_16-20-37.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三个重要的数据结构：&lt;/p&gt;
&lt;p&gt;1）30s超时，就创建一个index从0到30的环形队列（本质是个数组）&lt;/p&gt;
&lt;p&gt;2）环上每一个slot是一个Set&amp;lt;uid&amp;gt;，任务集合&lt;/p&gt;
&lt;p&gt;3）同时还有一个Map&amp;lt;uid, index&amp;gt;，记录uid落在环上的哪个slot里&lt;/p&gt;
&lt;p&gt;这样当有某用户uid有请求包到达时：&lt;/p&gt;
&lt;p&gt;1）从Map结构中，查找出这个uid存储在哪一个slot里&lt;/p&gt;
&lt;p&gt;2）从这个slot的Set结构中，删除这个uid&lt;/p&gt;
&lt;p&gt;3）将uid重新加入到新的slot中，具体是哪一个slot呢 =&amp;gt; Current Index指针所指向的上一个slot，因为这个slot，会被timer在30s之后扫描到&lt;/p&gt;
&lt;p&gt;4）更新Map，这个uid对应slot的index值&lt;/p&gt;
&lt;p&gt;哪些元素会被超时掉呢？&lt;/p&gt;
&lt;p&gt;Current Index每秒种移动一个slot，这个slot对应的Set&amp;lt;uid&amp;gt;中所有uid都应该被集体超时！如果最近30s有请求包来到，一定被放到Current Index的前一个slot了，Current Index所在的slot对应Set中所有元素，都是最近30s没有请求包来到的。&lt;/p&gt;
&lt;p&gt;所以，当没有超时时，Current Index扫到的每一个slot的Set中应该都没有元素。&lt;/p&gt;
&lt;p&gt;两种方案对比：&lt;/p&gt;
&lt;p&gt;方案一每次都要轮询所有数据，而方案二使用环形队列只需要轮询这一刻需要过期的数据，如果没有数据过期则没有数据要处理，并且是批量超时，并且由于是环形结构更加节约空间，这很适合高性能场景。&lt;/p&gt;
&lt;p&gt;第二个问题：在开发过程中有延迟一定时间的任务要执行，怎么做？&lt;/p&gt;
&lt;p&gt;如果不重复造轮子的话，我们的选择当然是延迟队列或者Timer。&lt;/p&gt;
&lt;p&gt;延迟队列和在Timer中增 加延时任务采用数组表示的最小堆的数据结构实现，每次放入新元素和移除队首元素时间复杂度为O(nlog(n))。&lt;/p&gt;
&lt;h1&gt;时间轮&lt;/h1&gt;
&lt;p&gt;方案二所采用的环形队列，就是时间轮的底层数据结构，它能够让需要处理的数据（任务的抽象）集中，在Kafka中存在大量的延迟操作，比如延迟生产、延迟拉取以及延迟删除等。Kafka并没有使用JDK自带的Timer或者DelayQueue来实现延迟的功能，而是基于时间轮自定义了一个用于实现延迟功能的定时器（SystemTimer）。JDK的Timer和DelayQueue插入和删除操作的平均时间复杂度为O(nlog(n))，并不能满足Kafka的高性能要求，而基于时间轮可以将插入和删除操作的时间复杂度都降为O(1)。时间轮的应用并非Kafka独有，其应用场景还有很多，在Netty、Akka、Quartz、Zookeeper等组件中都存在时间轮的踪影。&lt;/p&gt;
&lt;h2&gt;时间轮的数据结构&lt;/h2&gt;
&lt;p&gt;参考下图，Kafka中的时间轮（TimingWheel）是一个存储定时任务的环形队列，底层采用数组实现，数组中的每个元素可以存放一个定时任务列表（TimerTaskList）。TimerTaskList是一个环形的双向链表，链表中的每一项表示的都是定时任务项（TimerTaskEntry），其中封装了真正的定时任务TimerTask。在Kafka源码中对这个TimeTaskList是用一个名称为buckets的数组表示的，所以后面介绍中可能TimerTaskList也会被称为bucket。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200308202645122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1poaVp1aUNodW5GZW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;时间轮组成&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;时间轮相关名词解释&lt;/h2&gt;
&lt;p&gt;tickMs：时间轮由多个时间格组成，每个时间格就是tickMs，它代表当前时间轮的基本时间跨度。&lt;/p&gt;
&lt;p&gt;wheelSize：代表每一层时间轮的格数&lt;/p&gt;
&lt;p&gt;interval：当前时间轮的总体时间跨度，interval=tickMs × wheelSize&lt;/p&gt;
&lt;p&gt;startMs：构造当层时间轮时候的当前时间，第一层的时间轮的startMs是TimeUnit.NANOSECONDS.toMillis(nanoseconds()),上层时间轮的startMs为下层时间轮的currentTime。&lt;/p&gt;
&lt;p&gt;currentTime：表示时间轮当前所处的时间，currentTime是tickMs的整数倍（通过currentTime=startMs - (startMs % tickMs来保正currentTime一定是tickMs的整数倍），这个运算类比钟表中分钟里65秒分针指针指向的还是1分钟）。currentTime可以将整个时间轮划分为到期部分和未到期部分，currentTime当前指向的时间格也属于到期部分，表示刚好到期，需要处理此时间格所对应的TimerTaskList的所有任务。&lt;/p&gt;
&lt;h2&gt;时间轮中的任务存放&lt;/h2&gt;
&lt;p&gt;若时间轮的tickMs=1ms，wheelSize=20，那么可以计算得出interval为20ms。初始情况下表盘指针currentTime指向时间格0，此时有一个定时为2ms的任务插入进来会存放到时间格为2的TimerTaskList中。随着时间的不断推移，指针currentTime不断向前推进，过了2ms之后，当到达时间格2时，就需要将时间格2所对应的TimeTaskList中的任务做相应的到期操作。此时若又有一个定时为8ms的任务插入进来，则会存放到时间格10中，currentTime再过8ms后会指向时间格10。如果同时有一个定时为19ms的任务插入进来怎么办？新来的TimerTaskEntry会复用原来的TimerTaskList，所以它会插入到原本已经到期的时间格1中。总之，整个时间轮的总体跨度是不变的，随着指针currentTime的不断推进，当前时间轮所能处理的时间段也在不断后移，总体时间范围在currentTime和currentTime+interval之间。&lt;/p&gt;
&lt;h2&gt;时间轮的升降级&lt;/h2&gt;
&lt;p&gt;如果此时有个定时为350ms的任务该如何处理？直接扩充wheelSize的大小么？Kafka中不乏几万甚至几十万毫秒的定时任务，这个wheelSize的扩充没有底线，就算将所有的定时任务的到期时间都设定一个上限，比如100万毫秒，那么这个wheelSize为100万毫秒的时间轮不仅占用很大的内存空间，而且效率也会拉低。Kafka为此引入了层级时间轮的概念，当任务的到期时间超过了当前时间轮所表示的时间范围时，就会尝试添加到上层时间轮中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200308202605415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1poaVp1aUNodW5GZW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;时间轮升降级&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考上图，复用之前的案例，第一层的时间轮tickMs=1ms, wheelSize=20, interval=20ms。第二层的时间轮的tickMs为第一层时间轮的interval，即为20ms。每一层时间轮的wheelSize是固定的，都是20，那么第二层的时间轮的总体时间跨度interval为400ms。以此类推，这个400ms也是第三层的tickMs的大小，第三层的时间轮的总体时间跨度为8000ms。&lt;br/&gt;
刚才提到的350ms的任务，不会插入到第一层时间轮，会插入到interval=20*20的第二层时间轮中，具体插入到时间轮的哪个bucket呢？先用350/tickMs(20)=virtualId(17)，然后virtualId(17) %wheelSize (20) = 17，所以350会放在第17个bucket。如果此时有一个450ms后执行的任务，那么会放在第三层时间轮中，按照刚才的计算公式，会放在第0个bucket。第0个bucket里会包含&lt;/p&gt;
&lt;p&gt;[400,800)ms的任务。随着时间流逝，当时间过去了400ms，那么450ms后就要执行的任务还剩下50ms的时间才能执行，此时有一个时间轮降级的操作，将50ms任务重新提交到层级时间轮中，那么此时50ms的任务根据公式会放入第二个时间轮的第2个bucket中，此bucket的时间范围为[40,60)ms，然后再经过40ms，这个50ms的任务又会被监控到，此时距离任务执行还有10ms，同样将10ms的任务提交到层级时间轮，此时会加入到第一层时间轮的第10个bucket，所以再经过10ms后，此任务到期，最终执行。&lt;/p&gt;
&lt;p&gt;整个时间轮的升级降级操作是不是很类似于我们的时钟？ 第一层时间轮tickMs=1s, wheelSize=60，interval=1min，此为秒钟；第二层tickMs=1min，wheelSize=60，interval=1hour，此为分钟；第三层tickMs=1hour，wheelSize为12，interval为12hours，此为时钟。而钟表的指针就对应程序中的currentTime，这个后面分析代码时候会讲到（对这个的理解也是时间轮理解的重点和难点）。&lt;/p&gt;
&lt;p&gt;Kafka中任务添加和驱动时间轮滚动的核心流程：&lt;br/&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20200308202809831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1poaVp1aUNodW5GZW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;任务添加和驱动时间轮滚动核心流程图&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;重点代码介绍&lt;/h2&gt;
&lt;p&gt;这是往SystenTimer中添加一个任务&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//在Systemtimer中添加一个任务，任务被包装为一个TimerTaskEntry&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; def &lt;span class=&quot;hljs-title&quot;&gt;addTimerTaskEntry&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(timerTaskEntry: TimerTaskEntry)&lt;/span&gt;: Unit &lt;/span&gt;= {
&lt;span class=&quot;hljs-comment&quot;&gt;//先判断是否可以添加进时间轮中，如果不可以添加进去代表任务已经过期或者任务被取消，注意这里的timingWheel持有上一层时间轮的引用，所以可能存在递归调用&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!timingWheel.add(timerTaskEntry)) {
    &lt;span class=&quot;hljs-comment&quot;&gt;// Already expired or cancelled&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!timerTaskEntry.cancelled)
     &lt;span class=&quot;hljs-comment&quot;&gt;//过期任务直接线程池异步执行掉&lt;/span&gt;
      taskExecutor.submit(timerTaskEntry.timerTask)
  }
}
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;timingWheel添加任务，递归添加直到添加该任务进合适的时间轮的bucket中&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(timerTaskEntry: TimerTaskEntry)&lt;/span&gt;: Boolean &lt;/span&gt;= {
  val expiration = timerTaskEntry.expirationMs
  &lt;span class=&quot;hljs-comment&quot;&gt;//任务取消&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (timerTaskEntry.cancelled) {
    &lt;span class=&quot;hljs-comment&quot;&gt;// Cancelled&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;
  } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (expiration &amp;lt; currentTime + tickMs) {
    &lt;span class=&quot;hljs-comment&quot;&gt;// 任务过期后会被执行&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;
  } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (expiration &amp;lt; currentTime + interval) {&lt;span class=&quot;hljs-comment&quot;&gt;//任务过期时间比当前时间轮时间加周期小说明任务过期时间在本时间轮周期内&lt;/span&gt;
    val virtualId = expiration / tickMs
    &lt;span class=&quot;hljs-comment&quot;&gt;//找到任务对应本时间轮的bucket&lt;/span&gt;
    val bucket = buckets((virtualId % wheelSize.toLong).toInt)
    bucket.add(timerTaskEntry)
    &lt;span class=&quot;hljs-comment&quot;&gt;// Set the bucket expiration time&lt;/span&gt;
   &lt;span class=&quot;hljs-comment&quot;&gt;//只有本bucket内的任务都过期后才会bucket.setExpiration返回true此时将bucket放入延迟队列&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (bucket.setExpiration(virtualId * tickMs)) {
     &lt;span class=&quot;hljs-comment&quot;&gt;//bucket是一个TimerTaskList，它实现了java.util.concurrent.Delayed接口，里面是一个多任务组成的链表，图2有说明&lt;/span&gt;
      queue.offer(bucket)
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;
  } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;hljs-comment&quot;&gt;// Out of the interval. Put it into the parent timer&lt;/span&gt;
    &lt;span class=&quot;hljs-comment&quot;&gt;//任务的过期时间不在本时间轮周期内说明需要升级时间轮，如果不存在则构造上一层时间轮，继续用上一层时间轮添加任务&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (overflowWheel == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) addOverflowWheel()
    overflowWheel.add(timerTaskEntry)
  }
}

&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;在本层级时间轮里添加上一层时间轮里的过程，注意的是在下一层时间轮的interval为上一层时间轮的tickMs&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;[&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;] &lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;addOverflowWheel&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;: Unit &lt;/span&gt;= {
  &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; {
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (overflowWheel == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
      overflowWheel = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TimingWheel(
        tickMs = interval,
        wheelSize = wheelSize,
        startMs = currentTime,
        taskCounter = taskCounter,
        queue
      )
    }
  }
}
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;驱动时间轮滚动过程：&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//注意这里会存在一个递归，一直驱动时间轮的指针滚动直到时间不足于驱动上层的时间轮滚动。&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;advanceClock&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(timeMs: Long)&lt;/span&gt;: Unit &lt;/span&gt;= {
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (timeMs &amp;gt;= currentTime + tickMs) {
   &lt;span class=&quot;hljs-comment&quot;&gt;//把当前时间打平为时间轮tickMs的整数倍&lt;/span&gt;
    currentTime = timeMs - (timeMs % tickMs)
    &lt;span class=&quot;hljs-comment&quot;&gt;// Try to advance the clock of the overflow wheel if present&lt;/span&gt;
    &lt;span class=&quot;hljs-comment&quot;&gt;//驱动上层时间轮，这里的传给上层的currentTime时间是本层时间轮打平过的，但是在上层时间轮还是会继续打平&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (overflowWheel != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) overflowWheel.advanceClock(currentTime)
  }
}
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;这里是驱动源代码：&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//循环bucket里面的任务列表，一个个重新添加进时间轮，对符合条件的时间轮进行升降级或者执行任务&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;[&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;] val reinsert = (timerTaskEntry: TimerTaskEntry) =&amp;gt; addTimerTaskEntry(timerTaskEntry)
 
&lt;span class=&quot;hljs-comment&quot;&gt;/*
 * Advances the clock if there is an expired bucket. If there isn&#x27;t any expired bucket when called,
 * waits up to timeoutMs before giving up.
 */&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;advanceClock&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(timeoutMs: Long)&lt;/span&gt;: Boolean &lt;/span&gt;= {
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; bucket = delayQueue.poll(timeoutMs, TimeUnit.MILLISECONDS)
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (bucket != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
    writeLock.lock()
    &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
      &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (bucket != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;hljs-comment&quot;&gt;//驱动时间轮&lt;/span&gt;
        timingWheel.advanceClock(bucket.getExpiration())
       &lt;span class=&quot;hljs-comment&quot;&gt;//循环buckek也就是任务列表，任务列表一个个继续添加进时间轮以此来升级或者降级时间轮，把过期任务找出来执行&lt;/span&gt;
        bucket.flush(reinsert)
       &lt;span class=&quot;hljs-comment&quot;&gt;//循环&lt;/span&gt;
        &lt;span class=&quot;hljs-comment&quot;&gt;//这里就是从延迟队列取出bucket，bucket是有延迟时间的，取出代表该bucket过期，我们通过bucket能取到bucket包含的任务列表&lt;/span&gt;
        bucket = delayQueue.poll()
      }
    } &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; {
      writeLock.unlock()
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;
  } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;
  }
}
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;kafka的延迟队列使用时间轮实现，能够支持大量任务的高效触发，但是在kafka延迟队列实现方案里还是看到了delayQueue的影子，使用delayQueue是对时间轮里面的bucket放入延迟队列，以此来推动时间轮滚动，但是基于将插入和删除操作则放入时间轮中，将这些操作的时间复杂度都降为O(1)，提升效率。Kafka对性能的极致追求让它把最合适的组件放在最适合的位置。&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>64eee690f264f68b9682379d8c9cef43</guid>
<title>一文通关苦涩难懂的 Java 泛型</title>
<link>https://toutiao.io/k/xhidp2b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信大家对Java泛型并不陌生，无论是开源框架还是&lt;code&gt;JDK&lt;/code&gt;源码都能看到它，毫不夸张的说，泛型是通用设计上必不可少的元素，所以真正理解与正确使用泛型，是一门必修课，本文将解开大家对泛型的疑惑，并通过大量实践，让你get到泛型正确的使用姿势，下面开始进入正题吧！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;大纲&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7120181405895691&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx4t5DlH6w3mEmibxLicsc9mBd7RGCoN4mWQqqHia8InsMyfza0YuZrRphibJLsicXXTia2RDng7md5QfHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;882&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基础&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为本文重实践，而且面对的是Java开发人员群体，大家对泛型都有基础，所以泛型基础这块会快速过，帮助大家回忆下即可，后面主要的则重点是通配符&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;编译期与运行期&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;编译期&lt;/strong&gt;是指把源码交给编译器编译成计算机可执行文件的过程，&lt;strong&gt;运行期&lt;/strong&gt;是指把编译后的文件交给计算机执行，直到程序结束。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Java&lt;/code&gt;中就是把&lt;code&gt;.java&lt;/code&gt;文件编译成&lt;code&gt;.class&lt;/code&gt;文件，再把编译后的文件交给&lt;code&gt;J V M&lt;/code&gt;加载执行，如下图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6796805678793256&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx4t5DlH6w3mEmibxLicsc9mB6BpGy0N8RPhG9ib9gcoEicojmRiaREAtTlwiamo3NdoiadTTpO0x1as5AJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1127&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;泛型&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型又叫“参数化类型”，这么抽象的专业词汇不好理解，阿星就用大白话的形式来解释。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;人是铁，饭是刚，吃饭是刚需，要吃饭自然就少不了碗筷，但是没有规定碗只能盛饭，除了盛饭它还能盛汤、盛菜，制造者只造这个碗，不关心碗盛什么，具体要盛什么由使用者来决定，这就是泛型的概念。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型就是在定义类、接口、方法的时候指定某一种特定类型（&lt;span&gt;碗&lt;/span&gt;），让类、接口、方法的使用者来决定具体用哪一种类型的参数（&lt;span&gt;盛的东西&lt;/span&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Java&lt;/code&gt;的泛型是在&lt;code&gt;1.5&lt;/code&gt;引入的，只在&lt;strong&gt;编译期&lt;/strong&gt;做泛型检查，&lt;strong&gt;运行期&lt;/strong&gt;泛型就会消失，我们把这称为“泛型擦除”，最终类型都会变成 &lt;code&gt;Object&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在没有泛型之前，从集合中读取到的每一个对象都必须进行类型转换，如果不小心插入了错误的类型对象，在运行时的转换处理就会出错，有了泛型后，你可以告诉编译器每个集合接收的对象类型是什么，编译器在编译期就会做类型检查，告知是否插入了错误类型的对象，使得程序更加安全，也更加清楚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后插一句，泛型擦除与原生态类型（List就是原生态，List&lt;t&gt;非原生态）是为了照顾&lt;code&gt;1.5&lt;/code&gt;以前设计上的缺陷，为兼容非泛型代码，所作出的折中策略，&lt;span&gt;所以不推荐使用原生态类型，如果使用了原生态类型，就失去了泛型在安全性与描述性方面的优势。&lt;/span&gt;&lt;/t&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;泛型类&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5573770491803278&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx4t5DlH6w3mEmibxLicsc9mBVf19XNIRGicoI7myibkLaOuwF0vqQQPe3iaqKtk7IaibG0t1YnDopgJtibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;549&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类上定义泛型，作用于类的成员变量与函数，代码实例如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GenericClass&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//成员变量&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; T t;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;functionTwo&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//注意，这个不是泛型方法！！！&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;return&lt;/span&gt; t;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;泛型接口&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5008665511265165&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx4t5DlH6w3mEmibxLicsc9mBH7YHCTEPEk10v5uibXAu4E6zcna57ExYB22pdClibvoib1VwGicwlRiaRQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;577&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口上定义泛型，作用于函数，代码实例如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;GenericInterface&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;delete&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;default&lt;/span&gt; T &lt;span&gt;defaultFunction&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; t;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;泛型函数&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9408369408369408&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx4t5DlH6w3mEmibxLicsc9mBpIwIfD1pJYyMCAt0Haw9pGlWJ2NhWTib9tKCKF7iarapg4sfRsgc3Ziaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;693&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数返回类型旁加上泛型，作用于函数，代码实例如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GenericFunction&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;T &lt;span&gt;functionTwo&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; t;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;String &lt;span&gt;functionThree&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;通配符&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通配符是为了让&lt;code&gt;Java&lt;/code&gt;泛型支持范围限定，这样使得泛型的灵活性提升，同时也让通用性设计有了更多的空间。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;：无界通配符，即类型不确定，任意类型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt;：上边界通配符，即&lt;code&gt;?&lt;/code&gt;是继承自&lt;code&gt;T&lt;/code&gt;的任意子类型，遵守只读不写&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt;：下边界通配符，即&lt;code&gt;?&lt;/code&gt;是&lt;code&gt;T&lt;/code&gt;的任意父类型，遵守只写不读&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信大部分人，都是倒在通配符这块，这里多唠叨点，「&lt;strong&gt;通配符限定的范围是体现在确认“参数化类型”的时候，而不是“参数化类型”填充后&lt;/strong&gt;」，可能这句话不太好理解，来看看下面的代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 1.创建泛型为Number的List类，Integer、Double、Long等都是Number的子类&lt;br/&gt; *   new ArrayList&amp;lt;&amp;gt;() 等价于 new ArrayList&amp;lt;Number&amp;gt;()&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;List&amp;lt;Number&amp;gt; numberList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Number&amp;gt;();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 2.添加不同子类&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;numberList.add(&lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//添加Integer类型&lt;/span&gt;&lt;br/&gt;numberList.add(&lt;span&gt;0.5&lt;/span&gt;);&lt;span&gt;//添加Double类型&lt;/span&gt;&lt;br/&gt;numberList.add(&lt;span&gt;10000L&lt;/span&gt;);&lt;span&gt;//添加Long类型&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 3.创建泛型为Number的List类，Integer、Double、Long等都是Number的子类&lt;br/&gt; *   引用是泛型类别是Number，但具体实现指定的泛型是Integer&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;List&amp;lt;Number&amp;gt; numberListTwo = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;span&gt;//err 异常编译不通过&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 4.创建泛型为Integer的List类，把该对象的引用地址指向泛型为Number的List&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;List&amp;lt;Integer&amp;gt; integerList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;List&amp;lt;Number&amp;gt; numberListThree = integerList;&lt;span&gt;//err 异常编译不通过&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一步：我们创建一个泛型为&lt;code&gt;Number&lt;/code&gt;的&lt;code&gt;List&lt;/code&gt;，编译器检查泛型类别是否一致，一致编译通过（确认参数化类型）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二步：泛型&lt;code&gt;Number&lt;/code&gt;已经填充完毕，调用&lt;code&gt;add&lt;/code&gt;函数，此时&lt;code&gt;add&lt;/code&gt;入参泛型&lt;code&gt;T&lt;/code&gt;已经填充为&lt;code&gt;Number&lt;/code&gt;，&lt;code&gt;add&lt;/code&gt;可入参&lt;code&gt;Number&lt;/code&gt;或其子类&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第三步：我们又创建一个泛型为&lt;code&gt;Number&lt;/code&gt;的&lt;code&gt;List&lt;/code&gt;，编译器检查泛型类别是否一致，不一致编译失败，提示错误（确认参数化类型）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第四步：其实与第三步一样，只是做了一个间接的引用（确认参数化类型）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要解决上面的编译不通过问题，就需要使用通配符，代码如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 1.上边界通配符，Number与Number子类&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;List&amp;lt;? extends Number&amp;gt; numberListFour = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Number&amp;gt;();&lt;br/&gt;numberListFour = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;numberListFour = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Double&amp;gt;();&lt;br/&gt;numberListFour = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Long&amp;gt;();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 2.下边界通配符,Integer与Integer父类&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;List&amp;lt;? &lt;span&gt;super&lt;/span&gt; Integer&amp;gt; integerList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;integerList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Number&amp;gt;();&lt;br/&gt;integerList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Object&amp;gt;();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 3. 无界通配符,类型不确定，任意类型&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;List&amp;lt;?&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Number&amp;gt;();&lt;br/&gt;list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Object&amp;gt;();&lt;br/&gt;list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;();&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后再来说上边界通配符只读不写，下边界通配符只写不读到底是什么意思，用最简单的话来说&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt;上边界通配符不作为函数入参，只作为函数返回类型，比如&lt;code&gt;List&amp;lt;? extends T&amp;gt;&lt;/code&gt;的使用&lt;code&gt;add&lt;/code&gt;函数会编译不通过，&lt;code&gt;get&lt;/code&gt;函数则没问题&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt;下边界通配符不作为函数返回类型，只作为函数入参，比如&lt;code&gt;List&amp;lt;? super T&amp;gt;&lt;/code&gt;的&lt;code&gt;add&lt;/code&gt;函数正常调用，&lt;code&gt;get&lt;/code&gt;函数也没问题，但只会返回&lt;code&gt;Object&lt;/code&gt;，所以意义不大&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家只需要记住上面的规则即可，如果想知道为什么这样设计，可以去了解下&lt;code&gt;P E C S (producer-extends,consumer-super)&lt;/code&gt;原则&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最佳实践&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信过完基础理论大家很多东西都回忆起来了，不要着急，现在开始进入正题，后面内容会有大量的代码实践，所以大家要坐稳了，别晕车了，晕车的话多看几遍，或者评论区提出你的疑问~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/23OQmC1ia8nx4t5DlH6w3mEmibxLicsc9mBJ0TM0ic1RnvTs8TC4RjcsgQC2tzGJNYe1GITOGt1cD5kmOFyFoJV82w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;无限通配符场景&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用泛型，类型参数不确定并且不关心实际的类型参数，就可以使用&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;，像下面的代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 获取集合长度&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;size&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;T&amp;gt; list)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; list.size();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取集合长度-2&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;sizeTwo&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;?&amp;gt;  list)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; list.size();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取任意Set两个集合交集数量&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T,T2&amp;gt; &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;beMixedSum&lt;/span&gt;&lt;span&gt;(Set&amp;lt;T&amp;gt; s1,Set&amp;lt;T2&amp;gt; s2)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (T t : s1) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (s2.contains(t)) {&lt;br/&gt;            i++;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; i;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取任意两个Set集合交集数量-2&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; &lt;span&gt;beMixedSumTwo&lt;/span&gt;&lt;span&gt;(Set&amp;lt;?&amp;gt; s1,Set&amp;lt;?&amp;gt; s2)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Object o : s1) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (s2.contains(o)) {&lt;br/&gt;            i++;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; i;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;size&lt;/code&gt;与&lt;code&gt;sizeTwo&lt;/code&gt;这两个函数都可以正常使用，但是站在设计的角度，&lt;code&gt;sizeTwo&lt;/code&gt;会更合适，函数的目标是返回任意集合的长度，入参采用&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;或&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;都可以接收，但是函数本身并不关心你是什么类型参数，仅仅只要返回长度即可，所以采用&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;beMixedSum&lt;/code&gt;与&lt;code&gt;beMixedSumTwo&lt;/code&gt;这两个函数比较，道理同上面一样，&lt;code&gt;beMixedSumTwo&lt;/code&gt;会更合适，函数的目标是返回两个任意Set集合的交集数量，&lt;code&gt;beMixedSum&lt;/code&gt;函数虽然内部有使用到&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;，但是意义不大，因为&lt;code&gt;contains&lt;/code&gt;入参是&lt;code&gt;Object&lt;/code&gt;，函数本身并不关心你是什么类型参数，所以采用&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;忘了补充另一个场景，就是原生态类型，上述代码使用原生态类型函数使用也没问题，但是强烈不推荐，&lt;span&gt;因为使用原生态就丢失了泛型带来的安全性与描述性！！！&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;上下边界通配符场景&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先泛型是不变的，换句话说&lt;code&gt;List&amp;lt;Object&amp;gt; != List&amp;lt;String&amp;gt;&lt;/code&gt;，有时候需要更多灵活性，就可以通过上下边界通配符来做提升。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 集合工具类&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CollectionUtils&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;        &lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 复制集合-泛型&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;T&amp;gt;  &lt;span&gt;listCopy&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;T&amp;gt; collection)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        List&amp;lt;T&amp;gt; newCollection = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (T t : collection) {&lt;br/&gt;            newCollection.add(t);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; newCollection;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面声明了一个&lt;code&gt;CollectionUtils&lt;/code&gt;类，拥有&lt;code&gt;listCopy&lt;/code&gt;方法，传入任意一个集合返回新的集合，看似没有什么问题，也很灵活，那再看看下面这段代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    CollectionUtils&amp;lt;Number&amp;gt; collectionUtils = &lt;span&gt;new&lt;/span&gt; CollectionUtils&amp;lt;&amp;gt;();&lt;br/&gt;    List&amp;lt;Number&amp;gt;  list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//list.add....&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Integer&amp;gt;  listTwo = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//listTwo.add....&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Double&amp;gt;  listThree = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//listThree.add....&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    List&amp;lt;Number&amp;gt; list1 = collectionUtils.listCopy(list);&lt;br/&gt;    list1 = collectionUtils.listCopy(listTwo);&lt;span&gt;//err 编译异常&lt;/span&gt;&lt;br/&gt;    list1 = collectionUtils.listCopy(listThree);&lt;span&gt;//err 编译异常&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建&lt;code&gt;CollectionUtils&lt;/code&gt;类，泛型的类型参数为&lt;code&gt;Number&lt;/code&gt;，&lt;code&gt;listCopy&lt;/code&gt;函数入参的泛型填充为&lt;code&gt;Number&lt;/code&gt;，此时&lt;code&gt;listCopy&lt;/code&gt;只支持泛型为&lt;code&gt;Number&lt;/code&gt;的&lt;code&gt;List&lt;/code&gt;，如果要让它同时支持泛型为&lt;code&gt;Number&lt;/code&gt;子类的&lt;code&gt;List&lt;/code&gt;，就需要使用上边界通配符，我们再追加一个方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 集合工具&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CollectionUtils&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;        &lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 复制集合-泛型&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;T&amp;gt;  &lt;span&gt;listCopy&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;T&amp;gt; collection)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        List&amp;lt;T&amp;gt; newCollection = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (T t : collection) {&lt;br/&gt;            newCollection.add(t);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; newCollection;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 复制集合-上边界通配符&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt;  List&amp;lt;T&amp;gt;  &lt;span&gt;listCopyTwo&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;? extends T&amp;gt; collection)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        List&amp;lt;T&amp;gt; newCollection = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (T t : collection) {&lt;br/&gt;            newCollection.add(t);&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; newCollection;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    CollectionUtils&amp;lt;Number&amp;gt; collectionUtils = &lt;span&gt;new&lt;/span&gt; CollectionUtils&amp;lt;&amp;gt;();&lt;br/&gt;    List&amp;lt;Number&amp;gt;  list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//list.add....&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Integer&amp;gt;  listTwo = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//listTwo.add....&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Double&amp;gt;  listThree = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//listThree.add....&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    List&amp;lt;Number&amp;gt; list1 = collectionUtils.listCopyTwo(list);&lt;br/&gt;    list1 = collectionUtils.listCopyTwo(listTwo);&lt;br/&gt;    list1 = collectionUtils.listCopyTwo(listThree);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在使用&lt;code&gt;listCopyTwo&lt;/code&gt;就没有问题，&lt;code&gt;listCopyTwo&lt;/code&gt;对比&lt;code&gt;listCopy&lt;/code&gt;它的适用范围更广泛也更灵活，&lt;code&gt;listCopy&lt;/code&gt;能做的&lt;code&gt;listCopyTwo&lt;/code&gt;能做，&lt;code&gt;listCopyTwo&lt;/code&gt;能做的&lt;code&gt;listCopy&lt;/code&gt;就不一定能做了，除此之外，细心的小伙伴肯定发现了，使用上边界通配符的&lt;code&gt;collection&lt;/code&gt;在函数内只使用到了读操作，遵循了只读不写原则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完了上边界通配符，再来看看下边界通配符，依然是复制方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 儿子&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Son&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Father&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 父亲&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Father&lt;/span&gt;  &lt;span&gt;extends&lt;/span&gt;  &lt;span&gt;Grandpa&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 爷爷&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Grandpa&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 集合工具&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CollectionUtils&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 复制集合-泛型&lt;br/&gt;     * target目标   src来源&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;copy&lt;/span&gt;&lt;span&gt;(List&amp;lt;T&amp;gt; target,List&amp;lt;T&amp;gt; src)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (src.size() &amp;gt; target.size()){&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; src.size(); i++) {&lt;br/&gt;                target.set(i,src.get(i));&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义了3个类，分别是&lt;code&gt;Son&lt;/code&gt;儿子、&lt;code&gt;Father&lt;/code&gt;父亲、&lt;code&gt;Grandpa&lt;/code&gt;爷爷，它们是继承关系，作为集合元素，还声明了一个&lt;code&gt;CollectionUtils&lt;/code&gt;类，拥有&lt;code&gt;copy&lt;/code&gt;方法，传入两个集合，目标集合与来源集合，把来源集合元素复制到目标集合中，再看看下面这段代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    CollectionUtils&amp;lt;Father&amp;gt; collectionUtils = &lt;span&gt;new&lt;/span&gt; CollectionUtils&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    List&amp;lt;Father&amp;gt;  fatherTargets = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    List&amp;lt;Father&amp;gt;  fatherSources = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//fatherSources.add...&lt;/span&gt;&lt;br/&gt;    collectionUtils.copy(fatherTargets,fatherSources);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//子类复制到父类&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Son&amp;gt; sonSources = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//sonSources.add...&lt;/span&gt;&lt;br/&gt;    collectionUtils.copy(fatherTargets,sonSources);&lt;span&gt;//err 编译异常&lt;/span&gt;&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建&lt;code&gt;CollectionUtils&lt;/code&gt;类，泛型的类型参数为&lt;code&gt;Father&lt;/code&gt;父亲，&lt;code&gt;copy&lt;/code&gt;函数入参的泛型填充为&lt;code&gt;Father&lt;/code&gt;，此时&lt;code&gt;copy&lt;/code&gt;只支持泛型为&lt;code&gt;Father&lt;/code&gt;的&lt;code&gt;List&lt;/code&gt;，也就说，只支持泛型的类型参数为&lt;code&gt;Father&lt;/code&gt;之间的复制，如果想支持把子类复制到父类要怎么做，先分析下&lt;code&gt;copy&lt;/code&gt;函数，&lt;code&gt;copy&lt;/code&gt;函数的入参&lt;code&gt;src&lt;/code&gt;在函数内部只涉及到了&lt;code&gt;get&lt;/code&gt;函数，即读操作（&lt;span&gt;泛型只作为&lt;code&gt;get&lt;/code&gt;函数返回类型&lt;/span&gt;），符合只读不写原则，可以采用上边界通配符，调整代码如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 集合工具&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CollectionUtils&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 复制集合-泛型&lt;br/&gt;     * target目标   src来源&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;copy&lt;/span&gt;&lt;span&gt;(List&amp;lt;T&amp;gt; target,List&amp;lt;? extends T&amp;gt; src)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (src.size() &amp;gt; target.size()){&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; src.size(); i++) {&lt;br/&gt;                target.set(i,src.get(i));&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    CollectionUtils&amp;lt;Father&amp;gt; collectionUtils = &lt;span&gt;new&lt;/span&gt; CollectionUtils&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    List&amp;lt;Father&amp;gt;  fatherTargets = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    List&amp;lt;Father&amp;gt;  fatherSources = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//fatherSources.add...&lt;/span&gt;&lt;br/&gt;    collectionUtils.copy(fatherTargets,fatherSources);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//子类复制到父类&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Son&amp;gt; sonSources = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//sonSources.add...&lt;/span&gt;&lt;br/&gt;    collectionUtils.copy(fatherTargets,sonSources);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//把子类复制到父类的父类&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Grandpa&amp;gt; grandpaTargets = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    collectionUtils.copy(grandpaTargets,sonSources);&lt;span&gt;//err 编译异常&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;src&lt;/code&gt;入参调整为上边界通配符后，&lt;code&gt;copy&lt;/code&gt;函数传入&lt;code&gt;List&amp;lt;Son&amp;gt; sonSources&lt;/code&gt;就没问题了，此时的&lt;code&gt;copy&lt;/code&gt;函数相较之前的更加灵活了，支持同类与父子类复制，接着又发现了一个问题，目前能复制到上一级父类，如果是多级父类，还无法支持，继续分析&lt;code&gt;copy&lt;/code&gt;函数，&lt;code&gt;copy&lt;/code&gt;函数的入参&lt;code&gt;target&lt;/code&gt;在函数内部只涉及到了&lt;code&gt;add&lt;/code&gt;函数，即写操作（泛型&lt;span&gt;只作为&lt;code&gt;add&lt;/code&gt;函数入参&lt;/span&gt;），符合只写不读原则，可以采用下边界通配符，调整代码如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 集合工具&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CollectionUtils&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 复制集合-泛型&lt;br/&gt;     * target目标   src来源&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;copy&lt;/span&gt;&lt;span&gt;(List&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt;  target,List&amp;lt;? extends T&amp;gt; src)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (src.size() &amp;gt; target.size()){&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; src.size(); i++) {&lt;br/&gt;                target.set(i,src.get(i));&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    CollectionUtils&amp;lt;Father&amp;gt; collectionUtils = &lt;span&gt;new&lt;/span&gt; CollectionUtils&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    List&amp;lt;Father&amp;gt;  fatherTargets = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    List&amp;lt;Father&amp;gt;  fatherSources = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//fatherSources.add...&lt;/span&gt;&lt;br/&gt;    collectionUtils.copy(fatherTargets,fatherSources);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//子类复制到父类&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Son&amp;gt; sonSources = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//sonSources.add...&lt;/span&gt;&lt;br/&gt;    collectionUtils.copy(fatherTargets,sonSources);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//把子类复制到父类的父类&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Grandpa&amp;gt; grandpaTargets = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    collectionUtils.copy(grandpaTargets,sonSources);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;copy&lt;/code&gt;函数终于是完善了，可以说现在是真正支持父子类复制，不难发现&lt;code&gt;copy&lt;/code&gt;函数的设计还是遵循通配符原则的，&lt;code&gt;target&lt;/code&gt;作为目标集合，只做写入，符合只写不读原则，采用了下边界通配符，&lt;code&gt;src&lt;/code&gt;作为来源集合，只做读取，符合只读不写原则，采用了上边界通配符，最后设计出来的&lt;code&gt;copy&lt;/code&gt;函数，它的灵活性与适用范围是远超&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;方式设计的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后总结一下，什么时候用通配符，&lt;strong&gt;如果参数泛型类即要读也要写，那么就不推荐使用，使用正常的泛型即可，如果参数泛型类只读或写，就可以根据原则采用对应的上下边界&lt;/strong&gt;，是不是十分简单，最后再说一次读写的含义，这块确实很容易晕&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;读：所谓读是指参数泛型类，泛型只作为该参数类的函数返回类型，那这个函数就是读，&lt;code&gt;List&lt;/code&gt;作为参数泛型类，它的&lt;code&gt;get&lt;/code&gt;函数就是读&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;写：所谓写是指参数泛型类，泛型只作为该参数类的函数入参，那这个函数就是写，&lt;code&gt;List&lt;/code&gt;作为参数泛型类，它的&lt;code&gt;add&lt;/code&gt;函数就是读&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;留给小题，大家可以思考下&lt;code&gt;Stream&lt;/code&gt;的&lt;code&gt;forEach&lt;/code&gt;函数与&lt;code&gt;map&lt;/code&gt;函数的设计，在&lt;code&gt;Java1.8 Stream&lt;/code&gt;中是大量用到了通配符设计&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-----------------------------------------------------------------&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 下边界通配符&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;forEach&lt;/span&gt;&lt;span&gt;(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt; action)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Consumer&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//写方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;accept&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;-----------------------------------------------------------------&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 上下边界通配符&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&amp;lt;R&amp;gt; &lt;span&gt;Stream&amp;lt;R&amp;gt; &lt;span&gt;map&lt;/span&gt;&lt;span&gt;(Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; T, ? extends R&amp;gt; mapper)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; interface Function&amp;lt;T, R&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;     &lt;span&gt;//读写方法，T只作为入参符合写，R只作为返回值，符合读&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;R &lt;span&gt;apply&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;-----------------------------------------------------------------&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//代码案例&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;br/&gt;        List&amp;lt;Father&amp;gt; fatherList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;br/&gt;        Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; Father&amp;gt; action = &lt;span&gt;new&lt;/span&gt; Consumer&amp;lt;Father&amp;gt;() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;accept&lt;/span&gt;&lt;span&gt;(Father father)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;//执行father逻辑&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;        &lt;br/&gt;         &lt;span&gt;//下边界通配符向上转型&lt;/span&gt;&lt;br/&gt;        Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; Father&amp;gt; actionTwo = &lt;span&gt;new&lt;/span&gt; Consumer&amp;lt;Grandpa&amp;gt;() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;accept&lt;/span&gt;&lt;span&gt;(Grandpa grandpa)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;//执行grandpa逻辑&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;        &lt;br/&gt;         Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; Father, ? extends Grandpa&amp;gt; mapper = &lt;span&gt;new&lt;/span&gt; Function&amp;lt;Father, Grandpa&amp;gt;() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Grandpa &lt;span&gt;apply&lt;/span&gt;&lt;span&gt;(Father father)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;//执行father逻辑后返回Grandpa&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Grandpa();&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;//下边界通配符向上转型，上边界通配符向下转型&lt;/span&gt;&lt;br/&gt;         Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; Father, ? extends Grandpa&amp;gt; mapperTwo = &lt;span&gt;new&lt;/span&gt; Function&amp;lt;Grandpa, Son&amp;gt;() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Son &lt;span&gt;apply&lt;/span&gt;&lt;span&gt;(Grandpa grandpa)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;//执行grandpa逻辑后，返回Son&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Son();&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;        &lt;br/&gt;        fatherList.stream().forEach(action);&lt;br/&gt;        fatherList.stream().forEach(actionTwo);&lt;br/&gt;        &lt;br/&gt;        fatherList.stream().map(mapper);&lt;br/&gt;        fatherList.stream().map(mapperTwo);&lt;br/&gt;        &lt;br/&gt;    &lt;br/&gt;    }&lt;br/&gt;-----------------------------------------------------------------&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;有限制泛型场景&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有限制泛型很简单了，应用场景就是你需要对泛型的参数类型做限制，就可以使用它，比如下面这段代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GenericClass&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Grandpa&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;   &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//....&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    GenericClass&amp;lt;Grandpa&amp;gt; grandpaGeneric = &lt;span&gt;new&lt;/span&gt; GenericClass&amp;lt;&amp;gt;();&lt;br/&gt;    grandpaGeneric.test(&lt;span&gt;new&lt;/span&gt; Grandpa());&lt;br/&gt;    grandpaGeneric.test(&lt;span&gt;new&lt;/span&gt; Father());&lt;br/&gt;    grandpaGeneric.test(&lt;span&gt;new&lt;/span&gt; Son());&lt;br/&gt;    &lt;br/&gt;    GenericClass&amp;lt;Father&amp;gt; fatherGeneric = &lt;span&gt;new&lt;/span&gt; GenericClass&amp;lt;&amp;gt;();&lt;br/&gt;    fatherGeneric.test(&lt;span&gt;new&lt;/span&gt; Father());&lt;br/&gt;    fatherGeneric.test(&lt;span&gt;new&lt;/span&gt; Son());&lt;br/&gt;&lt;br/&gt;    GenericClass&amp;lt;Son&amp;gt; sonGeneric = &lt;span&gt;new&lt;/span&gt; GenericClass&amp;lt;&amp;gt;();&lt;br/&gt;    sonGeneric.test(&lt;span&gt;new&lt;/span&gt; Son());&lt;br/&gt;    &lt;br/&gt;    GenericClass&amp;lt;Object&amp;gt; ObjectGeneric = &lt;span&gt;new&lt;/span&gt; GenericClass&amp;lt;&amp;gt;();&lt;span&gt;//err 编译异常&lt;/span&gt;&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;GenericClass&lt;/code&gt;泛型参数化类型被限制为&lt;code&gt;Grandpa&lt;/code&gt;或其子类，就这么简单，千万不要把有限制泛型与上边界通配符搞混了，这两个不是同一个东西（&lt;code&gt;&amp;lt;T extends Grandpa&amp;gt; != &amp;lt;? extends Grandpa&amp;gt;&lt;/code&gt;），&lt;code&gt;&amp;lt;T extends Grandpa&amp;gt;&lt;/code&gt;不需要遵循上边界通配符的原则，它就是简单的泛型参数化类型限制，而且没有&lt;code&gt;super&lt;/code&gt;的写法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;递归泛型场景&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在有限制泛型的基础上，又可以衍生出递归泛型，就是自身需要使用到自身，比如集合进行自定义元素大小比较的时候，通常会配合&lt;code&gt;Comparable&lt;/code&gt;接口来完成，看看下面这段代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Comparable&lt;/span&gt;&amp;lt;&lt;span&gt;Person&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; age;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; age)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.age = age;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getAge&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; age;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;compareTo&lt;/span&gt;&lt;span&gt;(Person o)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 0代表相等 1代表大于  &amp;lt;0代表小于    &lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.age - o.age;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 集合工具&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CollectionUtils&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 获取集合最大值&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  &amp;lt;E extends Comparable&amp;lt;E&amp;gt;&amp;gt; &lt;span&gt;E &lt;span&gt;max&lt;/span&gt;&lt;span&gt;(List&amp;lt;E&amp;gt; list)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        E result = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (E e : list) {&lt;br/&gt;             &lt;span&gt;if&lt;/span&gt; (result == &lt;span&gt;null&lt;/span&gt; || e.compareTo(result) &amp;gt; &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;                 result = e;&lt;br/&gt;             }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    List&amp;lt;Person&amp;gt; personList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    personList.add(&lt;span&gt;new&lt;/span&gt; Person(&lt;span&gt;12&lt;/span&gt;));&lt;br/&gt;    personList.add(&lt;span&gt;new&lt;/span&gt; Person(&lt;span&gt;19&lt;/span&gt;));&lt;br/&gt;    personList.add(&lt;span&gt;new&lt;/span&gt; Person(&lt;span&gt;20&lt;/span&gt;));&lt;br/&gt;    personList.add(&lt;span&gt;new&lt;/span&gt; Person(&lt;span&gt;5&lt;/span&gt;));&lt;br/&gt;    personList.add(&lt;span&gt;new&lt;/span&gt; Person(&lt;span&gt;18&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;//返回年龄最大的Person元素 &lt;/span&gt;&lt;br/&gt;    Person max = CollectionUtils.max(personList);&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点关注&lt;code&gt;max&lt;/code&gt;泛型函数，&lt;code&gt;max&lt;/code&gt;泛型函数的目标是返回集合最大的元素，内部比较元素大小，取最大值返回，也就说需要和同类型元素做比较，&lt;code&gt;&amp;lt;E extends Comparable&amp;lt;E&amp;gt;&amp;gt;&lt;/code&gt;含义是，泛型&lt;code&gt;E&lt;/code&gt;必须是&lt;code&gt;Comparable&lt;/code&gt;或其子类/实现类，因为比较元素是同类型，所以&lt;code&gt;Comparable&lt;/code&gt;泛型也是&lt;code&gt;E&lt;/code&gt;,最终接收的&lt;code&gt;List&lt;/code&gt;泛型参数化类型必须实现了&lt;code&gt;Comparable&lt;/code&gt;接口，并且&lt;code&gt;Comparable&lt;/code&gt;接口填充的泛型也是该参数化类型，就像上述代码一样。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关于我&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是阿星，一个热爱技术的Java程序猿，在公众号  &lt;strong&gt;&lt;span&gt;「程序猿阿星」&lt;/span&gt;&lt;/strong&gt; 里将会定期分享操作系统、计算机网络、Java、分布式、数据库等精品原创文章，2021，与您在 Be Better 的路上共同成长！。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常感谢各位人才能 看到这里，原创不易，文章有帮助可以「点个赞」或「分享与评论」，都是支持（莫要白嫖）！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;愿你我都能奔赴在各自想去的路上，我们下篇文章见！&lt;/p&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>96a02fab303d0aa998da802df19a42ec</guid>
<title>假如让我来设计 “腾讯视频” 的推荐系统</title>
<link>https://toutiao.io/k/8m5ybgh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-width=&quot;100%&quot; data-opacity=&quot;1&quot; data-rotate=&quot;0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;作者·黄崇远&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;『数据虫巢』&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全文共&lt;strong&gt;4966&lt;/strong&gt;字&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;题图ssyer.com&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;375&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;441&quot; data-ratio=&quot;1.25&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBquKJr2v84mvozwoHosR1ajN8kMiaiaQic0ILbGtGNr2ohh1P9SSXJhtx7cxznJlDmO9iaHtTiboWA00ZVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;“&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 虽然我一向警惕被推荐系统带着走，但我也讨厌低效。&lt;strong&gt;&lt;span&gt;”&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一个带着故事背景的技术话题，轻松愉快但又不乏对于技术深度的思考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7627118644067796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOe4f1s3S39xWsicbxtSq1O8sylvTAh0F7Dw1eBiaPAvLLWvHQ7COTvia3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;59&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.0769230769230769&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOj6rvROR3uPaBiaqickoY94Qh9tGA9vG7aWAiamgBOiag7cnialLkuvxk9Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;01&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;故事背景&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;作为一个拥有二娃的三十多岁中年老男人，岁月早已磨光了我对游戏的激情，想当年我也是天梯1800分的选手，DOTA玩的老溜了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但岁月无情，残废了我的手，消退了我的意志，竟然沦落到简单AI电脑都打不过了，所以，偶尔的闲暇时光，看看电影竟成了我唯一的娱乐消遣方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;笔者作为腾讯视频多年的VIP付费会员，不得不说一句，腾讯视频真的太难用了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首页都是什么鬼，一票的什么热门视频，什么原创，什么娱乐综艺，总之，90%都可能是我一辈子都不会打开的类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是乎，片库和检索成了我的主要获取影片的方式，但是...人的认知是有限的，片库的片源看着也是有限的，但对于我来说就是无限的，看不过来也不知道到底讲啥的（反正有点名头的应该都看过了，剩下都是未知项）。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不可否认的是，通过这种摸索探索的方式，确实被我找到不少之前不知道但是确实还可以的影片，但这个过程太痛苦，试错成本蛮高的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他就不能搞个推荐系统吗？如果让我来设计这么一个推荐系统...&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7627118644067796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOe4f1s3S39xWsicbxtSq1O8sylvTAh0F7Dw1eBiaPAvLLWvHQ7COTvia3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;59&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.0769230769230769&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOj6rvROR3uPaBiaqickoY94Qh9tGA9vG7aWAiamgBOiag7cnialLkuvxk9Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;02&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;先吐槽几个点再说&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;笔者不确认腾讯视频是否有推荐逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先首页的跑马灯中“猜你会追”应该多少是个性化的，但观测下来大部分是根据之前的播放记录（没看完的之类的），甚至是已经看过的还一个劲儿放上去，反正挺辣眼睛的，这个模块还不如放个播放历史记录呢，没劲。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;剩下首页满满的各频道，各类别放了一些所谓的精挑细选的，大概率是非个性化的，如果有，我只能说做的太一言难尽了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;播放页，下面有个为你推荐栏目，目测是个性化的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5312270389419544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBquKJr2v84mvozwoHosR1ajNwsg8pTgfdfzyLBIhZj0nqzU0JNphKqjADW72eITg0dzE1icicwHe6vVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1361&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;不清楚具体的推荐逻辑，但目测在内容相关上做了不少事情，这些都不是重点，重点是以上面截图为例，上面总共推了14个，其中11个我都看过了，你还推个毛啊。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长视频领域是属于典型的短时间内不会重刷剧的场景，你这样搞让我很为难呀。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实现这种去重很难吗，我不是专业搞工程的，但想来不是很困难的，无非就是维护一个用户的已播放队列，甚至是播放进度都可以缓存下来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再再再做的差一点，好吧，没有服务器资源，你把有登录状态的播放历史记录在本地都行了吧，我不指望你跨设备能识别我已经看过的，最起码同个设备启动应用的时候加载播放过的记录，避免这种二货行为很难吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他难不难不知道，反正我是感觉我太难了，要不是看重他片源版权多，我早就放弃抵抗了，用的实在太辛苦了。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7627118644067796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOe4f1s3S39xWsicbxtSq1O8sylvTAh0F7Dw1eBiaPAvLLWvHQ7COTvia3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;59&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.0769230769230769&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOj6rvROR3uPaBiaqickoY94Qh9tGA9vG7aWAiamgBOiag7cnialLkuvxk9Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;03&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;推荐的产品必要性&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上面的吐槽部分来看，腾讯视频不是一个偏推荐系统逻辑的产品逻辑（至于为什么，感觉更多是基因吧，或者做产品的核心方法论，跟头条是另外一条路子，虽然我很不认同这个路子）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所谓推荐系统逻辑的产品逻辑，听着有点绕，笔者说个产品形态就容易理解了，今日头条。或者其下面的相关产品，都是典型重度依赖于推荐来做内容与流量的分发的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本质上推荐逻辑形态和重产品逻辑的形态其实是两种打法，但笔者认为本质上是对人的理解。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;产品思路的打法，核心&lt;/span&gt;&lt;span&gt;是识别主动型和被动型主体，或者说再加上时间因素，什么人什么时候是主动型需求，什么时候是被动型诉求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主动型的选手，其在产品逻辑上，可能更多期望的是一种固定的逻辑，给予其更多的自我空间，去探索和自己寻找需要的东西。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而被动型的选手，更多在于其获取信息的能力是有差的，又或者说人力终归有时尽，比如笔者个人，从某种程度上说获取信息的能力应该比95%的人都强，但很多时候一样非常无奈，毕竟人的认知是有限的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而为什么说要加上时间因素，依然如笔者，可能很多时候我自己通过检索，通过其他工具我已经明确知道我需要看什么剧看什么电影，但很多时候我也希望能够找到我所不知道但又是恰巧我所喜欢的电影，只是不希望这个找的过程太过于闹心。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，当主动型占据权重过大的时候，整个形态重产品逻辑，当被动型的时候重推荐逻辑，不冲突，各取所需而已。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;笔者自身，对于推荐类的产品有天然的抵触心理，并且常常违背推荐逻辑进行产品逻辑体验，属于推荐模型中的典型脏数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结下来就是，看菜下饭，各取所需，平台需要尽量做到千人前面，这里所谓的千人千面就不单纯指推荐系统中的千人千面，还包括上述所说的可能有些人就是喜欢这种严谨风，非个性化风，那么你给他呈现的就是这种非个性化的内容并且罗列整齐的内容，这也是一种个性化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;给喜欢或者有需求的人个性化的内容，给不喜欢个性化的人也是“个性化”的内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7627118644067796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOe4f1s3S39xWsicbxtSq1O8sylvTAh0F7Dw1eBiaPAvLLWvHQ7COTvia3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;59&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.0769230769230769&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOj6rvROR3uPaBiaqickoY94Qh9tGA9vG7aWAiamgBOiag7cnialLkuvxk9Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;04&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;推荐的策略&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;说完了潜在的必要性，现在来聊聊怎么做策略，甚至深入到怎么做模型，毕竟咱们是做数据做算法的嘛，看个视频也得看出花来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实整个视频领域，特别是长视频领域，还是非常有迹可循的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所有的产品形态记住一个推荐逻辑，越是需要决策成本的场景，其中长期的兴趣捕获就越重要，比如长视频领域，你看一个电影需要“浪费”你2个小时，这意味着一旦你选错了，可能你看了30分钟之后，终于发现你丫的一点都不喜欢这个影片，这意味着你真的浪费了30分钟。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这就是决策错误的成本，因此，大部分时候这种决策不会是一时兴趣，而是中长期的行为习惯的最终决策，毕竟浪费30分钟够你刷多少个抖音视频了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，回到中长期兴趣的话题，重点是挖掘中长期兴趣点，这个先放放。我们来看下，长视频还有哪些特点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;列一下电影的几大要素，导演、主演、类型、话题等，这些都是中长期形成的兴趣认知。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但又有所不同，导演主演是长期认同，是有前置认知的，比如我喜欢看黄渤的电影，是因为之前看过他的电影，形成了“这个演员演的电影应该靠谱”这种中长期的认知。导演维度同样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而类型则不同，他是一个大的概念，是一种界限分明的兴趣点，一定是有规律的，没有人所有类型通吃的。比如笔者，对于科幻、超级英雄、动漫、纪录片、动作片、灾难片之类的有一定的认知度，虽然不是说这些类型的电影都喜欢，但起码喜欢的电影大部分都在这些类型里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除此之外，比如什么爱情片、恐怖片、文艺片就不是我的菜了，虽然也看一些，但整体上是非常少的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于类型，其实衍生下去就是话题，这是比类型更细的兴趣聚合点，比如三国题材，他可能是大型战争，也可能是历史，也可能是剧情等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再衍生下去就是系列，比如漫威系列，钢铁侠系列等等，太多了，这种是有天然的强联系的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上都是非常明显的挖掘点，再说下不明显的挖掘点，那就是很多时候要素之间是互斥的，典型如笔者的操作逻辑，对于我所喜欢的主演，我大部分是不挑题材和话题的；对于没有名主演或者我所不熟悉的导演主演，我对于剧情的细节会更加扣，又或者是热度等驱动因素在里头起着很大的作用；对于同题材或者同系列，在体验良好之后，挖掘持续的内容是一个常态；时间是一个典型的类型，具有明显的分界线。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，在选择内容的时候，其实很多时候做决策的是其中一个因素，但是这种因素之间是有先后顺序的，甚至很多时候是互斥的，但难点在于系统需要知道什么内容对于目标来说，其哪个核心因素在起作用，抓住这个核心因素进行有效内容的呈现。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实不用说太多，上面这些做好了，已经能解决很大一部分问题了，大部分把常规兴趣就能捕获住了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，那些策略可验证吗？我觉得太好验证了，例如系列的问题，分析一下历史数据就知道这种系列的追溯程度了。对于主演和导演的因素，追溯一下检索的记录就知道了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些逻辑都是可以验证的，提出假设，在历史数据中寻找答案。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7627118644067796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOe4f1s3S39xWsicbxtSq1O8sylvTAh0F7Dw1eBiaPAvLLWvHQ7COTvia3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;59&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.0769230769230769&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOj6rvROR3uPaBiaqickoY94Qh9tGA9vG7aWAiamgBOiag7cnialLkuvxk9Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;05&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;关于推荐的模型&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面说了一些常见的策略，这里聊一些偏模型的东西。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于目标的兴趣预测，大部分常规逻辑是挖掘用户的特征，然后构建预测模型，然后对用户进行兴趣预测，然后在对应场景推荐合适的ITEM，然后打完收工。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，长视频平台是一个比较特别的场景，回到上面章节，有提到过，长视频平台是有决策成本的，特别是在各大平台争相变相让你付费VIP之后（不VIP就让你看广告看到吐），这种成本变得更高了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这就导致了，目标主体其实是一个多目标，即家庭成员共享账号。典型如笔者，自己和梓尘兄共享账号，我看我的大电影，他看他的动画片和火车视频。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但这俨然就是两个完全不同的兴趣列表，两个完全不同的目标群体，对于预测来说是个挑战。方式一就是分开建模，有没有办法将行为区分开来，然后再分开建模？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还是回到上个章节中的决策成本的问题，这意味着长视频平台注定就是一个低频，但是单次时长较长的场景，这就意味着不同目标主体之间的活动时间一定是有规律的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;依然回到笔者自身，例如笔者平时是没有时间看的，最多中午时间偶尔，周末时间偶尔，对于梓尘兄只要是白天非周末时间基本上不太可能是他在使用，除此之外就是观看的内容本身关联度是非常小的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于上面，一个是拆分行为分开建模，另一种就是把能够典型区分的行为作为典型特征加入训练，例如上面说到的观看时间，甚至是星期几。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要注意的是，在模型中，需要尽可能的让这种显著特征不要泯灭于茫茫特征之海中，是不是想到了什么？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对的wide&amp;amp;deep，一定要把这种显著逻辑放到离目标近的地方，万万不要把他丢到成千上万的深度参数中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二个典型问题，正负样本的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;依然是决策成本的问题，由于长视频观看一次成本还挺高的，所以其任何观看过程中的行为对于目标预测都是有意义的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如播放过程中是否看完，是否快进，对于系列是否持续追踪，这些都是对正样本有加权作用的，反过来看到一半看不下去的，后面没有续上的，典型就是负例了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但负例的情况有点特殊，那就是他为什么会点开这个视频，他为什么又会放弃掉这个视频。这就需要我们从点开的动作中捕获到其触发的兴趣点，然后从已播放的内容中挖掘中放弃的核心触动因素。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还是以笔者举例，我曾放弃对于导演主演的追求，尝试去看一些看着感兴趣主题的自制网络大电影，但最终却让我养成了对于自制网络大电影持长期怀疑态度。这就是我已经形成了对于网络大电影这个要素持反对的态度了，对于任何类似的内容都持有非常谨慎的选择态度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;是否可以验证？也是可以的，将这种节点获取出来，然后统计其后的行为即可，可以验证这个逻辑。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回到策略这个逻辑中，我们知道我们选择一个电影，很多时候其实就是一个触动点，导演？演员？主题？系列？热度？等等，所以本质上对于不同的特征其决策权重是不同的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;想到了什么？是的，注意力，如何能够精准的把握住不同特征之间的注意力非常主要，至于是不是用attention，这个就是实现方式的问题了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7627118644067796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOe4f1s3S39xWsicbxtSq1O8sylvTAh0F7Dw1eBiaPAvLLWvHQ7COTvia3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;59&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.0769230769230769&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOj6rvROR3uPaBiaqickoY94Qh9tGA9vG7aWAiamgBOiag7cnialLkuvxk9Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;06&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;商业行为的考量&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这个部分，我们回到商业问题的讨论，任何所谓的推荐系统也好，非推荐系统的产品形态也好，本质上都逃离不了商业变现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一切一切“罪恶”的根源在于平台想搞钱，谁都不是搞慈善的，所以可以理解，只是最好将这个事情做的更加平滑一些，让人更容易接受一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从目前长视频的各大平台的“尿性”来说，打怪升级的路径为普通会员（没啥鸟用），VIP会员（以前很有鸟用，现在很多时候也没啥鸟用），VVIP会员（传说中的荣耀级，可以各种抢先看），甚至还有付费片源（这个更吊，看一个收费一个）。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实推荐系统在这种升级打怪逻辑中是有帮助的，从普通到VIP，到VVIP，再到说服别人为单个片付费，这个难度是依次递增的。而笔者一直停留在第二级，始终上不去。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种内容追求的递增性，需要在产品逻辑的设计上，铺垫好节奏，前戏要做足，上来就让人各种付费，凭啥？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，依赖推荐逻辑，将这种付费的诱导性融入到推荐的内容层级上，先逐步的挖掘用户的兴趣，先用免费资源不断的探测用户的兴趣边界，然后通过推荐不断的深化这种偏好，并且往逐步付费的道路上引导。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通俗点说就是，先用免费的把你养熟了，加大依赖性了，逐步的把兴趣点上较新更好的付费资源逐步逐层去推进，用户就不知不觉去为更好的内容付费了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上来就让你整个VVIP，谁乐意呀（现在我都不乐意为VVIP付费，简直太侮辱人了，鬼知道过两天会不会搞出个VVVIP，不惯着），是吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不知不觉聊了5000字，内容有点散，不是体系化的内容，只是体验别人家产品的时候结合自身的一些专业性的一些零散思考而已。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从笔者个人的从业经验来说，推荐领域本身就是一个强业务的场景，其实单纯从模型网络角度上说，其实目前已经被挖的很多很多了，各种变形的模型，各种骚操作，都有迹可循，不会独创，总能抄上一抄。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要自己多思考的是自身业务场景的特殊性，比如上面说的一账号多个实际主体的问题，时间维度的问题，特性互斥的问题，如何潜入商业化内容夹带私货的问题，这些才是业务场景的独有特性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;围绕观测到的独有特性，去做特殊的处理和优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总而言之，言而总之，对于生活，多观测多思考，形成自己的决策思路，和产品价值观，哪怕不是自己操刀做一个东西，想想也是极有意思的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9465648854961832&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOkgZGq1Nam2wx8KHreT6gcGaEAOHDaREvvGbFfYficNNNkpHKMxiaYRIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;131&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;文章都看完了，还不点个赞来个赏~&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-id=&quot;2255&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;226&quot; data-backw=&quot;578&quot; data-before-oversubscription-url=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/icr5FVCSvBqvKestzBFLnfCjCM3dqHibqiaNpeU4tUjKw5ehb6Pdumns43uNwbr8VWHE2qJMh1WlSZtibU81nHUdXg/0?wx_fmt=jpeg&quot; data-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/icr5FVCSvBqvKestzBFLnfCjCM3dqHibqiadMpRoNxpDgggQFw15AdfibagOvQNbiakdzy3icmLsyTl5G1icl3O1rB3SQ/0?wx_fmt=jpeg&quot; data-ratio=&quot;0.390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/icr5FVCSvBqvKestzBFLnfCjCM3dqHibqiaNpeU4tUjKw5ehb6Pdumns43uNwbr8VWHE2qJMh1WlSZtibU81nHUdXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1a7042456df2dd7be4f4a3c2fd526ded</guid>
<title>Elasticsearch 架构选型指南：不止是搜索引擎，还有......</title>
<link>https://toutiao.io/k/j0yifcz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近被咨询到“ETC 卡口数据的存储以及车流量分析、车路线分析业务场景是否适合 Elasticsearch 去做”的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题涉及 Elasticsearch 架构选型的问题，而追根究底是：Elasticsearch 适合的业务场景的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记得我在做内部技术分享的时候，讲解 Elasticsearch 应用场景，就铺了3 页 PPT：搜索服务场景、日志实时分析场景、商业智能 BI 场景。我拿着初稿找同事讨论，我心想：“没毛病啊？！Elastic 官方、阿里云、腾讯云、金山云、京东云、百度云等介绍 Elasticsearch 都是这么说的。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同事一句话点醒了我：“是不是应该加上 Elasticsearch 不适合做什么？”，“我大呼：搜戴斯乃（原来如此）”。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、Elasticsearch 不适合做什么？&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 不支持事务&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不支持：ACID（在写入或更新数据的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability））。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要有强一致场景，如：银行业务，还得采购 Oracle 等大型商业数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;据我不完整了解：银行使用 Elasticsearch 一般和系统日志统一规范、存储和检索、自动化运维相关，而非存储核心金融交易数据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 多表关联有限&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为习惯了：Mysql 多表通过外键关联检索，不免会将 Mysql 思维平移到 Elasticsearch。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的实战多表关联问题如下：“
一般大in的场景有好的解决方案么？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;比如：连锁 一个人管理了1000家门店 要去查自己管辖的商品。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;比如：企微 一个人维护了 1000个员工 要去查自己管辖的员工。”&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Elasticsearch 多表关联的解决方案一般概括如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;宽表：适合增加冗余存储、空间换时间场景。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;nested 类型：适合子文档偶尔更新、查询频繁场景。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Join 父子文档类型：适合子文档频繁更新频繁场景。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如官方文档所说：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“In particular, joins should be avoided. nested can make queries several times slower and parent-child relations can make queries hundreds of times slower.  ”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方在数据建模部分强调：“应该避免关联。嵌套可以使查询速度慢几倍，父子关系可以使查询速度慢数百倍。因此，若能使用宽表，可以明显加速。”&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3 不支持准实时&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;refresh_interval 刷新频率决定近实时而非准实时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;腾讯云黄华老师的分享《腾讯Elasticsearch海量规模背后的内核优化剖析》中强调：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“ES 是一个实时的分布式搜索分析引擎，目前很多用户对 ES 的印象还是准实时，实际上在6.8版本之后官方文档已经将 near real-time 改为了 real-time”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们直接看一下6.8版本——7.6版本官方文档的说法，的确如黄老师所说：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&quot;Elasticsearch provides real-time search and analytics for all types of data.&quot;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ES 在写入完毕刷新之前，是可以通过 getById 的方式实时获取文档的，只是在刷新之前 FST 还没有构建，还不能提供搜索的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，7.7版本——7.13版本（截止：2021-06-17最新版本）又改成：“Elasticsearch provides &lt;span&gt;&lt;strong&gt;&lt;span&gt;near&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; real-time search and analytics for all types of data. ”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再一次改回原来的说法，说明：官方文档严谨性拿捏的很到位！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;近实时而非准实时说法没毛病。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7.13 版本官方文档地址：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://www.elastic.co/guide/en/elasticsearch/reference/7.13/elasticsearch-intro.html#elasticsearch-intro&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.4 高阶功能收费&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：机器学习、Kerberos 安全认证、JDBC 客户端、ODBC客户端、Graph 探索、威胁猎捕等高阶功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是主流开源上市公司的收费模式，MongoDB、Confluent、Elastic 皆是如此。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开源版、基础版、黄金版、白金版、企业版的区别和差异，查看地址（要做到必知必会）：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://www.elastic.co/cn/subscriptions&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、Elasticsearch 认知升级&lt;/span&gt;&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 Elasticsearch 早已不仅是搜索引擎了&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2418230563002681&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9ZcNaUFJicbnBibErEsESYE1DU8Dx0xArHVA7eJNazNror4sLKr8udMbnvXHZQ6M5Tbqj8z5RbuC0UQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1865&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以 Elasticsearch 起家，发展到：集成 Elasticsearch、Logstash、Beats、Kibana 四位一体的“全家桶”。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Elasticsearch：搜索和分析引擎。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Logstash：数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到诸如 Elasticsearch 等“存储库”中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Beats：一系列轻量型的单一功能数据采集器（包含：Metricbeat、Filebeat等100多种）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kibana ：使用图形和图表对Elasticsearch数据进行可视化和探索分析。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 Elasticsearch 早已不单单局限搜索场景&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Elasticsearch 发展战略也在随&lt;span&gt;势&lt;/span&gt;而变。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6293103448275862&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9ZcNaUFJicbnBibErEsESYE1D6icbh5scF8qyNsBgH0n1jDW0KsL3icVNIfa9hs0licYBFQGnCh5jf1hibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1044&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“3 + 1战略”——是指在Elastic Stack 基础上在Elastic 企业搜索、Elastic 全观察、Elastic 安全三个核心业务场景发力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Elastic 已经由原来的 Elasticsearch 检索工具转变为 Elastic Stack 解决方案提供商。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://www.elastic.co/cn/products/&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、Elasticsearch 业务场景&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是建议过一下官方文档关于 “ &lt;span&gt;What is Elasticsearch ? &lt;/span&gt;”的介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要强调的点如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;slogon 加了分析：由原来的“You know, for search” 改成 “You know, for search (&lt;span&gt;&lt;strong&gt;&lt;span&gt;and analysis&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;)”。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Elasticsearch 是位于 Elastic Stack 核心的分布式搜索和分析引擎。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Elasticsearch 为所有类型的数据提供高效存储和索引、近乎实时的搜索和分析。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有都指哪些？主要指：结构化文本、非结构化文本、数值数据、地理空间数据等。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Elasticsearch 的分布式特性、横向扩展能力可以应对数据、查询量的增长。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Elasticsearch 提供了在各种用例中处理数据的速度和灵活性，尽管并非所有问题都是搜索问题。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方明确点出的几种场景总结如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（1）支持各类应用、网站等的全文搜索。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（2）存储和分析日志、指标和安全事件数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（3）使用机器学习实时自动建模数据的行为。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（4）使用 Elasticsearch 作为存储引擎自动化业务工作流。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（5）使用 Elasticsearch 作为地理信息系统 (GIS) 管理、集成和分析空间信息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我也不免俗，将开头提及的：搜索服务场景、日志实时分析 场景、商业智能 BI 场景以截图的形式提供给大家，更直观一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下三页 PPT 截图是基于腾讯云的分享结合了：官方文档、各大云厂商介绍结合我的理解进行了整合梳理。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 场景1：搜索服务&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1.1 典型场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1.2 主要特性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;高性能：高并发、低延迟的搜索体验&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;强相关：自定义打分、排序机制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高可用：机房、机架感知，异地容灾&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1.3 相关公司&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;腾讯健康码、腾讯文档全文检索、携程、拼多多、蘑菇街、滴滴、今日头条、贝壳找房…….&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5484546883184913&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9ZcNaUFJicbnBibErEsESYE1DA1Qibc3JxrE5TgNoklzfpIRNicuQI5bDmqaEAAicS1NnaxohoAuvIR4qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1909&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 场景2：日志实时分析&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2.1 典型场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;业务日志：用户行为日志、应用日志&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;状态日志：慢查询、异常探测&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统日志：debug、info、warn、error、fatal&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2.2 主要特性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实时性：从日志产生到可访问，秒级&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全文搜索：基于倒排索引，支持灵活的搜索分析&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;交互式分析：万亿级日志，搜索秒级响应&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2.3 相关公司&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日志易等&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5450755601875977&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9ZcNaUFJicbnBibErEsESYE1Dlp2XofmibFeEfeF0ExspcLD1MNiaNzV4JDiaBTXib0k0PtIh9rd5PjSR3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1919&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3 场景3：商业智能BI&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3.1 典型场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;电子商务、移动应用、广告媒体等业务都需要借助数据分析和数据挖掘来辅助商业决策，而规模庞大的业务数据对数据的统计分析造成了很大的挑战。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3.2 主要特性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ES 拥有结构化查询的能力，支持复杂的过滤和聚合统计功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;帮助客户对海量数据进行高效地个性化统计分析、发现问题与机会、辅助商业决策，让数据产生真正的价值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3.3 相关公司&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;睿思BI 等。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5483028720626631&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9ZcNaUFJicbnBibErEsESYE1DkwtiaUcT04SmoO8Mmib8JHhibGCBr0iavcJNsMpWYKQbPP8tGbTJariczsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1915&quot;/&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4、小结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的座右铭之一：“自由不是你想干什么就干什么，而是你不想干什么就有能力不干什么！”。可见：不想干什么较想干什么更为牛逼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而选型 Elasticsearch 的时候也要注意：它不能干什么或者它不擅长需要优先考虑，而将它擅长的、能干什么的方面发挥到极致是我们架构选型及后续实战方面要多考虑的因素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你在架构选型方面还考虑哪些因素？欢迎留言交流分享实战心得。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ee5d231687d7b331c524ba59e340e3a2</guid>
<title>K8S 组件参数及常见问题处理</title>
<link>https://toutiao.io/k/2d8zps3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1 cid=&quot;n1066&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Kubernetes系列：&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxMTM1NDM0Mg==&amp;amp;action=getalbum&amp;amp;album_id=1706133605548163076&amp;amp;scene=173&amp;amp;from_msgid=2452241131&amp;amp;from_itemidx=1&amp;amp;count=3&amp;amp;nolastread=1#wechat_redirect&quot; textvalue=&quot;请点击&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;请点击&lt;/a&gt;。&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.554&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaqVSGJoMTQMQN7Z4JcCI1jwgaP17boxKODnR3q0HQDstyTibwaib7aSnWPDFlhbBtmrKF5QESHnB0P5B91a2P9hg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;/&gt;&lt;/p&gt;&lt;h1 cid=&quot;n1066&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;1. 问题说明&lt;/span&gt;&lt;/h1&gt;&lt;h1 cid=&quot;n1072&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2. 问题处理&lt;/span&gt;&lt;/h1&gt;&lt;p cid=&quot;n1073&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;先看一下Kubernetes主要架构组件图：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1074&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;E:\aa\微信公众号文章\容器加固系列\img\4.1.png&quot;/&gt;&lt;/p&gt;&lt;h2 cid=&quot;n1075&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2.1  etcd&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n1076&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Kubernetes 中的大部分概念如 Pod、ReplicaSet、Deployment、Service、Node 等都可以被 看作一种资源对象，几乎所有资源对象都可以通过 Kubernetes 提供的 kubectl 工具(或者 API 编程调用)执行增、删、改、查等操作并将其保存在 etcd 中持久化存储。从这个角度 来看，Kubernetes 其实是一个高度自动化的资源控制系统，它通过跟踪对比 etcd 库里保存 的“资源期望状态”与当前环境中的“实际资源状态”的差异来实现自动控制和自动纠错 的高级功能。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n1077&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1079&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;etcd 保存整个集群的状态信息，类比相当于k8s的数据库。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1081&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;高可用方面，etcd 需要以集群的方式进行部署，以实现 etcd 数据存储的冗余、备份与高可用。etcd 集群需要奇数形式，至少由三台组成，考虑到同步的开销，一般不推荐超过7个etcd节点。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1083&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;存储，由于etcd 的特性，应考虑使用高性能的存储设备，如 SSD 磁盘，在Kubernetes 集群较大时，必须使用PICe SSD 来提升IO性能减少读写延迟。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1085&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;etcd 性能有两个关键因素：延迟(latency)：延迟是完成操作的时间；吞吐量(throughput)：吞吐量是在某个时间期间之内完成操作的总数量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n1086&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1087&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;压缩空间&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;shell&quot; cid=&quot;n1088&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;# 获取当前版本号&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;$ rev&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;$(ETCDCTL_API=3 etcdctl --key=/etc/kubernetes/pki/etcd/server.key --cert=/etc/kubernetes/pki/etcd/server.crt --cacert=/etc/kubernetes/pki/etcd/ca.crt endpoint status --write-out=&quot;json&quot; | egrep -o &#x27;&quot;revision&quot;:[0-9]*&#x27; | egrep -o &#x27;[0-9]*&#x27;）&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;# 压缩所有旧版本&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;$ ETCDCTL_API&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; etcdctl compact &lt;span&gt;$rev&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;# 去碎片化&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;$ ETCDCTL_API&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; etcdctl defrag&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p cid=&quot;n1089&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;时间参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1090&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;etcd 的心跳间隔默认是 100 毫秒。Etcd 的选举超时时间默认是 1000 毫秒（即从节点等待多久没收到主节点的心跳就尝试去竞选领导者）。在网络环境吞吐量大情况下，如同步吞吐在100MB左右。可适当调整：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1091&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;--heartbeat-interval=300&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1092&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;--election-timeout=5000&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1093&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1094&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题一：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1095&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;etcd集群状态：不同节点上有时候结果还不一样。有时候member1 不健康，有时候 member3 不健康 —— unhealthy。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1096&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;原因：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1097&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;etcd 对系统时间很敏感，当集群节点出现时间不一致时则出现问题。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1098&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1099&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;统一 NTP 服务器校准。集群各节点使用如：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n1100&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1102&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;timedatectl set-timezone Asia/Shanghai 确保时区。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1104&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;ntpdate -u $NTP-SERVER 进行时间同步。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1106&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;使用 chronyd 进行自动时间同步。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n1107&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题二：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n1108&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1110&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;集群加入主机后，主机列表没有新增。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1112&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;接入主机命令执行之后，一般会报错 Node “xxx&quot; not found。（原因是添加被etcd 拒绝）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1114&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;主机状态 未知。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1116&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Kubelet 状态有 database space exceeded报错。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n1117&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;原因：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n1118&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1120&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;默认情况下，ETCD使用的空间上限是 2 GB。一般支持最大 8 GB。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1122&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;默认 etcd 的 snap 频率是 10万次提交 进行一次 Snapshot。Kubernetes 数据存储在 etcd，当 k8s load 较高时，Snap 频率会提高。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure cid=&quot;n1123&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n1124&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span cid=&quot;n1125&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;--snapshot-count &#x27;100000&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n1126&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;number of committed transactions to trigger a snapshot to disk.&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n1127&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1128&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;--max-snapshots&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1129&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;maximum number of snapshot files to retain (0 is unlimited).&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p cid=&quot;n1130&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;shell&quot; cid=&quot;n1131&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;# ETCDCTL_API=3 etcdctl --key=/etc/kubernetes/pki/etcd/server.key --cert=/etc/kubernetes/pki/etcd/server.crt --cacert=/etc/kubernetes/pki/etcd/ca.crt --write-out=table endpoint status&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n1132&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;E:\aa\微信公众号文章\容器加固系列\img\4.2.png&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n1133&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;查看 节点数据存储量，通常数据量应该很小。几百K到几十M不等。出问题一般会超过2G。&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n1134&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1136&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;获取 revision，然后压缩compact&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;shell&quot; cid=&quot;n1137&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;# ETCDCTL_API=3 etcdctl --key=/etc/kubernetes/pki/etcd/server.key --cert=/etc/kubernetes/pki/etcd/server.crt --cacert=/etc/kubernetes/pki/etcd/ca.crt endpoint status --write-out=&quot;json&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;# ETCDCTL_API=3 etcdctl --key=/etc/kubernetes/pki/etcd/server.key --cert=/etc/kubernetes/pki/etcd/server.crt --cacert=/etc/kubernetes/pki/etcd/ca.crt compact 4974364&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p cid=&quot;n1138&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;E:\aa\微信公众号文章\容器加固系列\img\4.3.png&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n1139&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;  2.defrag 整理空间&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;shell&quot; cid=&quot;n1140&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;# ETCDCTL_API=3 etcdctl --key=/etc/kubernetes/pki/etcd/server.key --cert=/etc/kubernetes/pki/etcd/server.crt --cacert=/etc/kubernetes/pki/etcd/ca.crt defrag&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n1141&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n1142&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;    3.修改默认空间&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1143&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;    etcd 的硬盘存储上限（默认是 2GB）,当 etcd 数据量超过默认 quota 值后便不再接受写请求，可以通过设置 --quota-backend-bytes 参数来增加存储大小。&lt;/span&gt;&lt;/p&gt;&lt;h2 cid=&quot;n1144&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2.2  APIServer&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n1145&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;APISERVER 是整个系统的对外接口，提供一套 RESTful 的 Kubernetes API，供客户端和其它组件调用。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n1146&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1148&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;提供对k8s资源操作的唯一入口，并提供认证授权，访问控制，API注册与发现等机制。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1150&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;只有 apiserver 才能操作 etcd，其他组件通过 APISERVER 进行数据的查询和集群状态更新。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1152&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Kubernetes 所有的数据变动都会经过 APISERVER。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure cid=&quot;n1153&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n1154&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span cid=&quot;n1155&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;组件参数&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n1156&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;功能描述&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n1157&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;使用建议&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n1158&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1159&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–enable-garbage-collector&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1160&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;“–enable-garbage-collector&quot;设置了是否开启garbage   collector，该选项必须和kube-controller-manager的”–enable-garbage-collector&quot;参数设置一致，该参数使用true作为默认值。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1161&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Kubernetes的garbage   collector是用来删除曾经有owner，但是现在没有owner的对象的。举个例子，一个ReplicaSet是一组Pod的owner，当这个ReplicaSet被删除后，Kubernetes的garbage   collector负责处理掉这个ReplicaSet控制下的Pod。如果这些Pod在业务中需要被保留，则&quot;–enable-garbage-collector&quot;应被设置为false，其他情况则应设置为true。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1162&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1163&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–enable-logs-handler&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1164&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&quot;–enable-logs-handler&quot;设置了是否为apiserver安装logs   handler，该参数使用true作为默认值。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1165&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;如果不处理apiserver的log是有必要的，则将该参数设置为false。其他情况下，设置为true或者使用默认值。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1166&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1167&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–max-mutating-requests-inflight&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1168&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;“–max-mutating-requests-inflight&quot;设置了apiserver在一定时间内并行处理mutating   request的最大数量，当数量超过这个数值时，超过部分的request会被拒绝处理。当设置为0时，表示apiserver没有单位时间内请求数量的限制，该参数使用200作为默认值。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1169&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;该参数旨在限制单位时间内处理mutating requests的最大数量。因为mutating   request通常需要比non-mutating request处理更多的业务逻辑，所以mutating   request需要消耗更多内存资源，”–max-mutating-requests-inflight&quot;的值也要比&quot;–max-requests-inflight&quot;的值更低。性能测试在决定特定业务场景中&quot;–max-requests-inflight&quot;和&quot;–max-mutating-requests-inflight&quot;两个值的比例时是有必要的。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1170&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1171&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–max-requests-inflight&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1172&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&quot;–max-requests-inflight&quot;设置了apiserver在一定时间内并行处理non-mutating   request的最大数量，当数量超过这个数值时，超过部分的request会被拒绝处理。当设置为0时，表示apiserver没有单位时间内请求数量的限制，该参数使用400作为默认值。该参数可以很好地控制kube-apiserver的内存消耗，而API   server在处理大量request时对CPU并没有很高要求。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1173&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;当该参数值过低时，系统会发生大量request-limit-exceed错误。当该参数值过高时，kube-apiserver会因试图并行处理过多request而内存不够（OOM）发生故障。总体而言，25～30个Pod并行处理15个请求是足够的。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1174&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1175&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–target-ram-mb&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1176&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&quot;–target-ram-mb&quot;设置了apiserver的内存限制。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1177&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;实践中，32C120G可以运行2000个Node和60000个Pod，相当于60M／Node和30Pod／Node。通常而言，每20～30个Pod使用60M是比较合理的。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n1178&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1180&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;上述参数根据实际生产环境调整。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1182&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在 v1.10 以前的版本中可能出现 kubelet 连接 apiserver 超时之后不会主动 reset 掉连接进行重试，除非主动重启 kubelet 或者等待十多分钟后其进行重试。v1.14 及以上版本修复此问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1184&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Kube-APIServer模块的代码审核也是最严格的，一般不会有什么较大的改动，一旦有改动，都是需要长久的讨论才能决定怎么改，毕竟API-Server的性能，直接决定了Kubernetes整体的性能。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n1185&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题一：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1186&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Kubernetes 的各个组件与 Master 之间可以通过 kube-apiserver 的非安全端口 http://&lt;/span&gt;&lt;span md-inline=&quot;tag&quot; spellcheck=&quot;false&quot;&gt;&amp;lt;kube-apiserver-ip&amp;gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;:8080 进行访问。但如果 API Server 需要对外提供服务，或者集群中的某些容器也需要访问 API Server 以获取集群中的某些信息，存在安全隐患。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1187&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1188&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;安全的做法是启用 HTTPS 安全机制。设置 kube-apiserver 的启动参数“--token-auth-file”，或启用RBAC认证，使用文件提供安全认证：&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;shell&quot; cid=&quot;n1189&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;--secure-port&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;6443&lt;/span&gt; &lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;--insecure-port&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;--basic-auth-file&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;/etc/kubernetes/basic_auth_file&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n1190&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n1193&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;8080 端口在后续的版本中将被弃用。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1194&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1195&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题二：&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1196&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;大量 POD 重建导致 events 增多，api server 压力较大，集群访问受到影响。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1197&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决方案 1：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1198&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;  &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;kubectl  delete events --all -n tenant1&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;  &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1202&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决方案 2：&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1203&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;  &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;kubectl  get pod -o wide --all-namespaces | awk &#x27;$5&amp;gt;0&#x27;&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1207&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h2 cid=&quot;n1208&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2.3 kube-scheduler&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n1209&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kube-scheduler，负责资源调度(Pod 调度)的进程，相当 于公交公司的“调度室”。实现 Pod 的调度， 整个调度过程通过执行一系列复杂的算法，最终为每个 Pod 都计算出一个最佳的目标节点。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n1210&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1212&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;通过 watch 到api-server 事件变化，获取需要创建并且未进行调度的 pod 进行调度，如果调度成功会把信息通过 api-server记录到etcd中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1214&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;daemonset 不经过 scheduler 调用，直接在 node 启动。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1216&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;对某些 Node 定义特定的 Label，并且在 Pod 定义文件中使用 NodeSelector 这 种标签调度策略，kube-scheduler 进程可以实现 Pod 定向调度的特性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1218&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Pod/Node Affinity &amp;amp; Anti-affinity&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1220&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Taint &amp;amp; Toleration&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1222&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Priority &amp;amp; Preemption&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1224&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Pod Disruption Budget&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n1225&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1226&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;systemd 启动参数：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1236&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题一：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1237&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;scheduler 默认监听 0.0.0.0，存在安全隐患。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1238&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1239&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;启用 HTTPS，指定监听地址为内网或本机127.0.0.1。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1240&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;--bind-address ip ，在 HTTPS 安全端口提供服务时监听的 IP 地址，默认值为 0.0.0.0。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1241&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;--secure-port int，设置 HTTPS 安全模式的监听端口号，设置为 0 表示不启用 HTTPS，默认值为 10257。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1242&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h2 cid=&quot;n1243&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2.4 kube-controller-manager&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n1244&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kube-manager，是 Kubernetes 中各种操作系统的管理者，是集群内部的管理控制中心，也是 Kubernetes 自动化功能的核心。作为集群内部的管理控制中心，负责集群内资源的管理。目的在于及时发现故障并自动化修复，确保集群始终处于预期的工作状况。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1250&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1251&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;通过设置 kube-controller-manager 组件的启动参数--leader-elect=true，即可实现 kube-controller-manager 组件的高可用性。&lt;/span&gt;&lt;/p&gt;&lt;figure cid=&quot;n1252&quot; mdtype=&quot;table&quot;&gt;&lt;table data-sort=&quot;sortDisabled&quot;&gt;&lt;thead&gt;&lt;tr cid=&quot;n1253&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span cid=&quot;n1254&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;设置参数&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n1255&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;值&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n1256&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;说明&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n1257&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1258&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–feature-gates=ExperimentalCriticalPodAnnotation=true&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1259&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1260&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;关于ExperimentalCriticalPodAnnotation=true这个参数，kube-controller-manager中并没有在使用。如果确实想用CriticalPod，为保险起见，最好还是设置上。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1261&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1262&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–enable-garbage-collector&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1263&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1264&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;设置为true表示启动垃圾回收器，必须与kube-apiserver的该参数设置为相同的值。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1265&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1266&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–cluster-cidr&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1267&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1268&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;表示Pod的IP范围，用于有云提供商的公有云环境下。它的用途是桥接来自集群外的流量。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1269&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1270&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–service-cluster-ip-range&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1271&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1272&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;表示Service的IP范围，用于有云提供商的公有云环境下。目前kube-manager-controller正在重构过程中，将其与云提供商有关部分进行解耦，被解耦的部分重组成一个新的组件，组件名称为cloud-controller-manager,整个重组过程预计在kubernetes-release-1.9版本完成。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1273&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1274&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–terminated-pod-gc-threshold&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1275&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;12500&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1276&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;设置可保存的终止Pod的数量，如果超过该数量，垃圾回收器开始删除操作。设置为不大于0的值表示不启用该功能。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p cid=&quot;n1277&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题一：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1278&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;节点宕机，保障业务不受影响。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1279&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n1280&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1282&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Pod 应该多实例，分布不同主机。避免某个节点宕机带来的单点影响。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1284&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;当计算节点出现问题时，kube-controller 默认需要5分钟后才会驱逐计算节点上的容器并重建。这个时间不建议减少太多，避免因为网络抖动带来 pod 频繁调度和误杀问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1286&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kube-controller-manager，其中「--unhealthy-zone-threshold」参数可以设置在一个 zone 中有多少比例的 Node 失效时将被判断为 unhealthy 不进行节点驱逐，默认值为 0.55。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1288&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;如果对时间敏感度有强烈需求，以下脚本供参考。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;shell&quot; cid=&quot;n1289&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;#!/bin/sh&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;KUBECTL&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;/usr/bin/kubectl&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;# Get only nodes which are not drained yet&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;NOT_READY_NODES&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;$(&lt;/span&gt;&lt;span&gt;$KUBECTL&lt;/span&gt;&lt;span&gt; get nodes | grep -P &#x27;NotReady(?!,SchedulingDisabled)&#x27; | awk &#x27;{print &lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;}&#x27; | xargs echo)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;# Get only nodes which are still drained&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;READY_NODES&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;$(&lt;/span&gt;&lt;span&gt;$KUBECTL&lt;/span&gt;&lt;span&gt; get nodes | grep &#x27;\sReady,SchedulingDisabled&#x27; | awk &#x27;{print &lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;}&#x27; | xargs echo)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;Unready nodes that are undrained: &lt;/span&gt;&lt;span&gt;$NOT_READY_NODES&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;Ready nodes: &lt;/span&gt;&lt;span&gt;$READY_NODES&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;node&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;$NOT_READY_NODES&lt;/span&gt;; &lt;span&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;Node &lt;/span&gt;&lt;span&gt;$node&lt;/span&gt;&lt;span&gt; not drained yet, draining...&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;$KUBECTL&lt;/span&gt; drain &lt;span&gt;--delete-local-data&lt;/span&gt; &lt;span&gt;--ignore-daemonsets&lt;/span&gt; &lt;span&gt;--force&lt;/span&gt; &lt;span&gt;$node&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;Done&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;done&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;node&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;$READY_NODES&lt;/span&gt;; &lt;span&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;Node &lt;/span&gt;&lt;span&gt;$node&lt;/span&gt;&lt;span&gt; still drained, uncordoning...&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;$KUBECTL&lt;/span&gt; uncordon &lt;span&gt;$node&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;Done&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;done&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p cid=&quot;n1293&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1294&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题二：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1295&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Kubernetes 的关键组件除了 API Server 、 scheduler、controller-manager 是运行在 master 节点上的，其余都在普通节点上。当集群内普通节点资源被消耗完，关键组件可能没有足够的资源来运行（如网络组件），导致整个集群无法正常工作。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1296&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1297&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;将普通 Pod （非关键组件）从节点上驱逐来释放占有的资源。但是这样做，普通 Pod 与关键组件 Pod 会一起进入调度器，普通 Pod 可能会先一步被调度到机器上，重新占有释放的资源。这样事情就会陷入一个死循环。可以将被选中的节点（用于释放资源），标记一个暂时的污点（taint “CriticalAddonsOnly” ），这样不能容忍污点的 Pod 将不能调度到有污点的节点上。&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n1298&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1300&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;组件必须运行在 kube-system 命名空间下;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1302&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;1.14 前版本，可以 scheduler.alpha.kubernetes.io/critical-pod 的注解（annotation ）设置为空字符串；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1304&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;PodSpec’s 的容忍（tolerations） 设置为：[{&quot;key&quot;:&quot;CriticalAddonsOnly&quot;,&quot;operator&quot;:&quot;Exists&quot;}]；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1306&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;需要将 priorityClassName 设置为 system-cluster-critical 或 system-node-critical ，后者是整个群集的最高级别。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n1307&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n1308&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h2 cid=&quot;n1309&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2.5 kubelet&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n1310&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet 负责 Pod 对应的容器的创建、启停等任务，同时与 Master 密切协作，实现集群管理的基本功能。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n1311&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1313&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet 负责容器声明周期。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1315&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet 服务依赖于 Docker 服务。如果 docker 进程异常或启动失败，则 kubelet 服务也随之出错。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1317&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;建议 kubelet 以主机服务进程启动运行，如 systemd。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1319&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet 默认采用向 Master 自动注册本 Node 的机制。定时向 Master 汇报自身的节点情况，包括操作系统、Docker 版本、机器的 CPU 和内存情况，以 及当前有哪些 Pod 在运行等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure cid=&quot;n1320&quot; mdtype=&quot;table&quot;&gt;&lt;table data-sort=&quot;sortDisabled&quot;&gt;&lt;thead&gt;&lt;tr cid=&quot;n1321&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span cid=&quot;n1322&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;组件参数&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n1323&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;默认值&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n1324&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;说明&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n1325&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1326&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;--experimental-allocatable-ignore-eviction&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1327&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1328&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;（1）设置为true时，当计算节点可分配资源总量时，&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;–eviction-hard参数将被忽略&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;。此时，节点可分配资源总量 [Allocatable] = [Node   Capacity] - [Kube-Reserved] - [System-Reserved]。（2）设置为false时，当计算节点可分配资源总量时，在原先的基础上还要减去–eviction-hard参数所设置的值。此时，节点可分配资源总量   [Allocatable] = [Node Capacity] - [Kube-Reserved] - [System-Reserved] -   [Hard-Eviction-Threshold]。（&amp;amp;）[Node Capacity] 表示节点的实际资源量；[Kube-Reserved]   表示为Kubernetes系统组件预留的资源量，可通过–kube-reserved参数设置；[System-Reserved]   表示为系统预留的资源量，可通过–system-reserved参数设置。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1329&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1330&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;--cgroup-root&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1331&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;’ ’ , 表示将使用容器运行时的默认值&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1332&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;为pods设置的root cgroup。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1333&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1334&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;--experimental-mounter-path&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1335&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;’ ’，空&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1336&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;（1）设置为空时，表示使用默认的挂载命令。（2）设置为绝对路径时，表示使用指定路径上的挂载命令。同时，其会将--expermental-check-node-capabilities-before-mount参数重置为false，因此，当执行挂载操作时，并不会去检查节点是否具备挂载此种类型数据卷的必要组件，如二进制可执行文件。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1337&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1338&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–experimental-check-node-capabilities-before-mount&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1339&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1340&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;(1) 设置为false时，在执行挂载操作前，不会去检查本节点是否具有挂载某种类型数据卷的必要组件，如二进制可执行文件等等。当挂载操作失败之后，会重新再执行此挂载操作。（2）设置为true时，在执行挂载操作前，会根据要挂载的数据卷类型，确定数据卷插件，并检查本节点具有此数据卷插件的必要的依赖性组件。当检查结果是不具备时，此挂载操作立即失败，对于此挂载操作，不会进行重试。（&amp;amp;）--expermental-mounter-path参数取值，会影响本参数的最终取值。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1341&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1342&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–enable-debugging-handlers&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1343&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1344&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;设置为true表示提供远程访问本节点容器的日志、进入容器执行命令等相关的REST服务。在安全性方面，还需后序调研。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1345&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1346&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–eviction-hard&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1347&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;memory.available&amp;lt;100Mi,nodefs.available&amp;lt;10%,nodes.inodesFree&amp;lt;5%&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1348&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;表示触发Pod Eviction操作的一组硬门限设置。当节点资源达至这个下限时，出于节点稳定性的考虑，kubelet会&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;立刻&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;执行Pod Eviction操作，释放资源，维护节点的稳定性。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1349&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1350&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–feature-gates&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1352&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;（1）ExperimentalCriticalPodAnnotation   默认值为false；设置为true时，表示当CriticalPod被调度器调度到本节点后，如果因为节点资源不足而无法运行时，kubelet会启用重调度机制，按qos等级删除一部分pod，释放资源来使CriticalPod可以在本节点上运行。另外，CriticalPod不会被kubelet的Pod   Eviction机制驱逐出去。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p cid=&quot;n1353&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题一：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1354&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet 容器启动出错。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1355&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1356&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet Pod status，获悉容器相关状态：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1357&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;CrashLoopBackOff：容器退出，kubelet正在将它重启&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1358&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;InvalidImageName：无法解析镜像名称&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1359&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;ImageInspectError：无法校验镜像&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1360&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;ErrImageNeverPull：策略禁止拉取镜像&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1361&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;ImagePullBackOff：正在重试拉取&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1362&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;RegistryUnavailable：连接不到镜像中心&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1363&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;ErrImagePull：通用的拉取镜像出错&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1364&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;CreateContainerConfigError：不能创建kubelet使用的容器配置&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1365&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;CreateContainerError：创建容器失败&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1366&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;m.internalLifecycle.PreStartContainer 执行hook报错&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1367&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;RunContainerError：启动容器失败&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1368&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;PostStartHookError：执行hook报错&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1369&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;ContainersNotInitialized：容器没有初始化完毕&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1370&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;ContainersNotReady：容器没有准备完毕&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1371&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;ContainerCreating：容器创建中&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1372&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;PodInitializing：pod 初始化中&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1373&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;DockerDaemonNotReady：docker还没有完全启动&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1374&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;NetworkPluginNotReady：网络插件还没有完全启动&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1375&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1376&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题二：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1377&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet 故障引起的常见结果。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1378&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1379&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet 故障对应用影响：&lt;/span&gt;&lt;/p&gt;&lt;figure cid=&quot;n1380&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n1381&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span cid=&quot;n1382&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;问题 &lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n1383&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;描述 &lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n1384&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;应用&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n1385&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1386&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet 出故障&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1387&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;无法在该节点启动新的容器组    crashing kubelet cannot start new   pods on the node [不会]&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1388&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;不影响&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1389&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1390&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet 出故障&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1391&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet might delete the pods or not&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1392&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;影响&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1393&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1394&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet 出故障&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1395&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;节点被标记为不健康   node marked unhealthy&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1396&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;不影响&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1397&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1398&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet 出故障&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1399&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;可能导致 RC 在其他节点启动新的容器组（Reschedule）   replication controllers start new pods elsewhere&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1400&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;不一定：  对可扩展的应用来说，没影响；  可能会影响到 无法扩展的一些应用&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p cid=&quot;n1401&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题三：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1402&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;重启kubelet之后，会导致节点上面的一些Pod也发生重启，并且会留下一些状态为&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;MatchNodeSelector&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;的僵尸Pod。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1403&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;原因：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1404&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;正常情况下，如果我们在某一节点上重启了kubelet，那么上面的Pod(容器)是不会重启的。这是kubelet 现存 BUG，但触发需要一定条件。&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n1405&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1407&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;某些Pod是通过NodeSelector的label给调度到某些专有label的节点上的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1409&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;当kubelet重启并且与apiServer的连接非常不稳定时，会有几率出现这些Pod被重启。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n1410&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1411&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;当重要业务节点需要重启 kubelet 时，为保证上面运行的 pod 业务。可以修改 kubelet 配置的 --node-labels 参数&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1412&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;E:\aa\微信公众号文章\容器加固系列\img\4.4.png&quot;/&gt;&lt;/p&gt;&lt;h2 cid=&quot;n1416&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2.6 kube-proxy&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n1417&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kube-proxy，实现 Kubernetes Service 的通信与负载均衡机制的重要组件。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n1418&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1420&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;负责把对 Service 的请求转发到后端的某个 Pod 实例上，自动建立每个 Service 到对应 Pod 的请求转发路由表，从而实现 Service 的负载均衡机制。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1422&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kube-proxy 服务依赖于 network 服务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1424&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;生成 service 相关网络访问规则，支持 iptables 和 ipvs 规则（最新版默认使用这个）创建。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure cid=&quot;n1425&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n1426&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span cid=&quot;n1427&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;组件参数&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n1428&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;默认值&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n1429&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;说明&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n1430&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1431&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–iptables-min-sync-period&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1432&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1433&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;表示iptables规则的最小同步周期。（1）设置为非0时，kube-proxy使用令牌桶算法实现流控控制，避免频繁刷新。例如，当--iptables-min-sync-period=10s,   kube-proxy以每秒0.1个令牌的速度，向令牌桶中放入令牌，桶的容量为2。（2）设置为0时，kube-proxy则不启用流控控制。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1434&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1435&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–iptables-sync-period&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1436&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;30s&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1437&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;表示iptables规则的最大同步周期。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1438&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1439&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;—feature-gates=   ExperimentalCriticalPodAnnotation=true&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1441&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;关于ExperimentalCriticalPodAnnotation=true这个参数，kube-proxy中并没有在使用。如果确实想用CriticalPod，为保险起见，最好还是设置上。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p cid=&quot;n1447&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题一：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1448&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;节点故障时，上面运行的 pod 需要较长时间才恢复正常。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1449&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;原因：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1450&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Kube-proxy 默认 30 秒就刷新一次 iptables 规则。如果主机故障或删除 iptables 规则，那就需要 30 秒后 kube-proxy 才能实现并恢复。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1451&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n1452&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1454&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;按实际调整 iptables 刷新、同步规则时间。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1456&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;pod 设置 readiness 健康检查，探测 pod 异常时可以自动去除前端 service 访问。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1458&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;调整 kubelet 的 --node-monitor-grace-period 参数，减少这个时间让节点从调度中摘除。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1460&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;上层添加硬负载，如 F5；软负载如Haproxy 可在 retries 配置中解决、Nginx在 max_fails 配置中解决。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n1461&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1462&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题二：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1463&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kube-proxy 不工作，导致访问某个节点的 pod 业务，服务异常。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1464&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;原因：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1465&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;iptables 规则没生成或规则没及时同步。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1466&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n1467&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1469&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;删除 kube-proxy 重建。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1471&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Service 需要的 ClusterIP 段可能有冲突，查找内网是否存在与默认10.96.0.0/12网段。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1473&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;大规模，如 service 超过5000个。使用 ipvs 模式替代 iptables。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n1474&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1475&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题三：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1476&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;存在 keepalived 的节点，监控脚本就不停重启keepalived&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1477&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;原因：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1478&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kube-proxy 使用 ipvs 模式，重启会导致 ipvs 的所有规则清除。keepalived节点依靠ipvs来转发， 但是只要restart该节点的kube-proxy， ipvsadm -L -n规则就全没了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1479&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1480&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;调整 kube-proxy 的参数：--cleanup-ipvs=false 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;内容持续更新，请扫码关注我们~&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAxMTM1NDM0Mg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/iaqVSGJoMTQMys1bEia86TW4rQFvBTOUR1eL173MLS9Fz121CziceNCMIVhWUjTBc3tPUOdcib4QByiaaPwiaibicqm6KQ/0?wx_fmt=png&quot; data-nickname=&quot;云计算架构师成长路&quot; data-alias=&quot;vincentjava&quot; data-signature=&quot;分享云计算相关知识。公众号由三人小组组成：主要记录Docker、Kubernetes、OpenStack、SpringCloud、Service Mesh等相关技术的学习历程，水平有限，知识无限，欢迎指正。用心生活，活在当下，珍惜拥有。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>